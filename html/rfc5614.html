<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 5614: Mobile Ad Hoc Network (MANET) Extension of OSPF Using Connected Dominating Set (CDS) Flooding中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC5614 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">打赏</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">5614</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc5614">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 5614: Mobile Ad Hoc Network (MANET) Extension of OSPF Using Connected Dominating Set (CDS) Flooding 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc5614">
              https://datatracker.ietf.org/doc/html/rfc5614
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 5614</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                           R. Ogier
Request for Comments: 5614                             SRI International
Category: Experimental                                       P. Spagnolo
                                                                  Boeing
                                                             August 2009
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                           R. Ogier
Request for Comments: 5614                             SRI International
Category: Experimental                                       P. Spagnolo
                                                                  Boeing
                                                             August 2009
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Mobile Ad Hoc Network (MANET) Extension of OSPF Using Connected Dominating Set (CDS) Flooding
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
基于连通支配集（CDS）泛洪的OSPF移动自组网（MANET）扩展
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an extension of OSPFv3 to support mobile ad hoc networks (MANETs). The extension, called OSPF-MDR, is designed as a new OSPF interface type for MANETs. OSPF-MDR is based on the selection of a subset of MANET routers, consisting of MANET Designated Routers (MDRs) and Backup MDRs. The MDRs form a connected dominating set (CDS), and the MDRs and Backup MDRs together form a biconnected CDS for robustness. This CDS is exploited in two ways. First, to reduce flooding overhead, an optimized flooding procedure is used in which only (Backup) MDRs flood new link state advertisements (LSAs) back out the receiving interface; reliable flooding is ensured by retransmitting LSAs along adjacencies. Second, adjacencies are formed only between (Backup) MDRs and a subset of their neighbors, allowing for much better scaling in dense networks. The CDS is constructed using 2-hop neighbor information provided in a Hello protocol extension. The Hello protocol is further optimized by allowing differential Hellos that report only changes in neighbor states. Options are specified for originating router-LSAs that provide full or partial topology information, allowing overhead to be reduced by advertising less topology information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了OSPFv3的扩展，以支持移动自组网（MANET）。该扩展名为OSPF-MDR，是为移动自组网设计的一种新的OSPF接口类型。OSPF-MDR基于MANET路由器子集的选择，由MANET指定路由器（MDR）和备份MDR组成。MDR形成一个连接的支配集（CDS），MDR和备份MDR一起形成一个双连接的CDS，以实现健壮性。这种CD有两种利用方式。首先，为了减少泛洪开销，使用了一种优化的泛洪过程，其中只有（备份）MDR泛洪新链路状态播发（LSA）使接收接口返回；通过沿相邻点重新传输LSA，确保可靠的泛洪。其次，邻接仅在（备份）MDR与其邻居的子集之间形成，从而在密集网络中实现更好的扩展。CDS是使用Hello协议扩展中提供的2跳邻居信息构建的。Hello协议通过允许只报告相邻状态变化的差异Hello进一步优化。为提供全部或部分拓扑信息的原始路由器LSA指定选项，允许通过公布较少的拓扑信息来减少开销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这份备忘录为互联网社区定义了一个实验性协议。它没有规定任何类型的互联网标准。要求进行讨论并提出改进建议。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（c）2009 IETF信托基金和确定为文件作者的人员。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents in effect on the date of publication of this document (http://trustee.ietf.org/license-info). Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和IETF信托在本文件出版之日生效的与IETF文件有关的法律规定的约束(http://trustee.ietf.org/license-info). 请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件可能包含2008年11月10日之前发布或公开的IETF文件或IETF贡献中的材料。控制某些材料版权的人员可能未授予IETF信托允许在IETF标准流程之外修改此类材料的权利。在未从控制此类材料版权的人员处获得充分许可的情况下，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其衍生作品，除了将其格式化以RFC形式发布或将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................4
      1.1. Terminology ................................................5
   2. Overview ........................................................7
      2.1. Selection of MDRs, BMDRs, Parents, and Adjacencies .........8
      2.2. Flooding Procedure .........................................9
      2.3. Link State Acknowledgments ................................10
      2.4. Routable Neighbors ........................................10
      2.5. Partial and Full Topology LSAs ............................11
      2.6. Hello Protocol ............................................12
   3. Interface and Neighbor Data Structures .........................12
      3.1. Changes to Interface Data Structure .......................12
      3.2. New Configurable Interface Parameters .....................13
      3.3. Changes to Neighbor Data Structure ........................15
   4. Hello Protocol .................................................17
      4.1. Sending Hello Packets .....................................17
      4.2. Receiving Hello Packets ...................................20
      4.3. Neighbor Acceptance Condition .............................24
   5. MDR Selection Algorithm ........................................25
      5.1. Phase 1: Creating the Neighbor Connectivity Matrix ........27
      5.2. Phase 2: MDR Selection ....................................27
      5.3. Phase 3: Backup MDR Selection .............................29
      5.4. Phase 4: Parent Selection .................................29
      5.5. Phase 5: Optional Selection of Non-Flooding MDRs ..........30
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................4
      1.1. Terminology ................................................5
   2. Overview ........................................................7
      2.1. Selection of MDRs, BMDRs, Parents, and Adjacencies .........8
      2.2. Flooding Procedure .........................................9
      2.3. Link State Acknowledgments ................................10
      2.4. Routable Neighbors ........................................10
      2.5. Partial and Full Topology LSAs ............................11
      2.6. Hello Protocol ............................................12
   3. Interface and Neighbor Data Structures .........................12
      3.1. Changes to Interface Data Structure .......................12
      3.2. New Configurable Interface Parameters .....................13
      3.3. Changes to Neighbor Data Structure ........................15
   4. Hello Protocol .................................................17
      4.1. Sending Hello Packets .....................................17
      4.2. Receiving Hello Packets ...................................20
      4.3. Neighbor Acceptance Condition .............................24
   5. MDR Selection Algorithm ........................................25
      5.1. Phase 1: Creating the Neighbor Connectivity Matrix ........27
      5.2. Phase 2: MDR Selection ....................................27
      5.3. Phase 3: Backup MDR Selection .............................29
      5.4. Phase 4: Parent Selection .................................29
      5.5. Phase 5: Optional Selection of Non-Flooding MDRs ..........30
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   6. Interface State Machine ........................................31
      6.1. Interface States ..........................................31
      6.2. Events that Cause Interface State Changes .................31
      6.3. Changes to Interface State Machine ........................32
   7. Adjacency Maintenance ..........................................32
      7.1. Changes to Neighbor State Machine .........................33
      7.2. Whether to Become Adjacent ................................34
      7.3. Whether to Eliminate an Adjacency .........................35
      7.4. Sending Database Description Packets ......................35
      7.5. Receiving Database Description Packets ....................36
   8. Flooding Procedure .............................................37
      8.1. LSA Forwarding Procedure ..................................38
      8.2. Sending Link State Acknowledgments ........................41
      8.3. Retransmitting LSAs .......................................42
      8.4. Receiving Link State Acknowledgments ......................42
   9. Router-LSAs ....................................................43
      9.1. Routable Neighbors ........................................44
      9.2. Backbone Neighbors ........................................45
      9.3. Selected Advertised Neighbors .............................45
      9.4. Originating Router-LSAs ...................................46
   10. Calculating the Routing Table .................................47
   11. Security Considerations .......................................49
   12. IANA Considerations ...........................................50
   13. Acknowledgments ...............................................51
   14. Normative References ..........................................51
   15. Informative References ........................................51
   Appendix A.  Packet Formats .......................................52
      A.1.  Options Field ............................................52
      A.2.  Link-Local Signaling .....................................52
      A.3.  Hello Packet DR and Backup DR Fields .....................57
      A.4.  LSA Formats and Examples .................................57
   Appendix B.  Detailed Algorithms for MDR/BMDR Selection ...........62
      B.1.  Detailed Algorithm for Step 2.4 (MDR Selection) ..........62
      B.2.  Detailed Algorithm for Step 3.2 (BMDR Selection) .........63
   Appendix C.  Min-Cost LSA Algorithm ...............................65
   Appendix D.  Non-Ackable LSAs for Periodic Flooding ...............68
   Appendix E.  Simulation Results ...................................69
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   6. Interface State Machine ........................................31
      6.1. Interface States ..........................................31
      6.2. Events that Cause Interface State Changes .................31
      6.3. Changes to Interface State Machine ........................32
   7. Adjacency Maintenance ..........................................32
      7.1. Changes to Neighbor State Machine .........................33
      7.2. Whether to Become Adjacent ................................34
      7.3. Whether to Eliminate an Adjacency .........................35
      7.4. Sending Database Description Packets ......................35
      7.5. Receiving Database Description Packets ....................36
   8. Flooding Procedure .............................................37
      8.1. LSA Forwarding Procedure ..................................38
      8.2. Sending Link State Acknowledgments ........................41
      8.3. Retransmitting LSAs .......................................42
      8.4. Receiving Link State Acknowledgments ......................42
   9. Router-LSAs ....................................................43
      9.1. Routable Neighbors ........................................44
      9.2. Backbone Neighbors ........................................45
      9.3. Selected Advertised Neighbors .............................45
      9.4. Originating Router-LSAs ...................................46
   10. Calculating the Routing Table .................................47
   11. Security Considerations .......................................49
   12. IANA Considerations ...........................................50
   13. Acknowledgments ...............................................51
   14. Normative References ..........................................51
   15. Informative References ........................................51
   Appendix A.  Packet Formats .......................................52
      A.1.  Options Field ............................................52
      A.2.  Link-Local Signaling .....................................52
      A.3.  Hello Packet DR and Backup DR Fields .....................57
      A.4.  LSA Formats and Examples .................................57
   Appendix B.  Detailed Algorithms for MDR/BMDR Selection ...........62
      B.1.  Detailed Algorithm for Step 2.4 (MDR Selection) ..........62
      B.2.  Detailed Algorithm for Step 3.2 (BMDR Selection) .........63
   Appendix C.  Min-Cost LSA Algorithm ...............................65
   Appendix D.  Non-Ackable LSAs for Periodic Flooding ...............68
   Appendix E.  Simulation Results ...................................69
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an extension of OSPFv3 [RFC5340] to support a new interface type for mobile ad hoc networks (MANETs), i.e., for broadcast-capable, multihop wireless networks in which routers and hosts can be mobile. Note that OSPFv3 is specified by describing the modifications to OSPFv2 [RFC2328]. This MANET extension of OSPFv3 is also applicable to non-mobile mesh networks using layer-3 routing. This extension does not preclude the use of any existing OSPF interface types, and is fully compatible with legacy OSPFv3 implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了OSPFv3[RFC5340]的扩展，以支持移动自组织网络（MANET）的新接口类型，即路由器和主机可以移动的支持广播的多跳无线网络。注意，OSPFv3是通过描述对OSPFv2[RFC2328]的修改来指定的。OSPFv3的MANET扩展也适用于使用第三层路由的非移动网状网络。此扩展不排除使用任何现有的OSPF接口类型，并且与传统的OSPFv3实现完全兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Existing OSPF interface types do not perform adequately in MANETs, due to scaling issues regarding the flooding protocol operation, inability of the Designated Router election protocol to converge in all scenarios, and large numbers of adjacencies when using a point-to-multipoint interface type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现有的OSPF接口类型在MANET中不能充分发挥作用，这是由于泛洪协议操作的可扩展性问题、指定的路由器选择协议无法在所有情况下收敛，以及使用点对多点接口类型时存在大量邻接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The approach taken is to generalize the concept of an OSPF Designated Router (DR) and Backup DR to multihop wireless networks, in order to reduce overhead by reducing the number of routers that must flood new LSAs and reducing the number of adjacencies. The generalized (Backup) Designated Routers are called (Backup) MANET Designated Routers (MDRs). The MDRs form a connected dominating set (CDS), and the MDRs and Backup MDRs together form a biconnected CDS for robustness (if the network itself is biconnected). By definition, each router in the MANET either belongs to the CDS or is one hop away from it. A distributed algorithm is used to select and dynamically maintain the biconnected CDS. Adjacencies are established only between (Backup) MDRs and a subset of their neighbors, thus resulting in a dramatic reduction in the number of adjacencies in dense networks, compared to the approach of forming adjacencies between all neighbor pairs. The OSPF extension is called OSPF-MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所采取的方法是将OSPF指定路由器（DR）和备份DR的概念推广到多跳无线网络，以便通过减少必须大量使用新LSA的路由器数量和减少邻接数量来减少开销。通用（备份）指定路由器称为（备份）MANET指定路由器（MDR）。MDR形成一个连接的支配集（CDS），MDR和备份MDR一起形成一个双连接的CDS，以实现健壮性（如果网络本身是双连接的）。根据定义，MANET中的每个路由器要么属于CDS，要么距离CDS一跳。使用分布式算法来选择和动态维护双连接的CD。邻接仅在（备份）MDR与其邻居的子集之间建立，因此与在所有邻居对之间形成邻接的方法相比，密集网络中的邻接数量显著减少。OSPF扩展名为OSPF-MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello packets are modified, using OSPF link-local signaling (LLS; see [RFC5613]), for two purposes: to provide neighbors with 2-hop neighbor information that is required by the MDR selection algorithm, and to allow differential Hellos that report only changes in neighbor states. Differential Hellos can be sent more frequently without a significant increase in overhead, in order to respond more quickly to topology changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用OSPF链路本地信令（LLS；请参阅[RFC5613]）修改Hello数据包有两个目的：向邻居提供MDR选择算法所需的2跳邻居信息，以及允许只报告邻居状态变化的差异Hello。可以更频繁地发送差异Hello，而不会显著增加开销，以便更快地响应拓扑更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each MANET router advertises a subset of its MANET neighbors as point-to-point links in its router-LSA. The choice of which neighbors to advertise is flexible, allowing overhead to be reduced by advertising less topology information. Options are specified for originating router-LSAs that provide full or partial topology information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个MANET路由器在其路由器LSA中将其MANET邻居的一个子集作为点对点链路播发。选择哪些邻居进行广告是灵活的，允许通过广告较少的拓扑信息来减少开销。为提供完整或部分拓扑信息的原始路由器LSA指定选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is organized as follows. Section 2 presents an overview of OSPF-MDR, Section 3 presents the new interface and neighbor data items that are required for the extension, Section 4 describes the Hello protocol, including procedures for maintaining the 2-hop neighbor information, Section 5 describes the MDR selection algorithm, Section 6 describes changes to the Interface state machine, Section 7 describes the procedures for forming adjacencies and deciding which neighbors should become adjacent, Section 8 describes the flooding procedure, Section 9 specifies the requirements and options for the contents of router-LSAs, and Section 10 describes changes in the calculation of the routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件的组织结构如下。第2节概述了OSPF-MDR，第3节介绍了扩展所需的新接口和邻居数据项，第4节介绍了Hello协议，包括维护2跳邻居信息的过程，第5节介绍了MDR选择算法，第6节描述了对接口状态机的更改，第7节描述了形成邻接和决定哪些邻接应成为邻接的程序，第8节描述了泛洪程序，第9节指定了路由器LSA内容的要求和选项，第10节描述了路由表计算中的变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The appendices specify packet formats, detailed algorithms for the MDR selection algorithm, an algorithm for the selection of a subset of neighbors to advertise in the router-LSA to provide shortest-path routing, a proposed option that uses non-ackable LSAs to provide periodic flooding without the overhead of Link State Acknowledgments, and simulation results that predict the performance of OSPF-MDR in mobile networks with up to 200 nodes. Additional information and resources for OSPF-MDR can be found at http://www.manet-routing.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附录规定了数据包格式、MDR选择算法的详细算法、选择邻居子集以在路由器LSA中公布以提供最短路径路由的算法、使用不可确认LSA提供周期性泛洪而无链路状态确认开销的建议选项，仿真结果预测了OSPF-MDR在多达200个节点的移动网络中的性能。有关OSPF-MDR的更多信息和资源，请访问http://www.manet-routing.org.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 术语
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC2119]中所述进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, this document uses the following terms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，本文件使用以下术语：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET Interface A MANET Interface is a new OSPF interface type that supports broadcast-capable, multihop wireless networks. Two neighboring routers on a MANET interface may not be able to communicate directly with each other. A neighboring router on a MANET interface is called a MANET neighbor. MANET neighbors are discovered dynamically using a modification of OSPF&#39;s Hello protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET接口MANET接口是一种新的OSPF接口类型，支持支持支持广播的多跳无线网络。MANET接口上的两个相邻路由器可能无法直接相互通信。MANET接口上的相邻路由器称为MANET邻居。MANET邻居是通过修改OSPF的Hello协议动态发现的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET Router A MANET Router is an OSPF router that has at least one MANET interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET路由器MANET路由器是至少有一个MANET接口的OSPF路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Differential Hello A Differential Hello is a Hello packet that reduces the overhead of sending full Hellos, by including only the Router IDs of neighbors whose state changed recently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Differential Hello Differential Hello是一个Hello数据包，它只包含最近状态发生变化的邻居的路由器ID，从而减少发送完整Hello的开销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2-Hop Neighbor Information This information specifies the bidirectional neighbors of each neighbor. The modified Hello protocol provides each MANET router with 2-hop neighbor information, which is used for selecting MDRs and Backup MDRs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2-Hop邻居信息该信息指定每个邻居的双向邻居。改进的Hello协议为每个MANET路由器提供了两跳邻居信息，用于选择mdr和备份mdr。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET Designated Router (MDR) A MANET Designated Router is one of a set of routers responsible for flooding new LSAs, and for determining the set of adjacencies that must be formed. The set of MDRs forms a connected dominating set and is a generalization of the DR found in broadcast networks. Each router runs the MDR selection algorithm for each MANET interface, to decide whether the router is an MDR, Backup MDR, or neither for that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移动自组网指定路由器（MDR）移动自组网指定路由器是一组路由器中的一个，负责泛洪新的LSA，并确定必须形成的邻接集。MDR集形成一个连通支配集，是广播网络中DR的推广。每个路由器为每个MANET接口运行MDR选择算法，以确定该路由器是否为该接口的MDR、备份MDR或两者都不是。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Backup MANET Designated Router (Backup MDR or BMDR) A Backup MANET Designated Router is one of a set of routers responsible for providing backup flooding when neighboring MDRs fail. The set of MDRs and Backup MDRs forms a biconnected dominating set. The Backup MDR is a generalization of the Backup DR found in broadcast networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
备份MANET指定路由器（备份MDR或BMDR）备份MANET指定路由器是一组路由器中的一个，负责在相邻MDR发生故障时提供备份泛洪。MDR和备份MDR的集合构成了一个双连通的支配集。备份MDR是广播网络中备份DR的概括。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR Other A router is an MDR Other for a particular MANET interface if it is neither an MDR nor a Backup MDR for that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR Other路由器是特定MANET接口的MDR Other，如果它既不是该接口的MDR，也不是该接口的备份MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parent Each router selects a Parent for each MANET interface. The Parent of a non-MDR router will be a neighboring MDR if one exists. The Parent of an MDR is always the router itself. Each non-MDR router becomes adjacent with its Parent. The Router ID of the Parent is advertised in the DR field of each Hello sent on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
父级每个路由器为每个MANET接口选择一个父级。非MDR路由器的父路由器将是相邻的MDR（如果存在）。MDR的父级始终是路由器本身。每个非MDR路由器与其父路由器相邻。父节点的路由器ID在接口上发送的每个Hello的DR字段中公布。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Backup Parent If the option of biconnected adjacencies is chosen, then each MDR Other selects a Backup Parent, which will be a neighboring MDR or BMDR if one exists that is not the Parent. The Backup Parent of a BMDR is always the router itself. Each MDR Other becomes adjacent with its Backup Parent if it exists. The Router ID of the Backup Parent is advertised in the Backup DR field of each Hello sent on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
备份父级如果选择了“双连接邻接”选项，则每个MDR将选择一个备份父级，如果存在一个不是父级的MDR或BMDR，则该备份父级将是相邻的MDR或BMDR。BMDR的备份父级始终是路由器本身。每个MDR都将与其备份父级（如果存在）相邻。备份父级的路由器ID在接口上发送的每个Hello的Backup DR字段中公布。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bidirectional Neighbor A bidirectional neighbor is a neighboring router whose neighbor state is 2-Way or greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双向邻居双向邻居是邻居状态为双向或更大的邻居路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routable Neighbor A bidirectional MANET neighbor becomes routable if the SPF calculation has produced a route to the neighbor and the neighbor satisfies a quality condition. Once a neighbor becomes routable, it remains routable as long as it remains bidirectional. Only routable and Full neighbors can be used as next hops in the SPF calculation, and can be included in the router-LSA originated by the router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可路由邻居如果SPF计算产生到邻居的路由并且邻居满足质量条件，则双向MANET邻居成为可路由的。一旦邻居成为可路由的，只要它保持双向，它就保持可路由。在SPF计算中，只有可路由的和完整的邻居可以用作下一跳，并且可以包含在路由器发起的路由器LSA中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-Flooding MDR A non-flooding MDR is an MDR that does not automatically flood received LSAs back out the receiving interface, but performs backup flooding like a BMDR. Some MDRs may declare themselves non-flooding in order to reduce flooding overhead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非泛洪MDR非泛洪MDR是一种MDR，它不会自动将接收到的LSA泛洪回接收接口，而是像BMDR一样执行备份泛洪。一些MDR可能会声明自己为非泛洪，以减少泛洪开销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an overview of OSPF-MDR, including motivation and rationale for some of the design choices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节概述了OSPF-MDR，包括一些设计选择的动机和基本原理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR was motivated by the desire to extend OSPF to support MANETs, while keeping the same design philosophy as OSPF and using techniques that are similar to those of OSPF. For example, OSPF reduces overhead in a broadcast network by electing a Designated Router (DR) and Backup DR, and by having two neighboring routers form an adjacency only if one of them is the DR or Backup DR. This idea can be generalized to a multihop wireless network by forming a spanning tree, with the edges of the tree being the adjacencies and the interior (non-leaf) nodes of the tree being the generalized DRs, called MANET Designated Routers (MDRs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR的动机是希望扩展OSPF以支持移动自组网，同时保持与OSPF相同的设计理念，并使用与OSPF类似的技术。例如，OSPF通过选择指定的路由器（DR）和备份DR，并通过让两个相邻的路由器仅在其中一个是DR或备份DR时形成邻接来减少广播网络中的开销。通过形成生成树，可以将这一思想推广到多跳无线网络，树的边缘是邻接，树的内部（非叶）节点是广义DRs，称为MANET指定路由器（MDR）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide better robustness and fast response to topology changes, it was decided that a router should decide whether it is an MDR based only on local information that can be obtained from neighbors&#39; Hellos. The resulting set of adjacencies therefore does not always form a tree globally, but appears to be a tree locally. Similarly, the Backup DR can be generalized to Backup MDRs (BMDRs), to provide robustness through biconnected redundancy. The set of MDRs forms a connected dominating set (CDS), and the set of MDRs and BMDRs forms a biconnected dominating set (if the network itself is biconnected).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了提供更好的健壮性和对拓扑变化的快速响应，决定路由器应仅基于可以从邻居的Hello获得的本地信息来决定它是否是MDR。因此，生成的邻接集并不总是全局形成树，而是局部形成树。类似地，备份灾难恢复可以推广到备份MDR（BMDR），通过双连接冗余提供健壮性。MDR集形成连通支配集（CDS），MDR和BMDR集形成双连通支配集（如果网络本身是双连通的）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections provide an overview of each of the main features of OSPF-MDR, starting with a summary of how MDRs, BMDRs, and adjacencies are selected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下小节概述了OSPF-MDR的每个主要功能，首先概述了MDR、BMDR和邻接的选择方式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Selection of MDRs, BMDRs, Parents, and Adjacencies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. MDR、BMDR、父代和邻接的选择
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MDR selection algorithm is distributed; each router selects itself as an MDR, BMDR, or other router (called an &#34;MDR Other&#34;) based on information about its one-hop neighborhood, which is obtained from Hello packets received from neighbors. Routers are ordered lexicographically based on the tuple (RtrPri, MDR Level, RID), where RtrPri is the Router Priority, MDR Level represents the current state of the router (2 for an MDR, 1 for a BMDR, and 0 for an MDR Other), and RID is the Router ID. Routers with lexicographically larger values of (RtrPri, MDR Level, RID) are given preference for becoming MDRs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR选择算法是分布式的；每个路由器根据从邻居接收的Hello数据包中获取的关于其单跳邻居的信息，选择自己作为MDR、BMDR或其他路由器（称为“MDR other”）。路由器根据元组（RtrPri，MDR Level，RID）按字典顺序排列，其中RtrPri是路由器优先级，MDR Level表示路由器的当前状态（MDR为2，BMDR为1，MDR为0），RID是路由器ID。按字典顺序排列的路由器值（RtrPri，MDR Level，RID）优先考虑成为MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MDR selection algorithm can be summarized as follows. If the router itself has a larger value of (RtrPri, MDR Level, RID) than all of its neighbors, it selects itself as an MDR. Otherwise, let Rmax denote the neighbor with the largest value of (RtrPri, MDR Level, RID). The router then selects itself as an MDR unless each neighbor can be reached from Rmax in at most k hops via neighbors that have a larger value of (RtrPri, MDR Level, RID) than the router itself, where k is the parameter MDRConstraint, whose default value is 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR选择算法可以总结如下。如果路由器本身的值（RtrPri、MDR Level、RID）大于其所有邻居，则它会选择自身作为MDR。否则，让Rmax表示最大值为（RtrPri、MDR级别、RID）的邻居。然后，路由器选择自己作为MDR，除非通过比路由器本身具有更大值（RtrPri、MDR级别、RID）的邻居，从Rmax最多可以以k个跃点到达每个邻居，其中k是参数MDRConstraint，其默认值为3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This parameter serves to control the density of the MDR set, since the MDR set need not be strictly minimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此参数用于控制MDR集的密度，因为MDR集不需要严格最小化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a router that does not select itself as an MDR will select itself as a BMDR unless each neighbor can be reached from Rmax via two node-disjoint paths, using as intermediate hops only neighbors that have a larger value of (RtrPri, MDR Level, RID) than the router itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类似地，不选择自身作为MDR的路由器将选择自身作为BMDR，除非可以通过两个节点不相交的路径从Rmax到达每个邻居，将仅具有比路由器自身更大值（RtrPri、MDR级别、RID）的邻居用作中间跳。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a router selects itself as an MDR, it also decides which MDR neighbors it should become adjacent with, to ensure that the set of MDRs and the adjacencies between them form a connected backbone. Each non-MDR router selects and becomes adjacent with an MDR neighbor called its Parent, thus ensuring that all routers are connected to the MDR backbone.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器选择自己作为MDR时，它还决定应该与哪个MDR邻居相邻，以确保MDR集和它们之间的邻接形成连接的主干。每个非MDR路由器选择一个称为其父路由器的MDR邻居并与其相邻，从而确保所有路由器都连接到MDR主干网。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the option of biconnected adjacencies is chosen (AdjConnectivity = 2), then additional adjacencies are selected to ensure that the set of MDRs and BMDRs, and the adjacencies between them, form a biconnected backbone. In this case, each MDR Other selects and becomes adjacent with an MDR/BMDR neighbor called its Backup Parent, in addition to its Parent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果选择了双连接邻接选项（邻接连接性=2），则选择其他邻接以确保MDR和BMDR的集合以及它们之间的邻接形成双连接主干。在这种情况下，每个MDR彼此选择一个称为其备份父级的MDR/BMDR邻居，并与其相邻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR also provides the option of full-topology adjacencies (AdjConnectivity = 0). If this option is selected, then each router forms an adjacency with each bidirectional neighbor. Although BMDR selection is optional if AdjConnectivity is 0 or 1, it is recommended since BMDRs improve robustness by providing backup flooding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR还提供全拓扑邻接选项（邻接连接=0）。如果选择此选项，则每个路由器与每个双向邻居形成邻接。虽然如果AdjConnectivity为0或1，则BMDR选择是可选的，但建议这样做，因为BMDR通过提供备份泛洪来提高健壮性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prioritizing routers according to (RtrPri, MDR Level, RID) allows neighboring routers to agree on which routers should become an MDR, and gives higher priority to existing MDRs, which increases the lifetime of MDRs and the adjacencies between them. In addition, Parents are selected to be existing adjacent neighbors whenever possible, to avoid forming new adjacencies unless necessary. Once a neighbor becomes adjacent, it remains adjacent as long as the neighbor is bidirectional and either the neighbor or the router itself is an MDR or BMDR (similar to OSPF). The above rules reduce the rate at which new adjacencies are formed, which is important since database exchange must be performed whenever a new adjacency is formed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据（RtrPri、MDR级别、RID）对路由器进行优先级排序允许相邻路由器就哪些路由器应成为MDR达成一致，并为现有MDR提供更高的优先级，从而延长MDR的生存期以及它们之间的邻接。此外，尽可能选择父对象作为现有的相邻邻居，以避免在必要时形成新的邻接。一旦邻居变得相邻，只要邻居是双向的，并且邻居或路由器本身是MDR或BMDR（类似于OSPF），它就会保持相邻。上述规则降低了形成新邻接的速率，这一点很重要，因为每当形成新邻接时都必须执行数据库交换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Flooding Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 注水程序
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an MDR receives a new link state advertisement (LSA) on a MANET interface, it floods the LSA back out the receiving interface unless it can be determined that such flooding is unnecessary (as specified in Section 8.1). The router MAY delay the flooding of the LSA by a small random amount of time (e.g., less than 100 ms). The delayed flooding is useful for coalescing multiple LSAs in the same Link State Update packet, and it can reduce the possibility of a collision in case multiple MDRs received the same LSA at the same time. However, such collisions are usually avoided with wireless MAC protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当MDR在MANET接口上接收到一个新的链路状态公告（LSA）时，除非可以确定这种泛洪是不必要的（如第8.1节所规定），否则它会将LSA泛洪回接收接口。路由器可将LSA的泛洪延迟小的随机时间量（例如，小于100ms）。延迟泛洪有助于在同一链路状态更新包中合并多个LSA，并且在多个MDR同时接收相同LSA的情况下，它可以减少冲突的可能性。然而，使用无线MAC协议通常可以避免此类冲突。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a Backup MDR receives a new LSA on a MANET interface, it waits a short interval (BackupWaitInterval), and then floods the LSA only if it has a neighbor that did not flood or acknowledge the LSA and is not known to be a neighbor of another neighbor (of the Backup MDR) that flooded the LSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当备份MDR在MANET接口上接收到新的LSA时，它会等待一段短的时间间隔（BackupWaitInterval），然后仅当其有一个邻居没有泛洪或确认LSA，并且不知道是另一个邻居（备份MDR的）的邻居（泛洪LSA）时，才会泛洪LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR Other routers never flood LSAs back out the receiving interface. To exploit the broadcast nature of MANETs, a new LSA is processed (and possibly forwarded) if it is received from any neighbor in state 2-Way or greater. The flooding procedure also avoids redundant forwarding of LSAs when multiple interfaces exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR其他路由器从不将LSA洪泛回接收接口。为了利用移动自组网的广播特性，如果从任何处于双向或更高状态的邻居接收到新的LSA，则会对其进行处理（并可能转发）。当存在多个接口时，泛洪过程还避免了LSA的冗余转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. Link State Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. 链路状态确认
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All Link State Acknowledgment packets are multicast. An LSA is acknowledged if it is a new LSA, or if it is a duplicate LSA received as a unicast. (A duplicate LSA received as multicast is not acknowledged.) An LSA that is flooded back out the same interface is treated as an implicit acknowledgment. Link State Acknowledgments may be delayed to allow coalescing multiple acknowledgments in the same packet. The only exception is that (Backup) MDRs send a multicast Link State Acknowledgment immediately when a duplicate LSA is received as a unicast, in order to prevent additional retransmissions. Only Link State Acknowledgments from adjacent neighbors are processed, and retransmitted LSAs are sent (via unicast) only to adjacent neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有链路状态确认数据包都是多播的。如果LSA是新的LSA，或者它是作为单播接收的重复LSA，则会确认LSA。（作为多播接收的重复LSA未被确认。）从同一接口被泛回的LSA被视为隐式确认。链路状态确认可以延迟，以允许在同一数据包中合并多个确认。唯一的例外是，（备份）MDR在收到重复LSA作为单播时立即发送多播链路状态确认，以防止额外的重新传输。仅处理来自相邻邻居的链路状态确认，并且仅向相邻邻居发送重新传输的LSA（通过单播）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Routable Neighbors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. 可路由邻居
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In OSPF, a neighbor must typically be fully adjacent (in state Full) for it to be used in the SPF calculation. An exception exists for an OSPF broadcast network, to avoid requiring all pairs of routers in such a network to form adjacencies, which would generate a large amount of overhead. In such a network, a router can use a non-adjacent neighbor as a next hop as long as both routers are fully adjacent with the Designated Router. We define this neighbor relationship as a &#34;routable neighbor&#34; and extend its usage to the MANET interface type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在OSPF中，邻居通常必须完全相邻（处于完全状态），才能在SPF计算中使用。OSPF广播网络存在例外情况，以避免要求此类网络中的所有路由器对形成邻接，这将产生大量开销。在这样的网络中，只要两个路由器与指定的路由器完全相邻，路由器就可以使用非相邻的邻居作为下一跳。我们将这种邻居关系定义为“可路由邻居”，并将其用法扩展到MANET接口类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A MANET neighbor becomes routable if it is bidirectional and the SPF calculation has produced a route to the neighbor. (A flexible quality condition may also be required.) Only routable and Full neighbors can be used as next hops in the SPF calculation, and can be included in the router-LSA originated by the router. The idea is that if the SPF calculation has produced a route to the neighbor, then it makes sense to take a &#34;shortcut&#34; and forward packets directly to the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果MANET邻居是双向的，并且SPF计算产生了到该邻居的路由，则MANET邻居成为可路由的。（可能还需要灵活的质量条件。）在SPF计算中，只有可路由的和完整的邻居可以用作下一个跃点，并且可以包括在路由器发起的路由器LSA中。其思想是，如果SPF计算产生了到邻居的路由，那么采取“快捷方式”并将数据包直接转发给邻居是有意义的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The routability condition is a generalization of the way that neighbors on broadcast networks are treated in the SPF calculation. The network-LSA of an OSPF broadcast network implies that a router can use a non-adjacent neighbor as a next hop. But a network-LSA cannot describe the general topology of a MANET, making it necessary to explicitly include non-adjacent neighbors in the router-LSA. Allowing only adjacent neighbors in LSAs would either result in suboptimal routes or require a large number of adjacencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可路由性条件是在SPF计算中处理广播网络上邻居的方法的推广。OSPF广播网络的网络LSA意味着路由器可以使用非相邻邻居作为下一跳。但是网络LSA不能描述MANET的一般拓扑结构，因此有必要在路由器LSA中显式地包含非相邻邻居。在LSA中只允许相邻的邻居将导致次优路由或需要大量的邻接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. Partial and Full Topology LSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.5. 局部和全拓扑LSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR allows routers to originate both full-topology LSAs, which advertise links to all routable and Full neighbors, and partial-topology LSAs, which advertise only a subset of such links. In a dense network, partial-topology LSAs are typically much smaller than full-topology LSAs, thus achieving better scalability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR允许路由器同时发起全拓扑LSA（向所有可路由和全邻居公布链接）和部分拓扑LSA（仅公布此类链接的子集）。在密集网络中，部分拓扑LSA通常比完整拓扑LSA小得多，从而实现更好的可扩展性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each router advertises a subset of its neighbors as point-to-point links in its router-LSA. The choice of which neighbors to advertise is flexible. As a minimum requirement, each router must advertise a minimum set of &#34;backbone&#34; neighbors in its router-LSA. An LSA that includes only this minimum set of neighbors is called a minimal LSA and corresponds to LSAFullness = 0. This choice results in the minimum amount of LSA flooding overhead, but does not ensure routing along shortest paths. However, it is useful for achieving scalability to networks with a large number of nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个路由器在其路由器LSA中将其邻居的子集作为点对点链路播发。选择哪一个邻居做广告是灵活的。作为最低要求，每个路由器必须在其路由器LSA中公布一组最小的“主干”邻居。仅包含此最小邻域集的LSA称为最小LSA，对应于LSAFullness=0。这种选择导致LSA泛洪开销最小，但不能确保沿最短路径进行路由。但是，它有助于实现对具有大量节点的网络的可伸缩性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the other extreme, if LSAFullness = 4, then the router originates a full-topology LSA, which includes all routable and Full neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在另一个极端，如果LSAFullness=4，则路由器生成一个完整拓扑LSA，其中包括所有可路由和完整邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Setting LSAFullness to 1 results in min-cost LSAs, which provide routing along shortest (minimum-cost) paths. Each router decides which neighbors to include in its router-LSA based on 2-hop neighbor information obtained from its neighbors&#39; Hellos. Each router includes in its LSA the minimum set of neighbors necessary to provide a shortest path between each pair of its neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将LSAFullness设置为1将产生最小成本lsa，它提供沿最短（最小成本）路径的路由。每个路由器根据从其邻居的hello获得的2跳邻居信息来决定将哪些邻居包括在其路由器LSA中。每个路由器在其LSA中包含提供其每对邻居之间的最短路径所需的最小邻居集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Setting LSAFullness to 2 also provides shortest-path routing, but allows the router to advertise additional neighbors to provide redundant routes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将LSAFullness设置为2也可以提供最短路径路由，但允许路由器公布其他邻居以提供冗余路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Setting LSAFullness to 3 results in MDR full LSAs, causing each MDR to originate a full-topology LSA while other routers originate minimal LSAs. This choice does not provide routing along shortest paths, but simulations have shown that it provides routing along nearly shortest paths with relatively low overhead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将LSAFullness设置为3将导致MDR完全LSA，从而导致每个MDR发起一个完整拓扑LSA，而其他路由器发起最小LSA。这种选择不提供沿最短路径的路由，但仿真表明，它以相对较低的开销提供沿几乎最短路径的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above LSA options are interoperable with each other, because they all require the router-LSA to include a minimum set of neighbors, and because the construction of the router-LSA (described in Section 9.4) ensures that the router-LSAs originated by different routers are consistent. Routing along shortest paths is provided if and only if every router selects LSAFullness to be 1, 2, or 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述LSA选项彼此可互操作，因为它们都要求路由器LSA包含一组最小的邻居，并且因为路由器LSA的构造（如第9.4节所述）确保不同路由器产生的路由器LSA是一致的。当且仅当每个路由器选择LSAFullness为1、2或4时，才提供沿最短路径的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. Hello Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.6. 你好协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR uses the same Hello format as OSPFv3, but appends additional information to Hello packets using link-local signaling (LLS), in order to indicate the set of bidirectional neighbors and other information that is used by the MDR selection algorithm and the min-cost LSA algorithm. In addition to full Hellos, which include the same set of neighbor IDs as OSPFv3 Hellos, OSPF-MDR allows the use of differential Hellos, which include only the IDs of neighbors whose state (or other information) has recently changed (within the last HelloRepeatCount Hellos).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR使用与OSPFv3相同的Hello格式，但使用链路本地信令（LLS）向Hello数据包附加附加信息，以指示MDR选择算法和最小成本LSA算法使用的双向邻居集和其他信息。除了完整hello（包括与OSPFv3 hello相同的邻居ID集）外，OSPF-MDR还允许使用差异hello，其中仅包括状态（或其他信息）最近发生变化（在上一次HelloRepeatCount hello内）的邻居的ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hellos are sent every HelloInterval seconds. Full Hellos are sent every 2HopRefresh Hellos, and differential Hellos are sent at all other times. For example, if 2HopRefresh is equal to 3, then every third Hello is a full Hello. The default value of 2HopRefresh is 1; i.e., the default is to send only full Hellos. The default value for HelloInterval is 2 seconds. Differential Hellos are used to reduce overhead and to allow Hellos to be sent more frequently, for faster reaction to topology changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每隔几秒钟发送一次问候。每2小时发送一次完整问候语刷新问候语，其他时间发送一次差异问候语。例如，如果2hopfresh等于3，则每三个Hello都是完整的Hello。2hopfresh的默认值为1；i、 默认情况下，只发送完整的hello。HelloInterval的默认值为2秒。差分hello用于减少开销，并允许更频繁地发送hello，以便对拓扑更改做出更快的反应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Interface and Neighbor Data Structures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 接口和邻居数据结构
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Changes to Interface Data Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 对接口数据结构的更改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following modified or new data items are required for the Interface Data Structure of a MANET interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET接口的接口数据结构需要以下修改或新的数据项：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type A router that implements this extension can have one or more interfaces of type MANET, in addition to the OSPF interface types defined in [RFC2328].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了[RFC2328]中定义的OSPF接口类型外，实现此扩展的类型A路由器可以具有一个或多个MANET类型的接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
State The possible states for a MANET interface are the same as for a broadcast interface. However, the DR and Backup states now imply that the router is an MDR or Backup MDR, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET接口的可能状态与广播接口的可能状态相同。但是，DR和Backup状态现在分别表示路由器是MDR或Backup MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR Level The MDR Level is equal to MDR (value 2) if the router is an MDR, Backup MDR (value 1) if the router is a Backup MDR, and MDR Other (value 0) otherwise. The MDR Level is used by the MDR selection algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR级别如果路由器是MDR，MDR级别等于MDR（值2），如果路由器是备份MDR，则等于备份MDR（值1），否则等于MDR Other（值0）。MDR级别由MDR选择算法使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parent The Parent replaces the Designated Router (DR) data item of OSPF. Each router selects a Parent as described in Section 5.4. The Parent of an MDR is the router itself, and the Parent of a non-MDR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
父级替换OSPF的指定路由器（DR）数据项。每个路由器按照第5.4节所述选择一个父路由器。MDR的父级是路由器本身，也是非MDR的父级
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
router will be a neighboring MDR, if one exists. The Parent is initialized to 0.0.0.0, indicating the lack of a Parent. Each router advertises the Router ID of its Parent in the DR field of each Hello sent on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器将是相邻的MDR（如果存在）。父项初始化为0.0.0.0，表示缺少父项。每个路由器在接口上发送的每个Hello的DR字段中公布其父路由器ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Backup Parent The Backup Parent replaces the Backup Designated Router data item of OSPF. The Backup Parent of a BMDR is the router itself. If the option of biconnected adjacencies is chosen, then each MDR Other selects a Backup Parent, which will be a neighboring MDR/BMDR if one exists that is not the Parent. The Backup Parent is initialized to 0.0.0.0, indicating the lack of a Backup Parent. Each router advertises the Router ID of its Backup Parent in the Backup DR field of each Hello sent on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
备份父项备份父项替换OSPF的备份指定路由器数据项。BMDR的备份父级是路由器本身。如果选择了双连接邻接选项，则每个MDR彼此选择一个备份父级，如果存在一个不是父级的MDR/BMDR，则该备份父级将是相邻的MDR/BMDR。备份父级初始化为0.0.0.0，表示缺少备份父级。每个路由器在接口上发送的每个Hello的Backup DR字段中公布其备份父级的路由器ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Router Priority An 8-bit unsigned integer. A router with a larger Router Priority is more likely to be selected as an MDR. The Router Priority for a MANET interface can be changed dynamically based on any criteria, including bandwidth capacity, willingness to be a relay (which can depend on battery life, for example), number of neighbors (degree), and neighbor stability. A router that has been a (Backup) MDR for a certain amount of time can reduce its Router Priority so that the burden of being a (Backup) MDR can be shared among all routers. If the Router Priority for a MANET interface is changed, then the interface variable MDRNeighborChange must be set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器优先级为8位无符号整数。具有较大路由器优先级的路由器更有可能被选为MDR。MANET接口的路由器优先级可以根据任何标准动态更改，包括带宽容量、成为中继的意愿（例如，这可能取决于电池寿命）、邻居数（度）和邻居稳定性。作为（备份）MDR存在一定时间的路由器可以降低其路由器优先级，以便在所有路由器之间分担作为（备份）MDR的负担。如果更改了MANET接口的路由器优先级，则必须设置接口变量MDRNeighborChange。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello Sequence Number (HSN) The 16-bit sequence number carried by the MDR-Hello TLV. The HSN is incremented by 1 (modulo 2^16) every time a Hello packet is sent on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello序列号（HSN）MDR Hello TLV携带的16位序列号。每次在接口上发送Hello数据包时，HSN将增加1（模2^16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDRNeighborChange A single-bit variable set to 1 if a neighbor change has occurred that requires the MDR selection algorithm to be executed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDRNEIGHBOR如果发生需要执行MDR选择算法的邻居更改，则将单位变量设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. New Configurable Interface Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 新的可配置接口参数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following new configurable interface parameters are required for a MANET interface. The default values for HelloInterval, RouterDeadInterval, and RxmtInterval for a MANET interface are 2, 6, and 7 seconds, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET接口需要以下新的可配置接口参数。MANET接口的HelloInterval、routerheadinterval和RxmtInterval的默认值分别为2、6和7秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default configuration for OSPF-MDR uses uniconnected adjacencies (AdjConnectivity = 1) and partial-topology LSAs that provide shortest-path routing (LSAFullness = 1). This is the most scalable configuration that provides shortest-path routing. Other
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR的默认配置使用提供最短路径路由（LSAFullness=1）的单连接邻接（AdjConnectivity=1）和部分拓扑LSA。这是提供最短路径路由的最具可扩展性的配置。另外
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
configurations may be preferable in special circumstances. For example, setting LSAFullness to 4 provides full-topology LSAs, and setting LSAFullness to 0 provides minimal LSAs that minimize overhead but do not ensure shortest-path routing. Setting AdjConnectivity to 2 may improve robustness by providing a biconnected adjacency subgraph, and setting AdjConnectivity to 0 results in full-topology adjacencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在特殊情况下，配置可能更可取。例如，将LSAFullness设置为4可提供完整的拓扑lsa，将LSAFullness设置为0可提供最小化开销但不确保最短路径路由的最小lsa。将AdjConnectivity设置为2可以通过提供双连接的邻接子图来提高健壮性，将AdjConnectivity设置为0会产生完整的拓扑邻接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All possible configurations of the new interface parameters are functional, except that if AdjConnectivity is 0 (full-topology adjacencies), then LSAFullness must be 1, 2, or 4 (see Section 9.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新接口参数的所有可能配置都是功能性的，但如果邻接连接为0（完整拓扑邻接），则LSAFullness必须为1、2或4（参见第9.3节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Differential Hellos should be used to reduce the size of Hello packets when the average number of neighbors is large (e.g., greater than 50). Differential Hellos are obtained by setting the parameter 2HopRefresh to an integer greater than 1, with the recommended value being 3. Good performance in simulated mobile networks with up to 160 nodes has been obtained using the default configuration with differential Hellos. Good performance in simulated mobile networks with up to 200 nodes has been obtained using the same configuration except with minimal LSAs (LSAFullness = 0). Simulation results are presented in Appendix E.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当平均邻居数较大（例如，大于50）时，应使用差分Hello来减小Hello数据包的大小。通过将参数2HopRefresh设置为大于1的整数（建议值为3），可以获得差分Hello。使用具有差分Hellos的默认配置，在多达160个节点的模拟移动网络中获得了良好的性能。除了最小LSA（LSAFullness=0）外，使用相同的配置，在多达200个节点的模拟移动网络中获得了良好的性能。模拟结果见附录E。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although all routers should preferably choose the same values for the new configurable interface parameters, this is not required. OSPF-MDR was carefully designed so that correct interoperation is achieved even if each router sets these parameters independently of the other routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管所有路由器最好为新的可配置接口参数选择相同的值，但这不是必需的。OSPF-MDR经过精心设计，即使每个路由器独立于其他路由器设置这些参数，也能实现正确的互操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AdjConnectivity If equal to the default value of 1, then the set of adjacencies forms a (uni)connected graph. If equal to the optional value of 2, then the set of adjacencies forms a biconnected graph. If AdjConnectivity is 0, then adjacency reduction is not used; i.e., the router becomes adjacent with all of its neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻接连通性如果等于默认值1，则邻接集将形成一个（uni）连通图。如果等于可选值2，则邻接集形成双连通图。如果邻接连接性为0，则不使用邻接减少；i、 例如，路由器与其所有邻居相邻。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDRConstraint A parameter of the MDR selection algorithm, which affects the number of MDRs selected and must be an integer greater than or equal to 2. The default value of 3 results in nearly the minimum number of MDRs. Values larger than 3 result in slightly fewer MDRs, and the value 2 results in a larger number of MDRs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR约束MDR选择算法的参数，该参数影响所选MDR的数量，并且必须是大于或等于2的整数。默认值3将导致MDR的数量几乎达到最小值。大于3的值会导致MDR稍微减少，而值2会导致MDR数量增加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BackupWaitInterval The number of seconds that a Backup MDR must wait after receiving a new LSA before it decides whether to flood the LSA. The default value is 0.5 second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BackupWaitInterval备份MDR在接收到新LSA后，在决定是否使用LSA之前必须等待的秒数。默认值为0.5秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AckInterval The interval between Link State Acknowledgment packets when only delayed acknowledgments need to be sent. AckInterval MUST be less than RxmtInterval, and SHOULD NOT be larger than 1 second. The default value is 1 second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
确认间隔当只需要发送延迟确认时，链路状态确认数据包之间的间隔。确认间隔必须小于RxmtInterval，且不应大于1秒。默认值为1秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LSAFullness Determines which neighbors a router should advertise in its router-LSA. The value 0 results in minimal LSAs that include only &#34;backbone&#34; neighbors. The values 1 and 2 result in partial-topology LSAs that provide shortest-path routing, with the value 2 providing redundant routes. The value 3 results in MDRs originating full-topology LSAs and other routers originating minimal LSAs. The value 4 results in all routers originating full-topology LSAs. The default value is 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LSAFullness决定路由器应该在其路由器LSA中通告哪些邻居。值0将生成仅包含“主干”邻居的最小LSA。值1和2产生提供最短路径路由的局部拓扑LSA，值2提供冗余路由。值3导致MDR生成完整拓扑LSA，而其他路由器生成最小LSA。值4导致所有路由器发起完整拓扑LSA。默认值为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2HopRefresh One out of every 2HopRefresh Hellos sent on the interface must be a full Hello. All other Hellos are differential. The default value is 1; i.e., the default is to send only full Hellos. If differential Hellos are used, the recommended value of 2HopRefresh is 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2hopfresh在接口上发送的每2hopfresh Hello中必须有一个是完整的Hello。所有其他的问候都是不同的。默认值为1；i、 默认情况下，只发送完整的hello。如果使用差分Hello，建议的2HopRefresh值为3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HelloRepeatCount The number of consecutive Hellos in which a neighbor must be included when its state changes, if differential Hellos are used. This parameter must be set to 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello重复计数如果使用差分Hello，则当邻居的状态更改时，必须将其包括在其中的连续Hello数。此参数必须设置为3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Changes to Neighbor Data Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 对邻居数据结构的更改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The neighbor states are the same as for OSPF. However, the data for a MANET neighbor that has transitioned to the Down state must be maintained for at least HelloInterval * HelloRepeatCount seconds, to allow the state change to be reported in differential Hellos. The following new data items are required for the Neighbor Data Structure of a neighbor on a MANET interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相邻状态与OSPF相同。但是，已转换为关闭状态的MANET邻居的数据必须至少保持HelloInterval*hellorepeaccount秒，以允许在差异Hellos中报告状态更改。MANET接口上邻居的邻居数据结构需要以下新数据项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor Hello Sequence Number (NHSN) The Hello sequence number contained in the last Hello received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居Hello序列号（NHSN）从邻居处接收的上一次Hello中包含的Hello序列号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A-bit The A-bit copied from the MDR-Hello TLV of the last Hello received from the neighbor. This bit is 1 if the neighbor is using full-topology adjacencies, i.e., is not using adjacency reduction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A位从MDR Hello TLV复制的来自邻居的最后一个Hello的A位。如果邻居使用完全拓扑邻接，即未使用邻接减少，则该位为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FullHelloRcvd A single-bit variable equal to 1 if a full Hello has been received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FullHelloRcvd如果从邻居接收到完整Hello，则为等于1的单位变量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor&#39;s MDR Level The MDR Level of the neighbor, based on the DR and Backup DR fields of the last Hello packet received from the neighbor or from the MDR-DD TLV in a Database Description (DD) packet received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居的MDR级别基于从邻居接收的最后一个Hello数据包或从邻居接收的数据库描述（DD）数据包中的MDR-DD TLV接收的最后一个Hello数据包的DR和Backup DR字段，邻居的MDR级别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor&#39;s Parent The neighbor&#39;s choice for Parent, obtained from the DR field of the last Hello packet received from the neighbor or from the MDR-DD TLV in a DD packet received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居的父级-邻居对父级的选择，从从邻居接收的最后一个Hello数据包的DR字段或从邻居接收的DD数据包中的MDR-DD TLV获取。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor&#39;s Backup Parent The neighbor&#39;s choice for Backup Parent, obtained from the Backup DR field of the last Hello packet received from the neighbor or from the MDR-DD TLV in a DD packet received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居的备份父项邻居对备份父项的选择，从从邻居收到的最后一个Hello数据包的备份DR字段或从邻居收到的DD数据包中的MDR-DD TLV获取。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Child A single-bit variable equal to 1 if the neighbor is a child, i.e., if the neighbor has selected the router as a (Backup) Parent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Child如果邻居是子节点，即如果邻居选择路由器作为（备份）父节点，则等于1的单位变量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dependent Neighbor A single-bit variable equal to 1 if the neighbor is a Dependent Neighbor, which is decided by the MDR selection algorithm. Each MDR/BMDR router becomes adjacent with its Dependent Neighbors (which are also MDR/BMDR routers) to form a connected backbone. The set of all Dependent Neighbors on a MANET interface is called the Dependent Neighbor Set (DNS) for the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从属邻居如果邻居是从属邻居，则单个位变量等于1，这由MDR选择算法决定。每个MDR/BMDR路由器与其依赖的邻居（也是MDR/BMDR路由器）相邻，以形成连接的主干网。MANET接口上所有依赖邻居的集合称为该接口的依赖邻居集合（DNS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dependent Selector A single-bit variable equal to 1 if the neighbor has selected the router to be dependent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相依选择器如果邻居选择路由器相依，则等于1的一位变量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Selected Advertised Neighbor (SAN) A single-bit variable equal to 1 if the neighbor is a Selected Advertised Neighbor. Selected Advertised Neighbors are neighbors that the router has selected to be included in the router-LSA, along with other neighbors that are required to be included. The set of all Selected Advertised Neighbors on a MANET interface is called the Selected Advertised Neighbor Set (SANS) for the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所选播发邻居（SAN）如果邻居是所选播发邻居，则为等于1的单位变量。选定的播发邻居是路由器已选择包含在路由器LSA中的邻居，以及需要包含的其他邻居。MANET接口上所有选定的播发邻居集称为该接口的选定播发邻居集（SAN）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routable A single-bit variable equal to 1 if the neighbor is routable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可路由如果邻居可路由，则等于1的一位变量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor&#39;s Bidirectional Neighbor Set (BNS) The neighbor&#39;s set of bidirectional neighbors, which is updated when a Hello is received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居的双向邻居集（BNS）邻居的双向邻居集，在收到邻居的问候时更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor&#39;s Dependent Neighbor Set (DNS) The neighbor&#39;s set of Dependent Neighbors, which is updated when a Hello is received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居的从属邻居集（DNS）邻居的从属邻居集，在收到邻居的问候时更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor&#39;s Selected Advertised Neighbor Set (SANS) The neighbor&#39;s set of Selected Advertised Neighbors, which is updated when a Hello is received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居的选定播发邻居集（SAN）邻居的选定播发邻居集，在收到邻居的问候时更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Neighbor&#39;s Link Metrics The link metric for each of the neighbor&#39;s bidirectional neighbors, obtained from the Metric TLV appended to Hello packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居的链路度量每个邻居的双向邻居的链路度量，从附加到Hello数据包的度量TLV获得。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Hello Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 你好协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MANET interface utilizes Hellos for neighbor discovery and for enabling neighbors to learn 2-hop neighbor information. The protocol is flexible because it allows the use of full or differential Hellos. Full Hellos list all neighbors on the interface that are in state Init or greater, as in OSPFv3, whereas differential Hellos list only neighbors whose status as a bidirectional neighbor, Dependent Neighbor, or Selected Advertised Neighbor has recently changed. Differential Hellos are used to reduce overhead, and they allow Hellos to be sent more frequently (for faster reaction to topology changes). If differential Hellos are used, full Hellos are sent less frequently to ensure that all neighbors have current 2-hop neighbor information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET接口利用Hellos进行邻居发现，并使邻居能够学习2跳邻居信息。该协议是灵活的，因为它允许使用完全或差异Hello。完整Hellos列出接口上处于Init或更高状态的所有邻居，如在OSPFv3中，而差分Hellos只列出其作为双向邻居、从属邻居或选定播发邻居的状态最近已更改的邻居。差分Hello用于减少开销，并且允许更频繁地发送Hello（以便对拓扑更改做出更快的反应）。如果使用差分hello，则发送完整hello的频率会降低，以确保所有邻居都具有当前的2跳邻居信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Sending Hello Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 发送问候包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello packets are sent according to [RFC5340], Section 4.2.1.1, and [RFC2328], Section 9.5, with the following MANET-specific specifications beginning after paragraph 3 of Section 9.5. The Hello packet format is defined in [RFC5340], Section A.3.2, except for the ordering of the Neighbor IDs and the meaning of the DR and Backup DR fields as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello数据包根据[RFC5340]第4.2.1.1节和[RFC2328]第9.5节发送，以下MANET特定规范从第9.5节第3段开始。Hello数据包格式在[RFC5340]第A.3.2节中定义，但邻居ID的顺序以及DR和Backup DR字段的含义除外，如下所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similar to [RFC2328], the DR and Backup DR fields indicate whether the router is an MDR or Backup MDR. If the router is an MDR, then the DR field is the router&#39;s own Router ID, and if the router is a Backup MDR, then the Backup DR field is the router&#39;s own Router ID. These fields are also used to advertise the router&#39;s Parent and Backup Parent, as specified in Section A.3 and Section 5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与[RFC2328]类似，DR和Backup DR字段指示路由器是MDR还是备份MDR。如果路由器是MDR，则DR字段是路由器自己的路由器ID；如果路由器是备份MDR，则备份DR字段是路由器自己的路由器ID。这些字段还用于公布路由器的父级和备份父级，如第a.3节和第5.4节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hellos are sent every HelloInterval seconds. Full Hellos are sent every 2HopRefresh Hellos, and differential Hellos are sent at all other times. For example, if 2HopRefresh is equal to 3, then every third Hello is a full Hello. If 2HopRefresh is set to 1, then all Hellos are full (the default).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每隔几秒钟发送一次问候。每2小时发送一次完整问候语刷新问候语，其他时间发送一次差异问候语。例如，如果2hopfresh等于3，则每三个Hello都是完整的Hello。如果2hopfresh设置为1，则所有hello都已满（默认值）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The neighbor IDs included in the body of each Hello are divided into the following five disjoint lists of neighbors (some of which may be empty), and must appear in the following order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个Hello正文中包含的邻居ID分为以下五个不相交的邻居列表（其中一些可能为空），并且必须按以下顺序显示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 1. Neighbors whose state recently changed to Down (included only in differential Hellos).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
清单1。最近状态变为“关闭”的邻居（仅包括在“差分问候”中）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 2. Neighbors in state Init.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
清单2。处于状态Init的邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 3. Dependent Neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
清单3。依赖邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 4. Selected Advertised Neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
清单4。选定的广告邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 5. Unselected bidirectional neighbors, defined as bidirectional neighbors that are neither Dependent nor Selected Advertised Neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
清单5。未选择的双向邻居，定义为既不依赖也不选择播发邻居的双向邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that all neighbors in Lists 3 through 5 are bidirectional neighbors. These lists are used to update the neighbor&#39;s Bidirectional Neighbor Set (BNS), Dependent Neighbor Set (DNS), and Selected Advertised Neighbor Set (SANS) when a Hello is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，列表3到5中的所有邻居都是双向邻居。这些列表用于在收到Hello时更新邻居的双向邻居集（BNS）、从属邻居集（DNS）和选定的播发邻居集（SAN）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the above five lists are disjoint, so each neighbor can appear in at most one list. Also note that some or all of the five lists can be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，以上五个列表是不相交的，因此每个邻居最多只能出现在一个列表中。还请注意，五个列表中的部分或全部可以为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Link-local signaling (LLS) is used to append up to two TLVs to each MANET Hello packet. The format for LLS is given in Section A.2. The MDR-Hello TLV is appended to each (full or differential) MANET Hello packet. It indicates whether the Hello is full or differential, and gives the Hello Sequence Number (HSN) and the number of neighbor IDs in each of Lists 1 through 4 defined above. The size of List 5 is then implied by the packet length field of the Hello. The format of the MDR-Hello TLV is given in Section A.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
链路本地信令（LLS）用于向每个MANET Hello数据包附加多达两个TLV。LLS的格式见第A.2节。MDR Hello TLV附加到每个（完整或差异）MANET Hello数据包。它指示Hello是完整的还是差分的，并给出上面定义的列表1到4中的Hello序列号（HSN）和邻居id的数量。列表5的大小随后由Hello的packetlength字段表示。MDR Hello TLV的格式见第A.2.3节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In both full and differential Hellos, the appended MDR-Hello TLV is built as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在完整Hello和差分Hello中，附加的MDR Hello TLV构建如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Sequence Number field is set to the current HSN for the interface; the HSN is then incremented (modulo 2^16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 序列号字段设置为接口的当前HSN；HSN随后递增（模2^16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The D-bit of the MDR-Hello TLV is set to 1 for a differential Hello and 0 for a full Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MDR Hello TLV的D位设置为1表示差分Hello，0表示完全Hello。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The A-bit of the MDR-Hello TLV is set to 1 if AdjConnectivity is 0 (the router is using full-topology adjacencies); otherwise, it is set to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果AdjConnectivity为0（路由器使用完全拓扑邻接），则MDR Hello TLV的A位设置为1；否则，它将设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The N1, N2, N3, and N4 fields are set to the number of neighbor IDs in the body of the Hello that are in List 1, List 2, List 3, and List 4, respectively. (N1 is always zero in a full Hello.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N1、N2、N3和N4字段分别设置为Hello正文中列表1、列表2、列表3和列表4中的邻居ID数。（完整问候中N1始终为零。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MDR-Metric TLV (or Metric TLV) advertises the link cost to each bidirectional neighbor on the interface, to allow the selection of neighbors to include in partial-topology LSAs. If LSAFullness is 1 or 2, a Metric TLV must be appended to each MANET Hello packet unless all link costs are 1. The format of the Metric TLV is given in Section A.2.5. The I bit of the Metric TLV can be set to 0 or 1. If the I bit is set to 0, then the Metric TLV does not contain neighbor IDs, and contains the metric for each bidirectional neighbor listed in the (full or differential) Hello, in the same order. If the I bit is set to 1, then the Metric TLV includes the neighbor ID and metric for each bidirectional neighbor listed in the Hello whose metric is not equal to the Default Metric field of the TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR度量TLV（或度量TLV）向接口上的每个双向邻居播发链路成本，以允许选择要包括在部分拓扑LSA中的邻居。如果LSAFullness为1或2，则必须将度量TLV附加到每个MANET Hello数据包，除非所有链路成本为1。第A.2.5节给出了公制TLV的格式。度量TLV的I位可以设置为0或1。如果I位设置为0，则度量TLV不包含邻居ID，并且包含（完整或差异）Hello中列出的每个双向邻居的度量，顺序相同。如果I位设置为1，则度量TLV包括邻居ID和Hello中列出的每个双向邻居的度量，其度量不等于TLV的默认度量字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The I bit should be chosen to minimize the size of the Metric TLV. This can be achieved by choosing the I bit to be 1 if and only if the number of bidirectional neighbors listed in the Hello whose metric differs from the Default Metric field is less than 1/3 of the total number of bidirectional neighbors listed in the Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应选择I位以最小化度量TLV的大小。这可以通过选择I位为1来实现，当且仅当Hello中列出的双向邻居数量（其度量不同于默认度量字段）小于Hello中列出的双向邻居总数的1/3时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if all neighbors have the same metric, then the I bit should be set to 1, with the Default Metric equal to this metric, avoiding the need to include neighbor IDs and corresponding metrics in the TLV. At the other extreme, if all neighbors have different metrics, then the I bit should be set to 0 to avoid listing the same neighbor IDs in both the body of the Hello and the Metric TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如，如果所有邻居都具有相同的度量，则I位应设置为1，默认度量等于此度量，从而避免需要在TLV中包括邻居ID和相应的度量。在另一个极端，如果所有邻居都有不同的度量，那么I位应该设置为0，以避免在Hello和度量TLV的主体中列出相同的邻居id。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In both full and differential Hello packets, the L bit is set in the Hello&#39;s option field to indicate LLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在全Hello和差分Hello数据包中，在Hello的选项字段中设置L位以指示LLS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Full Hello Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 完整的问候包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a full Hello, the neighbor ID list includes all neighbors on the interface that are in state Init or greater, in the order described above. The MDR-Hello TLV is built as described above. If a Metric TLV is appended, it is built as specified in Section A.2.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在完整的Hello中，邻居ID列表按上述顺序包括接口上处于Init或更高状态的所有邻居。MDR Hello TLV如上所述构建。如果附加了公制TLV，则按照第a.2.5节的规定进行构建。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Differential Hello Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 差分Hello包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a differential Hello, the five neighbor ID lists defined in Section 4.1 are populated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在差异Hello中，第4.1节中定义的五个邻居ID列表填充如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 1 includes each neighbor in state Down that has not yet been included in HelloRepeatCount Hellos since transitioning to this state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表1包括每个处于关闭状态的邻居，这些邻居自转换到此状态后尚未包含在Hello重复计数Hello中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 2 includes each neighbor in state Init that has not yet been included in HelloRepeatCount Hellos since transitioning to this state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表2包括状态Init中的每个邻居，这些邻居自转换到此状态后尚未包含在Hello重复计数Hellos中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 3 includes each Dependent Neighbor that has not yet been included in HelloRepeatCount Hellos since becoming a Dependent Neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表3包括自成为从属邻居以来尚未包含在Hello重复计数Hello中的每个从属邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 4 includes each Selected Advertised Neighbor that has not yet been included in HelloRepeatCount Hellos since becoming a Selected Advertised Neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表4包括每个选定的播发邻居，这些邻居在成为选定的播发邻居后尚未包含在Hello重复计数Hello中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
List 5 includes each unselected bidirectional neighbor (defined in Section 4.1) that has not yet been included in HelloRepeatCount Hellos since becoming an unselected bidirectional neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表5包括每个未选择的双向邻居（定义见第4.1节），这些邻居自成为未选择的双向邻居后尚未包括在Hello重复计数Hello中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, a bidirectional neighbor must be included (in the appropriate list) if the neighbor&#39;s BNS does not include the router (indicating that the neighbor does not consider the router to be bidirectional).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，如果邻居的BNS不包括路由器（指示邻居不考虑路由器是双向的），则必须包括双向邻居（在适当的列表中）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a Metric TLV is appended to the Hello, then a bidirectional neighbor must be included (in the appropriate list) if it has not yet been included in HelloRepeatCount Hellos since its metric last changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果将度量TLV附加到Hello，则如果自度量上次更改以来，双向邻居尚未包括在HellorePeaccount Hello中，则必须将其包括（在适当的列表中）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Receiving Hello Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 接收Hello数据包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Hello packet received on a MANET interface is processed as described in [RFC5340], Section 4.2.2.1, and the first two paragraphs of [RFC2328], Section 10.5, followed by the processing specified below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
按照[RFC5340]第4.2.2.1节和[RFC2328]第10.5节的前两段所述，对MANET接口上接收到的Hello数据包进行处理，然后进行以下规定的处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The source of a received Hello packet is identified by the Router ID found in the Hello&#39;s OSPF packet header. If a matching neighbor cannot be found in the interface&#39;s data structure, one is created
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收到的Hello数据包的源由Hello的OSPF数据包头中的路由器ID标识。如果在接口的数据结构中找不到匹配的邻居，则会创建一个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
with the Neighbor ID set to the Router ID found in the OSPF packet header, the state initialized to Down, all MANET-specific neighbor variables (specified in Section 3.3) initialized to zero, and the neighbor&#39;s DNS, SANS, and BNS initialized to empty sets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居ID设置为OSPF数据包头中的路由器ID时，状态初始化为关闭，所有MANET特定的邻居变量（在第3.3节中指定）初始化为零，邻居的DNS、SAN和BNS初始化为空集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The neighbor structure&#39;s Router Priority is set to the value of the corresponding field in the received Hello packet. The Neighbor&#39;s Parent is set to the value of the DR field, and the Neighbor&#39;s Backup Parent is set to the value of the Backup DR field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居结构的路由器优先级设置为接收到的Hello数据包中相应字段的值。邻居的父级设置为DR字段的值，而邻居的备份父级设置为Backup DR字段的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now the rest of the Hello Packet is examined, generating events to be given to the neighbor and interface state machines. These state machines are specified to be either executed or scheduled (see [RFC2328], Section 4.4, &#34;Tasking support&#34;). For example, by specifying below that the neighbor state machine be executed in line, several neighbor state transitions may be affected by a single received Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在检查Hello数据包的其余部分，生成要提供给邻居和接口状态机的事件。这些状态机被指定为执行或调度（见[RFC2328]，第4.4节，“任务支持”）。例如，通过在下面指定以行方式执行邻居状态机，多个邻居状态转换可能会受到单个接收到的Hello的影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the L bit in the options field is not set, then an error has occurred and the Hello is discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果未设置选项字段中的L位，则发生错误并丢弃Hello。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the LLS contains an MDR-Hello TLV, the neighbor state machine is executed with the event HelloReceived. Otherwise, an error has occurred and the Hello is discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果LLS包含MDR Hello TLV，则使用事件HelloReceived执行邻居状态机。否则，将发生错误并丢弃Hello。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Hello Sequence Number and the A-bit in the MDR-Hello TLV are copied to the neighbor&#39;s data structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MDR Hello TLV中的Hello序列号和A位被复制到邻居的数据结构中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The DR and Backup DR fields are processed as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DR和Backup DR字段的处理如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) If the DR field is equal to the neighbor&#39;s Router ID, set the neighbor&#39;s MDR Level to MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) 如果DR字段等于邻居的路由器ID，则将邻居的MDR级别设置为MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) Else if the Backup DR field is equal to the neighbor&#39;s Router ID, set the neighbor&#39;s MDR Level to Backup MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) 否则，如果Backup DR字段等于邻居的路由器ID，请将邻居的MDR级别设置为Backup MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(3) Else, set the neighbor&#39;s MDR Level to MDR Other and set the neighbor&#39;s Dependent Neighbor variable to 0. (Only MDR/BMDR neighbors can be Dependent.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(3) 否则，将邻居的MDR级别设置为MDR Other，并将邻居的从属邻居变量设置为0。（只能依赖MDR/BMDR邻居。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(4) If the DR or Backup DR field is equal to the router&#39;s own Router ID, set the neighbor&#39;s Child variable to 1; otherwise, set it to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(4) 如果DR或Backup DR字段等于路由器自己的路由器ID，则将邻居的子变量设置为1；否则，将其设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The neighbor ID list of the Hello is divided as follows into the five lists defined in Section 4.1, where N1, N2, N3, and N4 are obtained from the corresponding fields of the MDR-Hello TLV. List 1 is defined to be the first N1 neighbor IDs, List 2 is defined to be the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello的邻居ID列表分为第4.1节中定义的五个列表，其中N1、N2、N3和N4从MDR Hello TLV的相应字段中获取。列表1被定义为第一个N1邻居ID，列表2被定义为第一个N1邻居ID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
next N2 neighbor IDs, List 3 is defined to be the next N3 neighbor IDs, List 4 is defined to be the next N4 neighbor IDs, and List 5 is defined to be the remaining neighbor IDs in the Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下一个N2邻居ID，列表3定义为下一个N3邻居ID，列表4定义为下一个N4邻居ID，列表5定义为Hello中剩余的邻居ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Further processing of the Hello depends on whether it is full or differential, which is indicated by the value of the D-bit of the MDR-Hello TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello的进一步处理取决于它是满的还是差的，这由MDR Hello TLV的D位值指示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Full Hello Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. 完整的问候包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the received Hello is full (the D-bit of the MDR-Hello TLV is 0), the following steps are performed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果收到的Hello已满（MDR Hello TLV的D位为0），则执行以下步骤：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the N1 field of the MDR-Hello TLV is not zero, then an error has occurred and the Hello is discarded. Otherwise, set FullHelloRcvd to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果MDR Hello TLV的N1字段不为零，则发生错误并丢弃Hello。否则，将FullHelloRcvd设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In the neighbor structure, modify the neighbor&#39;s DNS to equal the set of neighbor IDs in the Hello&#39;s List 3, modify the neighbor&#39;s SANS to equal the set of neighbor IDs in the Hello&#39;s List 4, and modify the neighbor&#39;s BNS to equal the set of neighbor IDs in the union of Lists 3, 4, and 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在邻居结构中，修改邻居的DNS以等于Hello列表3中的邻居ID集，修改邻居的SAN以等于Hello列表4中的邻居ID集，并修改邻居的BNS以等于列表3、4和5的并集中的邻居ID集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the router itself appears in the Hello&#39;s neighbor ID list, the neighbor state machine is executed with the event 2-WayReceived after the Hello is processed. Otherwise, the neighbor state machine is executed with the event 1-WayReceived after the Hello is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果路由器本身出现在Hello的邻居ID列表中，则在处理Hello后，邻居状态机将执行事件2-WayReceived。否则，在处理Hello之后，将使用接收到的事件1-WayReceived执行邻居状态机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Differential Hello Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 差分Hello包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the received Hello is differential (the D-bit of the MDR-Hello TLV is 1), the following steps are performed:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果接收到的Hello是差分的（MDR Hello TLV的D位为1），则执行以下步骤：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) For each neighbor ID in List 1 or List 2 of the Hello:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 对于Hello列表1或列表2中的每个邻居ID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o Remove the neighbor ID from the neighbor&#39;s DNS, SANS, and BNS, if it belongs to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 从邻居的DNS、SAN和BNS中删除邻居ID（如果它属于邻居集）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) For each neighbor ID in List 3 of the Hello:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 对于Hello列表3中的每个邻居ID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o Add the neighbor ID to the neighbor&#39;s DNS and BNS, if it does not belong to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 如果邻居ID不属于邻居集，则将其添加到邻居的DNS和BNS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o Remove the neighbor ID from the neighbor&#39;s SANS, if it belongs to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 从邻居的SAN中删除邻居ID（如果它属于邻居集）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) For each neighbor ID in List 4 of the Hello:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 对于Hello列表4中的每个邻居ID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o Add the neighbor ID to the neighbor&#39;s SANS and BNS, if it does not belong to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 如果邻居ID不属于邻居集，则将其添加到邻居的SAN和BNS中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o Remove the neighbor ID from the neighbor&#39;s DNS, if it belongs to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 从邻居的DNS中删除邻居ID（如果它属于邻居集）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) For each neighbor ID in List 5 of the Hello:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 对于Hello列表5中的每个邻居ID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o Add the neighbor ID to the neighbor&#39;s BNS, if it does not belong to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 如果邻居ID不属于邻居集，则将其添加到邻居的BNS中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o Remove the neighbor ID from the neighbor&#39;s DNS and SANS, if it belongs to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 从邻居的DNS和SAN中删除邻居ID（如果它属于邻居集）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) If the router&#39;s own RID appears in List 1, execute the neighbor state machine with the event 1-WayReceived after the Hello is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) 如果路由器自己的RID出现在列表1中，则在处理Hello后，使用事件1-WayReceived执行邻居状态机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) If the router&#39;s own RID appears in List 2, 3, 4, or 5, execute the neighbor state machine with the event 2-WayReceived after the Hello is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) 如果路由器自己的RID出现在列表2、3、4或5中，则在处理Hello后，使用事件2-WayReceived执行邻居状态机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) If the router&#39;s own RID does not appear in the Hello&#39;s neighbor ID list, and the neighbor state is 2-Way or greater, and the Hello Sequence Number is less than or equal to the previous sequence number plus HelloRepeatCount, then the neighbor state machine is executed with the event 2-WayReceived after the Hello is processed (the state does not change).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) 如果路由器自己的RID没有出现在Hello的邻居ID列表中，并且邻居状态为2路或更大，并且Hello序列号小于或等于前一个序列号加上Hello重复计数，则在处理Hello后，使用接收到的事件2路执行邻居状态机（状态不变）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(8) If 2-WayReceived is not executed, then 1-WayReceived is executed after the Hello is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(8) 如果未执行2-WayReceived，则在处理Hello后执行1-WayReceived。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. Additional Processing for Both Hello Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. 两种Hello类型的附加处理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following applies to both full and differential Hellos.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下内容适用于全hello和差分hello。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the router itself belongs to the neighbor&#39;s DNS, the neighbor&#39;s Dependent Selector variable is set to 1; otherwise, it is set to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果路由器本身属于邻居的DNS，则邻居的从属选择器变量设置为1；否则，它将设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiving interface&#39;s MDRNeighborChange variable is set to 1 if any of the following changes occurred as a result of processing the Hello:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果由于处理Hello而发生以下任何更改，则接收接口的MDRNeighborChange变量将设置为1：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The neighbor&#39;s state changed from less than 2-Way to 2-Way or greater, or vice versa.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 邻居的状态从小于2路更改为2路或更大，反之亦然。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The neighbor is bidirectional and any of the following neighbor variables has changed: MDR Level, Router Priority, FullHelloRcvd, and Bidirectional Neighbor Set (BNS).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 邻居是双向的，并且以下任何邻居变量都已更改：MDR级别、路由器优先级、FullHelloRcvd和双向邻居集（BNS）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The neighbor state machine is scheduled with the event AdjOK? if any of the following changes occurred as a result of processing the Hello:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居状态机与事件AdjOK一起调度？如果由于处理Hello而发生以下任何更改：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The neighbor&#39;s state changed from less than 2-Way to 2-Way or greater.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 邻居的状态从小于双向更改为双向或更大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The neighbor is bidirectional and its MDR Level has changed, or its Child variable or Dependent Selector variable has changed from 0 to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 邻居是双向的，其MDR级别已更改，或者其子变量或从属选择器变量已从0更改为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the LLS contains a Metric TLV, it is processed by updating the neighbor&#39;s link metrics according to the format of the Metric TLV specified in Section A.2.5. If the LLS does not contain a Metric TLV and LSAFullness is 1 or 2, the metric for each of the neighbor&#39;s links is set to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LLS包含度量TLV，则根据第a.2.5节中规定的度量TLV格式，通过更新邻居的链路度量来处理。如果LLS不包含度量TLV，并且LSAFullness为1或2，则每个邻居链路的度量都设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Neighbor Acceptance Condition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 邻域接受条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In wireless networks, a single Hello can be received from a neighbor with which a poor connection exists, e.g., because the neighbor is almost out of range. To avoid accepting poor-quality neighbors, and to employ hysteresis, a router may require that a stricter condition be satisfied before changing the state of a MANET neighbor from Down to Init or greater. This condition is called the &#34;neighbor acceptance condition&#34;, which by default is the reception of a single Hello or DD packet. For example, the neighbor acceptance condition may require that 2 consecutive Hellos be received from a neighbor before changing the neighbor&#39;s state from Down to Init. Other possible conditions include the reception of 3 consecutive Hellos, or the reception of 2 of the last 3 Hellos. The neighbor acceptance condition may also impose thresholds on other measurements such as received signal strength.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在无线网络中，可以从存在不良连接的邻居处接收单个问候，例如，因为邻居几乎超出范围。为了避免接受低质量的邻居，并采用滞后，路由器可能要求在将MANET邻居的状态从Down更改为Init或更高之前满足更严格的条件。该条件称为“邻居接受条件”，默认情况下是接收单个Hello或DD数据包。例如，邻居接受条件可能要求在将邻居的状态从Down更改为Init之前从邻居接收2个连续的hello。其他可能的情况包括接收到3个连续的问候，或接收到最后3个问候中的2个。相邻接收条件还可以对诸如接收信号强度之类的其他测量施加阈值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The neighbor state transition for state Down and event HelloReceived is thus modified (see Section 7.1) to depend on the neighbor acceptance condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，状态关闭和事件HelloReceived的邻居状态转换被修改（参见第7.1节），以取决于邻居接受条件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. MDR Selection Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. MDR选择算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the MDR selection algorithm, which is run for each MANET interface to determine whether the router is an MDR, Backup MDR, or MDR Other for that interface. The algorithm also selects the Dependent Neighbors and the (Backup) Parent, which are used to decide which neighbors should become adjacent (see Section 7.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍MDR选择算法，该算法针对每个MANET接口运行，以确定路由器是该接口的MDR、备份MDR还是其他MDR。该算法还选择从属邻居和（备份）父级，用于决定哪些邻居应成为相邻邻居（参见第7.2节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MDR selection algorithm must be executed just before sending a Hello if the MDRNeighborChange bit is set for the interface. The algorithm SHOULD also be executed whenever a bidirectional neighbor transitions to less than 2-Way, and MAY be executed at other times when the MDRNeighborChange bit is set. The bit is cleared after the algorithm is executed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果为接口设置了MDRNeighborChange位，则必须在发送Hello之前执行MDR选择算法。该算法还应在双向邻居转换为小于2路时执行，并可在设置MDRNeighborChange位时的其他时间执行。该位在执行算法后被清除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To simplify the implementation, the MDR selection algorithm MAY be executed periodically just before sending each Hello, to avoid having to determine when the MDRNeighborChange bit should be set. After running the MDR selection algorithm, the AdjOK? event may be invoked for some or all neighbors as specified in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了简化实现，可以在发送每个Hello之前周期性地执行MDR选择算法，以避免必须确定何时应该设置MDRNeighborChange位。运行MDR选择算法后，AdjOK？事件可以为第7节中指定的部分或所有邻居调用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the MDRs is to provide a minimal set of relays for flooding LSAs, and the purpose of the Backup MDRs is to provide backup relays to flood LSAs when flooding by MDRs does not succeed. The set of MDRs forms a CDS, and the set of MDRs and Backup MDRs forms a biconnected CDS (if the network itself is biconnected).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR的目的是为泛洪LSA提供一组最小的继电器，而备用MDR的目的是在MDR泛洪失败时为泛洪LSA提供备用继电器。MDR集形成CDS，MDR和备份MDR集形成双连接CDS（如果网络本身是双连接的）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each MDR selects and becomes adjacent with a subset of its MDR neighbors, called Dependent Neighbors, forming a connected backbone. Each non-MDR router connects to this backbone by selecting and becoming adjacent with an MDR neighbor called its Parent. Each MDR selects itself as Parent, to inform neighbors that it is an MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个MDR选择其MDR邻居的子集（称为从属邻居），并与之相邻，形成连接的主干。每个非MDR路由器通过选择一个称为其父路由器的MDR邻居并与其相邻来连接到该主干网。每个MDR选择自己作为父级，以通知邻居它是一个MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If AdjConnectivity = 2, then each (Backup) MDR selects and becomes adjacent with additional (Backup) MDR neighbors to form a biconnected backbone, and each MDR Other selects and becomes adjacent with a second (Backup) MDR neighbor called its Backup Parent, thus becoming connected to the backbone via two adjacencies. Each BMDR selects itself as Backup Parent, to inform neighbors that it is a BMDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果AdjConnectivity=2，则每个（备份）MDR选择并与其他（备份）MDR邻居相邻以形成双连接主干，每个MDR彼此选择并与称为其备份父级的第二个（备份）MDR邻居相邻，从而通过两个相邻连接到主干。每个BMDR选择自己作为备份父级，以通知邻居它是一个BMDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MDR selection algorithm is a distributed CDS algorithm that uses 2-hop neighbor information obtained from Hellos. More specifically, it uses as inputs the set of bidirectional neighbors (in state 2-Way or greater), the triplet (Router Priority, MDR Level, Router ID) for each such neighbor and for the router itself, and the neighbor
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR选择算法是一种分布式CDS算法，它使用从Hellos获得的2跳邻居信息。更具体地说，它使用双向邻居集（状态为双向或更高）、每个这样的邻居的三元组（路由器优先级、MDR级别、路由器ID）、路由器本身和邻居作为输入
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
variables Bidirectional Neighbor Set (BNS) and FullHelloRcvd for each such neighbor. The MDR selection algorithm can be implemented in O(d^2) time, where d is the number of neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
变量双向邻居集（BNS）和每个这样的邻居的FullHelloRcvd。MDR选择算法可以在O（d^2）时间内实现，其中d是邻居的数量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above triplet will be abbreviated as (RtrPri, MDR Level, RID). The triplet (RtrPri, MDR Level, RID) is said to be larger for Router A than for Router B if the triplet for Router A is lexicographically greater than the triplet for Router B. Routers that have larger values of this triplet are preferred for selection as an MDR. The algorithm therefore prefers routers that are already MDRs, resulting in a longer average MDR lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述三元组将缩写为（RtrPri、MDR级别、RID）。如果路由器A的三元组在词典上大于路由器B的三元组，则称路由器A的三元组（RtrPri、MDR级别、RID）大于路由器B。首选具有此三元组较大值的路由器作为MDR选择。因此，该算法更喜欢已经是MDR的路由器，从而导致更长的平均MDR生存期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MDR selection algorithm consists of five phases, the last of which is optional. Phase 1 creates the neighbor connectivity matrix for the interface, which determines which pairs of neighbors are neighbors of each other. Phase 2 decides whether the calculating router is an MDR, and which MDR neighbors are Dependent. Phase 3 decides whether the calculating router is a Backup MDR and, if AdjConnectivity = 2, which additional MDR/BMDR neighbors are Dependent. Phase 4 selects the Parent and Backup Parent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR选择算法包括五个阶段，最后一个阶段是可选的。阶段1为接口创建邻居连接矩阵，该矩阵确定哪对邻居是彼此的邻居。阶段2决定计算路由器是否是MDR，以及哪些MDR邻居是相关的。阶段3决定计算路由器是否为备份MDR，如果AdjConnectivity=2，则决定依赖哪些其他MDR/BMDR邻居。阶段4选择父级和备份父级。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm simplifies considerably if AdjConnectivity is 0 (full-topology adjacencies). In this case, the set of Dependent Neighbors is empty and MDR Other routers need not select Parents. Also, Phase 3 (BMDR selection) is not required if AdjConnectivity is 0 or 1. However, Phase 3 MUST be executed if AdjConnectivity is 2, and SHOULD be executed if AdjConnectivity is 0 or 1, since BMDRs improve robustness by providing backup flooding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当邻接连通度为0（全拓扑邻接）时，该算法大大简化。在这种情况下，依赖邻居集为空，MDR其他路由器不需要选择父节点。此外，如果AdjConnectivity为0或1，则不需要阶段3（BMDR选择）。但是，如果AdjConnectivity为2，则必须执行阶段3，如果AdjConnectivity为0或1，则应执行阶段3，因为BMDR通过提供备份泛洪来提高健壮性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A router that has selected itself as an MDR in Phase 2 MAY execute Phase 5 to possibly declare itself a non-flooding MDR. A non-flooding MDR is the same as a flooding MDR except that it does not automatically flood received LSAs back out the receiving interface, because it has determined that neighboring MDRs are sufficient to flood the LSA to all neighbors. Instead, a non-flooding MDR performs backup flooding just like a BMDR. A non-flooding MDR maintains its MDR level (rather than being demoted to a BMDR) in order to maximize the stability of adjacencies. (The decision to form an adjacency does not depend on whether an MDR is non-flooding.) By having MDRs declare themselves to be non-flooding when possible, flooding overhead is reduced. The resulting reduction in flooding overhead can be dramatic for certain regular topologies, but has been found to be less than 15% for random topologies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在阶段2中选择自己作为MDR的路由器可以执行阶段5，以可能声明自己为非泛洪MDR。非泛洪MDR与泛洪MDR相同，只是它不会自动将接收到的LSA泛洪回接收接口，因为它已确定相邻MDR足以将LSA泛洪到所有邻居。相反，非泛洪MDR与BMDR一样执行备份泛洪。非泛洪MDR保持其MDR级别（而不是降级为BMDR），以最大限度地提高邻接的稳定性。（形成邻接的决定并不取决于MDR是否为非泛洪。）通过让MDR在可能的情况下声明自己为非泛洪，可以减少泛洪开销。由此产生的泛洪开销的减少对于某些常规拓扑可能是显著的，但对于随机拓扑，已发现其减少不到15%。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following subsections describe the MDR selection algorithm, which is applied independently to each MANET interface. For convenience, the term &#34;bi-neighbor&#34; will be used as an abbreviation for &#34;bidirectional neighbor&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下小节描述了MDR选择算法，该算法独立应用于每个MANET接口。为方便起见，术语“双向邻居”将用作“双向邻居”的缩写。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Phase 1: Creating the Neighbor Connectivity Matrix
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 阶段1：创建邻居连接矩阵
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phase 1 creates the neighbor connectivity matrix (NCM) for the interface. The NCM is a symmetric matrix that defines a topology graph for the set of bi-neighbors on the interface. The NCM assigns a value of 0 or 1 for each pair of bi-neighbors; a value of 1 indicates that the neighbors are assumed to be bi-neighbors of each other in the MDR selection algorithm. Letting i denote the router itself, NCM(i,j) and NCM(j,i) are set to 1 for each bi-neighbor j. The value of the matrix is set as follows for each pair of bi-neighbors j and k on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
阶段1为接口创建邻居连接矩阵（NCM）。NCM是一个对称矩阵，为接口上的bi邻居集定义拓扑图。NCM为每对bi邻居分配0或1的值；值为1表示在MDR选择算法中，邻居被假定为彼此的双邻居。让我表示路由器本身，对于每个双邻居j，NCM（i，j）和NCM（j，i）被设置为1。对于接口上的每对双邻居j和k，矩阵的值设置如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1.1) If FullHelloRcvd is 1 for both neighbors j and k: NCM(j,k) = NCM(k,j) is 1 only if j belongs to the BNS of neighbor k and k belongs to the BNS of neighbor j.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（1.1）如果FullHelloRcvd对于邻居j和k均为1:NCM（j，k）=NCM（k，j）仅当j属于邻居k的BNS且k属于邻居j的BNS时才为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1.2) If FullHelloRcvd is 1 for neighbor j and is 0 for neighbor k: NCM(j,k) = NCM(k,j) is 1 only if k belongs to the BNS of neighbor j.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（1.2）如果FullHelloRcvd对于邻居j为1，对于邻居k为0:NCM（j，k）=NCM（k，j）仅当k属于邻居j的BNS时才为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1.3) If FullHelloRcvd is 0 for both neighbors j and k: NCM(j,k) = NCM(k,j) = 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（1.3）如果相邻j和k的FullHelloRcvd均为0:NCM（j，k）=NCM（k，j）=0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Step 1.1 above, two neighbors are considered to be bi-neighbors of each other only if they both agree that the other router is a bi-neighbor. This provides faster response to the failure of a link between two neighbors, since it is likely that one router will detect the failure before the other router. In Step 1.2 above, only neighbor j has reported its full BNS, so neighbor j is believed in deciding whether j and k are bi-neighbors of each other. As Step 1.3 indicates, two neighbors are assumed not to be bi-neighbors of each other if neither neighbor has reported its full BNS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在上面的步骤1.1中，只有当两个邻居都同意另一个路由器是bi邻居时，它们才被认为是彼此的bi邻居。这为两个相邻路由器之间的链路故障提供了更快的响应，因为一个路由器可能会在另一个路由器之前检测到故障。在上面的步骤1.2中，只有邻居j报告了它的完整BNS，因此邻居j被认为是决定j和k是否是彼此的双邻居。如步骤1.3所示，如果两个邻居均未报告其完整BNS，则假定两个邻居彼此不是双邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Phase 2: MDR Selection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 第2阶段：MDR选择
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phase 2 depends on the parameter MDRConstraint, which affects the number of MDRs selected. The default value of 3 results in nearly the minimum number of MDRs, while the value 2 results in a larger number of MDRs. If AdjConnectivity = 0 (full-topology adjacencies), then the following steps are modified in that Dependent Neighbors are not selected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
阶段2取决于参数MDRConstraint，该参数会影响所选MDR的数量。默认值3导致MDR的数量几乎为最小，而值2导致MDR的数量更大。如果邻接连接性=0（完整拓扑邻接），则将修改以下步骤，因为未选择从属邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2.1) The set of Dependent Neighbors is initialized to be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2.1）依赖邻居集初始化为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2.2) If the router has a larger value of (RtrPri, MDR Level, RID) than all of its bi-neighbors, the router selects itself as an MDR; selects all of its MDR bi-neighbors as Dependent Neighbors; if AdjConnectivity = 2, selects all of its BMDR bi-neighbors as Dependent Neighbors; then proceeds to Phase 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2.2）如果路由器的值（RtrPri，MDR级别，RID）大于其所有bi邻居，则路由器选择自身作为MDR；选择其所有MDR bi邻居作为从属邻居；如果AdjConnectivity=2，则选择其所有BMDR bi邻居作为从属邻居；然后进入第4阶段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2.3) Let Rmax be the bi-neighbor with the largest value of (RtrPri, MDR Level, RID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2.3）让Rmax成为最大值（RtrPri、MDR级别、RID）的bi邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2.4) Using NCM to determine the connectivity of bi-neighbors, compute the minimum number of hops, denoted hops(u), from Rmax to each other bi-neighbor u, using only intermediate nodes that are bi-neighbors with a larger value of (RtrPri, MDR Level, RID) than the router itself. If no such path from Rmax to u exists, then hops(u) equals infinity. (See Appendix B for a detailed algorithm using breadth-first search.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2.4）使用NCM确定bi邻居的连接性，计算从Rmax到其他bi邻居u的最小跳数，表示为跳数（u），仅使用中间节点，这些节点是比路由器本身具有更大值（RtrPri、MDR级别、RID）的bi邻居。如果不存在从Rmax到u的路径，则跳数（u）等于无穷大。（关于使用广度优先搜索的详细算法，请参见附录B。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2.5) If hops(u) is at most MDRConstraint for each bi-neighbor u, the router selects no Dependent Neighbors, and sets its MDR Level as follows: If the MDR Level is currently MDR, then it is changed to BMDR if Phase 3 will be executed and to MDR Other if Phase 3 will not be executed. Otherwise, the MDR Level is not changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2.5）如果每个双邻居u的跳数（u）最多为MDR约束，则路由器选择不依赖的邻居，并将其MDR级别设置为：如果MDR级别当前为MDR，则如果将执行阶段3，则将其更改为BMDR，如果不执行阶段3，则将其更改为MDR Other。否则，MDR水平不会改变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2.6) Else, the router sets its MDR Level to MDR and selects the following neighbors as Dependent Neighbors: Rmax if it is an MDR or BMDR; each MDR bi-neighbor u such that hops(u) is greater than MDRConstraint; and if AdjConnectivity = 2, each BMDR bi-neighbor u such that hops(u) is greater than MDRConstraint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2.6）否则，路由器将其MDR级别设置为MDR，并选择以下邻居作为从属邻居：Rmax（如果是MDR或BMDR）；每个MDR双邻居u，使得跳数（u）大于MDR约束；如果AdjConnectivity=2，则每个BMDR bi邻居u使得跳数（u）大于MDRConstraint。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2.7) If steps 2.1 through 2.6 resulted in the MDR Level changing to BMDR, or to MDR with AdjConnectivity equal to 1 or 2, then execute steps 2.1 through 2.6 again. (This is necessary because the change in MDR Level can cause the set of Dependent Neighbors and the BFS tree to change.) This step is not required if the MDR selection algorithm is executed periodically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（2.7）如果步骤2.1至2.6导致MDR级别更改为BMDR，或更改为连接等于1或2的MDR，则再次执行步骤2.1至2.6。（这是必要的，因为MDR级别的更改会导致依赖邻居集和BFS树发生更改。）如果定期执行MDR选择算法，则不需要此步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 2.4 can be implemented using a breadth-first search (BFS) algorithm to compute min-hop paths from Rmax to all other bi-neighbors, modified to allow a bi-neighbor to be an intermediate node only if its value of (RtrPri, MDR Level, RID) is larger than that of the router itself. A detailed description of this algorithm, which runs in O(d^2) time, is given in Appendix B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
步骤2.4可以使用广度优先搜索（BFS）算法来实现，以计算从Rmax到所有其他bi邻居的最小跳跃路径，修改为仅当bi邻居的（RtrPri，MDR Level，RID）值大于路由器本身的值时，才允许其成为中间节点。附录B中给出了在O（d^2）时间内运行的该算法的详细说明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Phase 3: Backup MDR Selection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 阶段3：备份MDR选择
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3.1) If the MDR Level is MDR (after running Phase 2) and AdjConnectivity is not 2, then proceed to Phase 4. (If the MDR Level is MDR and AdjConnectivity = 2, then Phase 3 may select additional Dependent Neighbors to create a biconnected backbone.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3.1）如果MDR级别为MDR（运行阶段2后），且AdjConnectivity不是2，则进入阶段4。（如果MDR级别为MDR且AdjConnectivity=2，则阶段3可能会选择其他从属邻居来创建双连接主干。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3.2) Using NCM to determine the connectivity of bi-neighbors, determine whether or not there exist two node-disjoint paths from Rmax to each other bi-neighbor u, using only intermediate nodes that are bi-neighbors with a larger value of (RtrPri, MDR Level, RID) than the router itself. (See Appendix B for a detailed algorithm.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3.2）使用NCM确定bi邻居的连接性，确定从Rmax到彼此的bi邻居u是否存在两条节点不相交的路径，只使用中间节点，这些节点是比路由器本身具有更大值（RtrPri、MDR级别、RID）的bi邻居。（详细算法见附录B。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3.3) If there exist two such node-disjoint paths from Rmax to each other bi-neighbor u, then the router selects no additional Dependent Neighbors and sets its MDR Level to MDR Other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3.3）如果存在从Rmax到彼此的双邻居u的两条这样的节点不相交路径，则路由器不选择其他依赖邻居，并将其MDR级别设置为MDR other。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3.4) Else, the router sets its MDR Level to Backup MDR unless it already selected itself as an MDR in Phase 2, and if AdjConnectivity = 2, adds each of the following neighbors to the set of Dependent Neighbors: Rmax if it is an MDR or BMDR, and each MDR/BMDR bi-neighbor u such that Step 3.2 did not find two node-disjoint paths from Rmax to u.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3.4）否则，路由器将其MDR级别设置为备份MDR，除非它在第2阶段已选择自己作为MDR，并且如果AdjConnectivity=2，则将以下每个邻居添加到依赖邻居集中：如果是MDR或BMDR，则为Rmax，如果是MDR或BMDR，则为每个MDR/BMDR双邻居u，以便步骤3.2未找到从Rmax到u的两个节点不相交的路径。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3.5) If steps 3.1 through 3.4 resulted in the MDR Level changing from MDR Other to BMDR, then run Phases 2 and 3 again. (This is necessary because running Phase 2 again can cause the MDR Level to change to MDR.) This step is not required if the MDR selection algorithm is executed periodically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（3.5）如果步骤3.1至3.4导致MDR级别从MDR Other更改为BMDR，则再次运行阶段2和3。（这是必要的，因为再次运行阶段2可能会导致MDR级别更改为MDR。）如果定期执行MDR选择算法，则不需要此步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 3.2 can be implemented in O(d^2) time using the algorithm given in Appendix B. A simplified version of the algorithm is also specified, which results in a larger number of BMDRs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
步骤3.2可以使用附录B中给出的算法在O（d^2）时间内实现。还指定了算法的简化版本，这将导致更多的BMDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Phase 4: Parent Selection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 第四阶段：父母选择
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each router selects a Parent for each MANET interface. The Parent of a non-MDR router will be a neighboring MDR if one exists. If the option of biconnected adjacencies is chosen, then each MDR Other selects a Backup Parent, which will be a neighboring MDR/BMDR if one exists that is not the Parent. The Parent of an MDR is always the router itself, and the Backup Parent of a BMDR is always the router itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个路由器为每个MANET接口选择一个父节点。非MDR路由器的父路由器将是相邻的MDR（如果存在）。如果选择了双连接邻接选项，则每个MDR彼此选择一个备份父级，如果存在一个不是父级的MDR/BMDR，则该备份父级将是相邻的MDR/BMDR。MDR的父级始终是路由器本身，BMDR的备份父级始终是路由器本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (Backup) Parent is advertised in the (Backup) DR field of each Hello sent on the interface. As specified in Section 7.2, each router forms an adjacency with its Parent and Backup Parent if it exists and is a neighboring MDR/BMDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在接口上发送的每个Hello的（备份）DR字段中公布（备份）父项。如第7.2节所述，每个路由器与其父级和备份父级（如果存在）相邻，并且是相邻的MDR/BMDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a given MANET interface, let Rmax denote the router with the largest value of (RtrPri, MDR Level, RID) among all bidirectional neighbors, if such a neighbor exists that has a larger value of (RtrPri, MDR Level, RID) than the router itself. Otherwise, Rmax is null.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于给定的MANET接口，让Rmax表示所有双向邻居中最大值（RtrPri，MDR级别，RID）的路由器，如果存在这样一个邻居，其值（RtrPri，MDR级别，RID）大于路由器本身。否则，Rmax为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the calculating router has selected itself as an MDR, then the Parent is equal to the router itself, and the Backup Parent is Rmax. (The latter design choice was made because it results in slightly better performance than choosing no Backup Parent.) If the router has selected itself as a BMDR, then the Backup Parent is equal to the router itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果计算路由器已选择自身作为MDR，则父级等于路由器本身，备份父级为Rmax。（之所以选择后一种设计，是因为它的性能比不选择备份父级略好。）如果路由器选择自己作为BMDR，则备份父级与路由器本身相等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the calculating router is a BMDR or MDR Other, the Parent is selected to be any adjacent neighbor that is an MDR, if such a neighbor exists. If no adjacent MDR neighbor exists, then the Parent is selected to be Rmax. By giving preference to neighbors that are already adjacent, the formation of a new adjacency is avoided when possible. Note that the Parent can be a non-MDR neighbor temporarily when no MDR neighbor exists. (This design choice was also made for performance reasons.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果计算路由器是BMDR或MDR Other，则选择父路由器作为MDR的任何相邻邻居（如果存在这样的邻居）。如果不存在相邻的MDR邻居，则选择父级作为Rmax。通过优先选择已经相邻的邻域，尽可能避免形成新的邻域。请注意，当不存在MDR邻居时，父级可以临时成为非MDR邻居。（此设计选择也是出于性能原因。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If AdjConnectivity = 2 and the calculating router is an MDR Other, then the Backup Parent is selected to be any adjacent neighbor that is an MDR or BMDR, other than the Parent selected in the previous paragraph, if such a neighbor exists. If no such adjacent neighbor exists, then the Backup Parent is selected to be the bidirectional neighbor, excluding the selected Parent, with the largest value of (RtrPri, MDR Level, RID), if such a neighbor exists. Otherwise, the Backup Parent is null.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果AdjConnectivity=2且计算路由器是MDR Other，则选择备份父节点作为MDR或BMDR的任何相邻邻居，而不是上一段中选择的父节点（如果存在这样的邻居）。如果不存在这样的相邻邻居，则选择备份父级作为双向邻居，不包括所选父级，如果存在这样的邻居，则最大值为（RtrPri，MDR Level，RID）。否则，备份父级为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. Phase 5: Optional Selection of Non-Flooding MDRs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.5. 第5阶段：非淹没MDR的可选选择
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A router that has selected itself as an MDR MAY execute the following steps to possibly declare itself a non-flooding MDR. An MDR that does not execute the following steps is by default a flooding MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择自身作为MDR的路由器可能会执行以下步骤，以可能将自身声明为非泛洪MDR。默认情况下，不执行以下步骤的MDR是泛洪MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5.1) If the router has a larger value of (RtrPri, MDR Level, RID) than all of its bi-neighbors, the router is a flooding MDR. Else, proceed to Step 5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（5.1）如果路由器的值（RtrPri、MDR级别、RID）大于其所有bi邻居，则路由器是泛洪MDR。否则，继续执行步骤5.2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5.2) Let Rmax be the bi-neighbor that has the largest value of (RtrPri, MDR Level, RID).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（5.2）假设Rmax是具有最大值（RtrPri、MDR级别、RID）的bi邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5.3) Using NCM to determine the connectivity of bi-neighbors, compute the minimum number of hops, denoted hops(u), from Rmax to each other bi-neighbor u, using only intermediate nodes that are MDR bi-neighbors with a smaller value of (RtrPri, RID) than the router itself. (This can be done using BFS as in Step 2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（5.3）使用NCM确定bi邻居的连接性，计算从Rmax到其他bi邻居u的最小跳数，表示跳数（u），仅使用MDR bi邻居的中间节点，其值（RtrPri，RID）小于路由器本身。（这可以使用BFS完成，如步骤2.4所示）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5.4) If hops(u) is at most MDRConstraint for each bi-neighbor u, then the router is a non-flooding MDR. Else, it is a flooding MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（5.4）如果每个bi邻居u的跳数（u）最多为MDR约束，则路由器为非泛洪MDR。否则，它就是一个泛洪MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Interface State Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 接口状态机
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Interface States
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 界面状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No new states are defined for a MANET interface. However, the DR and Backup states now imply that the router is an MDR or Backup MDR, respectively. The following modified definitions apply to MANET interfaces:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
没有为MANET接口定义新状态。但是，DR和Backup状态现在分别表示路由器是MDR或Backup MDR。以下修改的定义适用于MANET接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Waiting In this state, the router learns neighbor information from the Hello packets it receives, but is not allowed to run the MDR selection algorithm until it transitions out of the Waiting state (when the Wait Timer expires). This prevents unnecessary changes in the MDR selection resulting from incomplete neighbor information. The length of the Wait Timer is 2HopRefresh * HelloInterval seconds (the interval between full Hellos).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在这种等待状态下，路由器从它接收到的Hello数据包中学习邻居信息，但不允许运行MDR选择算法，直到它转换出等待状态（等待计时器过期）。这可以防止由于邻居信息不完整而导致MDR选择中的不必要更改。等待计时器的长度为2hopfresh*HelloInterval seconds（满hello之间的间隔）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR Other The router has run the MDR selection algorithm and determined that it is not an MDR or a Backup MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR Other路由器已运行MDR选择算法并确定它不是MDR或备份MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Backup The router has selected itself as a Backup MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
备份路由器已选择自身作为备份MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR The router has selected itself as an MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR路由器已选择自身作为MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Events that Cause Interface State Changes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 导致接口状态更改的事件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All interface events defined in [RFC2328], Section 9.2, apply to MANET interfaces, except for BackupSeen and NeighborChange. BackupSeen is never invoked for a MANET interface (since seeing a Backup MDR does not imply that the router itself cannot also be an MDR or Backup MDR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2328]第9.2节中定义的所有接口事件均适用于MANET接口，但BackupSeen和NeighborChange除外。从来不会为MANET接口调用BackupSeen（因为看到备份MDR并不意味着路由器本身也不能是MDR或备份MDR）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The event NeighborChange is replaced with the new interface variable MDRNeighborChange, which indicates that the MDR selection algorithm must be executed due to a change in neighbor information (see Section 4.2.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用新的接口变量MDRNeighborChange替换事件NEARCHANGE，这表示由于邻居信息的变化，必须执行MDR选择算法（见第4.2.3节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Changes to Interface State Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 对接口状态机的更改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the changes to the interface state machine for a MANET interface. The two state transitions specified below are for state-event pairs that are described in [RFC2328], but have modified action descriptions because MDRs are selected instead of DRs. The state transition in [RFC2328] for the event NeighborChange is omitted; instead, the new interface variable MDRNeighborChange is used to indicate when the MDR selection algorithm needs to be executed. The state transition for the event BackupSeen does not apply to MANET interfaces, since this event is never invoked for a MANET interface. The interface state transitions for the events Loopback and UnloopInd are unchanged from [RFC2328].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节描述了对MANET接口的接口状态机的更改。下面指定的两个状态转换适用于[RFC2328]中描述的状态-事件对，但由于选择了MDR而不是DRs，因此修改了操作描述。省略了[RFC2328]中事件邻域更改的状态转换；相反，新的接口变量MDRNeighborChange用于指示何时需要执行MDR选择算法。事件BackupSeen的状态转换不适用于MANET接口，因为MANET接口从未调用此事件。事件环回和解锁的接口状态转换从[RFC2328]起保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 State: Down Event: InterfaceUp New state: Depends on action routine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态：关闭事件：接口EUP新状态：取决于操作例程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Action: Start the interval Hello Timer, enabling the periodic sending of Hello packets out the interface. The state transitions to Waiting and the single shot Wait Timer is started.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
操作：启动interval Hello计时器，启用从接口定期发送Hello数据包。状态转换为等待，单次激发等待计时器启动。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 State: Waiting Event: WaitTimer New state: Depends on action routine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态：等待事件：WaitTimer新状态：取决于操作例程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Action: Run the MDR selection algorithm, which may result in a change to the router&#39;s MDR Level, Dependent Neighbors, and (Backup) Parent. As a result of this calculation, the new interface state will be DR Other, Backup, or DR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
操作：运行MDR选择算法，这可能导致路由器的MDR级别、从属邻居和（备份）父级发生更改。作为此计算的结果，新接口状态将是DR Other、Backup或DR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
As a result of these changes, the AdjOK? neighbor event may be invoked for some or all neighbors. (See Section 7.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
由于这些变化，AdjOK？可以为部分或所有邻居调用邻居事件。（见第7节。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Adjacency Maintenance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 邻接保持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Adjacency forming and eliminating on non-MANET interfaces remain unchanged. Adjacency maintenance on a MANET interface requires changes to transitions in the neighbor state machine ([RFC2328], Section 10.3), to deciding whether to become adjacent ([RFC2328],
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非MANET接口上邻接的形成和消除保持不变。MANET接口上的邻接维护需要更改相邻状态机中的转换（[RFC2328]，第10.3节），以决定是否成为相邻状态（[RFC2328]，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 10.4), sending of DD packets ([RFC2328], Section 10.8), and receiving of DD packets ([RFC2328], Section 10.6). The specification below relates to the MANET interface only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第10.4节）、DD数据包的发送（[RFC2328]，第10.8节）和DD数据包的接收（[RFC2328]，第10.6节）。以下规范仅涉及MANET接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If full-topology adjacencies are used (AdjConnectivity = 0), the router forms an adjacency with each bidirectional neighbor. If adjacency reduction is used (AdjConnectivity is 1 or 2), the router forms adjacencies with a subset of its neighbors, according to the rules specified in Section 7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用全拓扑邻接（邻接连接性=0），路由器将与每个双向邻居形成邻接。如果使用邻接减少（邻接连接性为1或2），路由器将根据第7.2节中规定的规则与其邻居的子集形成邻接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An adjacency maintenance decision is made when any of the following four events occur between a router and its neighbor. The decision is made by executing the neighbor event AdjOK?.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器和它的邻居之间发生以下四个事件中的任何一个时，就会做出邻接维护决策。通过执行邻居事件AdjOK？作出决定？。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) The neighbor state changes from Init to 2-Way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) 相邻状态从Init更改为双向。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) The MDR Level changes for the neighbor or for the router itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) 邻居或路由器本身的MDR级别发生变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(3) The neighbor is selected to be the (Backup) Parent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(3) 邻居被选择为（备份）父对象。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(4) The neighbor selects the router to be its (Backup) Parent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(4) 邻居选择路由器作为其（备份）父路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Changes to Neighbor State Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 对邻居状态机的更改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following specifies new transitions in the neighbor state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下内容指定了邻居状态机中的新转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 State(s): Down Event: HelloReceived New state: Depends on action routine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态：关闭事件：Hello接收到的新状态：取决于操作例程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Action: If the neighbor acceptance condition is satisfied (see Section 4.3), the neighbor state transitions to Init and the Inactivity Timer is started. Otherwise, the neighbor remains in the Down state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
措施：如果邻居接受条件得到满足（参见第4.3节），邻居状态将转换为Init，并且不活动计时器将启动。否则，邻居将保持关闭状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 State(s): Init Event: 2-WayReceived New state: 2-Way
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态：初始事件：双向接收新状态：双向
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Action: Transition to neighbor state 2-Way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
操作：双向转换到相邻状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 State(s): 2-Way Event: AdjOK? New state: Depends on action routine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态：双向事件：AdjOK？新状态：取决于操作例程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Action: Determine whether an adjacency should be formed with the neighboring router (see Section 7.2). If not, the neighbor state remains at 2-Way and no further action is taken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
措施：确定是否应与相邻路由器形成邻接（见第7.2节）。否则，相邻状态保持双向，不采取进一步行动。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Otherwise, the neighbor state changes to ExStart, and the following actions are performed. If the neighbor has a larger Router ID than the router&#39;s own ID, and the received packet is a DD packet with the initialize (I), more (M), and master (MS) bits set, then execute the event NegotiationDone, which causes the state to transition to Exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
否则，邻居状态将更改为ExStart，并执行以下操作。如果邻居的路由器ID大于路由器自己的ID，并且接收到的数据包是设置了初始化（I）、更多（M）和主（MS）位的DD数据包，则执行事件协商完成，从而使状态转换为交换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Otherwise (negotiation is not complete), the router increments the DD sequence number in the neighbor data structure. If this is the first time that an adjacency has been attempted, the DD sequence number should be assigned a unique value (like the time of day clock). It then declares itself master (sets the master/slave bit to master), and starts sending Database Description packets, with the initialize (I), more (M), and master (MS) bits set, the MDR-DD TLV included in an LLS, and the L bit set. This Database Description packet should be otherwise empty. This Database Description packet should be retransmitted at intervals of RxmtInterval until the next state is entered (see [RFC2328], Section 10.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
否则（协商未完成），路由器增加邻居数据结构中的DD序列号。如果这是第一次尝试邻接，则应为DD序列号分配一个唯一值（如时间时钟）。然后，它声明自己为master（将主/从位设置为master），并开始发送数据库描述数据包，其中设置了initialize（I）、more（M）和master（MS）位、LLS中包含的MDR-DD TLV和L位。否则，此数据库描述数据包应为空。在进入下一个状态之前，应每隔RxmtInterval重新传输该数据库描述数据包（见[RFC2328]，第10.8节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 State(s): ExStart or greater Event: AdjOK? New state: Depends on action routine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态：ExStart或更大事件：AdjOK？新状态：取决于操作例程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Action: Determine whether the neighboring router should still be adjacent (see Section 7.3). If yes, there is no state change and no further action is necessary. Otherwise, the (possibly partially formed) adjacency must be destroyed. The neighbor state transitions to 2-Way. The Link state retransmission list, Database summary list, and Link state request list are cleared of LSAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
措施：确定相邻路由器是否仍应相邻（参见第7.3节）。如果是，则不存在状态更改，也无需采取进一步措施。否则，必须破坏（可能部分形成的）邻接。相邻状态转换为双向。清除链路状态重传列表、数据库摘要列表和链路状态请求列表中的LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Whether to Become Adjacent
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 是否相邻
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following defines the method to determine if an adjacency should be formed between neighbors in state 2-Way. The following procedure does not depend on whether AdjConnectivity is 1 or 2, but the selection of Dependent Neighbors (by the MDR selection algorithm) depends on AdjConnectivity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下定义了确定邻接是否应在状态为双向的邻居之间形成的方法。以下过程不取决于AdjConnectivity是1还是2，但依赖邻居的选择（通过MDR选择算法）取决于AdjConnectivity。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is not used (AdjConnectivity = 0), then an adjacency is formed with each neighbor in state 2-Way. Otherwise, an adjacency is formed with a neighbor in state 2-Way if any of the following conditions is true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果未使用邻接减少（邻接连接性=0），则邻接将与处于双向状态的每个邻居形成。否则，如果以下任一条件为真，则与状态为2-Way的邻居形成邻接：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) The router is a (Backup) MDR and the neighbor is a (Backup) MDR and is either a Dependent Neighbor or a Dependent Selector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 路由器是（备份）MDR，邻居是（备份）MDR，并且是从属邻居或从属选择器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) The neighbor is a (Backup) MDR and is the router&#39;s (Backup) Parent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 邻居是（备份）MDR，是路由器的（备份）父级。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) The router is a (Backup) MDR and the neighbor is a child.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 路由器是（备份）MDR，邻居是子路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) The neighbor&#39;s A-bit is 1, indicating that the neighbor is using full-topology adjacencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 邻居的A位为1，表示邻居正在使用完全拓扑邻接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, an adjacency is not established and the neighbor remains in state 2-Way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否则，将不建立邻接，并且邻居将保持双向状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Whether to Eliminate an Adjacency
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 是否消除邻接关系
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following defines the method to determine if an existing adjacency should be eliminated. An existing adjacency is maintained if any of the following is true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面定义了确定是否应消除现有邻接的方法。如果满足以下任一条件，则保持现有邻接：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) The router is an MDR or Backup MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 路由器是MDR或备份MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) The neighbor is an MDR or Backup MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 邻居是MDR或备份MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) The neighbor&#39;s A-bit is 1, indicating that the neighbor is using full-topology adjacencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 邻居的A位为1，表示邻居正在使用完全拓扑邻接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, the adjacency MAY be eliminated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否则，邻接可能会被消除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Sending Database Description Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 发送数据库描述数据包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending a DD packet on a MANET interface is the same as [RFC5340], Section 4.2.1.2, and [RFC2328], Section 10.8, with the following additions to paragraph 3 of Section 10.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在MANET接口上发送DD数据包与[RFC5340]第4.2.1.2节和[RFC2328]第10.8节相同，第10.8节第3段中增加了以下内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the neighbor state is ExStart, the standard initialization packet is sent with an MDR-DD TLV appended using LLS, and the L bit is set in the DD packet&#39;s option field. The format for the MDR-DD TLV is specified in Section A.2.4. The DR and Backup DR fields of the MDR-DD TLV are set exactly the same as the DR and Backup DR fields of a Hello sent on the same interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果邻居状态为ExStart，则发送标准初始化数据包时使用LLS附加MDR-DD TLV，并在DD数据包的选项字段中设置L位。第A.2.4节规定了MDR-DD TLV的格式。MDR-DD TLV的DR和Backup DR字段的设置与在同一接口上发送的Hello的DR和Backup DR字段完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. Receiving Database Description Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5. 接收数据库描述数据包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Processing a DD packet received on a MANET interface is the same as [RFC2328], Section 10.6, except for the changes described in this section. The following additional steps are performed before processing the packet based on neighbor state in paragraph 3 of Section 10.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处理MANET接口上接收的DD数据包与[RFC2328]第10.6节相同，但本节中描述的更改除外。在根据第10.6节第3段中的相邻状态处理数据包之前，执行以下附加步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the DD packet&#39;s L bit is set in the options field and an MDR-DD TLV is appended, then the MDR-DD TLV is processed as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果在选项字段中设置了DD数据包的L位并附加了MDR-DD TLV，则MDR-DD TLV的处理如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) If the DR field is equal to the neighbor&#39;s Router ID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) 如果DR字段等于邻居的路由器ID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(a) Set the MDR Level of the neighbor to MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(a) 将邻居的MDR级别设置为MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(b) Set the neighbor&#39;s Dependent Selector variable to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(b) 将邻居的从属选择器变量设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) Else if the Backup DR field is equal to the neighbor&#39;s Router ID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) 否则，如果备份灾难恢复字段等于邻居的路由器ID：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(a) Set the MDR Level of the neighbor to Backup MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(a) 将邻居的MDR级别设置为备份MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(b) Set the neighbor&#39;s Dependent Selector variable to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(b) 将邻居的从属选择器变量设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(3) Else:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(3) 其他：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(a) Set the MDR Level of the neighbor to MDR Other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(a) 将邻居的MDR级别设置为MDR Other。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(b) Set the neighbor&#39;s Dependent Neighbor variable to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(b) 将邻居的从属邻居变量设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(4) If the DR or Backup DR field is equal to the router&#39;s own Router ID, set the neighbor&#39;s Child variable to 1; otherwise, set it to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(4) 如果DR或Backup DR字段等于路由器自己的路由器ID，则将邻居的子变量设置为1；否则，将其设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the neighbor state is Init, the neighbor event 2-WayReceived is executed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果邻居状态为Init，则执行邻居事件2-WayReceived。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the MDR Level of the neighbor changed, the neighbor state machine is scheduled with the event AdjOK?.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果邻居的MDR级别已更改，则邻居状态机将使用事件AdjOK？进行调度？。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the neighbor&#39;s Child status has changed from 0 to 1, the neighbor state machine is scheduled with the event AdjOK?.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果邻居的子状态已从0更改为1，则邻居状态机将与事件AdjOK？一起调度？。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the neighbor&#39;s neighbor state changed from less than 2-Way to 2-Way or greater, the neighbor state machine is scheduled with the event AdjOK?.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果邻居的邻居状态从小于2路更改为2路或更大，则邻居状态机将使用事件AdjOK？进行调度？。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the Database Exchange optimization described in [RFC5243] SHOULD be performed as follows. If the router accepts a received DD packet as the next in sequence, the following additional step should be performed for each LSA listed in the DD packet (whether the router is master or slave). If the Database summary list contains an instance of the LSA that is the same as or less recent than the listed LSA, the LSA is removed from the Database summary list. This avoids listing the LSA in a DD packet sent to the neighbor, when the neighbor already has an instance of the LSA that is the same or more recent. This optimization reduces overhead due to DD packets by approximately 50% in large networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，[RFC5243]中描述的数据库交换优化应按如下方式执行。如果路由器接受接收到的DD数据包作为下一个序列，则应对DD数据包中列出的每个LSA执行以下附加步骤（无论路由器是主路由器还是从路由器）。如果数据库摘要列表包含与列出的LSA相同或不太新的LSA实例，则会从数据库摘要列表中删除LSA。这样可以避免在发送给邻居的DD数据包中列出LSA，而邻居已经拥有相同或更近的LSA实例。在大型网络中，这种优化可将DD数据包带来的开销减少约50%。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Flooding Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 注水程序
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section specifies the changes to [RFC2328], Section 13, for routers that support OSPF-MDR. The first part of Section 13 (before Section 13.1) is the same except for the following three changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节规定了支持OSPF-MDR的路由器对[RFC2328]第13节的更改。第13节的第一部分（在第13.1节之前）与第13节相同，但以下三个变化除外。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To exploit the broadcast nature of MANETs, if the Link State Update (LSU) packet was received on a MANET interface, then the packet is dropped without further processing only if the sending neighbor is in a lesser state than 2-Way. Otherwise, the LSU packet is processed as described in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 为了利用MANET的广播特性，如果在MANET接口上接收到链路状态更新（LSU）数据包，则仅当发送邻居的状态低于双向时，该数据包才被丢弃而无需进一步处理。否则，LSU分组按照本节中的描述进行处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the received LSA is the same instance as the database copy, the following actions are performed in addition to Step 7. For each MANET interface for which a BackupWait Neighbor List exists for the LSA (see Section 8.1):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果收到的LSA与数据库副本是同一实例，则除了步骤7之外，还将执行以下操作。对于存在LSA备份等待邻居列表的每个MANET接口（见第8.1节）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) Remove the sending neighbor from the BackupWait Neighbor List if it belongs to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) 如果发送邻居属于BackupWait邻居列表，请将其从该列表中删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) For each neighbor on the receiving interface that belongs to the BNS for the sending neighbor, remove the neighbor from the BackupWait Neighbor List if it belongs to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) 对于接收接口上属于发送邻居的BNS的每个邻居，如果该邻居属于该列表，则将其从BackupWait邻居列表中删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Step 8, which handles the case in which the database copy of the LSA is more recent than the received LSA, is modified as follows. If the sending neighbor is in a lesser state than Exchange, then the router does not send the LSA back to the sending neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 步骤8处理LSA的数据库副本比接收到的LSA更新的情况，修改如下。如果发送邻居的状态低于Exchange，则路由器不会将LSA发送回发送邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are no changes to Sections 13.1, 13.2, or 13.4. The following subsections describe the changes to Sections 13.3 (Next step in the flooding procedure), 13.5 (Sending Link State Acknowledgments), 13.6 (Retransmitting LSAs), and 13.7 (Receiving Link State Acknowledgments) of [RFC2328].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第13.1、13.2或13.4节无任何变更。以下小节描述了[RFC2328]第13.3节（泛洪程序的下一步）、第13.5节（发送链路状态确认）、第13.6节（重传LSA）和第13.7节（接收链路状态确认）的更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. LSA Forwarding Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. LSA转发过程
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a new LSA is received, Steps 1 through 5 of [RFC2328], Section 13.3, are performed without modification for each eligible (outgoing) interface that is not of type MANET. This section specifies the modified steps that must be performed for each eligible MANET interface. The eligible interfaces depend on the LSA&#39;s flooding scope as described in [RFC5340], Section 4.5.2. Whenever an LSA is flooded out a MANET interface, it is included in an LSU packet that is sent to the multicast address AllSPFRouters. (Retransmitted LSAs are always unicast, as specified in Section 8.3.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收到新的LSA时，第13.3节[RFC2328]的步骤1至5将在不修改每个不属于MANET类型的合格（传出）接口的情况下执行。本节规定了每个符合条件的MANET接口必须执行的修改步骤。合格接口取决于LSA的泛洪范围，如[RFC5340]第4.5.2节所述。每当一个LSA从MANET接口溢出时，它就会包含在一个LSU数据包中，该数据包被发送到多播地址AllsFrouters。（如第8.3节所述，重传的LSA始终为单播。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 1 of [RFC2328], Section 13.3, is performed for each eligible MANET interface with the following modification, so that the new LSA is placed on the Link State retransmission list for each appropriate adjacent neighbor. Step 1c is replaced with the following action, so that the LSA is not placed on the retransmission list for a neighbor that has already acknowledged the LSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2328]第13.3节的步骤1针对每个合格的MANET接口执行，并进行以下修改，以便将新的LSA放置在每个适当相邻邻居的链路状态重传列表中。步骤1c替换为以下操作，使得LSA不被置于已经确认LSA的邻居的重传列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the new LSA was received from this neighbor, or a Link State Acknowledgment (LS Ack) for the new LSA has already been received from this neighbor, examine the next neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果从该邻居接收到新LSA，或者已经从该邻居接收到新LSA的链路状态确认（LS Ack），请检查下一个邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine whether an Ack for the new LSA has been received from the neighbor, the router maintains an Acked LSA List for each adjacent neighbor, as described in Section 8.4. When a new LSA is received, the Acked LSA List for each neighbor, on each MANET interface, should be updated by removing any LS Ack that is for an older instance of the LSA than the one received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第8.4节所述，为了确定是否已从邻居接收到新LSA的Ack，路由器为每个相邻邻居维护一个Ack LSA列表。当接收到新的LSA时，每个MANET接口上每个邻居的已确认LSA列表应通过删除比接收到的LSA实例旧的LSA实例的任何LS Ack来更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following description will use the notion of a &#34;covered&#34; neighbor. A neighbor k is defined to be covered if the LSA was sent as a multicast by a MANET neighbor j, and neighbor k belongs to the Bidirectional Neighbor Set (BNS) for neighbor j. A neighbor k is also defined to be covered if the LSA was sent to the multicast address AllSPFRouters by a neighbor j on a broadcast interface on which both j and k are neighbors. (Note that j must be the DR or Backup DR for the broadcast network, since only these routers may send LSAs to AllSPFRouters on a broadcast network.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面的描述将使用“覆盖”邻居的概念。如果LSA是由MANET邻居j作为多播发送的，则邻居k被定义为被覆盖，并且邻居k属于邻居j的双向邻居集（BNS）。如果LSA由j和k都是邻居的广播接口上的邻居j发送到多播地址AllSPFRouters，则邻居k也被定义为被覆盖。（请注意，j必须是广播网络的DR或备份DR，因为只有这些路由器可以向广播网络上的所有SPFROUTER发送LSA。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following steps must be performed for each eligible MANET interface, to determine whether the new LSA should be forwarded on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须对每个合格的MANET接口执行以下步骤，以确定是否应在接口上转发新的LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) If every bidirectional neighbor on the interface satisfies at least one of the following three conditions, examine the next interface (the LSA is not flooded out this interface).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 如果接口上的每个双向邻居至少满足以下三个条件之一，则检查下一个接口（LSA不会淹没此接口）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) The LSA was received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) 从邻居那里收到了LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) The LSA was received on a MANET or broadcast interface and the neighbor is covered (defined above).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) LSA是在MANET或广播接口上接收的，邻居被覆盖（定义见上文）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(c) An Ack for the LSA has been received from the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(c) 已从邻居接收到LSA的Ack。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Condition (c) MAY be omitted (thus ignoring Acks) in order to simplify this step. Note that the above conditions do not assume the outgoing interface is the same as the receiving interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
为了简化该步骤，可以省略条件（c）（从而忽略Acks）。请注意，上述条件并不假定传出接口与接收接口相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) If the LSA was received on this interface, and the router is an MDR Other for this interface, examine the next interface (the LSA is not flooded out this interface).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 如果在该接口上接收到LSA，并且路由器是该接口的另一个MDR，则检查下一个接口（LSA不会淹没该接口）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) If the LSA was received on this interface, and the router is a Backup MDR or a non-flooding MDR for this interface, then the router waits BackupWaitInterval before deciding whether to flood the LSA. To accomplish this, the router creates a BackupWait Neighbor List for the LSA, which initially includes every bidirectional neighbor on this interface that does not satisfy any of the conditions in Step 2. A single-shot BackupWait Timer associated with the LSA is started, which is set to expire after BackupWaitInterval seconds plus a small amount of random jitter. (The actions performed when the BackupWait Timer expires are described below in Section 8.1.2.) Examine the next interface (the LSA is not yet flooded out this interface).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 如果在此接口上接收到LSA，并且路由器是此接口的备份MDR或非泛洪MDR，则路由器在决定是否泛洪LSA之前等待BackupWaitInterval。为了实现这一点，路由器为LSA创建一个BackupWait邻居列表，该列表最初包括该接口上不满足步骤2中任何条件的每个双向邻居。启动与LSA相关联的单次回程回程计时器，该计时器设置为在回程回程间隔秒加上少量随机抖动后过期。（BackupWait计时器到期时执行的操作将在下文第8.1.2节中描述。）检查下一个接口（LSA尚未淹没此接口）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) If the router is a flooding MDR for this interface, or if the LSA was originated by the router itself, then the LSA is flooded out the interface (whether or not the LSA was received on this interface) and the next interface is examined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) 如果路由器是此接口的泛洪MDR，或者如果LSA是由路由器本身发起的，则LSA将泛洪出接口（无论此接口上是否接收到LSA），并检查下一个接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) If the LSA was received on a MANET or broadcast interface that is different from this (outgoing) interface, then the following two steps SHOULD be performed to avoid redundant flooding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) 如果LSA是在与此（传出）接口不同的MANET或广播接口上接收的，则应执行以下两个步骤以避免冗余泛洪。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) If the router has a larger value of (RtrPri, MDR Level, RID) on the outgoing interface than every covered neighbor (defined above) that is a neighbor on BOTH the receiving and outgoing interfaces (or if no such neighbor exists), then the LSA is flooded out the interface and the next interface is examined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) 如果路由器在输出接口上的值（RtrPri、MDR Level、RID）大于作为接收和输出接口上的邻居的每个覆盖邻居（定义见上文）（或者如果不存在这样的邻居），则LSA从接口中溢出，并检查下一个接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) Else, the router waits BackupWaitInterval before deciding whether to flood the LSA on the interface, by performing the actions in Step 4 for a Backup MDR (whether or not the router is a Backup MDR on this interface). A separate BackupWait
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) 否则，路由器将等待BackupWaitInterval，然后再决定是否在接口上使用LSA，方法是执行步骤4中针对备份MDR的操作（无论路由器是否是此接口上的备份MDR）。单独的后场
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Neighbor List is created for each MANET interface, but only one BackupWait Timer is associated with the LSA. Examine the next interface (the LSA is not yet flooded out this interface).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
为每个MANET接口创建邻居列表，但只有一个BackupWait计时器与LSA关联。检查下一个接口（LSA尚未淹没此接口）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) If this step is reached, the LSA is flooded out the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) 如果达到此步骤，LSA将从接口中溢出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. Note on Step 6 of LSA Forwarding Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. 关于LSA转发程序步骤6的说明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Performing the optional Step 6 can greatly reduce flooding overhead if the LSA was received on a MANET or broadcast interface. For example, assume that the LSA was received from the DR of a broadcast network that includes 100 routers, and 50 of the routers (not including the DR) are also attached to a MANET. Assume that these 50 routers are neighbors of each other in the MANET and that each has a neighbor in the MANET that is not attached to the broadcast network (and is therefore not covered). Then by performing Step 6 of the LSA forwarding procedure, the number of routers that forward the LSA from the broadcast network to the MANET is reduced from 50 to just 1 (assuming that at most 1 of the 50 routers is an MDR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在MANET或广播接口上接收LSA，则执行可选步骤6可以大大减少泛洪开销。例如，假设LSA是从包括100个路由器的广播网络的DR接收的，并且50个路由器（不包括DR）也连接到MANET。假设这50个路由器是MANET中彼此的邻居，并且每个路由器在MANET中都有一个未连接到广播网络的邻居（因此未被覆盖）。然后，通过执行LSA转发过程的步骤6，将LSA从广播网络转发到MANET的路由器的数量从50个减少到仅1个（假设50个路由器中最多有1个是MDR）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. BackupWait Timer Expiration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. 备份等待计时器过期
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the BackupWait Timer for an LSA expires, then the following steps are performed for each (MANET) interface for which a BackupWait Neighbor List exists for the LSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LSA的BackupWait计时器过期，则对存在LSA BackupWait邻居列表的每个（MANET）接口执行以下步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) If the BackupWait Neighbor List for the interface contains at least one router that is currently a bidirectional neighbor, the following actions are performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 如果接口的BackupWait邻居列表包含至少一个当前为双向邻居的路由器，则执行以下操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) The LSA is flooded out the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(a) LSA从接口中溢出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) If the LSA is on the Ack List for the interface (i.e., is scheduled to be included in a delayed Link State Acknowledgment packet), then the router SHOULD remove the LSA from the Ack List, since the flooded LSA will be treated as an implicit Ack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(b) 如果LSA在接口的Ack列表上（即，计划包含在延迟链路状态确认包中），则路由器应从Ack列表中删除LSA，因为泛洪LSA将被视为隐式Ack。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(c) If the LSA is on the Link State retransmission list for any neighbor, the retransmission SHOULD be rescheduled to occur after RxmtInterval seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(c) 如果LSA位于任何邻居的链路状态重传列表上，则应重新安排重传，使其在RxmtInterval秒后发生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) The BackupWait Neighbor List is then deleted (whether or not the LSA is flooded).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 然后删除BackupWait邻居列表（无论LSA是否被淹没）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Sending Link State Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 发送链路状态确认
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the procedure for sending Link State Acknowledgments (LS Acks) on MANET interfaces. Section 13.5 of [RFC2328] remains unchanged for non-MANET interfaces, but does not apply to MANET interfaces. To minimize overhead due to LS Acks, and to take advantage of the broadcast nature of MANETs, all LS Ack packets sent on a MANET interface are multicast using the IP address AllSPFRouters. In addition, duplicate LSAs received as a multicast are not acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节描述在MANET接口上发送链路状态确认（LS确认）的过程。[RFC2328]第13.5节对非MANET接口保持不变，但不适用于MANET接口。为了最大限度地减少LS Ack造成的开销，并利用MANET的广播特性，在MANET接口上发送的所有LS Ack数据包都是使用IP地址AllsFrouters进行多播的。此外，不会确认作为多播接收的重复LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a router receives an LSA, it must decide whether to send a delayed Ack, an immediate Ack, or no Ack. The interface parameter AckInterval is the interval between LS Ack packets when only delayed Acks need to be sent. A delayed Ack SHOULD be delayed by at least (RxmtInterval - AckInterval - 0.5) seconds and at most (RxmtInterval - 0.5) seconds after the LSA instance being acknowledged was first received. If AckInterval and RxmtInterval are equal to their default values of 1 and 7 seconds, respectively, this reduces Ack traffic by increasing the chance that a new instance of the LSA will be received before the delayed Ack is sent. An immediate Ack is sent immediately in a multicast LS Ack packet, which may also include delayed Acks that were scheduled to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器收到LSA时，它必须决定是发送延迟Ack、立即Ack还是不发送Ack。接口参数AckInterval是仅需要发送延迟Ack时LS Ack数据包之间的间隔。延迟的Ack应在第一次接收到被确认的LSA实例后至少延迟（RxmtInterval-ACKTERVAL-0.5）秒，最多延迟（RxmtInterval-0.5）秒。如果AckInterval和RxmtInterval分别等于它们的默认值1秒和7秒，这将通过增加在发送延迟的Ack之前接收LSA的新实例的机会来减少Ack流量。立即Ack在多播LS Ack数据包中立即发送，该数据包还可能包括预定发送的延迟Ack。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decision whether to send a delayed or immediate Ack depends on whether the received LSA is new (i.e., is more recent than the database copy) or a duplicate (the same instance as the database copy), and on whether the LSA was received as a multicast or a unicast (which indicates a retransmitted LSA). The following rules are used to make this decision.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送延迟或立即Ack的决定取决于接收到的LSA是新的（即，比数据库副本更新）还是重复的（与数据库副本相同的实例），以及LSA是作为多播还是单播接收的（这表示重新传输的LSA）。以下规则用于做出此决定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) If the received LSA is new, a delayed Ack is sent on each MANET interface associated with the area, unless the LSA is flooded out the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 如果接收到的LSA是新的，则在与该区域相关联的每个MANET接口上发送延迟Ack，除非LSA从接口中溢出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) If the LSA is a duplicate and was received as a multicast, the LSA is not acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 如果LSA是重复的，并且作为多播接收，则不会确认LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) If the LSA is a duplicate and was received as a unicast:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 如果LSA是重复的，并且作为单播接收：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) If the router is an MDR, or AdjConnectivity = 2 and the router is a Backup MDR, or AdjConnectivity = 0, then an immediate Ack is sent out the receiving interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) 如果路由器是MDR，或AdjConnectivity=2，而路由器是备份MDR，或AdjConnectivity=0，则立即向接收接口发送Ack。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) Otherwise, a delayed Ack is sent out the receiving interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) 否则，将向接收接口发送延迟Ack。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reason that (Backup) MDRs send an immediate Ack when a retransmitted LSA is received is to try to prevent other adjacent neighbors from retransmitting the LSA, since (Backup) MDRs usually have a large number of adjacent neighbors. MDR Other routers do not send an immediate Ack (unless AdjConnectivity = 0) because they have fewer adjacent neighbors, and so the potential benefit does not justify the additional overhead resulting from sending immediate Acks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收到重新传输的LSA时，（备份）MDR立即发送Ack的原因是试图阻止其他相邻邻居重新传输LSA，因为（备份）MDR通常有大量相邻邻居。MDR其他路由器不发送即时Ack（除非AdjConnectivity=0），因为它们的相邻邻居较少，因此潜在的好处并不能证明发送即时Ack所产生的额外开销是合理的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Retransmitting LSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. 重传lsa
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LSAs are retransmitted according to Section 13.6 of [RFC2328]. Thus, LSAs are retransmitted only to adjacent routers. Therefore, since OSPF-MDR does not allow an adjacency to be formed between two MDR Other routers, an MDR Other never retransmits an LSA to another MDR Other, only to its Parents, which are (Backup) MDRs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据[RFC2328]第13.6节重新传输LSA。因此，lsa仅被重新传输到相邻路由器。因此，由于OSPF-MDR不允许在两个MDR-Other路由器之间形成邻接，所以MDR-Other从不将LSA重新传输给另一个MDR-Other，仅传输给其父级（备份）MDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retransmitted LSAs are included in LSU packets that are unicast directly to an adjacent neighbor that did not acknowledge the LSA (explicitly or implicitly). The length of time between retransmissions is given by the configurable interface parameter RxmtInterval, whose default is 7 seconds for a MANET interface. To reduce overhead, several retransmitted LSAs should be included in a single LSU packet whenever possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重传的LSA包括在LSU数据包中，该数据包直接单播到未确认LSA（显式或隐式）的相邻邻居。重新传输之间的时间长度由可配置的接口参数RxmtInterval给出，对于MANET接口，其默认值为7秒。为了减少开销，应尽可能在单个LSU数据包中包含多个重新传输的LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. Receiving Link State Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4. 接收链路状态确认
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Link State Acknowledgment (LS Ack) packet that is received from an adjacent neighbor (in state Exchange or greater) is processed as described in Section 13.7 of [RFC2328], with the additional steps described in this section. An LS Ack packet that is received from a neighbor in a lesser state than Exchange is discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
按照[RFC2328]第13.7节所述处理从相邻邻居（状态交换或更高）接收的链路状态确认（LS Ack）数据包，并执行本节所述的附加步骤。从邻居接收的状态低于Exchange的LS Ack数据包将被丢弃。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each router maintains an Acked LSA List for each adjacent neighbor, to keep track of any LSA instances the neighbor has acknowledged but that the router itself has NOT yet received. This is necessary because (unlike [RFC2328]) each router acknowledges an LSA only the first time it is received as a multicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个路由器为每个相邻的邻居维护一个已确认的LSA列表，以跟踪邻居已确认但路由器本身尚未接收的任何LSA实例。这是必要的，因为（与[RFC2328]不同），每个路由器仅在第一次将LSA作为多播接收时才确认LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the neighbor from which the LS Ack packet was received is in state Exchange or greater, then the following steps are performed for each LS Ack in the received LS Ack packet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果接收到LS Ack数据包的邻居处于状态交换或更高，则对接收到的LS Ack数据包中的每个LS Ack执行以下步骤：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) If the router does not have a database copy of the LSA being acknowledged, or has a database copy that is less recent than the one being acknowledged, the LS Ack is added to the Acked LSA List for the sending neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 如果路由器没有正在确认的LSA的数据库副本，或者有一个数据库副本比正在确认的数据库副本要短，则LS Ack将添加到发送邻居的已确认LSA列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) If the router has a database copy of the LSA being acknowledged, which is the same as the instance being acknowledged, then the following action is performed. For each MANET interface for which a BackupWait Neighbor List exists for the LSA (see Section 8.1), remove the sending neighbor from the BackupWait Neighbor List if it belongs to the list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 如果路由器有一个正在确认的LSA的数据库副本，这与正在确认的实例相同，则执行以下操作。对于存在LSA BackupWait邻居列表的每个MANET接口（参见第8.1节），如果发送邻居属于该列表，则将其从BackupWait邻居列表中删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Router-LSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 路由器LSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike the DR of an OSPF broadcast network, an MDR does not originate a network-LSA, since a network-LSA cannot be used to describe the general topology of a MANET. Instead, each router advertises a subset of its MANET neighbors as point-to-point links in its router-LSA. The choice of which MANET neighbors to include in the router-LSA is flexible. Whether or not adjacency reduction is used, the router can originate either partial-topology or full-topology LSAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与OSPF广播网络的DR不同，MDR不发起网络LSA，因为网络LSA不能用于描述MANET的一般拓扑。相反，每个路由器在其路由器LSA中作为点对点链路播发其MANET邻居的子集。在路由器LSA中包括哪些MANET邻居的选择是灵活的。无论是否使用邻接减少，路由器都可以发起部分拓扑或完全拓扑LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is used (AdjConnectivity is 1 or 2), then as a minimum requirement each router must advertise a minimum set of &#34;backbone&#34; neighbors in its router-LSA. This minimum choice corresponds to LSAFullness = 0, and results in the minimum amount of LSA flooding overhead, but does not provide routing along shortest paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用邻接减少（邻接连接为1或2），则作为最低要求，每个路由器必须在其路由器LSA中公布一组最小的“主干”邻居。此最小选择对应于LSAFullness=0，并导致最小的LSA泛洪开销，但不提供沿最短路径的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, to allow routers to calculate shortest paths, without requiring every pair of neighboring routers along the shortest paths to be adjacent (which would be inefficient due to requiring a large number of adjacencies), a router-LSA may also advertise non-adjacent neighbors that satisfy a synchronization condition described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，为了允许路由器计算最短路径，而不要求沿最短路径的每对相邻路由器相邻（这将由于需要大量相邻而效率低下），路由器LSA还可以通告满足下面描述的同步条件的非相邻邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To motivate this, we note that OSPF already allows a non-adjacent neighbor to be a next hop, if both the router and the neighbor belong to the same broadcast network (and are both adjacent to the DR). A network-LSA for a broadcast network (which includes all routers attached to the network) implies that any router attached to the network can forward packets directly to any other router attached to the network (which is why the distance from the network to all attached routers is zero in the graph representing the link-state database).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了激发这一点，我们注意到，如果路由器和邻居都属于同一广播网络（并且都与DR相邻），OSPF已经允许非相邻邻居成为下一跳。广播网络（包括连接到网络的所有路由器）的网络LSA意味着连接到网络的任何路由器都可以直接将数据包转发到连接到网络的任何其他路由器（这就是为什么在表示链路状态数据库的图中，从网络到所有连接路由器的距离为零）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a network-LSA cannot be used to describe the general topology of a MANET, the only way to advertise non-adjacent neighbors that can be used as next hops is to include them in the router-LSA. However, to ensure that such neighbors are sufficiently synchronized, only &#34;routable&#34; neighbors are allowed to be included in LSAs, and to be used as next hops in the SPF calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于网络LSA不能用于描述MANET的一般拓扑结构，因此宣传可用作下一跳的非相邻邻居的唯一方法是将它们包括在路由器LSA中。然而，为了确保这些邻居充分同步，只有“可路由”的邻居才允许包含在LSA中，并在SPF计算中用作下一跳。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Routable Neighbors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 可路由邻居
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is used, a bidirectional MANET neighbor becomes routable if the SPF calculation has found a route to the neighbor and the neighbor satisfies the routable neighbor quality condition (defined below). Since only routable and Full neighbors are advertised in router-LSAs, and since adjacencies are selected to form a connected spanning subgraph, this definition implies that there exists, or recently existed, a path of full adjacencies from the router to the routable neighbor. The idea is that, since a routable neighbor can be reached through an acceptable path, it makes sense to take a &#34;shortcut&#34; and forward packets directly to the routable neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用邻接减少，则如果SPF计算发现到邻居的路由并且邻居满足可路由邻居质量条件（定义如下），则双向MANET邻居成为可路由的。由于在路由器LSA中仅通告可路由和完全邻居，并且由于选择邻接以形成连接的生成子图，该定义意味着存在或最近存在从路由器到可路由邻居的完全邻接路径。其思想是，由于可以通过可接受的路径到达可路由的邻居，因此采取“快捷方式”并将数据包直接转发给可路由的邻居是有意义的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This requirement does not guarantee perfect synchronization, but simulations have shown that it performs well in mobile networks. This requirement avoids, for example, forwarding packets to a new neighbor that is poorly synchronized because it was not reachable before it became a neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这一要求并不能保证完美的同步，但仿真表明它在移动网络中表现良好。例如，此要求可避免将数据包转发给同步性差的新邻居，因为它在成为邻居之前无法访问。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid selecting poor-quality neighbors as routable neighbors, a neighbor that is selected as a routable neighbor must satisfy the routable neighbor quality condition. By default, this condition is that the neighbor&#39;s BNS must include the router itself (indicating that the neighbor agrees the connection is bidirectional). Optionally, a router may impose a stricter condition. For example, a router may require that two Hellos have been received from the neighbor that (explicitly or implicitly) indicate that the neighbor&#39;s BNS includes the router itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了避免选择质量差的邻居作为可路由邻居，被选为可路由邻居的邻居必须满足可路由邻居质量条件。默认情况下，此条件是邻居的BNS必须包括路由器本身（表示邻居同意连接是双向的）。可选地，路由器可以施加更严格的条件。例如，路由器可能要求从邻居接收到两个hello（显式或隐式）指示邻居的bn包括路由器本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single-bit neighbor variable Routable indicates whether the neighbor is routable, and is initially set to 0. If adjacency reduction is used, Routable is updated as follows when the state of the neighbor changes, or the SPF calculation finds a route to the neighbor, or a Hello is received that affects the routable neighbor quality condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单位邻居变量Routable指示邻居是否可路由，并最初设置为0。如果使用邻接减少，则当邻居的状态发生变化时，或者SPF计算发现到邻居的路由，或者接收到影响可路由邻居质量条件的Hello时，可路由将按如下方式更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) If Routable is 0 for the neighbor, the state of the neighbor is 2-Way or greater, there exists a route to the neighbor, and the routable neighbor quality condition (defined above) is satisfied, then Routable is set to 1 for the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 如果邻居的Routable为0，邻居的状态为双向或更高，存在到邻居的路由，并且满足可路由邻居质量条件（定义见上文），则邻居的Routable设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) If Routable is 1 for the neighbor and the state of the neighbor is less than 2-Way, Routable is set to 0 for the neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 如果邻居的Routable为1，且邻居的状态小于双向，则邻居的Routable设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is not used (AdjConnectivity = 0), then routable neighbors are not computed and the set of routable neighbors remains empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果未使用邻接减少（邻接连接性=0），则不计算可路由邻居，且可路由邻居集保持为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Backbone Neighbors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 骨干邻居
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flexible choice for the router-LSA is made possible by defining two types of neighbors that are included in the router-LSA: backbone neighbors and Selected Advertised Neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过定义路由器LSA中包括的两种类型的邻居，可以灵活地选择路由器LSA：主干邻居和选定的播发邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is used, a bidirectional neighbor is defined to be a backbone neighbor if and only if it satisfies the condition for becoming adjacent (see Section 7.2). If adjacency reduction is not used (AdjConnectivity = 0), a bidirectional neighbor is a backbone neighbor if and only if the neighbor&#39;s A-bit is 0 (indicating that the neighbor is using adjacency reduction). This definition allows the interoperation between routers that use adjacency reduction and routers that do not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用邻接减少，则当且仅当双向邻居满足成为相邻的条件时，才将其定义为骨干邻居（参见第7.2节）。如果未使用邻接减少（邻接连接性=0），则当且仅当邻居的a位为0（表示邻居正在使用邻接减少）时，双向邻居才是骨干邻居。此定义允许使用邻接减少的路由器和不使用邻接减少的路由器之间的互操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is used, then a router MUST include in its router-LSA all Full neighbors and all routable backbone neighbors. A minimal LSA, corresponding to LSAFullness = 0, includes only these neighbors. This choice guarantees connectivity, but does not ensure shortest paths. However, this choice is useful in large networks to achieve maximum scalability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用邻接减少，则路由器必须在其路由器LSA中包含所有完整邻居和所有可路由主干邻居。与LSAFullness=0相对应的最小LSA仅包括这些邻居。这种选择可以保证连接性，但不能确保最短路径。但是，这种选择在大型网络中非常有用，可以实现最大的可伸缩性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Selected Advertised Neighbors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. 选定的广告邻居
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow flexibility while ensuring that router-LSAs are symmetric (i.e., router i advertises a link to router j if and only if router j advertises a link to router i), each router maintains a Selected Advertised Neighbor set (SANS), which consists of MANET neighbors that the router has selected to advertise in its router-LSA, not including backbone neighbors. Since the SANS does not include backbone neighbors (and thus Dependent Neighbors), the SANS and DNS are disjoint. Both of these neighbor sets are advertised in Hellos.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了在确保路由器LSA对称的同时允许灵活性（即，当且仅当路由器j播发到路由器i的链路时，路由器i播发到路由器j的链路），每个路由器维护一个选定的播发邻居集（SAN），该邻居集由路由器选择在其路由器LSA中播发的MANET邻居组成，不包括骨干邻居。由于SAN不包括主干邻居（因此也不包括从属邻居），因此SAN和DNS是不相交的。这两个相邻集都在Hellos中公布。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If LSAFullness is 0 (minimal LSAs), then the SANS is empty. At the other extreme, if LSAFullness is 4 (full-topology LSAs), the SANS includes all bidirectional MANET neighbors except backbone neighbors. In between these two extremes, a router that is using adjacency reduction may select any subset of bidirectional non-backbone neighbors as its SANS. The resulting router-LSA is constructed as specified in Section 9.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LSAFullness为0（最小LSA），则SAN为空。在另一个极端，如果LSAFullness为4（全拓扑lsa），则SANS包括除骨干网邻居之外的所有双向MANET邻居。在这两个极端之间，使用邻接减少的路由器可以选择双向非主干邻居的任何子集作为其SAN。产生的路由器LSA按照第9.4节的规定构造。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since a router that is not using adjacency reduction typically has no backbone neighbors (unless it has neighbors that are using adjacency reduction), to ensure connectivity, such a router must choose its SANS to contain the SANS corresponding to LSAFullness = 1. Thus, if AdjConnectivity is 0 (no adjacency reduction), then LSAFullness must be 1, 2, or 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于不使用邻接减少的路由器通常没有主干网邻居（除非它有使用邻接减少的邻居），为了确保连接性，这样的路由器必须选择其SAN以包含对应于LSAFullness=1的SAN。因此，如果邻接连接性为0（无邻接减少），则LSAFullness必须为1、2或4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If LSAFullness is 1, the router originates min-cost LSAs, which are partial-topology LSAs that (when flooded) provide each router with sufficient information to calculate a shortest (minimum-cost) path to each destination. Appendix C describes the algorithm for selecting the neighbors to include in the SANS that results in min-cost LSAs. The input to this algorithm includes information obtained from Hellos received from each MANET neighbor, including the neighbor&#39;s Bidirectional Neighbor Set (BNS), Dependent Neighbor Set (DNS), Selected Advertised Neighbor Set (SANS), and the Metric TLV. The Metric TLV, specified in Section A.2.5, is appended to each Hello (unless all link costs are 1) to advertise the link cost to each bidirectional neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LSAFullness为1，则路由器生成最小成本lsa，这是局部拓扑lsa（在被淹没时）为每个路由器提供足够的信息，以计算到每个目的地的最短（最小成本）路径。附录C描述了选择要包含在SAN中的邻居的算法，该算法将产生最小成本LSA。该算法的输入包括从每个MANET邻居接收的HELOS中获得的信息，包括邻居的双向邻居集（BNS）、从属邻居集（DNS）、所选播发邻居集（SAN）和度量TLV。第A.2.5节中规定的度量TLV附加到每个Hello（除非所有链路成本为1），以向每个双向邻居公布链路成本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If LSAFullness is 2, the SANS must be selected to be a superset of the SANS corresponding to LSAFullness = 1. This choice provides shortest-path routing while allowing the router to advertise additional neighbors to provide redundant routes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LSAFullness为2，则必须选择SAN作为与LSAFullness=1对应的SAN的超集。此选项提供最短路径路由，同时允许路由器公布其他邻居以提供冗余路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If LSAFullness is 3, each MDR originates a full-topology LSA (which includes all Full and routable neighbors), while each non-MDR router originates a minimal LSA. If the router has multiple MANET interfaces, the router-LSA includes all Full and routable neighbors on each interface for which it is an MDR, and advertises only Full neighbors and routable backbone neighbors on its other interfaces. This choice provides routing along nearly shortest paths with relatively low overhead.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LSAFullness为3，则每个MDR生成一个完整拓扑LSA（包括所有完整和可路由的邻居），而每个非MDR路由器生成一个最小LSA。如果路由器具有多个MANET接口，则路由器LSA在其作为MDR的每个接口上包括所有完整的和可路由的邻居，并且在其其他接口上仅播发完整的邻居和可路由的主干邻居。这种选择提供了沿几乎最短路径的路由，开销相对较低。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although this document specifies a few choices of the SANS, which correspond to different values of LSAFullness, it is important to note that other choices are possible. In addition, it is not necessary for different routers to choose the same value of LSAFullness. The different choices are interoperable because they all require the router-LSA to include a minimum set of neighbors, and because the construction of the router-LSA (described below) ensures that the router-LSAs originated by different routers are consistent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管本文档指定了一些SAN选项，这些选项对应于不同的LSAFULNESS值，但需要注意的是，其他选项也是可能的。此外，不同的路由器不必选择相同的LSAFullness值。不同的选择是可互操作的，因为它们都要求路由器LSA包括一组最小的邻居，并且因为路由器LSA的构造（如下所述）确保由不同路由器发起的路由器LSA是一致的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Originating Router-LSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. 始发路由器LSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a new router-LSA is originated, it includes a point-to-point (type 1) link for each MANET neighbor that is advertised. The set of neighbors to be advertised is determined as follows. If adjacency reduction is used, the router advertises all Full neighbors, and advertises each routable neighbor j that satisfies any of the following three conditions. If adjacency reduction is not used (AdjConnectivity = 0), the router advertises each Full neighbor j that satisfies any of the following three conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当一个新的路由器LSA被发起时，它包括一个用于每个被广告的MANET邻居的点对点（类型1）链路。要通告的邻居集确定如下。如果使用邻接减少，路由器播发所有完整邻居，并播发满足以下三个条件之一的每个可路由邻居j。如果未使用邻接减少（邻接连接性=0），路由器播发满足以下三个条件之一的每个完整邻居j。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) The router&#39;s SANS (for any interface) includes j.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 路由器的SAN（用于任何接口）包括j。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) Neighbor j&#39;s SANS includes the router (to ensure symmetry).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 邻居j的SAN包括路由器（以确保对称性）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) Neighbor j is a backbone neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 邻居j是骨干邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that backbone neighbors and neighbors in the SANS need not be routable or Full, but only routable and Full neighbors may be included in the router-LSA. This is done so that the SANS, which is advertised in Hellos, does not depend on routability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，SAN中的主干邻居和邻居不需要是可路由的或完全的，但路由器LSA中只能包括可路由的和完全的邻居。这样做是为了使在Hello中公布的SAN不依赖于可路由性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The events that cause a new router-LSA to be originated are the same as in [RFC2328] and [RFC5340] except that a MANET neighbor changing to/from the Full state does not always cause a new router-LSA to be originated. Instead, a new router-LSA is originated whenever a change occurs that causes any of the following three conditions to occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
导致新路由器LSA被发起的事件与[RFC2328]和[RFC5340]中的相同，只是MANET邻居改变为/从完全状态改变并不总是导致新路由器LSA被发起。相反，每当发生导致以下三种情况之一的变化时，就会产生一个新的路由器LSA：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There exists a MANET neighbor j that satisfies the above conditions for inclusion in the router-LSA, but is not included in the current router-LSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 存在满足上述条件以包括在路由器LSA中但不包括在当前路由器LSA中的MANET邻居j。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The current router-LSA includes a MANET neighbor that is no longer bidirectional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当前路由器LSA包括不再是双向的MANET邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The link metric has changed for a MANET neighbor that is included in the current router-LSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当前路由器LSA中包含的MANET邻居的链路度量已更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above conditions may be checked periodically just before sending each Hello, instead of checking them every time one of the neighbor sets changes. The following implementation was found to work well. Just before sending each Hello, and whenever a bidirectional neighbor transitions to less than 2-Way, the router runs the MDR selection algorithm; updates its adjacencies, routable neighbors, and Selected Advertised Neighbors; then checks the above conditions to see if a new router-LSA should be originated. In addition, if a neighbor becomes bidirectional or Full, the router updates its routable neighbors and checks the above conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在发送每个Hello之前，可以定期检查上述条件，而不是每次邻居集合中的一个发生变化时都检查它们。发现以下实现运行良好。在发送每个Hello之前，每当双向邻居转换到少于2路时，路由器运行MDR选择算法；更新其邻接、可路由邻居和选定的播发邻居；然后检查上述条件，以确定是否应发起新的路由器LSA。此外，如果邻居变为双向或满，路由器将更新其可路由邻居并检查上述条件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Calculating the Routing Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 计算路由表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The routing table calculation is the same as specified in [RFC2328], except for the following changes to Section 16.1 (Calculating the shortest-path tree for an area). If full-topology adjacencies and full-topology LSAs are used (AdjConnectivity = 0 and LSAFullness = 4), there is no change to Section 16.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由表计算与[RFC2328]中规定的相同，但第16.1节（计算区域的最短路径树）中的以下更改除外。如果使用全拓扑邻接和全拓扑LSA（邻接连接性=0，LSAFullness=4），则第16.1节没有变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is used (AdjConnectivity is 1 or 2), then Section 16.1 is modified as follows. Recall from Section 9 that a router can use any routable neighbor as a next hop to a destination,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用邻接减少（邻接连接为1或2），则第16.1节修改如下。回想第9节，路由器可以使用任何可路由邻居作为到达目的地的下一跳，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
whether or not the neighbor is advertised in the router-LSA. This is accomplished by modifying Step 2 so that the router-LSA associated with the root vertex is replaced with a dummy router-LSA that includes links to all Full neighbors and all routable MANET neighbors. In addition, Step 2b (checking for a link from W back to V) MUST be skipped when V is the root vertex and W is a routable MANET neighbor. However, Step 2b must still be executed when V is not the root vertex, to ensure compatibility with OSPFv3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
是否在路由器LSA中通告邻居。这是通过修改步骤2来实现的，以便将与根顶点相关联的路由器LSA替换为虚拟路由器LSA，该虚拟路由器LSA包括到所有完整邻居和所有可路由MANET邻居的链路。此外，当V是根顶点且W是可路由MANET邻居时，必须跳过步骤2b（检查从W返回到V的链路）。但是，当V不是根顶点时，仍然必须执行步骤2b，以确保与OSPFv3兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If LSAFullness is 0 (minimal LSAs), then the calculated paths need not be shortest paths. In this case, the path actually taken by a packet can be shorter than the calculated path, since intermediate routers may have routable neighbors that are not advertised in any router-LSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LSAFullness为0（最小lsa），则计算的路径不必是最短路径。在这种情况下，数据包实际采用的路径可能比计算出的路径短，因为中间路由器可能具有不在任何路由器LSA中通告的可路由邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If full-topology adjacencies and partial-topology LSAs are used, then Section 16.1 is modified as follows. Step 2 is modified so that the router-LSA associated with the root vertex is replaced with a dummy router-LSA that includes links to all Full neighbors. In addition, Step 2b MUST be skipped when V is the root vertex and W is a Full MANET neighbor. (This is necessary since the neighbor&#39;s router-LSA need not contain a link back to the router.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用全拓扑邻接和部分拓扑LSA，则第16.1节修改如下。修改步骤2，以便将与根顶点关联的路由器LSA替换为虚拟路由器LSA，该虚拟路由器LSA包括到所有完整邻居的链接。此外，当V是根顶点且W是完全MANET邻居时，必须跳过步骤2b。（这是必要的，因为邻居的路由器LSA不需要包含回路由器的链路。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If adjacency reduction is used with partial-topology LSAs, then the set of routable neighbors can change without causing the contents of the router-LSA to change. This could happen, for example, if a routable neighbor that was not included in the router-LSA transitions to the Down or Init state. Therefore, if the set of routable neighbors changes, the shortest-path tree must be recalculated, even if the router-LSA does not change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果邻接减少用于局部拓扑LSA，则可路由邻居集可以更改，而不会导致路由器LSA的内容更改。例如，如果路由器LSA中不包含的可路由邻居转换为关闭或初始化状态，则可能发生这种情况。因此，如果可路由邻居集发生变化，即使路由器LSA没有变化，也必须重新计算最短路径树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the shortest-path tree and routing table are calculated, the set of routable neighbors must be updated, since a route to a non-routable neighbor may have been discovered. If the set of routable neighbors changes, then the shortest-path tree and routing table must be calculated a second time. The second calculation will not change the set of routable neighbors again, so two calculations are sufficient. If the set of routable neighbors is updated periodically every HelloInterval seconds, then it is not necessary to update the set of routable neighbors immediately after the routing table is updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在计算最短路径树和路由表之后，必须更新可路由邻居集，因为可能已经发现了到不可路由邻居的路由。如果可路由邻居集发生变化，则必须再次计算最短路径树和路由表。第二次计算不会再次更改可路由邻居集，因此两次计算就足够了。如果每HelloInterval秒定期更新一组可路由邻居，则无需在更新路由表后立即更新该组可路由邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with OSPFv3 [RFC5340], OSPF-MDR can use the IPv6 Authentication Header (AH) [RFC4302] and/or the IPv6 Encapsulation Security Payload (ESP) [RFC4303] to provide authentication, integrity, and/or confidentiality. The use of AH and ESP for OSPFv3 is described in [RFC4552].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与OSPFv3[RFC5340]一样，OSPF-MDR可以使用IPv6身份验证头（AH）[RFC4302]和/或IPv6封装安全负载（ESP）[RFC4303]来提供身份验证、完整性和/或机密性。[RFC4552]中描述了AH和ESP在OSPFv3中的使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generic threats to routing protocols are described and categorized in [RFC4593]. The mechanisms described in [RFC4552] provide protection against many of these threats, but not all of them. In particular, as mentioned in [RFC5340], these mechanisms do not provide protection against compromised, malfunctioning, or misconfigured routers (also called Byzantine routers); this is true for both OSPFv3 and OSPF-MDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4593]对路由协议的一般威胁进行了描述和分类。[RFC4552]中描述的机制提供了针对其中许多威胁的保护，但不是所有威胁。特别是，如[RFC5340]所述，这些机制不提供针对受损、故障或配置错误的路由器（也称为拜占庭路由器）的保护；OSPFv3和OSPF-MDR都是如此。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The extension of OSPFv3 to include MANET routers does not introduce any new security threats. However, the use of a wireless medium and lack of infrastructure, inherent with MANET routers, may render some of the attacks described in [RFC4593] easier to mount. Depending on the network context, these increased vulnerabilities may increase the need to provide authentication, integrity, and/or confidentiality, as well as anti-replay service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将OSPFv3扩展到包括MANET路由器不会引入任何新的安全威胁。然而，MANET路由器固有的无线介质的使用和基础设施的缺乏可能使[RFC4593]中描述的一些攻击更容易装载。根据网络环境，这些增加的漏洞可能会增加提供身份验证、完整性和/或机密性以及反重播服务的需要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, sniffing of routing information and traffic analysis are easier tasks with wireless routers than with wired routers, since the attacker only needs to be within the radio range of a router. The use of confidentiality (encryption) provides protection against sniffing but not traffic analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如，无线路由器比有线路由器更容易嗅探路由信息和流量分析，因为攻击者只需要在路由器的无线电范围内。使用保密性（加密）可以防止嗅探，但不能防止流量分析。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, interference attacks are also easier to mount against MANET routers due to their wireless nature. Such attacks can be mounted even if OSPF packets are protected by authentication and confidentiality, e.g., by transmitting noise or replaying outdated OSPF packets. As discussed below, an anti-replay service (provided by both ESP and AH) can be used to protect against the latter attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同样，由于MANET路由器的无线特性，干扰攻击也更容易针对其进行。即使OSPF数据包受到身份验证和机密性的保护，例如通过传输噪声或重放过时的OSPF数据包，也可以发起此类攻击。如下文所述，反重播服务（由ESP和AH提供）可用于防范后一种攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following threat actions are also easier with MANET routers: spoofing (assuming the identify of a legitimate router), falsification (sending false routing information), and overloading (sending or triggering an excessive amount of routing updates). These attacks are only possible if authentication is not used, or the attacker takes control of a router or is able to forge legitimacy (e.g., by discovering the cryptographic key).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于MANET路由器，以下威胁操作也更容易：欺骗（假设识别合法路由器）、伪造（发送虚假路由信息）和过载（发送或触发过多的路由更新）。只有在未使用身份验证、攻击者控制路由器或能够伪造合法性（例如，通过发现加密密钥）的情况下，这些攻击才可能发生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4552] mandates the use of manual keying when current IPsec protocols are used with OSPFv3. Routers are required to use manually configured keys with the same security association (SA) parameters for both inbound and outbound traffic. For MANET routers, this
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4552]在当前IPsec协议与OSPFv3一起使用时，强制使用手动键控。路由器需要为入站和出站流量使用具有相同安全关联（SA）参数的手动配置密钥。对于MANET路由器，这个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
implies that all routers attached to the same MANET must use the same key for multicasting packets. This is required in order to achieve scalability and feasibility, as explained in [RFC4552]. Future specifications can explore the use of automated key management protocols that may be suitable for MANETs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意味着连接到同一MANET的所有路由器必须使用相同的密钥进行多播数据包。这是实现可伸缩性和可行性所必需的，如[RFC4552]中所述。未来的规范可以探索适用于MANET的自动密钥管理协议的使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in [RFC4552], the use of manual keys can increase vulnerability. For example, manual keys are usually long lived, thus giving an attacker more time to discover the keys. In addition, the use of the same key on all routers attached to the same MANET leaves all routers insecure against impersonation attacks if any one of the routers is compromised.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如[RFC4552]所述，使用手动钥匙会增加漏洞。例如，手动密钥通常寿命较长，因此攻击者有更多的时间发现密钥。此外，在连接到同一MANET的所有路由器上使用相同的密钥会使所有路由器在任何一个路由器受到攻击时都不安全。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although [RFC4302] and [RFC4303] state that implementations of AH and ESP SHOULD NOT provide anti-replay service in conjunction with SAs that are manually keyed, it is important to note that such service is allowed if the sequence number counter at the sender is correctly maintained across local reboots until the key is replaced. Therefore, it may be possible for MANET routers to make use of the anti-replay service provided by AH and ESP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管[RFC4302]和[RFC4303]指出AH和ESP的实现不应与手动键入的SAs一起提供反重放服务，但需要注意的是，如果发送方的序列号计数器在本地重新启动过程中得到正确维护，直到密钥被替换，则允许此类服务。因此，MANET路由器可以利用AH和ESP提供的反重放服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an OSPF routing domain includes both MANET networks and fixed networks, the frequency of OSPF updates either due to actual topology changes or malfeasance could result in instability in the fixed networks. In situations where this is a concern, it is recommended that the border routers segregate the MANET networks from the fixed networks with either separate OSPF areas or, in cases where legacy routers are very sensitive to OSPF update frequency, separate OSPF instances. With separate OSPF areas, the 5-second MinLSInterval will dampen the frequency of changes originated in the MANET networks. Additionally, OSPF ranges can be configured to aggregate prefixes for the areas supporting MANET networks. With separate OSPF instances, more conservative local policies can be employed to limit the volume of updates emanating from the MANET networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当OSPF路由域同时包括MANET网络和固定网络时，由于实际拓扑变化或故障导致的OSPF更新频率可能会导致固定网络不稳定。在这种情况下，建议边界路由器使用单独的OSPF区域将MANET网络与固定网络隔离，或者在传统路由器对OSPF更新频率非常敏感的情况下，使用单独的OSPF实例。对于单独的OSPF区域，5秒的MinlInterval将降低源自MANET网络的变化频率。此外，OSPF范围可配置为聚合支持MANET网络的区域的前缀。对于单独的OSPF实例，可以采用更保守的本地策略来限制来自MANET网络的更新量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANA考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines three new LLS TLV types: MDR-Hello TLV (14), MDR-Metric TLV (16), and MDR-DD TLV (15) (see Section A.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件定义了三种新的LLS TLV类型：MDR Hello TLV（14）、MDR Metric TLV（16）和MDR-DD TLV（15）（见第A.2节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to Aniket Desai for helpful discussions and comments, including the suggestion that Router Priority should come before MDR Level in the lexicographical comparison of (RtrPri, MDR Level, RID) when selecting MDRs and BMDRs, and that the MDR calculation should be repeated if it causes the MDR Level to change. Thanks also to Tom Henderson, Acee Lindem, and Emmanuel Baccelli for helpful discussions and comments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
感谢Aniket Desai提供了有益的讨论和意见，包括在选择MDR和BMDR时，路由器优先级应优先于MDR级别的词典比较（RtrPri、MDR级别、RID），并且如果MDR计算导致MDR级别发生变化，则应重复MDR计算。还要感谢汤姆·亨德森、艾西·林登和埃曼纽尔·巴切利的讨论和评论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2328] Moy, J., &#34;OSPF Version 2&#34;, STD 54, RFC 2328, April 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2328]Moy，J.，“OSPF版本2”，STD 54，RFC 2328，1998年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302]Kent，S.，“IP认证头”，RFC43022005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303] Kent, S., &#34;IP Encapsulating Security Payload (ESP)&#34;, RFC 4303, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303]Kent，S.，“IP封装安全有效载荷（ESP）”，RFC 4303，2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4552] Gupta, M. and N. Melam, &#34;Authentication/Confidentiality for OSPFv3&#34;, RFC 4552, June 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4552]Gupta，M.和N.Melam，“OSPFv3的认证/保密”，RFC 4552，2006年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5243] Ogier, R., &#34;OSPF Database Exchange Summary List Optimization&#34;, RFC 5243, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5243]奥吉尔，R.，“OSPF数据库交换摘要列表优化”，RFC 5243，2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5340] Coltun, R., Ferguson, D., Moy, J., and A. Lindem, &#34;OSPF for IPv6&#34;, RFC 5340, July 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5340]Coltun，R.，Ferguson，D.，Moy，J.，和A.Lindem，“IPv6的OSPF”，RFC 53402008年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5613] Zinin, A., Roy, A., Nguyen, L., Friedman, B., and D. Yeung, &#34;OSPF Link-Local Signaling&#34;, RFC 5613, August 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5613]Zinin，A.，Roy，A.，Nguyen，L.，Friedman，B.，和D.Yeung，“OSPF链路本地信令”，RFC 5613，2009年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Lawler] Lawler, E., &#34;Combinatorial Optimization: Networks and Matroids&#34;, Holt, Rinehart, and Winston, New York, 1976.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Lawler]Lawler，E.，“组合优化：网络和拟阵”，Holt，Rinehart和Winston，纽约，1976年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Suurballe] Suurballe, J.W. and R.E. Tarjan, &#34;A Quick Method for Finding Shortest Pairs of Disjoint Paths&#34;, Networks, Vol. 14, pp. 325-336, 1984.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Suurballe]Suurballe，J.W.和R.E.Tarjan，“寻找不相交路径最短对的快速方法”，网络，第14卷，第325-336页，1984年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4593] Barbir, A., Murphy, S., and Y. Yang, &#34;Generic Threats to Routing Protocols&#34;, RFC 4593, October 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4593]Barbir，A.，Murphy，S.，和Y.Yang，“路由协议的一般威胁”，RFC 4593，2006年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A. Packet Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录A.数据包格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. Options Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 选项字段
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The L bit of the OSPF options field is used for link-local signaling, as described in [RFC5613]. Routers set the L bit in Hello and DD packets to indicate that the packet contains an LLS data block. Routers set the L bit in a self-originated router-LSA to indicate that the LSA is non-ackable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF选项字段的L位用于链路本地信令，如[RFC5613]所述。路由器在Hello和DD数据包中设置L位，以指示数据包包含LLS数据块。路由器在自创路由器LSA中设置L位，以指示LSA不可确认。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. Link-Local Signaling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. 链路本地信令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR uses link-local signaling [RFC5613] to append the MDR-Hello TLV and MDR-Metric TLV to Hello packets, and to append the MDR-DD TLV to Database Description packets. Link-local signaling is an extension of OSPFv2 and OSPFv3 that allows the exchange of arbitrary data using existing OSPF packet types. Here we use LLS for OSPFv3, which is accomplished by adding an LLS data block at the end of the OSPFv3 packet. The OSPF packet length field does not include the length of the LLS data block, but the IPv6 packet length does include this length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF-MDR使用链路本地信令[RFC5613]将MDR Hello TLV和MDR度量TLV附加到Hello数据包，并将MDR-DD TLV附加到数据库描述数据包。链路本地信令是OSPFv2和OSPFv3的扩展，允许使用现有的OSPF包类型交换任意数据。在这里，我们将LLS用于OSPFv3，这是通过在OSPFv3数据包的末尾添加一个LLS数据块来实现的。OSPF数据包长度字段不包括LLS数据块的长度，但IPv6数据包长度确实包括该长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.1. LLS Data Block
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.1. LLS数据块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data block used for link-local signaling is formatted as described below in Figure A.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于链路本地信令的数据块的格式如下图A.1所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Checksum           |       LLS Data Length         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       |                           LLS TLVs                            |
       .                                                               .
       .                                                               .
       .                                                               .
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Checksum           |       LLS Data Length         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       |                           LLS TLVs                            |
       .                                                               .
       .                                                               .
       .                                                               .
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure A.1: Format of LLS Data Block
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
图A.1:LLS数据块的格式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Checksum field contains the standard IP checksum of the entire contents of the LLS block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
校验和字段包含LLS块全部内容的标准IP校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 16-bit LLS Data Length field contains the length (in 32-bit words) of the LLS block including the header and payload. Implementations should not use the Length field in the IPv6 packet header to determine the length of the LLS data block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16位LLS数据长度字段包含LLS块的长度（32位字），包括标头和有效负载。实现不应使用IPv6数据包头中的长度字段来确定LLS数据块的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of the block contains a set of Type/Length/Value (TLV) triplets as described in the following section. All TLVs must be 32-bit aligned (with padding if necessary).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
块的其余部分包含一组类型/长度/值（TLV）三元组，如下节所述。所有TLV必须32位对齐（如有必要，使用填充）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.2. LLS TLV Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.2. LLS TLV格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the LLS data block are constructed using TLVs. See Figure A.2 for the TLV format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LLS数据块的内容是使用TLV构建的。TLV格式见图A.2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type field contains the TLV ID, which is unique for each type of TLV. The Length field contains the length of the Value field (in bytes) that is variable and contains arbitrary data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型字段包含TLV ID，该ID对于每种类型的TLV都是唯一的。长度字段包含可变且包含任意数据的值字段的长度（以字节为单位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Type               |           Length              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       .                                                               .
       .                             Value                             .
       .                                                               .
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |            Type               |           Length              |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                                                               |
       .                                                               .
       .                             Value                             .
       .                                                               .
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
Figure A.2: Format of LLS TLVs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-24">
图A.2:LLS TLV的格式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that TLVs are always padded to a 32-bit boundary, but padding bytes are not included in the TLV Length field (though they are included in the LLS Data Length field of the LLS block header). All unknown TLVs MUST be silently ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，TLV始终填充到32位边界，但填充字节不包括在TLV长度字段中（尽管它们包括在LLS块头的LLS数据长度字段中）。所有未知的TLV必须以静默方式忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.3. MDR-Hello TLV
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.3. MDR你好TLV
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MDR-Hello TLV is appended to each MANET Hello using LLS. It includes the current Hello sequence number (HSN) for the transmitting interface and the number of neighbors of each type that are listed in the body of the Hello (see Section 4.1). It also indicates whether the Hello is differential (via the D-bit), and whether the router is using full-topology adjacencies (via the A-bit).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR Hello TLV使用LLS附加到每个MANET Hello。它包括传输接口的当前Hello序列号（HSN）和Hello正文中列出的每种类型的邻居数（见第4.1节）。它还指示Hello是否是差分的（通过D位），以及路由器是否使用完全拓扑邻接（通过A位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Hello Sequence Number      |          Reserved         |A|D|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      N1       |      N2       |      N3       |      N4       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Hello Sequence Number      |          Reserved         |A|D|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      N1       |      N2       |      N3       |      N4       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Type: Set to 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 类型：设置为14。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Length: Set to 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 长度：设置为8。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Hello Sequence Number: A circular two-octet unsigned integer indicating the current HSN for the transmitting interface. The HSN for the interface is incremented by 1 (modulo 2^16) every time a (differential or full) Hello is sent on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Hello序列号：一个循环的两个八位无符号整数，表示传输接口的当前HSN。每次在接口上发送（差分或全）Hello时，接口的HSN将增加1（模2^16）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Reserved: Set to 0. Reserved for future use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 保留：设置为0。保留供将来使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A (1 bit): Set to 1 if AdjConnectivity is 0; otherwise, set to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A（1位）：如果AdjConnectivity为0，则设置为1；否则，设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o D (1 bit): Set to 1 for a differential Hello and 0 for a full Hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o D（1位）：差分Hello设置为1，完整Hello设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N1 (8 bits): The number of neighbors listed in the Hello that are in state Down. N1 is zero if the Hello is not differential.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N1（8位）：Hello中列出的处于关闭状态的邻居数。如果Hello不是差分的，则N1为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N2 (8 bits): The number of neighbors listed in the Hello that are in state Init.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N2（8位）：Hello中列出的处于Init状态的邻居数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N3 (8 bits): The number of neighbors listed in the Hello that are Dependent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N3（8位）：Hello中列出的依赖的邻居数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N4 (8 bits): The number of neighbors listed in the Hello that are Selected Advertised Neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N4（8位）：在Hello中列出的、被选为广告邻居的邻居数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.4. MDR-DD TLV
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.4. MDR-DD TLV
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a Database Description packet is sent to a neighbor in state ExStart, an MDR-DD TLV is appended to the packet using LLS. It includes the same two Router IDs that are included in the DR and Backup DR fields of a Hello sent by the router, and is used to indicate the router&#39;s MDR Level and Parent(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当数据库描述数据包以ExStart状态发送给邻居时，使用LLS将MDR-DD TLV附加到数据包。它包括路由器发送的Hello的DR和Backup DR字段中包含的两个相同的路由器ID，用于指示路由器的MDR级别和父级。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               DR                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Backup DR                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |                               DR                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           Backup DR                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--+--+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Type: Set to 15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 类型：设置为15。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Length: Set to 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 长度：设置为8。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DR: The same Router ID that is included in the DR field of a Hello sent by the router (see Section A.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DR：路由器发送的Hello的DR字段中包含的相同路由器ID（参见a.3节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Backup DR: The same Router ID that is included in the Backup DR field of a Hello sent by the router (see Section A.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 备份灾难恢复：路由器发送的Hello的备份灾难恢复字段中包含的相同路由器ID（参见a.3节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.5. MDR-Metric TLV
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2.5. MDR公制TLV
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If LSAFullness is 1 or 2, an MDR-Metric TLV must be appended to each MANET Hello packet using LLS, unless all link metrics are 1. This TLV advertises the link metric for each bidirectional neighbor listed in the body of the Hello. At a minimum, this TLV advertises a single default metric. If the I bit is set, the Router ID and link metric are included for each bidirectional neighbor listed in the body of the Hello whose link metric is not equal to the default metric. This option reduces overhead when all neighbors have the same link metric, or only a few neighbors have a link metric that differs from the default metric. If the I bit is zero, the link metric is included for each bidirectional neighbor that is listed in the body of the Hello and the neighbor RIDs are omitted from the TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LSAFullness为1或2，则必须使用LLS将MDR度量TLV附加到每个MANET Hello数据包，除非所有链路度量均为1。该TLV为Hello正文中列出的每个双向邻居播发链路度量。该TLV至少发布一个默认指标。如果设置了I位，则路由器ID和链路度量将包括在Hello的主体中列出的每个双向邻居，其链路度量不等于默认度量。当所有邻居具有相同的链路度量，或者只有少数邻居具有不同于默认度量的链路度量时，此选项可减少开销。如果I位为零，则包括Hello正文中列出的每个双向邻居的链路度量，并且从TLV中省略邻居rid。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Default Metric           |        Reserved             |I|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        Neighbor ID (1)                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        Neighbor ID (2)                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             ...                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Metric (1)            |        Metric (2)             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |            Type               |           Length              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Default Metric           |        Reserved             |I|
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        Neighbor ID (1)                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        Neighbor ID (2)                        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             ...                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Metric (1)            |        Metric (2)             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Type: Set to 16.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 类型：设置为16。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Length: Set to 4 + 6*N if the I bit is 1, and to 4 + 2*N if the I bit is 0, where N is the number of neighbors included in the TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 长度：如果I位为1，则设置为4+6*N；如果I位为0，则设置为4+2*N，其中N是TLV中包含的邻居数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Default Metric: If the I bit is 1, this is the link metric that applies to every bidirectional neighbor listed in the body of the Hello whose RID is not listed in the Metric TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 默认度量：如果I位为1，则这是应用于Hello主体中列出的每个双向邻居（其RID未在度量TLV中列出）的链路度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Neighbor ID: If the I bit is 1, the RID is listed for each bidirectional neighbor (Lists 3 through 5 as defined in Section 4.1) in the body of the Hello whose link metric is not equal to the default metric. Omitted if the I bit is 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 邻居ID：如果I位为1，则在链接度量不等于默认度量的Hello主体中为每个双向邻居列出RID（列出第4.1节中定义的3到5）。如果I位为0，则省略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Metric: Link metric for each bidirectional neighbor, listed in the same order as the Neighbor IDs in the TLV if the I bit is 1, and in the same order as the Neighbor IDs of bidirectional neighbors (Lists 3 through 5 as defined in Section 4.1) in the body of the Hello if the I bit is 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 度量：每个双向邻居的链路度量，如果I位为1，则按与TLV中邻居ID相同的顺序列出，如果I位为0，则按与Hello正文中双向邻居（第4.1节定义的列表3到5）的邻居ID相同的顺序列出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. Hello Packet DR and Backup DR Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. Hello数据包灾难恢复和备份灾难恢复字段
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Designated Router (DR) and Backup DR fields of a Hello packet are set as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello数据包的指定路由器（DR）和备份DR字段设置如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DR: This field is the router&#39;s Parent, or is 0.0.0.0 if the Parent is null. The Parent of an MDR is always the router&#39;s own RID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DR：此字段是路由器的父级，如果父级为空，则为0.0.0.0。MDR的父级总是路由器自己的RID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Backup DR: This field is the router&#39;s Backup Parent, or is 0.0.0.0 if the Backup Parent is null. The Backup Parent of a BMDR is always the router&#39;s own RID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 备份灾难恢复：此字段是路由器的备份父级，如果备份父级为空，则为0.0.0.0。BMDR的备份父级始终是路由器自己的RID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. LSA Formats and Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. LSA格式和示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LSA formats are specified in [RFC5340], Section 4.4. Figure A.3 below gives an example network map for a MANET in a single area.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LSA格式在[RFC5340]第4.4节中规定。下图A.3给出了单个区域中MANET的示例网络图。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Four MANET routers RT1, RT2, RT3, and RT4 are in area 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 区域1中有四个MANET路由器RT1、RT2、RT3和RT4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT1&#39;s MANET interface has links to RT2 and RT3&#39;s MANET interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT1的MANET接口有到RT2和RT3的MANET接口的链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT2&#39;s MANET interface has links to RT1 and RT3&#39;s MANET interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT2的MANET接口有到RT1和RT3的MANET接口的链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT3&#39;s MANET interface has links to RT1, RT2, and RT3&#39;s MANET interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT3的MANET接口有到RT1、RT2和RT3的MANET接口的链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT4&#39;s MANET interface has a link to RT3&#39;s MANET interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT4的MANET接口有一个到RT3的MANET接口的链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT1 and RT2 have stub networks attached on broadcast interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT1和RT2在广播接口上连接了存根网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT3 has a transit network attached on a broadcast interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RT3有一个连接在广播接口上的传输网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       ..........................................
       .                                  Area 1.
       .     +                                  .
       .     |                                  .
       .     |  2+---+1                      1+---+
       .  N1 |---|RT1|----+               +---|RT4|----
       .     |   +---+    |\             /    +---+
       .     |            | \           /       .
       .     +            |  \   N3    /        .
       .                  |   \       /         .
       .     +            |    \     /          .
       .     |            |     \   /           .
       .     |  2+---+1   |      \ /            .
       .  N2 |---|RT2|----+-------+             .
       .     |   +---+            |1            .
       .     |                  +---+           .
       .     |                  |RT3|----------------
       .     +                  +---+           .
       .                          |2            .
       .                   +------------+       .
       .                      |1   N4           .
       .                    +---+               .
       .                    |RT5|               .
       .                    +---+               .
       ..........................................
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       ..........................................
       .                                  Area 1.
       .     +                                  .
       .     |                                  .
       .     |  2+---+1                      1+---+
       .  N1 |---|RT1|----+               +---|RT4|----
       .     |   +---+    |\             /    +---+
       .     |            | \           /       .
       .     +            |  \   N3    /        .
       .                  |   \       /         .
       .     +            |    \     /          .
       .     |            |     \   /           .
       .     |  2+---+1   |      \ /            .
       .  N2 |---|RT2|----+-------+             .
       .     |   +---+            |1            .
       .     |                  +---+           .
       .     |                  |RT3|----------------
       .     +                  +---+           .
       .                          |2            .
       .                   +------------+       .
       .                      |1   N4           .
       .                    +---+               .
       .                    |RT5|               .
       .                    +---+               .
       ..........................................
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Figure A.3: Area 1 with IP Addresses Shown
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
图A.3：显示IP地址的区域1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Network   IPv6 prefix
      -----------------------------------
      N1        5f00:0000:c001:0200::/56
      N2        5f00:0000:c001:0300::/56
      N4        5f00:0000:c001:0400::/56
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Network   IPv6 prefix
      -----------------------------------
      N1        5f00:0000:c001:0200::/56
      N2        5f00:0000:c001:0300::/56
      N4        5f00:0000:c001:0400::/56
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table 1: IPv6 link prefixes for sample network
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表1：示例网络的IPv6链路前缀
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Router     interface   Interface ID  IPv6 global unicast prefix
      -----------------------------------------------------------
      RT1      LOOPBACK      0             5f00:0001::/64
               to N3         1             n/a
               to N1         2             5f00:0000:c001:0200::RT1/56
      RT2      LOOPBACK      0             5f00:0002::/64
               to N3         1             n/a
               to N2         2             5f00:0000:c001:0300::RT2/56
      RT3      LOOPBACK      0             5f00:0003::/64
               to N3         1             n/a
               to N4         2             5f00:0000:c001:0400::RT3/56
      RT4      LOOPBACK      0             5f00:0004::/64
               to N3         1             n/a
      RT5      to N4         1             5f00:0000:c001:0400::RT5/56
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Router     interface   Interface ID  IPv6 global unicast prefix
      -----------------------------------------------------------
      RT1      LOOPBACK      0             5f00:0001::/64
               to N3         1             n/a
               to N1         2             5f00:0000:c001:0200::RT1/56
      RT2      LOOPBACK      0             5f00:0002::/64
               to N3         1             n/a
               to N2         2             5f00:0000:c001:0300::RT2/56
      RT3      LOOPBACK      0             5f00:0003::/64
               to N3         1             n/a
               to N4         2             5f00:0000:c001:0400::RT3/56
      RT4      LOOPBACK      0             5f00:0004::/64
               to N3         1             n/a
      RT5      to N4         1             5f00:0000:c001:0400::RT5/56
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table 2: IPv6 link prefixes for sample network
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表2：示例网络的IPv6链路前缀
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Router   interface   Interface ID   link-local address
      -------------------------------------------------------
      RT1      LOOPBACK    0              n/a
               to N1       1              fe80:0001::RT1
               to N3       2              fe80:0002::RT1
      RT2      LOOPBACK    0              n/a
               to N2       1              fe80:0001::RT2
               to N3       2              fe80:0002::RT2
      RT3      LOOPBACK    0              n/a
               to N3       1              fe80:0001::RT3
               to N4       2              fe80:0002::RT3
      RT4      LOOPBACK    0              n/a
               to N3       1              fe80:0001::RT4
      RT5      to N4       1              fe80:0002::RT5
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Router   interface   Interface ID   link-local address
      -------------------------------------------------------
      RT1      LOOPBACK    0              n/a
               to N1       1              fe80:0001::RT1
               to N3       2              fe80:0002::RT1
      RT2      LOOPBACK    0              n/a
               to N2       1              fe80:0001::RT2
               to N3       2              fe80:0002::RT2
      RT3      LOOPBACK    0              n/a
               to N3       1              fe80:0001::RT3
               to N4       2              fe80:0002::RT3
      RT4      LOOPBACK    0              n/a
               to N3       1              fe80:0001::RT4
      RT5      to N4       1              fe80:0002::RT5
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Table 3: OSPF interface IDs and link-local addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
表3:OSPF接口ID和链路本地地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.1. Router-LSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.1. 路由器LSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example, consider the router-LSA that node RT3 would originate. The node consists of one MANET, one broadcast, and one loopback interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为一个例子，考虑节点RT3将产生的路由器LSA。该节点由一个MANET、一个广播和一个环回接口组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RT3&#39;s router-LSA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RT3的路由器LSA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LS age = DoNotAge+0              ;newly originated
   LS type = 0x2001                 ;router-LSA
   Link State ID = 0                ;first fragment
   Advertising Router = 192.1.1.3   ;RT3&#39;s Router ID
   bit E = 0                        ;not an AS boundary router
   bit B = 1                        ;area border router
   Options = (V6-bit|E-bit|R-bit)
     Type = 1                        ;p2p link to RT1
     Metric = 1                      ;cost to RT1
     Interface ID = 1                ;Interface ID
     Neighbor Interface ID = 1       ;Interface ID
     Neighbor Router ID = 192.1.1.1  ;RT1&#39;s Router ID
     Type = 1                        ;p2p link to RT2
     Metric = 1                      ;cost to RT2
     Interface ID = 1                ;Interface ID
     Neighbor Interface ID = 1       ;Interface ID
     Neighbor Router ID = 192.1.1.2  ;RT2&#39;s Router ID
     Type = 1                        ;p2p link to RT4
     Metric = 1                      ;cost to RT4
     Interface ID = 1                ;Interface ID
     Neighbor Interface ID = 1       ;Interface ID
     Neighbor Router ID = 192.1.1.4  ;RT4&#39;s Router ID
     Type = 2                        ;connects to N4
     Metric = 1                      ;cost to N4
     Interface ID = 2                ;RT3&#39;s Interface ID
     Neighbor Interface ID = 1       ;RT5&#39;s Interface ID (elected DR)
     Neighbor Router ID = 192.1.1.5  ;RT5&#39;s Router ID  (elected DR)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LS age = DoNotAge+0              ;newly originated
   LS type = 0x2001                 ;router-LSA
   Link State ID = 0                ;first fragment
   Advertising Router = 192.1.1.3   ;RT3&#39;s Router ID
   bit E = 0                        ;not an AS boundary router
   bit B = 1                        ;area border router
   Options = (V6-bit|E-bit|R-bit)
     Type = 1                        ;p2p link to RT1
     Metric = 1                      ;cost to RT1
     Interface ID = 1                ;Interface ID
     Neighbor Interface ID = 1       ;Interface ID
     Neighbor Router ID = 192.1.1.1  ;RT1&#39;s Router ID
     Type = 1                        ;p2p link to RT2
     Metric = 1                      ;cost to RT2
     Interface ID = 1                ;Interface ID
     Neighbor Interface ID = 1       ;Interface ID
     Neighbor Router ID = 192.1.1.2  ;RT2&#39;s Router ID
     Type = 1                        ;p2p link to RT4
     Metric = 1                      ;cost to RT4
     Interface ID = 1                ;Interface ID
     Neighbor Interface ID = 1       ;Interface ID
     Neighbor Router ID = 192.1.1.4  ;RT4&#39;s Router ID
     Type = 2                        ;connects to N4
     Metric = 1                      ;cost to N4
     Interface ID = 2                ;RT3&#39;s Interface ID
     Neighbor Interface ID = 1       ;RT5&#39;s Interface ID (elected DR)
     Neighbor Router ID = 192.1.1.5  ;RT5&#39;s Router ID  (elected DR)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.2. Link-LSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.2. 链路LSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the link-LSA that RT3 would originate for its MANET interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑RT3将为其MANET接口产生的链路LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RT3&#39;s link-LSA for its MANET interface
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RT3的MANET接口链路LSA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LS age = DoNotAge+0              ;newly originated
   LS type = 0x0008                 ;Link-LSA
   Link State ID = 1                ;Interface ID
   Advertising Router = 192.1.1.3   ;RT3&#39;s Router ID
   RtrPri = 1                       ;default priority
   Options = (V6-bit|E-bit|R-bit)
   Link-local Interface Address = fe80:0001::RT3
   # prefixes = 0                   ;no global unicast address
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LS age = DoNotAge+0              ;newly originated
   LS type = 0x0008                 ;Link-LSA
   Link State ID = 1                ;Interface ID
   Advertising Router = 192.1.1.3   ;RT3&#39;s Router ID
   RtrPri = 1                       ;default priority
   Options = (V6-bit|E-bit|R-bit)
   Link-local Interface Address = fe80:0001::RT3
   # prefixes = 0                   ;no global unicast address
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.3. Intra-Area-Prefix-LSAs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.3. 区域内前缀LSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A MANET node originates an intra-area-prefix-LSA to advertise its own prefixes, and those of its attached networks or stub links. As an example, consider the intra-area-prefix-LSA that RT3 will build.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MANET节点发起一个区域内前缀LSA来公布它自己的前缀，以及它所连接的网络或存根链路的前缀。作为一个例子，考虑RT3将构建的区域内前缀LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RT2&#39;s intra-area-prefix-LSA for its own prefixes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RT2自身前缀的区域内前缀LSA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LS age = DoNotAge+0              ;newly originated
   LS type = 0x2009                 ;intra-area-prefix-LSA
   Link State ID = 177              ;or something
   Advertising Router = 192.1.1.3   ;RT3&#39;s Router ID
   # prefixes = 2
   Referenced LS type = 0x2001      ;router-LSA reference
   Referenced Link State ID = 0     ;always 0 for router-LSA reference
   Referenced Advertising Router = 192.1.1.3 ;RT2&#39;s Router ID
     PrefixLength = 64               ;prefix on RT3&#39;s LOOPBACK
     PrefixOptions = 0
     Metric = 0                      ;cost of RT3&#39;s LOOPBACK
     Address Prefix = 5f00:0003::/64
     PrefixLength = 56               ;prefix on RT3&#39;s interface 2
     PrefixOptions = 0
     Metric = 1                      ;cost of RT3&#39;s interface 2
     Address Prefix = 5f00:0000:c001:0400::RT3/56    ;pad
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LS age = DoNotAge+0              ;newly originated
   LS type = 0x2009                 ;intra-area-prefix-LSA
   Link State ID = 177              ;or something
   Advertising Router = 192.1.1.3   ;RT3&#39;s Router ID
   # prefixes = 2
   Referenced LS type = 0x2001      ;router-LSA reference
   Referenced Link State ID = 0     ;always 0 for router-LSA reference
   Referenced Advertising Router = 192.1.1.3 ;RT2&#39;s Router ID
     PrefixLength = 64               ;prefix on RT3&#39;s LOOPBACK
     PrefixOptions = 0
     Metric = 0                      ;cost of RT3&#39;s LOOPBACK
     Address Prefix = 5f00:0003::/64
     PrefixLength = 56               ;prefix on RT3&#39;s interface 2
     PrefixOptions = 0
     Metric = 1                      ;cost of RT3&#39;s interface 2
     Address Prefix = 5f00:0000:c001:0400::RT3/56    ;pad
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B. Detailed Algorithms for MDR/BMDR Selection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
附录B.MDR/BMDR选择的详细算法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides detailed algorithms for Step 2.4 of Phase 2 (MDR selection) and Step 3.2 of Phase 3 (BMDR selection) of the MDR selection algorithm described in Section 5. Step 2.4 uses a breadth-first search (BFS) algorithm, and Step 3.2 uses an efficient algorithm for finding pairs of node-disjoint paths from Rmax to all other neighbors. Both algorithms run in O(d^2) time, where d is the number of neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节提供了第5节所述MDR选择算法第2阶段（MDR选择）第2.4步和第3阶段（BMDR选择）第3.2步的详细算法。步骤2.4使用广度优先搜索（BFS）算法，步骤3.2使用高效算法查找从Rmax到所有其他邻居的节点不相交路径对。这两种算法都在O（d^2）时间内运行，其中d是邻居的数量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For convenience, in the following description, the term &#34;bi-neighbor&#34; will be used as an abbreviation for &#34;bidirectional neighbor&#34;. Also, node i denotes the router performing the calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为方便起见，在以下描述中，术语“双向邻居”将用作“双向邻居”的缩写。此外，节点i表示执行计算的路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. Detailed Algorithm for Step 2.4 (MDR Selection)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. 步骤2.4（MDR选择）的详细算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following algorithm performs Step 2.4 of the MDR selection algorithm, and assumes that Phase 1 and Steps 2.1 through 2.3 have been performed, so that the neighbor connectivity matrix NCM has been computed and Rmax is the bi-neighbor with the (lexicographically) largest value of (RtrPri, MDR Level, RID). The BFS algorithm uses a FIFO queue so that all nodes 1 hop from node Rmax are processed first, then 2 hops, etc. When the BFS algorithm terminates, hops(u), for each bi-neighbor node u of node i, will be equal to the minimum number of hops from node Rmax to node u, using only intermediate nodes that are bi-neighbors of node i and that have a larger value of (RtrPri, MDR Level, RID) than node i. The algorithm also computes, for each node u, the tree parent p(u) and the second node r(u) on the tree path from Rmax to u, which will be used in Step 3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下算法执行MDR选择算法的步骤2.4，并假设已执行阶段1和步骤2.1至2.3，因此已计算邻居连接矩阵NCM，且Rmax是（字典）最大值为（RtrPri，MDR级别，RID）的bi邻居。BFS算法使用FIFO队列，以便首先处理从节点Rmax到节点Rmax的所有节点1跳，然后处理2跳，以此类推。当BFS算法终止时，节点i的每个双邻居节点u的跳数（u）将等于从节点Rmax到节点u的最小跳数，仅使用作为节点i的bi邻居且值（RtrPri、MDR级别、RID）大于节点i的中间节点。该算法还为每个节点u计算从Rmax到u的树路径上的树父节点p（u）和第二个节点r（u），这将在步骤3.2中使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) Compute a matrix of link costs c(u,v) for each pair of bi-neighbors u and v as follows: If node u has a larger value of (RtrPri, MDR Level, RID) than node i, and NCM(u,v) = 1, then set c(u,v) to 1. Otherwise, set c(u,v) to infinity. (Note that the matrix NCM(u,v) is symmetric, but the matrix c(u,v) is not.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) 按如下方式计算每对bi邻居u和v的链路成本c（u，v）矩阵：如果节点u的值（RtrPri，MDR级别，RID）大于节点i，且NCM（u，v）=1，则将c（u，v）设置为1。否则，将c（u，v）设置为无穷大。（请注意，矩阵NCM（u，v）是对称的，但矩阵c（u，v）不是对称的。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) Set hops(u) = infinity for all bi-neighbors u other than Rmax, and set hops(Rmax) = 0. Initially, p(u) is undefined for each neighbor u. For each bi-neighbor u such that c(Rmax,u) = 1, set r(u) = u; for all other u, r(u) is initially undefined. Add node Rmax to the FIFO queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) 设置跳数（u）=除Rmax之外的所有bi邻居u的无穷大，并且设置跳数（Rmax）=0。最初，p（u）对于每个相邻的u是未定义的。对于每个双邻居u，使得c（Rmax，u）=1，设置r（u）=u；对于所有其他u，r（u）最初是未定义的。将节点Rmax添加到FIFO队列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(c) While the FIFO queue is nonempty: Remove the node at the head of the queue; call it node u. For each bi-neighbor v of node i such that c(u,v) = 1: If hops(v) &gt; hops(u) + 1, then set hops(v) = hops(u) + 1, set p(v) = u, set r(v) = r(u) if hops(v) &gt; 1, and add node v to the tail of the queue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(c) 当FIFO队列为非空时：删除队列头部的节点；称之为节点u。对于节点i的每个双邻居v，c（u，v）=1：如果跳数（v）&gt;跳数（u）+1，则设置跳数（v）=跳数（u）+1，设置p（v）=u，如果跳数（v）&gt;1，则设置r（v）=r（u），并将节点v添加到队列的尾部。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. Detailed Algorithm for Step 3.2 (BMDR Selection)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. 步骤3.2（BMDR选择）的详细算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 3.2 of the MDR selection algorithm requires the router to determine whether there exist two node-disjoint paths from Rmax to each other bi-neighbor u, via bi-neighbors that have a larger value of (RtrPri, MDR Level, RID) than the router itself. This information is needed to determine whether the router should select itself as a BMDR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MDR选择算法的步骤3.2要求路由器通过具有比路由器本身更大值（RtrPri、MDR级别、RID）的bi邻居来确定是否存在从Rmax到彼此的bi邻居u的两条节点不相交路径。需要此信息来确定路由器是否应选择自身作为BMDR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible to determine separately for each bi-neighbor u whether there exist two node-disjoint paths from Rmax to u, using the well-known augmenting path algorithm [Lawler] that runs in O(n^2) time, but this must be done for all bi-neighbors u, thus requiring a total run time of O(n^3). The algorithm described below makes the same determination simultaneously for all bi-neighbors u, achieving a much faster total run time of O(n^2). The algorithm is a simplified variation of the Suurballe-Tarjan algorithm [Suurballe] for finding pairs of disjoint paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可以使用运行时间为O（n^2）的著名增广路径算法[Lawler]分别确定每个双邻居u是否存在从Rmax到u的两条节点不相交的路径，但这必须对所有双邻居u进行，因此总运行时间为O（n^3）。下面描述的算法对所有bi邻居u同时进行相同的确定，从而实现更快的总运行时间O（n^2）。该算法是Suurballe-Tarjan算法[Suurballe]的简化变体，用于查找不相交路径对。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm described below uses the following output of Phase 2: the tree parent p(u) of each node (which defines the BFS tree computed in Phase 2), and the second node r(u) on the tree path from Rmax to u.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面描述的算法使用阶段2的以下输出：每个节点的树父节点p（u）（定义在阶段2中计算的BFS树），以及从Rmax到u的树路径上的第二个节点r（u）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm uses the following concepts. For any node u on the BFS tree other than Rmax, we define g(u) to be the first labeled node on the reverse tree path from u to Rmax, if such a labeled node exists other than Rmax. (The reverse tree path consists of u, p(u), p(p(u)), ..., Rmax.) If no such labeled node exists, then g(u) is defined to be r(u). In particular, if u is labeled then g(u) = u. Note that g(u) either must be labeled or must be a neighbor of Rmax.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法使用以下概念。对于BFS树上除Rmax以外的任何节点u，我们定义g（u）为从u到Rmax的反向树路径上的第一个标记节点，如果该标记节点不存在于Rmax。（反向树路径由u，p（u），p（p（u）），…，Rmax组成。）如果不存在这样的标记节点，则g（u）被定义为r（u）。特别是，如果u被标记，那么g（u）=u。注意，g（u）要么必须被标记，要么必须是Rmax的邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For any node k that either is labeled or is a neighbor of Rmax, we define the unlabeled subtree rooted at k, denoted S(k), to be the set of nodes u such that g(u) = k. Thus, S(k) includes node k itself and the set of unlabeled nodes downstream of k on the BFS tree that can be reached without going through any labeled nodes. This set can be obtained in linear time using a depth-first search starting at node k, and using labeled nodes to indicate the boundaries of the search. Note that g(u) and S(k) are not maintained as variables in the algorithm given below, but simply refer to the definitions given above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于任何被标记或是Rmax邻居的节点k，我们将根在k的未标记子树（表示为S（k））定义为节点u的集合，使得g（u）=k。因此，S（k）包括节点k本身和BFS树上k下游的一组未标记节点，这些节点可以在不经过任何标记节点的情况下到达。使用从节点k开始的深度优先搜索，并使用标记节点指示搜索边界，可以在线性时间内获得该集合。注意，在下面给出的算法中，g（u）和S（k）不是作为变量来维护的，只是参考上面给出的定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The BMDR algorithm maintains a set B, which is initially empty. A node u is added to B when it is known that two node-disjoint paths exist from Rmax to u via nodes that have a larger value of (RtrPri, MDR Level, RID) than the router itself. When the algorithm terminates, B consists of all nodes that have this property.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BMDR算法维护一个集合B，该集合最初为空。当知道存在从Rmax到u的两条节点不相交路径时，节点u被添加到B中，这两条路径通过比路由器本身具有更大值（RtrPri、MDR级别、RID）的节点。当算法终止时，B由具有此属性的所有节点组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm consists of the following two steps.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法由以下两个步骤组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) Mark Rmax as labeled. For each pair of nodes u, v on the BFS tree other than Rmax such that r(u) is not equal to r(v) (i.e., u and v have different second nodes), NCM(u,v) = 1, and node u has a greater value of (RtrPri, MDR level, RID) than the router itself, add v to B. (Clearly there are two disjoint paths from Rmax to v.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) 将Rmax标记为标签。对于BFS树上除Rmax以外的每对节点u，v，使得r（u）不等于r（v）（即，u和v具有不同的第二个节点），NCM（u，v）=1，并且节点u的值（RtrPri，MDR level，RID）大于路由器本身，将v添加到B（显然，从Rmax到v有两条不相交的路径）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) While there exists a node in B that is not labeled, do the following. Choose any node k in B that is not labeled, and let j = g(k). Now mark k as labeled. (This creates a new unlabeled subtree S(k), and makes S(j) smaller by removing S(k) from it.) For each pair of nodes u, v such that u is in S(k), v is in S(j), and NCM(u,v) = 1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) 当B中存在未标记的节点时，请执行以下操作。选择B中未标记的任何节点k，并让j=g（k）。现在将k标记为已标记。（这将创建一个新的未标记子树S（k），并通过从中移除S（k）使S（j）变小。）对于每对节点u，v，u在S（k）中，v在S（j）中，NCM（u，v）=1：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o If u has a larger value of (RtrPri, MDR level, RID) than the router itself, and v is not in B, then add v to B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 如果u的值（RtrPri，MDR level，RID）大于路由器本身，并且v不在B中，那么将v添加到B中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o If v has a larger value of (RtrPri, MDR level, RID) than the router itself, and u is not in B, then add u to B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
o 如果v的值（RtrPri，MDR level，RID）大于路由器本身，并且u不在B中，那么将u添加到B中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simplified version of the algorithm MAY be performed by omitting step (b). However, the simplified algorithm will result in more BMDRs, and is not recommended if AdjConnectivity = 2 since it will result in more adjacencies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可通过省略步骤（b）来执行该算法的简化版本。但是，简化算法将产生更多的BMDR，如果AdjConnectivity=2，则不建议使用简化算法，因为它将产生更多的邻接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above algorithm can be executed in O(n^2) time, where n is the number of neighbors. Step (a) clearly requires O(n^2) time since it considers all pairs of nodes u and v. Step (b) also requires O(n^2) time because each pair of nodes is considered at most once. This is because labeling nodes divides unlabeled subtrees into smaller unlabeled subtrees, and a given pair u, v is considered only the first time u and v belong to different unlabeled subtrees.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述算法可以在O（n^2）时间内执行，其中n是邻居的数量。步骤（a）显然需要O（n^2）时间，因为它考虑所有对节点u和v。步骤（b）也需要O（n^2）时间，因为每对节点最多考虑一次。这是因为标记节点将未标记的子树划分为更小的未标记子树，并且仅当u和v第一次属于不同的未标记子树时，才会考虑给定的u，v对。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix C. Min-Cost LSA Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录C.最小成本LSA算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the algorithm for determining which MANET neighbors to include in the router-LSA when LSAFullness is 1. The min-cost LSA algorithm ensures that the link-state database provides sufficient information to calculate at least one shortest (minimum-cost) path to each destination. The algorithm assumes that a router may have multiple interfaces, at least one of which is a MANET interface. The algorithm becomes significantly simpler if the router has only a single (MANET) interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节描述了当LSAFullness为1时，确定路由器LSA中包括哪些MANET邻居的算法。最小成本LSA算法确保链路状态数据库提供足够的信息来计算到每个目的地的至少一条最短（最小成本）路径。该算法假设路由器可能有多个接口，其中至少一个是MANET接口。如果路由器只有一个（MANET）接口，则算法会变得非常简单。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to this algorithm includes information obtained from Hellos received from each neighbor on each MANET interface, including the neighbor&#39;s Bidirectional Neighbor Set (BNS), Dependent Neighbor Set (DNS), Selected Advertised Neighbor Set (SANS), and link metrics. The input also includes the link-state database if the router has a non-MANET interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法的输入包括从每个MANET接口上的每个邻居接收的HELOS中获得的信息，包括邻居的双向邻居集（BNS）、从属邻居集（DNS）、所选播发邻居集（SAN）和链路度量。如果路由器具有非MANET接口，则输入还包括链路状态数据库。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The output of the algorithm is the router&#39;s SANS for each MANET interface. The SANS is used to construct the router-LSA as described in Section 9.4. The min-cost LSA algorithm must be run to update the SANS (and possibly originate a new router-LSA) either periodically just before sending each Hello, or whenever any of the following events occurs:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法的输出是每个MANET接口的路由器SAN。SAN用于构建路由器LSA，如第9.4节所述。必须运行最小成本LSA算法，以便在发送每个Hello之前定期更新SAN（并可能发起新的路由器LSA），或者在发生以下任何事件时更新SAN：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The state or routability of a neighbor changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 邻居的状态或可路由性发生变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A Hello received from a neighbor indicates a change in its MDR Level, Router Priority, FullHelloRcvd, BNS, DNS, SANS, Parent(s), or link metrics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 从邻居接收到的Hello表示其MDR级别、路由器优先级、FullHelloRcvd、BNS、DNS、SAN、父级或链路度量发生了更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An LSA originated by a non-MANET neighbor is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接收由非MANET邻居发起的LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the algorithm described below runs in O(d^3) time, where d is the number of neighbors, an incremental version for a single topology change runs in O(d^2) time, as discussed following the algorithm description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管下面描述的算法在O（d^3）时间内运行，其中d是邻居的数量，但单个拓扑更改的增量版本在O（d^2）时间内运行，如算法描述后所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For convenience, in the following description, the term &#34;bi-neighbor&#34; will be used as an abbreviation for &#34;bidirectional neighbor&#34;. Also, router i will denote the router doing the calculation. To perform the min-cost LSA algorithm, the following steps are performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为方便起见，在以下描述中，术语“双向邻居”将用作“双向邻居”的缩写。此外，路由器i将表示进行计算的路由器。要执行最小成本LSA算法，请执行以下步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   (1) Create the neighbor connectivity matrix (NCM) for each MANET
       interface, as described in Section 5.1.  Create the multiple-
       interface neighbor connectivity matrix MNCM as follows.  For each
       bi-neighbor j, set MNCM(i,j) = MNCM(j,i) = 1.  For each pair j, k
       of MANET bi-neighbors, set MNCM(j,k) = 1 if NCM(j,k) equals 1 for
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   (1) Create the neighbor connectivity matrix (NCM) for each MANET
       interface, as described in Section 5.1.  Create the multiple-
       interface neighbor connectivity matrix MNCM as follows.  For each
       bi-neighbor j, set MNCM(i,j) = MNCM(j,i) = 1.  For each pair j, k
       of MANET bi-neighbors, set MNCM(j,k) = 1 if NCM(j,k) equals 1 for
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
any MANET interface. For each pair j, k of non-MANET bi-neighbors, set MNCM(j,k) = 1 if the link-state database indicates that a direct link exists between j and k. Otherwise, set MNCM(j,k) = 0. (Note that a given router can be a neighbor on both a MANET interface and a non-MANET interface.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
任何MANET接口。对于非MANET bi邻居的每对j，k，如果链路状态数据库指示j和k之间存在直接链路，则将MNCM（j，k）=1。否则，设置MNCM（j，k）=0。（请注意，给定路由器可以是MANET接口和非MANET接口上的邻居。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) Create the inter-neighbor cost matrix (COST) as follows. For each pair j, k of routers such that each of j and k is a bi-neighbor or router i itself:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 创建相邻成本矩阵（cost），如下所示。对于每对路由器j，k，使得j和k中的每一个都是双邻居或路由器i本身：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) If MNCM(j,k) = 1, set COST(j,k) to the metric of the link from j to k obtained from j&#39;s Hellos (for a MANET interface), or from the link-state database (for a non-MANET interface). If there are multiple links from j to k (via multiple interfaces), COST(j,k) is set to the minimum cost of these links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) 如果MNCM（j，k）=1，则将成本（j，k）设置为从j的Hellos（对于MANET接口）或从链路状态数据库（对于非MANET接口）获得的从j到k的链路的度量。如果存在从j到k的多个链路（通过多个接口），则成本（j，k）设置为这些链路的最小成本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) Otherwise, set COST(j,k) to LSInfinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) 否则，将COST（j，k）设置为LSInfinity。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) Create the backbone neighbor matrix (BNM) as follows. BNM indicates which pairs of MANET bi-neighbors are backbone neighbors of each other, as defined in Section 9.2.1. If adjacency reduction is not used (AdjConnectivity = 0), set all entries of BNM to zero and proceed to Step 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 创建主干邻居矩阵（BNM），如下所示。BNM表示，根据第9.2.1节的定义，哪对MANET bi邻居是彼此的主干邻居。如果未使用邻接减少（邻接连接性=0），则将BNM的所有条目设置为零，然后继续执行步骤4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
In the following, if a link exists from router j to router k on more than one interface, we consider only interfaces for which the cost from j to k equals COST(j,k); such interfaces will be called &#34;candidate&#34; interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
在下面，如果在多个接口上存在从路由器J到路由器K的链路，我们只考虑从j到k的成本等于成本（j，k）的接口；此类接口称为“候选”接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
For each pair j, k of MANET bi-neighbors, BNM(j,k) is set to 1 if j and k are backbone neighbors of each other on a candidate MANET interface. That is, BNM(j,k) is set to 1 if, for any candidate MANET interface, NCM(j,k) = 1 and either of the following conditions is satisfied:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
对于MANET双邻居的每对j，k，如果j和k是候选MANET接口上彼此的主干邻居，则BNM（j，k）被设置为1。即，如果对于任何候选MANET接口，NCM（j，k）=1并且满足以下任一条件，则BNM（j，k）被设置为1：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) Router k is included in j&#39;s DNS or router j is included in k&#39;s DNS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) 路由器k包含在j的DNS中或路由器j包含在k的DNS中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) Router j is the (Backup) Parent of router k or router k is the (Backup) Parent of router j.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) 路由器j是路由器k的（备份）父级，或者路由器k是路由器j的（备份）父级。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Otherwise, BNM(j,k) is set to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
否则，BNM（j，k）设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) Create the Selected Advertised Neighbor Matrix (SANM) as follows. For each pair j, k of routers such that each of j and k is a bi-neighbor or router i itself, SANM(j,k) is set to 1 if, for any
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 按如下所示创建选定的播发邻居矩阵（SANM）。对于路由器的每对j，k，使得j和k中的每一个都是双邻居或路由器i本身，SANM（j，k）被设置为1如果，对于任何
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
candidate MANET interface, NCM(j,k) = 1 and k is included in j&#39;s SANS. Otherwise, SANM(j,k) is set to 0. Note that SANM(i,k) is set to 1 if k is currently a Selected Advertised Neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
候选MANET接口，NCM（j，k）=1，k包含在j的SAN中。否则，SANM（j，k）设置为0。请注意，如果k当前是选定的播发邻居，则SANM（i，k）设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) Compute the new set of Selected Advertised Neighbors as follows. For each MANET bi-neighbor j, initialize the bit variable new_sel_adv(j) to 0. (This bit will be set to 1 if j is selected.) For each MANET bi-neighbor j:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) 按如下方式计算所选播发邻居的新集合。对于每个MANET bi邻居j，将位变量new_sel_adv（j）初始化为0。（如果选择j，该位将设置为1。）对于每个MANET bi邻居j：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) If j is a bi-neighbor on more than one interface, consider only candidate interfaces (for which the cost to j is minimum). If one of the candidate interfaces is a non-MANET interface, examine the next neighbor (j is not selected since it will be advertised anyway).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) 如果J是多个接口上的双邻居，则只考虑候选接口（其中J的成本最小）。如果其中一个候选接口是非MANET接口，则检查下一个邻居（j未被选择，因为它将被通告）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) If adjacency reduction is used, and one of the candidate interfaces is a MANET interface on which j is a backbone neighbor (see Section 9.2), examine the next neighbor (j is not selected since it will be advertised anyway).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) 如果使用邻接减少，并且其中一个候选接口是MANET接口，其中j是主干邻居（见第9.2节），则检查下一个邻居（j未被选择，因为它无论如何都会被通告）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) Otherwise, if there is more than one candidate MANET interface, select the &#34;preferred&#34; interface by using the following preference rules in the given order: an interface is preferred if (1) router i&#39;s SANS for that interface already includes j, (2) router i&#39;s Router Priority is larger on that interface, and (3) router i&#39;s MDR Level is larger on that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) 否则，如果有多个候选MANET接口，则按给定顺序使用以下首选规则选择“首选”接口：如果（1）该接口的路由器i的SAN已包括j，（2）该接口上路由器i的路由器优先级更高，则首选该接口，以及（3）路由器i的MDR级别在该接口上更高。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(d) For each bi-neighbor k (on any interface) such that COST(k,j) &gt; COST(k,i) + COST(i,j), determine whether there exists another bi-neighbor u such that either COST(k,u) + COST(u,j) &lt; COST(k,i) + COST(i,j), or COST(k,u) + COST(u,j) = COST(k,i) + COST(i,j) and either of the following conditions is true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(d) 对于成本（k，j）&gt;成本（k，i）+成本（i，j）的每个双邻居k（在任何接口上），确定是否存在另一个双邻居u，使得成本（k，u）+成本（u，j）&lt;成本（k，i）+成本（i，j），或成本（k，u）+成本（u，j）=成本（k，i）+成本（i，j），并且以下任一条件为真：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
o BNM(u,j) = 1, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
o BNM（u，j）=1，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
o (SANM(j,u), SANM(u,j), RtrPri(u), RID(u)) is lexicographically greater than (SANM(j,i), SANM(i,j), RtrPri(i), RID(i)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
o （SANM（j，u），SANM（u，j），RtrPri（u），RID（u））在词典编纂上大于（SANM（j，i），SANM（i，j），RtrPri（i），RID（i））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
If for some such bi-neighbor k, there does not exist such a bi-neighbor u, then set new_sel_adv(j) = 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果对于某些这样的双邻居k，不存在这样的双邻居u，则将new_sel_adv（j）=1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) For each MANET interface I, update the SANS to equal the set of all bi-neighbors j such that new_sel_adv(j) = 1 and I is the preferred interface for j.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) 对于每个MANET接口I，更新SAN以使所有bi邻居j的集合相等，从而新的_sel_adv（j）=1，I是j的首选接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) With the SANS updated, a new router-LSA may need to be originated as described in Section 9.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) 随着SAN的更新，可能需要按照第9.4节所述创建新的路由器LSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The lexicographical comparison of Step 5d gives preference to links that are already advertised, in order to improve LSA stability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了提高LSA的稳定性，第5d步的词典比较优先考虑已经公布的链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above algorithm can be run in O(d^2) time if a single link change occurs. For example, if link (x,y) fails where x and y are neighbors of router i, and either SANS(x,y) = 1 or BNM(x,y) = 1, then Step 5 need only be performed for pairs j, k such that either j or k is equal to x or y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果发生单链路更改，则上述算法可以在O（d^2）时间内运行。例如，如果链路（x，y）发生故障，其中x和y是路由器i的邻居，SANS（x，y）=1或BNM（x，y）=1，则只需对对j，k执行步骤5，以使j或k等于x或y。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix D. Non-Ackable LSAs for Periodic Flooding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录D.周期性洪水的不可确认LSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a highly mobile network, it is possible that a router almost always originates a new router-LSA every MinLSInterval seconds. In this case, it should not be necessary to send Acks for such an LSA, or to retransmit such an LSA as a unicast, or to describe such an LSA in a DD packet. In this case, the originator of an LSA MAY indicate that the router-LSA is &#34;non-ackable&#34; by setting the L bit in the options field of the LSA (see Section A.1). For example, a router can originate non-ackable LSAs if it determines (e.g., based on an exponential moving average) that a new LSA is originated every MinLSInterval seconds at least 90 percent of the time. (Simulations can be used to determine the best threshold.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在高度移动的网络中，路由器几乎总是每分钟间隔秒发起一个新的路由器LSA。在这种情况下，不必为这样的LSA发送ack，或者作为单播重新传输这样的LSA，或者在DD分组中描述这样的LSA。在这种情况下，LSA的发起者可以通过在LSA的选项字段中设置L位来指示路由器LSA是“不可确认的”（参见A.1节）。例如，如果路由器确定（例如，基于指数移动平均数）至少90%的时间每分钟间隔秒发起一个新的LSA，则路由器可以发起不可确认的LSA。（模拟可用于确定最佳阈值。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A non-ackable LSA is never acknowledged, nor is it ever retransmitted as a unicast or described in a DD packet, thus saving substantial overhead. However, the originating router must periodically retransmit the current instance of its router-LSA as a multicast (until it originates a new LSA, which will usually happen before the previous instance is retransmitted), and each MDR must periodically retransmit each non-ackable LSA as a multicast (until it receives a new instance of the LSA, which will usually happen before the previous instance is retransmitted). For this option to work, RxmtInterval must be larger than MinLSInterval so that a new instance of the LSA is usually received before the previous one is retransmitted. Note that the reception of a retransmitted (duplicate) LSA does not result in immediate forwarding of the LSA; only a new LSA (with a larger sequence number) may be forwarded immediately, according to the flooding procedure of Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不可确认的LSA从未被确认，也从未作为单播重新传输或在DD分组中描述，因此节省了大量开销。但是，发起路由器必须定期将其路由器LSA的当前实例作为多播重新传输（直到它发起新的LSA，这通常发生在前一个实例被重新传输之前），并且每个MDR必须定期将每个不可确认的LSA作为多播重新传输（直到它接收到LSA的新实例，这通常发生在重新传输前一个实例之前）。要使此选项起作用，RxmtInterval必须大于MinlInterval，以便在重新传输前一个LSA的新实例通常被接收。请注意，重新传输的接收（重复）LSA不会导致LSA的立即转发；根据第8节的泛洪程序，只能立即转发新的LSA（序列号较大）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix E. Simulation Results
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录E.模拟结果
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section presents simulation results that predict the performance of OSPF-MDR for up to 160 nodes with min-cost LSAs and up to 200 nodes with minimal LSAs. The results were obtained using the GTNetS simulator with OSPF-MDR version 1.01, available at http://hipserver.mct.phantomworks.org/ietf/ospf.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍了模拟结果，这些结果预测了OSPF-MDR在多达160个节点（最小成本LSA）和多达200个节点（最小成本LSA）的性能。结果是使用GTNetS模拟器和OSPF-MDR版本1.01获得的，可在http://hipserver.mct.phantomworks.org/ietf/ospf.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following scenario parameter values were used: radio range = 200 m and 250 m, grid length = 500 m, wireless alpha = 0.5, (maximum) velocity = 10 m/s, pause time = 0, packet rate = 10 pkts/s, packet size = 40 bytes, random seed = 8, start time (for gathering statistics) = 1800 s. The stop time was 3600 s for up to 80 nodes and 2700 s for more than 80 nodes. The source and destination are selected randomly for each generated UDP packet. The simulated MAC protocol is 802.11b.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用了以下场景参数值：无线电范围=200 m和250 m，网格长度=500 m，无线alpha=0.5，（最大）速度=10 m/s，暂停时间=0，数据包速率=10 pkts/s，数据包大小=40字节，随机种子=8，开始时间（用于收集统计数据）=1800 s。最多80个节点的停止时间为3600秒，超过80个节点的停止时间为2700秒。为每个生成的UDP数据包随机选择源和目标。模拟的MAC协议是802.11b。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tables 4 and 6 show the results for the default configuration of OSPF-MDR, except that differential Hellos were used (2HopRefresh = 3) since they are recommended when the number of neighbors is large. Tables 5 and 7 show the results for the same configuration except that minimal LSAs were used instead of min-cost LSAs. The tables show the results for total OSPF overhead in kb/s, the total number of OSPF packets per second, the delivery ratio for UDP packets, and the average number of hops traveled by UDP packets that reach their destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表4和表6显示了OSPF-MDR默认配置的结果，但使用了差分Hello（2HopRefresh=3），因为在邻居数量较大时建议使用差分Hello。表5和表7显示了相同配置的结果，只是使用了最小LSA而不是最小成本LSA。这些表显示了以kb/s为单位的OSPF总开销的结果、每秒OSPF数据包的总数、UDP数据包的传递率以及UDP数据包到达目的地的平均跳数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tables 5 and 7 for minimal LSAs also show the following statistics: the average number of bidirectional neighbors per node, the average number of fully adjacent neighbors per node, the number of changes in the set of bidirectional neighbors per node per second, and the number of changes in the set of fully adjacent neighbors per node per second. These statistics do not change significantly when min-cost LSAs are used instead of minimal LSAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小LSA的表5和表7还显示了以下统计信息：每个节点的双向邻居的平均数量、每个节点的完全相邻邻居的平均数量、每个节点每秒双向邻居集的更改数量以及每个节点每秒完全相邻邻居集的更改数量。当使用最小成本LSA而不是最小LSA时，这些统计数据不会发生显著变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results show that OSPF-MDR achieves good performance for up to at least 160 nodes when min-cost LSAs are used, and up to at least 200 nodes when minimal LSAs are used. Also, the results for the number of hops show that the routes obtained with minimal LSAs are only 2.3% to 4.5% longer than with min-cost LSAs when the range is 250 m, and 3.5% to 7.4% longer when the range is 200 m.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结果表明，当使用最小成本LSA时，OSPF-MDR可在至少160个节点上实现良好性能，当使用最小成本LSA时，可在至少200个节点上实现良好性能。此外，跳数的结果表明，当距离为250m时，使用最小LSA获得的路由仅比使用最小成本LSA获得的路由长2.3%到4.5%，当距离为200m时，使用最小成本LSA获得的路由长3.5%到7.4%。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The results also show that the number of adjacencies per node and the number of adjacency changes per node per second do not increase as the number of nodes increases, and are dramatically smaller than the number of neighbors per node and the number of neighbor changes per node per second, respectively. These factors contribute to the low overhead achieved by OSPF-MDR. For example, the results in Table 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结果还表明，每个节点的邻接数和每秒每个节点的邻接变化数不随节点数的增加而增加，分别显著小于每个节点的邻居数和每秒每个节点的邻居变化数。这些因素有助于OSPF-MDR实现低开销。例如，表5中的结果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
imply that with 200 nodes and range 250 m, there are 2.136/.039 = 55 times as many adjacency formations with full-topology adjacencies as with uniconnected adjacencies. Additional simulation results for OSPF-MDR can be found at http://www.manet-routing.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这意味着，对于200个节点和250 m的范围，具有全拓扑邻接的邻接结构的数量是具有单连接邻接结构的数量的2.136/.039=55倍。OSPF-MDR的其他模拟结果见http://www.manet-routing.org.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    100    120    160
   ------------------------------------------------------------------
   OSPF kb/s           27.1   74.2  175.3  248.6  354.6  479.2  795.7
   OSPF pkts/s         29.9   69.2  122.9  163.7  210.3  257.2  357.7
   Delivery ratio      .970   .968   .954   .958   .957   .956   .953
   Avg no. hops       1.433  1.348  1.389  1.368  1.411  1.361  1.386
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    100    120    160
   ------------------------------------------------------------------
   OSPF kb/s           27.1   74.2  175.3  248.6  354.6  479.2  795.7
   OSPF pkts/s         29.9   69.2  122.9  163.7  210.3  257.2  357.7
   Delivery ratio      .970   .968   .954   .958   .957   .956   .953
   Avg no. hops       1.433  1.348  1.389  1.368  1.411  1.361  1.386
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 4: Results for range 250 m with min-cost LSAs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表4：最小成本LSA范围250 m的结果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    120    160    200
   ------------------------------------------------------------------
   OSPF kb/s           15.5   41.6   91.0  132.9  246.3  419.0  637.4
   OSPF pkts/sec       18.8   42.5   78.6  102.8  166.8  245.6  321.0
   Delivery ratio      .968   .968   .951   .953   .962   .956   .951
   Avg no. hops       1.466  1.387  1.433  1.412  1.407  1.430  1.411
   Avg no. nbrs/node  11.38  25.82  36.30  50.13  75.87  98.65 125.59
   Avg no. adjs/node   2.60   2.32   2.38   2.26   2.25   2.32   2.13
   Nbr changes/node/s  .173   .372   .575   .752  1.223  1.654  2.136
   Adj changes/node/s  .035   .036   .046   .040   .032   .035   .039
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    120    160    200
   ------------------------------------------------------------------
   OSPF kb/s           15.5   41.6   91.0  132.9  246.3  419.0  637.4
   OSPF pkts/sec       18.8   42.5   78.6  102.8  166.8  245.6  321.0
   Delivery ratio      .968   .968   .951   .953   .962   .956   .951
   Avg no. hops       1.466  1.387  1.433  1.412  1.407  1.430  1.411
   Avg no. nbrs/node  11.38  25.82  36.30  50.13  75.87  98.65 125.59
   Avg no. adjs/node   2.60   2.32   2.38   2.26   2.25   2.32   2.13
   Nbr changes/node/s  .173   .372   .575   .752  1.223  1.654  2.136
   Adj changes/node/s  .035   .036   .046   .040   .032   .035   .039
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 5: Results for range 250 m with minimal LSAs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表5：最小LSA范围250 m的结果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    100    120    160
   ------------------------------------------------------------------
   OSPF kb/s           40.5  123.4  286.5  415.7  597.5  788.9 1309.8
   OSPF pkts/s         37.6   83.9  135.1  168.6  205.4  247.7  352.3
   Delivery ratio      .926   .919   .897   .900   .898   .895   .892
   Avg no. hops       1.790  1.628  1.666  1.632  1.683  1.608  1.641
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    100    120    160
   ------------------------------------------------------------------
   OSPF kb/s           40.5  123.4  286.5  415.7  597.5  788.9 1309.8
   OSPF pkts/s         37.6   83.9  135.1  168.6  205.4  247.7  352.3
   Delivery ratio      .926   .919   .897   .900   .898   .895   .892
   Avg no. hops       1.790  1.628  1.666  1.632  1.683  1.608  1.641
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 6: Results for range 200 m with min-cost LSAs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表6：最小成本LSA下200m范围的结果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    120    160    200
   ------------------------------------------------------------------
   OSPF kb/s           24.0   63.6  140.6  195.2  346.9  573.2  824.6
   OSPF pkts/sec       26.4   58.8  108.3  138.8  215.2  311.3  401.3
   Delivery ratio      .930   .927   .897   .907   .907   .904   .902
   Avg no. hops       1.853  1.714  1.771  1.743  1.727  1.758  1.747
   Avg no. nbrs/node   7.64  18.12  25.27  35.29  52.99  68.13  86.74
   Avg no. adjs/node   2.78   2.60   2.70   2.50   2.39   2.36   2.24
   Nbr changes/node/s  .199   .482   .702   .959  1.525  2.017  2.611
   Adj changes/node/s  .068   .069   .081   .068   .055   .058   .057
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      Number of nodes
                        20     40     60     80    120    160    200
   ------------------------------------------------------------------
   OSPF kb/s           24.0   63.6  140.6  195.2  346.9  573.2  824.6
   OSPF pkts/sec       26.4   58.8  108.3  138.8  215.2  311.3  401.3
   Delivery ratio      .930   .927   .897   .907   .907   .904   .902
   Avg no. hops       1.853  1.714  1.771  1.743  1.727  1.758  1.747
   Avg no. nbrs/node   7.64  18.12  25.27  35.29  52.99  68.13  86.74
   Avg no. adjs/node   2.78   2.60   2.70   2.50   2.39   2.36   2.24
   Nbr changes/node/s  .199   .482   .702   .959  1.525  2.017  2.611
   Adj changes/node/s  .068   .069   .081   .068   .055   .058   .057
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 7: Results for range 200 m with minimal LSAs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表7：最小LSA下200m范围的结果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard G. Ogier SRI International
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理查德·G·奥吉尔·斯里国际酒店
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: rich.ogier@earthlink.net or rich.ogier@gmail.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: rich.ogier@earthlink.net or rich.ogier@gmail.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phil Spagnolo Boeing Phantom Works
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
菲尔·斯帕格诺洛波音幻影工厂
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: phillipspagnolo@gmail.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: phillipspagnolo@gmail.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
