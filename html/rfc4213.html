<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 4213: Basic Transition Mechanisms for IPv6 Hosts and Routers中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC4213 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4213</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc4213.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">原文</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 4213: Basic Transition Mechanisms for IPv6 Hosts and Routers 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc4213" target="_blank">
              https://datatracker.ietf.org/doc/html/rfc4213
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 4213</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                        E. Nordmark
Request for Comments: 4213                        Sun Microsystems, Inc.
Obsoletes: 2893                                              R. Gilligan
Category: Standards Track                                 Intransa, Inc.
                                                            October 2005
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                        E. Nordmark
Request for Comments: 4213                        Sun Microsystems, Inc.
Obsoletes: 2893                                              R. Gilligan
Category: Standards Track                                 Intransa, Inc.
                                                            October 2005
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Basic Transition Mechanisms for IPv6 Hosts and Routers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
IPv6主机和路由器的基本转换机制
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2005年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies IPv4 compatibility mechanisms that can be implemented by IPv6 hosts and routers. Two mechanisms are specified, dual stack and configured tunneling. Dual stack implies providing complete implementations of both versions of the Internet Protocol (IPv4 and IPv6), and configured tunneling provides a means to carry IPv6 packets over unmodified IPv4 routing infrastructures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档指定了可由IPv6主机和路由器实现的IPv4兼容机制。指定了两种机制：双堆栈和配置隧道。双栈意味着提供两个版本的Internet协议（IPv4和IPv6）的完整实现，而配置的隧道则提供了一种通过未修改的IPv4路由基础结构承载IPv6数据包的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes RFC 2893.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件淘汰了RFC 2893。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................2
      1.1. Terminology ................................................3
   2. Dual IP Layer Operation .........................................4
      2.1. Address Configuration ......................................5
      2.2. DNS ........................................................5
   3. Configured Tunneling Mechanisms .................................6
      3.1. Encapsulation ..............................................7
      3.2. Tunnel MTU and Fragmentation ...............................8
           3.2.1. Static Tunnel MTU ...................................9
           3.2.2. Dynamic Tunnel MTU ..................................9
      3.3. Hop Limit .................................................11
      3.4. Handling ICMPv4 Errors ....................................11
      3.5. IPv4 Header Construction ..................................13
      3.6. Decapsulation .............................................14
      3.7. Link-Local Addresses ......................................17
      3.8. Neighbor Discovery over Tunnels ...........................18
   4. Threat Related to Source Address Spoofing ......................18
   5. Security Considerations ........................................19
   6. Acknowledgements ...............................................21
   7. References .....................................................21
      7.1. Normative References ......................................21
      7.2. Informative References ....................................21
   8. Changes from RFC 2893 ..........................................23
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................2
      1.1. Terminology ................................................3
   2. Dual IP Layer Operation .........................................4
      2.1. Address Configuration ......................................5
      2.2. DNS ........................................................5
   3. Configured Tunneling Mechanisms .................................6
      3.1. Encapsulation ..............................................7
      3.2. Tunnel MTU and Fragmentation ...............................8
           3.2.1. Static Tunnel MTU ...................................9
           3.2.2. Dynamic Tunnel MTU ..................................9
      3.3. Hop Limit .................................................11
      3.4. Handling ICMPv4 Errors ....................................11
      3.5. IPv4 Header Construction ..................................13
      3.6. Decapsulation .............................................14
      3.7. Link-Local Addresses ......................................17
      3.8. Neighbor Discovery over Tunnels ...........................18
   4. Threat Related to Source Address Spoofing ......................18
   5. Security Considerations ........................................19
   6. Acknowledgements ...............................................21
   7. References .....................................................21
      7.1. Normative References ......................................21
      7.2. Informative References ....................................21
   8. Changes from RFC 2893 ..........................................23
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key to a successful IPv6 transition is compatibility with the large installed base of IPv4 hosts and routers. Maintaining compatibility with IPv4 while deploying IPv6 will streamline the task of transitioning the Internet to IPv6. This specification defines two mechanisms that IPv6 hosts and routers may implement in order to be compatible with IPv4 hosts and routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功过渡IPv6的关键是与大量IPv4主机和路由器的兼容性。在部署IPv6的同时保持与IPv4的兼容性将简化将Internet转换为IPv6的任务。本规范定义了IPv6主机和路由器可以实现的两种机制，以便与IPv4主机和路由器兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanisms in this document are designed to be employed by IPv6 hosts and routers that need to interoperate with IPv4 hosts and utilize IPv4 routing infrastructures. We expect that most nodes in the Internet will need such compatibility for a long time to come, and perhaps even indefinitely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档中的机制设计用于需要与IPv4主机互操作并利用IPv4路由基础设施的IPv6主机和路由器。我们预计，互联网上的大多数节点在很长一段时间内，甚至可能无限期地需要这种兼容性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanisms specified here are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此处指定的机制是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Dual IP layer (also known as dual stack): A technique for providing complete support for both Internet protocols -- IPv4 and IPv6 -- in hosts and routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 双IP层（也称为双堆栈）：一种在主机和路由器中为Internet协议（IPv4和IPv6）提供完全支持的技术。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Configured tunneling of IPv6 over IPv4: A technique for establishing point-to-point tunnels by encapsulating IPv6 packets within IPv4 headers to carry them over IPv4 routing infrastructures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv4上配置的IPv6隧道：一种通过将IPv6数据包封装在IPv4报头中以在IPv4路由基础设施上传输来建立点对点隧道的技术。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanisms defined here are intended to be the core of a &#34;transition toolbox&#34; -- a growing collection of techniques that implementations and users may employ to ease the transition. The tools may be used as needed. Implementations and sites decide which techniques are appropriate to their specific needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里定义的机制旨在成为“过渡工具箱”的核心，过渡工具箱是实现和用户可以用来简化过渡的越来越多的技术集合。可根据需要使用这些工具。实现和站点决定哪些技术适合它们的特定需求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines the basic set of transition mechanisms, but these are not the only tools available. Additional transition and compatibility mechanisms are specified in other documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档定义了一组基本的转换机制，但这些并不是唯一可用的工具。其他文件中规定了其他转换和兼容性机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 术语
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following terms are used in this document:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中使用了以下术语：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Types of Nodes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点类型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv4-only node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
仅IPv4节点：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
A host or router that implements only IPv4. An IPv4-only node does not understand IPv6. The installed base of IPv4 hosts and routers existing before the transition begins are IPv4-only nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
仅实现IPv4的主机或路由器。仅IPv4节点不理解IPv6。转换开始之前存在的IPv4主机和路由器的安装基数是仅IPv4节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6/IPv4 node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6/IPv4节点：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
A host or router that implements both IPv4 and IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
同时实现IPv4和IPv6的主机或路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6-only node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
仅限IPv6的节点：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
A host or router that implements IPv6 and does not implement IPv4. The operation of IPv6-only nodes is not addressed in this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
实现IPv6而不实现IPv4的主机或路由器。本备忘录中未说明仅限IPv6节点的操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6 node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6节点：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Any host or router that implements IPv6. IPv6/IPv4 and IPv6- only nodes are both IPv6 nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
实现IPv6的任何主机或路由器。IPv6/IPv4和仅IPv6的节点都是IPv6节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv4 node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv4节点：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Any host or router that implements IPv4. IPv6/IPv4 and IPv4- only nodes are both IPv4 nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
实现IPv4的任何主机或路由器。IPv6/IPv4和仅IPv4的节点都是IPv4节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Techniques Used in the Transition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
过渡时期使用的技术
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6-over-IPv4 tunneling:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IPv6-over-IPv4隧道：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The technique of encapsulating IPv6 packets within IPv4 so that they can be carried across IPv4 routing infrastructures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
在IPv4中封装IPv6数据包的技术，以便它们可以跨IPv4路由基础结构进行传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Configured tunneling:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
配置的隧道：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
IPv6-over-IPv4 tunneling where the IPv4 tunnel endpoint address(es) are determined by configuration information on tunnel endpoints. All tunnels are assumed to be bidirectional. The tunnel provides a (virtual) point-to-point link to the IPv6 layer, using the configured IPv4 addresses as the lower-layer endpoint addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
IPv6-over-IPv4隧道，其中IPv4隧道端点地址由隧道端点上的配置信息确定。假设所有隧道都是双向的。隧道使用配置的IPv4地址作为下层端点地址，提供到IPv6层的（虚拟）点到点链路。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other transition mechanisms, including other tunneling mechanisms, are outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其他过渡机制，包括其他隧道机制，不在本文件范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this document, are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中出现的关键词必须、不得、要求、应、不应、应、不应、建议、可能和可选时，应按照[RFC2119]中的说明进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Dual IP Layer Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 双IP层操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most straightforward way for IPv6 nodes to remain compatible with IPv4-only nodes is by providing a complete IPv4 implementation. IPv6 nodes that provide complete IPv4 and IPv6 implementations are called &#34;IPv6/IPv4 nodes&#34;. IPv6/IPv4 nodes have the ability to send and receive both IPv4 and IPv6 packets. They can directly interoperate with IPv4 nodes using IPv4 packets, and also directly interoperate with IPv6 nodes using IPv6 packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6节点保持与仅IPv4节点兼容的最直接的方法是提供完整的IPv4实现。提供完整IPv4和IPv6实现的IPv6节点称为“IPv6/IPv4节点”。IPv6/IPv4节点能够发送和接收IPv4和IPv6数据包。它们可以使用IPv4数据包直接与IPv4节点互操作，也可以使用IPv6数据包直接与IPv6节点互操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even though a node may be equipped to support both protocols, one or the other stack may be disabled for operational reasons. Here we use a rather loose notion of &#34;stack&#34;. A stack being enabled has IP addresses assigned, but whether or not any particular application is available on the stacks is explicitly not defined. Thus, IPv6/IPv4 nodes may be operated in one of three modes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
即使一个节点可能装备为支持这两个协议，一个或另一个堆栈也可能由于操作原因而被禁用。这里我们使用了一个相当松散的“堆栈”概念。正在启用的堆栈已分配IP地址，但未明确定义堆栈上是否有任何特定应用程序可用。因此，IPv6/IPv4节点可在三种模式之一下运行：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- With their IPv4 stack enabled and their IPv6 stack disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 其IPv4堆栈已启用，IPv6堆栈已禁用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- With their IPv6 stack enabled and their IPv4 stack disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 其IPv6堆栈已启用，IPv4堆栈已禁用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- With both stacks enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 启用两个堆栈时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6/IPv4 nodes with their IPv6 stack disabled will operate like IPv4-only nodes. Similarly, IPv6/IPv4 nodes with their IPv4 stacks
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
禁用IPv6堆栈的IPv6/IPv4节点将像只运行IPv4的节点一样运行。类似地，IPv6/IPv4节点及其IPv4堆栈
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
disabled will operate like IPv6-only nodes. IPv6/IPv4 nodes MAY provide a configuration switch to disable either their IPv4 or IPv6 stack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
禁用将像仅IPv6节点一样运行。IPv6/IPv4节点可以提供配置交换机来禁用其IPv4或IPv6堆栈。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The configured tunneling technique, which is described in Section 3, may or may not be used in addition to the dual IP layer operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了双IP层操作之外，还可以使用第3节中描述的配置隧道技术，也可以不使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Address Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 地址配置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the nodes support both protocols, IPv6/IPv4 nodes may be configured with both IPv4 and IPv6 addresses. IPv6/IPv4 nodes use IPv4 mechanisms (e.g., DHCP) to acquire their IPv4 addresses, and IPv6 protocol mechanisms (e.g., stateless address autoconfiguration [RFC2462] and/or DHCPv6) to acquire their IPv6 addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因为节点同时支持这两种协议，所以IPv6/IPv4节点可以同时配置IPv4和IPv6地址。IPv6/IPv4节点使用IPv4机制（例如DHCP）获取其IPv4地址，使用IPv6协议机制（例如无状态地址自动配置[RFC2462]和/或DHCPv6）获取其IPv6地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. DNS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 域名服务器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Domain Naming System (DNS) is used in both IPv4 and IPv6 to map between hostnames and IP addresses. A new resource record type named &#34;AAAA&#34; has been defined for IPv6 addresses [RFC3596]. Since IPv6/IPv4 nodes must be able to interoperate directly with both IPv4 and IPv6 nodes, they must provide resolver libraries capable of dealing with IPv4 &#34;A&#34; records as well as IPv6 &#34;AAAA&#34; records. Note that the lookup of A versus AAAA records is independent of whether the DNS packets are carried in IPv4 or IPv6 packets and that there is no assumption that the DNS servers know the IPv4/IPv6 capabilities of the requesting node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4和IPv6都使用域名系统（DNS）在主机名和IP地址之间进行映射。已为IPv6地址定义了名为“AAAA”的新资源记录类型[RFC3596]。由于IPv6/IPv4节点必须能够直接与IPv4和IPv6节点进行互操作，因此它们必须提供能够处理IPv4“A”记录以及IPv6“AAAA”记录的解析器库。请注意，A与AAAA记录的查找与DNS数据包是在IPv4还是IPv6数据包中携带无关，并且不假设DNS服务器知道请求节点的IPv4/IPv6功能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The issues and operational guidelines for using IPv6 with DNS are described at more length in other documents, e.g., [DNSOPV6].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在其他文档（例如[DNSOPV6]）中更详细地描述了将IPv6与DNS结合使用的问题和操作指南。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DNS resolver libraries on IPv6/IPv4 nodes MUST be capable of handling both AAAA and A records. However, when a query locates an AAAA record holding an IPv6 address, and an A record holding an IPv4 address, the resolver library MAY order the results returned to the application in order to influence the version of IP packets used to communicate with that specific node -- IPv6 first, or IPv4 first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6/IPv4节点上的DNS解析程序库必须能够处理AAAA和A记录。但是，当查询查找到包含IPv6地址的AAAA记录和包含IPv4地址的a记录时，解析程序库可能会对返回给应用程序的结果进行排序，以便影响用于与该特定节点通信的IP数据包的版本—IPv6优先，或IPv4优先。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The applications SHOULD be able to specify whether they want IPv4, IPv6, or both records [RFC3493]. That defines which address families the resolver looks up. If there is not an application choice, or if the application has requested both, the resolver library MUST NOT filter out any records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序应该能够指定是需要IPv4、IPv6还是同时需要这两个记录[RFC3493]。它定义解析程序查找的地址族。如果没有应用程序选择，或者应用程序同时请求了这两个选项，则解析程序库不得过滤掉任何记录。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since most applications try the addresses in the order they are returned by the resolver, this can affect the IP version &#34;preference&#34; of applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于大多数应用程序都会按照解析程序返回的顺序尝试地址，这可能会影响应用程序的IP版本“首选项”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The actual ordering mechanisms are out of scope of this memo. Address selection is described at more length in [RFC3484].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实际订购机制不在本备忘录的范围内。[RFC3484]中详细描述了地址选择。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Configured Tunneling Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 配置隧道机制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In most deployment scenarios, the IPv6 routing infrastructure will be built up over time. While the IPv6 infrastructure is being deployed, the existing IPv4 routing infrastructure can remain functional and can be used to carry IPv6 traffic. Tunneling provides a way to utilize an existing IPv4 routing infrastructure to carry IPv6 traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在大多数部署场景中，IPv6路由基础设施将随着时间的推移而建立。在部署IPv6基础设施时，现有的IPv4路由基础设施可以保持功能，并可用于承载IPv6流量。隧道提供了一种利用现有IPv4路由基础设施来承载IPv6流量的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6/IPv4 hosts and routers can tunnel IPv6 datagrams over regions of IPv4 routing topology by encapsulating them within IPv4 packets. Tunneling can be used in a variety of ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6/IPv4主机和路由器可以通过将IPv6数据报封装在IPv4数据包中，在IPv4路由拓扑的区域上对其进行隧道传输。隧道可通过多种方式使用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Router-to-Router. IPv6/IPv4 routers interconnected by an IPv4 infrastructure can tunnel IPv6 packets between themselves. In this case, the tunnel spans one segment of the end-to-end path that the IPv6 packet takes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 路由器对路由器。由IPv4基础设施互连的IPv6/IPv4路由器可以在它们之间通过隧道传输IPv6数据包。在这种情况下，隧道跨越IPv6数据包所采用的端到端路径的一段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Host-to-Router. IPv6/IPv4 hosts can tunnel IPv6 packets to an intermediary IPv6/IPv4 router that is reachable via an IPv4 infrastructure. This type of tunnel spans the first segment of the packet&#39;s end-to-end path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 主机到路由器。IPv6/IPv4主机可以通过隧道将IPv6数据包传输到可通过IPv4基础结构访问的中间IPv6/IPv4路由器。这种类型的隧道跨越数据包端到端路径的第一段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Host-to-Host. IPv6/IPv4 hosts that are interconnected by an IPv4 infrastructure can tunnel IPv6 packets between themselves. In this case, the tunnel spans the entire end-to-end path that the packet takes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 主机对主机。由IPv4基础结构互连的IPv6/IPv4主机可以在它们之间通过隧道传输IPv6数据包。在这种情况下，隧道跨越数据包所采用的整个端到端路径。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Router-to-Host. IPv6/IPv4 routers can tunnel IPv6 packets to their final destination IPv6/IPv4 host. This tunnel spans only the last segment of the end-to-end path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 路由器到主机。IPv6/IPv4路由器可以通过隧道将IPv6数据包传输到其最终目标IPv6/IPv4主机。此隧道仅跨越端到端路径的最后一段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Configured tunneling can be used in all of the above cases, but it is most likely to be used router-to-router due to the need to explicitly configure the tunneling endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置的隧道可用于上述所有情况，但由于需要显式配置隧道端点，因此最有可能用于路由器到路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The underlying mechanisms for tunneling are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
隧道的基本机制是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The entry node of the tunnel (the encapsulator) creates an encapsulating IPv4 header and transmits the encapsulated packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 隧道的入口节点（封装器）创建封装的IPv4报头并传输封装的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The exit node of the tunnel (the decapsulator) receives the encapsulated packet, reassembles the packet if needed, removes the IPv4 header, and processes the received IPv6 packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 隧道的出口节点（解封装器）接收封装的数据包，根据需要重新组装数据包，删除IPv4报头，并处理接收到的IPv6数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The encapsulator may need to maintain soft-state information for each tunnel recording such parameters as the MTU of the tunnel in order to process IPv6 packets forwarded into the tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 封装器可能需要为记录诸如隧道的MTU之类的参数的每个隧道维护软状态信息，以便处理转发到隧道中的IPv6分组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In configured tunneling, the tunnel endpoint addresses are determined in the encapsulator from configuration information stored for each tunnel. When an IPv6 packet is transmitted over a tunnel, the destination and source addresses for the encapsulating IPv4 header are set as described in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在已配置的隧道中，隧道端点地址在封装器中根据为每个隧道存储的配置信息确定。当通过隧道传输IPv6数据包时，封装IPv4报头的目标和源地址将按照第3.5节中的说明进行设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The determination of which packets to tunnel is usually made by routing information on the encapsulator. This is usually done via a routing table, which directs packets based on their destination address using the prefix mask and match technique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常通过封装器上的路由信息来确定要通过隧道传输的数据包。这通常是通过路由表完成的，路由表使用前缀掩码和匹配技术根据数据包的目的地地址指示数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decapsulator matches the received protocol-41 packets to the tunnels it has configured, and allows only the packets in which IPv4 source addresses match the tunnels configured on the decapsulator. Therefore, the operator must ensure that the tunnel&#39;s IPv4 address configuration is the same both at the encapsulator and the decapsulator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解封装器将接收到的protocol-41数据包与其配置的隧道相匹配，并且仅允许IPv4源地址与解封装器上配置的隧道相匹配的数据包。因此，运营商必须确保隧道的IPv4地址配置在封装器和解封装器上相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Encapsulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 封装
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encapsulation of an IPv6 datagram in IPv4 is shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4中IPv6数据报的封装如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                             +-------------+
                                             |    IPv4     |
                                             |   Header    |
             +-------------+                 +-------------+
             |    IPv6     |                 |    IPv6     |
             |   Header    |                 |   Header    |
             +-------------+                 +-------------+
             |  Transport  |                 |  Transport  |
             |   Layer     |      ===&gt;       |   Layer     |
             |   Header    |                 |   Header    |
             +-------------+                 +-------------+
             |             |                 |             |
             ~    Data     ~                 ~    Data     ~
             |             |                 |             |
             +-------------+                 +-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                             +-------------+
                                             |    IPv4     |
                                             |   Header    |
             +-------------+                 +-------------+
             |    IPv6     |                 |    IPv6     |
             |   Header    |                 |   Header    |
             +-------------+                 +-------------+
             |  Transport  |                 |  Transport  |
             |   Layer     |      ===&gt;       |   Layer     |
             |   Header    |                 |   Header    |
             +-------------+                 +-------------+
             |             |                 |             |
             ~    Data     ~                 ~    Data     ~
             |             |                 |             |
             +-------------+                 +-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Encapsulating IPv6 in IPv4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
在IPv4中封装IPv6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to adding an IPv4 header, the encapsulator also has to handle some more complex issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了添加IPv4标头外，封装器还必须处理一些更复杂的问题：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Determine when to fragment and when to report an ICMPv6 &#34;packet too big&#34; error back to the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 确定何时对ICMPv6“数据包太大”错误进行分段以及何时向源报告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- How to reflect ICMPv4 errors from routers along the tunnel path back to the source as ICMPv6 errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 如何将路由器沿隧道路径返回到源的ICMPv4错误反映为ICMPv6错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Those issues are discussed in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下各节将讨论这些问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Tunnel MTU and Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 隧道MTU与破碎
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Naively, the encapsulator could view encapsulation as IPv6 using IPv4 as a link layer with a very large MTU (65535-20 bytes at most; 20 bytes &#34;extra&#34; are needed for the encapsulating IPv4 header). The encapsulator would only need to report ICMPv6 &#34;packet too big&#34; errors back to the source for packets that exceed this MTU. However, such a scheme would be inefficient or non-interoperable for three reasons and therefore MUST NOT be used:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
天真地说，封装者可以将封装视为IPv6，使用IPv4作为具有非常大MTU的链路层（最多65535-20字节；封装IPv4报头需要20字节“额外”）。对于超过此MTU的数据包，封装器只需向源报告ICMPv6“数据包太大”错误。但是，由于三个原因，此类方案效率低下或不可互操作，因此不得使用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) It would result in more fragmentation than needed. IPv4 layer fragmentation should be avoided due to the performance problems caused by the loss unit being smaller than the retransmission unit [KM97].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) 这将导致比需要更多的碎片。由于丢失单元小于重传单元[KM97]导致的性能问题，应避免IPv4层碎片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) Any IPv4 fragmentation occurring inside the tunnel, i.e., between the encapsulator and the decapsulator, would have to be reassembled at the tunnel endpoint. For tunnels that terminate at a router, this would require additional memory and other resources to reassemble the IPv4 fragments into a complete IPv6 packet before that packet could be forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) 隧道内发生的任何IPv4碎片，即封装器和解封装器之间的碎片，都必须在隧道端点重新组装。对于在路由器上终止的隧道，这将需要额外的内存和其他资源来将IPv4片段重新组装成完整的IPv6数据包，然后才能转发该数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3) The encapsulator has no way of knowing that the decapsulator is able to defragment such IPv4 packets (see Section 3.6 for details), and has no way of knowing that the decapsulator is able to handle such a large IPv6 Maximum Receive Unit (MRU).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3) 封装器无法知道解封装器是否能够对此类IPv4数据包进行碎片整理（有关详细信息，请参阅第3.6节），也无法知道解封装器是否能够处理如此大的IPv6最大接收单元（MRU）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hence, the encapsulator MUST NOT treat the tunnel as an interface with an MTU of 64 kilobytes, but instead either use the fixed static MTU or OPTIONAL dynamic MTU determination based on the IPv4 path MTU to the tunnel endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，封装器不得将隧道视为具有64 KB MTU的接口，而是使用固定静态MTU或基于到隧道端点的IPv4路径MTU的可选动态MTU确定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If both the mechanisms are implemented, the decision of which to use SHOULD be configurable on a per-tunnel endpoint basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果实现了这两种机制，则应根据每个隧道端点配置使用哪种机制的决策。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Static Tunnel MTU
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. 静态隧道MTU
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node using static tunnel MTU treats the tunnel interface as having a fixed-interface MTU. By default, the MTU MUST be between 1280 and 1480 bytes (inclusive), but it SHOULD be 1280 bytes. If the default is not 1280 bytes, the implementation MUST have a configuration knob that can be used to change the MTU value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用静态隧道MTU的节点将隧道接口视为具有固定接口MTU。默认情况下，MTU必须介于1280和1480字节（含）之间，但应为1280字节。如果默认值不是1280字节，则实现必须具有可用于更改MTU值的配置旋钮。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node must be able to accept a fragmented IPv6 packet that, after reassembly, is as large as 1500 octets [RFC2460]. This memo also includes requirements (see Section 3.6) for the amount of IPv4 reassembly and IPv6 MRU that MUST be supported by all the decapsulators. These ensure correct interoperability with any fixed MTUs between 1280 and 1480 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点必须能够接受碎片化的IPv6数据包，在重新组装后，该数据包的大小可达1500个八位字节[RFC2460]。本备忘录还包括所有去封装器必须支持的IPv4重新组装和IPv6 MRU数量要求（见第3.6节）。这些可确保与1280和1480字节之间的任何固定MTU的正确互操作性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A larger fixed MTU than supported by these requirements must not be configured unless it has been administratively ensured that the decapsulator can reassemble or receive packets of that size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不得配置比这些要求支持的更大的固定MTU，除非已从管理上确保去封装器可以重新组装或接收该大小的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The selection of a good tunnel MTU depends on many factors, at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择好的隧道MTU取决于许多因素，至少：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Whether the IPv4 protocol-41 packets will be transported over media that may have a lower path MTU (e.g., IPv4 Virtual Private Networks); then picking too high a value might lead to IPv4 fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv4协议-41数据包是否将通过可能具有较低路径MTU的媒体（例如，IPv4虚拟专用网络）传输；然后选择太高的值可能会导致IPv4碎片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Whether the tunnel is used to transport IPv6 tunneled packets (e.g., a mobile node with an IPv6-in-IPv4 configured tunnel, and an IPv6-in-IPv6 tunnel interface); then picking too low a value might lead to IPv6 fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 隧道是否用于传输IPv6隧道包（例如，具有IPv6-in-IPv4配置隧道和IPv6-in-IPv6隧道接口的移动节点）；然后选择太低的值可能会导致IPv6碎片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If layered encapsulation is believed to be present, it may be prudent to consider supporting dynamic MTU determination instead as it is able to minimize fragmentation and optimize packet sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果认为分层封装存在，则可以谨慎地考虑支持动态MTU确定，因为它能够最小化碎裂和优化分组大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using the static tunnel MTU, the Don&#39;t Fragment bit MUST NOT be set in the encapsulating IPv4 header. As a result, the encapsulator should not receive any ICMPv4 &#34;packet too big&#34; messages as a result of the packets it has encapsulated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用静态隧道MTU时，不得在封装IPv4标头中设置“不分段”位。因此，封装器不应因其封装的数据包而接收任何ICMPv4“数据包太大”消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. Dynamic Tunnel MTU
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. 动态隧道MTU
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dynamic MTU determination is OPTIONAL. However, if it is implemented, it SHOULD have the behavior described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
动态MTU测定是可选的。但是，如果实现了它，它应该具有本文档中描述的行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fragmentation inside the tunnel can be reduced to a minimum by having the encapsulator track the IPv4 path MTU across the tunnel, using the IPv4 Path MTU Discovery Protocol [RFC1191] and recording
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过让封装器使用IPv4路径MTU发现协议[RFC1191]和记录跨隧道跟踪IPv4路径MTU，可以将隧道内的碎片减少到最小
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the resulting path MTU. The IPv6 layer in the encapsulator can then view a tunnel as a link layer with an MTU equal to the IPv4 path MTU, minus the size of the encapsulating IPv4 header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结果路径MTU。然后，封装器中的IPv6层可以将隧道视为MTU等于IPv4路径MTU减去封装IPv4报头大小的链路层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this does not eliminate IPv4 fragmentation in the case when the IPv4 path MTU would result in an IPv6 MTU less than 1280 bytes. (Any link layer used by IPv6 has to have an MTU of at least 1280 bytes [RFC2460].) In this case, the IPv6 layer has to &#34;see&#34; a link layer with an MTU of 1280 bytes and the encapsulator has to use IPv4 fragmentation in order to forward the 1280 byte IPv6 packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，当IPv4路径MTU将导致IPv6 MTU小于1280字节时，这不会消除IPv4碎片。（IPv6使用的任何链路层必须具有至少1280字节的MTU[RFC2460]）在这种情况下，IPv6层必须“查看”MTU为1280字节的链路层，并且封装器必须使用IPv4分段以转发1280字节的IPv6数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encapsulator SHOULD employ the following algorithm to determine when to forward an IPv6 packet that is larger than the tunnel&#39;s path MTU using IPv4 fragmentation, and when to return an ICMPv6 &#34;packet too big&#34; message per [RFC1981]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
封装器应采用以下算法来确定何时使用IPv4分段转发大于隧道路径MTU的IPv6数据包，以及何时根据[RFC1981]返回ICMPv6“数据包太大”消息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         if (IPv4 path MTU - 20) is less than 1280
                 if packet is larger than 1280 bytes
                         Send ICMPv6 &#34;packet too big&#34; with MTU = 1280.
                         Drop packet.
                 else
                         Encapsulate but do not set the Don&#39;t Fragment
                         flag in the IPv4 header.  The resulting IPv4
                         packet might be fragmented by the IPv4 layer
                         on the encapsulator or by some router along
                         the IPv4 path.
                 endif
         else
                 if packet is larger than (IPv4 path MTU - 20)
                         Send ICMPv6 &#34;packet too big&#34; with
                         MTU = (IPv4 path MTU - 20).
                         Drop packet.
                 else
                         Encapsulate and set the Don&#39;t Fragment flag
                         in the IPv4 header.
                 endif
         endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         if (IPv4 path MTU - 20) is less than 1280
                 if packet is larger than 1280 bytes
                         Send ICMPv6 &#34;packet too big&#34; with MTU = 1280.
                         Drop packet.
                 else
                         Encapsulate but do not set the Don&#39;t Fragment
                         flag in the IPv4 header.  The resulting IPv4
                         packet might be fragmented by the IPv4 layer
                         on the encapsulator or by some router along
                         the IPv4 path.
                 endif
         else
                 if packet is larger than (IPv4 path MTU - 20)
                         Send ICMPv6 &#34;packet too big&#34; with
                         MTU = (IPv4 path MTU - 20).
                         Drop packet.
                 else
                         Encapsulate and set the Don&#39;t Fragment flag
                         in the IPv4 header.
                 endif
         endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encapsulators that have a large number of tunnels may choose between dynamic versus static tunnel MTUs on a per-tunnel endpoint basis. In cases where the number of tunnels that any one node is using is large, it is helpful to observe that this state information can be cached and discarded when not in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具有大量隧道的封装器可以根据每个隧道端点在动态隧道MTU和静态隧道MTU之间进行选择。在任何一个节点正在使用的隧道数量很大的情况下，观察不使用时可以缓存和丢弃该状态信息是很有帮助的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that using dynamic tunnel MTU is subject to IPv4 path MTU blackholes should the ICMPv4 &#34;packet too big&#34; messages be dropped by firewalls or not generated by the routers [RFC1435, RFC2923].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，如果防火墙丢弃ICMPv4“数据包太大”消息或路由器不生成该消息，则使用动态隧道MTU会受到IPv4路径MTU黑洞的影响[RFC1435，RFC2923]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Hop Limit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 跳数限制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6-over-IPv4 tunnels are modeled as &#34;single-hop&#34; from the IPv6 perspective. The tunnel is opaque to users of the network, and it is not detectable by network diagnostic tools such as traceroute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从IPv6的角度来看，IPv6-over-IPv4隧道被建模为“单跳”。隧道对网络用户来说是不透明的，并且不能被网络诊断工具（如traceroute）检测到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single-hop model is implemented by having the encapsulators and decapsulators process the IPv6 hop limit field as they would if they were forwarding a packet on to any other datalink. That is, they decrement the hop limit by 1 when forwarding an IPv6 packet. (The originating node and final destination do not decrement the hop limit.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单跳模型是通过让封装器和解封装器处理IPv6跃点限制字段来实现的，就像它们将数据包转发到任何其他数据链路时一样。也就是说，它们在转发IPv6数据包时将跃点限制减少1。（发起节点和最终目的地不减少跃点限制。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TTL of the encapsulating IPv4 header is selected in an implementation-dependent manner. The current suggested value is published in the &#34;Assigned Numbers&#34; RFC [RFC3232][ASSIGNED]. Implementations MAY provide a mechanism to allow the administrator to configure the IPv4 TTL as the IP Tunnel MIB [RFC4087].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
封装IPv4报头的TTL是以依赖于实现的方式选择的。当前建议值发布在“指定编号”RFC[RFC3232][Assigned]中。实现可能提供一种机制，允许管理员将IPv4 TTL配置为IP隧道MIB[RFC4087]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Handling ICMPv4 Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 处理ICMPv4错误
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In response to encapsulated packets it has sent into the tunnel, the encapsulator might receive ICMPv4 error messages from IPv4 routers inside the tunnel. These packets are addressed to the encapsulator because it is the IPv4 source of the encapsulated packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为对已发送到隧道中的封装数据包的响应，封装器可能会从隧道内的IPv4路由器接收ICMPv4错误消息。这些数据包被发送到封装器，因为它是封装数据包的IPv4源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv4 error handling is only applicable to dynamic MTU determination, even though the functions could be used with static MTU tunnels as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv4错误处理仅适用于动态MTU确定，即使该函数也可用于静态MTU隧道。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ICMPv4 &#34;packet too big&#34; error messages are handled according to IPv4 Path MTU Discovery [RFC1191] and the resulting path MTU is recorded in the IPv4 layer. The recorded path MTU is used by IPv6 to determine if an ICMPv6 &#34;packet too big&#34; error has to be generated as described in Section 3.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMPv4“数据包太大”错误消息根据IPv4路径MTU发现[RFC1191]进行处理，结果路径MTU记录在IPv4层中。IPv6使用记录的路径MTU来确定是否必须生成第3.2.2节所述的ICMPv6“数据包太大”错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handling of other types of ICMPv4 error messages depends on how much information is available from the encapsulated packet that caused the error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其他类型ICMPv4错误消息的处理取决于导致错误的封装数据包中有多少信息可用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many older IPv4 routers return only 8 bytes of data beyond the IPv4 header of the packet in error, which is not enough to include the address fields of the IPv6 header. More modern IPv4 routers are likely to return enough data beyond the IPv4 header to include the entire IPv6 header and possibly even the data beyond that. See [RFC1812].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
许多较旧的IPv4路由器只返回数据包IPv4报头以外的8字节数据，这不足以包含IPv6报头的地址字段。更现代的IPv4路由器可能会返回足够多的超出IPv4报头的数据，以包括整个IPv6报头，甚至可能包括超出该报头的数据。参见[RFC1812]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If sufficient data bytes from the offending packet are available, the encapsulator MAY extract the encapsulated IPv6 packet and use it to generate an ICMPv6 message directed back to the originating IPv6 node, as shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果有足够的数据字节来自违规数据包，则封装者可以提取封装的IPv6数据包，并使用它生成定向回发起IPv6节点的ICMPv6消息，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                         +--------------+
                         | IPv4 Header  |
                         | dst = encaps |
                         |       node   |
                         +--------------+
                         |    ICMPv4    |
                         |    Header    |
                  - -    +--------------+
                         | IPv4 Header  |
                         | src = encaps |
                 IPv4    |       node   |
                         +--------------+   - -
                 Packet  |    IPv6      |
                         |    Header    |   Original IPv6
                  in     +--------------+   Packet -
                         |  Transport   |   Can be used to
                 Error   |    Header    |   generate an
                         +--------------+   ICMPv6
                         |              |   error message
                         ~     Data     ~   back to the source.
                         |              |
                  - -    +--------------+   - -
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                         +--------------+
                         | IPv4 Header  |
                         | dst = encaps |
                         |       node   |
                         +--------------+
                         |    ICMPv4    |
                         |    Header    |
                  - -    +--------------+
                         | IPv4 Header  |
                         | src = encaps |
                 IPv4    |       node   |
                         +--------------+   - -
                 Packet  |    IPv6      |
                         |    Header    |   Original IPv6
                  in     +--------------+   Packet -
                         |  Transport   |   Can be used to
                 Error   |    Header    |   generate an
                         +--------------+   ICMPv6
                         |              |   error message
                         ~     Data     ~   back to the source.
                         |              |
                  - -    +--------------+   - -
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
ICMPv4 Error Message Returned to Encapsulating Node
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
ICMPv4错误消息返回到封装节点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When receiving ICMPv4 errors as above and the errors are not &#34;packet too big&#34;, it would be useful to log the error as an error related to the tunnel. Also, if sufficient headers are available, then the originating node MAY send an ICMPv6 error of type &#34;unreachable&#34; with code &#34;address unreachable&#34; to the IPv6 source. (The &#34;address unreachable&#34; code is appropriate since, from the perspective of IPv6, the tunnel is a link and that code is used for link-specific errors [RFC2463]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收到如上所述的ICMPv4错误并且错误不是“数据包太大”时，将错误记录为与隧道相关的错误将非常有用。此外，如果有足够的报头可用，则发起节点可能会向IPv6源发送“不可访问”类型的ICMPv6错误，代码为“地址不可访问”。（从IPv6的角度来看，“地址不可到达”代码是合适的，因为隧道是一条链路，该代码用于链路特定错误[RFC2463]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when the IPv4 path MTU is exceeded, and sufficient bytes of payload associated with the ICMPv4 errors are not available, or ICMPv4 errors do not cause the generation of ICMPv6 errors in case there is enough payload, there will be at least two packet drops instead of at least one (the case of a single layer of MTU discovery). Consider a case where an IPv6 host is connected to an IPv4/IPv6 router, which is connected to a network where an ICMPv4 error about too big packet size is generated. First, the router needs to learn the tunnel (IPv4) MTU that causes at least one packet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，如果超过IPv4路径MTU，并且与ICMPv4错误相关的有效负载字节数不足，或者ICMPv4错误不会导致产生ICMPv6错误（如果有足够的有效负载），则至少会有两个数据包丢弃，而不是至少一个（在MTU发现的单层情况下）。考虑一种IPv6主机连接到IPv4/IPv6路由器的情况，该路由器连接到一个网络，在该网络中产生了太大的包大小的ICMPv4错误。首先，路由器需要了解导致至少一个数据包的隧道（IPv4）MTU
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
loss, and then the host needs to learn the (IPv6) MTU from the router that causes at least one packet loss. Still, in all cases there can be more than one packet loss if there are multiple large packets in flight at the same time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
丢失，然后主机需要从路由器了解导致至少一个数据包丢失的（IPv6）MTU。尽管如此，在所有情况下，如果同时有多个大数据包在传输中，可能会有多个数据包丢失。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. IPv4 Header Construction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. IPv4报头构造
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When encapsulating an IPv6 packet in an IPv4 datagram, the IPv4 header fields are set as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在IPv4数据报中封装IPv6数据包时，IPv4标头字段设置如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Version:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
版本：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
4.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IP Header Length in 32-bit words:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IP标头长度（32位字）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
5 (There are no IPv4 options in the encapsulating header.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
5（封装标头中没有IPv4选项。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Type of Service:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
服务类别：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
0 unless otherwise specified. (See [RFC2983] and [RFC3168] Section 9.1 for issues relating to the Type-of-Service byte and tunneling.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
0，除非另有规定。（有关服务字节类型和隧道的问题，请参见[RFC2983]和[RFC3168]第9.1节。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Total Length:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
总长度：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Payload length from IPv6 header plus length of IPv6 and IPv4 headers (i.e., IPv6 payload length plus a constant 60 bytes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
IPv6头的有效负载长度加上IPv6和IPv4头的长度（即IPv6有效负载长度加上恒定的60字节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Identification:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
识别：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Generated uniquely as for any IPv4 packet transmitted by the system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
为系统传输的任何IPv4数据包唯一生成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Flags:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旗帜：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Set the Don&#39;t Fragment (DF) flag as specified in Section 3.2. Set the More Fragments (MF) bit as necessary if fragmenting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
按照第3.2节的规定设置不分段（DF）标志。如果需要碎片，请根据需要设置更多碎片（MF）位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Fragment Offset:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
碎片偏移量：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Set as necessary if fragmenting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
如有必要，设置为碎片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Time to Live:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
生存时间：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Set in an implementation-specific manner, as described in Section 3.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
按照第3.3节所述，以特定于实施的方式进行设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Protocol:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
协议：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
41 (Assigned payload type number for IPv6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
41（为IPv6分配的有效负载类型号）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Header Checksum:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
标题校验和：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Calculate the checksum of the IPv4 header [RFC791].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
计算IPv4标头[RFC791]的校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Source Address:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
来源地址：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
An IPv4 address of the encapsulator: either configured by the administrator or an address of the outgoing interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
封装器的IPv4地址：由管理员配置或传出接口的地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Destination Address:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
目的地地址：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
IPv4 address of the tunnel endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
隧道终结点的IPv4地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When encapsulating the packets, the node must ensure that it will use the correct source address so that the packets are acceptable to the decapsulator as described in Section 3.6. Configuring the source address is appropriate particularly in cases in which automatic selection of source address may produce different results in a certain period of time. This is often the case with multiple addresses, and multiple interfaces, or when routes may change frequently. Therefore, it SHOULD be possible to administratively specify the source address of a tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
封装数据包时，节点必须确保其将使用正确的源地址，以便如第3.6节所述，解封装器可以接受数据包。配置源地址是适当的，特别是在自动选择源地址可能在某一时间段内产生不同结果的情况下。对于多个地址和多个接口，或者当路由可能频繁更改时，通常会出现这种情况。因此，应该可以通过管理方式指定隧道的源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Decapsulation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 脱封
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an IPv6/IPv4 host or a router receives an IPv4 datagram that is addressed to one of its own IPv4 addresses or a joined multicast group address, and the value of the protocol field is 41, the packet is potentially a tunnel packet and needs to be verified to belong to one of the configured tunnel interfaces (by checking source/destination addresses), reassembled (if fragmented at the IPv4 level), and have the IPv4 header removed and the resulting IPv6 datagram be submitted to the IPv6 layer code on the node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当IPv6/IPv4主机或路由器接收到寻址到其自己的IPv4地址或加入的多播组地址之一的IPv4数据报，并且协议字段的值为41时，该数据包可能是隧道数据包，需要验证是否属于配置的隧道接口之一（通过检查源/目标地址），重新组装（如果在IPv4级别分段），并移除IPv4标头，并将生成的IPv6数据报提交给节点上的IPv6层代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decapsulator MUST verify that the tunnel source address is correct before further processing packets, to mitigate the problems with address spoofing (see Section 4). This check also applies to packets that are delivered to transport protocols on the decapsulator. This is done by verifying that the source address is the IPv4 address of the encapsulator, as configured on the decapsulator. Packets for which the IPv4 source address does not match MUST be discarded and an ICMP message SHOULD NOT be generated;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在进一步处理数据包之前，解封装器必须验证隧道源地址是否正确，以缓解地址欺骗问题（参见第4节）。此检查也适用于发送到decapsulator上传输协议的数据包。这是通过验证源地址是否为封装器的IPv4地址来完成的，如decapsulator上配置的那样。必须丢弃IPv4源地址不匹配的数据包，并且不应生成ICMP消息；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
however, if the implementation normally sends an ICMP message when receiving an unknown protocol packet, such an error message MAY be sent (e.g., ICMPv4 Protocol 41 Unreachable).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，如果实现在接收未知协议分组时通常发送ICMP消息，则可以发送这样的错误消息（例如，ICMPv4协议41不可到达）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A side effect of this address verification is that the node will silently discard packets with a wrong source address and packets that were received by the node but not directly addressed to it (e.g., broadcast addresses).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此地址验证的一个副作用是，节点将悄悄地丢弃具有错误源地址的数据包以及由节点接收但未直接寻址的数据包（例如，广播地址）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Independent of any other forms of IPv4 ingress filtering the administrator of the node may have configured, the implementation MAY perform ingress filtering, i.e., check that the packet is arriving from the interface in the direction of the route toward the tunnel end-point, similar to a Strict Reverse Path Forwarding (RPF) check [RFC3704]. As this may cause problems on tunnels that are routed through multiple links, it is RECOMMENDED that this check, if done, is disabled by default. The packets caught by this check SHOULD be discarded; an ICMP message SHOULD NOT be generated by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
独立于节点管理员可能已配置的任何其他形式的IPv4入口过滤，该实现可执行入口过滤，即，检查分组是否在朝向隧道端点的路由方向上从接口到达，类似于严格的反向路径转发（RPF）检查[RFC3704]。由于这可能会导致通过多个链路路由的隧道出现问题，建议在默认情况下禁用此检查（如果完成）。应丢弃此检查捕获的数据包；默认情况下不应生成ICMP消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decapsulator MUST be capable of having, on the tunnel interfaces, an IPv6 MRU of at least the maximum of 1500 bytes and the largest (IPv6) interface MTU on the decapsulator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解封装器必须能够在隧道接口上具有至少最大1500字节的IPv6 MRU和解封装器上最大（IPv6）接口MTU。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decapsulator MUST be capable of reassembling an IPv4 packet that is (after the reassembly) the maximum of 1500 bytes and the largest (IPv4) interface MTU on the decapsulator. The 1500-byte number is a result of encapsulators that use the static MTU scheme in Section 3.2.1, while encapsulators that use the dynamic scheme in Section 3.2.2 can cause up to the largest interface MTU on the decapsulator to be received. (Note that it is strictly the interface MTU on the last IPv4 router *before* the decapsulator that matters, but for most links the MTU is the same between all neighbors.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解封装器必须能够重新组装IPv4数据包（重新组装后），该数据包的最大长度为1500字节，并且是解封装器上最大的（IPv4）接口MTU。1500字节数是第3.2.1节中使用静态MTU方案的封装器的结果，而第3.2.2节中使用动态方案的封装器可导致接收decapsulator上最大的接口MTU。（请注意，重要的是解封装器之前*最后一个IPv4路由器*上的接口MTU，但对于大多数链路，所有邻居之间的MTU是相同的。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This reassembly limit allows dynamic tunnel MTU determination by the encapsulator to take advantage of larger IPv4 path MTUs. An implementation MAY have a configuration knob that can be used to set a larger value of the tunnel reassembly buffers than the above number, but it MUST NOT be set below the above number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此重新组装限制允许封装器通过动态隧道MTU确定，以利用较大的IPv4路径MTU。一个实现可能有一个配置旋钮，可用于设置比上述数字更大的通道重新组装缓冲器值，但不得设置在上述数字以下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decapsulation is shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
脱封过程如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +-------------+
            |    IPv4     |
            |   Header    |
            +-------------+                 +-------------+
            |    IPv6     |                 |    IPv6     |
            |   Header    |                 |   Header    |
            +-------------+                 +-------------+
            |  Transport  |                 |  Transport  |
            |   Layer     |      ===&gt;       |   Layer     |
            |   Header    |                 |   Header    |
            +-------------+                 +-------------+
            |             |                 |             |
            ~    Data     ~                 ~    Data     ~
            |             |                 |             |
            +-------------+                 +-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +-------------+
            |    IPv4     |
            |   Header    |
            +-------------+                 +-------------+
            |    IPv6     |                 |    IPv6     |
            |   Header    |                 |   Header    |
            +-------------+                 +-------------+
            |  Transport  |                 |  Transport  |
            |   Layer     |      ===&gt;       |   Layer     |
            |   Header    |                 |   Header    |
            +-------------+                 +-------------+
            |             |                 |             |
            ~    Data     ~                 ~    Data     ~
            |             |                 |             |
            +-------------+                 +-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Decapsulating IPv6 from IPv4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
从IPv4解除IPv6的封装
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decapsulator performs IPv4 reassembly before decapsulating the IPv6 packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解封装器在解封装IPv6数据包之前执行IPv4重新组装。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When decapsulating the packet, the IPv6 header is not modified. (However, see [RFC2983] and [RFC3168] section 9.1 for issues relating to the Type of Service byte and tunneling.) If the packet is subsequently forwarded, its hop limit is decremented by one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解除对数据包的封装时，不会修改IPv6标头。（但是，有关服务字节类型和隧道的问题，请参见[RFC2983]和[RFC3168]第9.1节。）如果随后转发数据包，其跳数限制将减少1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encapsulating IPv4 header is discarded, and the resulting packet is checked for validity when submitted to the IPv6 layer. When reconstructing the IPv6 packet, the length MUST be determined from the IPv6 payload length since the IPv4 packet might be padded (thus have a length that is larger than the IPv6 packet plus the IPv4 header being removed).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将丢弃封装的IPv4报头，并在将结果数据包提交到IPv6层时检查其有效性。重建IPv6数据包时，必须根据IPv6有效负载长度确定长度，因为IPv4数据包可能会被填充（因此长度大于IPv6数据包加上要删除的IPv4报头）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the decapsulation, the node MUST silently discard a packet with an invalid IPv6 source address. The list of invalid source addresses SHOULD include at least:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解除封装后，节点必须以静默方式丢弃具有无效IPv6源地址的数据包。无效源地址列表应至少包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- all multicast addresses (FF00::/8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 所有多播地址（FF00:：/8）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- the loopback address (::1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 环回地址（：：1）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- all the IPv4-compatible IPv6 addresses [RFC3513] (::/96), excluding the unspecified address for Duplicate Address Detection (::/128)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 所有与IPv4兼容的IPv6地址[RFC3513]（：：/96），不包括用于重复地址检测的未指定地址（：：/128）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- all the IPv4-mapped IPv6 addresses (::ffff:0:0/96)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 所有IPv4映射的IPv6地址（：：ffff:0:0/96）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the node should be configured to perform ingress filtering [RFC2827][RFC3704] on the IPv6 source address, similar to on any of its interfaces, e.g.:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，节点应配置为在IPv6源地址上执行入口过滤[RFC2827][RFC3704]，类似于在其任何接口上，例如：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) if the tunnel is toward the Internet, the node should be configured to check that the site&#39;s IPv6 prefixes are not used as the source addresses, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) 如果隧道朝向Internet，则应将节点配置为检查站点的IPv6前缀是否未用作源地址，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) if the tunnel is toward an edge network, the node should be configured to check that the source address belongs to that edge network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) 如果隧道朝向边缘网络，则应将节点配置为检查源地址是否属于该边缘网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prefix lists in the former typically need to be manually configured; the latter could be verified automatically, e.g., by using a strict unicast RPF check, as long as an interface can be designated to be toward an edge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前者中的前缀列表通常需要手动配置；后者可以自动验证，例如，通过使用严格的单播RPF检查，只要接口可以指定为朝向边缘。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that the implementations provide a single knob to make it easier to for the administrators to enable strict ingress filtering toward edge networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
建议这些实现提供一个旋钮，以便于管理员对边缘网络进行严格的入口过滤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. Link-Local Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. 链接本地地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The configured tunnels are IPv6 interfaces (over the IPv4 &#34;link layer&#34;) and thus MUST have link-local addresses. The link-local addresses are used by, e.g., routing protocols operating over the tunnels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置的隧道是IPv6接口（通过IPv4“链路层”），因此必须具有链路本地地址。链路本地地址由例如在隧道上运行的路由协议使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The interface identifier [RFC3513] for such an interface may be based on the 32-bit IPv4 address of an underlying interface, or formed using some other means, as long as it is unique from the other tunnel endpoint with a reasonably high probability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这种接口的接口标识符[RFC3513]可以基于底层接口的32位IPv4地址，或者使用一些其他方法形成，只要它以合理的高概率与其他隧道端点唯一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that it may be desirable to form the link-local address in a fashion that minimizes the probability and the effect of having to renumber the link-local address in the event of a topology or hardware change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，可能希望以最小化在拓扑或硬件改变的情况下必须重新编号链路本地地址的概率和影响的方式形成链路本地地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an IPv4 address is used for forming the IPv6 link-local address, the interface identifier is the IPv4 address, prepended by zeros. Note that the &#34;Universal/Local&#34; bit is zero, indicating that the interface identifier is not globally unique. The link-local address is formed by appending the interface identifier to the prefix FE80::/64.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果IPv4地址用于形成IPv6链路本地地址，则接口标识符为IPv4地址，前缀为零。请注意，“通用/本地”位为零，表示接口标识符不是全局唯一的。链路本地地址通过将接口标识符附加到前缀FE80:：/64形成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the host has more than one IPv4 address in use on the physical interface concerned, a choice of one of these IPv4 addresses is made
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当主机在相关物理接口上使用多个IPv4地址时，会选择其中一个IPv4地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
by the administrator or the implementation when forming the link-local address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由管理员或实现时形成的链接本地地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      +-------+-------+-------+-------+-------+-------+------+------+
      |  FE      80      00      00      00      00      00     00  |
      +-------+-------+-------+-------+-------+-------+------+------+
      |  00      00      00      00   |        IPv4 Address         |
      +-------+-------+-------+-------+-------+-------+------+------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      +-------+-------+-------+-------+-------+-------+------+------+
      |  FE      80      00      00      00      00      00     00  |
      +-------+-------+-------+-------+-------+-------+------+------+
      |  00      00      00      00   |        IPv4 Address         |
      +-------+-------+-------+-------+-------+-------+------+------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. Neighbor Discovery over Tunnels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. 隧道上的邻居发现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Configured tunnel implementations MUST at least accept and respond to the probe packets used by Neighbor Unreachability Detection (NUD) [RFC2461]. The implementations SHOULD also send NUD probe packets to detect when the configured tunnel fails at which point the implementation can use an alternate path to reach the destination. Note that Neighbor Discovery allows that the sending of NUD probes be omitted for router-to-router links if the routing protocol tracks bidirectional reachability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置的隧道实现必须至少接受并响应邻居不可访问性检测（NUD）[RFC2461]使用的探测数据包。实现还应发送NUD探测数据包，以检测配置的隧道何时失败，在该点实现可以使用备用路径到达目的地。注意，如果路由协议跟踪双向可达性，则邻居发现允许省略路由器到路由器链路的NUD探测发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of Neighbor Discovery, the configured tunnels specified in this document are assumed to NOT have a link-layer address, even though the link-layer (IPv4) does have an address. This means that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出于邻居发现的目的，假定本文档中指定的已配置隧道没有链路层地址，即使链路层（IPv4）确实有地址。这意味着：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- the sender of Neighbor Discovery packets SHOULD NOT include Source Link Layer Address options or Target Link Layer Address options on the tunnel link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 邻居发现数据包的发送方不应在隧道链路上包含源链路层地址选项或目标链路层地址选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- the receiver MUST, while otherwise processing the Neighbor Discovery packet, silently ignore the content of any Source Link Layer Address options or Target Link Layer Address options received on the tunnel link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 在以其他方式处理邻居发现数据包时，接收器必须静默地忽略在隧道链路上接收到的任何源链路层地址选项或目标链路层地址选项的内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not using link-layer address options is consistent with how Neighbor Discovery is used on other point-to-point links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不使用链路层地址选项与在其他点到点链路上使用邻居发现的方式一致。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Threat Related to Source Address Spoofing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 与源地址欺骗相关的威胁
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specification above contains rules that apply tunnel source address verification in particular and ingress filtering [RFC2827][RFC3704] in general to packets before they are decapsulated. When IP-in-IP tunneling (independent of IP versions) is used, it is important that this not be used to bypass any ingress filtering in use for non-tunneled packets. Thus, the rules in this document are derived based on should ingress filtering be used for IPv4 and IPv6, the use of tunneling should not provide an easy way to circumvent the filtering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述规范包含的规则特别适用于隧道源地址验证，而一般而言，在数据包被解封之前，入口过滤[RFC2827][RFC3704]适用于数据包。当使用IP-in-IP隧道（独立于IP版本）时，重要的是不要将其用于绕过任何用于非隧道数据包的入口过滤。因此，本文档中的规则是基于IPv4和IPv6是否使用入口过滤而派生的，隧道的使用不应提供一种绕过过滤的简单方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, without specific ingress filtering checks in the decapsulator, it would be possible for an attacker to inject a packet with:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在这种情况下，如果decapsulator中没有特定的入口过滤检查，攻击者可能会向数据包注入以下内容：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Outer IPv4 source: real IPv4 address of attacker
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 外部IPv4源：攻击者的真实IPv4地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Outer IPv4 destination: IPv4 address of decapsulator
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 外部IPv4目标：解封装器的IPv4地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Inner IPv6 source: Alice, which is either the decapsulator or a node close to it
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 内部IPv6源：Alice，它是解封装器或其附近的节点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Inner IPv6 destination: Bob
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 内部IPv6目标：Bob
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even if all IPv4 routers between the attacker and the decapsulator implement IPv4 ingress filtering, and all IPv6 routers between the decapsulator and Bob implement IPv6 ingress filtering, the above spoofed packets will not be filtered out. As a result, Bob will receive a packet that looks like it was sent from Alice even though the sender was some unrelated node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
即使攻击者和解封装器之间的所有IPv4路由器执行IPv4入口过滤，并且解封装器和Bob之间的所有IPv6路由器执行IPv6入口过滤，也不会过滤出上述伪造数据包。因此，Bob将收到一个看起来像是从Alice发送的数据包，即使发送者是一些不相关的节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The solution to this is to have the decapsulator accept only encapsulated packets from the explicitly configured source address (i.e., the other end of the tunnel) as specified in Section 3.6. While this does not provide complete protection in the case ingress filtering has not been deployed, it does provide a significant increase in security. The issue and the remainder threats are discussed at more length in Security Considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解决方案是让解封装器仅接受第3.6节中规定的明确配置的源地址（即隧道的另一端）的封装数据包。虽然在未部署入口过滤的情况下，这并不能提供完整的保护，但它确实显著提高了安全性。该问题和其余威胁将在安全考虑中进行更详细的讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generic security considerations of using IPv6 are discussed in a separate document [V6SEC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用IPv6的一般安全注意事项在单独的文档[V6SEC]中讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation of tunneling needs to be aware that although a tunnel is a link (as defined in [RFC2460]), the threat model for a tunnel might be rather different than for other links, since the tunnel potentially includes all of the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
隧道的实现需要注意，尽管隧道是一条链路（如[RFC2460]中所定义），但隧道的威胁模型可能与其他链路的威胁模型大不相同，因为隧道可能包括所有互联网。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several mechanisms (e.g., Neighbor Discovery) depend on Hop Count being 255 and/or the addresses being link local for ensuring that a packet originated on-link, in a semi-trusted environment. Tunnels are more vulnerable to a breach of this assumption than physical links, as an attacker anywhere in the Internet can send an IPv6-in-IPv4 packet to the tunnel decapsulator, causing injection of an encapsulted IPv6 packet to the configured tunnel interface unless the decapsulation checks are able to discard packets injected in such a manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有几种机制（例如，邻居发现）依赖于跳数为255和/或地址为链路本地，以确保数据包在半可信环境中起源于链路。隧道比物理链路更容易违反此假设，因为Internet上任何位置的攻击者都可以向隧道解封装器发送IPv6-in-IPv4数据包，从而导致将封装的IPv6数据包注入配置的隧道接口，除非解封装检查能够丢弃以这种方式注入的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, this memo specifies that the decapsulators make these steps (as described in Section 3.6) to mitigate this threat:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，本备忘录规定，除封装器应采取以下步骤（如第3.6节所述）以缓解该威胁：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv4 source address of the packet MUST be the same as configured for the tunnel end-point;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 数据包的IPv4源地址必须与为隧道端点配置的相同；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Independent of any IPv4 ingress filtering the administrator may have configured, the implementation MAY perform IPv4 ingress filtering to check that the IPv4 packets are received from an expected interface (but as this may cause some problems, it may be disabled by default);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 独立于管理员可能配置的任何IPv4入口过滤，实现可以执行IPv4入口过滤，以检查是否从预期接口接收到IPv4数据包（但由于这可能会导致一些问题，默认情况下可能会禁用）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6 packets with several, obviously invalid IPv6 source addresses received from the tunnel MUST be discarded (see Section 3.6 for details); and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 必须丢弃从隧道接收到的带有多个明显无效IPv6源地址的IPv6数据包（详见第3.6节）；和
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- IPv6 ingress filtering should be performed (typically requiring configuration from the operator), to check that the tunneled IPv6 packets are received from an expected interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 应执行IPv6入口过滤（通常需要运营商进行配置），以检查隧道IPv6数据包是否从预期接口接收。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Especially the first verification is vital: to avoid this check, the attacker must be able to know the source of the tunnel (ranging from difficult to predictable) and be able to spoof it (easier).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尤其是第一次验证是至关重要的：为了避免这种检查，攻击者必须能够知道隧道的来源（从困难到可预测），并且能够欺骗它（更容易）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the remainder threats of tunnel source verification are considered to be significant, a tunneling scheme with authentication should be used instead, e.g., IPsec [RFC2401] (preferable) or Generic Routing Encapsulation with a pre-configured secret key [RFC2890]. As the configured tunnels are set up more or less manually, setting up the keying material is probably not a problem. However, setting up secure IPsec IPv6-in-IPv4 tunnels is described in another document [V64IPSEC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果隧道源验证的其余威胁被认为是重大的，则应使用具有身份验证的隧道方案，例如，IPsec[RFC2401]（优选）或具有预配置密钥的通用路由封装[RFC2890]。由于配置的隧道或多或少是手动设置的，因此设置键控材质可能不是问题。但是，在另一个文档[V64IPSEC]中描述了如何设置安全的IPsec IPv6-in-IPv4隧道。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the tunneling is done inside an administrative domain, proper ingress filtering at the edge of the domain can also eliminate the threat from outside of the domain. Therefore, shorter tunnels are preferable to longer ones, possibly spanning the whole Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果隧道是在管理域内完成的，则在域边缘进行适当的入口过滤也可以消除来自域外的威胁。因此，较短的隧道比较长的隧道更可取，可能跨越整个互联网。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, an implementation MUST treat interfaces to different links as separate, e.g., to ensure that Neighbor Discovery packets arriving on one link do not affect other links. This is especially important for tunnel links.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，实现必须将不同链路的接口视为单独的，例如，确保到达一个链路的邻居发现数据包不会影响其他链路。这对于隧道连接尤其重要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When dropping packets due to failing to match the allowed IPv4 source addresses for a tunnel the node should not &#34;acknowledge&#34; the existence of a tunnel, otherwise this could be used to probe the acceptable tunnel endpoint addresses. For that reason, the specification says that such packets MUST be discarded, and an ICMP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当由于无法匹配隧道允许的IPv4源地址而丢弃数据包时，节点不应“确认”隧道的存在，否则这可用于探测可接受的隧道端点地址。出于这个原因，该规范规定必须丢弃此类数据包，并且必须使用ICMP
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
error message SHOULD NOT be generated, unless the implementation normally sends ICMP destination unreachable messages for unknown protocols; in such a case, the same code MAY be sent. As should be obvious, not returning the same ICMP code if an error is returned for other protocols may hint that the IPv6 stack (or the protocol 41 tunneling processing) has been enabled -- the behaviour should be consistent on how the implementation otherwise behaves to be transparent to probing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不应生成错误消息，除非实现通常为未知协议发送ICMP目的地不可访问消息；在这种情况下，可以发送相同的代码。显而易见，如果为其他协议返回错误，则不返回相同的ICMP代码可能暗示IPv6堆栈（或协议41隧道处理）已启用——该行为应与实现的其他行为保持一致，以便对探测透明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We would like to thank the members of the IPv6 working group, the Next Generation Transition (ngtrans) working group, and the v6ops working group for their many contributions and extensive review of this document. Special thanks are due to (in alphabetical order) Jim Bound, Ross Callon, Tim Chown, Alex Conta, Bob Hinden, Bill Manning, John Moy, Mohan Parthasarathy, Chirayu Patel, Pekka Savola, and Fred Templin for many helpful suggestions. Pekka Savola helped in editing the final revisions of the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们要感谢IPv6工作组、下一代过渡（ngtrans）工作组和v6ops工作组的成员，感谢他们对本文件的大量贡献和广泛审查。特别感谢（按字母顺序排列）吉姆·邦德、罗斯·卡隆、蒂姆·乔恩、亚历克斯·康塔、鲍勃·欣登、比尔·曼宁、约翰·莫伊、莫汉·帕塔萨拉西、奇拉尤·帕特尔、佩卡·萨沃拉和弗雷德·坦普林提出的许多有益建议。Pekka Savola帮助编辑了规范的最终修订版。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC791] Postel, J., &#34;Internet Protocol&#34;, STD 5, RFC 791, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC791]Postel，J.，“互联网协议”，标准5，RFC7911981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191] Mogul, J. and S. Deering, &#34;Path MTU discovery&#34;, RFC 1191, November 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191]Mogul，J.和S.Deering，“MTU发现路径”，RFC1191，1990年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1981] McCann, J., Deering, S., and J. Mogul, &#34;Path MTU Discovery for IP version 6&#34;, RFC 1981, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1981]McCann，J.，Deering，S.，和J.Mogul，“IP版本6的路径MTU发现”，RFC 1981，1996年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460]Deering，S.和R.Hinden，“互联网协议，第6版（IPv6）规范”，RFC 2460，1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2463] Conta, A. and S. Deering, &#34;Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification&#34;, RFC 2463, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2463]Conta，A.和S.Deering，“互联网协议版本6（IPv6）规范的互联网控制消息协议（ICMPv6）”，RFC2463，1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [ASSIGNED] IANA, &#34;Assigned numbers online database&#34;,
              http://www.iana.org/numbers.html
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [ASSIGNED] IANA, &#34;Assigned numbers online database&#34;,
              http://www.iana.org/numbers.html
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSOPV6] Durand, A., Ihren, J., and Savola P., &#34;Operational Considerations and Issues with IPv6 DNS&#34;, Work in Progress, October 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSOPV6]Durand，A.，Ihren，J.，和Savola P.，“IPv6 DNS的操作注意事项和问题”，正在进行的工作，2004年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KM97] Kent, C., and J. Mogul, &#34;Fragmentation Considered Harmful&#34;. In Proc. SIGCOMM &#39;87 Workshop on Frontiers in Computer Communications Technology. August 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[KM97]Kent，C.和J.Mogul，“碎片化被认为是有害的”。在过程中。SIGCOMM&#39;87计算机通信技术前沿研讨会。1987年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V6SEC] Savola, P., &#34;IPv6 Transition/Co-existence Security Considerations&#34;, Work in Progress, October 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V6SEC]Savola，P.，“IPv6过渡/共存安全考虑”，正在进行的工作，2004年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V64IPSEC] Graveman, R., et al., &#34;Using IPsec to Secure IPv6-over-IPv4 Tunnels&#34;, Work in Progress, December 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[V64IPSEC]Graveman，R.等人，“使用IPsec保护IPv4隧道上的IPv6”，正在进行的工作，2004年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1435] Knowles, S., &#34;IESG Advice from Experience with Path MTU Discovery&#34;, RFC 1435, March 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1435]Knowles，S.，“来自Path MTU发现经验的IESG建议”，RFC 1435，1993年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1812] Baker, F., &#34;Requirements for IP Version 4 Routers&#34;, RFC 1812, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1812]Baker，F.，“IP版本4路由器的要求”，RFC1812，1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2401] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2401]Kent，S.和R.Atkinson，“互联网协议的安全架构”，RFC 2401，1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2461] Narten, T., Nordmark, E., and W. Simpson, &#34;Neighbor Discovery for IP Version 6 (IPv6)&#34;, RFC 2461, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2461]Narten，T.，Nordmark，E.，和W.Simpson，“IP版本6（IPv6）的邻居发现”，RFC2461，1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2462] Thomson, S. and T. Narten, &#34;IPv6 Stateless Address Autoconfiguration&#34;, RFC 2462, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2462]Thomson，S.和T.Narten，“IPv6无状态地址自动配置”，RFC2462，1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2827] Ferguson, P. and D. Senie, &#34;Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing&#34;, BCP 38, RFC 2827, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2827]Ferguson，P.和D.Senie，“网络入口过滤：击败利用IP源地址欺骗的拒绝服务攻击”，BCP 38，RFC 2827，2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2890] Dommety, G., &#34;Key and Sequence Number Extensions to GRE&#34;, RFC 2890, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2890]Dommety，G.“GRE的密钥和序列号扩展”，RFC 28902000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2923] Lahey, K., &#34;TCP Problems with Path MTU Discovery&#34;, RFC 2923, September 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2923]Lahey，K.，“路径MTU发现的TCP问题”，RFC 29232000年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2983] Black, D., &#34;Differentiated Services and Tunnels&#34;, RFC 2983, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2983]Black，D.，“差异化服务和隧道”，RFC 29832000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3056] Carpenter, B. and K. Moore, &#34;Connection of IPv6 Domains via IPv4 Clouds&#34;, RFC 3056, February 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3056]Carpenter，B.和K.Moore，“通过IPv4云连接IPv6域”，RFC 3056，2001年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168]Ramakrishnan，K.，Floyd，S.，和D.Black，“向IP添加显式拥塞通知（ECN）”，RFC 3168，2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232] Reynolds, J., &#34;Assigned Numbers: RFC 1700 is Replaced by an On-line Database&#34;, RFC 3232, January 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3232]Reynolds，J.，“分配号码：RFC 1700被在线数据库取代”，RFC 3232，2002年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3484] Draves, R., &#34;Default Address Selection for Internet Protocol version 6 (IPv6)&#34;, RFC 3484, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3484]Draves，R.，“互联网协议版本6（IPv6）的默认地址选择”，RFC 3484，2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 3493, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493]Gilligan，R.，Thomson，S.，Bound，J.，McCann，J.，和W.Stevens，“IPv6的基本套接字接口扩展”，RFC 3493，2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3513] Hinden, R. and S. Deering, &#34;Internet Protocol Version 6 (IPv6) Addressing Architecture&#34;, RFC 3513, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3513]Hinden，R.和S.Deering，“互联网协议版本6（IPv6）寻址体系结构”，RFC 3513，2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3596] Thomson, S., Huitema, C., Ksinant, V., and M. Souissi, &#34;DNS Extensions to Support IP Version 6&#34;, RFC 3596, October 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3596]Thomson，S.，Huitema，C.，Ksinant，V.，和M.Souissi，“支持IP版本6的DNS扩展”，RFC 3596，2003年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3704] Baker, F. and P. Savola, &#34;Ingress Filtering for Multihomed Networks&#34;, BCP 84, RFC 3704, March 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3704]Baker，F.和P.Savola，“多宿网络的入口过滤”，BCP 84，RFC 37042004年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4087] Thaler, D., &#34;IP Tunnel MIB&#34;, RFC 4087, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4087]Thaler，D.，“IP隧道MIB”，RFC 4087，2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Changes from RFC 2893
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. RFC 2893的变更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The motivation for the bulk of these changes are to simplify the document to only contain the mechanisms of wide-spread use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些更改的主要目的是简化文档，使其仅包含广泛使用的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC 2893 contains a mechanism called automatic tunneling. But a much more general mechanism is specified in RFC 3056 [RFC3056] which gives each node with a (global) IPv4 address a /48 IPv6 prefix i.e., enough for a whole site.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC2893包含一种称为自动隧道的机制。但RFC 3056[RFC3056]中规定了一种更为通用的机制，该机制为每个节点提供一个（全局）IPv4地址和一个/48 IPv6前缀，即足以容纳整个站点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following changes have been performed since RFC 2893:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
自RFC 2893以来，已执行了以下更改：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed references to A6 and retained AAAA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除对A6的引用并保留AAAA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed automatic tunneling and use of IPv4-compatible addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除了自动隧道和IPv4兼容地址的使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed default Configured Tunnel using IPv4 &#34;Anycast Address&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 已删除使用IPv4“选播地址”的默认配置隧道
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed Source Address Selection section since this is now covered by another document ([RFC3484]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除了“源地址选择”部分，因为另一个文档（[RFC3484]）已涵盖该部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed brief mention of 6over4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除了6以上4的简短提及。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Split into normative and non-normative references and other reference cleanup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 分为规范性引用和非规范性引用以及其他引用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Dropped &#34;or equal&#34; in if (IPv4 path MTU - 20) is less than or equal to 1280.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 如果（IPv4路径MTU-20）小于或等于1280，则丢弃的“或等于”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Dropped this: However, IPv6 may be used in some environments where interoperability with IPv4 is not required. IPv6 nodes that are designed to be used in such environments need not use or even implement these mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除此选项：但是，在某些不需要与IPv4互操作性的环境中，可能会使用IPv6。设计用于此类环境的IPv6节点不需要使用甚至实现这些机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Described Static MTU and Dynamic MTU cases separately; clarified that the dynamic path MTU mechanism is OPTIONAL but if it is implemented it should follow the rules in section 3.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 分别描述了静态MTU和动态MTU情况；阐明动态路径MTU机制是可选的，但如果实施，则应遵循第3.2.2节中的规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Specified Static MTU to default to a MTU of 1280 to 1480 bytes, and that this may be configurable. Discussed the issues with using Static MTU at more length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 指定的静态MTU默认为1280到1480字节的MTU，并且这可能是可配置的。更详细地讨论了使用静态MTU的问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Specified minimal rules for IPv4 reassembly and IPv6 MRU to enhance interoperability and to minimize blacholes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 为IPv4重组和IPv6 MRU指定了最低限度的规则，以增强互操作性并最大限度地减少Blachole。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Restated the &#34;currently underway&#34; language about Type-of-Service, and loosely point at [RFC2983] and [RFC3168].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 重申了关于服务类型的“当前正在进行的”语言，并松散地指向[RFC2983]和[RFC3168]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Fixed reference to Assigned Numbers to be to online version (with proper pointer to &#34;Assigned Numbers is obsolete&#34; RFC).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 修正了在线版本中对指定号码的引用（正确指向“指定号码已过时”RFC）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clarified text about ingress filtering e.g., that it applies to packet delivered to transport protocols on the decapsulator as well as packets being forwarded by the decapsulator, and how the decapsulator&#39;s checks help when IPv4 and IPv6 ingress filtering is in place.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 澄清了关于入口过滤的文本，例如，它适用于发送到解封装器上的传输协议的数据包以及由解封装器转发的数据包，以及在IPv4和IPv6入口过滤到位时解封装器的检查如何帮助。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed unidirectional tunneling; assume all tunnels are bidirectional, between endpoint addresses (not nodes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 移除单向隧道；假设所有隧道都是双向的，在端点地址（不是节点）之间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed the guidelines for advertising addresses in DNS as slightly out of scope, referring to another document for the details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除了DNS中广告地址的指导原则，因为它稍微超出了范围，请参阅另一个文档了解详细信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed the SHOULD requirement that the link-local addresses should be formed based on IPv4 addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除了应基于IPv4地址形成链路本地地址的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added a SHOULD for implementing a knob to be able to set the source address of the tunnel, and add discussion why this is useful.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 添加了一个应该用于实现一个旋钮，以便能够设置隧道的源地址，并添加了为什么这是有用的讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added stronger wording for source address checks: both IPv4 and IPv6 source addresses MUST be checked, and RPF-like ingress filtering is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 为源地址检查添加了更强的措辞：必须检查IPv4和IPv6源地址，并且类似RPF的入口过滤是可选的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Rewrote security considerations to be more precise about the threats of tunneling.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 重写安全注意事项，以便更准确地了解隧道的威胁。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added a note about considering using TTL=255 when encapsulating.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 添加了关于在封装时考虑使用TTL=255的说明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added more discussion in Section 3.2 why using an &#34;infinite&#34; IPv6 MTU leads to likely interoperability problems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 在第3.2节中添加了更多讨论，为什么使用“无限”IPv6 MTU会导致可能的互操作性问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Added an explicit requirement that if both MTU determination methods are used, choosing one should be possible on a per-tunnel basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 增加了一项明确要求，即如果同时使用两种MTU测定方法，则应在每个隧道的基础上选择一种。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Clarified that ICMPv4 error handling is only applicable to dynamic MTU determination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 阐明ICMPv4错误处理仅适用于动态MTU确定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Removed/clarified DNS record filtering; an API is a SHOULD and if it does not exist, MUST NOT filter anything. Decree ordering out of scope, but refer to RFC3484.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 删除/澄清DNS记录过滤；API是应该的，如果它不存在，就不能过滤任何内容。订单超出范围，但请参考RFC3484。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Add a note that the destination IPv4 address could also be a multicast address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 请注意，目标IPv4地址也可以是多播地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Make it RECOMMENDED to provide a toggle to perform strict ingress filtering on an interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 建议提供一个切换，以便在接口上执行严格的入口过滤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Generalize the text on the data in ICMPv4 messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 概括ICMPv4消息中数据上的文本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Made a lot of miscellaneous editorial cleanups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 进行了大量的杂项编辑清理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Erik Nordmark Sun Microsystems 17 Network Circle Menlo Park, CA 94025 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Erik Nordmark Sun Microsystems 17 Network Circle Menlo Park，加利福尼亚州94025
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 786 2921
   EMail: erik.nordmark@sun.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 786 2921
   EMail: erik.nordmark@sun.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert E. Gilligan Intransa, Inc. 2870 Zanker Rd., Suite 100 San Jose, CA 95134 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Robert E.Gilligan Intransa，Inc.美国加利福尼亚州圣何塞市赞克路2870号100室，邮编95134
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone : +1 408 678 8600
   Fax :   +1 408 678 8800
   EMail:  bob.gilligan@acm.org
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone : +1 408 678 8600
   Fax :   +1 408 678 8800
   EMail:  bob.gilligan@acm.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2005年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其包含的信息是按“原样”提供的，贡献者、他/她所代表或赞助的组织（如有）、互联网协会和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
确认
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC编辑功能的资金目前由互联网协会提供。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
