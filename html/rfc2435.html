<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 2435:  RTP Payload Format for JPEG-compressed Video  中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2435</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2435">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2435:  RTP Payload Format for JPEG-compressed Video  中文翻译</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc2435">
              https://datatracker.ietf.org/doc/html/rfc2435
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 2435</strong></span><br>
          <span class="updated_by">翻译编辑 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                            L. Berc
Request for Comments: 2435                 Digital Equipment Corporation
Obsoletes: 2035                                                W. Fenner
Category: Standards Track                                     Xerox PARC
                                                            R. Frederick
                                                              Xerox PARC
                                                              S. McCanne
                                            Lawrence Berkeley Laboratory
                                                              P. Stewart
                                                              Xerox PARC
                                                            October 1998
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                            L. Berc
Request for Comments: 2435                 Digital Equipment Corporation
Obsoletes: 2035                                                W. Fenner
Category: Standards Track                                     Xerox PARC
                                                            R. Frederick
                                                              Xerox PARC
                                                              S. McCanne
                                            Lawrence Berkeley Laboratory
                                                              P. Stewart
                                                              Xerox PARC
                                                            October 1998
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
RTP Payload Format for JPEG-compressed Video
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
用于JPEG压缩视频的RTP有效负载格式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本备忘录的状况
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1998年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo describes the RTP payload format for JPEG video streams. The packet format is optimized for real-time video streams where codec parameters change rarely from frame to frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录描述了JPEG视频流的RTP有效负载格式。数据包格式针对实时视频流进行了优化，在实时视频流中，编解码器参数很少随帧变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Audio-Video Transport working group within the Internet Engineering Task Force. Comments are solicited and should be addressed to the working group&#39;s mailing list at rem-conf@es.net and/or the author(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件是互联网工程任务组音频视频传输工作组的产品。征求意见，并应发送至rem的工作组邮件列表-conf@es.net和/或作者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Changes from RFC 2035
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
RFC 2035的变更
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of this memo is identical to RFC 2035. The changes made to the protocol are summarized in Appendix D.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录大部分内容与RFC 2035相同。附录D总结了对方案所做的更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Key Words
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关键词
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照RFC 2119[9]中所述进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Joint Photographic Experts Group (JPEG) standard [1,2,3] defines a family of compression algorithms for continuous-tone, still images. This still image compression standard can be applied to video by compressing each frame of video as an independent still image and transmitting them in series. Video coded in this fashion is often called Motion-JPEG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
联合摄影专家组（JPEG）标准[1,2,3]定义了一系列用于连续色调静态图像的压缩算法。该静止图像压缩标准可通过将视频的每一帧压缩为独立的静止图像并将其串联传输而应用于视频。以这种方式编码的视频通常称为运动JPEG。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We first give an overview of JPEG and then describe the specific subset of JPEG that is supported in RTP and the mechanism by which JPEG frames are carried as RTP payloads.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们首先给出了JPEG的概述，然后描述了RTP中支持的JPEG的特定子集，以及JPEG帧作为RTP有效载荷承载的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JPEG standard defines four modes of operation: the sequential DCT mode, the progressive DCT mode, the lossless mode, and the hierarchical mode. Depending on the mode, the image is represented in one or more passes. Each pass (called a frame in the JPEG standard) is further broken down into one or more scans. Within each scan, there are one to four components, which represent the three components of a color signal (e.g., &#34;red, green, and blue&#34;, or a luminance signal and two chrominance signals). These components can be encoded as separate scans or interleaved into a single scan.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEG标准定义了四种操作模式：顺序DCT模式、渐进DCT模式、无损模式和分层模式。根据模式，图像以一个或多个过程表示。每个过程（在JPEG标准中称为帧）进一步细分为一个或多个扫描。在每次扫描中，有一到四个分量，它们代表颜色信号的三个分量（例如，“红色、绿色和蓝色”，或亮度信号和两个色度信号）。这些组件可以编码为单独的扫描，也可以交织成单个扫描。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each frame and scan is preceded with a header containing optional definitions for compression parameters like quantization tables and Huffman coding tables. The headers and optional parameters are identified with &#34;markers&#34; and comprise a marker segment; each scan appears as an entropy-coded bit stream within two marker segments. Markers are aligned to byte boundaries and (in general) cannot appear in the entropy-coded segment, allowing scan boundaries to be determined without parsing the bit stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个帧和扫描之前都有一个标头，其中包含压缩参数（如量化表和哈夫曼编码表）的可选定义。标题和可选参数由“标记”标识，并包括标记段；每个扫描在两个标记段内显示为熵编码比特流。标记与字节边界对齐，并且（通常）不能出现在熵编码段中，允许在不解析位流的情况下确定扫描边界。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compressed data is represented in one of three formats: the interchange format, the abbreviated format, or the table-specification format. The interchange format contains definitions for all the tables used by the entropy-coded segments, while the abbreviated format might omit some assuming they were defined out-of-band or by a &#34;previous&#34; image.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩数据以三种格式之一表示：交换格式、缩写格式或表规范格式。交换格式包含熵编码段使用的所有表的定义，而缩写格式可能会忽略一些表，假设它们是在带外或由“以前的”图像定义的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JPEG standard does not define the meaning or format of the components that comprise the image. Attributes like the color space and pixel aspect ratio must be specified out-of-band with respect to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEG标准没有定义组成图像的组件的含义或格式。颜色空间和像素纵横比等属性必须在带外指定
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the JPEG bit stream. The JPEG File Interchange Format (JFIF) [4] is a de-facto standard that provides this extra information using an application marker segment (APP0). Note that a JFIF file is simply a JPEG interchange format image along with the APP0 segment. In the case of video, additional parameters must be defined out-of-band (e.g., frame rate, interlaced vs. non-interlaced, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEG位流。JPEG文件交换格式（JFIF）[4]是一个事实上的标准，它使用应用程序标记段（APP0）提供了这些额外信息。请注意，JFIF文件只是一个JPEG交换格式的图像以及APP0段。对于视频，必须在带外定义附加参数（例如，帧速率、隔行与非隔行等）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the JPEG standard provides a rich set of algorithms for flexible compression, cost-effective hardware implementations of the full standard have not appeared. Instead, most hardware JPEG video codecs implement only a subset of the sequential DCT mode of operation. Typically, marker segments are interpreted in software (which &#34;re-programs&#34; the hardware) and the hardware is presented with a single, interleaved entropy-coded scan represented in the YUV color space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然JPEG标准为灵活的压缩提供了一套丰富的算法，但尚未出现完整标准的经济高效的硬件实现。相反，大多数硬件JPEG视频编解码器仅实现顺序DCT操作模式的子集。通常，标记段在软件中解释（软件“重新编程”硬件），硬件以YUV颜色空间中表示的单个交错熵编码扫描呈现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scan contains an ordered sequence of Minimum Coded Units, or MCUs, which are the smallest group of image data coded in a JPEG bit stream. Each MCU defines the image data for a small rectangular block of the output image.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
扫描包含最小编码单元（MCU）的有序序列，MCU是JPEG比特流中编码的最小图像数据组。每个MCU为输出图像的小矩形块定义图像数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restart markers in the JPEG data denote a point where the decoder should reset its state. As defined by JPEG, restart markers are the only type of marker that may appear embedded in the entropy-coded segment, and they may only appear on an MCU boundary. A &#34;restart interval&#34; is defined to be a block of data containing a restart marker followed by some fixed number of MCUs. An exception is made for the first restart interval in each frame, which omits the initial restart marker and just begins with the MCU data. When these markers are used, each frame is composed of some fixed number of back-to-back restart intervals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JPEG数据中的重新启动标记表示解码器应重置其状态的点。按照JPEG的定义，重新启动标记是唯一可能嵌入熵编码段的标记类型，它们可能只出现在MCU边界上。“重启间隔”定义为包含重启标记的数据块，后跟一些固定数量的MCU。每个帧中的第一次重新启动间隔都有一个例外，它忽略了初始重新启动标记，仅从MCU数据开始。使用这些标记时，每个帧由固定数量的背对背重新启动间隔组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. JPEG Over RTP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. RTP上的JPEG
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To maximize interoperability among hardware-based codecs, we assume the sequential DCT operating mode [1,Annex F] and restrict the set of predefined RTP/JPEG &#34;type codes&#34; (defined below) to single-scan, interleaved images. While this is more restrictive than even baseline JPEG, many hardware implementation fall short of the baseline specification (e.g., most hardware cannot decode non-interleaved scans).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了最大限度地提高基于硬件的编解码器之间的互操作性，我们采用顺序DCT操作模式[1，附录F]，并将预定义的RTP/JPEG“类型码”（定义见下文）限制为单扫描、交错图像。虽然这比基线JPEG更具限制性，但许多硬件实现没有达到基线规范（例如，大多数硬件无法解码非交错扫描）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, most of the table-specification data rarely changes from frame to frame within a single video stream. Therefore RTP/JPEG data is represented in abbreviated format, with all of the tables omitted from the bit stream where possible. Each frame begins immediately with the (single) entropy-coded scan. The information that would otherwise be in both the frame and scan headers is represented
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实际上，大多数表规范数据很少在单个视频流中随帧变化。因此，RTP/JPEG数据以缩写格式表示，尽可能从比特流中省略所有表。每一帧都以（单个）熵编码扫描立即开始。此时将显示帧和扫描头中的信息
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
entirely within the RTP/JPEG header (defined below) that lies between the RTP header and the JPEG payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全位于RTP报头和JPEG有效负载之间的RTP/JPEG报头（定义如下）内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While parameters like Huffman tables and color space are likely to remain fixed for the lifetime of the video stream, other parameters should be allowed to vary, notably the quantization tables and image size (e.g., to implement rate-adaptive transmission or allow a user to adjust the &#34;quality level&#34; or resolution manually). Thus explicit fields in the RTP/JPEG header are allocated to represent this information. Since only a small set of quantization tables are typically used, we encode the entire set of quantization tables in a small integer field. Customized quantization tables are accommodated by using a special range of values in this field, and then placing the table before the beginning of the JPEG payload. The image width and height are encoded explicitly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然诸如哈夫曼表和颜色空间之类的参数可能在视频流的生存期内保持固定，但应允许其他参数变化，尤其是量化表和图像大小（例如，实现速率自适应传输或允许用户手动调整“质量水平”或分辨率）。因此，RTP/JPEG报头中的显式字段被分配来表示该信息。由于通常只使用一小组量化表，因此我们将整个量化表组编码在一个小整数字段中。通过使用此字段中的特定范围的值，然后将该表放在JPEG有效载荷的开始之前，可以容纳定制的量化表。图像的宽度和高度是显式编码的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because JPEG frames are typically larger than the underlying network&#39;s maximum packet size, frames must often be fragmented into several packets. One approach is to allow the network layer below RTP (e.g., IP) to perform the fragmentation. However, this precludes rate-controlling the resulting packet stream or partial delivery in the presence of loss, and frames may be larger than the maximum network layer reassembly length (see [10] for more information). To avoid these limitations, RTP/JPEG defines a simple fragmentation and reassembly scheme at the RTP level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于JPEG帧通常大于底层网络的最大数据包大小，因此帧通常必须分割成多个数据包。一种方法是允许RTP（例如，IP）下的网络层执行分段。然而，这排除了在存在丢失的情况下控制产生的分组流或部分传送的速率，并且帧可能大于最大网络层重新组装长度（更多信息，请参见[10]）。为了避免这些限制，RTP/JPEG在RTP级别定义了一个简单的碎片和重组方案。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RTP/JPEG Packet Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. RTP/JPEG数据包格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTP timestamp is in units of 90000Hz. The same timestamp MUST appear in each fragment of a given frame. The RTP marker bit MUST be set in the last packet of a frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP时间戳的单位为90000Hz。给定帧的每个片段中必须出现相同的时间戳。RTP标记位必须在帧的最后一个数据包中设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. JPEG header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. JPEG头文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each packet contains a special JPEG header which immediately follows the RTP header. The first 8 bytes of this header, called the &#34;main JPEG header&#34;, are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个数据包都包含一个特殊的JPEG报头，紧跟在RTP报头之后。此标头的前8个字节称为“主JPEG标头”，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Type-specific |              Fragment Offset                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Type     |       Q       |     Width     |     Height    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Type-specific |              Fragment Offset                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Type     |       Q       |     Width     |     Height    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All fields in this header except for the Fragment Offset field MUST remain the same in all packets that correspond to the same JPEG frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在与同一JPEG帧相对应的所有数据包中，除片段偏移字段外，此标头中的所有字段必须保持相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Restart Marker header and/or Quantization Table header may follow this header, depending on the values of the Type and Q fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据类型和Q字段的值，重启标记报头和/或量化表报头可以跟随该报头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Type-specific: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. 特定类型：8位
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interpretation depends on the value of the type field. If no interpretation is specified, this field MUST be zeroed on transmission and ignored on reception.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解释取决于类型字段的值。如果未指定解释，则此字段在传输时必须归零，在接收时必须忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. Fragment Offset: 24 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. 片段偏移量：24位
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Fragment Offset is the offset in bytes of the current packet in the JPEG frame data. This value is encoded in network byte order (most significant byte first). The Fragment Offset plus the length of the payload data in the packet MUST NOT exceed 2^24 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
片段偏移量是JPEG帧数据中当前数据包的字节偏移量。该值按网络字节顺序编码（最高有效字节优先）。片段偏移量加上数据包中有效负载数据的长度不得超过2^24字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. Type: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. 类型：8位
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type field specifies the information that would otherwise be present in a JPEG abbreviated table-specification as well as the additional JFIF-style parameters not defined by JPEG. Types 0-63 are reserved as fixed, well-known mappings to be defined by this document and future revisions of this document. Types 64-127 are the same as types 0-63, except that restart markers are present in the JPEG data and a Restart Marker header appears immediately following the main JPEG header. Types 128-255 are free to be dynamically defined by a session setup protocol (which is beyond the scope of this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型字段指定JPEG缩略表规范中的信息以及JPEG未定义的附加JFIF样式参数。类型0-63保留为本文档和本文档未来版本定义的固定的、众所周知的映射。类型64-127与类型0-63相同，不同之处在于JPEG数据中存在重新启动标记，并且在主JPEG标头之后立即显示重新启动标记标头。128-255类型可以由会话设置协议（不在本文档范围内）动态定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. Q: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. Q:8位
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Q field defines the quantization tables for this frame. Q values 0-127 indicate the quantization tables are computed using an algorithm determined by the Type field (see below). Q values 128-255 indicate that a Quantization Table header appears after the main JPEG header (and the Restart Marker header, if present) in the first packet of the frame (fragment offset 0). This header can be used to explicitly specify the quantization tables in-band.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Q字段定义该帧的量化表。Q值0-127表示使用由类型字段确定的算法计算量化表（见下文）。Q值128-255指示量化表报头出现在帧的第一个分组（片段偏移量0）中的主JPEG报头（以及重新启动标记报头，如果存在）之后。此标头可用于显式指定频带内的量化表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. Width: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. 宽度：8位
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This field encodes the width of the image in 8-pixel multiples (e.g., a width of 40 denotes an image 320 pixels wide). The maximum width is 2040 pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该字段以8像素倍数对图像的宽度进行编码（例如，宽度40表示图像320像素宽）。最大宽度为2040像素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. Height: 8 bits
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. 高度：8位
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This field encodes the height of the image in 8-pixel multiples (e.g., a height of 30 denotes an image 240 pixels tall). When encoding interlaced video, this is the height of a video field, since fields are individually JPEG encoded. The maximum height is 2040 pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该字段以8像素倍数对图像的高度进行编码（例如，高度30表示图像240像素高）。对隔行扫描视频进行编码时，这是视频场的高度，因为场是单独进行JPEG编码的。最大高度为2040像素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. Restart Marker header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. 重新启动标记头
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header MUST be present immediately after the main JPEG header when using types 64-127. It provides the additional information required to properly decode a data stream containing restart markers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用64-127类型时，此标头必须紧跟在主JPEG标头之后。它提供了正确解码包含重启标记的数据流所需的附加信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Restart Interval        |F|L|       Restart Count       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       Restart Interval        |F|L|       Restart Count       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Restart Interval field specifies the number of MCUs that appear between restart markers. It is identical to the 16 bit value that would appear in the DRI marker segment of a JFIF header. This value MUST NOT be zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新启动间隔字段指定重新启动标记之间出现的MCU数。它与JFIF头的DRI标记段中出现的16位值相同。此值不能为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the restart intervals in a frame are not guaranteed to be aligned with packet boundaries, the F (first) and L (last) bits MUST be set to 1 and the Restart Count MUST be set to 0x3FFF. This indicates that a receiver MUST reassemble the entire frame before decoding it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果不能保证帧中的重新启动间隔与数据包边界对齐，则F（第一）位和L（最后）位必须设置为1，重新启动计数必须设置为0x3FFF。这表明接收器必须在解码前重新组装整个帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support partial frame decoding, the frame is broken into &#34;chunks&#34; each containing an integral number of restart intervals. The Restart Count field contains the position of the first restart interval in the current &#34;chunk&#34; so that receivers know which part of the frame this data corresponds to. A Restart Interval value SHOULD be chosen to allow a &#34;chunk&#34; to completely fit within a single packet. In this case, both the F and L bits of the packet are set to 1. However, if a chunk needs to be spread across multiple packets, the F bit will be set to 1 in the first packet of the chunk (and only that one) and the L bit will be set to 1 in the last packet of the chunk (and only that one).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了支持部分帧解码，帧被分成“块”，每个块包含整数个重新启动间隔。重新启动计数字段包含当前“块”中第一个重新启动间隔的位置，以便接收器知道此数据对应于帧的哪个部分。应选择重新启动间隔值，以允许“块”完全适合单个数据包。在这种情况下，分组的F和L位都被设置为1。然而，如果一个块需要在多个数据包中分布，则在该块的第一个数据包（并且仅该数据包）中，F位将设置为1，在该块的最后一个数据包（并且仅该数据包）中，L位将设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. Quantization Table header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. 量化表头
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This header MUST be present after the main JPEG header (and after the Restart Marker header, if present) when using Q values 128-255. It provides a way to specify the quantization tables associated with this Q value in-band.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用Q值128-255时，此标头必须位于主JPEG标头之后（以及重新启动标记标头之后，如果存在）。它提供了一种在频带中指定与该Q值相关联的量化表的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      MBZ      |   Precision   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Quantization Table Data                    |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      MBZ      |   Precision   |             Length            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Quantization Table Data                    |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Length field is set to the length in bytes of the quantization table data to follow. The Length field MAY be set to zero to indicate that no quantization table data is included in this frame. See section 4.2 for more information. If the Length field in a received packet is larger than the remaining number of bytes, the packet MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度字段被设置为要跟随的量化表数据的字节长度。长度字段可以设置为零，以指示该帧中不包括量化表数据。更多信息请参见第4.2节。如果接收到的数据包中的长度字段大于剩余字节数，则必须丢弃该数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When table data is included, the number of tables present depends on the JPEG type field. For example, type 0 uses two tables (one for the luminance component and one shared by the chrominance components). Each table is an array of 64 values given in zig-zag order, identical to the format used in a JFIF DQT marker segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包含表格数据时，显示的表格数量取决于JPEG类型字段。例如，类型0使用两个表（一个用于亮度分量，另一个由色度分量共享）。每个表是一个以之字形顺序给出的64个值的数组，与JFIF DQT标记段中使用的格式相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each quantization table present, a bit in the Precision field specifies the size of the coefficients in that table. If the bit is zero, the coefficients are 8 bits yielding a table length of 64 bytes. If the bit is one, the coefficients are 16 bits for a table length of 128 bytes. For 16 bit tables, the coefficients are presented in network byte order. The rightmost bit in the Precision field (bit 15 in the diagram above) corresponds to the first table and each additional table uses the next bit to the left. Bits beyond those corresponding to the tables needed by the type in use MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于存在的每个量化表，精度字段中的一位指定该表中系数的大小。如果位为零，则系数为8位，产生64字节的表长度。如果位为1，则对于128字节的表长度，系数为16位。对于16位表，系数以网络字节顺序表示。精度字段中最右边的位（上图中的位15）对应于第一个表，每个附加表使用左边的下一位。必须忽略与正在使用的类型所需的表相对应的位以外的位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Q values from 128 to 254, the Q value to quantization table data mapping MUST be static, i.e., the receivers are guaranteed that they only need to read the table data once in order to correctly decode frames sent with that Q value. A Q value of 255 denotes that the quantization table mapping is dynamic and can change on every frame. Decoders MUST NOT depend on any previous version of the tables, and need to reload these tables on every frame. Packets MUST NOT contain Q = 255 and Length = 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于从128到254的Q值，Q值到量化表数据映射必须是静态的，即，确保接收机只需要读取表数据一次，以便正确解码用该Q值发送的帧。Q值255表示量化表映射是动态的，并且可以在每一帧上改变。解码器不能依赖于任何以前版本的表，并且需要在每一帧上重新加载这些表。数据包不能包含Q=255和长度=0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9. JPEG Payload
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9. JPEG有效载荷
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data following the RTP/JPEG headers is an entropy-coded segment consisting of a single scan. The scan header is not present and is inferred from the RTP/JPEG header. The scan is terminated either implicitly (i.e., the point at which the image is fully parsed), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP/JPEG头后面的数据是由单个扫描组成的熵编码段。扫描头不存在，并根据RTP/JPEG头推断。扫描被隐式终止（即，图像被完全解析的点），或者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
explicitly with an EOI marker. The scan may be padded to arbitrary length with undefined bytes. (Some existing hardware codecs generate extra lines at the bottom of a video frame and removal of these lines would require a Huffman-decoding pass over the data.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
显式地使用EOI标记。扫描可以用未定义的字节填充到任意长度。（一些现有的硬件编解码器在视频帧的底部生成额外的行，删除这些行需要对数据进行哈夫曼解码。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type code determines whether restart markers are present. If a type supports restart markers, the packet MUST contain a non-zero Restart Interval value in a Restart Marker Header and restart markers MUST appear on byte aligned boundaries beginning with an 0xFF between MCUs at that interval. Additional 0xFF bytes MAY appear between restart intervals. This can be used in the packetization process to align data to something like a word boundary for more efficient copying. Restart markers MUST NOT appear anywhere else in the JPEG payload. Types which do not support restart makers MUST NOT contain restart markers anywhere in the JPEG payload. All packets MUST contain a &#34;stuffed&#34; 0x00 byte following any true 0xFF byte generated by the entropy coder [1, Sec. B.1.1.5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型代码确定是否存在重新启动标记。如果类型支持重新启动标记，则数据包必须在重新启动标记标头中包含非零的重新启动间隔值，并且重新启动标记必须显示在以该间隔在MCU之间以0xFF开始的字节对齐边界上。重启间隔之间可能会出现额外的0xFF字节。这可以在打包过程中用于将数据与字边界之类的内容对齐，以实现更高效的复制。重新启动标记不得出现在JPEG有效负载中的任何其他位置。不支持重新启动生成器的类型不得在JPEG有效负载中的任何位置包含重新启动标记。所有数据包必须在熵编码器生成的任何真实0xFF字节之后包含一个“填充”0x00字节[1，第B.1.1.5节]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 讨论
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. The Type Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 类型字段
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type field defines the abbreviated table-specification and additional JFIF-style parameters not defined by JPEG, since they are not present in the body of the transmitted JPEG data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型字段定义缩写表规范和JPEG未定义的附加JFIF样式参数，因为它们不存在于传输的JPEG数据体中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Three ranges of the type field are currently defined. Types 0-63 are reserved as fixed, well-known mappings to be defined by this document and future revisions of this document. Types 64-127 are the same as types 0-63, except that restart markers are present in the JPEG data and a Restart Marker header appears immediately following the main JPEG header. Types 128-255 are free to be dynamically defined by a session setup protocol (which is beyond the scope of this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当前定义了类型字段的三个范围。类型0-63保留为本文档和本文档未来版本定义的固定的、众所周知的映射。类型64-127与类型0-63相同，不同之处在于JPEG数据中存在重新启动标记，并且在主JPEG标头之后立即显示重新启动标记标头。128-255类型可以由会话设置协议（不在本文档范围内）动态定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Of the first group of fixed mappings, types 0 and 1 are currently defined, along with the corresponding types 64 and 65 that indicate the presence of restart markers. They correspond to an abbreviated table-specification indicating the &#34;Baseline DCT sequential&#34; mode, 8-bit samples, square pixels, three components in the YUV color space, standard Huffman tables as defined in [1, Annex K.3], and a single interleaved scan with a scan component selector indicating components 1, 2, and 3 in that order. The Y, U, and V color planes correspond to component numbers 1, 2, and 3, respectively. Component 1 (i.e., the luminance plane) uses Huffman table number 0 and quantization table number 0 (defined below) and components 2 and 3 (i.e., the chrominance planes) use Huffman table number 1 and quantization table number 1 (defined below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第一组固定映射中，当前定义了类型0和1，以及指示存在重启标记的相应类型64和65。它们对应于指示“基线DCT序列”模式的缩写表规范、8位样本、方形像素、YUV颜色空间中的三个分量、在[1，附录K.3]中定义的标准哈夫曼表，以及具有按该顺序指示分量1、2和3的扫描分量选择器的单次交错扫描。Y、U和V颜色平面分别对应于元件编号1、2和3。组件1（即亮度平面）使用哈夫曼表编号0和量化表编号0（定义见下文），组件2和3（即色度平面）使用哈夫曼表编号1和量化表编号1（定义见下文）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type numbers 2-5 are reserved and SHOULD NOT be used. Applications based on previous versions of this document (RFC 2035) should be updated to indicate the presence of restart markers with type 64 or 65 and the Restart Marker header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型编号2-5是保留的，不应使用。应更新基于本文档早期版本（RFC 2035）的应用程序，以指示是否存在类型为64或65的重启标记以及重启标记头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two RTP/JPEG types currently defined are described below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当前定义的两种RTP/JPEG类型如下所述：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                            horizontal   vertical   Quantization
           types  component samp. fact. samp. fact. table number
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       |  1 (Y)  |     2     |     1     |     0     |
         | 0, 64 |  2 (U)  |     1     |     1     |     1     |
         |       |  3 (V)  |     1     |     1     |     1     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       |  1 (Y)  |     2     |     2     |     0     |
         | 1, 65 |  2 (U)  |     1     |     1     |     1     |
         |       |  3 (V)  |     1     |     1     |     1     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                            horizontal   vertical   Quantization
           types  component samp. fact. samp. fact. table number
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       |  1 (Y)  |     2     |     1     |     0     |
         | 0, 64 |  2 (U)  |     1     |     1     |     1     |
         |       |  3 (V)  |     1     |     1     |     1     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |       |  1 (Y)  |     2     |     2     |     0     |
         | 1, 65 |  2 (U)  |     1     |     1     |     1     |
         |       |  3 (V)  |     1     |     1     |     1     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These sampling factors indicate that the chrominance components of type 0 video is downsampled horizontally by 2 (often called 4:2:2) while the chrominance components of type 1 video are downsampled both horizontally and vertically by 2 (often called 4:2:0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些采样系数表明，0型视频的色度分量水平向下采样2（通常称为4:2:2），而1型视频的色度分量水平和垂直向下采样2（通常称为4:2:0）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Types 0 and 1 can be used to carry both progressively scanned and interlaced image data. This is encoded using the Type-specific field in the main JPEG header. The following values are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型0和1可用于携带渐进扫描和隔行扫描的图像数据。这是使用主JPEG标头中的特定类型字段进行编码的。定义了以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0 : Image is progressively scanned. On a computer monitor, it can be displayed as-is at the specified width and height.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0：逐步扫描图像。在计算机显示器上，它可以按指定的宽度和高度按原样显示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1 : Image is an odd field of an interlaced video signal. The height specified in the main JPEG header is half of the height of the entire displayed image. This field should be de-interlaced with the even field following it such that lines from each of the images alternate. Corresponding lines from the even field should appear just above those same lines from the odd field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
1：图像是隔行扫描视频信号的奇数场。在主JPEG标头中指定的高度是整个显示图像高度的一半。该场应与其后的偶数场去隔行，以使来自每个图像的线交替。偶数场的对应线应正好出现在奇数场的相同线的上方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2 : Image is an even field of an interlaced video signal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
2：图像是隔行扫描视频信号的偶数场。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3 : Image is a single field from an interlaced video signal, but it should be displayed full frame as if it were received as both the odd &amp; even fields of the frame. On a computer monitor, each line in the image should be displayed twice, doubling the height of the image.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
3：图像是来自隔行扫描视频信号的单场，但它应在整帧显示，就好像它是作为帧的奇偶场接收的一样。在计算机显示器上，图像中的每一行应显示两次，使图像高度加倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendix B contains C source code for transforming the RTP/JPEG header parameters into the JPEG frame and scan headers that are absent from the data payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附录B包含C源代码，用于将RTP/JPEG头参数转换为数据有效负载中不存在的JPEG帧和扫描头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. The Q Field
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Q场
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For JPEG types 0 and 1 (and their corresponding types 64 and 65), Q values between 1 and 99 inclusive are defined as follows. Other values less than 128 are reserved. Additional types are encouraged to use this definition if applicable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于JPEG类型0和1（及其对应的类型64和65），1和99之间的Q值定义如下。保留小于128的其他值。如果适用，鼓励其他类型使用此定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both type 0 and type 1 JPEG require two quantization tables. These tables are calculated as follows. For 1 &lt;= Q &lt;= 99, the Independent JPEG Group&#39;s formula [5] is used to produce a scale factor S as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型0和类型1 JPEG都需要两个量化表。这些表格的计算如下。对于1&lt;=Q&lt;=99，独立JPEG组的公式[5]用于产生比例因子s，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           S = 5000 / Q          for  1 &lt;= Q &lt;= 50
             = 200 - 2 * Q       for 51 &lt;= Q &lt;= 99
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           S = 5000 / Q          for  1 &lt;= Q &lt;= 50
             = 200 - 2 * Q       for 51 &lt;= Q &lt;= 99
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This value is then used to scale Tables K.1 and K.2 from [1] (saturating each value to 8 bits) to give quantization table numbers 0 and 1, respectively. C source code is provided in Appendix A to compute these tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后使用该值从[1]缩放表K.1和K.2（将每个值饱和到8位），分别给出量化表编号0和1。附录A中提供了C源代码来计算这些表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For Q values 128-255, dynamically defined quantization tables are used. These tables may be specified either in-band or out of band by something like a session setup protocol, but the Quantization Table header MUST be present in the first packet of every frame. When the tables are specified out of band, they may be omitted from the packet by setting the Length field in this header to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于Q值128-255，使用动态定义的量化表。这些表可以通过类似于会话设置协议的方式在带内或带外指定，但是量化表报头必须存在于每个帧的第一个分组中。当表在带外指定时，可通过将此报头中的长度字段设置为0，将其从数据包中忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the quantization tables are sent in-band, they need not be sent with every frame. Like the out of band case, frames which do not contain tables will have a Quantization Table header with a Length field of 0. While this does decrease the overhead of including the tables, new receivers will be unable to properly decode frames from the time they start up until they receive the tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当量化表在频带中发送时，它们不需要在每一帧中发送。与带外情况一样，不包含表的帧将具有长度字段为0的量化表头。虽然这确实减少了包含表的开销，但新的接收器将无法正确解码从启动到接收表的帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Fragmentation and Reassembly
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 分裂与重组
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since JPEG frames can be large, they must often be fragmented. Frames SHOULD be fragmented into packets in a manner avoiding fragmentation at a lower level. If support for partial frame decoding is desired, frames SHOULD be fragmented such that each packet contains an integral number of restart intervals (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于JPEG帧可能很大，因此必须经常对其进行分段。帧应以避免在较低级别上出现碎片的方式分割成数据包。如果需要支持部分帧解码，则帧应分段，以便每个数据包包含整数个重新启动间隔（见下文）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each packet that makes up a single frame MUST have the same timestamp, and the RTP marker bit MUST be set on the last packet in a frame. The fragment offset field of each packet is set to the byte
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
构成单个帧的每个数据包必须具有相同的时间戳，并且RTP标记位必须在帧中的最后一个数据包上设置。每个数据包的片段偏移量字段设置为字节
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
offset of its payload data within the original frame. Packets making up a frame SHOULD be sent sequentially and the fragments they contain MUST NOT overlap one another.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其有效负载数据在原始帧内的偏移量。组成一个帧的数据包应该按顺序发送，它们包含的片段不能相互重叠。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An entire frame can be identified as a sequence of packets beginning with a packet having a zero fragment offset and ending with a packet having the RTP marker bit set. Missing packets can be detected either with RTP sequence numbers or with the fragment offset and lengths of each packet. Reassembly could be carried out without the offset field (i.e., using only the RTP marker bit and sequence numbers), but an efficient single-copy implementation would not otherwise be possible in the presence of misordered packets. Moreover, if the last packet of the previous frame (containing the marker bit) were dropped, then a receiver could not always detect that the current frame is entirely intact.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
整个帧可以被识别为以具有零片段偏移量的分组开始并以具有RTP标记位集的分组结束的分组序列。可以使用RTP序列号或每个数据包的片段偏移量和长度来检测丢失的数据包。可以在没有偏移字段的情况下执行重新组装（即，仅使用RTP标记位和序列号），但是在存在无序数据包的情况下，不可能实现有效的单拷贝实现。此外，如果前一帧的最后一个数据包（包含标记位）被丢弃，那么接收器不能总是检测到当前帧是完全完整的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Restart Markers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 重新启动标记
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restart markers indicate a point in the JPEG stream at which the Huffman decoder and DC predictors are reset, allowing partial decoding starting at that point. To fully take advantage of this, however, a decoder must know which MCUs of a frame a particular restart interval encodes. While the original JPEG specification does provide a small sequence number field in the restart markers for this purpose, it is not large enough to properly cope with the loss of an entire packet&#39;s worth of data at a typical network MTU size. The RTP/JPEG Restart Marker header contains the additional information needed to accomplish this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新启动标记表示JPEG流中的一个点，在该点处，哈夫曼解码器和DC预测器被重置，从而允许从该点开始部分解码。然而，为了充分利用这一点，解码器必须知道特定重启间隔编码的帧的哪个MCU。虽然原始JPEG规范确实为此目的在重新启动标记中提供了一个小的序列号字段，但它不足以在典型的网络MTU大小下正确处理整个数据包的数据丢失。RTP/JPEG重新启动标记头包含完成此操作所需的附加信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size of restart intervals SHOULD be chosen to always allow an integral number of restart intervals to fit within a single packet. This will guarantee that packets can be decoded independently from one another. If a restart interval ends up being larger than a packet, the F and L bits in the Restart Marker header can be used to fragment it, but the resulting set of packets must all be received by a decoder for that restart interval to be decoded properly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新启动间隔的大小应选择为始终允许在单个数据包中容纳整数个重新启动间隔。这将保证数据包可以彼此独立地解码。如果重新启动间隔最终大于一个数据包，则可以使用重新启动标记头中的F和L位对其进行分段，但解码器必须接收所有生成的数据包集，才能正确解码该重新启动间隔。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once a decoder has received either a single packet with both the F and L bits set on or a contiguous sequence of packets (based on the RTP sequence number) which begin with an F bit and end with an L bit, it can begin decoding. The position of the MCU at the beginning of the data can be determined by multiplying the Restart Count value by the Restart Interval value. A packet (or group of packets as identified by the F and L bits) may contain any number of consecutive restart intervals.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦解码器接收到同时设置了F和L位的单个数据包或以F位开始并以L位结束的连续数据包序列（基于RTP序列号），它就可以开始解码。通过将重启计数值乘以重启间隔值，可以确定MCU在数据开始处的位置。一个数据包（或由F和L位标识的一组数据包）可以包含任意数量的连续重启间隔。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To accommodate encoders which generate frames with restart markers in them but cannot fragment the data in this manner, the Restart Count
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了适应编码器生成的帧中带有重新启动标记，但不能以这种方式分割数据，重新启动计数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
field may be set to 0x3FFF with the F and L bits both set to 1. This indicates to decoders that the entire frame must be reassembled before decoding it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字段可以设置为0x3FFF，F和L位都设置为1。这向解码器表明，在解码之前必须重新组装整个帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTP packets using the payload format defined in this specification are subject to the security considerations discussed in the RTP specification [6], and any appropriate RTP profile (for example [7]). This implies that confidentiality of the media streams is achieved by encryption. Because the data compression used with this payload format is applied end-to-end, encryption may be performed after compression so there is no conflict between the two operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用本规范中定义的有效负载格式的RTP数据包受RTP规范[6]和任何适当RTP配置文件（例如[7]）中讨论的安全注意事项的约束。这意味着媒体流的机密性是通过加密实现的。由于与此有效负载格式一起使用的数据压缩是端到端应用的，因此可以在压缩之后执行加密，因此两个操作之间没有冲突。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A potential denial-of-service threat exists for data encodings using compression techniques that have non-uniform receiver-end computational load. The attacker can inject pathological datagrams into the stream which are complex to decode and cause the receiver to be overloaded. However, this encoding does not exhibit any significant non-uniformity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用压缩技术的数据编码存在潜在的拒绝服务威胁，这种压缩技术具有非均匀的接收端计算负载。攻击者可以向流中注入病理数据报，这些数据报解码复杂，并导致接收器过载。然而，这种编码并没有表现出任何显著的非均匀性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another potential denial-of-service threat exists around the fragmentation mechanism presented here. Receivers should be prepared to limit the total amount of data associated with assembling received frames so as to avoid resource exhaustion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
另一个潜在的拒绝服务威胁存在于此处介绍的碎片机制周围。接收机应准备好限制与组合接收帧相关联的数据总量，以避免资源耗尽。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with any IP-based protocol, in some circumstances a receiver may be overloaded simply by the receipt of too many packets, either desired or undesired. Network-layer authentication may be used to discard packets from undesired sources, but the processing cost of the authentication itself may be too high. In a multicast environment, pruning of specific sources will be implemented in a future version of IGMP [8] and in multicast routing protocols to allow a receiver to select which sources are allowed to reach it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与任何基于IP的协议一样，在某些情况下，接收机可能仅仅因为接收了太多的数据包而过载，不管是想要的还是不想要的。网络层认证可用于丢弃来自不希望的源的数据包，但认证本身的处理成本可能过高。在多播环境中，将在IGMP[8]的未来版本和多播路由协议中实现特定源的修剪，以允许接收器选择允许到达它的源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A security review of this payload format found no additional considerations beyond those in the RTP specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对该有效负载格式的安全性审查发现，除了RTP规范中的考虑之外，没有其他考虑。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 作者地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lance M. Berc Systems Research Center Digital Equipment Corporation 130 Lytton Ave Palo Alto CA 94301
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lance M.Berc系统研究中心数字设备公司加利福尼亚州帕洛阿尔托市利顿大道130号94301
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 853 2100
   EMail: berc@pa.dec.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 853 2100
   EMail: berc@pa.dec.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
William C. Fenner Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
美国加利福尼亚州帕洛阿尔托郊狼山路3333号威廉·C·芬纳施乐公园，邮编94304
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 812 4816
   EMail: fenner@parc.xerox.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 812 4816
   EMail: fenner@parc.xerox.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ron Frederick Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
罗恩·弗雷德里克·施乐公园，地址：加利福尼亚州帕洛阿尔托市郊狼山路3333号，邮编：94304
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 812 4459
   EMail: frederick@parc.xerox.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 812 4459
   EMail: frederick@parc.xerox.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Steven McCanne University of California at Berkeley Electrical Engineering and Computer Science 633 Soda Hall Berkeley, CA 94720
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
史提芬McChane加州大学伯克利分校电气工程与计算机科学633苏打厅伯克利，CA 94720
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 510 642 0865
   EMail: mccanne@cs.berkeley.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 510 642 0865
   EMail: mccanne@cs.berkeley.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Stewart Xerox PARC 3333 Coyote Hill Road Palo Alto, CA 94304
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保尔·斯图尔特·施乐帕克3333，加利福尼亚州帕洛阿尔托郊狼山路94304
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 812 4821
   EMail: stewart@parc.xerox.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 812 4821
   EMail: stewart@parc.xerox.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] ISO DIS 10918-1. Digital Compression and Coding of Continuous-tone Still Images (JPEG), CCITT Recommendation T.81.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] ISO DIS 10918-1。连续色调静态图像（JPEG）的数字压缩和编码，CCITT建议T.81。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] William B. Pennebaker, Joan L. Mitchell, JPEG: Still Image Data Compression Standard, Van Nostrand Reinhold, 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] 威廉·B·彭尼贝克，琼·L·米切尔，JPEG：静态图像数据压缩标准，范诺斯特朗·莱因霍尔德，1993。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Gregory K. Wallace, The JPEG Sill Picture Compression Standard, Communications of the ACM, April 1991, Vol 34, No. 1, pp. 31-44.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Gregory K.Wallace，《JPEG图像压缩标准》，ACM通信，1991年4月，第34卷，第1期，第31-44页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] The JPEG File Interchange Format. Maintained by C-Cube Microsystems, Inc., and available in ftp://ftp.uu.net/graphics/jpeg/jfif.ps.gz.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] JPEG文件交换格式。由C-Cube Microsystems，Inc.维护，可在ftp://ftp.uu.net/graphics/jpeg/jfif.ps.gz.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Tom Lane et. al., The Independent JPEG Group software JPEG codec. Source code available in ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6a.tar.gz.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Tom Lane等人，独立的JPEG组软件JPEG编解码器。源代码可在ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6a.tar.gz.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, RFC 1889, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Schulzrinne，H.，Casner，S.，Frederick，R.和V.Jacobson，“RTP：实时应用的传输协议”，RFC 1889，1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Schulzrinne, H., &#34;RTP Profile for Audio and Video Conferences with Minimal Control&#34;, RFC 1890, January 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Schulzrinne，H.，“具有最小控制的音频和视频会议的RTP配置文件”，RFC 1890，1996年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Fenner, W., &#34;Internet Group Management Protocol Version 2&#34;, RFC 2236, November 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Fenner，W.，“互联网组管理协议版本2”，RFC 2236，1997年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Kent C., and J. Mogul, &#34;Fragmentation Considered Harmful&#34;, Proceedings of the ACM SIGCOMM &#39;87 Workshop on Frontiers in Computer Communications Technology, August 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Kent C.和J.Mogul，“碎片被认为是有害的”，ACM SIGCOMM&#39;87计算机通信技术前沿研讨会论文集，1987年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录A
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following code can be used to create a quantization table from a Q factor:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下代码可用于根据Q因子创建量化表：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * Table K.1 from JPEG spec.
 */
static const int jpeg_luma_quantizer[64] = {
        16, 11, 10, 16, 24, 40, 51, 61,
        12, 12, 14, 19, 26, 58, 60, 55,
        14, 13, 16, 24, 40, 57, 69, 56,
        14, 17, 22, 29, 51, 87, 80, 62,
        18, 22, 37, 56, 68, 109, 103, 77,
        24, 35, 55, 64, 81, 104, 113, 92,
        49, 64, 78, 87, 103, 121, 120, 101,
        72, 92, 95, 98, 112, 100, 103, 99
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * Table K.1 from JPEG spec.
 */
static const int jpeg_luma_quantizer[64] = {
        16, 11, 10, 16, 24, 40, 51, 61,
        12, 12, 14, 19, 26, 58, 60, 55,
        14, 13, 16, 24, 40, 57, 69, 56,
        14, 17, 22, 29, 51, 87, 80, 62,
        18, 22, 37, 56, 68, 109, 103, 77,
        24, 35, 55, 64, 81, 104, 113, 92,
        49, 64, 78, 87, 103, 121, 120, 101,
        72, 92, 95, 98, 112, 100, 103, 99
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * Table K.2 from JPEG spec.
 */
static const int jpeg_chroma_quantizer[64] = {
        17, 18, 24, 47, 99, 99, 99, 99,
        18, 21, 26, 66, 99, 99, 99, 99,
        24, 26, 56, 99, 99, 99, 99, 99,
        47, 66, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * Table K.2 from JPEG spec.
 */
static const int jpeg_chroma_quantizer[64] = {
        17, 18, 24, 47, 99, 99, 99, 99,
        18, 21, 26, 66, 99, 99, 99, 99,
        24, 26, 56, 99, 99, 99, 99, 99,
        47, 66, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99,
        99, 99, 99, 99, 99, 99, 99, 99
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * Call MakeTables with the Q factor and two u_char[64] return arrays
 */
void
MakeTables(int q, u_char *lqt, u_char *cqt)
{
  int i;
  int factor = q;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * Call MakeTables with the Q factor and two u_char[64] return arrays
 */
void
MakeTables(int q, u_char *lqt, u_char *cqt)
{
  int i;
  int factor = q;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
  if (q &lt; 1) factor = 1;
  if (q &gt; 99) factor = 99;
  if (q &lt; 50)
    q = 5000 / factor;
  else
    q = 200 - factor*2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
  if (q &lt; 1) factor = 1;
  if (q &gt; 99) factor = 99;
  if (q &lt; 50)
    q = 5000 / factor;
  else
    q = 200 - factor*2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
  for (i=0; i &lt; 64; i++) {
    int lq = (jpeg_luma_quantizer[i] * q + 50) / 100;
    int cq = (jpeg_chroma_quantizer[i] * q + 50) / 100;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
  for (i=0; i &lt; 64; i++) {
    int lq = (jpeg_luma_quantizer[i] * q + 50) / 100;
    int cq = (jpeg_chroma_quantizer[i] * q + 50) / 100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    /* Limit the quantizers to 1 &lt;= q &lt;= 255 */
    if (lq &lt; 1) lq = 1;
    else if (lq &gt; 255) lq = 255;
    lqt[i] = lq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    /* Limit the quantizers to 1 &lt;= q &lt;= 255 */
    if (lq &lt; 1) lq = 1;
    else if (lq &gt; 255) lq = 255;
    lqt[i] = lq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    if (cq &lt; 1) cq = 1;
    else if (cq &gt; 255) cq = 255;
    cqt[i] = cq;
  }
}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    if (cq &lt; 1) cq = 1;
    else if (cq &gt; 255) cq = 255;
    cqt[i] = cq;
  }
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix B
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录B
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following routines can be used to create the JPEG marker segments corresponding to the table-specification data that is absent from the RTP/JPEG body.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下例程可用于创建与RTP/JPEG正文中缺少的表规范数据相对应的JPEG标记段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_dc_codelens[] = {
        0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_dc_codelens[] = {
        0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_dc_symbols[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_dc_symbols[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_ac_codelens[] = {
        0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d,
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_ac_codelens[] = {
        0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_ac_symbols[] = {
        0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
        0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
        0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
        0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
        0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
        0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
        0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
        0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
        0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
        0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
        0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
        0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
        0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
        0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
        0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
        0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
        0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa,
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char lum_ac_symbols[] = {
        0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
        0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
        0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08,
        0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0,
        0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16,
        0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
        0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
        0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
        0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
        0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
        0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
        0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
        0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6,
        0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5,
        0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4,
        0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea,
        0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_dc_codelens[] = {
        0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_dc_codelens[] = {
        0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_dc_symbols[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_dc_symbols[] = {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_ac_codelens[] = {
        0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77,
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_ac_codelens[] = {
        0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_ac_symbols[] = {
        0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
        0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
        0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
        0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
        0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
        0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
        0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
        0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
        0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
        0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
        0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
        0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
        0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa,
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char chm_ac_symbols[] = {
        0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21,
        0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
        0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91,
        0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0,
        0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34,
        0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26,
        0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
        0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5,
        0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3,
        0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2,
        0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
        0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
        0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa,
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char *
MakeQuantHeader(u_char *p, u_char *qt, int tableNo)
{
        *p++ = 0xff;
        *p++ = 0xdb;            /* DQT */
        *p++ = 0;               /* length msb */
        *p++ = 67;              /* length lsb */
        *p++ = tableNo;
        memcpy(p, qt, 64);
        return (p + 64);
}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char *
MakeQuantHeader(u_char *p, u_char *qt, int tableNo)
{
        *p++ = 0xff;
        *p++ = 0xdb;            /* DQT */
        *p++ = 0;               /* length msb */
        *p++ = 67;              /* length lsb */
        *p++ = tableNo;
        memcpy(p, qt, 64);
        return (p + 64);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char *
MakeHuffmanHeader(u_char *p, u_char *codelens, int ncodes,
                  u_char *symbols, int nsymbols, int tableNo,
                  int tableClass)
{
        *p++ = 0xff;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char *
MakeHuffmanHeader(u_char *p, u_char *codelens, int ncodes,
                  u_char *symbols, int nsymbols, int tableNo,
                  int tableClass)
{
        *p++ = 0xff;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xc4;            /* DHT */
        *p++ = 0;               /* length msb */
        *p++ = 3 + ncodes + nsymbols; /* length lsb */
        *p++ = (tableClass &lt;&lt; 4) | tableNo;
        memcpy(p, codelens, ncodes);
        p += ncodes;
        memcpy(p, symbols, nsymbols);
        p += nsymbols;
        return (p);
}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xc4;            /* DHT */
        *p++ = 0;               /* length msb */
        *p++ = 3 + ncodes + nsymbols; /* length lsb */
        *p++ = (tableClass &lt;&lt; 4) | tableNo;
        memcpy(p, codelens, ncodes);
        p += ncodes;
        memcpy(p, symbols, nsymbols);
        p += nsymbols;
        return (p);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char *
MakeDRIHeader(u_char *p, u_short dri) {
        *p++ = 0xff;
        *p++ = 0xdd;            /* DRI */
        *p++ = 0x0;             /* length msb */
        *p++ = 4;               /* length lsb */
        *p++ = dri &gt;&gt; 8;        /* dri msb */
        *p++ = dri &amp; 0xff;      /* dri lsb */
        return (p);
}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_char *
MakeDRIHeader(u_char *p, u_short dri) {
        *p++ = 0xff;
        *p++ = 0xdd;            /* DRI */
        *p++ = 0x0;             /* length msb */
        *p++ = 4;               /* length lsb */
        *p++ = dri &gt;&gt; 8;        /* dri msb */
        *p++ = dri &amp; 0xff;      /* dri lsb */
        return (p);
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 *  Arguments:
 *    type, width, height: as supplied in RTP/JPEG header
 *    lqt, cqt: quantization tables as either derived from
 *         the Q field using MakeTables() or as specified
 *         in section 4.2.
 *    dri: restart interval in MCUs, or 0 if no restarts.
 *
 *    p: pointer to return area
 *
 *  Return value:
 *    The length of the generated headers.
 *
 *    Generate a frame and scan headers that can be prepended to the
 *    RTP/JPEG data payload to produce a JPEG compressed image in
 *    interchange format (except for possible trailing garbage and
 *    absence of an EOI marker to terminate the scan).
 */
int MakeHeaders(u_char *p, int type, int w, int h, u_char *lqt,
                u_char *cqt, u_short dri)
{
        u_char *start = p;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 *  Arguments:
 *    type, width, height: as supplied in RTP/JPEG header
 *    lqt, cqt: quantization tables as either derived from
 *         the Q field using MakeTables() or as specified
 *         in section 4.2.
 *    dri: restart interval in MCUs, or 0 if no restarts.
 *
 *    p: pointer to return area
 *
 *  Return value:
 *    The length of the generated headers.
 *
 *    Generate a frame and scan headers that can be prepended to the
 *    RTP/JPEG data payload to produce a JPEG compressed image in
 *    interchange format (except for possible trailing garbage and
 *    absence of an EOI marker to terminate the scan).
 */
int MakeHeaders(u_char *p, int type, int w, int h, u_char *lqt,
                u_char *cqt, u_short dri)
{
        u_char *start = p;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* convert from blocks to pixels */
        w &lt;&lt;= 3;
        h &lt;&lt;= 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* convert from blocks to pixels */
        w &lt;&lt;= 3;
        h &lt;&lt;= 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xd8;            /* SOI */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xd8;            /* SOI */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        p = MakeQuantHeader(p, lqt, 0);
        p = MakeQuantHeader(p, cqt, 1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        p = MakeQuantHeader(p, lqt, 0);
        p = MakeQuantHeader(p, cqt, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        if (dri != 0)
                p = MakeDRIHeader(p, dri);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        if (dri != 0)
                p = MakeDRIHeader(p, dri);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xc0;            /* SOF */
        *p++ = 0;               /* length msb */
        *p++ = 17;              /* length lsb */
        *p++ = 8;               /* 8-bit precision */
        *p++ = h &gt;&gt; 8;          /* height msb */
        *p++ = h;               /* height lsb */
        *p++ = w &gt;&gt; 8;          /* width msb */
        *p++ = w;               /* wudth lsb */
        *p++ = 3;               /* number of components */
        *p++ = 0;               /* comp 0 */
        if (type == 0)
                *p++ = 0x21;    /* hsamp = 2, vsamp = 1 */
        else
                *p++ = 0x22;    /* hsamp = 2, vsamp = 2 */
        *p++ = 0;               /* quant table 0 */
        *p++ = 1;               /* comp 1 */
        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */
        *p++ = 1;               /* quant table 1 */
        *p++ = 2;               /* comp 2 */
        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */
        *p++ = 1;               /* quant table 1 */
        p = MakeHuffmanHeader(p, lum_dc_codelens,
                              sizeof(lum_dc_codelens),
                              lum_dc_symbols,
                              sizeof(lum_dc_symbols), 0, 0);
        p = MakeHuffmanHeader(p, lum_ac_codelens,
                              sizeof(lum_ac_codelens),
                              lum_ac_symbols,
                              sizeof(lum_ac_symbols), 0, 1);
        p = MakeHuffmanHeader(p, chm_dc_codelens,
                              sizeof(chm_dc_codelens),
                              chm_dc_symbols,
                              sizeof(chm_dc_symbols), 1, 0);
        p = MakeHuffmanHeader(p, chm_ac_codelens,
                              sizeof(chm_ac_codelens),
                              chm_ac_symbols,
                              sizeof(chm_ac_symbols), 1, 1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xc0;            /* SOF */
        *p++ = 0;               /* length msb */
        *p++ = 17;              /* length lsb */
        *p++ = 8;               /* 8-bit precision */
        *p++ = h &gt;&gt; 8;          /* height msb */
        *p++ = h;               /* height lsb */
        *p++ = w &gt;&gt; 8;          /* width msb */
        *p++ = w;               /* wudth lsb */
        *p++ = 3;               /* number of components */
        *p++ = 0;               /* comp 0 */
        if (type == 0)
                *p++ = 0x21;    /* hsamp = 2, vsamp = 1 */
        else
                *p++ = 0x22;    /* hsamp = 2, vsamp = 2 */
        *p++ = 0;               /* quant table 0 */
        *p++ = 1;               /* comp 1 */
        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */
        *p++ = 1;               /* quant table 1 */
        *p++ = 2;               /* comp 2 */
        *p++ = 0x11;            /* hsamp = 1, vsamp = 1 */
        *p++ = 1;               /* quant table 1 */
        p = MakeHuffmanHeader(p, lum_dc_codelens,
                              sizeof(lum_dc_codelens),
                              lum_dc_symbols,
                              sizeof(lum_dc_symbols), 0, 0);
        p = MakeHuffmanHeader(p, lum_ac_codelens,
                              sizeof(lum_ac_codelens),
                              lum_ac_symbols,
                              sizeof(lum_ac_symbols), 0, 1);
        p = MakeHuffmanHeader(p, chm_dc_codelens,
                              sizeof(chm_dc_codelens),
                              chm_dc_symbols,
                              sizeof(chm_dc_symbols), 1, 0);
        p = MakeHuffmanHeader(p, chm_ac_codelens,
                              sizeof(chm_ac_codelens),
                              chm_ac_symbols,
                              sizeof(chm_ac_symbols), 1, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xda;            /* SOS */
        *p++ = 0;               /* length msb */
        *p++ = 12;              /* length lsb */
        *p++ = 3;               /* 3 components */
        *p++ = 0;               /* comp 0 */
        *p++ = 0;               /* huffman table 0 */
        *p++ = 1;               /* comp 1 */
        *p++ = 0x11;            /* huffman table 1 */
        *p++ = 2;               /* comp 2 */
        *p++ = 0x11;            /* huffman table 1 */
        *p++ = 0;               /* first DCT coeff */
        *p++ = 63;              /* last DCT coeff */
        *p++ = 0;               /* sucessive approx. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *p++ = 0xff;
        *p++ = 0xda;            /* SOS */
        *p++ = 0;               /* length msb */
        *p++ = 12;              /* length lsb */
        *p++ = 3;               /* 3 components */
        *p++ = 0;               /* comp 0 */
        *p++ = 0;               /* huffman table 0 */
        *p++ = 1;               /* comp 1 */
        *p++ = 0x11;            /* huffman table 1 */
        *p++ = 2;               /* comp 2 */
        *p++ = 0x11;            /* huffman table 1 */
        *p++ = 0;               /* first DCT coeff */
        *p++ = 63;              /* last DCT coeff */
        *p++ = 0;               /* sucessive approx. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        return (p - start);
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        return (p - start);
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix C
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录C
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following routine is used to illustrate the RTP/JPEG packet fragmentation and header creation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下例程用于说明RTP/JPEG数据包分段和头创建。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For clarity and brevity, the structure definitions are only valid for 32-bit big-endian (most significant octet first) architectures. Bit fields are assumed to be packed tightly in big-endian bit order, with no additional padding. Modifications would be required to construct a portable implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为清晰和简洁起见，结构定义仅适用于32位big-endian（最重要的八位组优先）体系结构。假定位字段按大端位顺序紧密排列，没有额外的填充。构建一个可移植的实现需要修改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * RTP data header from RFC1889
 */
typedef struct {
        unsigned int version:2;   /* protocol version */
        unsigned int p:1;         /* padding flag */
        unsigned int x:1;         /* header extension flag */
        unsigned int cc:4;        /* CSRC count */
        unsigned int m:1;         /* marker bit */
        unsigned int pt:7;        /* payload type */
        u_int16 seq;              /* sequence number */
        u_int32 ts;               /* timestamp */
        u_int32 ssrc;             /* synchronization source */
        u_int32 csrc[1];          /* optional CSRC list */
} rtp_hdr_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/*
 * RTP data header from RFC1889
 */
typedef struct {
        unsigned int version:2;   /* protocol version */
        unsigned int p:1;         /* padding flag */
        unsigned int x:1;         /* header extension flag */
        unsigned int cc:4;        /* CSRC count */
        unsigned int m:1;         /* marker bit */
        unsigned int pt:7;        /* payload type */
        u_int16 seq;              /* sequence number */
        u_int32 ts;               /* timestamp */
        u_int32 ssrc;             /* synchronization source */
        u_int32 csrc[1];          /* optional CSRC list */
} rtp_hdr_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define RTP_HDR_SZ 12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#定义RTP_HDR_SZ 12
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/* The following definition is from RFC1890 */
#define RTP_PT_JPEG             26
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/* The following definition is from RFC1890 */
#define RTP_PT_JPEG             26
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
struct jpeghdr {
        unsigned int tspec:8;   /* type-specific field */
        unsigned int off:24;    /* fragment byte offset */
        u_int8 type;            /* id of jpeg decoder params */
        u_int8 q;               /* quantization factor (or table id) */
        u_int8 width;           /* frame width in 8 pixel blocks */
        u_int8 height;          /* frame height in 8 pixel blocks */
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
struct jpeghdr {
        unsigned int tspec:8;   /* type-specific field */
        unsigned int off:24;    /* fragment byte offset */
        u_int8 type;            /* id of jpeg decoder params */
        u_int8 q;               /* quantization factor (or table id) */
        u_int8 width;           /* frame width in 8 pixel blocks */
        u_int8 height;          /* frame height in 8 pixel blocks */
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
struct jpeghdr_rst {
        u_int16 dri;
        unsigned int f:1;
        unsigned int l:1;
        unsigned int count:14;
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
struct jpeghdr_rst {
        u_int16 dri;
        unsigned int f:1;
        unsigned int l:1;
        unsigned int count:14;
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
struct jpeghdr_qtable {
        u_int8  mbz;
        u_int8  precision;
        u_int16 length;
};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
struct jpeghdr_qtable {
        u_int8  mbz;
        u_int8  precision;
        u_int16 length;
};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#define RTP_JPEG_RESTART 0x40
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
#定义RTP_JPEG_重新启动0x40
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/* Procedure SendFrame:
 *
 *  Arguments:
 *    start_seq: The sequence number for the first packet of the current
 *               frame.
 *    ts: RTP timestamp for the current frame
 *    ssrc: RTP SSRC value
 *    jpeg_data: Huffman encoded JPEG scan data
 *    len: Length of the JPEG scan data
 *    type: The value the RTP/JPEG type field should be set to
 *    typespec: The value the RTP/JPEG type-specific field should be set
 *              to
 *    width: The width in pixels of the JPEG image
 *    height: The height in pixels of the JPEG image
 *    dri: The number of MCUs between restart markers (or 0 if there
 *         are no restart markers in the data
 *    q: The Q factor of the data, to be specified using the Independent
 *       JPEG group&#39;s algorithm if 1 &lt;= q &lt;= 99, specified explicitly
 *       with lqt and cqt if q &gt;= 128, or undefined otherwise.
 *    lqt: The quantization table for the luminance channel if q &gt;= 128
 *    cqt: The quantization table for the chrominance channels if
 *         q &gt;= 128
 *
 *  Return value:
 *    the sequence number to be sent for the first packet of the next
 *    frame.
 *
 * The following are assumed to be defined:
 *
 * PACKET_SIZE                         - The size of the outgoing packet
 * send_packet(u_int8 *data, int len)  - Sends the packet to the network
 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
/* Procedure SendFrame:
 *
 *  Arguments:
 *    start_seq: The sequence number for the first packet of the current
 *               frame.
 *    ts: RTP timestamp for the current frame
 *    ssrc: RTP SSRC value
 *    jpeg_data: Huffman encoded JPEG scan data
 *    len: Length of the JPEG scan data
 *    type: The value the RTP/JPEG type field should be set to
 *    typespec: The value the RTP/JPEG type-specific field should be set
 *              to
 *    width: The width in pixels of the JPEG image
 *    height: The height in pixels of the JPEG image
 *    dri: The number of MCUs between restart markers (or 0 if there
 *         are no restart markers in the data
 *    q: The Q factor of the data, to be specified using the Independent
 *       JPEG group&#39;s algorithm if 1 &lt;= q &lt;= 99, specified explicitly
 *       with lqt and cqt if q &gt;= 128, or undefined otherwise.
 *    lqt: The quantization table for the luminance channel if q &gt;= 128
 *    cqt: The quantization table for the chrominance channels if
 *         q &gt;= 128
 *
 *  Return value:
 *    the sequence number to be sent for the first packet of the next
 *    frame.
 *
 * The following are assumed to be defined:
 *
 * PACKET_SIZE                         - The size of the outgoing packet
 * send_packet(u_int8 *data, int len)  - Sends the packet to the network
 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_int16 SendFrame(u_int16 start_seq, u_int32 ts, u_int32 ssrc,
                   u_int8 *jpeg_data, int len, u_int8 type,
                   u_int8 typespec, int width, int height, int dri,
                   u_int8 q, u_int8 *lqt, u_int8 *cqt) {
        rtp_hdr_t rtphdr;
        struct jpeghdr jpghdr;
        struct jpeghdr_rst rsthdr;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
u_int16 SendFrame(u_int16 start_seq, u_int32 ts, u_int32 ssrc,
                   u_int8 *jpeg_data, int len, u_int8 type,
                   u_int8 typespec, int width, int height, int dri,
                   u_int8 q, u_int8 *lqt, u_int8 *cqt) {
        rtp_hdr_t rtphdr;
        struct jpeghdr jpghdr;
        struct jpeghdr_rst rsthdr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct jpeghdr_qtable qtblhdr;
        u_int8 packet_buf[PACKET_SIZE];
        u_int8 *ptr;
        int bytes_left = len;
        int seq = start_seq;
        int pkt_len, data_len;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct jpeghdr_qtable qtblhdr;
        u_int8 packet_buf[PACKET_SIZE];
        u_int8 *ptr;
        int bytes_left = len;
        int seq = start_seq;
        int pkt_len, data_len;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize RTP header
         */
        rtphdr.version = 2;
        rtphdr.p = 0;
        rtphdr.x = 0;
        rtphdr.cc = 0;
        rtphdr.m = 0;
        rtphdr.pt = RTP_PT_JPEG;
        rtphdr.seq = start_seq;
        rtphdr.ts = ts;
        rtphdr.ssrc = ssrc;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize RTP header
         */
        rtphdr.version = 2;
        rtphdr.p = 0;
        rtphdr.x = 0;
        rtphdr.cc = 0;
        rtphdr.m = 0;
        rtphdr.pt = RTP_PT_JPEG;
        rtphdr.seq = start_seq;
        rtphdr.ts = ts;
        rtphdr.ssrc = ssrc;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize JPEG header
         */
        jpghdr.tspec = typespec;
        jpghdr.off = 0;
        jpghdr.type = type | ((dri != 0) ? RTP_JPEG_RESTART : 0);
        jpghdr.q = q;
        jpghdr.width = width / 8;
        jpghdr.height = height / 8;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize JPEG header
         */
        jpghdr.tspec = typespec;
        jpghdr.off = 0;
        jpghdr.type = type | ((dri != 0) ? RTP_JPEG_RESTART : 0);
        jpghdr.q = q;
        jpghdr.width = width / 8;
        jpghdr.height = height / 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize DRI header
         */
        if (dri != 0) {
                rsthdr.dri = dri;
                rsthdr.f = 1;        /* This code does not align RIs */
                rsthdr.l = 1;
                rsthdr.count = 0x3fff;
        }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize DRI header
         */
        if (dri != 0) {
                rsthdr.dri = dri;
                rsthdr.f = 1;        /* This code does not align RIs */
                rsthdr.l = 1;
                rsthdr.count = 0x3fff;
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize quantization table header
         */
        if (q &gt;= 128) {
                qtblhdr.mbz = 0;
                qtblhdr.precision = 0; /* This code uses 8 bit tables only */
                qtblhdr.length = 128;  /* 2 64-byte tables */
        }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        /* Initialize quantization table header
         */
        if (q &gt;= 128) {
                qtblhdr.mbz = 0;
                qtblhdr.precision = 0; /* This code uses 8 bit tables only */
                qtblhdr.length = 128;  /* 2 64-byte tables */
        }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        while (bytes_left &gt; 0) {
                ptr = packet_buf + RTP_HDR_SZ;
                memcpy(ptr, &amp;jpghdr, sizeof(jpghdr));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        while (bytes_left &gt; 0) {
                ptr = packet_buf + RTP_HDR_SZ;
                memcpy(ptr, &amp;jpghdr, sizeof(jpghdr));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                ptr += sizeof(jpghdr);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                ptr += sizeof(jpghdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                if (dri != 0) {
                        memcpy(ptr, &amp;rsthdr, sizeof(rsthdr));
                        ptr += sizeof(rsthdr);
                }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                if (dri != 0) {
                        memcpy(ptr, &amp;rsthdr, sizeof(rsthdr));
                        ptr += sizeof(rsthdr);
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                if (q &gt;= 128 &amp;&amp; jpghdr.off == 0) {
                        memcpy(ptr, &amp;qtblhdr, sizeof(qtblhdr));
                        ptr += sizeof(qtblhdr);
                        memcpy(ptr, lqt, 64);
                        ptr += 64;
                        memcpy(ptr, cqt, 64);
                        ptr += 64;
                }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                if (q &gt;= 128 &amp;&amp; jpghdr.off == 0) {
                        memcpy(ptr, &amp;qtblhdr, sizeof(qtblhdr));
                        ptr += sizeof(qtblhdr);
                        memcpy(ptr, lqt, 64);
                        ptr += 64;
                        memcpy(ptr, cqt, 64);
                        ptr += 64;
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                data_len = PACKET_SIZE - (ptr - packet_buf);
                if (data_len &gt;= bytes_left) {
                        data_len = bytes_left;
                        rtphdr.m = 1;
                }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                data_len = PACKET_SIZE - (ptr - packet_buf);
                if (data_len &gt;= bytes_left) {
                        data_len = bytes_left;
                        rtphdr.m = 1;
                }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                memcpy(packet_buf, &amp;rtphdr, RTP_HDR_SZ);
                memcpy(ptr, jpeg_data + jpghdr.off, data_len);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                memcpy(packet_buf, &amp;rtphdr, RTP_HDR_SZ);
                memcpy(ptr, jpeg_data + jpghdr.off, data_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                send_packet(packet_buf, (ptr - packet_buf) + data_len);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                send_packet(packet_buf, (ptr - packet_buf) + data_len);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                jpghdr.off += data_len;
                bytes_left -= data_len;
                rtphdr.seq++;
        }
        return rtphdr.seq;
}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                jpghdr.off += data_len;
                bytes_left -= data_len;
                rtphdr.seq++;
        }
        return rtphdr.seq;
}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix D
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录D
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section outlines the changes between this document and its precdecessor, RFC 2035. The changes to the protocol were made with an eye towards causing as few interoperability problems between implementations based on the older text and newer implementations, and indeed, many of the obsolete conventions can still be unambiguously decoded by a newer implementation. However, use of the older conventions in newer implementations is strongly discouraged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节概述了本文件与其预声明人RFC 2035之间的变更。对协议的更改着眼于在基于旧文本和新实现的实现之间造成尽可能少的互操作性问题，事实上，许多过时的约定仍然可以由新的实现毫不含糊地解码。然而，强烈反对在新的实现中使用旧的约定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o Types 0 and 1 have been augmented to allow for the encoding of interlaced video images, using 2 bits of the type-specific field. See section 4.1 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o 类型0和1已被扩充，以允许使用类型特定字段的2位对隔行扫描视频图像进行编码。详见第4.1节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o There has been discussion in the working group arguing for more flexibility in specifying the JPEG quantization tables. This memo allows table coefficients to be specified explicitly through the use of an optional Quantization Table header, discussed in sections 3.1.8 and 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o 工作组中进行了讨论，主张在指定JPEG量化表时具有更大的灵活性。本备忘录允许通过使用第3.1.8节和第4.2节中讨论的可选量化表格标题明确指定表格系数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o In RFC 2035, the encoding of restart marker information in the Type field made it difficult to add new types. Additionally, the type- specific field was used for the restart count, making it unavailable for other type-specific purposes. This memo moves the restart marker indication to a particular bit in the Type field, and adds an optional header to hold the additional information required, leaving the type-specific field free for its intended purpose. The handling of partial frame decoding was also made more robust against packet loss. See sections 3.1.7 and 4.4 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
o 在RFC 2035中，类型字段中重新启动标记信息的编码使添加新类型变得困难。此外，特定于类型的字段用于重新启动计数，使其无法用于其他特定于类型的目的。此备忘将重新启动标记指示移动到类型字段中的特定位，并添加可选标题以保存所需的附加信息，使特定类型字段可自由使用。部分帧解码的处理对于分组丢失也变得更加健壮。详见第3.1.7节和第4.4节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1998年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
