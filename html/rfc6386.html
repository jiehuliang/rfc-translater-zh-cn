<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6386: VP8 Data Format and Decoding Guide 中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6386</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6386">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6386: VP8 Data Format and Decoding Guide 中文翻译</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc6386">
              https://datatracker.ietf.org/doc/html/rfc6386
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 6386</strong></span><br>
          <span class="updated_by">翻译编辑 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Independent Submission                                       J. Bankoski
Request for Comments: 6386                                   J. Koleszar
Category: Informational                                       L. Quillio
ISSN: 2070-1721                                               J. Salonen
                                                              P. Wilkins
                                                                   Y. Xu
                                                             Google Inc.
                                                           November 2011
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Independent Submission                                       J. Bankoski
Request for Comments: 6386                                   J. Koleszar
Category: Informational                                       L. Quillio
ISSN: 2070-1721                                               J. Salonen
                                                              P. Wilkins
                                                                   Y. Xu
                                                             Google Inc.
                                                           November 2011
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
VP8 Data Format and Decoding Guide
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
VP8数据格式和解码指南
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the VP8 compressed video data format, together with a discussion of the decoding procedure for the format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档介绍了VP8压缩视频数据格式，并讨论了该格式的解码过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件不是互联网标准跟踪规范；它是为了提供信息而发布的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是对RFC系列的贡献，独立于任何其他RFC流。RFC编辑器已选择自行发布此文档，并且未声明其对实现或部署的价值。RFC编辑批准发布的文件不适用于任何级别的互联网标准；见RFC 5741第2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6386.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc6386.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（c）2011 IETF信托基金和确定为文件作者的人员。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................4
   2. Format Overview .................................................5
   3. Compressed Frame Types ..........................................7
   4. Overview of Compressed Data Format ..............................8
   5. Overview of the Decoding Process ................................9
   6. Description of Algorithms ......................................14
   7. Boolean Entropy Decoder ........................................16
      7.1. Underlying Theory of Coding ...............................17
      7.2. Practical Algorithm Description ...........................18
      7.3. Actual Implementation .....................................20
   8. Compressed Data Components .....................................25
      8.1. Tree Coding Implementation ................................27
      8.2. Tree Coding Example .......................................28
   9. Frame Header ...................................................30
      9.1. Uncompressed Data Chunk ...................................30
      9.2. Color Space and Pixel Type (Key Frames Only) ..............33
      9.3. Segment-Based Adjustments .................................34
      9.4. Loop Filter Type and Levels ...............................35
      9.5. Token Partition and Partition Data Offsets ................36
      9.6. Dequantization Indices ....................................37
      9.7. Refresh Golden Frame and Altref Frame .....................38
      9.8. Refresh Last Frame Buffer .................................39
      9.9. DCT Coefficient Probability Update ........................39
      9.10. Remaining Frame Header Data (Non-Key Frame) ..............40
      9.11. Remaining Frame Header Data (Key Frame) ..................41
   10. Segment-Based Feature Adjustments .............................41
   11. Key Frame Macroblock Prediction Records .......................42
      11.1. mb_skip_coeff ............................................42
      11.2. Luma Modes ...............................................42
      11.3. Subblock Mode Contexts ...................................45
      11.4. Chroma Modes .............................................46
      11.5. Subblock Mode Probability Table ..........................47
   12. Intraframe Prediction .........................................50
      12.1. mb_skip_coeff ............................................51
      12.2. Chroma Prediction ........................................51
      12.3. Luma Prediction ..........................................54
   13. DCT Coefficient Decoding ......................................60
      13.1. Macroblock without Non-Zero Coefficient Values ...........61
      13.2. Coding of Individual Coefficient Values ..................61
      13.3. Token Probabilities ......................................63
      13.4. Token Probability Updates ................................68
      13.5. Default Token Probability Table ..........................73
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................4
   2. Format Overview .................................................5
   3. Compressed Frame Types ..........................................7
   4. Overview of Compressed Data Format ..............................8
   5. Overview of the Decoding Process ................................9
   6. Description of Algorithms ......................................14
   7. Boolean Entropy Decoder ........................................16
      7.1. Underlying Theory of Coding ...............................17
      7.2. Practical Algorithm Description ...........................18
      7.3. Actual Implementation .....................................20
   8. Compressed Data Components .....................................25
      8.1. Tree Coding Implementation ................................27
      8.2. Tree Coding Example .......................................28
   9. Frame Header ...................................................30
      9.1. Uncompressed Data Chunk ...................................30
      9.2. Color Space and Pixel Type (Key Frames Only) ..............33
      9.3. Segment-Based Adjustments .................................34
      9.4. Loop Filter Type and Levels ...............................35
      9.5. Token Partition and Partition Data Offsets ................36
      9.6. Dequantization Indices ....................................37
      9.7. Refresh Golden Frame and Altref Frame .....................38
      9.8. Refresh Last Frame Buffer .................................39
      9.9. DCT Coefficient Probability Update ........................39
      9.10. Remaining Frame Header Data (Non-Key Frame) ..............40
      9.11. Remaining Frame Header Data (Key Frame) ..................41
   10. Segment-Based Feature Adjustments .............................41
   11. Key Frame Macroblock Prediction Records .......................42
      11.1. mb_skip_coeff ............................................42
      11.2. Luma Modes ...............................................42
      11.3. Subblock Mode Contexts ...................................45
      11.4. Chroma Modes .............................................46
      11.5. Subblock Mode Probability Table ..........................47
   12. Intraframe Prediction .........................................50
      12.1. mb_skip_coeff ............................................51
      12.2. Chroma Prediction ........................................51
      12.3. Luma Prediction ..........................................54
   13. DCT Coefficient Decoding ......................................60
      13.1. Macroblock without Non-Zero Coefficient Values ...........61
      13.2. Coding of Individual Coefficient Values ..................61
      13.3. Token Probabilities ......................................63
      13.4. Token Probability Updates ................................68
      13.5. Default Token Probability Table ..........................73
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   14. DCT and WHT Inversion and Macroblock Reconstruction ...........76
      14.1. Dequantization ...........................................76
      14.2. Inverse Transforms .......................................78
      14.3. Implementation of the WHT Inversion ......................78
      14.4. Implementation of the DCT Inversion ......................81
      14.5. Summation of Predictor and Residue .......................83
   15. Loop Filter ...................................................84
      15.1. Filter Geometry and Overall Procedure ....................85
      15.2. Simple Filter ............................................87
      15.3. Normal Filter ............................................91
      15.4. Calculation of Control Parameters ........................95
   16. Interframe Macroblock Prediction Records ......................97
      16.1. Intra-Predicted Macroblocks ..............................97
      16.2. Inter-Predicted Macroblocks ..............................98
      16.3. Mode and Motion Vector Contexts ..........................99
      16.4. Split Prediction ........................................105
   17. Motion Vector Decoding .......................................108
      17.1. Coding of Each Component ................................108
      17.2. Probability Updates .....................................110
   18. Interframe Prediction ........................................113
      18.1. Bounds on, and Adjustment of, Motion Vectors ............113
      18.2. Prediction Subblocks ....................................115
      18.3. Sub-Pixel Interpolation .................................115
      18.4. Filter Properties .......................................118
   19. Annex A: Bitstream Syntax ....................................120
      19.1. Uncompressed Data Chunk .................................121
      19.2. Frame Header ............................................122
      19.3. Macroblock Data .........................................130
   20. Attachment One: Reference Decoder Source Code ................133
      20.1. bit_ops.h ...............................................133
      20.2. bool_decoder.h ..........................................133
      20.3. dequant_data.h ..........................................137
      20.4. dixie.c .................................................138
      20.5. dixie.h .................................................151
      20.6. dixie_loopfilter.c ......................................158
      20.7. dixie_loopfilter.h ......................................170
      20.8. idct_add.c ..............................................171
      20.9. idct_add.h ..............................................174
      20.10. mem.h ..................................................175
      20.11. modemv.c ...............................................176
      20.12. modemv.h ...............................................192
      20.13. modemv_data.h ..........................................193
      20.14. predict.c ..............................................198
      20.15. predict.h ..............................................231
      20.16. tokens.c ...............................................232
      20.17. tokens.h ...............................................242
      20.18. vp8_prob_data.h ........................................243
      20.19. vpx_codec_internal.h ...................................252
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   14. DCT and WHT Inversion and Macroblock Reconstruction ...........76
      14.1. Dequantization ...........................................76
      14.2. Inverse Transforms .......................................78
      14.3. Implementation of the WHT Inversion ......................78
      14.4. Implementation of the DCT Inversion ......................81
      14.5. Summation of Predictor and Residue .......................83
   15. Loop Filter ...................................................84
      15.1. Filter Geometry and Overall Procedure ....................85
      15.2. Simple Filter ............................................87
      15.3. Normal Filter ............................................91
      15.4. Calculation of Control Parameters ........................95
   16. Interframe Macroblock Prediction Records ......................97
      16.1. Intra-Predicted Macroblocks ..............................97
      16.2. Inter-Predicted Macroblocks ..............................98
      16.3. Mode and Motion Vector Contexts ..........................99
      16.4. Split Prediction ........................................105
   17. Motion Vector Decoding .......................................108
      17.1. Coding of Each Component ................................108
      17.2. Probability Updates .....................................110
   18. Interframe Prediction ........................................113
      18.1. Bounds on, and Adjustment of, Motion Vectors ............113
      18.2. Prediction Subblocks ....................................115
      18.3. Sub-Pixel Interpolation .................................115
      18.4. Filter Properties .......................................118
   19. Annex A: Bitstream Syntax ....................................120
      19.1. Uncompressed Data Chunk .................................121
      19.2. Frame Header ............................................122
      19.3. Macroblock Data .........................................130
   20. Attachment One: Reference Decoder Source Code ................133
      20.1. bit_ops.h ...............................................133
      20.2. bool_decoder.h ..........................................133
      20.3. dequant_data.h ..........................................137
      20.4. dixie.c .................................................138
      20.5. dixie.h .................................................151
      20.6. dixie_loopfilter.c ......................................158
      20.7. dixie_loopfilter.h ......................................170
      20.8. idct_add.c ..............................................171
      20.9. idct_add.h ..............................................174
      20.10. mem.h ..................................................175
      20.11. modemv.c ...............................................176
      20.12. modemv.h ...............................................192
      20.13. modemv_data.h ..........................................193
      20.14. predict.c ..............................................198
      20.15. predict.h ..............................................231
      20.16. tokens.c ...............................................232
      20.17. tokens.h ...............................................242
      20.18. vp8_prob_data.h ........................................243
      20.19. vpx_codec_internal.h ...................................252
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
      20.20. vpx_decoder.h ..........................................263
      20.21. vpx_decoder_compat.h ...................................271
      20.22. vpx_image.c ............................................285
      20.23. vpx_image.h ............................................291
      20.24. vpx_integer.h ..........................................298
      20.25. AUTHORS File ...........................................299
      20.26. LICENSE ................................................301
      20.27. PATENTS ................................................302
   21. Security Considerations ......................................302
   22. References ...................................................303
      22.1. Normative Reference .....................................303
      22.2. Informative References ..................................303
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
      20.20. vpx_decoder.h ..........................................263
      20.21. vpx_decoder_compat.h ...................................271
      20.22. vpx_image.c ............................................285
      20.23. vpx_image.h ............................................291
      20.24. vpx_integer.h ..........................................298
      20.25. AUTHORS File ...........................................299
      20.26. LICENSE ................................................301
      20.27. PATENTS ................................................302
   21. Security Considerations ......................................302
   22. References ...................................................303
      22.1. Normative Reference .....................................303
      22.2. Informative References ..................................303
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes the VP8 compressed video data format, together with a discussion of the decoding procedure for the format. It is intended to be used in conjunction with, and as a guide to, the reference decoder source code provided in Attachment One (Section 20). If there are any conflicts between this narrative and the reference source code, the reference source code should be considered correct. The bitstream is defined by the reference source code and not this narrative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档介绍了VP8压缩视频数据格式，并讨论了该格式的解码过程。其旨在与附件1（第20节）中提供的参考解码器源代码结合使用，并作为指南。如果此叙述与参考源代码之间存在任何冲突，则应认为参考源代码是正确的。比特流由参考源代码定义，而不是此叙述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like many modern video compression schemes, VP8 is based on decomposition of frames into square subblocks of pixels, prediction of such subblocks using previously constructed blocks, and adjustment of such predictions (as well as synthesis of unpredicted blocks) using a discrete cosine transform (hereafter abbreviated as DCT). In one special case, however, VP8 uses a Walsh-Hadamard transform (hereafter abbreviated as WHT) instead of a DCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与许多现代视频压缩方案一样，VP8基于将帧分解为像素的方形子块、使用先前构造的块预测此类子块以及使用离散余弦变换（以下简称为DCT）调整此类预测（以及合成不可预测的块）。然而，在一种特殊情况下，VP8使用沃尔什-阿达玛变换（以下简称WHT）代替DCT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roughly speaking, such systems reduce datarate by exploiting the temporal and spatial coherence of most video signals. It is more efficient to specify the location of a visually similar portion of a prior frame than it is to specify pixel values. The frequency segregation provided by the DCT and WHT facilitates the exploitation of both spatial coherence in the original signal and the tolerance of the human visual system to moderate losses of fidelity in the reconstituted signal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
粗略地说，这样的系统通过利用大多数视频信号的时间和空间一致性来降低数据速率。指定前一帧的视觉相似部分的位置比指定像素值更有效。DCT和WHT提供的频率分离有助于利用原始信号中的空间相干性和人类视觉系统的容忍度，以缓和重建信号中的保真度损失。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 augments these basic concepts with, among other things, sophisticated usage of contextual probabilities. The result is a significant reduction in datarate at a given quality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8增加了这些基本概念，其中包括对上下文概率的复杂使用。结果是在给定质量下，数据速率显著降低。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike some similar schemes (the older MPEG formats, for example), VP8 specifies exact values for reconstructed pixels. Specifically, the specification for the DCT and WHT portions of the reconstruction does not allow for any &#34;drift&#34; caused by truncation of fractions. Rather, the algorithm is specified using fixed-precision integer operations exclusively. This greatly facilitates the verification of the correctness of a decoder implementation and also avoids difficult-to-predict visual incongruities between such implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与一些类似的方案（例如，较旧的MPEG格式）不同，VP8为重建像素指定精确的值。具体而言，重构的DCT和WHT部分的规范不允许由分数截断引起的任何“漂移”。相反，该算法是专门使用固定精度整数运算指定的。这大大有助于验证解码器实现的正确性，还避免了此类实现之间难以预测的视觉不一致。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be remarked that, in a complete video playback system, the displayed frames may or may not be identical to the reconstructed frames. Many systems apply a final level of filtering (commonly referred to as postprocessing) to the reconstructed frames prior to viewing. Such postprocessing has no effect on the decoding and reconstruction of subsequent frames (which are predicted using the completely specified reconstructed frames) and is beyond the scope of this document. In practice, the nature and extent of this sort of postprocessing is dependent on both the taste of the user and on the computational facilities of the playback environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应当注意，在完整的视频回放系统中，显示的帧可能与重构的帧相同，也可能与重构的帧不同。许多系统在观看之前对重建的帧应用最终级别的过滤（通常称为后处理）。这种后处理对后续帧（使用完全指定的重构帧预测）的解码和重构没有影响，并且超出了本文档的范围。实际上，这种后处理的性质和程度取决于用户的喜好和回放环境的计算设施。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照RFC 2119[RFC2119]中所述进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Format Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 格式概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 works exclusively with an 8-bit YUV 4:2:0 image format. In this format, each 8-bit pixel in the two chroma planes (U and V) corresponds positionally to a 2x2 block of 8-bit luma pixels in the Y plane; coordinates of the upper left corner of the Y block are of course exactly twice the coordinates of the corresponding chroma pixels. When we refer to pixels or pixel distances without specifying a plane, we are implicitly referring to the Y plane or to the complete image, both of which have the same (full) resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8专用于8位YUV 4:2:0图像格式。在该格式中，两个色度平面（U和V）中的每个8位像素在位置上对应于Y平面中的8位luma像素的2x2块；Y块左上角的坐标当然是相应色度像素坐标的两倍。当我们在不指定平面的情况下引用像素或像素距离时，我们暗指的是Y平面或完整图像，两者具有相同的（完整）分辨率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As is usually the case, the pixels are simply a large array of bytes stored in rows from top to bottom, each row being stored from left to right. This &#34;left to right&#34; then &#34;top to bottom&#34; raster-scan order is reflected in the layout of the compressed data as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常情况下，像素只是从上到下按行存储的一个大字节数组，每行从左到右存储。这种“从左到右”然后“从上到下”的光栅扫描顺序也反映在压缩数据的布局中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Provision has been made in the VP8 bitstream header for the support of a secondary YUV color format, in the form of a reserved bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8比特流报头中已规定以保留位的形式支持辅助YUV颜色格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Occasionally, at very low datarates, a compression system may decide to reduce the resolution of the input signal to facilitate efficient compression. The VP8 data format supports this via optional upscaling of its internal reconstruction buffer prior to output (this
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有时，在非常低的数据速率下，压缩系统可能会决定降低输入信号的分辨率，以促进高效压缩。VP8数据格式通过在输出之前可选地放大其内部重建缓冲区（此
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is completely distinct from the optional postprocessing discussed earlier, which has nothing to do with decoding per se). This upsampling restores the video frames to their original resolution. In other words, the compression/decompression system can be viewed as a &#34;black box&#34;, where the input and output are always at a given resolution. The compressor might decide to &#34;cheat&#34; and process the signal at a lower resolution. In that case, the decompressor needs the ability to restore the signal to its original resolution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与前面讨论的可选后处理完全不同，后者与解码本身无关）。此上采样将视频帧恢复为其原始分辨率。换句话说，压缩/解压缩系统可以被视为一个“黑匣子”，其中输入和输出总是以给定的分辨率。压缩机可能决定“欺骗”并以较低的分辨率处理信号。在这种情况下，解压器需要能够将信号恢复到其原始分辨率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internally, VP8 decomposes each output frame into an array of macroblocks. A macroblock is a square array of pixels whose Y dimensions are 16x16 and whose U and V dimensions are 8x8. Macroblock-level data in a compressed frame occurs (and must be processed) in a raster order similar to that of the pixels comprising the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在内部，VP8将每个输出帧分解为宏块数组。宏块是Y尺寸为16x16、U和V尺寸为8x8的正方形像素阵列。压缩帧中的宏块级数据以与构成帧的像素的光栅顺序相似的光栅顺序出现（并且必须进行处理）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Macroblocks are further decomposed into 4x4 subblocks. Every macroblock has 16 Y subblocks, 4 U subblocks, and 4 V subblocks. Any subblock-level data (and processing of such data) again occurs in raster order, this time in raster order within the containing macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏块进一步分解为4x4子块。每个宏块有16个Y子块、4个U子块和4个V子块。任何子块级数据（以及对此类数据的处理）再次以光栅顺序出现，这一次是在包含宏块内以光栅顺序出现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in further detail below, data can be specified at the levels of both macroblocks and their subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如下文进一步详细讨论的，可以在宏块及其子块的级别指定数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pixels are always treated, at a minimum, at the level of subblocks, which may be thought of as the &#34;atoms&#34; of the VP8 algorithm. In particular, the 2x2 chroma blocks corresponding to 4x4 Y subblocks are never treated explicitly in the data format or in the algorithm specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
像素总是至少在子块级别上处理，这可能被认为是VP8算法的“原子”。特别是，与4x4 Y子块相对应的2x2色度块从未在数据格式或算法规范中明确处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCT and WHT always operate at a 4x4 resolution. The DCT is used for the 16Y, 4U, and 4V subblocks. The WHT is used (with some but not all prediction modes) to encode a 4x4 array comprising the average intensities of the 16 Y subblocks of a macroblock. These average intensities are, up to a constant normalization factor, nothing more than the 0th DCT coefficients of the Y subblocks. This &#34;higher-level&#34; WHT is a substitute for the explicit specification of those coefficients, in exactly the same way as the DCT of a subblock substitutes for the specification of the pixel values comprising the subblock. We consider this 4x4 array as a second-order subblock called Y2, and think of a macroblock as containing 24 &#34;real&#34; subblocks and, sometimes, a 25th &#34;virtual&#34; subblock. This is dealt with further in Section 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCT和WHT始终以4x4分辨率运行。DCT用于16Y、4U和4V子块。WHT（与一些但不是所有预测模式一起）用于编码4x4阵列，该4x4阵列包括宏块的16个Y子块的平均强度。这些平均强度，直到一个恒定的归一化因子，只不过是Y子块的第0个DCT系数。该“更高级别”WHT是这些系数的显式规范的替代，其方式与子块的DCT替代包含子块的像素值的规范的方式完全相同。我们认为这个4x4数组是一个称为Y2的二阶子块，并认为宏块包含24个“真实”子块，有时也有第二十五个“虚拟”子块。这将在第13节中进一步讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The frame layout used by the reference decoder may be found in the file vpx_image.h (Section 20.23).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考解码器使用的帧布局可在文件vpx_image.h（第20.23节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Compressed Frame Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 压缩帧类型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are only two types of frames in VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8中只有两种类型的帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intraframes (also called key frames and, in MPEG terminology, I-frames) are decoded without reference to any other frame in a sequence; that is, the decompressor reconstructs such frames beginning from its &#34;default&#34; state. Key frames provide random access (or seeking) points in a video stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧内帧（也称为关键帧，在MPEG术语中称为I帧）在不参考序列中的任何其他帧的情况下被解码；也就是说，解压器从其“默认”状态开始重构这样的帧。关键帧提供视频流中的随机访问（或搜索）点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interframes (also called prediction frames and, in MPEG terminology, P-frames) are encoded with reference to prior frames, specifically all prior frames up to and including the most recent key frame. Generally speaking, the correct decoding of an interframe depends on the correct decoding of the most recent key frame and all ensuing frames. Consequently, the decoding algorithm is not tolerant of dropped frames: In an environment in which frames may be dropped or corrupted, correct decoding will not be possible until a key frame is correctly received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧间（也称为预测帧，在MPEG术语中称为P帧）参照先前帧进行编码，具体地说，参照直到并包括最近关键帧的所有先前帧。一般来说，帧间的正确解码取决于最近的关键帧和所有后续帧的正确解码。因此，解码算法不能容忍丢弃的帧：在帧可能被丢弃或损坏的环境中，在正确接收到关键帧之前，不可能进行正确解码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In contrast to MPEG, there is no use of bidirectional prediction. No frame is predicted using frames temporally subsequent to it; there is no analog to an MPEG B-frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与MPEG相比，不使用双向预测。没有帧是使用在其之后的帧来预测的；不存在与MPEG B帧的模拟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Secondly, VP8 augments these notions with that of alternate prediction frames, called golden frames and altref frames (alternative reference frames). Blocks in an interframe may be predicted using blocks in the immediately previous frame as well as the most recent golden frame or altref frame. Every key frame is automatically golden and altref, and any interframe may optionally replace the most recent golden or altref frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二，VP8用交替预测帧（称为golden帧和altref帧（交替参考帧））来增强这些概念。可以使用前一帧中的块以及最近的黄金帧或altref帧中的块来预测帧间中的块。每个关键帧自动为golden和altref，任何帧间帧都可以选择替换最近的golden或altref帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Golden frames and altref frames may also be used to partially overcome the intolerance to dropped frames discussed above: If a compressor is configured to code golden frames only with reference to the prior golden frame (and key frame), then the &#34;substream&#34; of key and golden frames may be decoded regardless of loss of other interframes. Roughly speaking, the implementation requires (on the compressor side) that golden frames subsume and recode any context updates effected by the intervening interframes. A typical application of this approach is video conferencing, in which retransmission of a prior golden frame and/or a delay in playback until receipt of the next golden frame is preferable to a larger retransmit and/or delay until the next key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
黄金帧和altref帧也可用于部分克服对上述丢弃帧的不容忍：如果压缩器被配置为仅参考先前的黄金帧（和关键帧）对黄金帧进行编码，则可以解码关键帧和黄金帧的“子流”，而不考虑其他帧间的丢失。粗略地说，实现要求（在压缩器端）黄金帧包含并重新编码由中间帧影响的任何上下文更新。该方法的典型应用是视频会议，其中，与更大的重发和/或直到下一关键帧的延迟相比，优选先前黄金帧的重发和/或直到接收到下一黄金帧的回放延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Overview of Compressed Data Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 压缩数据格式概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to a VP8 decoder is a sequence of compressed frames whose order matches their order in time. Issues such as the duration of frames, the corresponding audio, and synchronization are generally provided by the playback environment and are irrelevant to the decoding process itself; however, to aid in fast seeking, a start code is included in the header of each key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8解码器的输入是一个压缩帧序列，其顺序与其时间顺序相匹配。帧的持续时间、相应的音频和同步等问题通常由回放环境提供，与解码过程本身无关；但是，为了帮助快速查找，每个关键帧的标头中都包含一个开始代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder is simply presented with a sequence of compressed frames and produces a sequence of decompressed (reconstructed) YUV frames corresponding to the input sequence. As stated in the Introduction, the exact pixel values in the reconstructed frame are part of VP8&#39;s specification. This document specifies the layout of the compressed frames and gives unambiguous algorithms for the correct production of reconstructed frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码器简单地呈现压缩帧序列，并产生与输入序列对应的解压缩（重构）YUV帧序列。如引言中所述，重建帧中的精确像素值是VP8规范的一部分。本文件规定了压缩帧的布局，并给出了正确生成重建帧的明确算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first frame presented to the decompressor is of course a key frame. This may be followed by any number of interframes; the correct reconstruction of each frame depends on all prior frames up to the key frame. The next key frame restarts this process: The decompressor resets to its default initial condition upon reception of a key frame, and the decoding of a key frame (and its ensuing interframes) is completely independent of any prior decoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
呈现给解压器的第一帧当然是关键帧。这之后可以是任意数量的帧；每个帧的正确重建取决于关键帧之前的所有帧。下一个关键帧重新启动该过程：解压器在接收到关键帧时重置为其默认初始条件，并且关键帧（及其随后的帧间）的解码完全独立于任何先前的解码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the highest level, every compressed frame has three or more pieces. It begins with an uncompressed data chunk comprising 10 bytes in the case of key frames and 3 bytes for interframes. This is followed by two or more blocks of compressed data (called partitions). These compressed data partitions begin and end on byte boundaries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在最高级别，每个压缩帧都有三个或更多的片段。它从一个未压缩的数据块开始，对于关键帧，它包含10个字节，对于帧间帧，它包含3个字节。然后是两个或多个压缩数据块（称为分区）。这些压缩数据分区在字节边界上开始和结束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first compressed partition has two subsections:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第一个压缩分区有两个子部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Header information that applies to the frame as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 应用于整个帧的标题信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Per-macroblock information specifying how each macroblock is predicted from the already-reconstructed data that is available to the decompressor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 每个宏块信息，指定如何从解压缩器可用的已重构数据预测每个宏块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated above, the macroblock-level information occurs in raster-scan order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述，宏块级信息以光栅扫描顺序出现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of the partitions contain, for each block, the DCT/WHT coefficients (quantized and logically compressed) of the residue signal to be added to the predicted block values. It typically accounts for roughly 70% of the overall datarate. VP8 supports packing the compressed DCT/WHT coefficients&#39; data from macroblock
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个块，其余分区包含要添加到预测块值的剩余信号的DCT/WHT系数（量化和逻辑压缩）。它通常约占总数据速率的70%。VP8支持从宏块打包压缩的DCT/WHT系数数据
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rows into separate partitions. If there is more than one partition for these coefficients, the sizes of the partitions -- except the last partition -- in bytes are also present in the bitstream right after the above first partition. Each of the sizes is a 3-byte data item written in little endian format. These sizes provide the decoder direct access to all DCT/WHT coefficient partitions, which enables parallel processing of the coefficients in a decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将行划分为单独的分区。如果这些系数有多个分区，则分区的大小（最后一个分区除外）以字节为单位也会出现在上述第一个分区之后的比特流中。每个大小都是一个以little endian格式编写的3字节数据项。这些大小为解码器提供了对所有DCT/WHT系数分区的直接访问，从而实现了解码器中系数的并行处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The separate partitioning of the prediction data and coefficient data also allows flexibility in the implementation of a decompressor: An implementation may decode and store the prediction information for the whole frame and then decode, transform, and add the residue signal to the entire frame, or it may simultaneously decode both partitions, calculating prediction information and adding in the residue signal for each block in order. The length field in the frame tag, which allows decoding of the second partition to begin before the first partition has been completely decoded, is necessary for the second &#34;block-at-a-time&#34; decoder implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
预测数据和系数数据的单独分区还允许在解压器的实现中具有灵活性：实现可以解码和存储整个帧的预测信息，然后解码、变换并将剩余信号添加到整个帧，或者可以同时解码两个分区，计算预测信息并按顺序加入每个块的剩余信号。帧标签中的长度字段允许在第一分区被完全解码之前开始第二分区的解码，对于第二“一次分块”解码器实现是必需的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All partitions are decoded using separate instances of the boolean entropy decoder described in Section 7. Although some of the data represented within the partitions is conceptually &#34;flat&#34; (a bit is just a bit with no probabilistic expectation one way or the other), because of the way such coders work, there is never a direct correspondence between a &#34;conceptual bit&#34; and an actual physical bit in the compressed data partitions. Only in the 3- or 10-byte uncompressed chunk described above is there such a physical correspondence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用第7节中描述的布尔熵解码器的单独实例对所有分区进行解码。尽管分区中表示的一些数据在概念上是“平坦的”（一个位只是一个没有概率期望的位），但由于这种编码器的工作方式，“概念位”和压缩数据分区中的实际物理位之间从来没有直接对应关系。只有在上面描述的3字节或10字节未压缩块中才存在这样的物理对应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A related matter is that seeking within a partition is not supported. The data must be decompressed and processed (or at least stored) in the order in which it occurs in the partition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个相关的问题是不支持在分区内进行查找。数据必须按照其在分区中出现的顺序进行解压缩和处理（或至少存储）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While this document specifies the ordering of the partition data correctly, the details and semantics of this data are discussed in a more logical fashion to facilitate comprehension. For example, the frame header contains updates to many probability tables used in decoding per-macroblock data. The per-macroblock data is often described before the layouts of the probabilities and their updates, even though this is the opposite of their order in the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然本文档正确地指定了分区数据的顺序，但以更符合逻辑的方式讨论了该数据的细节和语义，以便于理解。例如，帧报头包含对解码每个宏块数据时使用的许多概率表的更新。每宏块数据通常在概率及其更新的布局之前描述，即使这与它们在比特流中的顺序相反。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Overview of the Decoding Process
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 解码过程概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A VP8 decoder needs to maintain four YUV frame buffers whose resolutions are at least equal to that of the encoded image. These buffers hold the current frame being reconstructed, the immediately previous reconstructed frame, the most recent golden frame, and the most recent altref frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8解码器需要保持四个YUV帧缓冲区，其分辨率至少等于编码图像的分辨率。这些缓冲区保存正在重建的当前帧、上一个重建帧、最近的黄金帧和最近的altref帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most implementations will wish to &#34;pad&#34; these buffers with &#34;invisible&#34; pixels that extend a moderate number of pixels beyond all four edges of the visible image. This simplifies interframe prediction by allowing all (or most) prediction blocks -- which are not guaranteed to lie within the visible area of a prior frame -- to address usable image data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大多数实现都希望用“不可见”像素“填充”这些缓冲区，这些像素将适度数量的像素扩展到可见图像的所有四个边缘之外。这通过允许所有（或大部分）预测块（不保证位于前一帧的可见区域内）寻址可用图像数据来简化帧间预测。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the amount of padding chosen, the invisible rows above (or below) the image are filled with copies of the top (or bottom) row of the image; the invisible columns to the left (or right) of the image are filled with copies of the leftmost (or rightmost) visible row; and the four invisible corners are filled with copies of the corresponding visible corner pixels. The use of these prediction buffers (and suggested sizes for the halo) will be elaborated on in the discussion of motion vectors, interframe prediction, and sub-pixel interpolation later in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论选择了多少填充，图像上方（或下方）的不可见行都会填充图像顶部（或底部）行的副本；图像左侧（或右侧）的不可见列由最左侧（或最右侧）可见行的副本填充；四个不可见角被相应可见角像素的副本填充。这些预测缓冲区（以及光晕的建议大小）的使用将在本文后面的运动矢量、帧间预测和亚像素插值讨论中详细说明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As will be seen in the description of the frame header, the image dimensions are specified (and can change) with every key frame. These buffers (and any other data structures whose size depends on the size of the image) should be allocated (or re-allocated) immediately after the dimensions are decoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从帧标题的描述中可以看出，图像尺寸随每个关键帧而指定（并且可以更改）。这些缓冲区（以及大小取决于图像大小的任何其他数据结构）应在尺寸解码后立即分配（或重新分配）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Leaving most of the details for later elaboration, the following is an outline of the decoding process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面是解码过程的概要，将大部分细节留给以后的详细阐述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, the frame header (the beginning of the first data partition) is decoded. Altering or augmenting the maintained state of the decoder, this provides the context in which the per-macroblock data can be interpreted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
首先，对帧头（第一数据分区的开始）进行解码。改变或增加解码器的保持状态，这提供了可以解释每宏块数据的上下文。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macroblock data occurs (and must be processed) in raster-scan order. This data comes in two or more parts. The first (prediction or mode) part comes in the remainder of the first data partition. The other parts comprise the data partition(s) for the DCT/WHT coefficients of the residue signal. For each macroblock, the prediction data must be processed before the residue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏块数据以光栅扫描顺序出现（并且必须进行处理）。这些数据分为两部分或更多部分。第一部分（预测或模式）位于第一个数据分区的剩余部分。其他部分包括剩余信号的DCT/WHT系数的数据分区。对于每个宏块，预测数据必须在剩余之前进行处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each macroblock is predicted using one (and only one) of four possible frames. All macroblocks in a key frame, and all intra-coded macroblocks in an interframe, are predicted using the already-decoded macroblocks in the current frame. Macroblocks in an interframe may also be predicted using the previous frame, the golden frame, or the altref frame. Such macroblocks are said to be inter-coded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用四个可能帧中的一个（且仅一个）预测每个宏块。使用当前帧中已解码的宏块预测关键帧中的所有宏块以及帧间中的所有帧内编码宏块。帧间宏块也可以使用前一帧、黄金帧或altref帧来预测。这种宏块被称为是帧间编码的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of prediction is to use already-constructed image data to approximate the portion of the original image being reconstructed. The effect of any of the prediction modes is then to write a macroblock-sized prediction buffer containing this approximation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
预测的目的是使用已经构造的图像数据来近似原始图像的被重建部分。然后，任何预测模式的效果都是写入包含该近似值的宏块大小的预测缓冲区。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the prediction method, the residue DCT signal is decoded, dequantized, reverse-transformed, and added to the prediction buffer to produce the (almost final) reconstruction value of the macroblock, which is stored in the correct position of the current frame buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论采用何种预测方法，残余DCT信号都将被解码、去量化、反向变换并添加到预测缓冲器中，以产生宏块的（几乎最终）重建值，该重建值存储在当前帧缓冲器的正确位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The residue signal consists of 24 (sixteen Y, four U, and four V) 4x4 quantized and losslessly compressed DCT transforms approximating the difference between the original macroblock in the uncompressed source and the prediction buffer. For most prediction modes, the 0th coefficients of the sixteen Y subblocks are expressed via a 25th WHT of the second-order virtual Y2 subblock discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
残余信号由24（16个Y、4个U和4个V）4x4量化和无损压缩DCT变换组成，近似于未压缩源和预测缓冲器中原始宏块之间的差值。对于大多数预测模式，十六个Y子块的第0个系数通过上面讨论的二阶虚拟Y2子块的第25个WHT表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intra-prediction exploits the spatial coherence of frames. The 16x16 luma (Y) and 8x8 chroma (UV) components are predicted independently of each other using one of four simple means of pixel propagation, starting from the already-reconstructed (16-pixel-long luma, 8-pixel-long chroma) row above, and column to the left of, the current macroblock. The four methods are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧内预测利用帧的空间相干性。16x16亮度（Y）和8x8色度（UV）分量通过四种简单的像素传播方式中的一种相互独立地进行预测，从当前宏块上方已重建的（16像素长亮度，8像素长色度）行和左侧的列开始。这四种方法是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Copying the row from above throughout the prediction buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 在整个预测缓冲区中从上面复制行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Copying the column from the left throughout the prediction buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 在整个预测缓冲区中从左侧复制列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Copying the average value of the row and column throughout the prediction buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 在整个预测缓冲区中复制行和列的平均值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Extrapolation from the row and column using the (fixed) second difference (horizontal and vertical) from the upper left corner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 使用左上角的（固定）第二个差（水平和垂直）从行和列进行外推。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, the sixteen Y subblocks may be predicted independently of each other using one of ten different modes, four of which are 4x4 analogs of those described above, augmented with six &#34;diagonal&#34; prediction methods. There are two types of predictions, one intra and one prediction (among all the modes), for which the residue signal does not use the Y2 block to encode the DC portion of the sixteen 4x4 Y subblock DCTs. This &#34;independent Y subblock&#34; mode has no effect on the 8x8 chroma prediction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，可以使用十种不同模式中的一种彼此独立地预测十六个Y子块，其中四种是用六种“对角”预测方法增强的上述模式的4x4类似物。存在两种类型的预测，一种是帧内预测，另一种是预测（在所有模式中），对于这两种预测，剩余信号不使用Y2块来编码16个4x4y子块dct的DC部分。此“独立Y子块”模式对8x8色度预测没有影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inter-prediction exploits the temporal coherence between nearby frames. Except for the choice of the prediction frame itself, there is no difference between inter-prediction based on the previous frame and that based on the golden frame or altref frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧间预测利用相邻帧之间的时间相关性。除了选择预测帧本身之外，基于前一帧的帧间预测与基于黄金帧或altref帧的帧间预测之间没有区别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inter-prediction is conceptually very simple. While, for reasons of efficiency, there are several methods of encoding the relationship between the current macroblock and corresponding sections of the prediction frame, ultimately each of the sixteen Y subblocks is related to a 4x4 subblock of the prediction frame, whose position in that frame differs from the current subblock position by a (usually small) displacement. These two-dimensional displacements are called motion vectors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧间预测在概念上非常简单。然而，出于效率的原因，存在几种编码当前宏块和预测帧的对应部分之间的关系的方法，最终十六个Y子块中的每一个与预测帧的4x4子块相关，其在该帧中的位置与当前子块位置相差一倍（通常很小）位移。这些二维位移称为运动矢量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The motion vectors used by VP8 have quarter-pixel precision. Prediction of a subblock using a motion vector that happens to have integer (whole number) components is very easy: The 4x4 block of pixels from the displaced block in the previous, golden, or altref frame is simply copied into the correct position of the current macroblock&#39;s prediction buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8使用的运动矢量具有四分之一像素精度。使用恰好具有整数（整数）分量的运动向量预测子块非常容易：将前一帧、golden帧或altref帧中位移块的4x4像素块复制到当前宏块预测缓冲区的正确位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fractional displacements are conceptually and implementationally more complex. They require the inference (or synthesis) of sample values that, strictly speaking, do not exist. This is one of the most basic problems in signal processing, and readers conversant with that subject will see that the approach taken by VP8 provides a good balance of robustness, accuracy, and efficiency.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分数位移在概念上和实施上更为复杂。它们需要推断（或合成）严格来说不存在的样本值。这是信号处理中最基本的问题之一，熟悉该主题的读者将看到VP8所采用的方法在稳健性、准确性和效率之间提供了良好的平衡。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Leaving the details for the implementation discussion below, the pixel interpolation is calculated by applying a kernel filter (using reasonable-precision integer math) three pixels on either side, both horizontally and vertically, of the pixel to be synthesized. The resulting 4x4 block of synthetic pixels is then copied into position exactly as in the case of integer displacements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将细节留给下面的实现讨论，通过在要合成的像素的任意一侧（水平和垂直）应用内核滤波器（使用合理精度的整数数学）三个像素来计算像素插值。然后，生成的4x4合成像素块被复制到与整数位移完全相同的位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the eight chroma subblocks is handled similarly. Their motion vectors are never specified explicitly; instead, the motion vector for each chroma subblock is calculated by averaging the vectors of the four Y subblocks that occupy the same area of the frame. Since chroma pixels have twice the diameter (and four times the area) of luma pixels, the calculated chroma motion vectors have 1/8-pixel resolution, but the procedure for copying or generating pixels for each subblock is essentially identical to that done in the luma plane.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
八个色度子块中的每一个都以类似方式处理。它们的运动矢量从未明确指定；相反，通过平均占据帧的相同区域的四个Y子块的向量来计算每个色度子块的运动向量。由于色度像素的直径是亮度像素的两倍（面积的四倍），因此计算出的色度运动矢量具有1/8像素的分辨率，但用于复制或生成每个子块的像素的过程基本上与在亮度平面中完成的过程相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After all the macroblocks have been generated (predicted and corrected with the DCT/WHT residue), a filtering step (the loop filter) is applied to the entire frame. The purpose of the loop filter is to reduce blocking artifacts at the boundaries between macroblocks and between subblocks of the macroblocks. The term &#34;loop filter&#34; is used because this filter is part of the &#34;coding loop&#34;; that is, it affects the reconstructed frame buffers that are used to predict ensuing frames. This is distinguished from the postprocessing filters discussed earlier, which affect only the viewed video and do not &#34;feed into&#34; subsequent frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在生成所有宏块（使用DCT/WHT残差预测和校正）之后，对整个帧应用滤波步骤（循环滤波器）。循环滤波器的目的是减少宏块之间和宏块的子块之间的边界处的块伪影。使用术语“环路滤波器”是因为该滤波器是“编码环路”的一部分；也就是说，它影响用于预测后续帧的重构帧缓冲区。这与前面讨论的后处理过滤器不同，后者只影响观看的视频，不会“馈送”到后续帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Next, if signaled in the data, the current frame may replace the golden frame prediction buffer and/or the altref frame buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接下来，如果在数据中发信号，则当前帧可以替换黄金帧预测缓冲器和/或altref帧缓冲器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The halos of the frame buffers are next filled as specified above. Finally, at least as far as decoding is concerned, the (references to) the &#34;current&#34; and &#34;last&#34; frame buffers should be exchanged in preparation for the next frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧缓冲区的光晕将按上述规定填充。最后，至少就解码而言，（对）“当前”和“最后”帧缓冲器的引用）应交换以准备下一帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Various processes may be required (or desired) before viewing the generated frame. As discussed in the frame dimension information below, truncation and/or upscaling of the frame may be required. Some playback systems may require a different frame format (RGB, YUY2, etc.). Finally, as mentioned in the Introduction, further postprocessing or filtering of the image prior to viewing may be desired. Since the primary purpose of this document is a decoding specification, the postprocessing is not specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在查看生成的帧之前，可能需要（或期望）各种过程。如下文框架尺寸信息中所述，可能需要对框架进行截断和/或放大。某些播放系统可能需要不同的帧格式（RGB、YUY2等）。最后，如引言中所述，可能需要在观看之前对图像进行进一步的后处理或滤波。由于本文件的主要目的是解码规范，因此本文件未规定后处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the basic ideas of prediction and correction used by VP8 are straightforward, many of the details are quite complex. The management of probabilities is particularly elaborate. Not only do the various modes of intra-prediction and motion vector specification have associated probabilities, but they, together with the coding of DCT coefficients and motion vectors, often base these probabilities on a variety of contextual information (calculated from what has been decoded so far), as well as on explicit modification via the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然VP8使用的预测和校正的基本思想很简单，但许多细节相当复杂。概率的管理尤其复杂。帧内预测和运动向量规范的各种模式不仅具有相关的概率，而且它们与DCT系数和运动向量的编码一起，通常将这些概率基于各种上下文信息（根据迄今为止解码的内容计算），以及通过帧头进行显式修改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;top-level&#34; of decoding and frame reconstruction is implemented in the reference decoder file dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码和帧重建的“顶层”在参考解码器文件dixie.c（第20.4节）中实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This concludes our summary of decoding and reconstruction; we continue by discussing the individual aspects in more depth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是我们对解码和重构的总结；我们继续更深入地讨论各个方面。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reasonable &#34;divide and conquer&#34; approach to implementation of a decoder is to begin by decoding streams composed exclusively of key frames. After that works reliably, interframe handling can be added more easily than if complete functionality were attempted
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现解码器的一种合理的“分而治之”方法是首先对仅由关键帧组成的流进行解码。在这项工作可靠之后，与尝试完整功能相比，可以更轻松地添加帧间处理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
immediately. In accordance with this, we first discuss components needed to decode key frames (most of which are also used in the decoding of interframes) and conclude with topics exclusive to interframes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
立即根据这一点，我们首先讨论解码关键帧所需的组件（其中大部分也用于帧间解码），并以帧间专有的主题结束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Description of Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 算法描述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the intent of this document, together with the reference decoder source code, is to specify a platform-independent procedure for the decoding and reconstruction of a VP8 video stream, many (small) algorithms must be described exactly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于本文件以及参考解码器源代码的目的是为VP8视频流的解码和重建指定独立于平台的过程，因此必须准确描述许多（小型）算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to its near-universality, terseness, ability to easily describe calculation at specific precisions, and the fact that On2&#39;s reference VP8 decoder is written in C, these algorithm fragments are written using the C programming language, augmented with a few simple definitions below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于其接近通用性、简洁性、能够在特定精度下轻松描述计算，以及On2的参考VP8解码器是用C编写的事实，这些算法片段使用C编程语言编写，并在下面添加了一些简单的定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The standard (and best) reference for C is [Kernighan].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
C的标准（也是最好的）参考是[Kernighan]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many code fragments will be presented in this document. Some will be nearly identical to corresponding sections of the reference decoder; others will differ. Roughly speaking, there are three reasons for such differences:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文将介绍许多代码片段。有些将与参考解码器的相应部分几乎相同；其他人则会有所不同。大致来说，造成这种差异的原因有三个：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. For reasons of efficiency, the reference decoder version may be less obvious.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 出于效率原因，参考解码器版本可能不太明显。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The reference decoder often uses large data structures to maintain context that need not be described or used here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 参考解码器通常使用大型数据结构来维护此处不需要描述或使用的上下文。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The authors of this document felt that a different expression of the same algorithm might facilitate exposition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 本文作者认为，同一算法的不同表达式可能有助于阐述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the chosen presentation, the calculation effected by any of the algorithms described here is identical to that effected by the corresponding portion of the reference decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不管所选择的呈现方式如何，由本文描述的任何算法影响的计算与由参考解码器的相应部分影响的计算相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All VP8 decoding algorithms use integer math. To facilitate specification of arithmetic precision, we define the following types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有VP8解码算法都使用整数数学。为了便于指定算术精度，我们定义了以下类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef   signed char  int8; /* signed int exactly 8 bits wide */
   typedef unsigned char uint8; /* unsigned &#34;&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef   signed char  int8; /* signed int exactly 8 bits wide */
   typedef unsigned char uint8; /* unsigned &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef short int16;         /* signed int exactly 16 bits wide */
   typedef unsigned int16 uint16; /* unsigned &#34;&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef short int16;         /* signed int exactly 16 bits wide */
   typedef unsigned int16 uint16; /* unsigned &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* int32 is a signed integer type at least 32 bits wide */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* int32 is a signed integer type at least 32 bits wide */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef long int32; /* guaranteed to work on all systems */
   typedef int  int32; /* will be more efficient on some systems */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef long int32; /* guaranteed to work on all systems */
   typedef int  int32; /* will be more efficient on some systems */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef unsigned int32 uint32;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef无符号int32 uint32；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* unsigned integer type, at least 16 bits wide, whose exact size
      is most convenient to whatever processor we are using */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* unsigned integer type, at least 16 bits wide, whose exact size
      is most convenient to whatever processor we are using */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef unsigned int uint;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef无符号整数单元；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* While pixels themselves are 8-bit unsigned integers,
      pixel arithmetic often occurs at 16- or 32-bit precision and
      the results need to be &#34;saturated&#34; or clamped to an 8-bit
      range. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* While pixels themselves are 8-bit unsigned integers,
      pixel arithmetic often occurs at 16- or 32-bit precision and
      the results need to be &#34;saturated&#34; or clamped to an 8-bit
      range. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint8 Pixel;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint8像素；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel clamp255(int32 v) { return v &lt; 0? 0 : (v &lt; 255? v : 255);}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel clamp255(int32 v) { return v &lt; 0? 0 : (v &lt; 255? v : 255);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*  As is elaborated in the discussion of the bool_decoder below,
       VP8 represents probabilities as unsigned 8-bit numbers. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*  As is elaborated in the discussion of the bool_decoder below,
       VP8 represents probabilities as unsigned 8-bit numbers. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint8 Prob;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef uint8 Prob；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We occasionally need to discuss mathematical functions involving honest-to-goodness &#34;infinite precision&#34; real numbers. The DCT is first described via the cosine function cos; the ratio of the lengths of the circumference and diameter of a circle is denoted pi; at one point, we take a (base 1/2) logarithm, denoted log; and pow(x, y) denotes x raised to the power y. If x = 2 and y is a small non-negative integer, pow(2, y) may be expressed in C as 1 &lt;&lt; y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们偶尔需要讨论涉及诚实到善良的“无限精度”实数的数学函数。首先通过余弦函数cos描述DCT；圆周长度与圆直径之比表示为pi；在某一点上，我们取（以1/2为底）对数，表示为log；pow（x，y）表示x升到y的幂。如果x=2且y是一个小的非负整数，则pow（2，y）可以用C表示为1&lt;&lt;y。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we sometimes need to divide signed integers by powers of two; that is, we occasionally right-shift signed numbers. The behavior of such shifts (i.e., the propagation of the sign bit) is, perhaps surprisingly, not defined by the C language itself and is left up to individual compilers. Because of the utility of this frequently needed operation, it is at least arguable that it should be defined by the language (to naturally propagate the sign bit) and, at a minimum, should be correctly implemented by any reasonable compiler. In the interest of strict portability, we attempt to call attention to these shifts when they arise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，我们有时需要将有符号整数除以二的幂；也就是说，我们偶尔会右移有符号的数字。这种移位的行为（即符号位的传播）可能令人惊讶地不是由C语言本身定义的，而是由单个编译器决定的。由于这种经常需要的操作的实用性，它至少应该由语言定义（自然传播符号位），并且至少应该由任何合理的编译器正确实现。为了严格的可移植性，我们试图在出现这些变化时提请注意。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Boolean Entropy Decoder
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 布尔熵译码器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in the overview above, essentially the entire VP8 data stream is encoded using a boolean entropy coder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正如上面概述中所讨论的，整个VP8数据流基本上是使用布尔熵编码器编码的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An understanding of the bool_decoder is critical to the implementation of a VP8 decompressor, so we discuss the bool_decoder in detail. It is easier to comprehend the bool_decoder in conjunction with the bool_encoder used by the compressor to write the compressed data partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
了解bool_解码器对于VP8解压器的实现至关重要，因此我们将详细讨论bool_解码器。更容易理解bool_解码器与压缩机用来写入压缩数据分区的bool_编码器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bool_encoder encodes (and the bool_decoder decodes) one bool (zero-or-one boolean value) at a time. Its purpose is to losslessly compress a sequence of bools for which the probability of their being zero or one can be well-estimated (via constant or previously coded information) at the time they are written, using identical corresponding probabilities at the time they are read.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bool_编码器一次编码（bool_解码器解码）一个bool（零或一个布尔值）。其目的是无损压缩bool序列，在写入bool时，使用读取bool时相同的相应概率（通过常量或先前编码的信息），可以很好地估计bool序列为零或一的概率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As the reader is probably aware, if a bool is much more likely to be zero than one (for instance), it can, on average, be faithfully encoded using much less than one bit per value. The bool_encoder exploits this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
读者可能知道，如果bool很可能是零而不是一（例如），那么平均而言，它可以使用每个值不到一位的数据进行忠实的编码。布尔鲁编码器利用了这一点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the 1940s, [Shannon] proved that there is a lower bound for the average datarate of a faithful encoding of a sequence of bools (whose probability distributions are known and are independent of each other) and also that there are encoding algorithms that approximate this lower bound as closely as one wishes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在20世纪40年代，[Shannon]证明了布尔序列（其概率分布已知且相互独立）的忠实编码的平均数据率有一个下界，并且有一些编码算法可以尽可能接近这个下界。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If we encode a sequence of bools whose probability of being zero is p (and whose probability of being 1 is 1-p), the lowest possible datarate per value is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果我们对概率为零的布尔序列进行编码（概率为1的布尔序列为1-p），则每个值的最低可能数据速率为
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   plog(p) + (1-p)log(1-p);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   plog(p) + (1-p)log(1-p);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
taking the logarithms to the base 1/2 expresses the datarate in bits/ value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将对数以1/2为基数表示数据速率，单位为位/值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We give two simple examples. At one extreme, if p = 1/2, then log(p) = log(1-p) = 1, and the lowest possible datarate per bool is 1/2 + 1/2 = 1; that is, we cannot do any better than simply literally writing out bits. At another extreme, if p is very small, say p = 1/1024, then log(p)=10, log(1-p) is roughly .0014, and the lowest possible datarate is approximately 10/1024 + .0014, roughly 1/100 of a bit per bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们给出两个简单的例子。在一个极端，如果p=1/2，那么log（p）=log（1-p）=1，每个bool的最低可能数据速率为1/2+1/2=1；也就是说，我们不能做得比简单地写出比特更好。在另一个极端，如果p非常小，比如p=1/1024，那么log（p）=10，log（1-p）大约为.0014，最低可能的数据速率大约为10/1024+.0014，大约为每bool 1/100位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because most of the bools in the VP8 datastream have zero-probabilities nowhere near 1/2, the compression provided by the bool_encoder is critical to the performance of VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于VP8数据流中的大多数布尔值的概率为零，不接近1/2，因此布尔_编码器提供的压缩对VP8的性能至关重要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The boolean coder used by VP8 is a variant of an arithmetic coder. An excellent discussion of arithmetic coding (and other lossless compression techniques) can be found in [Bell].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8使用的布尔编码器是算术编码器的变体。在[Bell]中可以找到关于算术编码（和其他无损压缩技术）的精彩讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Underlying Theory of Coding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 编码的基本理论
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic idea used by the boolean coder is to consider the entire data stream (either of the partitions in our case) as the binary expansion of a single number x with 0 &lt;= x &lt; 1. The bits (or bytes) in x are of course written from high to low order, and if b[j] (B[j]) is the j^(th) bit (byte) in the partition, the value x is simply the sum (starting with j = 1) of pow(2, -j) * b[j] or pow(256, -j) * B[j].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
布尔编码器使用的基本思想是将整个数据流（我们的分区中的任一个）考虑为单个数字x的二进制扩展，具有0 &lt;= x＜1。x中的位（或字节）当然是从高到低的顺序写入的，如果b[j]（b[j]）是分区中的第j^（th）位（字节），那么值x只是pow（2，-j）*b[j]或pow（256，-j）*b[j]的和（从j=1开始）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before the first bool is coded, all values of x are possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在编码第一个布尔之前，x的所有值都是可能的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding of each bool restricts the possible values of x in proportion to the probability of what is coded. If p1 is the probability of the first bool being zero and a zero is coded, the range of possible values of x is restricted to 0 &lt;= x &lt; p1. If a one is coded, the range becomes p1 &lt;= x &lt; 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个布尔的编码限制x的可能值，该值与编码的概率成比例。如果p1是第一个bool为零的概率，并且编码了零，则x的可能值范围限制为0&lt;=x&lt;p1。如果对1进行编码，则范围变为p1&lt;=x&lt;1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding continues by repeating the same idea. At every stage, there is an interval a &lt;= x &lt; b of possible values of x. If p is the probability of a zero being coded at this stage and a zero is coded, the interval becomes a &lt;= x &lt; a + (p(b-a)). If a one is coded, the possible values of x are restricted to a + (p(b-a)) &lt;= x &lt; b.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码继续重复相同的想法。在每个阶段，都有一个区间a&lt;=x&lt;b的x的可能值。如果p是在该阶段对零进行编码的概率，并且对零进行了编码，则区间变为a&lt;=x&lt;a+（p（b-a））。如果对一进行编码，则x的可能值限制为a+（p（b-a））&lt;=x&lt;b。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming that only finitely many values are to be coded, after the encoder has received the last bool, it can write as its output any value x that lies in the final interval. VP8 simply writes the left endpoint of the final interval. Consequently, the output it would make if encoding were to stop at any time either increases or stays the same as each bool is encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设只对有限多个值进行编码，在编码器接收到最后一个bool后，它可以将最终间隔中的任何值x写入其输出。VP8只写最后一个间隔的左端点。因此，如果编码在任何时候停止，它将产生的输出会随着每个bool的编码而增加或保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding parallels encoding. The decoder is presented with the number x, which has only the initial restriction 0 &lt;= x &lt; 1. To decode the first bool, the decoder is given the first probability p1. If x &lt; p1, a zero is decoded; if x &gt;= p1, a one is decoded. In either case, the new restriction on x -- that is, the interval of possible values of x -- is remembered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码与编码并行。解码器以数字x呈现，其仅具有初始限制0&lt;=x&lt;1。为了解码第一bool，解码器被赋予第一概率p1。如果x&lt;p1，则解码零；如果x&gt;=p1，则解码一个。在任何一种情况下，都会记住对x的新限制，即x的可能值的间隔。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding continues in exactly the same way: If a &lt;= x &lt; b is the current interval and we are to decode a bool with zero-probability p, we return a zero if a &lt;= x &lt; a + (p(b-a)) and a one if a + (p(b-a)) &lt;= x &lt; b. In either case, the new restriction is remembered in preparation for decoding the next bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码以完全相同的方式继续：如果a&lt;=x&lt;b是当前间隔，并且我们要以零概率p解码bool，那么如果a&lt;=x&lt;a+（p（b-a）），我们将返回零，如果a+（p（b-a））&lt;=x&lt;b，则返回一。在任何一种情况下，新的限制都会被记住，以准备解码下一个bool。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process outlined above uses real numbers of infinite precision to express the probabilities and ranges. It is true that, if one could actualize this process and coded a large number of bools whose supplied probabilities matched their value distributions, the datarate achieved would approach the theoretical minimum as the number of bools encoded increased.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述过程使用无限精度的实数来表示概率和范围。的确，如果一个人能够实现这一过程并编码大量布尔值，其提供的概率与其值分布相匹配，那么随着编码布尔值数量的增加，所获得的数据速率将接近理论最小值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unfortunately, computers operate at finite precision, and an approximation to the theoretically perfect process described above is necessary. Such approximation increases the datarate but, at quite moderate precision and for a wide variety of data sets, this increase is negligible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不幸的是，计算机在有限的精度下运行，必须近似于上述理论上完美的过程。这种近似增加了数据速率，但在相当中等的精度下，对于各种各样的数据集，这种增加可以忽略不计。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only conceptual limitations are, first, that coder probabilities must be expressed at finite precision and, second, that the decoder be able to detect each individual modification to the value interval via examination of a fixed amount of input. As a practical matter, many of the implementation details stem from the fact that the coder can function using only a small &#34;window&#34; to incrementally read or write the arbitrarily precise number x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一的概念限制是，首先，编码器概率必须以有限精度表示，其次，解码器能够通过检查固定数量的输入来检测对值间隔的每个单独修改。实际上，许多实现细节源于这样一个事实，即编码器可以只使用一个小“窗口”来递增地读取或写入任意精确的数字x。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Practical Algorithm Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 实用算法描述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8&#39;s boolean coder works with 8-bit probabilities p. The range of such p is 0 &lt;= p &lt;= 255; the actual probability represented by p is p/256. Also, the coder is designed so that decoding of a bool requires no more than an 8-bit comparison, and so that the state of both the encoder and decoder can be easily represented using a small number of unsigned 16-bit integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8的布尔编码器使用8位概率p。该p的范围为0&lt;=p&lt;=255；p表示的实际概率为p/256。此外，编码器的设计使得bool的解码只需要8位比较，并且使得编码器和解码器的状态可以使用少量无符号16位整数轻松表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details are most easily understood if we first describe the algorithm using bit-at-a-time input and output. Aside from the ability to maintain a position in this bitstream and write/read bits, the encoder also needs the ability to add 1 to the bits already output; after writing n bits, adding 1 to the existing output is the same thing as adding pow(2, -n) to x.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果我们首先使用一次一位的输入和输出来描述算法，那么细节最容易理解。除了能够保持在该比特流中的位置和写入/读取比特外，编码器还需要能够向已经输出的比特添加1；写入n位后，将1添加到现有输出与将pow（2，-n）添加到x是相同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together with the bit position, the encoder must maintain two unsigned 8-bit numbers, which we call &#34;bottom&#34; and &#34;range&#34;. Writing w for the n bits already written and S = pow(2, - n - 8) for the scale of the current bit position one byte out, we have the following constraint on all future values v of w (including the final value v = x):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
连同位位置，编码器必须保持两个无符号8位数字，我们称之为“底部”和“范围”。对于已经写入的n个位写入w，对于当前位位置的比例为1字节，写入S=pow（2，-n-8），我们对w的所有未来值v（包括最终值v=x）有以下约束：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   w + ( S * bottom ) &lt;= v &lt; w + ( S * ( bottom + range ) )
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   w + ( S * bottom ) &lt;= v &lt; w + ( S * ( bottom + range ) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, appending bottom to the already-written bits w gives the left endpoint of the interval of possible values, appending bottom + range gives the right endpoint, and range itself (scaled to the current output position) is the length of the interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，将bottom附加到已经写入的位w上，给出可能值间隔的左端点，将bottom+range附加到右端点，range本身（缩放到当前输出位置）是间隔的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So that our probabilistic encodings are reasonably accurate, we do not let range vary by more than a factor of two: It stays within the bounds 128 &lt;= range &lt;= 255.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，我们的概率编码是相当准确的，我们不让范围变化超过两个因素：它保持在128&lt;=范围&lt;=255的范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process for encoding a boolean value val whose probability of being zero is prob / 256 -- and whose probability of being one is ( 256 - prob ) / 256 -- with 1 &lt;= prob &lt;= 255 is as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对布尔值val进行编码的过程如下：其概率为零的概率为prob/256，其概率为（256-prob）/256，其中1&lt;=prob&lt;=255。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using an unsigned 16-bit multiply followed by an unsigned right shift, we calculate an unsigned 8-bit split value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用无符号16位乘法和无符号右移，我们计算无符号8位分割值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   split = 1 + (((range - 1) * probability)]] &gt;&gt; 8)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   split = 1 + (((range - 1) * probability)]] &gt;&gt; 8)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
split is approximately ( prob / 256 ) * range and lies within the bounds 1 &lt;= split &lt;= range - 1. These bounds ensure the correctness of the decoding procedure described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
split大约在（prob/256）*范围内，位于范围1&lt;=split&lt;=范围-1内。这些界限确保了下面描述的解码过程的正确性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the incoming boolean val to be encoded is false, we leave the left interval endpoint bottom alone and reduce range, replacing it by split. If the incoming val is true, we move up the left endpoint to bottom + split, propagating any carry to the already-written value w (this is where we need the ability to add 1 to w), and reduce range to range - split.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果要编码的传入布尔值为false，我们将保留左区间端点底部，并缩小范围，用split替换它。如果传入的val为true，我们将左端点向上移动到bottom+split，将任何进位传播到已经写入的值w（这是我们需要将1添加到w的地方），并减少范围到范围-split。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Regardless of the value encoded, range has been reduced and now has the bounds 1 &lt;= range &lt;= 254. If range &lt; 128, the encoder doubles it and shifts the high-order bit out of bottom to the output as it also doubles bottom, repeating this process one bit at a time until 128 &lt;= range &lt;= 255. Once this is completed, the encoder is ready to accept another bool, maintaining the constraints described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论编码的值是多少，范围都已缩小，现在的边界为1&lt;=范围&lt;=254。如果范围&lt;128，编码器将其加倍，并将高阶位从底部移到输出，因为它也将底部加倍，每次重复此过程一位，直到128&lt;=范围&lt;=255。一旦完成，编码器准备接受另一个bool，保持上述约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After encoding the last bool, the partition may be completed by appending bottom to the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在编码最后一个bool之后，可以通过向比特流追加bottom来完成分区。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder mimics the state of the encoder. It maintains, together with an input bit position, two unsigned 8-bit numbers, a range identical to that maintained by the encoder and a value. Decoding one bool at a time, the decoder (in effect) tracks the same left interval endpoint as does the encoder and subtracts it from the remaining input. Appending the unread portion of the bitstream to the 8-bit value gives the difference between the actual value encoded and the known left endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码器模拟编码器的状态。它与输入位位置一起保持两个无符号8位数字，一个与编码器保持的范围相同的范围和一个值。每次解码一个布尔，解码器（实际上）跟踪与编码器相同的左间隔端点，并从剩余输入中减去它。将比特流的未读部分附加到8位值会给出编码的实际值和已知左端点之间的差异。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder is initialized by setting range = 255 and reading the first 16 input bits into value. The decoder maintains range and calculates split in exactly the same way as does the encoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码器通过设置range=255并将前16个输入位读入值来初始化。解码器保持范围并以与编码器完全相同的方式计算分割。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To decode a bool, it compares value to split; if value &lt; split, the bool is zero, and range is replaced with split. If value &gt;= split, the bool is one, range is replaced with range - split, and value is replaced with value - split.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要解码布尔值，它将值与拆分值进行比较；如果值&lt;拆分，则bool为零，范围替换为拆分。如果值&gt;=split，则布尔值为1，范围替换为范围-split，值替换为值-split。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Again, range is doubled one bit at a time until it is at least 128. The value is doubled in parallel, shifting a new input bit into the bottom each time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同样，范围一次增加一位，直到至少达到128位。该值并行加倍，每次将一个新的输入位移到底部。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Writing Value for value together with the unread input bits and Range for range extended indefinitely on the right by zeros, the condition Value &lt; Range is maintained at all times by the decoder. In particular, the bits shifted out of value as it is doubled are always zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将Value for Value与未读输入位一起写入，并将右侧的Range for Range无限扩展0，解码器始终保持条件Value&lt;Range。特别是，当值翻倍时移位的位始终为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Actual Implementation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 实际执行
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The C code below gives complete implementations of the encoder and decoder described above. While they are logically identical to the &#34;bit-at-a-time&#34; versions, they internally buffer a couple of extra bytes of the bitstream. This allows I/O to be done (more practically) a byte at a time and drastically reduces the number of carries the encoder has to propagate into the already-written data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面的C代码给出了上述编码器和解码器的完整实现。虽然它们在逻辑上与“一次比特”版本相同，但它们在内部缓冲比特流的两个额外字节。这允许I/O一次完成一个字节（更实际），并大幅减少编码器必须传播到已写入数据中的载波数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another (logically equivalent) implementation may be found in the reference decoder file bool_decoder.h (Section 20.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考解码器文件bool_decoder.h（第20.2节）中可以找到另一个（逻辑等效）实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Encoder first */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Encoder first */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct {
     uint8 *output;  /* ptr to next byte to be written */
     uint32 range;   /* 128 &lt;= range &lt;= 255 */
     uint32 bottom;  /* minimum value of remaining output */
     int bit_count;  /* # of shifts before an output byte
                        is available */
   } bool_encoder;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct {
     uint8 *output;  /* ptr to next byte to be written */
     uint32 range;   /* 128 &lt;= range &lt;= 255 */
     uint32 bottom;  /* minimum value of remaining output */
     int bit_count;  /* # of shifts before an output byte
                        is available */
   } bool_encoder;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Must set initial state of encoder before writing any bools. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Must set initial state of encoder before writing any bools. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void init_bool_encoder(bool_encoder *e, uint8 *start_partition)
   {
     e-&gt;output = start_partition;
     e-&gt;range = 255;
     e-&gt;bottom = 0;
     e-&gt;bit_count = 24;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void init_bool_encoder(bool_encoder *e, uint8 *start_partition)
   {
     e-&gt;output = start_partition;
     e-&gt;range = 255;
     e-&gt;bottom = 0;
     e-&gt;bit_count = 24;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Encoding very rarely produces a carry that must be propagated
      to the already-written output.  The arithmetic guarantees that
      the propagation will never go beyond the beginning of the
      output.  Put another way, the encoded value x is always less
      than one. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Encoding very rarely produces a carry that must be propagated
      to the already-written output.  The arithmetic guarantees that
      the propagation will never go beyond the beginning of the
      output.  Put another way, the encoded value x is always less
      than one. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void add_one_to_output(uint8 *q)
   {
     while (*--q == 255)
       *q = 0;
     ++*q;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void add_one_to_output(uint8 *q)
   {
     while (*--q == 255)
       *q = 0;
     ++*q;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Main function writes a bool_value whose probability of being
      zero is (expected to be) prob/256. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Main function writes a bool_value whose probability of being
      zero is (expected to be) prob/256. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void write_bool(bool_encoder *e, Prob prob, int bool_value)
   {
     /* split is approximately (range * prob) / 256 and,
        crucially, is strictly bigger than zero and strictly
        smaller than range */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void write_bool(bool_encoder *e, Prob prob, int bool_value)
   {
     /* split is approximately (range * prob) / 256 and,
        crucially, is strictly bigger than zero and strictly
        smaller than range */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     uint32 split = 1 + (((e-&gt;range - 1) * prob) &gt;&gt; 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     uint32 split = 1 + (((e-&gt;range - 1) * prob) &gt;&gt; 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (bool_value) {
       e-&gt;bottom += split; /* move up bottom of interval */
       e-&gt;range -= split;  /* with corresponding decrease in range */
     } else
       e-&gt;range = split;   /* decrease range, leaving bottom alone */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (bool_value) {
       e-&gt;bottom += split; /* move up bottom of interval */
       e-&gt;range -= split;  /* with corresponding decrease in range */
     } else
       e-&gt;range = split;   /* decrease range, leaving bottom alone */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while (e-&gt;range &lt; 128)
     {
       e-&gt;range &lt;&lt;= 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while (e-&gt;range &lt; 128)
     {
       e-&gt;range &lt;&lt;= 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (e-&gt;bottom &amp; (1 &lt;&lt; 31))  /* detect carry */
         add_one_to_output(e-&gt;output);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (e-&gt;bottom &amp; (1 &lt;&lt; 31))  /* detect carry */
         add_one_to_output(e-&gt;output);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       e-&gt;bottom &lt;&lt;= 1;        /* before shifting bottom */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       e-&gt;bottom &lt;&lt;= 1;        /* before shifting bottom */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!--e-&gt;bit_count) {  /* write out high byte of bottom ... */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!--e-&gt;bit_count) {  /* write out high byte of bottom ... */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         *e-&gt;output++ = (uint8) (e-&gt;bottom &gt;&gt; 24);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         *e-&gt;output++ = (uint8) (e-&gt;bottom &gt;&gt; 24);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         e-&gt;bottom &amp;= (1 &lt;&lt; 24) - 1;  /* ... keeping low 3 bytes */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         e-&gt;bottom &amp;= (1 &lt;&lt; 24) - 1;  /* ... keeping low 3 bytes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         e-&gt;bit_count = 8;            /* 8 shifts until next output */
       }
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         e-&gt;bit_count = 8;            /* 8 shifts until next output */
       }
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Call this function (exactly once) after encoding the last
      bool value for the partition being written */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Call this function (exactly once) after encoding the last
      bool value for the partition being written */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void flush_bool_encoder(bool_encoder *e)
   {
     int c = e-&gt;bit_count;
     uint32 v = e-&gt;bottom;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void flush_bool_encoder(bool_encoder *e)
   {
     int c = e-&gt;bit_count;
     uint32 v = e-&gt;bottom;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (v &amp; (1 &lt;&lt; (32 - c)))   /* propagate (unlikely) carry */
       add_one_to_output(e-&gt;output);
     v &lt;&lt;= c &amp; 7;               /* before shifting remaining output */
     c &gt;&gt;= 3;                   /* to top of internal buffer */
     while (--c &gt;= 0)
       v &lt;&lt;= 8;
     c = 4;
     while (--c &gt;= 0) {    /* write remaining data, possibly padded */
       *e-&gt;output++ = (uint8) (v &gt;&gt; 24);
       v &lt;&lt;= 8;
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (v &amp; (1 &lt;&lt; (32 - c)))   /* propagate (unlikely) carry */
       add_one_to_output(e-&gt;output);
     v &lt;&lt;= c &amp; 7;               /* before shifting remaining output */
     c &gt;&gt;= 3;                   /* to top of internal buffer */
     while (--c &gt;= 0)
       v &lt;&lt;= 8;
     c = 4;
     while (--c &gt;= 0) {    /* write remaining data, possibly padded */
       *e-&gt;output++ = (uint8) (v &gt;&gt; 24);
       v &lt;&lt;= 8;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Decoder state exactly parallels that of the encoder.
      &#34;value&#34;, together with the remaining input, equals the
      complete encoded number x less the left endpoint of the
      current coding interval. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Decoder state exactly parallels that of the encoder.
      &#34;value&#34;, together with the remaining input, equals the
      complete encoded number x less the left endpoint of the
      current coding interval. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct {
     uint8   *input;     /* pointer to next compressed data byte */
     uint32  range;      /* always identical to encoder&#39;s range */
     uint32  value;      /* contains at least 8 significant bits */
     int     bit_count;  /* # of bits shifted out of
                            value, at most 7 */
   } bool_decoder;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct {
     uint8   *input;     /* pointer to next compressed data byte */
     uint32  range;      /* always identical to encoder&#39;s range */
     uint32  value;      /* contains at least 8 significant bits */
     int     bit_count;  /* # of bits shifted out of
                            value, at most 7 */
   } bool_decoder;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Call this function before reading any bools from the
      partition. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Call this function before reading any bools from the
      partition. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void init_bool_decoder(bool_decoder *d, uint8 *start_partition)
   {
     {
       int i = 0;
       d-&gt;value = 0;           /* value = first 2 input bytes */
       while (++i &lt;= 2)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void init_bool_decoder(bool_decoder *d, uint8 *start_partition)
   {
     {
       int i = 0;
       d-&gt;value = 0;           /* value = first 2 input bytes */
       while (++i &lt;= 2)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         d-&gt;value = (d-&gt;value &lt;&lt; 8)  |  *start_partition++;
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         d-&gt;value = (d-&gt;value &lt;&lt; 8)  |  *start_partition++;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     d-&gt;input = start_partition;  /* ptr to next byte to be read */
     d-&gt;range = 255;           /* initial range is full */
     d-&gt;bit_count = 0;         /* have not yet shifted out any bits */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     d-&gt;input = start_partition;  /* ptr to next byte to be read */
     d-&gt;range = 255;           /* initial range is full */
     d-&gt;bit_count = 0;         /* have not yet shifted out any bits */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Main function reads a bool encoded at probability prob/256,
      which of course must agree with the probability used when the
      bool was written. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Main function reads a bool encoded at probability prob/256,
      which of course must agree with the probability used when the
      bool was written. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int read_bool(bool_decoder *d, Prob prob)
   {
     /* range and split are identical to the corresponding values
        used by the encoder when this bool was written */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int read_bool(bool_decoder *d, Prob prob)
   {
     /* range and split are identical to the corresponding values
        used by the encoder when this bool was written */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     uint32  split = 1 + (((d-&gt;range - 1) * prob) &gt;&gt; 8);
     uint32  SPLIT = split &lt;&lt; 8;
     int     retval;           /* will be 0 or 1 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     uint32  split = 1 + (((d-&gt;range - 1) * prob) &gt;&gt; 8);
     uint32  SPLIT = split &lt;&lt; 8;
     int     retval;           /* will be 0 or 1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (d-&gt;value &gt;= SPLIT) {  /* encoded a one */
       retval = 1;
       d-&gt;range -= split;  /* reduce range */
       d-&gt;value -= SPLIT;  /* subtract off left endpoint of interval */
     } else {              /* encoded a zero */
       retval = 0;
       d-&gt;range = split;  /* reduce range, no change in left endpoint */
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (d-&gt;value &gt;= SPLIT) {  /* encoded a one */
       retval = 1;
       d-&gt;range -= split;  /* reduce range */
       d-&gt;value -= SPLIT;  /* subtract off left endpoint of interval */
     } else {              /* encoded a zero */
       retval = 0;
       d-&gt;range = split;  /* reduce range, no change in left endpoint */
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while (d-&gt;range &lt; 128) {  /* shift out irrelevant value bits */
       d-&gt;value &lt;&lt;= 1;
       d-&gt;range &lt;&lt;= 1;
       if (++d-&gt;bit_count == 8) {  /* shift in new bits 8 at a time */
         d-&gt;bit_count = 0;
         d-&gt;value |= *d-&gt;input++;
       }
     }
     return retval;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while (d-&gt;range &lt; 128) {  /* shift out irrelevant value bits */
       d-&gt;value &lt;&lt;= 1;
       d-&gt;range &lt;&lt;= 1;
       if (++d-&gt;bit_count == 8) {  /* shift in new bits 8 at a time */
         d-&gt;bit_count = 0;
         d-&gt;value |= *d-&gt;input++;
       }
     }
     return retval;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Convenience function reads a &#34;literal&#34;, that is, a &#34;num_bits&#34;-
      wide unsigned value whose bits come high- to low-order, with
      each bit encoded at probability 128 (i.e., 1/2). */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Convenience function reads a &#34;literal&#34;, that is, a &#34;num_bits&#34;-
      wide unsigned value whose bits come high- to low-order, with
      each bit encoded at probability 128 (i.e., 1/2). */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   uint32 read_literal(bool_decoder *d, int num_bits)
   {
     uint32 v = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   uint32 read_literal(bool_decoder *d, int num_bits)
   {
     uint32 v = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while (num_bits--)
       v = (v &lt;&lt; 1) + read_bool(d, 128);
     return v;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while (num_bits--)
       v = (v &lt;&lt; 1) + read_bool(d, 128);
     return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Variant reads a signed number */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Variant reads a signed number */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int32 read_signed_literal(bool_decoder *d, int num_bits)
   {
     int32 v = 0;
     if (!num_bits)
       return 0;
     if (read_bool(d, 128))
       v = -1;
     while (--num_bits)
       v = (v &lt;&lt; 1) + read_bool(d, 128);
     return v;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int32 read_signed_literal(bool_decoder *d, int num_bits)
   {
     int32 v = 0;
     if (!num_bits)
       return 0;
     if (read_bool(d, 128))
       v = -1;
     while (--num_bits)
       v = (v &lt;&lt; 1) + read_bool(d, 128);
     return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Compressed Data Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 压缩数据组件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the lowest level, VP8&#39;s compressed data is simply a sequence of probabilistically encoded bools. Most of this data is composed of (slightly) larger semantic units fashioned from bools, which we describe here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在最底层，VP8的压缩数据只是一个概率编码布尔序列。这些数据中的大多数是由（稍大一点的）bools语义单元组成的，我们在这里描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We sometimes use these descriptions in C expressions within data format specifications. In this context, they refer to the return value of a call to an appropriate bool_decoder d, reading (as always) from its current reference point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们有时在数据格式规范的C表达式中使用这些描述。在这种情况下，它们指的是调用相应bool_解码器d的返回值，从其当前参考点读取（一如既往）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +--------------+-------+--------------------------------------------+
   | Call         | Alt.  | Return                                     |
   +--------------+-------+--------------------------------------------+
   | Bool(p)      | B(p)  | Bool with probability p/256 of being 0.    |
   |              |       | Return value of read_bool(d, p).           |
   |              |       |                                            |
   | Flag         | F     | A one-bit flag (same thing as a B(128) or  |
   |              |       | an L(1)).  Abbreviated F.  Return value of |
   |              |       | read_bool(d, 128).                         |
   |              |       |                                            |
   | Lit(n)       | L(n)  | Unsigned n-bit number encoded as n flags   |
   |              |       | (a &#34;literal&#34;).  Abbreviated L(n).  The     |
   |              |       | bits are read from high to low order.      |
   |              |       | Return value of read_literal(d, n).        |
   |              |       |                                            |
   | SignedLit(n) |       | Signed n-bit number encoded similarly to   |
   |              |       | an L(n).  Return value of                  |
   |              |       | read_signed_literal(d, n).  These are      |
   |              |       | rare.                                      |
   |              |       |                                            |
   | P(8)         |       | An 8-bit probability.  No different from   |
   |              |       | an L(8), but we sometimes use this         |
   |              |       | notation to emphasize that a probability   |
   |              |       | is being coded.                            |
   |              |       |                                            |
   | P(7)         |       | A 7-bit specification of an 8-bit          |
   |              |       | probability.  Coded as an L(7) number x;   |
   |              |       | the resulting 8-bit probability is x ? x   |
   |              |       | &lt;&lt; 1 : 1.                                  |
   |              |       |                                            |
   | F?  X        |       | A flag that, if true, is followed by a     |
   |              |       | piece of data X.                           |
   |              |       |                                            |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +--------------+-------+--------------------------------------------+
   | Call         | Alt.  | Return                                     |
   +--------------+-------+--------------------------------------------+
   | Bool(p)      | B(p)  | Bool with probability p/256 of being 0.    |
   |              |       | Return value of read_bool(d, p).           |
   |              |       |                                            |
   | Flag         | F     | A one-bit flag (same thing as a B(128) or  |
   |              |       | an L(1)).  Abbreviated F.  Return value of |
   |              |       | read_bool(d, 128).                         |
   |              |       |                                            |
   | Lit(n)       | L(n)  | Unsigned n-bit number encoded as n flags   |
   |              |       | (a &#34;literal&#34;).  Abbreviated L(n).  The     |
   |              |       | bits are read from high to low order.      |
   |              |       | Return value of read_literal(d, n).        |
   |              |       |                                            |
   | SignedLit(n) |       | Signed n-bit number encoded similarly to   |
   |              |       | an L(n).  Return value of                  |
   |              |       | read_signed_literal(d, n).  These are      |
   |              |       | rare.                                      |
   |              |       |                                            |
   | P(8)         |       | An 8-bit probability.  No different from   |
   |              |       | an L(8), but we sometimes use this         |
   |              |       | notation to emphasize that a probability   |
   |              |       | is being coded.                            |
   |              |       |                                            |
   | P(7)         |       | A 7-bit specification of an 8-bit          |
   |              |       | probability.  Coded as an L(7) number x;   |
   |              |       | the resulting 8-bit probability is x ? x   |
   |              |       | &lt;&lt; 1 : 1.                                  |
   |              |       |                                            |
   | F?  X        |       | A flag that, if true, is followed by a     |
   |              |       | piece of data X.                           |
   |              |       |                                            |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | F?  X:Y      |       | A flag that, if true, is followed by X     |
   |              |       | and, if false, is followed by Y.  Also     |
   |              |       | used to express a value where Y is an      |
   |              |       | implicit default (not encoded in the data  |
   |              |       | stream), as in F?  P(8):255, which         |
   |              |       | expresses an optional probability: If the  |
   |              |       | flag is true, the probability is specified |
   |              |       | as an 8-bit literal, while if the flag is  |
   |              |       | false, the probability defaults to 255.    |
   |              |       |                                            |
   | B(p)?  X     | B(p)? | Variants of the above using a boolean      |
   |              | X:Y   | indicator whose probability is not         |
   |              |       | necessarily 128.                           |
   |              |       |                                            |
   | T            |       | Tree-encoded value from small alphabet.    |
   +--------------+-------+--------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | F?  X:Y      |       | A flag that, if true, is followed by X     |
   |              |       | and, if false, is followed by Y.  Also     |
   |              |       | used to express a value where Y is an      |
   |              |       | implicit default (not encoded in the data  |
   |              |       | stream), as in F?  P(8):255, which         |
   |              |       | expresses an optional probability: If the  |
   |              |       | flag is true, the probability is specified |
   |              |       | as an 8-bit literal, while if the flag is  |
   |              |       | false, the probability defaults to 255.    |
   |              |       |                                            |
   | B(p)?  X     | B(p)? | Variants of the above using a boolean      |
   |              | X:Y   | indicator whose probability is not         |
   |              |       | necessarily 128.                           |
   |              |       |                                            |
   | T            |       | Tree-encoded value from small alphabet.    |
   +--------------+-------+--------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last type requires elaboration. We often wish to encode something whose value is restricted to a small number of possibilities (the alphabet).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后一种类型需要细化。我们经常希望编码的东西，其价值被限制在少数可能性（字母表）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is done by representing the alphabet as the leaves of a small binary tree. The (non-leaf) nodes of the tree have associated probabilities p and correspond to calls to read_bool(d, p). We think of a zero as choosing the left branch below the node and a one as choosing the right branch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是通过将字母表表示为小二叉树的叶子来实现的。树的（非叶）节点具有相关概率p，并对应于对read_bool（d，p）的调用。我们认为零表示选择节点下方的左分支，一表示选择右分支。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, every value (leaf) whose tree depth is x is decoded after exactly x calls to read_bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，树深度为x的每个值（叶）在x调用read_bool之后被解码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A tree representing an encoding of an alphabet of n possible values always contains n-1 non-leaf nodes, regardless of its shape (this is easily seen by induction on n).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表示n个可能值的字母表编码的树始终包含n-1个非叶节点，而不管其形状如何（这很容易通过对n的归纳来看出）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are many ways that a given alphabet can be so represented. The choice of tree has little impact on datarate but does affect decoder performance. The trees used by VP8 are chosen to (on average) minimize the number of calls to read_bool. This amounts to shaping the tree so that values that are more probable have smaller tree depth than do values that are less probable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个给定的字母表有很多种表达方式。树的选择对数据速率几乎没有影响，但会影响解码器的性能。VP8使用的树的选择（平均）是为了最小化读取布尔的调用次数。这相当于对树进行整形，以便更可能的值比不太可能的值具有更小的树深度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Readers familiar with Huffman coding will notice that, given an alphabet together with probabilities for each value, the associated Huffman tree minimizes the expected number of calls to read_bool.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
熟悉哈夫曼编码的读者会注意到，给定一个字母表以及每个值的概率，关联的哈夫曼树会最小化读取布尔的预期调用数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Such readers will also realize that the coding method described here never results in higher datarates than does the Huffman method and, indeed, often results in much lower datarates. Huffman coding is, in fact, nothing more than a special case of this method in which each node probability is fixed at 128 (i.e., 1/2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些读者还将认识到，这里描述的编码方法永远不会产生比哈夫曼方法更高的数据速率，事实上，通常会产生更低的数据速率。事实上，哈夫曼编码不过是这种方法的一种特例，其中每个节点的概率固定在128（即1/2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Tree Coding Implementation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 树编码实现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We give a suggested implementation of a tree data structure followed by a couple of actual examples of its usage by VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们给出了一个树数据结构的建议实现，然后给出了VP8使用它的两个实际示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is most convenient to represent the values using small positive integers, typically an enum counting up from zero. The largest alphabet (used to code DCT coefficients, described in Section 13) that is tree-coded by VP8 has only 12 values. The tree for this alphabet adds 11 interior nodes and so has a total of 23 positions. Thus, an 8-bit number easily accommodates both a tree position and a return value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用小的正整数表示值是最方便的，通常是从零开始计数的枚举。VP8树编码的最大字母表（用于编码DCT系数，如第13节所述）只有12个值。此字母表的树添加了11个内部节点，因此总共有23个位置。因此，8位数字容易容纳树位置和返回值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A tree may then be compactly represented as an array of (pairs of) 8-bit integers. Each (even) array index corresponds to an interior node of the tree; the 0th index of course corresponds to the root of the tree. The array entries come in pairs corresponding to the left (0) and right (1) branches of the subtree below the interior node. We use the convention that a positive (even) branch entry is the index of a deeper interior node, while a nonpositive entry v corresponds to a leaf whose value is -v.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，树可以紧凑地表示为8位整数（对）的数组。每个（偶数）数组索引对应于树的内部节点；当然，第0个索引对应于树的根。数组项成对出现，对应于内部节点下方子树的左（0）和右（1）分支。我们使用的约定是，正（偶数）分支条目是较深内部节点的索引，而非正条目v对应于值为-v的叶。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The node probabilities associated to a tree-coded value are stored in an array whose indices are half the indices of the corresponding tree positions. The length of the probability array is one less than the size of the alphabet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与树编码值相关联的节点概率存储在一个数组中，该数组的索引是相应树位置索引的一半。概率数组的长度比字母表的大小小一个。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here is C code implementing the foregoing. The advantages of our data structure should be noted. Aside from the smallness of the structure itself, the tree-directed reading algorithm is essentially a single line of code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面是实现上述功能的C代码。应该注意我们的数据结构的优点。除了结构本身很小之外，树定向读取算法本质上是一行代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* A tree specification is simply an array of 8-bit integers. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* A tree specification is simply an array of 8-bit integers. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef int8 tree_index;
   typedef const tree_index Tree[];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef int8 tree_index;
   typedef const tree_index Tree[];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Read and return a tree-coded value at the current decoder
      position. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Read and return a tree-coded value at the current decoder
      position. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int treed_read(
     bool_decoder * const d, /* bool_decoder always returns a 0 or 1 */
     Tree t,                 /* tree specification */
     const Prob p[]     /* corresponding interior node probabilities */
   ) {
     register tree_index i = 0;   /* begin at root */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int treed_read(
     bool_decoder * const d, /* bool_decoder always returns a 0 or 1 */
     Tree t,                 /* tree specification */
     const Prob p[]     /* corresponding interior node probabilities */
   ) {
     register tree_index i = 0;   /* begin at root */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     /* Descend tree until leaf is reached */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     /* Descend tree until leaf is reached */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while ((i = t[ i + read_bool(d, p[i&gt;&gt;1])]) &gt; 0) {}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     while ((i = t[ i + read_bool(d, p[i&gt;&gt;1])]) &gt; 0) {}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     return -i;     /* return value is negation of nonpositive index */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     return -i;     /* return value is negation of nonpositive index */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tree-based decoding is implemented in the reference decoder file bool_decoder.h (Section 20.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基于树的解码在参考解码器文件bool_decoder.h（第20.2节）中实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Tree Coding Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 树编码示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a multi-part example, without getting too far into the semantics of macroblock decoding (which is of course taken up below), we look at the &#34;mode&#34; coding for intra-predicted macroblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为一个多部分示例，在不深入宏块解码语义的情况下（这当然在下面讨论），我们来看看帧内预测宏块的“模式”编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It so happens that, because of a difference in statistics, the Y (or luma) mode encoding uses two different trees: one for key frames and another for interframes. This is the only instance in VP8 of the same dataset being coded by different trees under different circumstances. The UV (or chroma) modes are a proper subset of the Y modes and, as such, have their own decoding tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于统计数据的差异，Y（或luma）模式编码使用两种不同的树：一种用于关键帧，另一种用于帧间。这是VP8中同一数据集在不同情况下由不同树编码的唯一实例。UV（或色度）模式是Y模式的适当子集，因此具有其自己的解码树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       DC_PRED, /* predict DC using row above and column to the left */
       V_PRED,  /* predict rows using row above */
       H_PRED,  /* predict columns using column to the left */
       TM_PRED, /* propagate second differences a la &#34;True Motion&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       DC_PRED, /* predict DC using row above and column to the left */
       V_PRED,  /* predict rows using row above */
       H_PRED,  /* predict columns using column to the left */
       TM_PRED, /* propagate second differences a la &#34;True Motion&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_PRED,  /* each Y subblock is independently predicted */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_PRED,  /* each Y subblock is independently predicted */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_uv_modes = B_PRED,  /* first four modes apply to chroma */
       num_ymodes   /* all modes apply to luma */
   }
   intra_mbmode;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_uv_modes = B_PRED,  /* first four modes apply to chroma */
       num_ymodes   /* all modes apply to luma */
   }
   intra_mbmode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* The aforementioned trees together with the implied codings as
      comments.
      Actual (i.e., positive) indices are always even.
      Value (i.e., nonpositive) indices are arbitrary. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* The aforementioned trees together with the implied codings as
      comments.
      Actual (i.e., positive) indices are always even.
      Value (i.e., nonpositive) indices are arbitrary. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index ymode_tree [2 * (num_ymodes - 1)] =
   {
    -DC_PRED, 2,        /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,              /* &#34;1&#34; subtree has 2 descendant subtrees */
      -V_PRED, -H_PRED, /* &#34;10&#34; subtree: V_PRED = &#34;100&#34;,
                           H_PRED = &#34;101&#34; */
      -TM_PRED, -B_PRED /* &#34;11&#34; subtree: TM_PRED = &#34;110&#34;,
                           B_PRED = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index ymode_tree [2 * (num_ymodes - 1)] =
   {
    -DC_PRED, 2,        /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,              /* &#34;1&#34; subtree has 2 descendant subtrees */
      -V_PRED, -H_PRED, /* &#34;10&#34; subtree: V_PRED = &#34;100&#34;,
                           H_PRED = &#34;101&#34; */
      -TM_PRED, -B_PRED /* &#34;11&#34; subtree: TM_PRED = &#34;110&#34;,
                           B_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =
   {
    -B_PRED, 2,            /* root: B_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -DC_PRED, -V_PRED,   /* &#34;10&#34; subtree: DC_PRED = &#34;100&#34;,
                              V_PRED = &#34;101&#34; */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =
   {
    -B_PRED, 2,            /* root: B_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -DC_PRED, -V_PRED,   /* &#34;10&#34; subtree: DC_PRED = &#34;100&#34;,
                              V_PRED = &#34;101&#34; */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =
   {
    -DC_PRED, 2,          /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     -V_PRED, 4,          /* &#34;1&#34; subtree:  V_PRED = &#34;10&#34;,
                             &#34;11&#34; subtree */
      -H_PRED, -TM_PRED   /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                             TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =
   {
    -DC_PRED, 2,          /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     -V_PRED, 4,          /* &#34;1&#34; subtree:  V_PRED = &#34;10&#34;,
                             &#34;11&#34; subtree */
      -H_PRED, -TM_PRED   /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                             TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Given a bool_decoder d, a Y mode might be decoded as follows. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Given a bool_decoder d, a Y mode might be decoded as follows. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob pretend_its_huffman [num_ymodes - 1] =
     { 128, 128, 128, 128};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob pretend_its_huffman [num_ymodes - 1] =
     { 128, 128, 128, 128};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Ymode = (intra_mbmode) treed_read(d, ymode_tree,
     pretend_its_huffman);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Ymode = (intra_mbmode) treed_read(d, ymode_tree,
     pretend_its_huffman);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since it greatly facilitates re-use of reference code, and since there is no real reason to do otherwise, it is strongly suggested that any decoder implementation use exactly the same enumeration values and probability table layouts as those described in this document (and in the reference code) for all tree-coded data in VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于它极大地促进了参考代码的重复使用，并且没有真正的理由这样做，因此强烈建议任何解码器实现对VP8中的所有树编码数据使用与本文档（以及参考代码）中描述的完全相同的枚举值和概率表布局。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Frame Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 帧头
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The uncompressed data chunk at the start of each frame and at the first part of the first data partition contains information pertaining to the frame as a whole. We list the fields in the order of occurrence. Most of the header decoding occurs in the reference decoder file dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个帧开头和第一个数据分区的第一部分的未压缩数据块包含与整个帧相关的信息。我们按出现的顺序列出字段。大多数头解码发生在参考解码器文件dixie.c中（第20.4节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Uncompressed Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 未压缩数据块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The uncompressed data chunk comprises a common (for key frames and interframes) 3-byte frame tag that contains four fields, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未压缩数据块包含一个公共（用于关键帧和帧间）3字节帧标记，该标记包含四个字段，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A 1-bit frame type (0 for key frames, 1 for interframes).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 1位帧类型（0表示关键帧，1表示干涉帧）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A 3-bit version number (0 - 3 are defined as four different profiles with different decoding complexity; other values may be defined for future variants of the VP8 data format).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 一个3位版本号（0-3被定义为具有不同解码复杂度的四个不同配置文件；其他值可为VP8数据格式的未来变体定义）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. A 1-bit show_frame flag (0 when current frame is not for display, 1 when current frame is for display).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 1位显示帧标志（当前帧不用于显示时为0，当前帧用于显示时为1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A 19-bit field containing the size of the first data partition in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 包含第一个数据分区大小（字节）的19位字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The version number setting enables or disables certain features in the bitstream, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版本号设置启用或禁用位流中的某些功能，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +---------+-------------------------+-------------+
            | Version | Reconstruction Filter   | Loop Filter |
            +---------+-------------------------+-------------+
            | 0       | Bicubic                 | Normal      |
            |         |                         |             |
            | 1       | Bilinear                | Simple      |
            |         |                         |             |
            | 2       | Bilinear                | None        |
            |         |                         |             |
            | 3       | None                    | None        |
            |         |                         |             |
            | Other   | Reserved for future use |             |
            +---------+-------------------------+-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +---------+-------------------------+-------------+
            | Version | Reconstruction Filter   | Loop Filter |
            +---------+-------------------------+-------------+
            | 0       | Bicubic                 | Normal      |
            |         |                         |             |
            | 1       | Bilinear                | Simple      |
            |         |                         |             |
            | 2       | Bilinear                | None        |
            |         |                         |             |
            | 3       | None                    | None        |
            |         |                         |             |
            | Other   | Reserved for future use |             |
            +---------+-------------------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference software also adjusts the loop filter based on version number, as per the table above. Version number 1 implies a &#34;simple&#34; loop filter, and version numbers 2 and 3 imply no loop filter. However, the &#34;simple&#34; filter setting in this context has no effect whatsoever on the decoding process, and the &#34;no loop filter&#34; setting only forces the reference encoder to set filter level equal to 0. Neither affect the decoding process. In decoding, the only loop filter settings that matter are those in the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考软件还根据上表，根据版本号调整循环过滤器。版本号1表示“简单”循环过滤器，版本号2和3表示没有循环过滤器。然而，在此上下文中的“简单”滤波器设置对解码过程没有任何影响，“无环路滤波器”设置仅强制参考编码器将滤波器电平设置为0。两者都不影响解码过程。在解码中，唯一重要的循环过滤器设置是帧头中的设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For key frames, the frame tag is followed by a further 7 bytes of uncompressed data, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于关键帧，帧标记后面还有7个字节的未压缩数据，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Start code byte 0 0x9d Start code byte 1 0x01 Start code byte 2 0x2a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
开始代码字节0 0x9d开始代码字节1 0x01开始代码字节2 0x2a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   16 bits      :     (2 bits Horizontal Scale &lt;&lt; 14) | Width (14 bits)
   16 bits      :     (2 bits Vertical Scale &lt;&lt; 14) | Height (14 bits)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   16 bits      :     (2 bits Horizontal Scale &lt;&lt; 14) | Width (14 bits)
   16 bits      :     (2 bits Vertical Scale &lt;&lt; 14) | Height (14 bits)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following source code segment illustrates validation of the start code and reading the width, height, and scale factors for a key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面的源代码段演示了开始代码的验证以及读取关键帧的宽度、高度和比例因子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source+3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source+3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   // vet via sync code
   if (c[0]!=0x9d||c[1]!=0x01||c[2]!=0x2a)
       return -1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   // vet via sync code
   if (c[0]!=0x9d||c[1]!=0x01||c[2]!=0x2a)
       return -1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where pbi-&gt;source points to the beginning of the frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中pbi-&gt;source指向帧的开头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following code reads the image dimension from the bitstream:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下代码从比特流读取图像维度：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pc-&gt;Width      = swap2(*(unsigned short*)(c+3))&amp;0x3fff;
   pc-&gt;horiz_scale = swap2(*(unsigned short*)(c+3))&gt;&gt;14;
   pc-&gt;Height     = swap2(*(unsigned short*)(c+5))&amp;0x3fff;
   pc-&gt;vert_scale  = swap2(*(unsigned short*)(c+5))&gt;&gt;14;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pc-&gt;Width      = swap2(*(unsigned short*)(c+3))&amp;0x3fff;
   pc-&gt;horiz_scale = swap2(*(unsigned short*)(c+3))&gt;&gt;14;
   pc-&gt;Height     = swap2(*(unsigned short*)(c+5))&amp;0x3fff;
   pc-&gt;vert_scale  = swap2(*(unsigned short*)(c+5))&gt;&gt;14;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the swap2 macro takes care of the endian on a different platform:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
swap2宏在不同平台上处理endian时：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(__ppc__) || defined(__ppc64__)
   # define swap2(d)  \
     ((d&amp;0x000000ff)&lt;&lt;8) |  \
     ((d&amp;0x0000ff00)&gt;&gt;8)
   #else
     # define swap2(d) d
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(__ppc__) || defined(__ppc64__)
   # define swap2(d)  \
     ((d&amp;0x000000ff)&lt;&lt;8) |  \
     ((d&amp;0x0000ff00)&gt;&gt;8)
   #else
     # define swap2(d) d
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While each frame is encoded as a raster scan of 16x16 macroblocks, the frame dimensions are not necessarily evenly divisible by 16. In this case, write ew = 16 - (width &amp; 15) and eh = 16 - (height &amp; 15) for the excess width and height, respectively. Although they are
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然每个帧编码为16x16宏块的光栅扫描，但帧尺寸不一定能被16整除。在这种情况下，将多余的宽度和高度分别写入ew=16-（宽度和高度15）和eh=16-（高度和高度15）。虽然他们是
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
encoded, the last ew columns and eh rows are not actually part of the image and should be discarded before final output. However, these &#34;excess pixels&#34; should be maintained in the internal reconstruction buffer used to predict ensuing frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码后，最后的ew列和eh行实际上不是图像的一部分，应该在最终输出之前丢弃。然而，这些“多余像素”应该保留在用于预测后续帧的内部重建缓冲区中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The scaling specifications for each dimension are encoded as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个维度的缩放规格编码如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             +-------+--------------------------------------+
             | Value | Scaling                              |
             +-------+--------------------------------------+
             | 0     | No upscaling (the most common case). |
             |       |                                      |
             | 1     | Upscale by 5/4.                      |
             |       |                                      |
             | 2     | Upscale by 5/3.                      |
             |       |                                      |
             | 3     | Upscale by 2.                        |
             +-------+--------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             +-------+--------------------------------------+
             | Value | Scaling                              |
             +-------+--------------------------------------+
             | 0     | No upscaling (the most common case). |
             |       |                                      |
             | 1     | Upscale by 5/4.                      |
             |       |                                      |
             | 2     | Upscale by 5/3.                      |
             |       |                                      |
             | 3     | Upscale by 2.                        |
             +-------+--------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upscaling does not affect the reconstruction buffer, which should be maintained at the encoded resolution. Any reasonable method of upsampling (including any that may be supported by video hardware in the playback environment) may be used. Since scaling has no effect on decoding, we do not discuss it any further.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
放大不影响重建缓冲区，重建缓冲区应保持编码分辨率。可以使用任何合理的上采样方法（包括回放环境中视频硬件支持的任何上采样方法）。由于缩放对解码没有影响，我们不再进一步讨论它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in Section 5, allocation (or re-allocation) of data structures (such as the reconstruction buffer) whose size depends on dimension will be triggered here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第5节所述，此处将触发大小取决于维度的数据结构（如重建缓冲区）的分配（或重新分配）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Color Space and Pixel Type (Key Frames Only)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 颜色空间和像素类型（仅限关键帧）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Field | Value                                    |
           +-------+------------------------------------------+
           | L(1)  | 1-bit color space type specification     |
           |       |                                          |
           | L(1)  | 1-bit pixel value clamping specification |
           +-------+------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Field | Value                                    |
           +-------+------------------------------------------+
           | L(1)  | 1-bit color space type specification     |
           |       |                                          |
           | L(1)  | 1-bit pixel value clamping specification |
           +-------+------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The color space type bit is encoded as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
颜色空间类型位编码如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 - YUV color space similar to the YCrCb color space defined in [ITU-R_BT.601]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0-YUV颜色空间，类似于[ITU-R_BT.601]中定义的YCrCb颜色空间
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 - Reserved for future use
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1-保留供将来使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pixel value clamping type bit is encoded as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
像素值箝位类型位编码如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 - Decoders are required to clamp the reconstructed pixel values to between 0 and 255 (inclusive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0-需要使用解码器将重建的像素值钳制在0和255（包括0和255）之间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 - Reconstructed pixel values are guaranteed to be between 0 and 255; no clamping is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1-重建像素值保证在0到255之间；无需夹紧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information in this subsection does not appear in interframes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本小节中的信息不会出现在干涉图中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. Segment-Based Adjustments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.3. 基于分部的调整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This subsection contains probability and value information for implementing segment adaptive adjustments to default decoder behavior. The data in this subsection is used in the decoding of the ensuing per-segment information and applies to the entire frame. When segment adaptive adjustments are enabled, each macroblock will be assigned a segment ID. Macroblocks with the same segment ID belong to the same segment and have the same adaptive adjustments over default baseline values for the frame. The adjustments can be quantizer level or loop filter strength.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本小节包含对默认解码器行为实施段自适应调整的概率和值信息。本小节中的数据用于随后的每段信息的解码，并应用于整个帧。启用段自适应调整时，将为每个宏块分配一个段ID。具有相同段ID的宏块属于同一段，并且在帧的默认基线值上具有相同的自适应调整。调整可以是量化器电平或环路滤波器强度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The context for decoding this feature at the macroblock level is provided by a subsection in the frame header, which contains:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在宏块级别解码该特征的上下文由帧头中的子部分提供，该子部分包含：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A segmentation_enabled flag that enables the feature for this frame if set to 1, and disables it if set to 0. The following fields occur if the feature is enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 一个segmentation_enabled标志，如果设置为1，则启用此帧的功能，如果设置为0，则禁用该功能。如果启用该功能，则会出现以下字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. L(1) indicates if the segment map is updated for the current frame (update_mb_segmentation_map).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. L（1）表示是否为当前帧更新了段映射（更新\u mb\u segmentation\u映射）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. L(1) indicates if the segment feature data items are updated for the current frame (update_segment_feature_data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. L（1）表示是否为当前帧更新段特征数据项（更新段特征数据）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If Item 3 above (update_segment_feature_data) is 1, the following fields occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 如果上面的第3项（更新\段\特征\数据）为1，则出现以下字段：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
a. L(1), the mode of segment feature data (segment_feature_mode), can be absolute-value mode (0) or delta value mode (1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
a. L（1），段特征数据的模式（段特征模式），可以是绝对值模式（0）或增量值模式（1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
b. Segment feature data items are decoded segment by segment for each segment feature. For every data item, a one-bit flag indicates whether the item is 0, or a non-zero value to be decoded. If the value is non-zero, then the value is decoded as a magnitude L(n), followed by a one-bit sign (L(1) -- 0 for positive and 1 for negative). The length n can be looked up from a pre-defined length table for all feature data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
b. 段特征数据项针对每个段特征逐段解码。对于每个数据项，一位标志指示该项是0还是要解码的非零值。如果该值不为零，则该值被解码为幅值L（n），后跟一位符号（L（1）——0表示正，1表示负）。可以从预定义的长度表中查找所有特征数据的长度n。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the L(1) flag as noted in Item 2 above is set to 1, the probabilities of the decoding tree for the segment map are decoded from the bitstream. Each probability is decoded with a one-bit flag indicating whether the probability is the default value of 255 (flag is set to 0), or an 8-bit value, L(8), from the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 如果如上面项目2中所述的L（1）标志被设置为1，则从比特流解码段映射的解码树的概率。使用一位标志对每个概率进行解码，该标志指示概率是来自比特流的默认值255（标志设置为0）还是8位值L（8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout and semantics supporting this feature at the macroblock level are described in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第10节描述了在宏块级别支持此功能的布局和语义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. Loop Filter Type and Levels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.4. 环路滤波器类型和电平
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 supports two types of loop filters having different computational complexity. The following bits occur in the header to support the selection of the baseline type, strength, and sharpness behavior of the loop filter used for the current frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8支持两种计算复杂度不同的环路滤波器。以下位出现在标题中，以支持选择用于当前帧的循环过滤器的基线类型、强度和锐度行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       +-------+-------------------+
                       | Index | Description       |
                       +-------+-------------------+
                       | L(1)  | filter_type       |
                       |       |                   |
                       | L(6)  | loop_filter_level |
                       |       |                   |
                       | L(3)  | sharpness_level   |
                       +-------+-------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       +-------+-------------------+
                       | Index | Description       |
                       +-------+-------------------+
                       | L(1)  | filter_type       |
                       |       |                   |
                       | L(6)  | loop_filter_level |
                       |       |                   |
                       | L(3)  | sharpness_level   |
                       +-------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of these numbers will be further explained in Section 15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第15节将进一步解释这些数字的含义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 has a feature in the bitstream that enables adjustment of the loop filter level based on a macroblock&#39;s prediction mode and reference frame. The per-macroblock adjustment is done through delta values against the default loop filter level for the current frame. This subsection contains flag and value information for implementing per-macroblock loop filter level adjustment to default decoder behavior. The data in this section is used in the decoding of the ensuing per-macroblock information and applies to the entire frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8在比特流中具有一个特性，该特性使得能够基于宏块的预测模式和参考帧来调整循环滤波器电平。每宏块调整是根据当前帧的默认循环过滤器级别，通过增量值完成的。本小节包含用于将每个宏块循环滤波器电平调整到默认解码器行为的标志和值信息。该部分中的数据用于随后的每个宏块信息的解码，并应用于整个帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
L(1) is a one-bit flag indicating if the macroblock loop filter adjustment is on for the current frame. 0 means that such a feature is not supported in the current frame, and 1 means this feature is enabled for the current frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
L（1）是一位标志，指示当前帧的宏块循环滤波器调整是否开启。0表示当前帧不支持此功能，1表示当前帧已启用此功能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whether the adjustment is based on a reference frame or encoding mode, the adjustment of the loop filter level is done via a delta value against a baseline loop filter value. The delta values are updated for the current frame if an L(1) bit, mode_ref_lf_delta_update, takes the value 1. There are two groups of delta values: One group of delta values is for reference frame-based adjustments, and the other group is for mode-based adjustments. The number of delta values in the two groups is MAX_REF_LF_DELTAS and MAX_MODE_LF_DELTAS, respectively. For every value within the two groups, there is a one-bit L(1) to indicate if the particular value is updated. When one is updated (1), it is transmitted as a six-bit-magnitude L(6) followed by a one-bit sign flag (L(1) -- 0 for positive and 1 for negative).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论调整是基于参考帧还是编码模式，循环滤波器电平的调整都是通过相对于基线循环滤波器值的增量值来完成的。如果L（1）位mode_ref_lf_delta_update的值为1，则更新当前帧的delta值。有两组增量值：一组增量值用于基于参考帧的调整，另一组用于基于模式的调整。两组中的增量值数量分别为MAX_REF_LF_delta和MAX_MODE_LF_delta。对于两个组中的每个值，都有一个1位L（1）来指示是否更新了特定值。当一个被更新（1）时，它被传输为一个六位幅值L（6），后跟一位符号标志（L（1）——0表示正，1表示负）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. Token Partition and Partition Data Offsets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.5. 令牌分区和分区数据偏移
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 allows DCT coefficients to be packed into multiple partitions, besides the first partition with header and per-macroblock prediction information, so the decoder can perform parallel decoding in an efficient manner. A two-bit L(2) is used to indicate the number of coefficient data partitions within a compressed frame. The two bits are defined in the following table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8允许将DCT系数打包到多个分区中，除了第一个分区具有报头和每宏块预测信息之外，因此解码器可以高效地执行并行解码。两位L（2）用于指示压缩帧内系数数据分区的数量。下表中定义了这两个位：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 +-------+-------+----------------------+
                 | Bit 1 | Bit 0 | Number of Partitions |
                 +-------+-------+----------------------+
                 | 0     | 0     | 1                    |
                 |       |       |                      |
                 | 0     | 1     | 2                    |
                 |       |       |                      |
                 | 1     | 0     | 4                    |
                 |       |       |                      |
                 | 1     | 1     | 8                    |
                 +-------+-------+----------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 +-------+-------+----------------------+
                 | Bit 1 | Bit 0 | Number of Partitions |
                 +-------+-------+----------------------+
                 | 0     | 0     | 1                    |
                 |       |       |                      |
                 | 0     | 1     | 2                    |
                 |       |       |                      |
                 | 1     | 0     | 4                    |
                 |       |       |                      |
                 | 1     | 1     | 8                    |
                 +-------+-------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Offsets are embedded in the bitstream to provide the decoder direct access to token partitions. If the number of data partitions is greater than 1, the size of each partition (except the last) is written in 3 bytes (24 bits). The size of the last partition is the remainder of the data not used by any of the previous partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
偏移量嵌入在比特流中，以便解码器直接访问令牌分区。如果数据分区的数量大于1，则每个分区（最后一个除外）的大小以3字节（24位）写入。最后一个分区的大小是前一个分区未使用的剩余数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The partitioned data are consecutive in the bitstream, so the size can also be used to calculate the offset of each partition. The following pseudocode illustrates how the size/offset is defined by the three bytes in the bitstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分区数据在比特流中是连续的，因此大小也可用于计算每个分区的偏移量。以下伪代码说明了如何通过位流中的三个字节定义大小/偏移量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Offset/size  =  (uint32)(byte0) + ((uint32)(byte1)&lt;&lt;8)
     + ((uint32)(byte2)&lt;&lt;16);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Offset/size  =  (uint32)(byte0) + ((uint32)(byte1)&lt;&lt;8)
     + ((uint32)(byte2)&lt;&lt;16);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. Dequantization Indices
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.6. 去量化指数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All residue signals are specified via a quantized 4x4 DCT applied to the Y, U, V, or Y2 subblocks of a macroblock. As detailed in Section 14, before inverting the transform, each decoded coefficient is multiplied by one of six dequantization factors, the choice of which depends on the plane (Y, chroma = U or V, Y2) and coefficient position (DC = coefficient 0, AC = coefficients 1-15). The six values are specified using 7-bit indices into six corresponding fixed tables (the tables are given in Section 14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有剩余信号通过应用于宏块的Y、U、V或Y2子块的量化4x4 DCT来指定。如第14节所述，在逆变换变换之前，每个解码系数乘以六个去量化因子中的一个，其选择取决于平面（Y，色度=U或V，Y2）和系数位置（DC=系数0，AC=系数1-15）。使用7位索引将六个值指定为六个相应的固定表（表在第14节中给出）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first 7-bit index gives the dequantization table index for Y-plane AC coefficients, called yac_qi. It is always coded and acts as a baseline for the other 5 quantization indices, each of which is represented by a delta from this baseline index. Pseudocode for reading the indices follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第一个7位索引给出Y平面AC系数的去量化表索引，称为yac_qi。它总是被编码并充当其他5个量化索引的基线，每个量化索引都由该基线索引的增量表示。用于读取索引的伪代码如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   yac_qi     = L(7);           /* Y ac index always specified */
   ydc_delta  = F? delta(): 0;  /* Y dc delta specified if
                                   flag is true */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   yac_qi     = L(7);           /* Y ac index always specified */
   ydc_delta  = F? delta(): 0;  /* Y dc delta specified if
                                   flag is true */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   y2dc_delta = F? delta(): 0;  /* Y2 dc delta specified if
                                   flag is true */
   y2ac_delta = F? delta(): 0;  /* Y2 ac delta specified if
                                   flag is true */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   y2dc_delta = F? delta(): 0;  /* Y2 dc delta specified if
                                   flag is true */
   y2ac_delta = F? delta(): 0;  /* Y2 ac delta specified if
                                   flag is true */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   uvdc_delta = F? delta(): 0;  /* chroma dc delta specified
                                   if flag is true */
   uvac_delta = F? delta(): 0;  /* chroma ac delta specified
                                   if flag is true */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   uvdc_delta = F? delta(): 0;  /* chroma dc delta specified
                                   if flag is true */
   uvac_delta = F? delta(): 0;  /* chroma ac delta specified
                                   if flag is true */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where delta() is the process to read 5 bits from the bitstream to determine a signed delta value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中delta（）是从比特流中读取5位以确定有符号delta值的过程：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       +-------+--------------------------------------------------+
       | Index | Description                                      |
       +-------+--------------------------------------------------+
       | L(4)  | Magnitude of delta                               |
       |       |                                                  |
       | L(1)  | Sign of delta, 0 for positive and 1 for negative |
       +-------+--------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       +-------+--------------------------------------------------+
       | Index | Description                                      |
       +-------+--------------------------------------------------+
       | L(4)  | Magnitude of delta                               |
       |       |                                                  |
       | L(1)  | Sign of delta, 0 for positive and 1 for negative |
       +-------+--------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. Refresh Golden Frame and Altref Frame
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.7. 刷新金色框架和Altref框架
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For key frames, both the golden frame and the altref frame are refreshed/ replaced by the current reconstructed frame, by default. For non-key frames, VP8 uses two bits to indicate whether the two frame buffers are refreshed, using the reconstructed current frame:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于关键帧，默认情况下，黄金帧和altref帧都将刷新/替换为当前重建帧。对于非关键帧，VP8使用两个位指示是否使用重建的当前帧刷新两个帧缓冲区：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------+----------------------------------------------------------+
   | Index | Description                                              |
   +-------+----------------------------------------------------------+
   | L(1)  | Whether golden frame is refreshed (0 for no, 1 for yes). |
   |       |                                                          |
   | L(1)  | Whether altref frame is refreshed (0 for no, 1 for yes). |
   +-------+----------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------+----------------------------------------------------------+
   | Index | Description                                              |
   +-------+----------------------------------------------------------+
   | L(1)  | Whether golden frame is refreshed (0 for no, 1 for yes). |
   |       |                                                          |
   | L(1)  | Whether altref frame is refreshed (0 for no, 1 for yes). |
   +-------+----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the flag for the golden frame is 0, VP8 uses 2 more bits in the bitstream to indicate whether the buffer (and which buffer) is copied to the golden frame, or if no buffer is copied:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当黄金帧的标志为0时，VP8在比特流中再使用2位来指示是否将缓冲区（以及哪个缓冲区）复制到黄金帧，或者如果没有复制缓冲区：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Index | Description                              |
           +-------+------------------------------------------+
           | L(2)  | Buffer copy flag for golden frame buffer |
           +-------+------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Index | Description                              |
           +-------+------------------------------------------+
           | L(2)  | Buffer copy flag for golden frame buffer |
           +-------+------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
哪里：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 means no buffer is copied to the golden frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0表示没有缓冲区复制到黄金帧
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 means last_frame is copied to the golden frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1表示最后一帧复制到黄金帧
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2 means alt_ref_frame is copied to the golden frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2表示alt_ref_帧复制到黄金帧
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, when the flag for altref is 0, VP8 uses 2 bits in the bitstream to indicate which buffer is copied to alt_ref_frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类似地，当altref的标志为0时，VP8使用位流中的2位来指示将哪个缓冲区复制到alt_ref_帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Index | Description                              |
           +-------+------------------------------------------+
           | L(2)  | Buffer copy flag for altref frame buffer |
           +-------+------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-------+------------------------------------------+
           | Index | Description                              |
           +-------+------------------------------------------+
           | L(2)  | Buffer copy flag for altref frame buffer |
           +-------+------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
哪里：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 means no buffer is copied to the altref frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0表示未将缓冲区复制到altref帧
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 means last_frame is copied to the altref frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1表示最后一帧复制到altref帧
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2 means golden_frame is copied to the altref frame
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2表示金色框架复制到altref框架
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two bits are transmitted for ref_frame_sign_bias for golden_frame and alt_ref_frame, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分别为黄金帧和alt\u ref\u帧的ref\u frame\u sign\u bias发送两位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                +-------+---------------------------------+
                | Index | Description                     |
                +-------+---------------------------------+
                | L(1)  | Sign bias flag for golden frame |
                |       |                                 |
                | L(1)  | Sign bias flag for altref frame |
                +-------+---------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                +-------+---------------------------------+
                | Index | Description                     |
                +-------+---------------------------------+
                | L(1)  | Sign bias flag for golden frame |
                |       |                                 |
                | L(1)  | Sign bias flag for altref frame |
                +-------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These values are used to control the sign of the motion vectors when a golden frame or an altref frame is used as the reference frame for a macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当黄金帧或altref帧用作宏块的参考帧时，这些值用于控制运动向量的符号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. Refresh Last Frame Buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.8. 刷新最后一帧缓冲区
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 uses one bit, L(1), to indicate if the last frame reference buffer is refreshed using the constructed current frame. On a key frame, this bit is overridden, and the last frame buffer is always refreshed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8使用一个位L（1）来指示是否使用构造的当前帧刷新最后一个帧参考缓冲区。在关键帧上，此位被覆盖，并且始终刷新最后一个帧缓冲区。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. DCT Coefficient Probability Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.9. DCT系数概率更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This field contains updates to the probability tables used to decode DCT coefficients. For each of the probabilities in the tables, there is an L(1) flag indicating if the probability is updated for the current frame, and if the L(1) flag is set to 1, there follows an additional 8-bit value representing the new probability value. These tables are maintained across interframes but are of course replaced with their defaults at the beginning of every key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此字段包含用于解码DCT系数的概率表的更新。对于表中的每个概率，存在一个L（1）标志，指示是否针对当前帧更新了概率，并且如果L（1）标志被设置为1，则跟随表示新概率值的附加8位值。这些表格在帧间进行维护，但在每个关键帧的开头，当然会替换为其默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout and semantics of this field will be taken up in Section 13.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该字段的布局和语义将在第13节中讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10. Remaining Frame Header Data (Non-Key Frame)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.10. 剩余帧头数据（非关键帧）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------+-----------------------------------------------------------+
   | Index | Description                                               |
   +-------+-----------------------------------------------------------+
   | L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |
   |       | if skipping of macroblocks with no non-zero coefficients  |
   |       | is enabled.  If it is set to 0, then prob_skip_false is   |
   |       | not read and mb_skip_coeff is forced to 0 for all         |
   |       | macroblocks (see Sections 11.1 and 12.1).                 |
   |       |                                                           |
   | L(8)  | prob_skip_false = probability used for decoding a         |
   |       | macroblock-level flag, which indicates if a macroblock    |
   |       | has any non-zero coefficients.  Only read if              |
   |       | mb_no_skip_coeff is 1.                                    |
   |       |                                                           |
   | L(8)  | prob_intra = probability that a macroblock is &#34;intra&#34;     |
   |       | predicted (that is, predicted from the already-encoded    |
   |       | portions of the current frame), as opposed to &#34;inter&#34;     |
   |       | predicted (that is, predicted from the contents of a      |
   |       | prior frame).                                             |
   |       |                                                           |
   | L(8)  | prob_last = probability that an inter-predicted           |
   |       | macroblock is predicted from the immediately previous     |
   |       | frame, as opposed to the most recent golden frame or      |
   |       | altref frame.                                             |
   |       |                                                           |
   | L(8)  | prob_gf = probability that an inter-predicted macroblock  |
   |       | is predicted from the most recent golden frame, as        |
   |       | opposed to the altref frame.                              |
   |       |                                                           |
   | F     | If true, followed by four L(8)s updating the              |
   |       | probabilities for the different types of intra-prediction |
   |       | for the Y plane.  These probabilities correspond to the   |
   |       | four interior nodes of the decoding tree for intra-Y      |
   |       | modes in an interframe, that is, the even positions in    |
   |       | the ymode_tree array given above.                         |
   |       |                                                           |
   | F     | If true, followed by three L(8)s updating the             |
   |       | probabilities for the different types of intra-prediction |
   |       | for the chroma planes.  These probabilities correspond to |
   |       | the even positions in the uv_mode_tree array given above. |
   |       |                                                           |
   | X     | Motion vector probability update.  Details are given in   |
   |       | Section 17.2, &#34;Probability Updates&#34;.                      |
   +-------+-----------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------+-----------------------------------------------------------+
   | Index | Description                                               |
   +-------+-----------------------------------------------------------+
   | L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |
   |       | if skipping of macroblocks with no non-zero coefficients  |
   |       | is enabled.  If it is set to 0, then prob_skip_false is   |
   |       | not read and mb_skip_coeff is forced to 0 for all         |
   |       | macroblocks (see Sections 11.1 and 12.1).                 |
   |       |                                                           |
   | L(8)  | prob_skip_false = probability used for decoding a         |
   |       | macroblock-level flag, which indicates if a macroblock    |
   |       | has any non-zero coefficients.  Only read if              |
   |       | mb_no_skip_coeff is 1.                                    |
   |       |                                                           |
   | L(8)  | prob_intra = probability that a macroblock is &#34;intra&#34;     |
   |       | predicted (that is, predicted from the already-encoded    |
   |       | portions of the current frame), as opposed to &#34;inter&#34;     |
   |       | predicted (that is, predicted from the contents of a      |
   |       | prior frame).                                             |
   |       |                                                           |
   | L(8)  | prob_last = probability that an inter-predicted           |
   |       | macroblock is predicted from the immediately previous     |
   |       | frame, as opposed to the most recent golden frame or      |
   |       | altref frame.                                             |
   |       |                                                           |
   | L(8)  | prob_gf = probability that an inter-predicted macroblock  |
   |       | is predicted from the most recent golden frame, as        |
   |       | opposed to the altref frame.                              |
   |       |                                                           |
   | F     | If true, followed by four L(8)s updating the              |
   |       | probabilities for the different types of intra-prediction |
   |       | for the Y plane.  These probabilities correspond to the   |
   |       | four interior nodes of the decoding tree for intra-Y      |
   |       | modes in an interframe, that is, the even positions in    |
   |       | the ymode_tree array given above.                         |
   |       |                                                           |
   | F     | If true, followed by three L(8)s updating the             |
   |       | probabilities for the different types of intra-prediction |
   |       | for the chroma planes.  These probabilities correspond to |
   |       | the even positions in the uv_mode_tree array given above. |
   |       |                                                           |
   | X     | Motion vector probability update.  Details are given in   |
   |       | Section 17.2, &#34;Probability Updates&#34;.                      |
   +-------+-----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding of this portion of the frame header is handled in the reference decoder file dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这部分帧头的解码在参考解码器文件dixie.c（第20.4节）中处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11. Remaining Frame Header Data (Key Frame)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.11. 剩余帧头数据（关键帧）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------+-----------------------------------------------------------+
   | Index | Description                                               |
   +-------+-----------------------------------------------------------+
   | L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |
   |       | if skipping of macroblocks with no non-zero coefficients  |
   |       | is enabled.  If it is set to 0, then prob_skip_false is   |
   |       | not read and mb_skip_coeff is forced to 0 for all         |
   |       | macroblocks (see Sections 11.1 and 12.1).                 |
   |       |                                                           |
   | L(8)  | prob_skip_false = Probability used for decoding a         |
   |       | macroblock-level flag, which indicates if a macroblock    |
   |       | has any non-zero coefficients.  Only read if              |
   |       | mb_no_skip_coeff is 1.                                    |
   +-------+-----------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------+-----------------------------------------------------------+
   | Index | Description                                               |
   +-------+-----------------------------------------------------------+
   | L(1)  | mb_no_skip_coeff.  This flag indicates at the frame level |
   |       | if skipping of macroblocks with no non-zero coefficients  |
   |       | is enabled.  If it is set to 0, then prob_skip_false is   |
   |       | not read and mb_skip_coeff is forced to 0 for all         |
   |       | macroblocks (see Sections 11.1 and 12.1).                 |
   |       |                                                           |
   | L(8)  | prob_skip_false = Probability used for decoding a         |
   |       | macroblock-level flag, which indicates if a macroblock    |
   |       | has any non-zero coefficients.  Only read if              |
   |       | mb_no_skip_coeff is 1.                                    |
   +-------+-----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding of this portion of the frame header is handled in the reference decoder file modemv.c (Section 20.11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧头这一部分的解码在参考解码器文件modemv.c（第20.11节）中处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the layout of the frame header. The remainder of the first data partition consists of macroblock-level prediction data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这就完成了框架标题的布局。第一数据分区的其余部分由宏块级预测数据组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the frame header is processed, all probabilities needed to decode the prediction and residue data are known and will not change until the next frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在处理帧头之后，解码预测和剩余数据所需的所有概率都是已知的，并且在下一帧之前不会改变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Segment-Based Feature Adjustments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 基于段的特征调整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every macroblock may optionally override some of the default behaviors of the decoder. Specifically, VP8 uses segment-based adjustments to support changing quantizer level and loop filter level for a macroblock. When the segment-based adjustment feature is enabled for a frame, each macroblock within the frame is coded with a segment_id. This effectively segments all the macroblocks in the current frame into a number of different segments. Macroblocks within the same segment behave exactly the same for quantizer and loop filter level adjustments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个宏块可以选择性地覆盖解码器的一些默认行为。具体而言，VP8使用基于段的调整来支持改变宏块的量化器电平和环路滤波器电平。当为帧启用基于段的调整功能时，帧内的每个宏块都使用段id进行编码。这有效地将当前帧中的所有宏块分割为多个不同的段。对于量化器和环路滤波器电平调整，同一段中的宏块的行为完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If both the segmentation_enabled and update_mb_segmentation_map flags in subsection B of the frame header take a value of 1, the prediction data for each (intra- or inter-coded) macroblock begins with a specification of segment_id for the current macroblock. It is decoded using this simple tree ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果帧头的分段B中的分段启用和更新分段映射标志的值均为1，则每个（帧内或帧间编码的）宏块的预测数据从当前宏块的分段id的指定开始。它是用这个简单的树解码的。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index mb_segment_tree [2 * (4-1)] =
     {
       2,  4,     /* root: &#34;0&#34;, &#34;1&#34; subtrees */
       -0, -1,    /* &#34;00&#34; = 0th value, &#34;01&#34; = 1st value */
        -2, -3    /* &#34;10&#34; = 2nd value, &#34;11&#34; = 3rd value */
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index mb_segment_tree [2 * (4-1)] =
     {
       2,  4,     /* root: &#34;0&#34;, &#34;1&#34; subtrees */
       -0, -1,    /* &#34;00&#34; = 0th value, &#34;01&#34; = 1st value */
        -2, -3    /* &#34;10&#34; = 2nd value, &#34;11&#34; = 3rd value */
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
... combined with a 3-entry probability table, mb_segment_tree_probs[3]. The macroblock&#39;s segment_id is used later in the decoding process to look into the segment_feature_data table and determine how the quantizer and loop filter levels are adjusted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
... 结合一个三项概率表，mb_段_树_问题[3]。宏块的segment_id稍后在解码过程中用于查看segment_feature_数据表并确定如何调整量化器和环路滤波器电平。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoding of segment_id, together with the parsing of intra-prediction modes (which is taken up next), is implemented in the reference decoder file modemv.c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在参考解码器文件modemv.c中实现段_id的解码以及帧内预测模式的解析（下一步讨论）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Key Frame Macroblock Prediction Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 关键帧宏块预测记录
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After specifying the features described above, the macroblock prediction record next specifies the prediction mode used for the macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在指定上述特征之后，宏块预测记录接下来指定用于宏块的预测模式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. mb_skip_coeff
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. mb_skip_coeff
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single bool flag is decoded using prob_skip_false if and only if mb_no_skip_coeff is set to 1 (see Sections 9.10 and 9.11). If mb_no_skip_coeff is set to 0, then this value defaults to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当且仅当mb_no_skip_coeff设置为1时（见第9.10节和第9.11节），使用prob_skip_false对单个bool标志进行解码。如果mb_no_skip_coeff设置为0，则该值默认为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Luma Modes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 亮度模式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First comes the luma specification of type intra_mbmode, coded using the kf_ymode_tree, as described in Section 8 and repeated here for convenience:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
首先是intra_mbmode类型的luma规范，使用kf_ymode_树进行编码，如第8节所述，为了方便起见在此处重复：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       DC_PRED, /* predict DC using row above and column to the left */
       V_PRED,  /* predict rows using row above */
       H_PRED,  /* predict columns using column to the left */
       TM_PRED, /* propagate second differences a la &#34;True Motion&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       DC_PRED, /* predict DC using row above and column to the left */
       V_PRED,  /* predict rows using row above */
       H_PRED,  /* predict columns using column to the left */
       TM_PRED, /* propagate second differences a la &#34;True Motion&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_PRED,  /* each Y subblock is independently predicted */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_PRED,  /* each Y subblock is independently predicted */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_uv_modes = B_PRED,  /* first four modes apply to chroma */
       num_ymodes   /* all modes apply to luma */
   }
   intra_mbmode;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_uv_modes = B_PRED,  /* first four modes apply to chroma */
       num_ymodes   /* all modes apply to luma */
   }
   intra_mbmode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =
   {
    -B_PRED, 2,            /* root: B_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -DC_PRED, -V_PRED,   /* &#34;10&#34; subtree: DC_PRED = &#34;100&#34;,
                              V_PRED = &#34;101&#34; */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index kf_ymode_tree [2 * (num_ymodes - 1)] =
   {
    -B_PRED, 2,            /* root: B_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -DC_PRED, -V_PRED,   /* &#34;10&#34; subtree: DC_PRED = &#34;100&#34;,
                              V_PRED = &#34;101&#34; */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For key frames, the Y mode is decoded using a fixed probability array as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于关键帧，使用固定概率数组解码Y模式，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob kf_ymode_prob [num_ymodes - 1] = { 145, 156, 163, 128};
   Ymode = (intra_mbmode) treed_read(d, kf_ymode_tree, kf_ymode_prob);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob kf_ymode_prob [num_ymodes - 1] = { 145, 156, 163, 128};
   Ymode = (intra_mbmode) treed_read(d, kf_ymode_tree, kf_ymode_prob);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d is of course the bool_decoder being used to read the first data partition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d当然是用于读取第一个数据分区的bool_解码器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Ymode is B_PRED, it is followed by a (tree-coded) mode for each of the 16 Y subblocks. The 10 subblock modes and their coding tree are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果Ymode是B_PRED，则16个Y子块中的每一个子块后面都有一个（树编码）模式。10个子块模式及其编码树如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       B_DC_PRED,  /* predict DC using row above and column
                      to the left */
       B_TM_PRED,  /* propagate second differences a la
                      &#34;True Motion&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       B_DC_PRED,  /* predict DC using row above and column
                      to the left */
       B_TM_PRED,  /* propagate second differences a la
                      &#34;True Motion&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_VE_PRED,  /* predict rows using row above */
       B_HE_PRED,  /* predict columns using column to the left */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_VE_PRED,  /* predict rows using row above */
       B_HE_PRED,  /* predict columns using column to the left */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_LD_PRED,  /* southwest (left and down) 45 degree diagonal
                      prediction */
       B_RD_PRED,  /* southeast (right and down) &#34;&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_LD_PRED,  /* southwest (left and down) 45 degree diagonal
                      prediction */
       B_RD_PRED,  /* southeast (right and down) &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_VR_PRED,  /* SSE (vertical right) diagonal prediction */
       B_VL_PRED,  /* SSW (vertical left) &#34;&#34; */
       B_HD_PRED,  /* ESE (horizontal down) &#34;&#34; */
       B_HU_PRED,  /* ENE (horizontal up) &#34;&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       B_VR_PRED,  /* SSE (vertical right) diagonal prediction */
       B_VL_PRED,  /* SSW (vertical left) &#34;&#34; */
       B_HD_PRED,  /* ESE (horizontal down) &#34;&#34; */
       B_HU_PRED,  /* ENE (horizontal up) &#34;&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_intra_bmodes
   }
   intra_bmode;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_intra_bmodes
   }
   intra_bmode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Coding tree for the above, with implied codings as comments */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Coding tree for the above, with implied codings as comments */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index bmode_tree [2 * (num_intra_bmodes - 1)] =
   {
    -B_DC_PRED, 2,                   /* B_DC_PRED = &#34;0&#34; */
     -B_TM_PRED, 4,                  /* B_TM_PRED = &#34;10&#34; */
      -B_VE_PRED, 6,                 /* B_VE_PRED = &#34;110&#34; */
       8, 12,
        -B_HE_PRED, 10,              /* B_HE_PRED = &#34;11100&#34; */
         -B_RD_PRED, -B_VR_PRED,     /* B_RD_PRED = &#34;111010&#34;,
                                        B_VR_PRED = &#34;111011&#34; */
        -B_LD_PRED, 14,              /* B_LD_PRED = &#34;111110&#34; */
          -B_VL_PRED, 16,            /* B_VL_PRED = &#34;1111110&#34; */
            -B_HD_PRED, -B_HU_PRED   /* HD = &#34;11111110&#34;,
                                        HU = &#34;11111111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index bmode_tree [2 * (num_intra_bmodes - 1)] =
   {
    -B_DC_PRED, 2,                   /* B_DC_PRED = &#34;0&#34; */
     -B_TM_PRED, 4,                  /* B_TM_PRED = &#34;10&#34; */
      -B_VE_PRED, 6,                 /* B_VE_PRED = &#34;110&#34; */
       8, 12,
        -B_HE_PRED, 10,              /* B_HE_PRED = &#34;11100&#34; */
         -B_RD_PRED, -B_VR_PRED,     /* B_RD_PRED = &#34;111010&#34;,
                                        B_VR_PRED = &#34;111011&#34; */
        -B_LD_PRED, 14,              /* B_LD_PRED = &#34;111110&#34; */
          -B_VL_PRED, 16,            /* B_VL_PRED = &#34;1111110&#34; */
            -B_HD_PRED, -B_HU_PRED   /* HD = &#34;11111110&#34;,
                                        HU = &#34;11111111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first four modes are smaller versions of the similarly named 16x16 modes above, albeit with slightly different numbering. The last six &#34;diagonal&#34; modes are unique to luma subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前四种模式是上述类似命名的16x16模式的较小版本，尽管编号略有不同。最后六个“对角”模式是luma子块所特有的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Subblock Mode Contexts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. 子块模式上下文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding of subblock modes in key frames uses the modes already coded for the subblocks to the left of and above the subblock to select a probability array for decoding the current subblock mode. This is our first instance of contextual prediction, and there are several caveats associated with it:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
关键帧中的子块模式的编码使用已经为子块左侧和上方的子块编码的模式来选择用于解码当前子块模式的概率阵列。这是我们的第一个上下文预测实例，有几个与之相关的注意事项：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The adjacency relationships between subblocks are based on the normal default raster placement of the subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 子块之间的邻接关系基于子块的正常默认光栅放置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The adjacent subblocks need not lie in the current macroblock. The subblocks to the left of the left-edge subblocks 0, 4, 8, and 12 are the right-edge subblocks 3, 7, 11, and 15, respectively, of the (already coded) macroblock immediately to the left. Similarly, the subblocks above the top-edge subblocks 0, 1, 2, and 3 are the bottom-edge subblocks 12, 13, 14, and 15 of the already-coded macroblock immediately above us.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 相邻子块不必位于当前宏块中。左边缘子块0、4、8和12左侧的子块分别是紧靠左侧的（已编码的）宏块的右边缘子块3、7、11和15。类似地，上边缘子块0、1、2和3上方的子块是紧挨着我们上方的已编码宏块的下边缘子块12、13、14和15。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. For macroblocks on the top row or left edge of the image, some of the predictors will be non-existent. Such predictors are taken to have had the value B_DC_PRED, which, perhaps conveniently, takes the value 0 in the enumeration above. A simple management scheme for these contexts might maintain a row of above predictors and four left predictors. Before decoding the frame, the entire row is initialized to B_DC_PRED; before decoding each row of macroblocks, the four left predictors are also set to B_DC_PRED. After decoding a macroblock, the bottom four subblock modes are copied into the row predictor (at the current position, which then advances to be above the next macroblock), and the right four subblock modes are copied into the left predictor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 对于图像顶行或左边缘的宏块，某些预测器将不存在。这些预测值被认为具有值B_DC_PRED，这可能很方便，在上面的枚举中取值0。对于这些上下文，一个简单的管理方案可能会维护一行上述预测器和四个左预测器。在解码帧之前，整行被初始化为B_DC_PRED；在解码每行宏块之前，四个左预测器也被设置为B_DC_PRED。解码宏块后，将底部的四个子块模式复制到行预测器中（在当前位置，然后前进到下一个宏块的上方），并将右侧的四个子块模式复制到左侧预测器中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Many macroblocks will of course be coded using a 16x16 luma prediction mode. For the purpose of predicting ensuing subblock modes (only), such macroblocks derive a subblock mode, constant throughout the macroblock, from the 16x16 luma mode as follows: DC_PRED uses B_DC_PRED, V_PRED uses B_VE_PRED, H_PRED uses B_HE_PRED, and TM_PRED uses B_TM_PRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 当然，许多宏块将使用16x16 luma预测模式进行编码。为了预测随后的子块模式（仅限），此类宏块从16x16 luma模式导出整个宏块恒定的子块模式，如下所示：DC_PRED使用B_DC_PRED，V_PRED使用B_VE_PRED，H_PRED使用B_HE_PRED，TM_PRED使用B_TM_PRED。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Although we discuss interframe modes in Section 16, we remark here that, while interframes do use all the intra-coding modes described here and below, the subblock modes in an interframe are coded using a single constant probability array that does not depend on any context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 尽管我们在第16节中讨论了帧间模式，但我们在这里指出，虽然帧间确实使用这里和下面描述的所有帧内编码模式，但帧间中的子块模式使用不依赖于任何上下文的单个恒定概率数组进行编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The dependence of subblock mode probability on the nearby subblock mode context is most easily handled using a three-dimensional constant array:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子块模式概率对附近子块模式上下文的依赖性最容易使用三维常量数组处理：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes] [num_intra_bmodes-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const Prob kf_bmode_Prob[num_intra_bmodes][num_intra_bmodes][num_intra_bmodes][num_intra_bmodes-1]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The outer two dimensions of this array are indexed by the already-coded subblock modes above and to the left of the current block, respectively. The inner dimension is a typical tree probability list whose indices correspond to the even indices of the bmode_tree above. The mode for the j^(th) luma subblock is then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此数组的外部二维分别由当前块上方和左侧已编码的子块模式索引。内维是一个典型的树概率列表，其索引对应于上面bmode_树的偶数索引。然后，j^（th）luma子块的模式为
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Bmode = (intra_bmode) treed_read(d, bmode_tree, kf_bmode_prob
     [A] [L]);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Bmode = (intra_bmode) treed_read(d, bmode_tree, kf_bmode_prob
     [A] [L]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where the 4x4 Y subblock index j varies from 0 to 15 in raster order, and A and L are the modes used above and to the left of the j^(th) subblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中，4x4 Y子块索引j按光栅顺序从0到15变化，A和L是上面和j^（th）子块左侧使用的模式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the kf_bmode_prob array are given at the end of this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kf_bmode_prob数组的内容在本节末尾给出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. Chroma Modes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. 色度模式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the Y mode (and optional subblock mode) specification comes the chroma mode. The chroma modes are a subset of the Y modes and are coded using the uv_mode_tree, as described in Section 8 and repeated here for convenience:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在Y模式（和可选子块模式）规范之后是色度模式。色度模式是Y模式的子集，并使用uv_模式_树进行编码，如第8节所述，为方便起见，在此重复：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =
   {
    -DC_PRED, 2,           /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     -V_PRED, 4,           /* &#34;1&#34; subtree:  V_PRED = &#34;10&#34;,
                              &#34;11&#34; subtree */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index uv_mode_tree [2 * (num_uv_modes - 1)] =
   {
    -DC_PRED, 2,           /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     -V_PRED, 4,           /* &#34;1&#34; subtree:  V_PRED = &#34;10&#34;,
                              &#34;11&#34; subtree */
      -H_PRED, -TM_PRED    /* &#34;11&#34; subtree: H_PRED = &#34;110&#34;,
                              TM_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As for the Y modes (in a key frame), the chroma modes are coded using a fixed, contextless probability table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于Y模式（在关键帧中），色度模式使用固定的、无上下文的概率表进行编码：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob kf_uv_mode_prob [num_uv_modes - 1] = { 142, 114, 183};
   uv_mode = (intra_mbmode) treed_read(d, uv_mode_tree,
     kf_uv_mode_prob);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob kf_uv_mode_prob [num_uv_modes - 1] = { 142, 114, 183};
   uv_mode = (intra_mbmode) treed_read(d, uv_mode_tree,
     kf_uv_mode_prob);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the description of macroblock prediction coding for key frames. As will be discussed in Section 16, the coding of intra modes within interframes is similar, but not identical, to that described here (and in the reference code) for prediction modes and, indeed, for all tree-coded data in VP8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这就完成了对关键帧的宏块预测编码的描述。如将在第16节中讨论的，帧间内模式的编码与此处（和参考代码中）针对预测模式以及VP8中的所有树编码数据描述的编码相似，但不相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5. Subblock Mode Probability Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.5. 子块模式概率表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, here is the fixed probability table used to decode subblock modes in key frames.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，这里是用于解码关键帧中的子块模式的固定概率表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes]
     [num_intra_bmodes-1] =
   {
     {
       { 231, 120,  48,  89, 115, 113, 120, 152, 112},
       { 152, 179,  64, 126, 170, 118,  46,  70,  95},
       { 175,  69, 143,  80,  85,  82,  72, 155, 103},
       {  56,  58,  10, 171, 218, 189,  17,  13, 152},
       { 144,  71,  10,  38, 171, 213, 144,  34,  26},
       { 114,  26,  17, 163,  44, 195,  21,  10, 173},
       { 121,  24,  80, 195,  26,  62,  44,  64,  85},
       { 170,  46,  55,  19, 136, 160,  33, 206,  71},
       {  63,  20,   8, 114, 114, 208,  12,   9, 226},
       {  81,  40,  11,  96, 182,  84,  29,  16,  36}
     },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob kf_bmode_prob [num_intra_bmodes] [num_intra_bmodes]
     [num_intra_bmodes-1] =
   {
     {
       { 231, 120,  48,  89, 115, 113, 120, 152, 112},
       { 152, 179,  64, 126, 170, 118,  46,  70,  95},
       { 175,  69, 143,  80,  85,  82,  72, 155, 103},
       {  56,  58,  10, 171, 218, 189,  17,  13, 152},
       { 144,  71,  10,  38, 171, 213, 144,  34,  26},
       { 114,  26,  17, 163,  44, 195,  21,  10, 173},
       { 121,  24,  80, 195,  26,  62,  44,  64,  85},
       { 170,  46,  55,  19, 136, 160,  33, 206,  71},
       {  63,  20,   8, 114, 114, 208,  12,   9, 226},
       {  81,  40,  11,  96, 182,  84,  29,  16,  36}
     },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
       { 134, 183,  89, 137,  98, 101, 106, 165, 148},
       {  72, 187, 100, 130, 157, 111,  32,  75,  80},
       {  66, 102, 167,  99,  74,  62,  40, 234, 128},
       {  41,  53,   9, 178, 241, 141,  26,   8, 107},
       { 104,  79,  12,  27, 217, 255,  87,  17,   7},
       {  74,  43,  26, 146,  73, 166,  49,  23, 157},
       {  65,  38, 105, 160,  51,  52,  31, 115, 128},
       {  87,  68,  71,  44, 114,  51,  15, 186,  23},
       {  47,  41,  14, 110, 182, 183,  21,  17, 194},
       {  66,  45,  25, 102, 197, 189,  23,  18,  22}
     },
     {
       {  88,  88, 147, 150,  42,  46,  45, 196, 205},
       {  43,  97, 183, 117,  85,  38,  35, 179,  61},
       {  39,  53, 200,  87,  26,  21,  43, 232, 171},
       {  56,  34,  51, 104, 114, 102,  29,  93,  77},
       { 107,  54,  32,  26,  51,   1,  81,  43,  31},
       {  39,  28,  85, 171,  58, 165,  90,  98,  64},
       {  34,  22, 116, 206,  23,  34,  43, 166,  73},
       {  68,  25, 106,  22,  64, 171,  36, 225, 114},
       {  34,  19,  21, 102, 132, 188,  16,  76, 124},
       {  62,  18,  78,  95,  85,  57,  50,  48,  51}
     },
     {
       { 193, 101,  35, 159, 215, 111,  89,  46, 111},
       {  60, 148,  31, 172, 219, 228,  21,  18, 111},
       { 112, 113,  77,  85, 179, 255,  38, 120, 114},
       {  40,  42,   1, 196, 245, 209,  10,  25, 109},
       { 100,  80,   8,  43, 154,   1,  51,  26,  71},
       {  88,  43,  29, 140, 166, 213,  37,  43, 154},
       {  61,  63,  30, 155,  67,  45,  68,   1, 209},
       { 142,  78,  78,  16, 255, 128,  34, 197, 171},
       {  41,  40,   5, 102, 211, 183,   4,   1, 221},
       {  51,  50,  17, 168, 209, 192,  23,  25,  82}
     },
     {
       { 125,  98,  42,  88, 104,  85, 117, 175,  82},
       {  95,  84,  53,  89, 128, 100, 113, 101,  45},
       {  75,  79, 123,  47,  51, 128,  81, 171,   1},
       {  57,  17,   5,  71, 102,  57,  53,  41,  49},
       { 115,  21,   2,  10, 102, 255, 166,  23,   6},
       {  38,  33,  13, 121,  57,  73,  26,   1,  85},
       {  41,  10,  67, 138,  77, 110,  90,  47, 114},
       { 101,  29,  16,  10,  85, 128, 101, 196,  26},
       {  57,  18,  10, 102, 102, 213,  34,  20,  43},
       { 117,  20,  15,  36, 163, 128,  68,   1,  26}
     },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
       { 134, 183,  89, 137,  98, 101, 106, 165, 148},
       {  72, 187, 100, 130, 157, 111,  32,  75,  80},
       {  66, 102, 167,  99,  74,  62,  40, 234, 128},
       {  41,  53,   9, 178, 241, 141,  26,   8, 107},
       { 104,  79,  12,  27, 217, 255,  87,  17,   7},
       {  74,  43,  26, 146,  73, 166,  49,  23, 157},
       {  65,  38, 105, 160,  51,  52,  31, 115, 128},
       {  87,  68,  71,  44, 114,  51,  15, 186,  23},
       {  47,  41,  14, 110, 182, 183,  21,  17, 194},
       {  66,  45,  25, 102, 197, 189,  23,  18,  22}
     },
     {
       {  88,  88, 147, 150,  42,  46,  45, 196, 205},
       {  43,  97, 183, 117,  85,  38,  35, 179,  61},
       {  39,  53, 200,  87,  26,  21,  43, 232, 171},
       {  56,  34,  51, 104, 114, 102,  29,  93,  77},
       { 107,  54,  32,  26,  51,   1,  81,  43,  31},
       {  39,  28,  85, 171,  58, 165,  90,  98,  64},
       {  34,  22, 116, 206,  23,  34,  43, 166,  73},
       {  68,  25, 106,  22,  64, 171,  36, 225, 114},
       {  34,  19,  21, 102, 132, 188,  16,  76, 124},
       {  62,  18,  78,  95,  85,  57,  50,  48,  51}
     },
     {
       { 193, 101,  35, 159, 215, 111,  89,  46, 111},
       {  60, 148,  31, 172, 219, 228,  21,  18, 111},
       { 112, 113,  77,  85, 179, 255,  38, 120, 114},
       {  40,  42,   1, 196, 245, 209,  10,  25, 109},
       { 100,  80,   8,  43, 154,   1,  51,  26,  71},
       {  88,  43,  29, 140, 166, 213,  37,  43, 154},
       {  61,  63,  30, 155,  67,  45,  68,   1, 209},
       { 142,  78,  78,  16, 255, 128,  34, 197, 171},
       {  41,  40,   5, 102, 211, 183,   4,   1, 221},
       {  51,  50,  17, 168, 209, 192,  23,  25,  82}
     },
     {
       { 125,  98,  42,  88, 104,  85, 117, 175,  82},
       {  95,  84,  53,  89, 128, 100, 113, 101,  45},
       {  75,  79, 123,  47,  51, 128,  81, 171,   1},
       {  57,  17,   5,  71, 102,  57,  53,  41,  49},
       { 115,  21,   2,  10, 102, 255, 166,  23,   6},
       {  38,  33,  13, 121,  57,  73,  26,   1,  85},
       {  41,  10,  67, 138,  77, 110,  90,  47, 114},
       { 101,  29,  16,  10,  85, 128, 101, 196,  26},
       {  57,  18,  10, 102, 102, 213,  34,  20,  43},
       { 117,  20,  15,  36, 163, 128,  68,   1,  26}
     },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
       { 138,  31,  36, 171,  27, 166,  38,  44, 229},
       {  67,  87,  58, 169,  82, 115,  26,  59, 179},
       {  63,  59,  90, 180,  59, 166,  93,  73, 154},
       {  40,  40,  21, 116, 143, 209,  34,  39, 175},
       {  57,  46,  22,  24, 128,   1,  54,  17,  37},
       {  47,  15,  16, 183,  34, 223,  49,  45, 183},
       {  46,  17,  33, 183,   6,  98,  15,  32, 183},
       {  65,  32,  73, 115,  28, 128,  23, 128, 205},
       {  40,   3,   9, 115,  51, 192,  18,   6, 223},
       {  87,  37,   9, 115,  59,  77,  64,  21,  47}
     },
     {
       { 104,  55,  44, 218,   9,  54,  53, 130, 226},
       {  64,  90,  70, 205,  40,  41,  23,  26,  57},
       {  54,  57, 112, 184,   5,  41,  38, 166, 213},
       {  30,  34,  26, 133, 152, 116,  10,  32, 134},
       {  75,  32,  12,  51, 192, 255, 160,  43,  51},
       {  39,  19,  53, 221,  26, 114,  32,  73, 255},
       {  31,   9,  65, 234,   2,  15,   1, 118,  73},
       {  88,  31,  35,  67, 102,  85,  55, 186,  85},
       {  56,  21,  23, 111,  59, 205,  45,  37, 192},
       {  55,  38,  70, 124,  73, 102,   1,  34,  98}
     },
     {
       { 102,  61,  71,  37,  34,  53,  31, 243, 192},
       {  69,  60,  71,  38,  73, 119,  28, 222,  37},
       {  68,  45, 128,  34,   1,  47,  11, 245, 171},
       {  62,  17,  19,  70, 146,  85,  55,  62,  70},
       {  75,  15,   9,   9,  64, 255, 184, 119,  16},
       {  37,  43,  37, 154, 100, 163,  85, 160,   1},
       {  63,   9,  92, 136,  28,  64,  32, 201,  85},
       {  86,   6,  28,   5,  64, 255,  25, 248,   1},
       {  56,   8,  17, 132, 137, 255,  55, 116, 128},
       {  58,  15,  20,  82, 135,  57,  26, 121,  40}
     },
     {
       { 164,  50,  31, 137, 154, 133,  25,  35, 218},
       {  51, 103,  44, 131, 131, 123,  31,   6, 158},
       {  86,  40,  64, 135, 148, 224,  45, 183, 128},
       {  22,  26,  17, 131, 240, 154,  14,   1, 209},
       {  83,  12,  13,  54, 192, 255,  68,  47,  28},
       {  45,  16,  21,  91,  64, 222,   7,   1, 197},
       {  56,  21,  39, 155,  60, 138,  23, 102, 213},
       {  85,  26,  85,  85, 128, 128,  32, 146, 171},
       {  18,  11,   7,  63, 144, 171,   4,   4, 246},
       {  35,  27,  10, 146, 174, 171,  12,  26, 128}
     },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
       { 138,  31,  36, 171,  27, 166,  38,  44, 229},
       {  67,  87,  58, 169,  82, 115,  26,  59, 179},
       {  63,  59,  90, 180,  59, 166,  93,  73, 154},
       {  40,  40,  21, 116, 143, 209,  34,  39, 175},
       {  57,  46,  22,  24, 128,   1,  54,  17,  37},
       {  47,  15,  16, 183,  34, 223,  49,  45, 183},
       {  46,  17,  33, 183,   6,  98,  15,  32, 183},
       {  65,  32,  73, 115,  28, 128,  23, 128, 205},
       {  40,   3,   9, 115,  51, 192,  18,   6, 223},
       {  87,  37,   9, 115,  59,  77,  64,  21,  47}
     },
     {
       { 104,  55,  44, 218,   9,  54,  53, 130, 226},
       {  64,  90,  70, 205,  40,  41,  23,  26,  57},
       {  54,  57, 112, 184,   5,  41,  38, 166, 213},
       {  30,  34,  26, 133, 152, 116,  10,  32, 134},
       {  75,  32,  12,  51, 192, 255, 160,  43,  51},
       {  39,  19,  53, 221,  26, 114,  32,  73, 255},
       {  31,   9,  65, 234,   2,  15,   1, 118,  73},
       {  88,  31,  35,  67, 102,  85,  55, 186,  85},
       {  56,  21,  23, 111,  59, 205,  45,  37, 192},
       {  55,  38,  70, 124,  73, 102,   1,  34,  98}
     },
     {
       { 102,  61,  71,  37,  34,  53,  31, 243, 192},
       {  69,  60,  71,  38,  73, 119,  28, 222,  37},
       {  68,  45, 128,  34,   1,  47,  11, 245, 171},
       {  62,  17,  19,  70, 146,  85,  55,  62,  70},
       {  75,  15,   9,   9,  64, 255, 184, 119,  16},
       {  37,  43,  37, 154, 100, 163,  85, 160,   1},
       {  63,   9,  92, 136,  28,  64,  32, 201,  85},
       {  86,   6,  28,   5,  64, 255,  25, 248,   1},
       {  56,   8,  17, 132, 137, 255,  55, 116, 128},
       {  58,  15,  20,  82, 135,  57,  26, 121,  40}
     },
     {
       { 164,  50,  31, 137, 154, 133,  25,  35, 218},
       {  51, 103,  44, 131, 131, 123,  31,   6, 158},
       {  86,  40,  64, 135, 148, 224,  45, 183, 128},
       {  22,  26,  17, 131, 240, 154,  14,   1, 209},
       {  83,  12,  13,  54, 192, 255,  68,  47,  28},
       {  45,  16,  21,  91,  64, 222,   7,   1, 197},
       {  56,  21,  39, 155,  60, 138,  23, 102, 213},
       {  85,  26,  85,  85, 128, 128,  32, 146, 171},
       {  18,  11,   7,  63, 144, 171,   4,   4, 246},
       {  35,  27,  10, 146, 174, 171,  12,  26, 128}
     },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
       { 190,  80,  35,  99, 180,  80, 126,  54,  45},
       {  85, 126,  47,  87, 176,  51,  41,  20,  32},
       { 101,  75, 128, 139, 118, 146, 116, 128,  85},
       {  56,  41,  15, 176, 236,  85,  37,   9,  62},
       { 146,  36,  19,  30, 171, 255,  97,  27,  20},
       {  71,  30,  17, 119, 118, 255,  17,  18, 138},
       { 101,  38,  60, 138,  55,  70,  43,  26, 142},
       { 138,  45,  61,  62, 219,   1,  81, 188,  64},
       {  32,  41,  20, 117, 151, 142,  20,  21, 163},
       { 112,  19,  12,  61, 195, 128,  48,   4,  24}
     }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
       { 190,  80,  35,  99, 180,  80, 126,  54,  45},
       {  85, 126,  47,  87, 176,  51,  41,  20,  32},
       { 101,  75, 128, 139, 118, 146, 116, 128,  85},
       {  56,  41,  15, 176, 236,  85,  37,   9,  62},
       { 146,  36,  19,  30, 171, 255,  97,  27,  20},
       {  71,  30,  17, 119, 118, 255,  17,  18, 138},
       { 101,  38,  60, 138,  55,  70,  43,  26, 142},
       { 138,  45,  61,  62, 219,   1,  81, 188,  64},
       {  32,  41,  20, 117, 151, 142,  20,  21, 163},
       { 112,  19,  12,  61, 195, 128,  48,   4,  24}
     }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Intraframe Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 帧内预测
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intraframe prediction uses already-coded macroblocks within the current frame to approximate the contents of the current macroblock. It applies to intra-coded macroblocks in an interframe and to all macroblocks in a key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧内预测使用当前帧内已编码的宏块来近似当前宏块的内容。它适用于帧间中的帧内编码宏块和关键帧中的所有宏块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Relative to the current macroblock &#34;M&#34;, the already-coded macroblocks include all macroblocks above M together with the macroblocks on the same row as, and to the left of, M, though at most four of these macroblocks are actually used: the block &#34;A&#34; directly above M, the blocks immediately to the left and right of A, and the block immediately to the left of M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相对于当前宏块“M”，已经编码的宏块包括M上方的所有宏块以及与M同一行且在M左侧的宏块，尽管实际使用的这些宏块中最多有四个：直接在M上方的块“A”、紧靠M左右的块，和M左边的街区。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the prediction modes (i.e., means of extrapolation from already-calculated values) uses fairly simple arithmetic on pixel values whose positions, relative to the current position, are defined by the mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个预测模式（即，从已经计算的值外推的手段）对像素值使用相当简单的算法，其相对于当前位置的位置由模式定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chroma (U and V) and luma (Y) predictions are independent of each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
色度（U和V）和亮度（Y）预测相互独立。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The relative addressing of pixels applied to macroblocks on the upper row or left column of the frame will sometimes cause pixels outside the visible frame to be referenced. Usually such out-of-bounds pixels have an assumed value of 129 for pixels to the left of the leftmost column of the visible frame and 127 for pixels above the top row of the visible frame (including the special case of the pixel above and to the left of the top-left pixel in the visible frame). Exceptions to this (associated to certain modes) will be noted below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用于帧的上行或左列上的宏块的像素的相对寻址有时会导致引用可见帧之外的像素。通常，对于可见帧最左列左侧的像素，此类越界像素的假设值为129，对于可见帧顶行上方的像素，此类越界像素的假设值为127（包括可见帧中左上像素上方和左侧的像素的特殊情况）。以下将说明例外情况（与某些模式相关）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The already-coded macroblocks referenced by intra-prediction have been &#34;reconstructed&#34;, that is, have been predicted and residue-adjusted (as described in Section 14), but have not been loop-filtered. While it does process the edges between individual macroblocks and individual subblocks, loop filtering (described in Section 15) is applied to the frame as a whole, after all of the macroblocks have been reconstructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧内预测所引用的已经编码的宏块已经被“重构”，也就是说，已经被预测和残余调整（如第14节所述），但是没有被循环滤波。虽然它确实处理各个宏块和各个子块之间的边缘，但是在所有宏块都被重构之后，循环滤波（在第15节中描述）被应用于作为一个整体的帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. mb_skip_coeff
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. mb_skip_coeff
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The single bool flag is decoded using prob_skip_false if and only if mb_no_skip_coeff is set to 1 (see Sections 9.10 and 9.11). If mb_no_skip_coeff is set to 0, then this value defaults to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当且仅当mb_no_skip_coeff设置为1时（见第9.10节和第9.11节），使用prob_skip_false对单个bool标志进行解码。如果mb_no_skip_coeff设置为0，则该值默认为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. Chroma Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. 色度预测
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The chroma prediction is a little simpler than the luma prediction, so we treat it first. Each of the chroma modes treats U and V identically; that is, the U and V prediction values are calculated in parallel, using the same relative addressing and arithmetic in each of the two planes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
色度预测比亮度预测简单一点，所以我们先处理它。每个色度模式都相同地处理U和V；也就是说，U和V预测值是并行计算的，在两个平面的每个平面中使用相同的相对寻址和算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The modes extrapolate prediction values using the 8-pixel row &#34;A&#34; lying immediately above the block (that is, the bottom chroma row of the macroblock immediately above the current macroblock) and the 8-pixel column &#34;L&#34; immediately to the left of the block (that is, the rightmost chroma column of the macroblock immediately to the left of the current macroblock).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
模式使用紧靠块上方的8像素行“A”（即，紧靠当前宏块上方的宏块的底部色度行）和紧靠块左侧的8像素列“L”来外推预测值（即，紧靠当前宏块左侧的宏块最右边的色度列）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vertical prediction (chroma mode V_PRED) simply fills each 8-pixel row of the 8x8 chroma block with a copy of the &#34;above&#34; row (A). If the current macroblock lies on the top row of the frame, all 8 of the pixel values in A are assigned the value 127.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
垂直预测（色度模式V_PRED）仅用“以上”行（a）的副本填充8x8色度块的每个8像素行。如果当前宏块位于帧的顶行上，则A中的所有8个像素值被分配值127。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, horizontal prediction (H_PRED) fills each 8-pixel column of the 8x8 chroma block with a copy of the &#34;left&#34; column (L). If the current macroblock is in the left column of the frame, all 8 pixel values in L are assigned the value 129.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类似地，水平预测（H_PRED）用“左”列（L）的副本填充8x8色度块的每个8像素列。如果当前宏块在帧的左列中，则L中的所有8个像素值被分配值129。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DC prediction (DC_PRED) fills the 8x8 chroma block with a single value. In the generic case of a macroblock lying below the top row and right of the leftmost column of the frame, this value is the average of the 16 (genuinely visible) pixels in the (union of the) above row A and left column L.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
直流预测（DC_PRED）用单个值填充8x8色度块。在一般情况下，宏块位于帧的顶行和最左列的右侧下方，该值是行a和左列L上方（并集）的16个（真正可见）像素的平均值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, if the current macroblock lies on the top row of the frame, the average of the 8 pixels in L is used; if it lies in the left column of the frame, the average of the 8 pixels in A is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否则，如果当前宏块位于帧的顶行上，则使用L中的8个像素的平均值；如果它位于帧的左列，则使用A中8个像素的平均值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the averages used in these exceptional cases are not the same as those that would be arrived at by using the out-of-bounds A and L values defined for V_PRED and H_PRED. In the case of the leftmost macroblock on the top row of the frame, the 8x8 block is simply filled with the constant value 128.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，这些例外情况下使用的平均值与使用为V_PRED和H_PRED定义的越界A和L值得出的平均值不同。对于帧顶行最左侧的宏块，8x8块仅用常量值128填充。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For DC_PRED, apart from the exceptional case of the top-left macroblock, we are averaging either 16 or 8 pixel values to get a single prediction value that fills the 8x8 block. The rounding is done as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于DC_PRED，除了左上宏块的例外情况外，我们对16或8个像素值进行平均，以获得填充8x8块的单个预测值。四舍五入操作如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int sum;  /* sum of 8 or 16 pixels at (at least) 16-bit precision */
   int shf;  /* base 2 logarithm of the number of pixels (3 or 4) */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int sum;  /* sum of 8 or 16 pixels at (at least) 16-bit precision */
   int shf;  /* base 2 logarithm of the number of pixels (3 or 4) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel DCvalue = (sum + (1 &lt;&lt; (shf-1))) &gt;&gt; shf;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel DCvalue = (sum + (1 &lt;&lt; (shf-1))) &gt;&gt; shf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the summands are all valid pixels, no &#34;clamp&#34; is necessary in the calculation of DCvalue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于总和都是有效像素，因此在计算DCvalue时不需要“钳制”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining &#34;True Motion&#34; (TM_PRED) chroma mode gets its name from an older technique of video compression used by On2 Technologies, to which it bears some relation. In addition to the row &#34;A&#34; and column &#34;L&#34;, TM_PRED uses the pixel &#34;P&#34; above and to the left of the chroma block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
剩下的“真实运动”（TM_PRED）色度模式的名称来自On2 Technologies使用的一种较旧的视频压缩技术，与此有一定关系。除了行“A”和列“L”之外，TM_PRED使用色度块上方和左侧的像素“P”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following figure gives an example of how TM_PRED works:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下图给出了TM_PRED如何工作的示例：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | P   | A0  | A1  | A2  | A3  | A4  | A5  | A6  | A7  |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L0  | X00 | X01 | X02 | X03 | X04 | X05 | X06 | X07 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L1  | X10 | X11 | X12 | X13 | X14 | X15 | X16 | X17 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L2  | X20 | X21 | X22 | X23 | X24 | X25 | X26 | X27 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L3  | X30 | X31 | X32 | X33 | X34 | X35 | X36 | X37 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L4  | X40 | X41 | X42 | X43 | X44 | X45 | X46 | X47 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L5  | X50 | X51 | X52 | X53 | X54 | X55 | X56 | X57 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L6  | X60 | X61 | X62 | X63 | X64 | X65 | X66 | X67 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L7  | X70 | X71 | X72 | X73 | X74 | X75 | X76 | X77 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | P   | A0  | A1  | A2  | A3  | A4  | A5  | A6  | A7  |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L0  | X00 | X01 | X02 | X03 | X04 | X05 | X06 | X07 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L1  | X10 | X11 | X12 | X13 | X14 | X15 | X16 | X17 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L2  | X20 | X21 | X22 | X23 | X24 | X25 | X26 | X27 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L3  | X30 | X31 | X32 | X33 | X34 | X35 | X36 | X37 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L4  | X40 | X41 | X42 | X43 | X44 | X45 | X46 | X47 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L5  | X50 | X51 | X52 | X53 | X54 | X55 | X56 | X57 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L6  | X60 | X61 | X62 | X63 | X64 | X65 | X66 | X67 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
   | L7  | X70 | X71 | X72 | X73 | X74 | X75 | X76 | X77 |
   |-----|-----|-----|-----|-----|-----|-----|-----|-----|
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where P, As, and Ls represent reconstructed pixel values from previously coded blocks, and X00 through X77 represent predicted values for the current block. TM_PRED uses the following equation to calculate X_ij:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中P、As和Ls表示来自先前编码块的重构像素值，X00到X77表示当前块的预测值。TM_PRED使用以下方程式计算X_ij：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   X_ij = L_i + A_j - P (i, j=0, 1, 2, 3)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   X_ij = L_i + A_j - P (i, j=0, 1, 2, 3)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact algorithm is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体算法如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void TMpred(
       Pixel b[8][8],      /* chroma (U or V) prediction block */
       const Pixel A[8],   /* row of already-constructed pixels
                              above block */
       const Pixel L[8],   /* column of &#34;&#34; just to the left of
                              block */
       const Pixel P       /* pixel just to the left of A and
                              above L*/
   ) {
       int r = 0;          /* row */
       do {
           int c = 0;      /* column */
           do {
               b[r][c] = clamp255(L[r]+ A[c] - P);
           } while (++c &lt; 8);
       } while (++r &lt; 8);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void TMpred(
       Pixel b[8][8],      /* chroma (U or V) prediction block */
       const Pixel A[8],   /* row of already-constructed pixels
                              above block */
       const Pixel L[8],   /* column of &#34;&#34; just to the left of
                              block */
       const Pixel P       /* pixel just to the left of A and
                              above L*/
   ) {
       int r = 0;          /* row */
       do {
           int c = 0;      /* column */
           do {
               b[r][c] = clamp255(L[r]+ A[c] - P);
           } while (++c &lt; 8);
       } while (++r &lt; 8);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the process could equivalently be described as propagating the vertical differences between pixels in L (starting from P), using the pixels from A to start each column.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，该过程可以等效地描述为传播L中的像素之间的垂直差异（从P开始），使用A中的像素来开始每个列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation of chroma intra-prediction may be found in the reference decoder file predict.c (Section 20.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
色度帧内预测的实现可在参考解码器文件predict.c（第20.14节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike DC_PRED, for macroblocks on the top row or left edge, TM_PRED does use the out-of-bounds values of 127 and 129 (respectively) defined for V_PRED and H_PRED.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与DC_PRED不同，对于顶行或左边缘上的宏块，TM_PRED使用为V_PRED和H_PRED定义的127和129（分别）越界值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. Luma Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.3. 亮度预测
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prediction processes for the first four 16x16 luma modes (DC_PRED, V_PRED, H_PRED, and TM_PRED) are essentially identical to the corresponding chroma prediction processes described above, the only difference being that we are predicting a single 16x16 luma block instead of two 8x8 chroma blocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前四个16x16亮度模式（DC_PRED、V_PRED、H_PRED和TM_PRED）的预测过程基本上与上述相应的色度预测过程相同，唯一的区别是我们预测的是一个16x16亮度块而不是两个8x8色度块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, the row &#34;A&#34; and column &#34;L&#34; here contain 16 pixels, the DC prediction is calculated using 16 or 32 pixels (and shf is 4 or 5), and we of course fill the entire prediction buffer, that is, 16 rows (or columns) containing 16 pixels each. The reference implementation of 16x16 luma prediction is also in predict.c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，这里的行“A”和列“L”包含16个像素，使用16或32个像素计算DC预测（并且shf是4或5），并且我们当然填充整个预测缓冲区，即，16行（或列）每个包含16个像素。16x16 luma预测的参考实现也在predict.c中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the remaining luma mode (B_PRED), each 4x4 Y subblock is independently predicted using one of ten modes (listed, along with their encodings, in Section 11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在剩余的luma模式（B_PRED）中，每个4x4 Y子块使用十种模式中的一种进行独立预测（在第11节中列出，以及它们的编码）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, unlike the full-macroblock modes already described, some of the subblock modes use prediction pixels above and to the right of the current subblock. In detail, each 4x4 subblock &#34;B&#34; is predicted using (at most) the 4-pixel column &#34;L&#34; immediately to the left of B and the 8-pixel row &#34;A&#34; immediately above B, consisting of the 4 pixels above B followed by the 4 adjacent pixels above and to the right of B, together with the single pixel &#34;P&#34; immediately to the left of A (and immediately above L).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，与已经描述的全宏块模式不同，一些子块模式使用当前子块上方和右侧的预测像素。具体地说，每个4x4子块“B”使用（最多）紧靠B左侧的4像素列“L”和紧靠B上方的8像素行“A”进行预测，该行由B上方的4个像素和B上方和右侧的4个相邻像素以及紧靠A左侧（紧靠L上方）的单个像素“P”组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purpose of subblock intra-prediction, the pixels immediately to the left and right of a pixel in a subblock are the same as the pixels immediately to the left and right of the corresponding pixel in the frame buffer &#34;F&#34;. Vertical offsets behave similarly: The above row A lies immediately above B in F, and the adjacent pixels in the left column L are separated by a single row in F.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了子块内预测的目的，子块中的像素的紧邻左侧和右侧的像素与帧缓冲器“F”中的对应像素的紧邻左侧和右侧的像素相同。垂直偏移的行为类似：上面的行A位于F中B的正上方，左列L中的相邻像素由F中的一行分隔。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because entire macroblocks (as opposed to their constituent subblocks) are reconstructed in raster-scan order, for subblocks lying along the right edge (and not along the top row) of the current macroblock, the four &#34;extra&#34; prediction pixels in A above and to the right of B have not yet actually been constructed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于以光栅扫描顺序重建整个宏块（与其组成的子块相反），因此对于沿当前宏块的右边缘（而不是沿顶行）的子块，还没有实际构造B的上方和右侧A中的四个“额外”预测像素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subblocks 7, 11, and 15 are affected. All three of these subblocks use the same extra pixels as does subblock 3 (at the upper right corner of the macroblock), namely the 4 pixels immediately above and to the right of subblock 3. Writing (R,C) for a frame buffer position offset from the upper left corner of the current macroblock by R rows and C columns, the extra pixels for all the right-edge subblocks (3, 7, 11, and 15) are at positions (-1,16), (-1,17), (-1,18), and (-1,19). For the rightmost macroblock in each macroblock row except the top row, the extra pixels shall use the same value as the pixel at position (-1,15), which is the rightmost visible pixel on the line immediately above the macroblock row. For the top macroblock row, all the extra pixels assume a value of 127.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子块7、11和15受到影响。所有这三个子块使用与子块3（在宏块的右上角）相同的额外像素，即子块3正上方和右侧的4个像素。为从当前宏块左上角偏移R行和C列的帧缓冲区位置写入（R，C），所有右边缘子块（3、7、11和15）的额外像素位于位置（-1,16），（-1,17），（-1,18）和（-1,19）。对于除顶行之外的每个宏块行中最右边的宏块，额外像素应使用与位置（-1,15）处的像素相同的值，该位置是宏块行正上方行上最右边的可见像素。对于顶部宏块行，所有额外像素的值均为127。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details of the prediction modes are most easily described in code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
预测模式的细节最容易在代码中描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Result pixels are often averages of two or three predictor
      pixels.  The following subroutines are used to calculate
      these averages.  Because the arguments are valid pixels, no
      clamping is necessary.  An actual implementation would
      probably use inline functions or macros. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Result pixels are often averages of two or three predictor
      pixels.  The following subroutines are used to calculate
      these averages.  Because the arguments are valid pixels, no
      clamping is necessary.  An actual implementation would
      probably use inline functions or macros. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Compute weighted average centered at y w/adjacent x, z */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Compute weighted average centered at y w/adjacent x, z */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg3(Pixel x, Pixel y, Pixel z) {
     return (x + y + y + z + 2) &gt;&gt; 2;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg3(Pixel x, Pixel y, Pixel z) {
     return (x + y + y + z + 2) &gt;&gt; 2;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Weighted average of 3 adjacent pixels centered at p */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Weighted average of 3 adjacent pixels centered at p */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg3p(const Pixel *p) { return avg3(p[-1], p[0], p[1]);}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg3p(const Pixel *p) { return avg3(p[-1], p[0], p[1]);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Simple average of x and y */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Simple average of x and y */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg2(Pixel x, Pixel y) { return (x + y + 1) &gt;&gt; 1;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg2(Pixel x, Pixel y) { return (x + y + 1) &gt;&gt; 1;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Average of p[0] and p[1] may be considered to be a synthetic
      pixel lying between the two, that is, one half-step past p. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Average of p[0] and p[1] may be considered to be a synthetic
      pixel lying between the two, that is, one half-step past p. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg2p(const Pixel *p) { return avg2(p[0], p[1]);}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel avg2p(const Pixel *p) { return avg2(p[0], p[1]);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void subblock_intra_predict(
       Pixel B[4][4],     /* Y subblock prediction buffer */
       const Pixel *A,    /* A[0]...A[7] = above row, A[-1] = P */
       const Pixel *L,    /* L[0]...L[3] = left column, L[-1] = P */
       intra_bmode mode   /* enum is in Section 11.2 */
   ) {
       Pixel E[9];        /* 9 already-constructed edge pixels */
       E[0] = L[3];  E[1] = L[2];  E[2] = L[1];  E[3] = L[0];
       E[4] = A[-1];      /* == L[-1] == P */
       E[5] = A[0];  E[6] = A[1];  E[7] = A[2];  E[8] = A[3];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void subblock_intra_predict(
       Pixel B[4][4],     /* Y subblock prediction buffer */
       const Pixel *A,    /* A[0]...A[7] = above row, A[-1] = P */
       const Pixel *L,    /* L[0]...L[3] = left column, L[-1] = P */
       intra_bmode mode   /* enum is in Section 11.2 */
   ) {
       Pixel E[9];        /* 9 already-constructed edge pixels */
       E[0] = L[3];  E[1] = L[2];  E[2] = L[1];  E[3] = L[0];
       E[4] = A[-1];      /* == L[-1] == P */
       E[5] = A[0];  E[6] = A[1];  E[7] = A[2];  E[8] = A[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     switch(mode) {
       /* First four modes are similar to corresponding
          full-block modes. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     switch(mode) {
       /* First four modes are similar to corresponding
          full-block modes. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_DC_PRED:
       {
           int v = 4;      /* DC sum/avg, 4 is rounding adjustment */
           int i = 0;  do { v += A[i] + L[i];}  while (++i &lt; 4);
           v &gt;&gt;= 3;        /* averaging 8 pixels */
           i = 0;  do {    /* fill prediction buffer with constant DC
                              value */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_DC_PRED:
       {
           int v = 4;      /* DC sum/avg, 4 is rounding adjustment */
           int i = 0;  do { v += A[i] + L[i];}  while (++i &lt; 4);
           v &gt;&gt;= 3;        /* averaging 8 pixels */
           i = 0;  do {    /* fill prediction buffer with constant DC
                              value */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               int j = 0;  do { B[i][j] = v;}  while (++j &lt; 4);
           } while (++i &lt; 4);
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               int j = 0;  do { B[i][j] = v;}  while (++j &lt; 4);
           } while (++i &lt; 4);
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_TM_PRED: /* just like 16x16 TM_PRED */
       {
           int r = 0;  do {
               int c = 0;  do {
                   B[r][c] = clamp255(L[r] + A[c] - A[-1]);
               } while (++c &lt; 4);
           } while (++r &lt; 4);
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_TM_PRED: /* just like 16x16 TM_PRED */
       {
           int r = 0;  do {
               int c = 0;  do {
                   B[r][c] = clamp255(L[r] + A[c] - A[-1]);
               } while (++c &lt; 4);
           } while (++r &lt; 4);
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_VE_PRED: /* like 16x16 V_PRED except using averages */
       {
           int c = 0;  do { /* all 4 rows = smoothed top row */
               B[0][c] = B[1][c] = B[2][c] = B[3][c] = avg3p(A + c);
           } while (++c &lt; 4);
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_VE_PRED: /* like 16x16 V_PRED except using averages */
       {
           int c = 0;  do { /* all 4 rows = smoothed top row */
               B[0][c] = B[1][c] = B[2][c] = B[3][c] = avg3p(A + c);
           } while (++c &lt; 4);
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_HE_PRED: /* like 16x16 H_PRED except using averages */
       {
           /* Bottom row is exceptional because L[4] does not exist */
           int v = avg3(L[2], L[3], L[3]);
           int r = 3;  while (1) {  /* all 4 columns = smoothed left
                                       column */
               B[r][0] = B[r][1] = B[r][2] = B[r][3] = v;
               if (--r &lt; 0)
                   break;
               v = avg3p(L + r);  /* upper 3 rows use average of
                                      3 pixels */
           }
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_HE_PRED: /* like 16x16 H_PRED except using averages */
       {
           /* Bottom row is exceptional because L[4] does not exist */
           int v = avg3(L[2], L[3], L[3]);
           int r = 3;  while (1) {  /* all 4 columns = smoothed left
                                       column */
               B[r][0] = B[r][1] = B[r][2] = B[r][3] = v;
               if (--r &lt; 0)
                   break;
               v = avg3p(L + r);  /* upper 3 rows use average of
                                      3 pixels */
           }
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The remaining six &#34;diagonal&#34; modes subdivide the
          prediction buffer into diagonal lines.  All the pixels
          on each line are assigned the same value; this value is
          (a smoothed or synthetic version of) an
          already-constructed predictor value lying on the same
          line.  For clarity, in the comments, we express the
          positions of these predictor pixels relative to the
          upper left corner of the destination array B.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The remaining six &#34;diagonal&#34; modes subdivide the
          prediction buffer into diagonal lines.  All the pixels
          on each line are assigned the same value; this value is
          (a smoothed or synthetic version of) an
          already-constructed predictor value lying on the same
          line.  For clarity, in the comments, we express the
          positions of these predictor pixels relative to the
          upper left corner of the destination array B.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          These modes are unique to subblock prediction and have
          no full-block analogs.  The first two use lines at
          +|- 45 degrees from horizontal (or, equivalently,
          vertical), that is, lines whose slopes are +|- 1. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          These modes are unique to subblock prediction and have
          no full-block analogs.  The first two use lines at
          +|- 45 degrees from horizontal (or, equivalently,
          vertical), that is, lines whose slopes are +|- 1. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_LD_PRED:    /* southwest (left and down) step =
                             (-1, 1) or (1,-1) */
           /* avg3p(A + j) is the &#34;smoothed&#34; pixel at (-1,j) */
           B[0][0] = avg3p(A + 1);
           B[0][1] = B[1][0] = avg3p(A + 2);
           B[0][2] = B[1][1] = B[2][0] = avg3p(A + 3);
           B[0][3] = B[1][2] = B[2][1] = B[3][0] = avg3p(A + 4);
           B[1][3] = B[2][2] = B[3][1] = avg3p(A + 5);
           B[2][3] = B[3][2] = avg3p(A + 6);
           B[3][3] = avg3(A[6], A[7], A[7]); /* A[8] does not exist */
           break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_LD_PRED:    /* southwest (left and down) step =
                             (-1, 1) or (1,-1) */
           /* avg3p(A + j) is the &#34;smoothed&#34; pixel at (-1,j) */
           B[0][0] = avg3p(A + 1);
           B[0][1] = B[1][0] = avg3p(A + 2);
           B[0][2] = B[1][1] = B[2][0] = avg3p(A + 3);
           B[0][3] = B[1][2] = B[2][1] = B[3][0] = avg3p(A + 4);
           B[1][3] = B[2][2] = B[3][1] = avg3p(A + 5);
           B[2][3] = B[3][2] = avg3p(A + 6);
           B[3][3] = avg3(A[6], A[7], A[7]); /* A[8] does not exist */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_RD_PRED: /* southeast (right and down) step =
                          (1,1) or (-1,-1) */
           B[3][0] = avg3p(E + 1);  /* predictor is from (2, -1) */
           B[3][1] = B[2][0] = avg3p(E + 2);  /* (1, -1) */
           B[3][2] = B[2][1] = B[1][0] = avg3p(E + 3);  /* (0, -1) */
           B[3][3] = B[2][2] = B[1][1] = B[0][0] =
             avg3p(E + 4);  /* (-1, -1) */
           B[2][3] = B[1][2] = B[0][1] = avg3p(E + 5);  /* (-1, 0) */
           B[1][3] = B[0][2] = avg3p(E + 6);  /* (-1, 1) */
           B[0][3] = avg3p(E + 7);  /* (-1, 2) */
           break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_RD_PRED: /* southeast (right and down) step =
                          (1,1) or (-1,-1) */
           B[3][0] = avg3p(E + 1);  /* predictor is from (2, -1) */
           B[3][1] = B[2][0] = avg3p(E + 2);  /* (1, -1) */
           B[3][2] = B[2][1] = B[1][0] = avg3p(E + 3);  /* (0, -1) */
           B[3][3] = B[2][2] = B[1][1] = B[0][0] =
             avg3p(E + 4);  /* (-1, -1) */
           B[2][3] = B[1][2] = B[0][1] = avg3p(E + 5);  /* (-1, 0) */
           B[1][3] = B[0][2] = avg3p(E + 6);  /* (-1, 1) */
           B[0][3] = avg3p(E + 7);  /* (-1, 2) */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The remaining 4 diagonal modes use lines whose slopes are
          +|- 2 and +|- 1/2.  The angles of these lines are roughly
          +|- 27 degrees from horizontal or vertical.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The remaining 4 diagonal modes use lines whose slopes are
          +|- 2 and +|- 1/2.  The angles of these lines are roughly
          +|- 27 degrees from horizontal or vertical.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          Unlike the 45 degree diagonals, here we often need to
          &#34;synthesize&#34; predictor pixels midway between two actual
          predictors using avg2p(p), which we think of as returning
          the pixel &#34;at&#34; p[1/2]. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          Unlike the 45 degree diagonals, here we often need to
          &#34;synthesize&#34; predictor pixels midway between two actual
          predictors using avg2p(p), which we think of as returning
          the pixel &#34;at&#34; p[1/2]. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_VR_PRED:    /* SSE (vertical right) step =
                             (2,1) or (-2,-1) */
           B[3][0] = avg3p(E + 2);  /* predictor is from (1, -1) */
           B[2][0] = avg3p(E + 3);  /* (0, -1) */
           B[3][1] = B[1][0] = avg3p(E + 4);  /* (-1,   -1) */
           B[2][1] = B[0][0] = avg2p(E + 4);  /* (-1, -1/2) */
           B[3][2] = B[1][1] = avg3p(E + 5);  /* (-1,    0) */
           B[2][2] = B[0][1] = avg2p(E + 5);  /* (-1,  1/2) */
           B[3][3] = B[1][2] = avg3p(E + 6);  /* (-1,    1) */
           B[2][3] = B[0][2] = avg2p(E + 6);  /* (-1,  3/2) */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_VR_PRED:    /* SSE (vertical right) step =
                             (2,1) or (-2,-1) */
           B[3][0] = avg3p(E + 2);  /* predictor is from (1, -1) */
           B[2][0] = avg3p(E + 3);  /* (0, -1) */
           B[3][1] = B[1][0] = avg3p(E + 4);  /* (-1,   -1) */
           B[2][1] = B[0][0] = avg2p(E + 4);  /* (-1, -1/2) */
           B[3][2] = B[1][1] = avg3p(E + 5);  /* (-1,    0) */
           B[2][2] = B[0][1] = avg2p(E + 5);  /* (-1,  1/2) */
           B[3][3] = B[1][2] = avg3p(E + 6);  /* (-1,    1) */
           B[2][3] = B[0][2] = avg2p(E + 6);  /* (-1,  3/2) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           B[1][3] = avg3p(E + 7);  /* (-1, 2) */
           B[0][3] = avg2p(E + 7);  /* (-1, 5/2) */
           break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           B[1][3] = avg3p(E + 7);  /* (-1, 2) */
           B[0][3] = avg2p(E + 7);  /* (-1, 5/2) */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_VL_PRED:    /* SSW (vertical left) step =
                             (2,-1) or (-2,1) */
           B[0][0] = avg2p(A);  /* predictor is from (-1, 1/2) */
           B[1][0] = avg3p(A + 1);  /* (-1, 1) */
           B[2][0] = B[0][1] = avg2p(A + 1);  /* (-1, 3/2) */
           B[1][1] = B[3][0] = avg3p(A + 2);  /* (-1,   2) */
           B[2][1] = B[0][2] = avg2p(A + 2);  /* (-1, 5/2) */
           B[3][1] = B[1][2] = avg3p(A + 3);  /* (-1,   3) */
           B[2][2] = B[0][3] = avg2p(A + 3);  /* (-1, 7/2) */
           B[3][2] = B[1][3] = avg3p(A + 4);  /* (-1,   4) */
           /* Last two values do not strictly follow the pattern. */
           B[2][3] = avg3p(A + 5);  /* (-1, 5) [avg2p(A + 4) =
                                        (-1,9/2)] */
           B[3][3] = avg3p(A + 6);  /* (-1, 6) [avg3p(A + 5) =
                                        (-1,5)] */
           break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_VL_PRED:    /* SSW (vertical left) step =
                             (2,-1) or (-2,1) */
           B[0][0] = avg2p(A);  /* predictor is from (-1, 1/2) */
           B[1][0] = avg3p(A + 1);  /* (-1, 1) */
           B[2][0] = B[0][1] = avg2p(A + 1);  /* (-1, 3/2) */
           B[1][1] = B[3][0] = avg3p(A + 2);  /* (-1,   2) */
           B[2][1] = B[0][2] = avg2p(A + 2);  /* (-1, 5/2) */
           B[3][1] = B[1][2] = avg3p(A + 3);  /* (-1,   3) */
           B[2][2] = B[0][3] = avg2p(A + 3);  /* (-1, 7/2) */
           B[3][2] = B[1][3] = avg3p(A + 4);  /* (-1,   4) */
           /* Last two values do not strictly follow the pattern. */
           B[2][3] = avg3p(A + 5);  /* (-1, 5) [avg2p(A + 4) =
                                        (-1,9/2)] */
           B[3][3] = avg3p(A + 6);  /* (-1, 6) [avg3p(A + 5) =
                                        (-1,5)] */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_HD_PRED:    /* ESE (horizontal down) step =
                             (1,2) or (-1,-2) */
           B[3][0] = avg2p(E);  /* predictor is from (5/2, -1) */
           B[3][1] = avg3p(E + 1);  /* (2, -1) */
           B[2][0] = B[3][2] = svg2p(E + 1);  /* ( 3/2, -1) */
           B[2][1] = B[3][3] = avg3p(E + 2);  /* (   1, -1) */
           B[2][2] = B[1][0] = avg2p(E + 2);  /* ( 1/2, -1) */
           B[2][3] = B[1][1] = avg3p(E + 3);  /* (   0, -1) */
           B[1][2] = B[0][0] = avg2p(E + 3);  /* (-1/2, -1) */
           B[1][3] = B[0][1] = avg3p(E + 4);  /* (  -1, -1) */
           B[0][2] = avg3p(E + 5);  /* (-1, 0) */
           B[0][3] = avg3p(E + 6);  /* (-1, 1) */
           break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_HD_PRED:    /* ESE (horizontal down) step =
                             (1,2) or (-1,-2) */
           B[3][0] = avg2p(E);  /* predictor is from (5/2, -1) */
           B[3][1] = avg3p(E + 1);  /* (2, -1) */
           B[2][0] = B[3][2] = svg2p(E + 1);  /* ( 3/2, -1) */
           B[2][1] = B[3][3] = avg3p(E + 2);  /* (   1, -1) */
           B[2][2] = B[1][0] = avg2p(E + 2);  /* ( 1/2, -1) */
           B[2][3] = B[1][1] = avg3p(E + 3);  /* (   0, -1) */
           B[1][2] = B[0][0] = avg2p(E + 3);  /* (-1/2, -1) */
           B[1][3] = B[0][1] = avg3p(E + 4);  /* (  -1, -1) */
           B[0][2] = avg3p(E + 5);  /* (-1, 0) */
           B[0][3] = avg3p(E + 6);  /* (-1, 1) */
           break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_HU_PRED:    /* ENE (horizontal up) step = (1,-2)
                             or (-1,2) */
           B[0][0] = avg2p(L);  /* predictor is from (1/2, -1) */
           B[0][1] = avg3p(L + 1);  /* (1, -1) */
           B[0][2] = B[1][0] = avg2p(L + 1);  /* (3/2, -1) */
           B[0][3] = B[1][1] = avg3p(L + 2);  /* (  2, -1) */
           B[1][2] = B[2][0] = avg2p(L + 2);  /* (5/2, -1) */
           B[1][3] = B[2][1] = avg3(L[2], L[3], L[3]);  /* (3, -1) */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case B_HU_PRED:    /* ENE (horizontal up) step = (1,-2)
                             or (-1,2) */
           B[0][0] = avg2p(L);  /* predictor is from (1/2, -1) */
           B[0][1] = avg3p(L + 1);  /* (1, -1) */
           B[0][2] = B[1][0] = avg2p(L + 1);  /* (3/2, -1) */
           B[0][3] = B[1][1] = avg3p(L + 2);  /* (  2, -1) */
           B[1][2] = B[2][0] = avg2p(L + 2);  /* (5/2, -1) */
           B[1][3] = B[2][1] = avg3(L[2], L[3], L[3]);  /* (3, -1) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Not possible to follow pattern for much of the bottom
              row because no (nearby) already-constructed pixels lie
              on the diagonals in question. */
           B[2][2] = B[2][3] = B[3][0] = B[3][1] = B[3][2] = B[3][3]
             = L[3];
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Not possible to follow pattern for much of the bottom
              row because no (nearby) already-constructed pixels lie
              on the diagonals in question. */
           B[2][2] = B[2][3] = B[3][0] = B[3][1] = B[3][2] = B[3][3]
             = L[3];
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference decoder implementation of subblock intra-prediction may be found in predict.c (Section 20.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子块帧内预测的参考解码器实现可在predict.c（第20.14节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. DCT Coefficient Decoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. DCT系数解码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second data partition consists of an encoding of the quantized DCT (and WHT) coefficients of the residue signal. As discussed in the format overview (Section 2), for each macroblock, the residue is added to the (intra- or inter-generated) prediction buffer to produce the final (except for loop filtering) reconstructed macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二个数据分区由剩余信号的量化DCT（和WHT）系数的编码组成。如格式概述（第2节）中所述，对于每个宏块，将剩余添加到（帧内或帧间生成的）预测缓冲器中，以产生最终（循环滤波除外）重构宏块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 works exclusively with 4x4 DCTs and WHTs, applied to the 24 (or 25 with the Y2 subblock) 4x4 subblocks of a macroblock. The ordering of macroblocks within any of the &#34;residue&#34; partitions in general follows the same raster scan as used in the first &#34;prediction&#34; partition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8仅适用于4x4 DCT和WHT，应用于宏块的24个（或25个Y2子块）4x4子块。任何“剩余”分区内宏块的排序通常遵循与第一个“预测”分区中使用的相同光栅扫描。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all intra- and inter-prediction modes apart from B_PRED (intra: whose Y subblocks are independently predicted) and SPLITMV (inter), each macroblock&#39;s residue record begins with the Y2 component of the residue, coded using a WHT. B_PRED and SPLITMV coded macroblocks omit this WHT and specify the 0th DCT coefficient in each of the 16 Y subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于所有帧内和帧间预测模式，除了B_PRED（帧内：其Y子块被独立预测）和SPLITMV（帧间），每个宏块的剩余记录从剩余的Y2分量开始，使用WHT编码。B_PRED和SPLITMV编码宏块省略该WHT，并在16个Y子块中的每个子块中指定第0个DCT系数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the optional Y2 block, the residue record continues with 16 DCTs for the Y subblocks, followed by 4 DCTs for the U subblocks, ending with 4 DCTs for the V subblocks. The subblocks occur in the usual order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在可选的Y2块之后，剩余记录继续进行Y子块的16个DCT，接着是U子块的4个DCT，最后是V子块的4个DCT。子块以通常的顺序出现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DCTs and WHT are tree-coded using a 12-element alphabet whose members we call &#34;tokens&#34;. Except for the end-of-block token (which sets the remaining subblock coefficients to zero and is followed by the next block), each token (sometimes augmented with data immediately following the token) specifies the value of the single coefficient at the current (implicit) position and is followed by a token applying to the next (implicit) position.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DCT和WHT使用12元素字母表进行树编码，我们称其成员为“标记”。除了块结束标记（将剩余的子块系数设置为零，然后是下一个块）之外，每个标记（有时在标记后面加上数据）在当前（隐式）位置指定单个系数的值，然后是应用于下一个（隐式）位置的标记位置
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all the Y and chroma subblocks, the ordering of the coefficients follows a so-called zig-zag order. DCTs begin at coefficient 1 if Y2 is present, and begin at coefficient 0 if Y2 is absent. The WHT for a Y2 subblock always begins at coefficient 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于所有Y和色度子块，系数的顺序遵循所谓的Z字形顺序。如果存在Y2，则DCT从系数1开始，如果不存在Y2，则从系数0开始。Y2子块的WHT始终从系数0开始。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Macroblock without Non-Zero Coefficient Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. 没有非零系数值的宏块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the flag within macroblock (MB) MODE_INFO indicates that a macroblock does not have any non-zero coefficients, the decoding process of DCT coefficients is skipped for the macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果宏块（MB）模式_INFO内的标志指示宏块不具有任何非零系数，则针对该宏块跳过DCT系数的解码过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Coding of Individual Coefficient Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 单个系数值的编码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The coding of coefficient tokens is the same for the DCT and WHT, and for the remainder of this section &#34;DCT&#34; should be taken to mean either DCT or WHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
系数标记的编码对于DCT和WHT是相同的，对于本节的其余部分，“DCT”应表示DCT或WHT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All tokens (except end-of-block) specify either a single unsigned value or a range of unsigned values (immediately) followed by a simple probabilistic encoding of the offset of the value from the base of that range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有标记（块末尾除外）指定单个无符号值或一个无符号值范围（立即），然后对该值从该范围底部的偏移量进行简单的概率编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-zero values (of either type) are then followed by a flag indicating the sign of the coded value (negative if 1, positive if 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非零值（任何一种类型）后面都会有一个标志，指示编码值的符号（如果为1，则为负，如果为0，则为正）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Below are the tokens and decoding tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面是令牌和解码树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       DCT_0,      /* value 0 */
       DCT_1,      /* 1 */
       DCT_2,      /* 2 */
       DCT_3,      /* 3 */
       DCT_4,      /* 4 */
       dct_cat1,   /* range 5 - 6  (size 2) */
       dct_cat2,   /* 7 - 10   (4) */
       dct_cat3,   /* 11 - 18  (8) */
       dct_cat4,   /* 19 - 34  (16) */
       dct_cat5,   /* 35 - 66  (32) */
       dct_cat6,   /* 67 - 2048  (1982) */
       dct_eob,    /* end of block */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       DCT_0,      /* value 0 */
       DCT_1,      /* 1 */
       DCT_2,      /* 2 */
       DCT_3,      /* 3 */
       DCT_4,      /* 4 */
       dct_cat1,   /* range 5 - 6  (size 2) */
       dct_cat2,   /* 7 - 10   (4) */
       dct_cat3,   /* 11 - 18  (8) */
       dct_cat4,   /* 19 - 34  (16) */
       dct_cat5,   /* 35 - 66  (32) */
       dct_cat6,   /* 67 - 2048  (1982) */
       dct_eob,    /* end of block */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_dct_tokens   /* 12 */
   }
   dct_token;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_dct_tokens   /* 12 */
   }
   dct_token;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index coeff_tree [2 * (num_dct_tokens - 1)] =
   {
    -dct_eob, 2,               /* eob = &#34;0&#34;   */
     -DCT_0, 4,                /* 0   = &#34;10&#34;  */
      -DCT_1, 6,               /* 1   = &#34;110&#34; */
       8, 12,
        -DCT_2, 10,            /* 2   = &#34;11100&#34; */
         -DCT_3, -DCT_4,       /* 3   = &#34;111010&#34;, 4 = &#34;111011&#34; */
        14, 16,
         -dct_cat1, -dct_cat2, /* cat1 =  &#34;111100&#34;,
                                  cat2 = &#34;111101&#34; */
        18, 20,
         -dct_cat3, -dct_cat4, /* cat3 = &#34;1111100&#34;,
                                  cat4 = &#34;1111101&#34; */
         -dct_cat5, -dct_cat6  /* cat4 = &#34;1111110&#34;,
                                  cat4 = &#34;1111111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index coeff_tree [2 * (num_dct_tokens - 1)] =
   {
    -dct_eob, 2,               /* eob = &#34;0&#34;   */
     -DCT_0, 4,                /* 0   = &#34;10&#34;  */
      -DCT_1, 6,               /* 1   = &#34;110&#34; */
       8, 12,
        -DCT_2, 10,            /* 2   = &#34;11100&#34; */
         -DCT_3, -DCT_4,       /* 3   = &#34;111010&#34;, 4 = &#34;111011&#34; */
        14, 16,
         -dct_cat1, -dct_cat2, /* cat1 =  &#34;111100&#34;,
                                  cat2 = &#34;111101&#34; */
        18, 20,
         -dct_cat3, -dct_cat4, /* cat3 = &#34;1111100&#34;,
                                  cat4 = &#34;1111101&#34; */
         -dct_cat5, -dct_cat6  /* cat4 = &#34;1111110&#34;,
                                  cat4 = &#34;1111111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, all DCT coefficients are decoded using the same tree. However, if the preceding coefficient is a DCT_0, decoding will skip the first branch, since it is not possible for dct_eob to follow a DCT_0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常，所有DCT系数都使用同一棵树进行解码。然而，如果前面的系数是DCT_0，则解码将跳过第一个分支，因为DCT_eob不可能跟随DCT_0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The tokens dct_cat1 ... dct_cat6 specify ranges of unsigned values, the value within the range being formed by adding an unsigned offset (whose width is 1, 2, 3, 4, 5, or 11 bits, respectively) to the base of the range, using the following algorithm and fixed probability tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
令牌dct_cat1。。。dct_cat6指定无符号值的范围，该范围内的值是通过使用以下算法和固定概率表将无符号偏移量（其宽度分别为1、2、3、4、5或11位）添加到范围的基来形成的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   uint DCTextra(bool_decoder *d, const Prob *p)
   {
       uint v = 0;
       do { v += v + read_bool(d, *p);}  while (*++p);
       return v;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   uint DCTextra(bool_decoder *d, const Prob *p)
   {
       uint v = 0;
       do { v += v + read_bool(d, *p);}  while (*++p);
       return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob Pcat1[] = { 159, 0};
   const Prob Pcat2[] = { 165, 145, 0};
   const Prob Pcat3[] = { 173, 148, 140, 0};
   const Prob Pcat4[] = { 176, 155, 140, 135, 0};
   const Prob Pcat5[] = { 180, 157, 141, 134, 130, 0};
   const Prob Pcat6[] =
       { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob Pcat1[] = { 159, 0};
   const Prob Pcat2[] = { 165, 145, 0};
   const Prob Pcat3[] = { 173, 148, 140, 0};
   const Prob Pcat4[] = { 176, 155, 140, 135, 0};
   const Prob Pcat5[] = { 180, 157, 141, 134, 130, 0};
   const Prob Pcat6[] =
       { 254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If v -- the unsigned value decoded using the coefficient tree, possibly augmented by the process above -- is non-zero, its sign is set by simply reading a flag:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果v——使用系数树解码的无符号值（可能通过上述过程增加）为非零，则其符号仅通过读取一个标志来设置：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (read_bool(d, 128))
       v = -v;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (read_bool(d, 128))
       v = -v;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Token Probabilities
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. 标记概率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability specification for the token tree (unlike that for the &#34;extra bits&#34; described above) is rather involved. It uses three pieces of context to index a large probability table, the contents of which may be incrementally modified in the frame header. The full (non-constant) probability table is laid out as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
令牌树的概率规范（与上述“额外比特”的概率规范不同）相当复杂。它使用三个上下文来索引一个大概率表，其内容可以在帧头中进行增量修改。完整（非常数）概率表如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prob coeff_probs [4] [8] [3] [num_dct_tokens-1];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prob coeff_probs[4][8][3][num_dct_tokens-1]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Working from the outside in, the outermost dimension is indexed by the type of plane being decoded:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从外到内工作时，最外层尺寸根据解码的平面类型进行索引：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0 - Y beginning at coefficient 1 (i.e., Y after Y2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 0-从系数1开始的Y（即Y2之后的Y）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1 - Y2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 1-Y2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2 - U or V
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 2-U或V
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 3 - Y beginning at coefficient 0 (i.e., Y in the absence of Y2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 3-从系数0开始的Y（即，在没有Y2的情况下为Y）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next dimension is selected by the position of the coefficient being decoded. That position, c, steps by ones up to 15, starting from zero for block types 1, 2, or 3 and starting from one for block type 0. The second array index is then
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下一个维度由解码系数的位置选择。该位置，c，从1、2或3型块的0开始，从1型块的0开始，逐步递增至15。第二个数组索引是
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
coeff_bands [c]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
系数带[c]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
哪里：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int coeff_bands [16] = {
        0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int coeff_bands [16] = {
        0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is a fixed mapping of position to &#34;band&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
是位置到“波段”的固定映射。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third dimension is the trickiest. Roughly speaking, it measures the &#34;local complexity&#34; or extent to which nearby coefficients are non-zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三维度是最棘手的。粗略地说，它衡量“局部复杂性”或附近系数非零的程度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the first coefficient (DC, unless the block type is 0), we consider the (already encoded) blocks within the same plane (Y2, Y, U, or V) above and to the left of the current block. The context index is then the number (0, 1, or 2) of these blocks that had at least one non-zero coefficient in their residue record. Specifically for Y2, because macroblocks above and to the left may or may not have a Y2 block, the block above is determined by the most recent macroblock in the same column that has a Y2 block, and the block to the left is determined by the most recent macroblock in the same row that has a Y2 block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于第一系数（DC，除非块类型为0），我们考虑在当前块上方和左侧的同一平面（Y2、Y、U或V）中的（已编码）块。然后，上下文索引是在剩余记录中至少有一个非零系数的这些块的数目（0、1或2）。特别是对于Y2，因为上面和左边的宏块可能有也可能没有Y2块，上面的块由具有Y2块的同一列中的最新宏块确定，左边的块由具有Y2块的同一行中的最新宏块确定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Beyond the first coefficient, the context index is determined by the absolute value of the most recently decoded coefficient (necessarily within the current block) and is 0 if the last coefficient was a zero, 1 if it was plus or minus one, and 2 if its absolute value exceeded one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第一个系数之外，上下文索引由最近解码的系数（必须在当前块内）的绝对值确定，如果最后一个系数为零，则上下文索引为0，如果其为正或负1，则上下文索引为1，如果其绝对值超过1，则上下文索引为2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the intuitive meaning of this measure changes as coefficients are decoded. For example, prior to the first token, a zero means that the neighbors are empty, suggesting that the current block may also be empty. After the first token, because an end-of-block token must have at least one non-zero value before it, a zero means that we just decoded a zero and hence guarantees that a non-zero coefficient will appear later in this block. However, this shift in meaning is perfectly okay because the complete context depends also on the coefficient band (and since band 0 is occupied exclusively by position 0).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，随着系数被解码，此度量的直观含义会发生变化。例如，在第一个令牌之前，零表示邻居为空，表明当前块也可能为空。在第一个令牌之后，因为块结束令牌之前必须至少有一个非零值，所以零表示我们刚刚解码了一个零，因此保证非零系数稍后将出现在该块中。然而，这种意义上的转移是完全正确的，因为完整的上下文也取决于系数带（并且因为带0完全被位置0占据）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with other contexts used by VP8, the &#34;neighboring block&#34; context described here needs a special definition for subblocks lying along the top row or left edge of the frame. These &#34;non-existent&#34; predictors above and to the left of the image are simply taken to be empty -- that is, taken to contain no non-zero coefficients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与VP8使用的其他上下文一样，此处描述的“相邻块”上下文需要对位于帧顶行或左边缘的子块进行特殊定义。图像上方和左侧的这些“不存在”预测器被简单地认为是空的——也就是说，不包含非零系数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The residue decoding of each macroblock then requires, in each of two directions (above and to the left), an aggregate coefficient predictor consisting of a single Y2 predictor, two predictors for each of U and V, and four predictors for Y. In accordance with the scan-ordering of macroblocks, a decoder needs to maintain a single &#34;left&#34; aggregate predictor and a row of &#34;above&#34; aggregate predictors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，每个宏块的剩余解码在两个方向（上方和左侧）的每个方向上都需要一个聚合系数预测器，该预测器由一个Y2预测器、两个U和V预测器以及四个Y预测器组成。根据宏块的扫描顺序，解码器需要保持一个“左”聚合预测值和一行“以上”聚合预测值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before decoding any residue, these maintained predictors may simply be cleared, in compliance with the definition of &#34;non-existent&#34; prediction. After each block is decoded, the two predictors referenced by the block are replaced with the (empty or non-empty) state of the block, in preparation for the later decoding of the blocks below and to the right of the block just decoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在解码任何剩余之前，可以根据“不存在”预测的定义，简单地清除这些保持的预测器。在解码每个块之后，由块引用的两个预测器被块的（空或非空）状态替换，以准备稍后解码刚刚解码的块的右下方的块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fourth, and final, dimension of the token probability array is of course indexed by (half) the position in the token tree structure, as are all tree probability arrays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
令牌概率数组的第四个也是最后一个维度当然是由令牌树结构中的位置（一半）索引的，就像所有树概率数组一样。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudocode below illustrates the decoding process. Note that criteria, functions, etc. delimited with ** are either dependent on decoder architecture or are elaborated on elsewhere in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面的伪码说明了解码过程。请注意，用**分隔的标准、功能等取决于解码器架构，或在本文档其他地方详细说明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int block[16] = { 0 }; /* current 4x4 block coeffs */
   int firstCoeff = 0;
   int plane;
   int ctx2;
   int ctx3 = 0; /* the 3rd context referred to in above description */
   Prob *probTable;
   int token;
   int sign;
   int absValue;
   int extraBits;
   bool prevCoeffWasZero = false;
   bool currentBlockHasCoeffs = false;
   /* base coeff abs values per each category, elem #0 is
      DCT_VAL_CATEGORY1, * #1 is DCT_VAL_CATEGORY2, etc. */
   int categoryBase[6] = { 5, 7, 11, 19, 35, 67 };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int block[16] = { 0 }; /* current 4x4 block coeffs */
   int firstCoeff = 0;
   int plane;
   int ctx2;
   int ctx3 = 0; /* the 3rd context referred to in above description */
   Prob *probTable;
   int token;
   int sign;
   int absValue;
   int extraBits;
   bool prevCoeffWasZero = false;
   bool currentBlockHasCoeffs = false;
   /* base coeff abs values per each category, elem #0 is
      DCT_VAL_CATEGORY1, * #1 is DCT_VAL_CATEGORY2, etc. */
   int categoryBase[6] = { 5, 7, 11, 19, 35, 67 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Determine plane to use */
   if ( **current_block_is_Y2_block** )       plane = 0;
   else if ( **current_block_is_chroma** )   plane = 2;
   else if ( **current_macroblock_has_Y2** ) plane = 1;
   else                                      plane = 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Determine plane to use */
   if ( **current_block_is_Y2_block** )       plane = 0;
   else if ( **current_block_is_chroma** )   plane = 2;
   else if ( **current_macroblock_has_Y2** ) plane = 1;
   else                                      plane = 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* For luma blocks of a &#34;Y2 macroblock&#34; we skip coeff index #0 */
   if ( plane == 1 )
       firstCoeff++;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* For luma blocks of a &#34;Y2 macroblock&#34; we skip coeff index #0 */
   if ( plane == 1 )
       firstCoeff++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Determine whether neighbor 4x4 blocks have coefficients.
      This is dependent on the plane we are currently decoding;
      i.e., we check only coefficients from the same plane as the
      current block. */
   if ( **left_neighbor_block_has_coefficients(plane)** )
       ctx3++;
   if ( **above_neighbor_block_has_coefficients(plane)** )
       ctx3++;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Determine whether neighbor 4x4 blocks have coefficients.
      This is dependent on the plane we are currently decoding;
      i.e., we check only coefficients from the same plane as the
      current block. */
   if ( **left_neighbor_block_has_coefficients(plane)** )
       ctx3++;
   if ( **above_neighbor_block_has_coefficients(plane)** )
       ctx3++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   for( i = firstCoeff; i &lt; 16; ++i )
   {
       ctx2 = coeff_bands[i];
       probTable = coeff_probs[plane][ctx2][ctx3];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   for( i = firstCoeff; i &lt; 16; ++i )
   {
       ctx2 = coeff_bands[i];
       probTable = coeff_probs[plane][ctx2][ctx3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* skip first code (dct_eob) if previous token was DCT_0 */
       if ( prevCoeffWasZero )
           token = treed_read ( d, **coeff_tree_without_eob**,
             probTable );
       else
           token = treed_read ( d, coeff_tree, probTable );
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* skip first code (dct_eob) if previous token was DCT_0 */
       if ( prevCoeffWasZero )
           token = treed_read ( d, **coeff_tree_without_eob**,
             probTable );
       else
           token = treed_read ( d, coeff_tree, probTable );
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if ( token == dct_eob ) break;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（令牌==dct_eob）中断；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if ( token != DCT_0 )
       {
           currentBlockHasCoeffs = true;
     if ( **token_has_extra_bits(token)** )
     {
         extraBits = DCTextra( token );
         absValue =
             categoryBase[**token_to_cat_index(token)**] +
       extraBits;
     }
     else
     {
         absValue = **token_to_abs_value(token)**;
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if ( token != DCT_0 )
       {
           currentBlockHasCoeffs = true;
     if ( **token_has_extra_bits(token)** )
     {
         extraBits = DCTextra( token );
         absValue =
             categoryBase[**token_to_cat_index(token)**] +
       extraBits;
     }
     else
     {
         absValue = **token_to_abs_value(token)**;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     sign = read_bool(d, 128);
           block[i] = sign ? -absValue : absValue;
       }
       else
       {
           absValue = 0;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     sign = read_bool(d, 128);
           block[i] = sign ? -absValue : absValue;
       }
       else
       {
           absValue = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set contexts and stuff for next coeff */
       if ( absValue == 0 )         ctx3 = 0;
       else if ( absValue == 1 )   ctx3 = 1;
       else                        ctx3 = 2;
       prevCoeffWasZero = true;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set contexts and stuff for next coeff */
       if ( absValue == 0 )         ctx3 = 0;
       else if ( absValue == 1 )   ctx3 = 1;
       else                        ctx3 = 2;
       prevCoeffWasZero = true;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Store current block status to decoder internals */
   **block_has_coefficients[currentMb][currentBlock]** =
     currentBlockHasCoeffs;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Store current block status to decoder internals */
   **block_has_coefficients[currentMb][currentBlock]** =
     currentBlockHasCoeffs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While we have in fact completely described the coefficient decoding procedure, the reader will probably find it helpful to consult the reference implementation, which can be found in the file tokens.c (Section 20.16).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然我们实际上已经完全描述了系数解码过程，但读者可能会发现参考实现很有帮助，参考实现可以在文件tokens.c（第20.16节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. Token Probability Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. 令牌概率更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, the token-decoding probabilities may change from frame to frame. After detection of a key frame, they are of course set to their defaults as shown in Section 13.5; this must occur before decoding the remainder of the header, as both key frames and interframes may adjust these probabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述，令牌解码概率可以在帧之间改变。在检测到关键帧后，它们当然被设置为第13.5节所示的默认值；这必须在解码报头的其余部分之前发生，因为关键帧和帧间都可以调整这些概率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The layout and semantics of the coefficient probability update record (Section I of the frame header) are straightforward. For each position in the coeff_probs array there occurs a fixed-probability bool indicating whether or not the corresponding probability should be updated. If the bool is true, there follows a P(8) replacing that probability. Note that updates are cumulative; that is, a probability updated on one frame is in effect for all ensuing frames until the next key frame, or until the probability is explicitly updated by another frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
系数概率更新记录（帧头的第一部分）的布局和语义非常简单。对于coeff_probs阵列中的每个位置，都会出现一个固定的概率bool，指示是否应更新相应的概率。如果布尔值为真，则会有一个P（8）替换该概率。注意，更新是累积的；也就是说，在一帧上更新的概率对所有后续帧有效，直到下一关键帧，或者直到该概率被另一帧显式更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm to effect the foregoing is simple:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现上述目的的算法很简单：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int i = 0;  do {
    int j = 0;  do {
     int k = 0;  do {
      int t = 0;  do {
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int i = 0;  do {
    int j = 0;  do {
     int k = 0;  do {
      int t = 0;  do {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (read_bool(d, coeff_update_probs [i] [j] [k] [t]))
               coeff_probs [i] [j] [k] [t] = read_literal(d, 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (read_bool(d, coeff_update_probs [i] [j] [k] [t]))
               coeff_probs [i] [j] [k] [t] = read_literal(d, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      } while (++t &lt; num_dct_tokens - 1);
     } while (++k &lt; 3);
    } while (++j &lt; 8);
   } while (++i &lt; 4);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      } while (++t &lt; num_dct_tokens - 1);
     } while (++k &lt; 3);
    } while (++j &lt; 8);
   } while (++i &lt; 4);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (constant) update probabilities are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（恒定）更新概率如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob coeff_update_probs [4] [8] [3] [num_dct_tokens-1] =
   {
    {
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},
      { 249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},
      { 234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},
      { 250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob coeff_update_probs [4] [8] [3] [num_dct_tokens-1] =
   {
    {
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},
      { 249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},
      { 234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},
      { 250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    {
     {
      { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},
      { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255}
     },
     {
      { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    },
    {
     {
      { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},
      { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},
      { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255}
     },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    {
     {
      { 217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},
      { 234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255}
     },
     {
      { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    },
    {
     {
      { 186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},
      { 234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},
      { 251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255}
     },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    },
    {
     {
      { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},
      { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255}
     },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      { 255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    },
    {
     {
      { 248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},
      { 248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255}
     },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},
      { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      { 255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},
      { 248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},
      { 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     },
     {
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
      { 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255}
     }
    }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. Default Token Probability Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. 默认令牌概率表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default token probabilities are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
默认令牌概率如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob default_coeff_probs [4] [8] [3] [num_dct_tokens - 1] =
   {
    {
     {
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},
      { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},
      { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128}
     },
     {
      {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},
      { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},
      {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128}
     },
     {
      {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},
      { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},
      {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128}
     },
     {
      {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},
      { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},
      {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128}
     },
     {
      {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},
      { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},
      { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128}
     },
     {
      {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},
      { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},
      {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128}
     },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob default_coeff_probs [4] [8] [3] [num_dct_tokens - 1] =
   {
    {
     {
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},
      { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},
      { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128}
     },
     {
      {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},
      { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},
      {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128}
     },
     {
      {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},
      { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},
      {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128}
     },
     {
      {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},
      { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},
      {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128}
     },
     {
      {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},
      { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},
      { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128}
     },
     {
      {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},
      { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},
      {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128}
     },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
     }
    },
    {
     {
      { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},
      { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},
      {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128}
     },
     {
      {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},
      { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},
      {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128}
     },
     {
      {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},
      {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},
      {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128}
     },
     {
      {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},
      { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},
      {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128}
     },
     {
      {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},
      {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},
      {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128}
     },
     {
      {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},
      { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},
      {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128}
     },
     {
      {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},
      { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},
      {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128}
     },
     {
      {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},
      { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},
      { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128}
     }
    },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
     }
    },
    {
     {
      { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},
      { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},
      {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128}
     },
     {
      {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},
      { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},
      {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128}
     },
     {
      {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},
      {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},
      {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128}
     },
     {
      {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},
      { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},
      {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128}
     },
     {
      {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},
      {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},
      {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128}
     },
     {
      {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},
      { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},
      {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128}
     },
     {
      {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},
      { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},
      {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128}
     },
     {
      {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},
      { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},
      { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128}
     }
    },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    {
     {
      { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},
      { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},
      {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128}
     },
     {
      {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},
      { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},
      { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128}
     },
     {
      {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},
      { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},
      {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128}
     },
     {
      {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},
      { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},
      { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128}
     },
     {
      {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},
      { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},
      { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},
      { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},
      {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
     }
    },
    {
     {
      { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},
      { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},
      {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128}
     },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    {
     {
      { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},
      { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},
      {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128}
     },
     {
      {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},
      { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},
      { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128}
     },
     {
      {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},
      { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},
      {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128}
     },
     {
      {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},
      { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},
      { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128}
     },
     {
      {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},
      { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},
      { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},
      { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},
      {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     },
     {
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
      { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
     }
    },
    {
     {
      { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},
      { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},
      {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128}
     },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},
      { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},
      {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128}
     },
     {
      {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},
      { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},
      {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128}
     },
     {
      {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},
      { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},
      {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128}
     },
     {
      {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},
      { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},
      {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128}
     },
     {
      {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},
      { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},
      {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128}
     },
     {
      {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},
      { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},
      {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128}
     },
     {
      {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     }
    }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {
      {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},
      { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},
      {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128}
     },
     {
      {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},
      { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},
      {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128}
     },
     {
      {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},
      { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},
      {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128}
     },
     {
      {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},
      { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},
      {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128}
     },
     {
      {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},
      { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},
      {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128}
     },
     {
      {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},
      { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},
      {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128}
     },
     {
      {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
      { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
     }
    }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. DCT and WHT Inversion and Macroblock Reconstruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. DCT和WHT反演与宏块重建
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Dequantization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. 去量化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After decoding the DCTs/WHTs as described above, each (quantized) coefficient in each subblock is multiplied by one of six dequantization factors, the choice of factor depending on the plane (Y2, Y, or chroma) and position (DC = coefficient zero, AC = any
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在如上所述解码dct/wht之后，每个子块中的每个（量化）系数乘以六个去量化因子中的一个，因子的选择取决于平面（Y2、Y或色度）和位置（DC＝系数零，AC＝任意）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
other coefficient). If the current macroblock has overridden the quantizer level (as described in Section 10), then the six factors are looked up from two dequantization tables with appropriate scaling and clamping using the single index supplied by the override. Otherwise, the frame-level dequantization factors (as described in Section 9.6) are used. In either case, the multiplies are computed and stored using 16-bit signed integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其他系数）。如果当前宏块覆盖了量化器级别（如第10节所述），则使用覆盖提供的单个索引，通过适当的缩放和钳位，从两个去量化表中查找六个因子。否则，使用帧级去量化因子（如第9.6节所述）。在这两种情况下，乘法都是使用16位有符号整数计算和存储的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two dequantization tables, which may also be found in the reference decoder file dequant_data.h (Section 20.3), are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
也可在参考解码器文件dequant_data.h（第20.3节）中找到的两个去量化表如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int dc_qlookup[QINDEX_RANGE] =
   {
       4,   5,   6,   7,   8,   9,  10,  10,   11,  12,  13,  14,  15,
      16,  17,  17,  18,  19,  20,  20,  21,   21,  22,  22,  23,  23,
      24,  25,  25,  26,  27,  28,  29,  30,   31,  32,  33,  34,  35,
      36,  37,  37,  38,  39,  40,  41,  42,   43,  44,  45,  46,  46,
      47,  48,  49,  50,  51,  52,  53,  54,   55,  56,  57,  58,  59,
      60,  61,  62,  63,  64,  65,  66,  67,   68,  69,  70,  71,  72,
      73,  74,  75,  76,  76,  77,  78,  79,   80,  81,  82,  83,  84,
      85,  86,  87,  88,  89,  91,  93,  95,   96,  98, 100, 101, 102,
      104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130,
      132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157,
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int dc_qlookup[QINDEX_RANGE] =
   {
       4,   5,   6,   7,   8,   9,  10,  10,   11,  12,  13,  14,  15,
      16,  17,  17,  18,  19,  20,  20,  21,   21,  22,  22,  23,  23,
      24,  25,  25,  26,  27,  28,  29,  30,   31,  32,  33,  34,  35,
      36,  37,  37,  38,  39,  40,  41,  42,   43,  44,  45,  46,  46,
      47,  48,  49,  50,  51,  52,  53,  54,   55,  56,  57,  58,  59,
      60,  61,  62,  63,  64,  65,  66,  67,   68,  69,  70,  71,  72,
      73,  74,  75,  76,  76,  77,  78,  79,   80,  81,  82,  83,  84,
      85,  86,  87,  88,  89,  91,  93,  95,   96,  98, 100, 101, 102,
      104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130,
      132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157,
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int ac_qlookup[QINDEX_RANGE] =
   {
       4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,
      17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
      30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,
      43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,
      56,  57,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,  78,
      80,  82,  84,  86,  88,  90,  92,  94,  96,  98, 100, 102, 104,
     106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137,
     140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177,
     181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229,
     234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284,
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int ac_qlookup[QINDEX_RANGE] =
   {
       4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,
      17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
      30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,
      43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,
      56,  57,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,  78,
      80,  82,  84,  86,  88,  90,  92,  94,  96,  98, 100, 102, 104,
     106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137,
     140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177,
     181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229,
     234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284,
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lookup values from the above two tables are directly used in the DC and AC coefficients in Y1, respectively. For Y2 and chroma, values from the above tables undergo either scaling or clamping before the multiplies. Details regarding these scaling and clamping processes can be found in related lookup functions in dixie.c (Section 20.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述两个表中的查找值分别直接用于Y1中的DC和AC系数。对于Y2和色度，上表中的值在倍增之前进行缩放或钳制。有关这些缩放和夹紧过程的详细信息，请参见dixie.c（第20.4节）中的相关查找函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Inverse Transforms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. 逆变换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Y2 residue block exists (i.e., the macroblock luma mode is not SPLITMV or B_PRED), it is inverted first (using the inverse WHT) and the element of the result at row i, column j is used as the 0th coefficient of the Y subblock at position (i, j), that is, the Y subblock whose index is (i * 4) + j. As discussed in Section 13, if the luma mode is B_PRED or SPLITMV, the 0th Y coefficients are part of the residue signal for the subblocks themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果Y2剩余块存在（即，宏块luma模式不是SPLITMV或B_PRED），则首先将其反转（使用逆WHT），并且第i行、第j列的结果元素用作位置（i，j）处Y子块的第0个系数，即索引为（i*4）+j的Y子块。如第13节中所讨论的，如果luma模式是B_PRED或SPLITMV，则第0y系数是子块本身的剩余信号的一部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In either case, the inverse transforms for the sixteen Y subblocks and eight chroma subblocks are computed next. All 24 of these inversions are independent of each other; their results may (at least conceptually) be stored in 24 separate 4x4 arrays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在这两种情况下，接下来计算十六个Y子块和八个色度子块的逆变换。所有这24种反演都是相互独立的；其结果可能（至少在概念上）存储在24个单独的4x4阵列中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As is done by the reference decoder, an implementation may wish to represent the prediction and residue buffers as macroblock-sized arrays (that is, a 16x16 Y buffer and two 8x8 chroma buffers). Regarding the inverse DCT implementation given below, this requires a simple adjustment to the address calculation for the resulting residue pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如参考解码器所做的，实现可能希望将预测和剩余缓冲器表示为宏块大小的阵列（即，一个16x16y缓冲器和两个8x8色度缓冲器）。关于下面给出的逆DCT实现，这需要对结果剩余像素的地址计算进行简单调整。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. Implementation of the WHT Inversion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. WHT反演的实现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As previously discussed (see Sections 2 and 13), for macroblocks encoded using prediction modes other than B_PRED and SPLITMV, the DC values derived from the DCT transform on the 16 Y blocks are collected to construct a 25th block of a macroblock (16 Y, 4 U, 4 V constitute the 24 blocks). This 25th block is transformed using a Walsh-Hadamard transform (WHT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如前所述（参见第2节和第13节），对于使用B_PRED和SPLITMV以外的预测模式编码的宏块，从16 Y块上的DCT变换导出的DC值被收集以构造宏块的第25块（16 Y，4 U，4 V构成24个块）。第25个块使用沃尔什-阿达玛变换（WHT）进行变换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inputs to the inverse WHT (that is, the dequantized coefficients), the intermediate &#34;horizontally detransformed&#34; signal, and the completely detransformed residue signal are all stored as arrays of 16-bit signed integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆WHT（即，去量化系数）、中间“水平去变换”信号和完全去变换的剩余信号的输入都存储为16位有符号整数的阵列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following the tradition of specifying bitstream format using the decoding process, we specify the inverse WHT in the decoding process using the following C-style source code:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
按照使用解码过程指定比特流格式的传统，我们使用以下C风格源代码在解码过程中指定逆WHT：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vp8_short_inv_walsh4x4_c(short *input, short *output)
   {
     int i;
     int a1, b1, c1, d1;
     int a2, b2, c2, d2;
     short *ip = input;
     short *op = output;
     int temp1, temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vp8_short_inv_walsh4x4_c(short *input, short *output)
   {
     int i;
     int a1, b1, c1, d1;
     int a2, b2, c2, d2;
     short *ip = input;
     short *op = output;
     int temp1, temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0] + ip[12];
       b1 = ip[4] + ip[8];
       c1 = ip[4] - ip[8];
       d1 = ip[0] - ip[12];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0] + ip[12];
       b1 = ip[4] + ip[8];
       c1 = ip[4] - ip[8];
       d1 = ip[0] - ip[12];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[0] = a1 + b1;
       op[4] = c1 + d1;
       op[8] = a1 - b1;
       op[12]= d1 - c1;
       ip++;
       op++;
     }
     ip = output;
     op = output;
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0] + ip[3];
       b1 = ip[1] + ip[2];
       c1 = ip[1] - ip[2];
       d1 = ip[0] - ip[3];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[0] = a1 + b1;
       op[4] = c1 + d1;
       op[8] = a1 - b1;
       op[12]= d1 - c1;
       ip++;
       op++;
     }
     ip = output;
     op = output;
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0] + ip[3];
       b1 = ip[1] + ip[2];
       c1 = ip[1] - ip[2];
       d1 = ip[0] - ip[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a2 = a1 + b1;
       b2 = c1 + d1;
       c2 = a1 - b1;
       d2 = d1 - c1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a2 = a1 + b1;
       b2 = c1 + d1;
       c2 = a1 - b1;
       d2 = d1 - c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[0] = (a2+3)&gt;&gt;3;
       op[1] = (b2+3)&gt;&gt;3;
       op[2] = (c2+3)&gt;&gt;3;
       op[3] = (d2+3)&gt;&gt;3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[0] = (a2+3)&gt;&gt;3;
       op[1] = (b2+3)&gt;&gt;3;
       op[2] = (c2+3)&gt;&gt;3;
       op[3] = (d2+3)&gt;&gt;3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip+=4;
       op+=4;
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip+=4;
       op+=4;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case that there is only one non-zero DC value in input, the inverse transform can be simplified to the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在输入中只有一个非零DC值的情况下，逆变换可简化为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vp8_short_inv_walsh4x4_1_c(short *input, short *output)
   {
     int i;
     int a1;
     short *op=output;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vp8_short_inv_walsh4x4_1_c(short *input, short *output)
   {
     int i;
     int a1;
     short *op=output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     a1 = ((input[0] + 3)&gt;&gt;3);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     a1 = ((input[0] + 3)&gt;&gt;3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       op[0] = a1;
       op[1] = a1;
       op[2] = a1;
       op[3] = a1;
       op+=4;
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       op[0] = a1;
       op[1] = a1;
       op[2] = a1;
       op[3] = a1;
       op+=4;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should be noted that a conforming decoder should implement the inverse transform using exactly the same rounding to achieve bit-wise matching output to the output of the process specified by the above C source code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应注意，一致性解码器应使用完全相同的舍入实现逆变换，以实现与上述C源代码指定的过程输出的逐位匹配输出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference decoder WHT inversion may be found in the file idct_add.c (Section 20.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考解码器WHT反转可在文件idct_add.c（第20.8节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. Implementation of the DCT Inversion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. DCT逆变换的实现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the DCT inversions are computed in exactly the same way. In principle, VP8 uses a classical 2-D inverse discrete cosine transform, implemented as two passes of 1-D inverse DCT. The 1-D inverse DCT was calculated using a similar algorithm to what was described in [Loeffler]. However, the paper only provided the 8-point and 16-point version of the algorithms, which was adapted by On2 to perform the 4-point 1-D DCT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有DCT反演的计算方法都完全相同。原则上，VP8使用经典的二维离散余弦逆变换，实现为两次一维逆DCT。使用与[Loeffler]中描述的类似算法计算1-D逆DCT。然而，本文只提供了算法的8点和16点版本，On2对其进行了调整，以执行4点1-D DCT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Accurate calculation of 1-D DCT of the above algorithm requires infinite precision. VP8 of course can use only a finite-precision approximation. Also, the inverse DCT used by VP8 takes care of normalization of the standard unitary transform; that is, every dequantized coefficient has roughly double the size of the corresponding unitary coefficient. However, at all but the highest datarates, the discrepancy between transmitted and ideal coefficients is due almost entirely to (lossy) compression and not to errors induced by finite-precision arithmetic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述算法的1-D DCT的精确计算需要无限的精度。VP8当然只能使用有限精度近似值。此外，VP8使用的逆DCT负责标准酉变换的归一化；也就是说，每个去量化系数的大小大约是相应的酉系数的两倍。然而，除了最高的数据速率外，传输系数和理想系数之间的差异几乎完全是由于（有损）压缩，而不是由有限精度算法引起的错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inputs to the inverse DCT (that is, the dequantized coefficients), the intermediate &#34;horizontally detransformed&#34; signal, and the completely detransformed residue signal are all stored as arrays of 16-bit signed integers. The details of the computation are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
逆DCT（即，去量化系数）、中间“水平去变换”信号和完全去变换的剩余信号的输入都存储为16位有符号整数的数组。计算的细节如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It should also be noted that this implementation makes use of the 16-bit fixed-point version of two multiplication constants:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还应注意，此实现使用两个乘法常数的16位定点版本：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   sqrt(2) * cos (pi/8)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   sqrt(2) * cos (pi/8)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   sqrt(2) * sin (pi/8)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   sqrt(2) * sin (pi/8)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the first constant is bigger than 1, to maintain the same 16-bit fixed-point precision as the second one, we make use of the fact that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于第一个常数大于1，为了保持与第二个常数相同的16位定点精度，我们利用以下事实：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   x * a = x + x*(a-1)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   x * a = x + x*(a-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
therefore
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   x * sqrt(2) * cos (pi/8) = x + x * (sqrt(2) * cos(pi/8)-1)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   x * sqrt(2) * cos (pi/8) = x + x * (sqrt(2) * cos(pi/8)-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* IDCT implementation */
   static const int cospi8sqrt2minus1=20091;
   static const int sinpi8sqrt2      =35468;
   void short_idct4x4llm_c(short *input, short *output, int pitch)
   {
     int i;
     int a1, b1, c1, d1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* IDCT implementation */
   static const int cospi8sqrt2minus1=20091;
   static const int sinpi8sqrt2      =35468;
   void short_idct4x4llm_c(short *input, short *output, int pitch)
   {
     int i;
     int a1, b1, c1, d1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     short *ip=input;
     short *op=output;
     int temp1, temp2;
     int shortpitch = pitch&gt;&gt;1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     short *ip=input;
     short *op=output;
     int temp1, temp2;
     int shortpitch = pitch&gt;&gt;1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0]+ip[8];
       b1 = ip[0]-ip[8];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0]+ip[8];
       b1 = ip[0]-ip[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = (ip[4] * sinpi8sqrt2)&gt;&gt;16;
       temp2 = ip[12]+((ip[12] * cospi8sqrt2minus1)&gt;&gt;16);
       c1 = temp1 - temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = (ip[4] * sinpi8sqrt2)&gt;&gt;16;
       temp2 = ip[12]+((ip[12] * cospi8sqrt2minus1)&gt;&gt;16);
       c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = ip[4] + ((ip[4] * cospi8sqrt2minus1)&gt;&gt;16);
       temp2 = (ip[12] * sinpi8sqrt2)&gt;&gt;16;
       d1 = temp1 + temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = ip[4] + ((ip[4] * cospi8sqrt2minus1)&gt;&gt;16);
       temp2 = (ip[12] * sinpi8sqrt2)&gt;&gt;16;
       d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[shortpitch*0] = a1+d1;
       op[shortpitch*3] = a1-d1;
       op[shortpitch*1] = b1+c1;
       op[shortpitch*2] = b1-c1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[shortpitch*0] = a1+d1;
       op[shortpitch*3] = a1-d1;
       op[shortpitch*1] = b1+c1;
       op[shortpitch*2] = b1-c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip++;
       op++;
     }
     ip = output;
     op = output;
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0]+ip[2];
       b1 = ip[0]-ip[2];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip++;
       op++;
     }
     ip = output;
     op = output;
     for(i=0;i&lt;4;i++)
     {
       a1 = ip[0]+ip[2];
       b1 = ip[0]-ip[2];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = (ip[1] * sinpi8sqrt2)&gt;&gt;16;
       temp2 = ip[3]+((ip[3] * cospi8sqrt2minus1)&gt;&gt;16);
       c1 = temp1 - temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = (ip[1] * sinpi8sqrt2)&gt;&gt;16;
       temp2 = ip[3]+((ip[3] * cospi8sqrt2minus1)&gt;&gt;16);
       c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = ip[1] + ((ip[1] * cospi8sqrt2minus1)&gt;&gt;16);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp1 = ip[1] + ((ip[1] * cospi8sqrt2minus1)&gt;&gt;16);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp2 = (ip[3] * sinpi8sqrt2)&gt;&gt;16;
       d1 = temp1 + temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp2 = (ip[3] * sinpi8sqrt2)&gt;&gt;16;
       d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[0] = (a1+d1+4)&gt;&gt;3;
       op[3] = (a1-d1+4)&gt;&gt;3;
       op[1] = (b1+c1+4)&gt;&gt;3;
       op[2] = (b1-c1+4)&gt;&gt;3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       op[0] = (a1+d1+4)&gt;&gt;3;
       op[3] = (a1-d1+4)&gt;&gt;3;
       op[1] = (b1+c1+4)&gt;&gt;3;
       op[2] = (b1-c1+4)&gt;&gt;3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip+=shortpitch;
       op+=shortpitch;
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip+=shortpitch;
       op+=shortpitch;
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference decoder DCT inversion may be found in the file idct_add.c (Section 20.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考解码器DCT反转可在文件idct_add.c（第20.8节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. Summation of Predictor and Residue
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. 预测器与残差之和
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, the prediction and residue signals are summed to form the reconstructed macroblock, which, except for loop filtering (taken up next), completes the decoding process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，将预测信号和残差信号相加，形成重构宏块，除循环滤波（下一步）外，完成解码过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The summing procedure is fairly straightforward, having only a couple of details. The prediction and residue buffers are both arrays of 16-bit signed integers. Each individual (Y, U, and V pixel) result is calculated first as a 32-bit sum of the prediction and residue, and is then saturated to 8-bit unsigned range (using, say, the clamp255 function defined above) before being stored as an 8-bit unsigned pixel value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
求和过程相当简单，只有几个细节。预测和剩余缓冲区都是16位有符号整数的数组。每个单独的（Y、U和V像素）结果首先作为预测和残差的32位和进行计算，然后在存储为8位无符号像素值之前，饱和到8位无符号范围（例如，使用上面定义的clamp255函数）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8 also supports a mode where the encoding of a bitstream guarantees all reconstructed pixel values between 0 and 255; compliant bitstreams of such requirements have the clamp_type bit in the frame header set to 1. In such a case, the clamp255 function is no longer required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8还支持一种模式，其中比特流的编码保证所有重建像素值在0到255之间；此类要求的兼容比特流将帧头中的clamp_类型比特设置为1。在这种情况下，不再需要clamp255功能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The summation process is the same, regardless of the (intra or inter) mode of prediction in effect for the macroblock. The reference decoder implementation of reconstruction may be found in the file idct_add.c.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
求和过程是相同的，而与宏块的有效预测模式（帧内或帧间）无关。重构的参考解码器实现可以在文件idct_add.c中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Loop Filter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 环路滤波器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Loop filtering is the last stage of frame reconstruction and the next-to-last stage of the decoding process. The loop filter is applied to the entire frame after the summation of predictor and residue signals, as described in Section 14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
环路滤波是帧重建的最后一个阶段，也是解码过程的下一个到最后一个阶段。如第14节所述，在预测器信号和剩余信号求和之后，将环路滤波器应用于整个帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the loop filter is to eliminate (or at least reduce) visually objectionable artifacts associated with the semi-independence of the coding of macroblocks and their constituent subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
环路滤波器的目的是消除（或至少减少）与宏块及其组成子块的编码的半独立性相关联的视觉上令人不快的伪影。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As was discussed in Section 5, the loop filter is &#34;integral&#34; to decoding, in that the results of loop filtering are used in the prediction of subsequent frames. Consequently, a functional decoder implementation must perform loop filtering exactly as described here. This is distinct from any postprocessing that may be applied only to the image immediately before display; such postprocessing is entirely at the option of the implementor (and/or user) and has no effect on decoding per se.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第5节所述，环路滤波器与解码是“积分”的，因为环路滤波的结果用于后续帧的预测。因此，功能解码器实现必须完全按照此处所述执行循环滤波。这不同于仅在显示之前应用于图像的任何后处理；这种后处理完全由实现者（和/或用户）选择，对解码本身没有影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The baseline frame-level parameters controlling the loop filter are defined in the frame header (Section 9.4) along with a mechanism for adjustment based on a macroblock&#39;s prediction mode and/or reference frame. The first is a flag (filter_type) selecting the type of filter (normal or simple); the other two are numbers (loop_filter_level and sharpness_level) that adjust the strength or sensitivity of the filter. As described in Sections 9.3 and 10, loop_filter_level may also be overridden on a per-macroblock basis using segmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
控制环路滤波器的基线帧级参数在帧头（第9.4节）中定义，以及基于宏块的预测模式和/或参考帧的调整机制。第一个是选择过滤器类型（普通或简单）的标志（过滤器类型）；另外两个是数字（环路滤波器电平和锐度电平），用于调整滤波器的强度或灵敏度。如第9.3节和第10节所述，还可以使用分段在每个宏块的基础上覆盖循环过滤器级别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Loop filtering is one of the more computationally intensive aspects of VP8 decoding. This is the reason for the existence of the optional, less-demanding simple filter type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
环路滤波是VP8解码的计算密集型方面之一。这就是存在可选、要求较低的简单过滤器类型的原因。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note carefully that loop filtering must be skipped entirely if loop_filter_level at either the frame header level or macroblock override level is 0. In no case should the loop filter be run with a value of 0; it should instead be skipped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，如果帧头级别或宏块覆盖级别的循环过滤器级别为0，则必须完全跳过循环过滤。在任何情况下，循环过滤器的运行值均不得为0；应该跳过它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We begin by discussing the aspects of loop filtering that are independent of the controlling parameters and type of filter chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们首先讨论环路滤波的各个方面，这些方面与所选择的控制参数和滤波器类型无关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. Filter Geometry and Overall Procedure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.1. 过滤器几何结构和总体程序
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Y, U, and V planes are processed independently and identically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Y、U和V平面分别进行相同的处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The loop filter acts on the edges between adjacent macroblocks and on the edges between adjacent subblocks of a macroblock. All such edges are horizontal or vertical. For each pixel position on an edge, a small number (two or three) of pixels adjacent to either side of the position are examined and possibly modified. The displacements of these pixels are at a right angle to the edge orientation; that is, for a horizontal edge, we treat the pixels immediately above and below the edge position, and for a vertical edge, we treat the pixels immediately to the left and right of the edge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
循环滤波器作用于相邻宏块之间的边缘和宏块的相邻子块之间的边缘。所有这些边缘都是水平或垂直的。对于边缘上的每个像素位置，检查并可能修改与该位置任一侧相邻的少量（两个或三个）像素。这些像素的位移与边缘方向成直角；也就是说，对于水平边缘，我们处理边缘位置正上方和正下方的像素，对于垂直边缘，我们处理边缘左右两侧的像素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We call this collection of pixels associated to an edge position a segment; the length of a segment is 2, 4, 6, or 8. Excepting that the normal filter uses slightly different algorithms for, and either filter may apply different control parameters to, the edges between macroblocks and those between subblocks, the treatment of edges is quite uniform: All segments straddling an edge are treated identically; there is no distinction between the treatment of horizontal and vertical edges, whether between macroblocks or between subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们将与边缘位置相关联的像素集合称为一段；线段的长度为2、4、6或8。除了普通滤波器对宏块之间的边和子块之间的边使用略微不同的算法，并且任一滤波器可以对宏块之间的边和子块之间的边应用不同的控制参数外，对边的处理是相当一致的：横跨边的所有段都被相同地处理；无论是宏块之间还是子块之间，水平边缘和垂直边缘的处理都没有区别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As a consequence, adjacent subblock edges within a macroblock may be concatenated and processed in their entirety. There is a single 8-pixel-long vertical edge horizontally centered in each of the U and V blocks (the concatenation of upper and lower 4-pixel edges between chroma subblocks), and three 16-pixel-long vertical edges at horizontal positions 1/4, 1/2, and 3/4 the width of the luma macroblock, each representing the concatenation of four 4-pixel sub-edges between pairs of Y subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结果，宏块内的相邻子块边缘可以全部连接和处理。在每个U和V块中水平居中有一个8像素长的垂直边（色度子块之间的上下4像素边的串联），在亮度宏块宽度的水平位置1/4、1/2和3/4处有三个16像素长的垂直边，每个表示Y子块对之间四个4像素子边的串联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macroblocks comprising the frame are processed in the usual raster-scan order. Each macroblock is &#34;responsible for&#34; the inter-macroblock edges immediately above and to the left of it (but not the edges below and to the right of it), as well as the edges between its subblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
构成帧的宏块按照通常的光栅扫描顺序进行处理。每个宏块“负责”其正上方和左侧的宏块间边缘（但不负责其下方和右侧的边缘），以及其子块之间的边缘。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each macroblock M, there are four filtering steps, which are, (almost) in order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个宏块M，有四个过滤步骤，其顺序为（几乎）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. If M is not on the leftmost column of macroblocks, filter across the left (vertical) inter-macroblock edge of M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 如果M不在宏块的最左侧列上，则在M的左侧（垂直）宏块间边缘进行过滤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Filter across the vertical subblock edges within M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 过滤M内的垂直子块边缘。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If M is not on the topmost row of macroblocks, filter across the top (horizontal) inter-macroblock edge of M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 如果M不在宏块的最顶层行，则在M的顶部（水平）宏块间边缘进行过滤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Filter across the horizontal subblock edges within M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 过滤M内的水平子块边缘。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We write MY, MU, and MV for the planar constituents of M, that is, the 16x16 luma block, 8x8 U block, and 8x8 V block comprising M.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们为M的平面成分编写MY、MU和MV，即16x16 luma块、8x8 U块和包含M的8x8 V块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In step 1, for each of the three blocks MY, MU, and MV, we filter each of the (16 luma or 8 chroma) segments straddling the column separating the block from the block immediately to the left of it, using the inter-macroblock filter and controls associated to the loop_filter_level and sharpness_level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在步骤1中，对于三个块MY、MU和MV中的每一个，我们使用宏块间过滤器和与loop_filter_level和sharpness_level相关联的控件，过滤横跨将块与其左侧块分离的列的每个（16 luma或8色度）段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In step 4, we filter across the (three luma and one each for U and V) vertical subblock edges described above, this time using the inter-subblock filter and controls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在步骤4中，我们过滤上述垂直子块边缘（三个luma，每个luma用于U和V），这次使用子块间过滤器和控件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Steps 2 and 4 are skipped for macroblocks that satisfy both of the following two conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于同时满足以下两个条件的宏块，跳过步骤2和4：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Macroblock coding mode is neither B_PRED nor SPLITMV; and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 宏块编码模式既不是B_PRED也不是SPLITMV；和
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. There is no DCT coefficient coded for the whole macroblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 整个宏块没有DCT系数编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For these macroblocks, loop filtering for edges between subblocks internal to a macroblock is effectively skipped. This skip strategy significantly reduces VP8 loop-filtering complexity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于这些宏块，有效地跳过宏块内部子块之间的边的循环过滤。这种跳过策略显著降低了VP8循环过滤的复杂性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Edges between macroblocks and those between subblocks are treated with different control parameters (and, in the case of the normal filter, with different algorithms). Except for pixel addressing, there is no distinction between the treatment of vertical and horizontal edges. Luma edges are always 16 pixels long, chroma edges are always 8 pixels long, and the segments straddling an edge are treated identically; this of course facilitates vector processing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏块之间的边缘和子块之间的边缘用不同的控制参数处理（在普通滤波器的情况下，用不同的算法处理）。除了像素寻址，垂直和水平边缘的处理没有区别。亮度边缘始终为16像素长，色度边缘始终为8像素长，跨边的线段处理相同；这当然有助于向量处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because many pixels belong to segments straddling two or more edges, and so will be filtered more than once, the order in which edges are processed given above must be respected by any implementation. Within a single edge, however, the segments straddling that edge are disjoint, and the order in which these segments are processed is immaterial.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于许多像素属于跨越两条或多条边的线段，因此将被多次过滤，因此任何实现都必须遵守上面给出的边处理顺序。但是，在一条边内，跨越该边的线段是不相交的，处理这些线段的顺序无关紧要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before taking up the filtering algorithms themselves, we should emphasize a point already made: Even though the pixel segments associated to a macroblock are antecedent to the macroblock (that is, lie within the macroblock or in already-constructed macroblocks), a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在讨论过滤算法本身之前，我们应该强调已经提出的一点：即使与宏块相关联的像素段在宏块之前（即，位于宏块内或在已经构造的宏块中），但是
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
macroblock must not be filtered immediately after its &#34;reconstruction&#34; (described in Section 14). Rather, the loop filter applies after all the macroblocks have been &#34;reconstructed&#34; (i.e., had their predictor summed with their residue); correct decoding is predicated on the fact that already-constructed portions of the current frame referenced via intra-prediction (described in Section 12) are not yet filtered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏块“重建”后不得立即过滤（如第14节所述）。相反，在所有宏块都已“重建”（即，将其预测器与其余数求和）之后应用循环滤波器；正确解码的前提是，通过帧内预测（在第12节中描述）引用的当前帧的已经构造的部分尚未被过滤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. Simple Filter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.2. 简单过滤器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Having described the overall procedure of, and pixels affected by, the loop filter, we turn our attention to the treatment of individual segments straddling edges. We begin by describing the simple filter, which, as the reader might guess, is somewhat simpler than the normal filter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在描述了环路滤波器的整体过程和受其影响的像素之后，我们将注意力转向处理跨越边缘的各个分段。我们首先描述简单过滤器，正如读者可能猜测的那样，它比普通过滤器稍微简单一些。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the simple filter only applies to luma edges. Chroma edges are left unfiltered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，简单过滤器仅适用于luma边。色度边缘未经过滤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Roughly speaking, the idea of loop filtering is, within limits, to reduce the difference between pixels straddling an edge. Differences in excess of a threshold (associated to the loop_filter_level) are assumed to be &#34;natural&#34; and are unmodified; differences below the threshold are assumed to be artifacts of quantization and the (partially) separate coding of blocks, and are reduced via the procedures described below. While the loop_filter_level is in principle arbitrary, the levels chosen by a VP8 compressor tend to be correlated to quantizer levels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
粗略地说，循环过滤的思想是在一定范围内减少跨越边缘的像素之间的差异。超过阈值的差异（与环路滤波器电平相关）被认为是“自然”的且未经修改；低于阈值的差异被假定为量化的伪影和块的（部分）单独编码，并且通过下面描述的过程被减少。虽然环路滤波器电平原则上是任意的，但VP8压缩器选择的电平往往与量化器电平相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most of the filtering arithmetic is done using 8-bit signed operands (having a range of -128 to +127, inclusive), supplemented by 16-bit temporaries holding results of multiplies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大多数滤波算法都是使用8位有符号操作数（范围为-128到+127，包括-128到+127）完成的，并辅之以保存乘法结果的16位临时操作数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sums and other temporaries need to be &#34;clamped&#34; to a valid signed 8-bit range:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总和和其他临时值需要“钳制”到有效的有符号8位范围：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int8 c(int v)
   {
       return (int8) (v &lt; -128 ? -128 : (v &lt; 128 ? v : 127));
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int8 c(int v)
   {
       return (int8) (v &lt; -128 ? -128 : (v &lt; 128 ? v : 127));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since pixel values themselves are unsigned 8-bit numbers, we need to convert between signed and unsigned values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于像素值本身是无符号8位数字，我们需要在有符号值和无符号值之间进行转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Convert pixel value (0 &lt;= v &lt;= 255) to an 8-bit signed
      number. */
   int8 u2s(Pixel v) { return (int8) (v - 128);}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Convert pixel value (0 &lt;= v &lt;= 255) to an 8-bit signed
      number. */
   int8 u2s(Pixel v) { return (int8) (v - 128);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Clamp, then convert signed number back to pixel value. */
   Pixel s2u(int v) { return (Pixel) (c(v) + 128);}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Clamp, then convert signed number back to pixel value. */
   Pixel s2u(int v) { return (Pixel) (c(v) + 128);}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Filtering is often predicated on absolute-value thresholds. The following function is the equivalent of the standard library function abs, whose prototype is found in the standard header file stdlib.h. For us, the argument v is always the difference between two pixels and lies in the range -255 &lt;= v &lt;= +255.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
过滤通常基于绝对值阈值。以下函数相当于标准库函数abs，其原型可在标准头文件stdlib.h中找到。对于我们来说，参数v始终是两个像素之间的差值，并且位于-255&lt;=v&lt;=255的范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int abs(int v) { return v &lt; 0?  -v : v;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int abs(int v) { return v &lt; 0?  -v : v;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An actual implementation would of course use inline functions or macros to accomplish these trivial procedures (which are used by both the normal and simple loop filters). An optimal implementation would probably express them in machine language, perhaps using single instruction, multiple data (SIMD) vector instructions. On many SIMD processors, the saturation accomplished by the above clamping function is often folded into the arithmetic instructions themselves, obviating the explicit step taken here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实际的实现当然会使用内联函数或宏来完成这些琐碎的过程（普通循环过滤器和简单循环过滤器都使用这些过程）。一个最佳的实现可能会用机器语言来表达它们，可能会使用单指令多数据（SIMD）向量指令。在许多SIMD处理器上，通过上述箝位函数实现的饱和通常被折叠到算术指令本身中，从而避免了此处采取的显式步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To simplify the specification of relative pixel positions, we use the word &#34;before&#34; to mean &#34;immediately above&#34; (for a vertical segment straddling a horizontal edge) or &#34;immediately to the left of&#34; (for a horizontal segment straddling a vertical edge), and the word &#34;after&#34; to mean &#34;immediately below&#34; or &#34;immediately to the right of&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了简化对相对像素位置的说明，我们使用“before”一词表示“紧上方”（对于横跨水平边缘的垂直段）或“紧靠左侧”（对于横跨垂直边缘的水平段），使用“after”一词表示“紧靠下方”或“紧靠右侧”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given an edge, a segment, and a limit value, the simple loop filter computes a value based on the four pixels that straddle the edge (two either side). If that value is below a supplied limit, then, very roughly speaking, the two pixel values are brought closer to each other, &#34;shaving off&#34; something like a quarter of the difference. The
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定一条边、一个段和一个限制值，简单循环过滤器将基于横跨该边的四个像素（两边各两个）计算一个值。如果该值低于提供的限制，那么，非常粗略地说，这两个像素值彼此更接近，“去除”大约四分之一的差异。这个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
same procedure is used for all segments straddling any type of edge, regardless of the nature (inter-macroblock, inter-subblock, luma, or chroma) of the edge; only the limit value depends on the edge type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于跨越任何类型边缘的所有段，无论边缘的性质（宏块间、子块间、亮度或色度）如何，都使用相同的程序；仅限值取决于边类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact procedure (for a single segment) is as follows; the subroutine common_adjust is used by both the simple filter presented here and the normal filters discussed in Section 15.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体程序（针对单个管段）如下所示：；这里介绍的简单滤波器和第15.3节讨论的普通滤波器都使用了子程序common_adjust。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int8 common_adjust(
       int use_outer_taps,   /* filter is 2 or 4 taps wide */
       const Pixel *P1,    /* pixel before P0 */
       Pixel *P0,          /* pixel before edge */
       Pixel *Q0,          /* pixel after edge */
       const Pixel *Q1     /* pixel after Q0 */
   ) {
       cint8 p1 = u2s(*P1);   /* retrieve and convert all 4 pixels */
       cint8 p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0);
       cint8 q1 = u2s(*Q1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int8 common_adjust(
       int use_outer_taps,   /* filter is 2 or 4 taps wide */
       const Pixel *P1,    /* pixel before P0 */
       Pixel *P0,          /* pixel before edge */
       Pixel *Q0,          /* pixel after edge */
       const Pixel *Q1     /* pixel after Q0 */
   ) {
       cint8 p1 = u2s(*P1);   /* retrieve and convert all 4 pixels */
       cint8 p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0);
       cint8 q1 = u2s(*Q1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Disregarding clamping, when &#34;use_outer_taps&#34; is false,
          &#34;a&#34; is 3*(q0-p0).  Since we are about to divide &#34;a&#34; by
          8, in this case we end up multiplying the edge
          difference by 5/8.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Disregarding clamping, when &#34;use_outer_taps&#34; is false,
          &#34;a&#34; is 3*(q0-p0).  Since we are about to divide &#34;a&#34; by
          8, in this case we end up multiplying the edge
          difference by 5/8.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          When &#34;use_outer_taps&#34; is true (as for the simple filter),
          &#34;a&#34; is p1 - 3*p0 + 3*q0 - q1, which can be thought of as
          a refinement of 2*(q0 - p0), and the adjustment is
          something like (q0 - p0)/4. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          When &#34;use_outer_taps&#34; is true (as for the simple filter),
          &#34;a&#34; is p1 - 3*p0 + 3*q0 - q1, which can be thought of as
          a refinement of 2*(q0 - p0), and the adjustment is
          something like (q0 - p0)/4. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int8 a = c((use_outer_taps? c(p1 - q1) : 0) + 3*(q0 - p0));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int8 a = c((use_outer_taps? c(p1 - q1) : 0) + 3*(q0 - p0));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* b is used to balance the rounding of a/8 in the case where
          the &#34;fractional&#34; part &#34;f&#34; of a/8 is exactly 1/2. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* b is used to balance the rounding of a/8 in the case where
          the &#34;fractional&#34; part &#34;f&#34; of a/8 is exactly 1/2. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cint8 b = (c(a + 3)) &gt;&gt; 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cint8 b = (c(a + 3)) &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Divide a by 8, rounding up when f &gt;= 1/2.
          Although not strictly part of the C language,
          the right shift is assumed to propagate the sign bit. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Divide a by 8, rounding up when f &gt;= 1/2.
          Although not strictly part of the C language,
          the right shift is assumed to propagate the sign bit. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = c(a + 4) &gt;&gt; 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = c(a + 4) &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Subtract &#34;a&#34; from q0, &#34;bringing it closer&#34; to p0. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Subtract &#34;a&#34; from q0, &#34;bringing it closer&#34; to p0. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       *Q0 = s2u(q0 - a);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       *Q0 = s2u(q0 - a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Add &#34;a&#34; (with adjustment &#34;b&#34;) to p0, &#34;bringing it closer&#34;
          to q0.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Add &#34;a&#34; (with adjustment &#34;b&#34;) to p0, &#34;bringing it closer&#34;
          to q0.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          The clamp of &#34;a+b&#34;, while present in the reference decoder,
          is superfluous; we have -16 &lt;= a &lt;= 15 at this point. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          The clamp of &#34;a+b&#34;, while present in the reference decoder,
          is superfluous; we have -16 &lt;= a &lt;= 15 at this point. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       *P0 = s2u(p0 + b);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       *P0 = s2u(p0 + b);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return a;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return a;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void simple_segment(
       uint8 edge_limit,   /* do nothing if edge difference
                              exceeds limit */
       const Pixel *P1,    /* pixel before P0 */
       Pixel *P0,          /* pixel before edge */
       Pixel *Q0,          /* pixel after edge */
       const Pixel *Q1     /* pixel after Q0 */
   ) {
       if ((abs(*P0 - *Q0)*2 + abs(*P1 - *Q1)/2) &lt;= edge_limit))
           common_adjust(1, P1, P0, Q0, Q1);   /* use outer taps */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void simple_segment(
       uint8 edge_limit,   /* do nothing if edge difference
                              exceeds limit */
       const Pixel *P1,    /* pixel before P0 */
       Pixel *P0,          /* pixel before edge */
       Pixel *Q0,          /* pixel after edge */
       const Pixel *Q1     /* pixel after Q0 */
   ) {
       if ((abs(*P0 - *Q0)*2 + abs(*P1 - *Q1)/2) &lt;= edge_limit))
           common_adjust(1, P1, P0, Q0, Q1);   /* use outer taps */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We make a couple of remarks about the rounding procedure above. When b is zero (that is, when the &#34;fractional part&#34; of a is not 1/2), we are (except for clamping) adding the same number to p0 as we are subtracting from q0. This preserves the average value of p0 and q0, but the resulting difference between p0 and q0 is always even; in particular, the smallest non-zero gradation +-1 is not possible here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们对上述四舍五入程序作几点评论。当b为零时（即，当a的“分数部分”不是1/2时），我们（除了钳位）向p0添加的数字与从q0中减去的数字相同。这保留了p0和q0的平均值，但由此产生的p0和q0之间的差异始终是均匀的；特别是，此处不可能出现最小的非零灰度+-1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When b is one, the value we add to p0 (again except for clamping) is one less than the value we are subtracting from q0. In this case, the resulting difference is always odd (and the small gradation +-1 is possible), but the average value is reduced by 1/2, yielding, for instance, a very slight darkening in the luma plane. (In the very unlikely event of appreciable darkening after a large number of interframes, a compressor would of course eventually compensate for this in the selection of predictor and/or residue.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当b为1时，我们加在p0上的值（同样，除了箝位）比我们从q0中减去的值小1。在这种情况下，产生的差异总是奇数（并且小灰度+-1是可能的），但是平均值减少1/2，例如，在亮度平面中产生非常轻微的变暗。（在大量帧后出现明显变暗的极不可能的情况下，压缩机当然最终会在预测器和/或残差的选择中对此进行补偿。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The derivation of the edge_limit value used above, which depends on the loop_filter_level and sharpness_level, as well as the type of edge being processed, will be taken up after we describe the normal loop filtering algorithm below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在我们描述了下面的正常循环滤波算法后，将开始推导上面使用的边缘极限值，该极限值取决于循环滤波水平和锐度水平，以及正在处理的边缘类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3. Normal Filter
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.3. 普通滤波器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The normal loop filter is a refinement of the simple loop filter; all of the general discussion above applies here as well. In particular, the functions c, u2s, s2u, abs, and common_adjust are used by both the normal and simple filters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
普通环路滤波器是简单环路滤波器的改进；上面所有的一般性讨论也适用于这里。特别是，普通和简单滤波器都使用功能c、u2s、s2u、abs和common_adjust。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As mentioned above, the normal algorithms for inter-macroblock and inter-subblock edges differ. Nonetheless, they have a great deal in common: They use similar threshold algorithms to disable the filter and to detect high internal edge variance (which influences the filtering algorithm). Both algorithms also use, at least conditionally, the simple filter adjustment procedure described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述，宏块间和子块间边缘的常规算法不同。尽管如此，它们有很多共同点：它们使用类似的阈值算法来禁用过滤器并检测较高的内部边缘方差（这会影响过滤算法）。这两种算法还至少有条件地使用上述简单的滤波器调整程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The common thresholding algorithms are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
常用的阈值算法如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* All functions take (among other things) a segment (of length
      at most 4 + 4 = 8) symmetrically straddling an edge.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* All functions take (among other things) a segment (of length
      at most 4 + 4 = 8) symmetrically straddling an edge.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      The pixel values (or pointers) are always given in order,
      from the &#34;beforemost&#34; to the &#34;aftermost&#34;.  So, for a
      horizontal edge (written &#34;|&#34;), an 8-pixel segment would be
      ordered p3 p2 p1 p0 | q0 q1 q2 q3. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      The pixel values (or pointers) are always given in order,
      from the &#34;beforemost&#34; to the &#34;aftermost&#34;.  So, for a
      horizontal edge (written &#34;|&#34;), an 8-pixel segment would be
      ordered p3 p2 p1 p0 | q0 q1 q2 q3. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Filtering is disabled if the difference between any two
      adjacent &#34;interior&#34; pixels in the 8-pixel segment exceeds
      the relevant threshold (I).  A more complex thresholding
      calculation is done for the group of four pixels that
      straddle the edge, in line with the calculation in
      simple_segment() above. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Filtering is disabled if the difference between any two
      adjacent &#34;interior&#34; pixels in the 8-pixel segment exceeds
      the relevant threshold (I).  A more complex thresholding
      calculation is done for the group of four pixels that
      straddle the edge, in line with the calculation in
      simple_segment() above. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int filter_yes(
       uint8 I,        /* limit on interior differences */
       uint8 E,        /* limit at the edge */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int filter_yes(
       uint8 I,        /* limit on interior differences */
       uint8 E,        /* limit at the edge */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cint8 p3, cint8 p2, cint8 p1, cint8 p0, /* pixels before
                                                  edge */
       cint8 q0, cint8 q1, cint8 q2, cint8 q3  /* pixels after
                                                  edge */
   ) {
       return  (abs(p0 - q0)*2 + abs(p1 - q1)/2) &lt;= E
           &amp;&amp;  abs(p3 - p2) &lt;= I  &amp;&amp;  abs(p2 - p1) &lt;= I  &amp;&amp;
             abs(p1 - p0) &lt;= I
           &amp;&amp;  abs(q3 - q2) &lt;= I  &amp;&amp;  abs(q2 - q1) &lt;= I  &amp;&amp;
             abs(q1 - q0) &lt;= I;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cint8 p3, cint8 p2, cint8 p1, cint8 p0, /* pixels before
                                                  edge */
       cint8 q0, cint8 q1, cint8 q2, cint8 q3  /* pixels after
                                                  edge */
   ) {
       return  (abs(p0 - q0)*2 + abs(p1 - q1)/2) &lt;= E
           &amp;&amp;  abs(p3 - p2) &lt;= I  &amp;&amp;  abs(p2 - p1) &lt;= I  &amp;&amp;
             abs(p1 - p0) &lt;= I
           &amp;&amp;  abs(q3 - q2) &lt;= I  &amp;&amp;  abs(q2 - q1) &lt;= I  &amp;&amp;
             abs(q1 - q0) &lt;= I;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Filtering is altered if (at least) one of the differences
      on either side of the edge exceeds a threshold (we have
      &#34;high edge variance&#34;). */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Filtering is altered if (at least) one of the differences
      on either side of the edge exceeds a threshold (we have
      &#34;high edge variance&#34;). */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int hev(
       uint8 threshold,
       cint8 p1, cint8 p0, /* pixels before edge */
       cint8 q0, cint8 q1  /* pixels after edge */
   ) {
       return abs(p1 - p0) &gt; threshold  ||  abs(q1 - q0) &gt; threshold;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int hev(
       uint8 threshold,
       cint8 p1, cint8 p0, /* pixels before edge */
       cint8 q0, cint8 q1  /* pixels after edge */
   ) {
       return abs(p1 - p0) &gt; threshold  ||  abs(q1 - q0) &gt; threshold;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The subblock filter is a variant of the simple filter. In fact, if we have high edge variance, the adjustment is exactly as for the simple filter. Otherwise, the simple adjustment (without outer taps) is applied, and the two pixels one step in from the edge pixels are adjusted by roughly half the amount by which the two edge pixels are adjusted; since the edge adjustment here is essentially 3/8 the edge difference, the inner adjustment is approximately 3/16 the edge difference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子块过滤器是简单过滤器的一种变体。事实上，如果我们有很高的边缘方差，调整是完全一样的简单过滤器。否则，应用简单调整（无外部抽头），并且从边缘像素一步进的两个像素被调整大约两个边缘像素被调整的量的一半；因为这里的边缘调整基本上是边缘差的3/8，所以内部调整大约是边缘差的3/16。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void subblock_filter(
       uint8 hev_threshold,     /* detect high edge variance */
       uint8 interior_limit,    /* possibly disable filter */
       uint8 edge_limit,
       cint8 *P3, cint8 *P2, int8 *P1, int8 *P0,   /* pixels before
                                                      edge */
       int8 *Q0, int8 *Q1, cint8 *Q2, cint8 *Q3    /* pixels after
                                                      edge */
   ) {
       cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),
         p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),
         q3 = u2s(*Q3);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void subblock_filter(
       uint8 hev_threshold,     /* detect high edge variance */
       uint8 interior_limit,    /* possibly disable filter */
       uint8 edge_limit,
       cint8 *P3, cint8 *P2, int8 *P1, int8 *P0,   /* pixels before
                                                      edge */
       int8 *Q0, int8 *Q1, cint8 *Q2, cint8 *Q3    /* pixels after
                                                      edge */
   ) {
       cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),
         p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),
         q3 = u2s(*Q3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0,
         p0, p1, p2, p3))
       {
           const int hv = hev(hev_threshold, p1, p0, q0, q1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0,
         p0, p1, p2, p3))
       {
           const int hv = hev(hev_threshold, p1, p0, q0, q1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           cint8 a = (common_adjust(hv, P1, P0, Q0, Q1) + 1) &gt;&gt; 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           cint8 a = (common_adjust(hv, P1, P0, Q0, Q1) + 1) &gt;&gt; 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!hv) {
               *Q1 = s2u(q1 - a);
               *P1 = s2u(p1 + a);
           }
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!hv) {
               *Q1 = s2u(q1 - a);
               *P1 = s2u(p1 + a);
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The inter-macroblock filter has potentially wider scope. If the edge variance is high, it performs the simple adjustment (using the outer taps, just like the simple filter and the corresponding case of the normal subblock filter). If the edge variance is low, we begin with the same basic filter calculation and apply multiples of it to pixel pairs symmetric about the edge; the magnitude of adjustment decays as we move away from the edge and six of the pixels in the segment are affected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏块间滤波器具有潜在的更大范围。如果边缘方差较高，则执行简单调整（使用外部抽头，就像简单滤波器和正常子块滤波器的相应情况一样）。如果边缘方差较低，我们从相同的基本滤波器计算开始，并将其倍数应用于边缘对称的像素对；当我们离开边缘时，调整的幅度会衰减，并且段中的六个像素会受到影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void MBfilter(
       uint8 hev_threshold,     /* detect high edge variance */
       uint8 interior_limit,    /* possibly disable filter */
       uint8 edge_limit,
       cint8 *P3, int8 *P2, int8 *P1, int8 *P0,  /* pixels before
                                                    edge */
       int8 *Q0, int8 *Q1, int8 *Q2, cint8 *Q3   /* pixels after
                                                    edge */
   ) {
       cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),
         p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),
         q3 = u2s(*Q3);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void MBfilter(
       uint8 hev_threshold,     /* detect high edge variance */
       uint8 interior_limit,    /* possibly disable filter */
       uint8 edge_limit,
       cint8 *P3, int8 *P2, int8 *P1, int8 *P0,  /* pixels before
                                                    edge */
       int8 *Q0, int8 *Q1, int8 *Q2, cint8 *Q3   /* pixels after
                                                    edge */
   ) {
       cint8 p3 = u2s(*P3), p2 = u2s(*P2), p1 = u2s(*P1),
         p0 = u2s(*P0);
       cint8 q0 = u2s(*Q0), q1 = u2s(*Q1), q2 = u2s(*Q2),
         q3 = u2s(*Q3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0,
         p0, p1, p2, p3))
       {
           if (!hev(hev_threshold, p1, p0, q0, q1))
           {
               /* Same as the initial calculation in &#34;common_adjust&#34;,
                  w is something like twice the edge difference */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_yes(interior_limit, edge_limit, q3, q2, q1, q0,
         p0, p1, p2, p3))
       {
           if (!hev(hev_threshold, p1, p0, q0, q1))
           {
               /* Same as the initial calculation in &#34;common_adjust&#34;,
                  w is something like twice the edge difference */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               const int8 w = c(c(p1 - q1) + 3*(q0 - p0));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               const int8 w = c(c(p1 - q1) + 3*(q0 - p0));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* 9/64 is approximately 9/63 = 1/7, and 1&lt;&lt;7 = 128 =
                  2*64.  So this a, used to adjust the pixels adjacent
                  to the edge, is something like 3/7 the edge
                  difference. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* 9/64 is approximately 9/63 = 1/7, and 1&lt;&lt;7 = 128 =
                  2*64.  So this a, used to adjust the pixels adjacent
                  to the edge, is something like 3/7 the edge
                  difference. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               int8 a = c((27*w + 63) &gt;&gt; 7);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               int8 a = c((27*w + 63) &gt;&gt; 7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *Q0 = s2u(q0 - a);  *P0 = s2u(p0 + a);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *Q0 = s2u(q0 - a);  *P0 = s2u(p0 + a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* Next two are adjusted by 2/7 the edge difference */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* Next two are adjusted by 2/7 the edge difference */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               a = c((18*w + 63) &gt;&gt; 7);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               a = c((18*w + 63) &gt;&gt; 7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *Q1 = s2u(q1 - a);  *P1 = s2u(p1 + a);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *Q1 = s2u(q1 - a);  *P1 = s2u(p1 + a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* Last two are adjusted by 1/7 the edge difference */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* Last two are adjusted by 1/7 the edge difference */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               a = c((9*w + 63) &gt;&gt; 7);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               a = c((9*w + 63) &gt;&gt; 7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *Q2 = s2u(q2 - a);  *P2 = s2u(p2 + a);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *Q2 = s2u(q2 - a);  *P2 = s2u(p2 + a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           } else                      /* if hev, do simple filter */
               common_adjust(1, P1, P0, Q0, Q1);   /* using outer
                                                       taps */
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           } else                      /* if hev, do simple filter */
               common_adjust(1, P1, P0, Q0, Q1);   /* using outer
                                                       taps */
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4. Calculation of Control Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15.4. 控制参数的计算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We conclude the discussion of loop filtering by showing how the thresholds supplied to the procedures above are derived from the two control parameters sharpness_level (an unsigned 3-bit number having maximum value 7) and loop_filter_level (an unsigned 6-bit number having maximum value 63).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们通过展示提供给上述过程的阈值是如何从两个控制参数sharpness_level（最大值为7的无符号3位数字）和loop_filter_level（最大值为63的无符号6位数字）导出的，从而结束对循环过滤的讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the sharpness_level is constant over the frame, individual macroblocks may override the loop_filter_level with one of four possibilities supplied in the frame header (as described in Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然锐度_级别在帧上是恒定的，但是单个宏块可以使用帧头中提供的四种可能性之一覆盖循环_过滤器_级别（如第10节所述）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the simple and normal filters disable filtering if a value derived from the four pixels that straddle the edge (2 either side) exceeds a threshold / limit value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果从横跨边缘（两侧各2个）的四个像素派生的值超过阈值/限制值，则简单过滤器和普通过滤器都会禁用过滤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Luma and Chroma use the same inter-macroblock edge limit */
   uint8 mbedge_limit = ((loop_filter_level + 2) * 2) +
     interior_limit;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Luma and Chroma use the same inter-macroblock edge limit */
   uint8 mbedge_limit = ((loop_filter_level + 2) * 2) +
     interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Luma and Chroma use the same inter-subblock edge limit */
   uint8 sub_bedge_limit = (loop_filter_level * 2) + interior_limit;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Luma and Chroma use the same inter-subblock edge limit */
   uint8 sub_bedge_limit = (loop_filter_level * 2) + interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining thresholds are used only by the normal filters. The filter-disabling interior difference limit is the same for all edges (luma, chroma, inter-subblock, inter-macroblock) and is given by the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其余的阈值仅由普通过滤器使用。禁用过滤器的内部差异限制对于所有边缘（亮度、色度、子块间、宏块间）都是相同的，如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8 interior_limit = loop_filter_level;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8内部\u限值=环路\u过滤器\u电平；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (sharpness_level)
   {
       interior_limit  &gt;&gt;=  sharpness_level &gt; 4 ?  2 : 1;
       if (interior_limit &gt; 9 - sharpness_level)
           interior_limit = 9 - sharpness_level;
   }
   if (!interior_limit)
       interior_limit = 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (sharpness_level)
   {
       interior_limit  &gt;&gt;=  sharpness_level &gt; 4 ?  2 : 1;
       if (interior_limit &gt; 9 - sharpness_level)
           interior_limit = 9 - sharpness_level;
   }
   if (!interior_limit)
       interior_limit = 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we give the derivation of the high edge-variance threshold, which is also the same for all edge types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，我们给出了高边缘方差阈值的推导，这对于所有边缘类型也是相同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8 hev_threshold = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uint8 hev_阈值=0；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (we_are_decoding_akey_frame)   /* current frame is a key frame */
   {
       if (loop_filter_level &gt;= 40)
           hev_threshold = 2;
       else if (loop_filter_level &gt;= 15)
           hev_threshold = 1;
   }
   else                            /* current frame is an interframe */
   {
       if (loop_filter_level &gt;= 40)
           hev_threshold = 3;
       else if (loop_filter_level &gt;= 20)
           hev_threshold = 2;
       else if (loop_filter_level &gt;= 15)
           hev_threshold = 1;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (we_are_decoding_akey_frame)   /* current frame is a key frame */
   {
       if (loop_filter_level &gt;= 40)
           hev_threshold = 2;
       else if (loop_filter_level &gt;= 15)
           hev_threshold = 1;
   }
   else                            /* current frame is an interframe */
   {
       if (loop_filter_level &gt;= 40)
           hev_threshold = 3;
       else if (loop_filter_level &gt;= 20)
           hev_threshold = 2;
       else if (loop_filter_level &gt;= 15)
           hev_threshold = 1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. Interframe Macroblock Prediction Records
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. 帧间宏块预测记录
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We describe the layout and semantics of the prediction records for macroblocks in an interframe.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们描述帧间宏块预测记录的布局和语义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the feature specification (which is described in Section 10 and is identical for intraframes and interframes), there comes a Bool(prob_intra), which indicates inter-prediction (i.e., prediction from prior frames) when true and intra-prediction (i.e., prediction from already-coded portions of the current frame) when false. The zero-probability prob_intra is set by field J of the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在特征规范（在第10节中描述并且对于帧内和帧间相同）之后，出现Bool（prob_intra），当为真时指示帧间预测（即，来自先前帧的预测），当为假时指示帧内预测（即，来自当前帧的已编码部分的预测）。零概率prob_intra由帧头的字段J设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. Intra-Predicted Macroblocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. 帧内预测宏块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For intra-prediction, the layout of the prediction data is essentially the same as the layout for key frames, although the contexts used by the decoding process are slightly different.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于帧内预测，预测数据的布局基本上与关键帧的布局相同，尽管解码过程使用的上下文略有不同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in Section 8, the &#34;outer&#34; Y mode here uses a different tree from that used in key frames, repeated here for convenience.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第8节所述，此处的“外部”Y模式使用与关键帧中使用的不同的树，为了方便起见在此处重复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index ymode_tree [2 * (num_ymodes - 1)] =
   {
    -DC_PRED, 2,           /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -V_PRED, -H_PRED,    /* &#34;10&#34; subtree:  V_PRED = &#34;100&#34;,
                              H_PRED = &#34;101&#34; */
      -TM_PRED, -B_PRED    /* &#34;11&#34; subtree:  TM_PRED = &#34;110&#34;,
                              B_PRED = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index ymode_tree [2 * (num_ymodes - 1)] =
   {
    -DC_PRED, 2,           /* root: DC_PRED = &#34;0&#34;, &#34;1&#34; subtree */
     4, 6,                 /* &#34;1&#34; subtree has 2 descendant subtrees */
      -V_PRED, -H_PRED,    /* &#34;10&#34; subtree:  V_PRED = &#34;100&#34;,
                              H_PRED = &#34;101&#34; */
      -TM_PRED, -B_PRED    /* &#34;11&#34; subtree:  TM_PRED = &#34;110&#34;,
                              B_PRED = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability table used to decode this tree is variable. As described in Section 11, it (along with the similarly treated UV table) can be updated by field J of the frame header. Similar to the coefficient-decoding probabilities, such updates are cumulative and affect all ensuing frames until the next key frame or explicit update. The default probabilities for the Y and UV tables are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于解码此树的概率表是可变的。如第11节所述，它（以及类似处理的UV表）可以通过帧头的字段J进行更新。与系数解码概率类似，此类更新是累积的，并且影响所有后续帧，直到下一关键帧或显式更新。Y和UV表的默认概率为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Prob ymode_prob [num_ymodes - 1] = { 112, 86, 140, 37};
   Prob uv_mode_prob [num_uv_modes - 1] = { 162, 101, 204};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Prob ymode_prob [num_ymodes - 1] = { 112, 86, 140, 37};
   Prob uv_mode_prob [num_uv_modes - 1] = { 162, 101, 204};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These defaults must be restored after detection of a key frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
检测到关键帧后，必须恢复这些默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Just as for key frames, if the Y mode is B_PRED, there next comes an encoding of the intra_bpred mode used by each of the sixteen Y subblocks. These encodings use the same tree as does that for key frames but, in place of the contexts used in key frames, these encodings use the single fixed probability table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与关键帧一样，如果Y模式是B_PRED，则接下来是16个Y子块中的每个所使用的帧内模式的编码。这些编码使用与关键帧相同的树，但代替关键帧中使用的上下文，这些编码使用单个固定概率表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob bmode_prob [num_intra_bmodes - 1] = {
       120, 90, 79, 133, 87, 85, 80, 111, 151
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob bmode_prob [num_intra_bmodes - 1] = {
       120, 90, 79, 133, 87, 85, 80, 111, 151
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Last comes the chroma mode, again coded using the same tree as that used for key frames, this time using the dynamic uv_mode_prob table described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后是色度模式，再次使用与关键帧相同的树进行编码，这次使用上述动态uv_模式_prob表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The calculation of the intra-prediction buffer is identical to that described for key frames in Section 12.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧内预测缓冲器的计算与第12部分中针对关键帧描述的计算相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. Inter-Predicted Macroblocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. 帧间预测宏块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise (when the above bool is true), we are using inter-prediction (which of course only happens for interframes), to which we now restrict our attention.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否则（当上述bool为真时），我们将使用帧间预测（当然，这只发生在帧间），我们现在将注意力限制在这一点上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next datum is then another bool, B(prob_last), selecting the reference frame. If 0, the reference frame is the previous frame (the last frame); if 1, another bool (prob_gf) selects the reference frame between the golden frame (0) and the altref frame (1). The probabilities prob_last and prob_gf are set in field J of the frame header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，下一个基准是另一个布尔B（prob_last），选择参考坐标系。如果为0，则参考帧为前一帧（最后一帧）；如果为1，则另一个布尔（prob_gf）选择黄金帧（0）和altref帧（1）之间的参考帧。在帧头的字段J中设置概率prob_last和prob_gf。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together with setting the reference frame, the purpose of inter-mode decoding is to set a motion vector for each of the sixteen Y subblocks of the current macroblock. These settings then define the calculation of the inter-prediction buffer (detailed in Section 18). While the net effect of inter-mode decoding is straightforward, the implementation is somewhat complex; the (lossless) compression achieved by this method justifies the complexity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与设置参考帧一起，模式间解码的目的是为当前宏块的十六个Y子块中的每一个设置运动矢量。然后，这些设置定义帧间预测缓冲器的计算（在第18节中详细说明）。虽然模式间解码的净效果是直接的，但实现有点复杂；这种方法实现的（无损）压缩证明了其复杂性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the reference frame selector comes the mode (or motion vector reference) applied to the macroblock as a whole, coded using the following enumeration and tree. Setting mv_nearest = num_ymodes is a convenience that allows a single variable to unambiguously hold an inter- or intra-prediction mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考帧选择器之后是应用于整个宏块的模式（或运动矢量参考），使用以下枚举和树进行编码。设置mv_nearest=num_ymodes是一种方便，它允许单个变量明确地保持帧间或帧内预测模式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       mv_nearest = num_ymodes, /* use &#34;nearest&#34; motion vector
                                   for entire MB */
       mv_near,                 /* use &#34;next nearest&#34; &#34;&#34; */
       mv_zero,                 /* use zero &#34;&#34; */
       mv_new,                  /* use explicit offset from
                                   implicit &#34;&#34; */
       mv_split,                /* use multiple motion vectors */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       mv_nearest = num_ymodes, /* use &#34;nearest&#34; motion vector
                                   for entire MB */
       mv_near,                 /* use &#34;next nearest&#34; &#34;&#34; */
       mv_zero,                 /* use zero &#34;&#34; */
       mv_new,                  /* use explicit offset from
                                   implicit &#34;&#34; */
       mv_split,                /* use multiple motion vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_mv_refs = mv_split + 1 - mv_nearest
   }
   mv_ref;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_mv_refs = mv_split + 1 - mv_nearest
   }
   mv_ref;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index mv_ref_tree [2 * (num_mv_refs - 1)] =
   {
    -mv_zero, 2,                /* zero = &#34;0&#34; */
     -mv_nearest, 4,            /* nearest = &#34;10&#34; */
      -mv_near, 6,              /* near = &#34;110&#34; */
        -mv_new, -mv_split      /* new = &#34;1110&#34;, split = &#34;1111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index mv_ref_tree [2 * (num_mv_refs - 1)] =
   {
    -mv_zero, 2,                /* zero = &#34;0&#34; */
     -mv_nearest, 4,            /* nearest = &#34;10&#34; */
      -mv_near, 6,              /* near = &#34;110&#34; */
        -mv_new, -mv_split      /* new = &#34;1110&#34;, split = &#34;1111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3. Mode and Motion Vector Contexts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.3. 模式和运动矢量上下文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability table used to decode the mv_ref, along with three reference motion vectors used by the selected mode, is calculated via a survey of the already-decoded motion vectors in (up to) 3 nearby macroblocks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于解码mv_ref的概率表以及所选模式使用的三个参考运动矢量，通过对（最多）3个相邻宏块中已解码运动矢量的调查来计算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm generates a sorted list of distinct motion vectors adjacent to the search site. The best_mv is the vector with the highest score. The mv_nearest is the non-zero vector with the highest score. The mv_near is the non-zero vector with the next highest score. The number of motion vectors coded using the SPLITMV mode is scored using the same weighting and is returned with the scores of the best, nearest, and near vectors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法生成与搜索站点相邻的不同运动矢量的排序列表。最好的是得分最高的向量。最近的mv_是得分最高的非零向量。mv_near是得分次高的非零向量。使用SPLITMV模式编码的运动矢量数使用相同的权重进行评分，并返回最佳、最近和接近矢量的评分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The three adjacent macroblocks above, left, and above-left are considered in order. If the macroblock is intra-coded, no action is taken. Otherwise, the motion vector is compared to other previously found motion vectors to determine if it has been seen before, and if so contributes its weight to that vector; otherwise, it enters a new vector in the list. The above and left vectors have twice the weight of the above-left vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
按顺序考虑左上方、左上方和左上方的三个相邻宏块。如果宏块是帧内编码的，则不采取任何操作。否则，将该运动向量与先前发现的其他运动向量进行比较，以确定其之前是否已被看见，并且如果是，则将其权重贡献给该向量；否则，它将在列表中输入一个新向量。上方向向量和左方向向量的权重是上方向向量的两倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As is the case with many contexts used by VP8, it is possible for macroblocks near the top or left edges of the image to reference blocks that are outside the visible image. VP8 provides a border of 1 macroblock filled with 0x0 motion vectors left of the left edge, and a border filled with 0,0 motion vectors of 1 macroblocks above the top edge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与VP8使用的许多上下文的情况一样，靠近图像上边缘或左边缘的宏块可以参考可见图像之外的块。VP8提供了一个由1个宏块组成的边界，该宏块填充了左边缘左侧的0x0运动矢量，以及一个由上边缘上方的1个宏块的0,0运动矢量填充的边界。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Much of the process is more easily described in C than in English. The reference code for this can be found in modemv.c (Section 20.11). The calculation of reference vectors, probability table, and, finally, the inter-prediction mode itself is implemented as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用C语言比用英语更容易描述这个过程。可在modemv.c（第20.11节）中找到这方面的参考代码。参考向量、概率表的计算，以及最后帧间预测模式本身的计算如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef union
   {
       unsigned int as_int;
       MV           as_mv;
   } int_mv;        /* facilitates rapid equality tests */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef union
   {
       unsigned int as_int;
       MV           as_mv;
   } int_mv;        /* facilitates rapid equality tests */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void mv_bias(MODE_INFO *x,int refframe, int_mv *mvp,
     int * ref_frame_sign_bias)
   {
       MV xmv;
       xmv = x-&gt;mbmi.mv.as_mv;
       if ( ref_frame_sign_bias[x-&gt;mbmi.ref_frame] !=
         ref_frame_sign_bias[refframe] )
       {
           xmv.row*=-1;
           xmv.col*=-1;
       }
       mvp-&gt;as_mv = xmv;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void mv_bias(MODE_INFO *x,int refframe, int_mv *mvp,
     int * ref_frame_sign_bias)
   {
       MV xmv;
       xmv = x-&gt;mbmi.mv.as_mv;
       if ( ref_frame_sign_bias[x-&gt;mbmi.ref_frame] !=
         ref_frame_sign_bias[refframe] )
       {
           xmv.row*=-1;
           xmv.col*=-1;
       }
       mvp-&gt;as_mv = xmv;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vp8_clamp_mv(MV *mv, const MACROBLOCKD *xd)
   {
       if ( mv-&gt;col &lt; (xd-&gt;mb_to_left_edge - LEFT_TOP_MARGIN) )
           mv-&gt;col = xd-&gt;mb_to_left_edge - LEFT_TOP_MARGIN;
       else if ( mv-&gt;col &gt; xd-&gt;mb_to_right_edge + RIGHT_BOTTOM_MARGIN )
           mv-&gt;col = xd-&gt;mb_to_right_edge + RIGHT_BOTTOM_MARGIN;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vp8_clamp_mv(MV *mv, const MACROBLOCKD *xd)
   {
       if ( mv-&gt;col &lt; (xd-&gt;mb_to_left_edge - LEFT_TOP_MARGIN) )
           mv-&gt;col = xd-&gt;mb_to_left_edge - LEFT_TOP_MARGIN;
       else if ( mv-&gt;col &gt; xd-&gt;mb_to_right_edge + RIGHT_BOTTOM_MARGIN )
           mv-&gt;col = xd-&gt;mb_to_right_edge + RIGHT_BOTTOM_MARGIN;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if ( mv-&gt;row &lt; (xd-&gt;mb_to_top_edge - LEFT_TOP_MARGIN) )
           mv-&gt;row = xd-&gt;mb_to_top_edge - LEFT_TOP_MARGIN;
       else if ( mv-&gt;row &gt; xd-&gt;mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN )
           mv-&gt;row = xd-&gt;mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if ( mv-&gt;row &lt; (xd-&gt;mb_to_top_edge - LEFT_TOP_MARGIN) )
           mv-&gt;row = xd-&gt;mb_to_top_edge - LEFT_TOP_MARGIN;
       else if ( mv-&gt;row &gt; xd-&gt;mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN )
           mv-&gt;row = xd-&gt;mb_to_bottom_edge + RIGHT_BOTTOM_MARGIN;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the function vp8_find_near_mvs(), the vectors &#34;nearest&#34; and &#34;near&#34; are used by the corresponding modes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在函数vp8_find_near_mvs（）中，向量“nearest”和“near”由相应的模式使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The vector best_mv is used as a base for explicitly coded motion vectors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
矢量best_mv用作显式编码运动矢量的基础。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first three entries in the return value cnt are (in order) weighted census values for &#34;zero&#34;, &#34;nearest&#34;, and &#34;near&#34; vectors. The final value indicates the extent to which SPLITMV was used by the neighboring macroblocks. The largest possible &#34;weight&#34; value in each case is 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
返回值cnt中的前三个条目（按顺序）是“零”、“最近”和“近”向量的加权普查值。最终值指示相邻宏块使用SPLITMV的程度。在每种情况下，最大可能的“重量”值为5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_find_near_mvs ( MACROBLOCKD *xd, const MODE_INFO *here, MV *nearest, MV *near, MV *best_mv, int cnt[4], int refframe, int * ref_frame_sign_bias )
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_find_near_mvs（宏块D*xd，此处常量模式信息，MV*最近，MV*近，MV*最佳，int cnt[4]，int refframe，int*ref框架符号偏差）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       const MODE_INFO *above = here - xd-&gt;mode_info_stride;
       const MODE_INFO *left = here - 1;
       const MODE_INFO *aboveleft = above - 1;
       int_mv            near_mvs[4];
       int_mv           *mv = near_mvs;
       int             *cntx = cnt;
       enum {CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       const MODE_INFO *above = here - xd-&gt;mode_info_stride;
       const MODE_INFO *left = here - 1;
       const MODE_INFO *aboveleft = above - 1;
       int_mv            near_mvs[4];
       int_mv           *mv = near_mvs;
       int             *cntx = cnt;
       enum {CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Zero accumulators */
       mv[0].as_int = mv[1].as_int = mv[2].as_int = 0;
       cnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Zero accumulators */
       mv[0].as_int = mv[1].as_int = mv[2].as_int = 0;
       cnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above */
       if (above-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (above-&gt;mbmi.mv.as_int) {
               (++mv)-&gt;as_int = above-&gt;mbmi.mv.as_int;
               mv_bias(above, refframe, mv, ref_frame_sign_bias);
               ++cntx;
           }
           *cntx += 2;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above */
       if (above-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (above-&gt;mbmi.mv.as_int) {
               (++mv)-&gt;as_int = above-&gt;mbmi.mv.as_int;
               mv_bias(above, refframe, mv, ref_frame_sign_bias);
               ++cntx;
           }
           *cntx += 2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process left */
       if (left-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (left-&gt;mbmi.mv.as_int) {
               int_mv this_mv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process left */
       if (left-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (left-&gt;mbmi.mv.as_int) {
               int_mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.as_int = left-&gt;mbmi.mv.as_int;
               mv_bias(left, refframe, &amp;this_mv, ref_frame_sign_bias);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.as_int = left-&gt;mbmi.mv.as_int;
               mv_bias(left, refframe, &amp;this_mv, ref_frame_sign_bias);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.as_int != mv-&gt;as_int) {
                   (++mv)-&gt;as_int = this_mv.as_int;
                   ++cntx;
               }
               *cntx += 2;
           } else
               cnt[CNT_ZERO] += 2;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.as_int != mv-&gt;as_int) {
                   (++mv)-&gt;as_int = this_mv.as_int;
                   ++cntx;
               }
               *cntx += 2;
           } else
               cnt[CNT_ZERO] += 2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above left */
       if (aboveleft-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (aboveleft-&gt;mbmi.mv.as_int) {
               int_mv this_mv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above left */
       if (aboveleft-&gt;mbmi.ref_frame != INTRA_FRAME) {
           if (aboveleft-&gt;mbmi.mv.as_int) {
               int_mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.as_int = aboveleft-&gt;mbmi.mv.as_int;
               mv_bias(aboveleft, refframe, &amp;this_mv,
                 ref_frame_sign_bias);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.as_int = aboveleft-&gt;mbmi.mv.as_int;
               mv_bias(aboveleft, refframe, &amp;this_mv,
                 ref_frame_sign_bias);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.as_int != mv-&gt;as_int) {
                   (++mv)-&gt;as_int = this_mv.as_int;
                   ++cntx;
               }
               *cntx += 1;
           } else
               cnt[CNT_ZERO] += 1;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.as_int != mv-&gt;as_int) {
                   (++mv)-&gt;as_int = this_mv.as_int;
                   ++cntx;
               }
               *cntx += 1;
           } else
               cnt[CNT_ZERO] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* If we have three distinct MVs ... */
       if (cnt[CNT_SPLITMV]) {
           /* See if above-left MV can be merged with NEAREST */
           if (mv-&gt;as_int == near_mvs[CNT_NEAREST].as_int)
               cnt[CNT_NEAREST] += 1;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* If we have three distinct MVs ... */
       if (cnt[CNT_SPLITMV]) {
           /* See if above-left MV can be merged with NEAREST */
           if (mv-&gt;as_int == near_mvs[CNT_NEAREST].as_int)
               cnt[CNT_NEAREST] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cnt[CNT_SPLITMV] = ((above-&gt;mbmi.mode == SPLITMV)
                            + (left-&gt;mbmi.mode == SPLITMV)) * 2
                           + (aboveleft-&gt;mbmi.mode == SPLITMV);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cnt[CNT_SPLITMV] = ((above-&gt;mbmi.mode == SPLITMV)
                            + (left-&gt;mbmi.mode == SPLITMV)) * 2
                           + (aboveleft-&gt;mbmi.mode == SPLITMV);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Swap near and nearest if necessary */
       if (cnt[CNT_NEAR] &gt; cnt[CNT_NEAREST]) {
           int tmp;
           tmp = cnt[CNT_NEAREST];
           cnt[CNT_NEAREST] = cnt[CNT_NEAR];
           cnt[CNT_NEAR] = tmp;
           tmp = near_mvs[CNT_NEAREST].as_int;
           near_mvs[CNT_NEAREST].as_int = near_mvs[CNT_NEAR].as_int;
           near_mvs[CNT_NEAR].as_int = tmp;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Swap near and nearest if necessary */
       if (cnt[CNT_NEAR] &gt; cnt[CNT_NEAREST]) {
           int tmp;
           tmp = cnt[CNT_NEAREST];
           cnt[CNT_NEAREST] = cnt[CNT_NEAR];
           cnt[CNT_NEAR] = tmp;
           tmp = near_mvs[CNT_NEAREST].as_int;
           near_mvs[CNT_NEAREST].as_int = near_mvs[CNT_NEAR].as_int;
           near_mvs[CNT_NEAR].as_int = tmp;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Use near_mvs[0] to store the &#34;best&#34; MV */
       if (cnt[CNT_NEAREST] &gt;= cnt[CNT_ZERO])
           near_mvs[CNT_ZERO] = near_mvs[CNT_NEAREST];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Use near_mvs[0] to store the &#34;best&#34; MV */
       if (cnt[CNT_NEAREST] &gt;= cnt[CNT_ZERO])
           near_mvs[CNT_ZERO] = near_mvs[CNT_NEAREST];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set up return values */
       *best_mv = near_mvs[0].as_mv;
       *nearest = near_mvs[CNT_NEAREST].as_mv;
       *near = near_mvs[CNT_NEAR].as_mv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set up return values */
       *best_mv = near_mvs[0].as_mv;
       *nearest = near_mvs[CNT_NEAREST].as_mv;
       *near = near_mvs[CNT_NEAR].as_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       vp8_clamp_mv(nearest, xd);
       vp8_clamp_mv(near, xd);
       vp8_clamp_mv(best_mv, xd); //TODO: Move this up before
                                    the copy
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       vp8_clamp_mv(nearest, xd);
       vp8_clamp_mv(near, xd);
       vp8_clamp_mv(best_mv, xd); //TODO: Move this up before
                                    the copy
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mv_ref probability table (mv_ref_p) is then derived from the census as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mv_ref概率表（mv_ref_p）由人口普查得出，如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int vp8_mode_contexts[6][4] =
   {
     {   7,     1,     1,   143,   },
     {  14,    18,    14,   107,   },
     { 135,    64,    57,    68,   },
     {  60,    56,   128,    65,   },
     { 159,   134,   128,    34,   },
     { 234,   188,   128,    28,   },
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int vp8_mode_contexts[6][4] =
   {
     {   7,     1,     1,   143,   },
     {  14,    18,    14,   107,   },
     { 135,    64,    57,    68,   },
     {  60,    56,   128,    65,   },
     { 159,   134,   128,    34,   },
     { 234,   188,   128,    28,   },
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vp8_prob *vp8_mv_ref_probs(vp8_prob mv_ref_p[VP8_MVREFS-1],
     int cnt[4])
   {
       mv_ref_p[0] = vp8_mode_contexts [cnt[0]] [0];
       mv_ref_p[1] = vp8_mode_contexts [cnt[1]] [1];
       mv_ref_p[2] = vp8_mode_contexts [cnt[2]] [2];
       mv_ref_p[3] = vp8_mode_contexts [cnt[3]] [3];
       return p;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vp8_prob *vp8_mv_ref_probs(vp8_prob mv_ref_p[VP8_MVREFS-1],
     int cnt[4])
   {
       mv_ref_p[0] = vp8_mode_contexts [cnt[0]] [0];
       mv_ref_p[1] = vp8_mode_contexts [cnt[1]] [1];
       mv_ref_p[2] = vp8_mode_contexts [cnt[2]] [2];
       mv_ref_p[3] = vp8_mode_contexts [cnt[3]] [3];
       return p;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once mv_ref_p is established, the mv_ref is decoded as usual.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦mv_ref_p建立，mv_ref将像往常一样解码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     mvr = (mv_ref) treed_read(d, mv_ref_tree, mv_ref_p);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     mvr = (mv_ref) treed_read(d, mv_ref_tree, mv_ref_p);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the first four inter-coding modes, the same motion vector is used for all the Y subblocks. The first three modes use an implicit motion vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于前四种帧间编码模式，相同的运动矢量用于所有Y子块。前三种模式使用隐式运动矢量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +------------+------------------------------------------------------+
   | Mode       | Instruction                                          |
   +------------+------------------------------------------------------+
   | mv_nearest | Use the nearest vector returned by                   |
   |            | vp8_find_near_mvs.                                   |
   |            |                                                      |
   | mv_near    | Use the near vector returned by vp8_find_near_mvs.   |
   |            |                                                      |
   | mv_zero    | Use a zero vector; that is, predict the current      |
   |            | macroblock from the corresponding macroblock in the  |
   |            | prediction frame.                                    |
   |            |                                                      |
   | NEWMV      | This mode is followed by an explicitly coded motion  |
   |            | vector (the format of which is described in the next |
   |            | section) that is added (component-wise) to the       |
   |            | best_mv reference vector returned by find_near_mvs   |
   |            | and applied to all 16 subblocks.                     |
   +------------+------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +------------+------------------------------------------------------+
   | Mode       | Instruction                                          |
   +------------+------------------------------------------------------+
   | mv_nearest | Use the nearest vector returned by                   |
   |            | vp8_find_near_mvs.                                   |
   |            |                                                      |
   | mv_near    | Use the near vector returned by vp8_find_near_mvs.   |
   |            |                                                      |
   | mv_zero    | Use a zero vector; that is, predict the current      |
   |            | macroblock from the corresponding macroblock in the  |
   |            | prediction frame.                                    |
   |            |                                                      |
   | NEWMV      | This mode is followed by an explicitly coded motion  |
   |            | vector (the format of which is described in the next |
   |            | section) that is added (component-wise) to the       |
   |            | best_mv reference vector returned by find_near_mvs   |
   |            | and applied to all 16 subblocks.                     |
   +------------+------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4. Split Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.4. 分裂预测
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining mode (SPLITMV) causes multiple vectors to be applied to the Y subblocks. It is immediately followed by a partition specification that determines how many vectors will be specified and how they will be assigned to the subblocks. The possible partitions, with indicated subdivisions and coding tree, are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
剩余模式（SPLITMV）使多个向量应用于Y子块。紧接着是一个分区规范，该规范确定将指定多少个向量以及如何将它们分配给子块。可能的分区（带有指示的子分区和编码树）如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       mv_top_bottom,   /* two pieces {0...7} and {8...15} */
       mv_left_right,   /* {0,1,4,5,8,9,12,13} and
                           {2,3,6,7,10,11,14,15} */
       mv_quarters,    /* {0,1,4,5}, {2,3,6,7}, {8,9,12,13},
                          {10,11,14,15} */
       MV_16,          /* every subblock gets its own vector
                          {0} ... {15} */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       mv_top_bottom,   /* two pieces {0...7} and {8...15} */
       mv_left_right,   /* {0,1,4,5,8,9,12,13} and
                           {2,3,6,7,10,11,14,15} */
       mv_quarters,    /* {0,1,4,5}, {2,3,6,7}, {8,9,12,13},
                          {10,11,14,15} */
       MV_16,          /* every subblock gets its own vector
                          {0} ... {15} */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mv_num_partitions
   }
   MVpartition;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mv_num_partitions
   }
   MVpartition;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index mvpartition_tree [2 * (mvnum_partition - 1)] =
   {
    -MV_16, 2,                         /* MV_16 = &#34;0&#34; */
     -mv_quarters, 4,                  /* mv_quarters = &#34;10&#34; */
      -mv_top_bottom, -mv_left_right   /* top_bottom = &#34;110&#34;,
                                          left_right = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index mvpartition_tree [2 * (mvnum_partition - 1)] =
   {
    -MV_16, 2,                         /* MV_16 = &#34;0&#34; */
     -mv_quarters, 4,                  /* mv_quarters = &#34;10&#34; */
      -mv_top_bottom, -mv_left_right   /* top_bottom = &#34;110&#34;,
                                          left_right = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The partition is decoded using a fixed, constant probability table:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用固定不变的概率表对分区进行解码：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob mvpartition_probs [mvnum_partition - 1] =
     { 110, 111, 150};
   part = (MVpartition) treed_read(d, mvpartition_tree,
     mvpartition_probs);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob mvpartition_probs [mvnum_partition - 1] =
     { 110, 111, 150};
   part = (MVpartition) treed_read(d, mvpartition_tree,
     mvpartition_probs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the partition come two (for mv_top_bottom or mv_left_right), four (for mv_quarters), or sixteen (for MV_16) subblock inter-prediction modes. These modes occur in the order indicated by the partition layouts (given as comments to the MVpartition enum) and are coded as follows. (As was done for the macroblock-level modes, we offset the mode enumeration so that a single variable may unambiguously hold either an intra- or inter-subblock mode.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分区后出现两个（用于mv_顶部_底部或mv_左侧_右侧）、四个（用于mv_四分之一）或十六个（用于mv_16）子块间预测模式。这些模式按照分区布局指示的顺序出现（作为MVpartition枚举的注释给出），并按如下方式编码。（与宏块级模式一样，我们偏移了模式枚举，以便单个变量可以明确地保持子块内或子块间模式。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prior to decoding each subblock, a decoding tree context is chosen as illustrated in the code snippet below. The context is based on the immediate left and above subblock neighbors, and whether they are equal, are zero, or a combination of those.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在解码每个子块之前，选择解码树上下文，如下面的代码片段所示。上下文基于直接的左侧和上方子块邻居，以及它们是否相等、为零或它们的组合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       LEFT4x4 = num_intra_bmodes,   /* use already-coded MV to
                                        my left */
       ABOVE4x4,             /* use already-coded MV above me */
       ZERO4x4,              /* use zero MV */
       NEW4x4,               /* explicit offset from &#34;best&#34; */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       LEFT4x4 = num_intra_bmodes,   /* use already-coded MV to
                                        my left */
       ABOVE4x4,             /* use already-coded MV above me */
       ZERO4x4,              /* use zero MV */
       NEW4x4,               /* explicit offset from &#34;best&#34; */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_sub_mv_ref
   };
   sub_mv_ref;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       num_sub_mv_ref
   };
   sub_mv_ref;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index sub_mv_ref_tree [2 * (num_sub_mv_ref - 1)] =
   {
    -LEFT4X4, 2,           /* LEFT = &#34;0&#34; */
     -ABOVE4X4, 4,         /* ABOVE = &#34;10&#34; */
      -ZERO4X4, -NEW4X4    /* ZERO = &#34;110&#34;, NEW = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index sub_mv_ref_tree [2 * (num_sub_mv_ref - 1)] =
   {
    -LEFT4X4, 2,           /* LEFT = &#34;0&#34; */
     -ABOVE4X4, 4,         /* ABOVE = &#34;10&#34; */
      -ZERO4X4, -NEW4X4    /* ZERO = &#34;110&#34;, NEW = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Choose correct decoding tree context
    * Function parameters are left subblock neighbor MV and above
    * subblock neighbor MV */
   int vp8_mvCont(MV *l, MV*a)
   {
       int lez = (l-&gt;row == 0 &amp;&amp; l-&gt;col == 0);   /* left neighbor
                                                    is zero */
       int aez = (a-&gt;row == 0 &amp;&amp; a-&gt;col == 0);   /* above neighbor
                                                    is zero */
       int lea = (l-&gt;row == a-&gt;row &amp;&amp; l-&gt;col == a-&gt;col);  /* left
                                neighbor equals above neighbor */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Choose correct decoding tree context
    * Function parameters are left subblock neighbor MV and above
    * subblock neighbor MV */
   int vp8_mvCont(MV *l, MV*a)
   {
       int lez = (l-&gt;row == 0 &amp;&amp; l-&gt;col == 0);   /* left neighbor
                                                    is zero */
       int aez = (a-&gt;row == 0 &amp;&amp; a-&gt;col == 0);   /* above neighbor
                                                    is zero */
       int lea = (l-&gt;row == a-&gt;row &amp;&amp; l-&gt;col == a-&gt;col);  /* left
                                neighbor equals above neighbor */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lea &amp;&amp; lez)
           return SUBMVREF_LEFT_ABOVE_ZED; /* =4 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lea &amp;&amp; lez)
           return SUBMVREF_LEFT_ABOVE_ZED; /* =4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lea)
           return SUBMVREF_LEFT_ABOVE_SAME; /* =3 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lea)
           return SUBMVREF_LEFT_ABOVE_SAME; /* =3 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (aez)
           return SUBMVREF_ABOVE_ZED; /* =2 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (aez)
           return SUBMVREF_ABOVE_ZED; /* =2 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lez)
           return SUBMVREF_LEFT_ZED; /* =1*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lez)
           return SUBMVREF_LEFT_ZED; /* =1*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return SUBMVREF_NORMAL; /* =0 */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return SUBMVREF_NORMAL; /* =0 */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Constant probabilities and decoding procedure. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Constant probabilities and decoding procedure. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob sub_mv_ref_prob [5][num_sub_mv_ref - 1] = {
       { 147,136,18 },
       { 106,145,1  },
       { 179,121,1  },
       { 223,1  ,34 },
       { 208,1  ,1  }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const Prob sub_mv_ref_prob [5][num_sub_mv_ref - 1] = {
       { 147,136,18 },
       { 106,145,1  },
       { 179,121,1  },
       { 223,1  ,34 },
       { 208,1  ,1  }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sub_ref = (sub_mv_ref) treed_read(d, sub_mv_ref_tree,
         sub_mv_ref_prob[context]);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sub_ref = (sub_mv_ref) treed_read(d, sub_mv_ref_tree,
         sub_mv_ref_prob[context]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two sub-prediction modes simply copy the already-coded motion vectors used by the blocks above and to the left of the subblock at the upper left corner of the current subset (i.e., collection of subblocks being predicted). These prediction blocks need not lie in the current macroblock and, if the current subset lies at the top or left edges of the frame, need not lie in the frame. In this latter case, their motion vectors are taken to be zero, as are subblock motion vectors within an intra-predicted macroblock. Also, to ensure the correctness of prediction within this macroblock, all subblocks lying in an already-decoded subset of the current macroblock must have their motion vectors set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前两个子预测模式简单地复制当前子集左上角（即，被预测的子块的集合）的子块上方和左侧的块所使用的已编码运动向量。这些预测块不必位于当前宏块中，并且如果当前子集位于帧的上边缘或左边缘，则不必位于帧中。在后一种情况下，它们的运动矢量被取为零，如同帧内预测宏块内的子块运动矢量一样。此外，为了确保该宏块内预测的正确性，位于当前宏块的已解码子集中的所有子块必须设置其运动向量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ZERO4x4 uses a zero motion vector and predicts the current subset using the corresponding subset from the prediction frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ZERO4x4使用零运动矢量，并使用来自预测帧的相应子集预测当前子集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NEW4x4 is exactly like NEWMV except that NEW4x4 is applied only to the current subset. It is followed by a two-dimensional motion vector offset (described in the next section) that is added to the best vector returned by the earlier call to find_near_mvs to form the motion vector in effect for the subset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NEW4x4与NEWMV完全相同，只是NEW4x4仅应用于当前子集。然后是一个二维运动矢量偏移量（在下一节中描述），该偏移量被添加到先前调用返回的最佳矢量中，以查找_near_mvs，从而形成对子集有效的运动矢量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parsing of both inter-prediction modes and motion vectors (described next) can be found in the reference decoder file modemv.c (Section 20.11).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧间预测模式和运动矢量（如下所述）的解析可在参考解码器文件modemv.c（第20.11节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Motion Vector Decoding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. 运动矢量解码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed above, motion vectors appear in two places in the VP8 datastream: applied to whole macroblocks in NEWMV mode and applied to subsets of macroblocks in NEW4x4 mode. The format of the vectors is identical in both cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述，运动矢量出现在VP8数据流中的两个位置：在NEWMV模式下应用于整个宏块，在NEW4x4模式下应用于宏块子集。在这两种情况下，向量的格式是相同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each vector has two pieces: a vertical component (row) followed by a horizontal component (column). The row and column use separate coding probabilities but are otherwise represented identically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个向量有两个部分：一个垂直分量（行）后跟一个水平分量（列）。行和列使用单独的编码概率，但在其他方面表示相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. Coding of Each Component
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.1. 每个部件的编码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each component is a signed integer V representing a vertical or horizontal luma displacement of V quarter-pixels (and a chroma displacement of V eighth-pixels). The absolute value of V, if non-zero, is followed by a boolean sign. V may take any value between -1023 and +1023, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个分量是一个有符号整数V，表示V四分之一像素的垂直或水平亮度位移（以及V八分之一像素的色度位移）。如果V的绝对值不为零，则后跟布尔符号。V可以取-1023和+1023之间的任何值，包括-1023和+1023。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The absolute value A is coded in one of two different ways according to its size. For 0 &lt;= A &lt;= 7, A is tree-coded, and for 8 &lt;= A &lt;= 1023, the bits in the binary expansion of A are coded using independent boolean probabilities. The coding of A begins with a bool specifying which range is in effect.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
绝对值A根据其大小以两种不同方式之一进行编码。对于0&lt;=A&lt;=7，对A进行树编码，对于8&lt;=A&lt;=1023，对A的二进制展开中的位使用独立的布尔概率进行编码。A的编码从指定有效范围的布尔开始。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Decoding a motion vector component then requires a 19-position probability table, whose offsets, along with the procedure used to decode components, are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码运动矢量分量需要一个19位概率表，其偏移量以及用于解码分量的过程如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       mvpis_short,         /* short (&lt;= 7) vs long (&gt;= 8) */
       MVPsign,             /* sign for non-zero */
       MVPshort,            /* 8 short values = 7-position tree */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef enum
   {
       mvpis_short,         /* short (&lt;= 7) vs long (&gt;= 8) */
       MVPsign,             /* sign for non-zero */
       MVPshort,            /* 8 short values = 7-position tree */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       MVPbits = MVPshort + 7,      /* 8 long value bits
                                       w/independent probs */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       MVPbits = MVPshort + 7,      /* 8 long value bits
                                       w/independent probs */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       MVPcount = MVPbits + 10      /* 19 probabilities in total */
   }
   MVPindices;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       MVPcount = MVPbits + 10      /* 19 probabilities in total */
   }
   MVPindices;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef Prob MV_CONTEXT [MVPcount];    /* Decoding spec for
                                             a single component */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef Prob MV_CONTEXT [MVPcount];    /* Decoding spec for
                                             a single component */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Tree used for small absolute values (has expected
      correspondence). */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Tree used for small absolute values (has expected
      correspondence). */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index small_mvtree [2 * (8 - 1)] =
   {
    2, 8,          /* &#34;0&#34; subtree, &#34;1&#34; subtree */
     4, 6,         /* &#34;00&#34; subtree, &#34;01&#34; subtree */
      -0, -1,      /* 0 = &#34;000&#34;, 1 = &#34;001&#34; */
      -2, -3,      /* 2 = &#34;010&#34;, 3 = &#34;011&#34; */
     10, 12,       /* &#34;10&#34; subtree, &#34;11&#34; subtree */
      -4, -5,      /* 4 = &#34;100&#34;, 5 = &#34;101&#34; */
      -6, -7       /* 6 = &#34;110&#34;, 7 = &#34;111&#34; */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const tree_index small_mvtree [2 * (8 - 1)] =
   {
    2, 8,          /* &#34;0&#34; subtree, &#34;1&#34; subtree */
     4, 6,         /* &#34;00&#34; subtree, &#34;01&#34; subtree */
      -0, -1,      /* 0 = &#34;000&#34;, 1 = &#34;001&#34; */
      -2, -3,      /* 2 = &#34;010&#34;, 3 = &#34;011&#34; */
     10, 12,       /* &#34;10&#34; subtree, &#34;11&#34; subtree */
      -4, -5,      /* 4 = &#34;100&#34;, 5 = &#34;101&#34; */
      -6, -7       /* 6 = &#34;110&#34;, 7 = &#34;111&#34; */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Read MV component at current decoder position, using
      supplied probs. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Read MV component at current decoder position, using
      supplied probs. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int read_mvcomponent(bool_decoder *d, const MV_CONTEXT *mvc)
   {
       const Prob * const p = (const Prob *) mvc;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int read_mvcomponent(bool_decoder *d, const MV_CONTEXT *mvc)
   {
       const Prob * const p = (const Prob *) mvc;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int A = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
int A=0；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (read_bool(d, p [mvpis_short]))    /* 8 &lt;= A &lt;= 1023 */
       {
           /* Read bits 0, 1, 2 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (read_bool(d, p [mvpis_short]))    /* 8 &lt;= A &lt;= 1023 */
       {
           /* Read bits 0, 1, 2 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           int i = 0;
           do { A += read_bool(d, p [MVPbits + i]) &lt;&lt; i;}
             while (++i &lt; 3);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           int i = 0;
           do { A += read_bool(d, p [MVPbits + i]) &lt;&lt; i;}
             while (++i &lt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Read bits 9, 8, 7, 6, 5, 4 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Read bits 9, 8, 7, 6, 5, 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           i = 9;
           do { A += read_bool(d, p [MVPbits + i]) &lt;&lt; i;}
             while (--i &gt; 3);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           i = 9;
           do { A += read_bool(d, p [MVPbits + i]) &lt;&lt; i;}
             while (--i &gt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* We know that A &gt;= 8 because it is coded long,
              so if A &lt;= 15, bit 3 is one and is not
              explicitly coded. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* We know that A &gt;= 8 because it is coded long,
              so if A &lt;= 15, bit 3 is one and is not
              explicitly coded. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!(A &amp; 0xfff0)  ||  read_bool(d, p [MVPbits + 3]))
               A += 8;
       }
       else    /* 0 &lt;= A &lt;= 7 */
           A = treed_read(d, small_mvtree, p + MVPshort);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!(A &amp; 0xfff0)  ||  read_bool(d, p [MVPbits + 3]))
               A += 8;
       }
       else    /* 0 &lt;= A &lt;= 7 */
           A = treed_read(d, small_mvtree, p + MVPshort);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return A &amp;&amp; read_bool(r, p [MVPsign]) ?  -A : A;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return A &amp;&amp; read_bool(r, p [MVPsign]) ?  -A : A;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. Probability Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17.2. 概率更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decoder should maintain an array of two MV_CONTEXTs for decoding row and column components, respectively. These MV_CONTEXTs should be set to their defaults every key frame. Each individual probability may be updated every interframe (by field J of the frame header) using a constant table of update probabilities. Each optional update is of the form B? P(7), that is, a bool followed by a 7-bit probability specification if true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码器应保持两个MV_上下文的数组，分别用于解码行和列组件。这些MV_上下文应在每个关键帧设置为默认值。可以使用恒定的更新概率表在每个帧间（通过帧头的字段J）更新每个单独的概率。每个可选更新都是表格B？P（7），也就是说，如果为真，则为bool后跟7位概率规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As with other dynamic probabilities used by VP8, the updates remain in effect until the next key frame or until replaced via another update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与VP8使用的其他动态概率一样，更新保持有效，直到下一个关键帧或通过另一个更新替换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In detail, the probabilities should then be managed as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体而言，概率应按如下方式进行管理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Never-changing table of update probabilities for each
      individual probability used in decoding motion vectors. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Never-changing table of update probabilities for each
      individual probability used in decoding motion vectors. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const MV_CONTEXT vp8_mv_update_probs[2] =
   {
     {
       237,
       246,
       253, 253, 254, 254, 254, 254, 254,
       254, 254, 254, 254, 254, 250, 250, 252, 254, 254
     },
     {
       231,
       243,
       245, 253, 254, 254, 254, 254, 254,
       254, 254, 254, 254, 254, 251, 251, 254, 254, 254
     }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const MV_CONTEXT vp8_mv_update_probs[2] =
   {
     {
       237,
       246,
       253, 253, 254, 254, 254, 254, 254,
       254, 254, 254, 254, 254, 250, 250, 252, 254, 254
     },
     {
       231,
       243,
       245, 253, 254, 254, 254, 254, 254,
       254, 254, 254, 254, 254, 251, 251, 254, 254, 254
     }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Default MV decoding probabilities. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Default MV decoding probabilities. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const MV_CONTEXT default_mv_context[2] = { { // row 162, // is short 128, // sign 225, 146, 172, 147, 214, 39, 156, // short tree 128, 129, 132, 75, 145, 178, 206, 239, 254, 254 // long bits },
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
const MV_CONTEXT default_MV_CONTEXT[2]={{//row 162，//短128，//符号225、146、172、147、214、39、156，//短树128、129、132、75、145、178、206、239、254、254//长位}，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {                       // same for column
       164,                    // is short
       128,
       204, 170, 119, 235, 140, 230, 228,
       128, 130, 130,  74, 148, 180, 203, 236, 254, 254 // long bits
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     {                       // same for column
       164,                    // is short
       128,
       204, 170, 119, 235, 140, 230, 228,
       128, 130, 130,  74, 148, 180, 203, 236, 254, 254 // long bits
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Current MV decoding probabilities, set to above defaults
      every key frame. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Current MV decoding probabilities, set to above defaults
      every key frame. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   MV_CONTEXT mvc [2];     /* always row, then column */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   MV_CONTEXT mvc [2];     /* always row, then column */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Procedure for decoding a complete motion vector. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Procedure for decoding a complete motion vector. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct { int16 row, col;}  MV;  /* as in previous section */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct { int16 row, col;}  MV;  /* as in previous section */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   MV read_mv(bool_decoder *d)
   {
       MV v;
       v.row = (int16) read_mvcomponent(d, mvc);
       v.col = (int16) read_mvcomponent(d, mvc + 1);
       return v;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   MV read_mv(bool_decoder *d)
   {
       MV v;
       v.row = (int16) read_mvcomponent(d, mvc);
       v.col = (int16) read_mvcomponent(d, mvc + 1);
       return v;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Procedure for updating MV decoding probabilities, called
      every interframe with &#34;d&#34; at the appropriate position in
      the frame header. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Procedure for updating MV decoding probabilities, called
      every interframe with &#34;d&#34; at the appropriate position in
      the frame header. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void update_mvcontexts(bool_decoder *d)
   {
       int i = 0;
       do {                      /* component = row, then column */
           const Prob *up = mv_update_probs[i];    /* update probs
                                                      for component */
           Prob *p = mvc[i];                  /* start decode tbl &#34;&#34; */
           Prob * const pstop = p + MVPcount; /* end decode tbl &#34;&#34; */
           do {
               if (read_bool(d, *up++))     /* update this position */
               {
                   const Prob x = read_literal(d, 7);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void update_mvcontexts(bool_decoder *d)
   {
       int i = 0;
       do {                      /* component = row, then column */
           const Prob *up = mv_update_probs[i];    /* update probs
                                                      for component */
           Prob *p = mvc[i];                  /* start decode tbl &#34;&#34; */
           Prob * const pstop = p + MVPcount; /* end decode tbl &#34;&#34; */
           do {
               if (read_bool(d, *up++))     /* update this position */
               {
                   const Prob x = read_literal(d, 7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                   *p = x? x&lt;&lt;1 : 1;
               }
           } while (++p &lt; pstop);              /* next position */
       } while (++i &lt; 2);                      /* next component */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                   *p = x? x&lt;&lt;1 : 1;
               }
           } while (++p &lt; pstop);              /* next position */
       } while (++i &lt; 2);                      /* next component */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the description of the motion-vector decoding procedure and, with it, the procedure for decoding interframe macroblock prediction records.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这就完成了对运动矢量解码过程的描述，以及对帧间宏块预测记录进行解码的过程的描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. Interframe Prediction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. 帧间预测
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given an inter-prediction specification for the current macroblock, that is, a reference frame together with a motion vector for each of the sixteen Y subblocks, we describe the calculation of the prediction buffer for the macroblock. Frame reconstruction is then completed via the previously described processes of residue summation (Section 14) and loop filtering (Section 15).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定当前宏块的帧间预测规范，即16个Y子块中的每个的参考帧和运动向量，我们描述宏块的预测缓冲器的计算。然后，通过前面描述的剩余求和（第14节）和循环滤波（第15节）过程完成帧重建。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The management of inter-predicted subblocks and sub-pixel interpolation may be found in the reference decoder file predict.c (Section 20.14).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
帧间预测子块和子像素插值的管理可在参考解码器文件predict.c（第20.14节）中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. Bounds on, and Adjustment of, Motion Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.1. 运动矢量的边界和调整
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since each motion vector is differentially encoded from a neighboring block or macroblock and the only clamp is to ensure that the referenced motion vector represents a valid location inside a reference frame buffer, it is technically possible within the VP8 format for a block or macroblock to have arbitrarily large motion vectors, up to the size of the input image plus the extended border areas. For practical reasons, VP8 imposes a motion vector size range limit of -4096 to 4095 full pixels, regardless of image size (VP8 defines 14 raw bits for width and height; 16383x16383 is the maximum possible image size). Bitstream-compliant encoders and decoders shall enforce this limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于每个运动矢量从相邻块或宏块进行差分编码，并且唯一的钳制是确保参考运动矢量表示参考帧缓冲器内的有效位置，因此在VP8格式中，块或宏块具有任意大的运动矢量在技术上是可能的，最大为输入图像的大小加上扩展的边界区域。出于实际原因，VP8将运动矢量大小范围限制为-4096到4095个完整像素，而不考虑图像大小（VP8定义了14个原始位的宽度和高度；163816383是可能的最大图像大小）。符合比特流的编码器和解码器应执行此限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the motion vectors applied to the chroma subblocks have 1/8-pixel resolution, the synthetic pixel calculation, outlined in Section 5 and detailed below, uses this resolution for the luma subblocks as well. In accordance, the stored luma motion vectors are all doubled, each component of each luma vector becoming an even integer in the range -2046 to +2046, inclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于应用于色度子块的运动矢量具有1/8像素分辨率，因此第5节中概述并在下文详述的合成像素计算也将该分辨率用于亮度子块。相应地，存储的luma运动向量全部加倍，每个luma向量的每个分量成为-2046到+2046（包括-2046到+2046）范围内的偶数整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The vector applied to each chroma subblock is calculated by averaging the vectors for the 4 luma subblocks occupying the same visible area as the chroma subblock in the usual correspondence; that is, the vector for U and V block 0 is the average of the vectors for the Y subblocks { 0, 1, 4, 5}, chroma block 1 corresponds to Y blocks { 2, 3, 6, 7}, chroma block 2 to Y blocks { 8, 9, 12, 13}, and chroma block 3 to Y blocks { 10, 11, 14, 15}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用于每个色度子块的向量是通过对占据与通常对应中的色度子块相同可见区域的4个luma子块的向量求平均来计算的；即，U和V块0的向量是Y子块{0、1、4、5}的向量的平均值，色度块1对应于Y块{2、3、6、7}，色度块2对应于Y块{8、9、12、13}，色度块3对应于Y块{10、11、14、15}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In detail, each of the two components of the vectors for each of the chroma subblocks is calculated from the corresponding luma vector components as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体而言，根据相应的亮度向量分量计算每个色度子块的向量的两个分量中的每一个，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int avg(int c1, int c2, int c3, int c4)
   {
       int s = c1 + c2 + c3 + c4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int avg(int c1, int c2, int c3, int c4)
   {
       int s = c1 + c2 + c3 + c4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The shift divides by 8 (not 4) because chroma pixels
          have twice the diameter of luma pixels.  The handling
          of negative motion vector components is slightly
          cumbersome because, strictly speaking, right shifts
          of negative numbers are not well-defined in C. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The shift divides by 8 (not 4) because chroma pixels
          have twice the diameter of luma pixels.  The handling
          of negative motion vector components is slightly
          cumbersome because, strictly speaking, right shifts
          of negative numbers are not well-defined in C. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return s &gt;= 0 ?  (s + 4) &gt;&gt; 3 : -((-s + 4) &gt;&gt; 3);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return s &gt;= 0 ?  (s + 4) &gt;&gt; 3 : -((-s + 4) &gt;&gt; 3);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, if the version number in the frame tag specifies only full-pel chroma motion vectors, then the fractional parts of both components of the vector are truncated to zero, as illustrated in the following pseudocode (assuming 3 bits of fraction for both luma and chroma vectors):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，如果帧标签中的版本号仅指定完整像素色度运动向量，则向量的两个分量的分数部分被截断为零，如以下伪码中所示（假设亮度和色度向量的分数均为3位）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x = x &amp; (~7);
       y = y &amp; (~7);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x = x &amp; (~7);
       y = y &amp; (~7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Earlier in this document we described the vp8_clamp_mv() function to limit &#34;nearest&#34; and &#34;near&#34; motion vector predictors inside specified margins within the frame boundaries. Additional clamping is performed for NEWMV macroblocks, for which the final motion vector is clamped again after combining the &#34;best&#34; predictor and the differential vector decoded from the stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本文档前面，我们描述了vp8_clamp_mv（）函数，该函数用于将“最近”和“近”运动矢量预测器限制在帧边界内指定的边距内。对NEWMV宏块执行附加箝位，在组合“最佳”预测器和从流解码的差分向量之后，对其再次箝位最终运动向量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the secondary clamping is not performed for SPLITMV macroblocks, meaning that any subblock&#39;s motion vector within the SPLITMV macroblock may point outside the clamping zone. These non-clamped vectors are also used when determining the decoding tree context for subsequent subblocks&#39; modes in the vp8_mvCont() function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，不针对SPLITMV宏块执行二次箝位，这意味着SPLITMV宏块内的任何子块的运动矢量可能指向箝位区域之外。在vp8_mvCont（）函数中确定后续子块模式的解码树上下文时，也使用这些非钳位向量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. Prediction Subblocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.2. 预测子块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The prediction calculation for each subblock is then as follows. Temporarily disregarding the fractional part of the motion vector (that is, rounding &#34;up&#34; or &#34;left&#34; by right-shifting each component 3 bits with sign propagation) and adding the origin (upper left position) of the (16x16 luma or 8x8 chroma) current macroblock gives us an origin in the Y, U, or V plane of the predictor frame (either the golden frame or previous frame).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个子块的预测计算如下所示。暂时忽略运动矢量的分数部分（即，通过符号传播将每个分量右移3位来“向上”或“向左”取整），并添加（16x16 luma或8x8色度）当前宏块的原点（左上位置），我们可以在预测器帧的Y、U或V平面中获得原点（金色边框或上一个边框）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering that origin to be the upper left corner of a (luma or chroma) macroblock, we need to specify the relative positions of the pixels associated to that subblock, that is, any pixels that might be involved in the sub-pixel interpolation processes for the subblock.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑到原点是（亮度或色度）宏块的左上角，我们需要指定与该子块相关联的像素的相对位置，即，可能涉及子块的子像素插值过程的任何像素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. Sub-Pixel Interpolation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.3. 亚像素插值
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sub-pixel interpolation is effected via two one-dimensional convolutions. These convolutions may be thought of as operating on a two-dimensional array of pixels whose origin is the subblock origin, that is the origin of the prediction macroblock described above plus the offset to the subblock. Because motion vectors are arbitrary, so are these &#34;prediction subblock origins&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
亚像素插值通过两个一维卷积实现。这些卷积可以被认为是在其原点是子块原点的像素的二维阵列上操作的，该子块原点是上述预测宏块的原点加上到子块的偏移。因为运动矢量是任意的，所以这些“预测子块原点”也是任意的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The integer part of the motion vector is subsumed in the origin of the prediction subblock; the 16 (synthetic) pixels we need to construct are given by 16 offsets from the origin. The integer part of each of these offsets is the offset of the corresponding pixel from the subblock origin (using the vertical stride). To these integer parts is added a constant fractional part, which is simply the difference between the actual motion vector and its integer truncation used to calculate the origins of the prediction macroblock and subblock. Each component of this fractional part is an integer between 0 and 7, representing a forward displacement in eighths of a pixel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
运动矢量的整数部分包含在预测子块的原点中；我们需要构造的16个（合成）像素由距原点的16个偏移量给出。每个偏移的整数部分是对应像素相对于子块原点的偏移（使用垂直步幅）。向这些整数部分添加一个常量分数部分，该部分仅为实际运动矢量与其整数截断之间的差值，用于计算预测宏块和子块的原点。该分数部分的每个分量都是0到7之间的整数，表示八分之一像素的正向位移。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is these fractional displacements that determine the filtering process. If they both happen to be zero (that is, we had a &#34;whole pixel&#34; motion vector), the prediction subblock is simply copied into the corresponding piece of the current macroblock&#39;s prediction buffer. As discussed in Section 14, the layout of the macroblock&#39;s prediction buffer can depend on the specifics of the reconstruction implementation chosen. Of course, the vertical displacement between lines of the prediction subblock is given by the stride, as are all vertical displacements used here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正是这些分数位移决定了过滤过程。如果它们恰好都为零（即，我们有一个“整像素”运动矢量），则预测子块将被简单地复制到当前宏块的预测缓冲区的相应部分中。如第14节中所讨论的，宏块的预测缓冲器的布局可以取决于所选择的重建实现的细节。当然，预测子块行之间的垂直位移由步幅给出，这里使用的所有垂直位移也是如此。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, at least one of the fractional displacements is non-zero. We then synthesize the missing pixels via a horizontal, followed by a vertical, one-dimensional interpolation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否则，至少一个分数位移为非零。然后，我们通过一个水平的，然后是一个垂直的，一维插值合成丢失的像素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two interpolations are essentially identical. Each uses a (at most) six-tap filter (the choice of which of course depends on the one-dimensional offset). Thus, every calculated pixel references at most three pixels before (above or to the left of) it and at most three pixels after (below or to the right of) it. The horizontal interpolation must calculate two extra rows above and three extra rows below the 4x4 block, to provide enough samples for the vertical interpolation to proceed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这两种插值基本相同。每个都使用（最多）六抽头滤波器（当然，其选择取决于一维偏移）。因此，每个计算的像素在其前面（上方或左侧）最多参考三个像素，在其后面（下方或右侧）最多参考三个像素。水平插值必须计算4x4块上方的两个额外行和下方的三个额外行，以便为垂直插值提供足够的样本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the reconstruction filter type given in the version number field in the frame tag, either a bicubic or a bilinear tap set is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据帧标记的版本号字段中给定的重建过滤器类型，使用双三次或双线性抽头集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The exact implementation of subsampling is as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子采样的具体实现如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Filter taps taken to 7-bit precision.
      Because DC is always passed, taps always sum to 128. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Filter taps taken to 7-bit precision.
      Because DC is always passed, taps always sum to 128. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int BilinearFilters[8][6] =
   {
       { 0, 0, 128,   0, 0, 0 },
       { 0, 0, 112,  16, 0, 0 },
       { 0, 0,  96,  32, 0, 0 },
       { 0, 0,  80,  48, 0, 0 },
       { 0, 0,  64,  64, 0, 0 },
       { 0, 0,  48,  80, 0, 0 },
       { 0, 0,  32,  96, 0, 0 },
       { 0, 0,  16, 112, 0, 0 }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int BilinearFilters[8][6] =
   {
       { 0, 0, 128,   0, 0, 0 },
       { 0, 0, 112,  16, 0, 0 },
       { 0, 0,  96,  32, 0, 0 },
       { 0, 0,  80,  48, 0, 0 },
       { 0, 0,  64,  64, 0, 0 },
       { 0, 0,  48,  80, 0, 0 },
       { 0, 0,  32,  96, 0, 0 },
       { 0, 0,  16, 112, 0, 0 }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int filters [8] [6] = {        /* indexed by displacement */
       { 0,  0,  128,    0,   0,  0 },  /* degenerate whole-pixel */
       { 0, -6,  123,   12,  -1,  0 },  /* 1/8 */
       { 2, -11, 108,   36,  -8,  1 },  /* 1/4 */
       { 0, -9,   93,   50,  -6,  0 },  /* 3/8 */
       { 3, -16,  77,   77, -16,  3 },  /* 1/2 is symmetric */
       { 0, -6,   50,   93,  -9,  0 },  /* 5/8 = reverse of 3/8 */
       { 1, -8,   36,  108, -11,  2 },  /* 3/4 = reverse of 1/4 */
       { 0, -1,   12,  123,  -6,  0 }   /* 7/8 = reverse of 1/8 */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const int filters [8] [6] = {        /* indexed by displacement */
       { 0,  0,  128,    0,   0,  0 },  /* degenerate whole-pixel */
       { 0, -6,  123,   12,  -1,  0 },  /* 1/8 */
       { 2, -11, 108,   36,  -8,  1 },  /* 1/4 */
       { 0, -9,   93,   50,  -6,  0 },  /* 3/8 */
       { 3, -16,  77,   77, -16,  3 },  /* 1/2 is symmetric */
       { 0, -6,   50,   93,  -9,  0 },  /* 5/8 = reverse of 3/8 */
       { 1, -8,   36,  108, -11,  2 },  /* 3/4 = reverse of 1/4 */
       { 0, -1,   12,  123,  -6,  0 }   /* 7/8 = reverse of 1/8 */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* One-dimensional synthesis of a single sample.
      Filter is determined by fractional displacement */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* One-dimensional synthesis of a single sample.
      Filter is determined by fractional displacement */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel interp(
       const int fil[6],   /* filter to apply */
       const Pixel *p,     /* origin (rounded &#34;before&#34;) in
                              prediction area */
       const int s         /* size of one forward step &#34;&#34; */
   ) {
       int32 a = 0;
       int i = 0;
       p -= s + s;         /* move back two positions */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pixel interp(
       const int fil[6],   /* filter to apply */
       const Pixel *p,     /* origin (rounded &#34;before&#34;) in
                              prediction area */
       const int s         /* size of one forward step &#34;&#34; */
   ) {
       int32 a = 0;
       int i = 0;
       p -= s + s;         /* move back two positions */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       do {
           a += *p * fil[i];
           p += s;
       }  while (++i &lt; 6);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       do {
           a += *p * fil[i];
           p += s;
       }  while (++i &lt; 6);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return clamp255((a + 64) &gt;&gt; 7);    /* round to nearest
                                              8-bit value */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return clamp255((a + 64) &gt;&gt; 7);    /* round to nearest
                                              8-bit value */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* First do horizontal interpolation, producing intermediate
      buffer. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* First do horizontal interpolation, producing intermediate
      buffer. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void Hinterp(
       Pixel temp[9][4],   /* 9 rows of 4 (intermediate)
                              destination values */
       const Pixel *p,     /* subblock origin in prediction
                              frame */
       int s,              /* vertical stride to be used in
                              prediction frame */
       uint hfrac,         /* 0 &lt;= horizontal displacement &lt;= 7 */
       uint bicubic        /* 1=bicubic filter, 0=bilinear */
   ) {
       const int * const fil = bicubic ? filters [hfrac] :
         BilinearFilters[hfrac];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void Hinterp(
       Pixel temp[9][4],   /* 9 rows of 4 (intermediate)
                              destination values */
       const Pixel *p,     /* subblock origin in prediction
                              frame */
       int s,              /* vertical stride to be used in
                              prediction frame */
       uint hfrac,         /* 0 &lt;= horizontal displacement &lt;= 7 */
       uint bicubic        /* 1=bicubic filter, 0=bilinear */
   ) {
       const int * const fil = bicubic ? filters [hfrac] :
         BilinearFilters[hfrac];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int r = 0;  do              /* for each row */
       {
           int c = 0;  do          /* for each destination sample */
           {
               /* Pixel separation = one horizontal step = 1 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int r = 0;  do              /* for each row */
       {
           int c = 0;  do          /* for each destination sample */
           {
               /* Pixel separation = one horizontal step = 1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               temp[r][c] = interp(fil, p + c, 1);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               temp[r][c] = interp(fil, p + c, 1);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           while (++c &lt; 4);
       }
       while (p += s, ++r &lt; 9);    /* advance p to next row */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           while (++c &lt; 4);
       }
       while (p += s, ++r &lt; 9);    /* advance p to next row */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Finish with vertical interpolation, producing final results.
      Input array &#34;temp&#34; is of course that computed above. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Finish with vertical interpolation, producing final results.
      Input array &#34;temp&#34; is of course that computed above. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void Vinterp(
       Pixel final[4][4],  /* 4 rows of 4 (final) destination values */
       const Pixel temp[9][4],
       uint vfrac,         /* 0 &lt;= vertical displacement &lt;= 7 */
       uint bicubic        /* 1=bicubic filter, 0=bilinear */
   ) {
       const int * const fil = bicubic ? filters [vfrac] :
         BilinearFilters[vfrac];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void Vinterp(
       Pixel final[4][4],  /* 4 rows of 4 (final) destination values */
       const Pixel temp[9][4],
       uint vfrac,         /* 0 &lt;= vertical displacement &lt;= 7 */
       uint bicubic        /* 1=bicubic filter, 0=bilinear */
   ) {
       const int * const fil = bicubic ? filters [vfrac] :
         BilinearFilters[vfrac];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int r = 0;  do              /* for each row */
       {
           int c = 0;  do          /* for each destination sample */
           {
               /* Pixel separation = one vertical step = width
                  of array = 4 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int r = 0;  do              /* for each row */
       {
           int c = 0;  do          /* for each destination sample */
           {
               /* Pixel separation = one vertical step = width
                  of array = 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               final[r][c] = interp(fil, temp[r] + c, 4);
           }
           while (++c &lt; 4);
       }
       while (++r &lt; 4);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               final[r][c] = interp(fil, temp[r] + c, 4);
           }
           while (++c &lt; 4);
       }
       while (++r &lt; 4);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4. Filter Properties
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18.4. 过滤器特性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We discuss briefly the rationale behind the choice of filters. Our approach is necessarily cursory; a genuinely accurate discussion would require a couple of books. Readers unfamiliar with signal processing may or may not wish to skip this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们简要讨论了选择滤波器的基本原理。我们的做法必然是草率的；真正准确的讨论需要几本书。不熟悉信号处理的读者可能希望也可能不希望跳过这一步。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All digital signals are of course sampled in some fashion. The case where the inter-sample spacing (say in time for audio samples, or space for pixels) is uniform, that is, the same at all positions, is particularly common and amenable to analysis. Many aspects of the treatment of such signals are best-understood in the frequency domain via Fourier Analysis, particularly those aspects of the signal that are not changed by shifts in position, especially when those positional shifts are not given by a whole number of samples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当然，所有数字信号都是以某种方式采样的。样本间间隔（例如，对于音频样本的时间间隔，或者对于像素的空间）是均匀的（即，在所有位置上相同）的情况尤其常见并且易于分析。通过傅里叶分析，在频域中最好地理解此类信号处理的许多方面，尤其是那些不因位置偏移而改变的信号方面，尤其是当这些位置偏移不是由整数个样本给出时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Non-integral translates of a sampled signal are a textbook example of the foregoing. In our case of non-integral motion vectors, we wish to say what the underlying image &#34;really is&#34; at these pixels; although we don&#39;t have values for them, we feel that it makes sense to talk about them. The correctness of this feeling is predicated on the underlying signal being band-limited, that is, not containing any energy in spatial frequencies that cannot be faithfully rendered at the pixel resolution at our disposal. In one dimension, this range of &#34;OK&#34; frequencies is called the Nyquist band; in our two-dimensional case of integer-grid samples, this range might be termed a Nyquist rectangle. The finer the grid, the more we know about the image, and the wider the Nyquist rectangle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
采样信号的非积分平移是前述的教科书示例。在我们的非积分运动矢量的例子中，我们希望说明这些像素处的基础图像“实际上是什么”；虽然我们对他们没有价值观，但我们觉得谈论他们是有意义的。这种感觉的正确性取决于基本信号的带宽限制，即不包含空间频率中的任何能量，这些能量无法以像素分辨率忠实呈现。在一维中，这种“OK”频率范围称为奈奎斯特频带；在整数网格样本的二维情况下，这个范围可以称为奈奎斯特矩形。网格越细，我们对图像的了解就越多，奈奎斯特矩形越宽。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It turns out that, for such band-limited signals, there is indeed an exact mathematical formula to produce the correct sample value at an arbitrary point. Unfortunately, this calculation requires the consideration of every single sample in the image, as well as needing to operate at infinite precision. Also, strictly speaking, all band-limited signals have infinite spatial (or temporal) extent, so everything we are discussing is really some sort of approximation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事实证明，对于这种带限信号，确实存在一个精确的数学公式，可以在任意点产生正确的采样值。不幸的是，此计算需要考虑图像中的每个样本，并且需要以无限精度进行操作。而且，严格地说，所有带限信号都有无限的空间（或时间）范围，所以我们讨论的一切实际上都是某种近似。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is true that the theoretically correct subsampling procedure, as well as any approximation thereof, is always given by a translation-invariant weighted sum (or filter) similar to that used by VP8. It is also true that the reconstruction error made by such a filter can be simply represented as a multiplier in the frequency domain; that is, such filters simply multiply the Fourier transform of any signal to which they are applied by a fixed function associated to the filter. This fixed function is usually called the frequency response (or transfer function); the ideal subsampling filter has a frequency response equal to one in the Nyquist rectangle and zero everywhere else.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
的确，理论上正确的子采样过程及其任何近似值总是由平移不变加权和（或滤波器）给出，类似于VP8所使用的方法。同样，这种滤波器产生的重构误差可以简单地表示为频域中的乘法器；也就是说，这种滤波器只是将其应用到的任何信号的傅里叶变换乘以与滤波器相关联的固定函数。这种固定函数通常称为频率响应（或传递函数）；理想的子采样滤波器的频率响应在奈奎斯特矩形中等于一，在其他地方等于零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another basic fact about approximations to &#34;truly correct&#34; subsampling is that the wider the subrectangle (within the Nyquist rectangle) of spatial frequencies one wishes to &#34;pass&#34; (that is, correctly render) or, put more accurately, the closer one wishes to approximate the ideal transfer function, the more samples of the original signal must be considered by the subsampling, and the wider the calculation precision necessitated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
关于近似“真正正确”子采样的另一个基本事实是，希望“通过”（即正确渲染）的空间频率的子矩形（在奈奎斯特矩形内）越宽，或者更准确地说，希望近似理想传递函数的子矩形越近，子采样必须考虑的原始信号样本越多，计算精度就越高。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The filters chosen by VP8 were chosen, within the constraints of 4 or 6 taps and 7-bit precision, to do the best possible job of handling the low spatial frequencies near the 0th DC frequency along with introducing no resonances (places where the absolute value of the frequency response exceeds one).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8选择的滤波器在4或6抽头和7位精度的限制范围内，尽可能最好地处理第0个直流频率附近的低空间频率，同时不引入共振（频率响应的绝对值超过1的地方）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The justification for the foregoing has two parts. First, resonances can produce extremely objectionable visible artifacts when, as often happens in actual compressed video streams, filters are applied repeatedly. Second, the vast majority of energy in real-world images lies near DC and not at the high end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述理由分为两部分。首先，当反复应用滤波器时，共振会产生非常令人讨厌的可见伪影，这在实际压缩视频流中经常发生。第二，现实世界图像中的绝大多数能量位于直流附近，而不是高端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To get slightly more specific, the filters chosen by VP8 are the best resonance-free 4- or 6-tap filters possible, where &#34;best&#34; describes the frequency response near the origin: The response at 0 is required to be 1, and the graph of the response at 0 is as flat as possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更具体地说，VP8选择的滤波器是最好的无共振4抽头或6抽头滤波器，其中“最佳”描述原点附近的频率响应：0处的响应要求为1，0处的响应曲线尽可能平坦。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To provide an intuitively more obvious point of reference, the &#34;best&#34; 2-tap filter is given by simple linear interpolation between the surrounding actual pixels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了提供更直观的参考点，“最佳”2抽头滤波器通过周围实际像素之间的简单线性插值给出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, it should be noted that, because of the way motion vectors are calculated, the (shorter) 4-tap filters (used for odd fractional displacements) are applied in the chroma plane only. Human color perception is notoriously poor, especially where higher spatial frequencies are involved. The shorter filters are easier to understand mathematically, and the difference between them and a theoretically slightly better 6-tap filter is negligible where chroma is concerned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，应注意，由于计算运动矢量的方式，仅在色度平面中应用（较短的）4抽头滤波器（用于奇数分数位移）。人类的颜色感知能力是出了名的差，尤其是在涉及更高空间频率的情况下。较短的滤波器在数学上更容易理解，它们与理论上稍好的6抽头滤波器之间的差异在色度方面可以忽略不计。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. Annex A: Bitstream Syntax
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. 附件A：比特流语法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This annex presents the bitstream syntax in a tabular form. All the information elements have been introduced and explained in the previous sections but are collected here for a quick reference. Each syntax element is briefly described after the tabular representation along with a reference to the corresponding paragraph in the main document. The meaning of each syntax element value is not repeated here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录以表格形式提供了位流语法。所有的信息元素都在前面的章节中介绍和解释过，但这里收集的信息仅供快速参考。每个语法元素在表格表示法之后进行简要描述，并参考主文档中的相应段落。这里不重复每个语法元素值的含义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The top-level hierarchy of the bitstream is introduced in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4节介绍了比特流的顶级层次结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition of syntax element coding types can be found in Section 8. The types used in the representation in this annex are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
语法元素编码类型的定义见第8节。本附件中表示中使用的类型为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o f(n), n-bit value from stream (n successive bits, not boolean encoded)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o f（n），来自流的n位值（n个连续位，非布尔编码）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o L(n), n-bit number encoded as n booleans (with equal probability of being 0 or 1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o L（n），编码为n布尔的n位数字（0或1的概率相等）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o B(p), bool with probability p of being 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 概率p为0的B（p），bool
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o T, tree-encoded value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o T、 树编码值
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. Uncompressed Data Chunk
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.1. 未压缩数据块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | Frame Tag                                         | Type  |
   | ------------------------------------------------- | ----- |
   | frame_tag                                         | f(24) |
   | if (key_frame) {                                  |       |
   |     start_code                                    | f(24) |
   |     horizontal_size_code                          | f(16) |
   |     vertical_size_code                            | f(16) |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | Frame Tag                                         | Type  |
   | ------------------------------------------------- | ----- |
   | frame_tag                                         | f(24) |
   | if (key_frame) {                                  |       |
   |     start_code                                    | f(24) |
   |     horizontal_size_code                          | f(16) |
   |     vertical_size_code                            | f(16) |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 3-byte frame tag can be parsed as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3字节帧标记可以按如下方式解析：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source;
   unsigned int tmp;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source;
   unsigned int tmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   tmp = (c[2] &lt;&lt; 16) | (c[1] &lt;&lt; 8) | c[0];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   tmp = (c[2] &lt;&lt; 16) | (c[1] &lt;&lt; 8) | c[0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   key_frame = tmp &amp; 0x1;
   version = (tmp &gt;&gt; 1) &amp; 0x7;
   show_frame = (tmp &gt;&gt; 4) &amp; 0x1;
   first_part_size = (tmp &gt;&gt; 5) &amp; 0x7FFFF;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   key_frame = tmp &amp; 0x1;
   version = (tmp &gt;&gt; 1) &amp; 0x7;
   show_frame = (tmp &gt;&gt; 4) &amp; 0x1;
   first_part_size = (tmp &gt;&gt; 5) &amp; 0x7FFFF;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
哪里：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o key_frame indicates whether the current frame is a key frame or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 关键帧指示当前帧是否为关键帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o version determines the bitstream version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 版本决定比特流的版本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o show_frame indicates whether the current frame is meant to be displayed or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o show_frame指示是否要显示当前帧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o first_part_size determines the size of the first partition (control partition), excluding the uncompressed data chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第一部分大小决定第一个分区（控制分区）的大小，不包括未压缩的数据块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The start_code is a constant 3-byte pattern having value 0x9d012a. The latter part of the uncompressed chunk (after the start_code) can be parsed as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
start_代码是一个恒定的3字节模式，其值为0x9d012a。未压缩块的后半部分（在start_代码之后）可以按如下方式解析：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source + 6;
   unsigned int tmp;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   unsigned char *c = pbi-&gt;source + 6;
   unsigned int tmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   tmp = (c[1] &lt;&lt; 8) | c[0];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   tmp = (c[1] &lt;&lt; 8) | c[0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   width = tmp &amp; 0x3FFF;
   horizontal_scale = tmp &gt;&gt; 14;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   width = tmp &amp; 0x3FFF;
   horizontal_scale = tmp &gt;&gt; 14;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   tmp = (c[3] &lt;&lt; 8) | c[2];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   tmp = (c[3] &lt;&lt; 8) | c[2];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   height = tmp &amp; 0x3FFF;
   vertical_scale = tmp &gt;&gt; 14;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   height = tmp &amp; 0x3FFF;
   vertical_scale = tmp &gt;&gt; 14;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. Frame Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.2. 帧头
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | Frame Header                                      | Type  |
   | ------------------------------------------------- | ----- |
   | if (key_frame) {                                  |       |
   |   color_space                                     | L(1)  |
   |   clamping_type                                   | L(1)  |
   | }                                                 |       |
   | segmentation_enabled                              | L(1)  |
   | if (segmentation_enabled)                         |       |
   |   update_segmentation()                           |       |
   | filter_type                                       | L(1)  |
   | loop_filter_level                                 | L(6)  |
   | sharpness_level                                   | L(3)  |
   | mb_lf_adjustments()                               |       |
   | log2_nbr_of_dct_partitions                        | L(2)  |
   | quant_indices()                                   |       |
   | if (key_frame)                                    |       |
   |   refresh_entropy_probs                           | L(1)  |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | Frame Header                                      | Type  |
   | ------------------------------------------------- | ----- |
   | if (key_frame) {                                  |       |
   |   color_space                                     | L(1)  |
   |   clamping_type                                   | L(1)  |
   | }                                                 |       |
   | segmentation_enabled                              | L(1)  |
   | if (segmentation_enabled)                         |       |
   |   update_segmentation()                           |       |
   | filter_type                                       | L(1)  |
   | loop_filter_level                                 | L(6)  |
   | sharpness_level                                   | L(3)  |
   | mb_lf_adjustments()                               |       |
   | log2_nbr_of_dct_partitions                        | L(2)  |
   | quant_indices()                                   |       |
   | if (key_frame)                                    |       |
   |   refresh_entropy_probs                           | L(1)  |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | else {                                            |       |
   |   refresh_golden_frame                            | L(1)  |
   |   refresh_alternate_frame                         | L(1)  |
   |   if (!refresh_golden_frame)                      |       |
   |     copy_buffer_to_golden                         | L(2)  |
   |   if (!refresh_alternate_frame)                   |       |
   |     copy_buffer_to_alternate                      | L(2)  |
   |   sign_bias_golden                                | L(1)  |
   |   sign_bias_alternate                             | L(1)  |
   |   refresh_entropy_probs                           | L(1)  |
   |   refresh_last                                    | L(1)  |
   | }                                                 |       |
   | token_prob_update()                               |       |
   | mb_no_skip_coeff                                  | L(1)  |
   | if (mb_no_skip_coeff)                             |       |
   |   prob_skip_false                                 | L(8)  |
   | if (!key_frame) {                                 |       |
   |   prob_intra                                      | L(8)  |
   |   prob_last                                       | L(8)  |
   |   prob_gf                                         | L(8)  |
   |   intra_16x16_prob_update_flag                    | L(1)  |
   |   if (intra_16x16_prob_update_flag) {             |       |
   |     for (i = 0; i &lt; 4; i++)                       |       |
   |       intra_16x16_prob                            | L(8)  |
   |   }                                               |       |
   |   intra_chroma prob_update_flag                   | L(1)  |
   |   if (intra_chroma_prob_update_flag) {            |       |
   |     for (i = 0; i &lt; 3; i++)                       |       |
   |       intra_chroma_prob                           | L(8)  |
   |   }                                               |       |
   |   mv_prob_update()                                |       |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | else {                                            |       |
   |   refresh_golden_frame                            | L(1)  |
   |   refresh_alternate_frame                         | L(1)  |
   |   if (!refresh_golden_frame)                      |       |
   |     copy_buffer_to_golden                         | L(2)  |
   |   if (!refresh_alternate_frame)                   |       |
   |     copy_buffer_to_alternate                      | L(2)  |
   |   sign_bias_golden                                | L(1)  |
   |   sign_bias_alternate                             | L(1)  |
   |   refresh_entropy_probs                           | L(1)  |
   |   refresh_last                                    | L(1)  |
   | }                                                 |       |
   | token_prob_update()                               |       |
   | mb_no_skip_coeff                                  | L(1)  |
   | if (mb_no_skip_coeff)                             |       |
   |   prob_skip_false                                 | L(8)  |
   | if (!key_frame) {                                 |       |
   |   prob_intra                                      | L(8)  |
   |   prob_last                                       | L(8)  |
   |   prob_gf                                         | L(8)  |
   |   intra_16x16_prob_update_flag                    | L(1)  |
   |   if (intra_16x16_prob_update_flag) {             |       |
   |     for (i = 0; i &lt; 4; i++)                       |       |
   |       intra_16x16_prob                            | L(8)  |
   |   }                                               |       |
   |   intra_chroma prob_update_flag                   | L(1)  |
   |   if (intra_chroma_prob_update_flag) {            |       |
   |     for (i = 0; i &lt; 3; i++)                       |       |
   |       intra_chroma_prob                           | L(8)  |
   |   }                                               |       |
   |   mv_prob_update()                                |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o color_space defines the YUV color space of the sequence (Section 9.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 颜色空间定义序列的YUV颜色空间（第9.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o clamping_type specifies if the decoder is required to clamp the reconstructed pixel values (Section 9.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 钳制类型指定解码器是否需要钳制重构像素值（第9.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segmentation_enabled enables the segmentation feature for the current frame (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segmentation_enabled启用当前帧的分段功能（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o filter_type determines whether the normal or the simple loop filter is used (Sections 9.4, 15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 过滤器类型决定使用普通还是简单环路过滤器（第9.4、15节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_level controls the deblocking filter (Sections 9.4, 15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 环路滤波器电平控制去块滤波器（第9.4、15节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sharpness_level controls the deblocking filter (Sections 9.4, 15)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 锐度水平控制去块滤波器（第9.4、15节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o log2_nbr_of_dct_partitions determines the number of separate partitions containing the DCT coefficients of the macroblocks (Section 9.5)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o dct分区的log2\u nbr\u确定包含宏块dct系数的单独分区的数量（第9.5节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_entropy_probs determines whether updated token probabilities are used only for this frame or until further update
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_entropy_probs确定更新的令牌概率是仅用于此帧还是在进一步更新之前使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_golden_frame determines if the current decoded frame refreshes the golden frame (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 刷新黄金帧确定当前解码帧是否刷新黄金帧（第9.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_alternate_frame determines if the current decoded frame refreshes the alternate reference frame (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_alternate_frame确定当前解码帧是否刷新备用参考帧（第9.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o copy_buffer_to_golden determines if the golden reference is replaced by another reference (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 将“缓冲区”复制到“黄金”以确定黄金参考是否被另一参考替换（第9.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o copy_buffer_to_alternate determines if the alternate reference is replaced by another reference (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 将“缓冲区”复制到“备用”确定备用参考是否被另一个参考替换（第9.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sign_bias_golden controls the sign of motion vectors when the golden frame is referenced (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 参考黄金帧时，符号\偏差\黄金控制运动矢量的符号（第9.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sign_bias_alternate controls the sign of motion vectors when the alternate frame is referenced (Section 9.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 符号\偏移\交替控制参考交替帧时运动矢量的符号（第9.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_last determines if the current decoded frame refreshes the last frame reference buffer (Section 9.8)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o refresh_last确定当前解码帧是否刷新最后一帧参考缓冲区（第9.8节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_no_skip_coeff enables or disables the skipping of macroblocks containing no non-zero coefficients (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_no_skip_coeff启用或禁用跳过不包含非零系数的宏块（第9.10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_skip_false indicates the probability that the macroblock is not skipped (flag indicating skipped macroblock is false) (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_skip_false表示宏块未被跳过的概率（表示跳过的宏块为false的标志）（第9.10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_intra indicates the probability of an intra macroblock (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_intra表示帧内宏块的概率（第9.10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_last indicates the probability that the last reference frame is used for inter-prediction (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_last表示最后一个参考帧用于帧间预测的概率（第9.10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_gf indicates the probability that the golden reference frame is used for inter-prediction (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob_gf表示黄金参考帧用于帧间预测的概率（第9.10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_16x16_prob_update_flag indicates if the branch probabilities used in the decoding of the luma intra-prediction mode are updated (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o INTERRAL_16x16_prob_update_标志指示luma帧内预测模式解码中使用的分支概率是否更新（第9.10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_16x16_prob indicates the branch probabilities of the luma intra-prediction mode decoding tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_16x16_prob指示luma帧内预测模式解码树的分支概率
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_chroma_prob_update_flag indicates if the branch probabilities used in the decoding of the chroma intra-prediction mode are updated (Section 9.10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 帧内色度概率更新标志指示在色度帧内预测模式解码中使用的分支概率是否更新（第9.10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_chroma_prob indicates the branch probabilities of the chroma intra-prediction mode decoding tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_chroma_prob指示色度帧内预测模式解码树的分支概率
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | update_segmentation()                             | Type  |
   | ------------------------------------------------- | ----- |
   | update_mb_segmentation_map                        | L(1)  |
   | update_segment_feature_data                       | L(1)  |
   | if (update_segment_feature_data) {                |       |
   |   segment_feature_mode                            | L(1)  |
   |   for (i = 0; i &lt; 4; i++) {                       |       |
   |     quantizer_update                              | L(1)  |
   |     if (quantizer_update) {                       |       |
   |       quantizer_update_value                      | L(7)  |
   |       quantizer_update_sign                       | L(1)  |
   |     }                                             |       |
   |   }                                               |       |
   |   for (i = 0; i &lt; 4; i++) {                       |       |
   |     loop_filter_update                            | L(1)  |
   |     if (loop_filter_update) {                     |       |
   |       lf_update_value                             | L(6)  |
   |       lf_update_sign                              | L(1)  |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
   | if (update_mb_segmentation_map) {                 |       |
   |   for (i = 0; i &lt; 3; i++) {                       |       |
   |     segment_prob_update                           | L(1)  |
   |     if (segment_prob_update)                      |       |
   |       segment_prob                                | L(8)  |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | update_segmentation()                             | Type  |
   | ------------------------------------------------- | ----- |
   | update_mb_segmentation_map                        | L(1)  |
   | update_segment_feature_data                       | L(1)  |
   | if (update_segment_feature_data) {                |       |
   |   segment_feature_mode                            | L(1)  |
   |   for (i = 0; i &lt; 4; i++) {                       |       |
   |     quantizer_update                              | L(1)  |
   |     if (quantizer_update) {                       |       |
   |       quantizer_update_value                      | L(7)  |
   |       quantizer_update_sign                       | L(1)  |
   |     }                                             |       |
   |   }                                               |       |
   |   for (i = 0; i &lt; 4; i++) {                       |       |
   |     loop_filter_update                            | L(1)  |
   |     if (loop_filter_update) {                     |       |
   |       lf_update_value                             | L(6)  |
   |       lf_update_sign                              | L(1)  |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
   | if (update_mb_segmentation_map) {                 |       |
   |   for (i = 0; i &lt; 3; i++) {                       |       |
   |     segment_prob_update                           | L(1)  |
   |     if (segment_prob_update)                      |       |
   |       segment_prob                                | L(8)  |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o update_mb_segmentation_map determines if the MB segmentation map is updated in the current frame (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o update_mb_segmentation_map确定mb segmentation map是否在当前帧中更新（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o update_segment_feature_data indicates if the segment feature data is updated in the current frame (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 更新\段\特征\数据表示段特征数据是否在当前帧中更新（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_feature_mode indicates the feature data update mode, 0 for delta and 1 for the absolute value (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 段\特征\模式表示特征数据更新模式，0表示增量，1表示绝对值（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o quantizer_update indicates if the quantizer value is updated for the i^(th) segment (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 量化器_update表示是否为i^（th）段更新量化器值（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o quantizer_update_value indicates the update value for the segment quantizer (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 量化器\更新\值表示段量化器的更新值（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o quantizer_update_sign indicates the update sign for the segment quantizer (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 量化器\更新\符号表示段量化器的更新符号（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_update indicates if the loop filter level value is updated for the i^(th) segment (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_update表示是否为i^（th）段更新了loop过滤器级别值（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o lf_update_value indicates the update value for the loop filter level (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o lf_update_值表示循环过滤器级别的更新值（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o lf_update_sign indicates the update sign for the loop filter level (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o lf_update_符号表示循环过滤器级别的更新符号（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_prob_update indicates whether the branch probabilities used to decode the segment_id in the MB header are decoded from the stream or use the default value of 255 (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_prob_update表示用于解码MB头中的segment_id的分支概率是从流中解码的，还是使用默认值255（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_prob indicates the branch probabilities of the segment_id decoding tree (Section 9.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_prob表示segment_id解码树的分支概率（第9.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | mb_lf_adjustments()                               | Type  |
   | ------------------------------------------------- | ----- |
   | loop_filter_adj_enable                            | L(1)  |
   | if (loop_filter_adj_enable) {                     |       |
   |   mode_ref_lf_delta_update                        | L(1)  |
   |   if (mode_ref_lf_delta_update) {                 |       |
   |     for (i = 0; i &lt; 4; i++) {                     |       |
   |       ref_frame_delta_update_flag                 | L(1)  |
   |       if (ref_frame_delta_update_flag) {          |       |
   |         delta_magnitude                           | L(6)  |
   |         delta_sign                                | L(1)  |
   |       }                                           |       |
   |     }                                             |       |
   |     for (i = 0; i &lt; 4; i++) {                     |       |
   |       mb_mode_delta_update_flag                   | L(1)  |
   |       if (mb_mode_delta_update_flag) {            |       |
   |         delta_magnitude                           | L(6)  |
   |         delta_sign                                | L(1)  |
   |       }                                           |       |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | mb_lf_adjustments()                               | Type  |
   | ------------------------------------------------- | ----- |
   | loop_filter_adj_enable                            | L(1)  |
   | if (loop_filter_adj_enable) {                     |       |
   |   mode_ref_lf_delta_update                        | L(1)  |
   |   if (mode_ref_lf_delta_update) {                 |       |
   |     for (i = 0; i &lt; 4; i++) {                     |       |
   |       ref_frame_delta_update_flag                 | L(1)  |
   |       if (ref_frame_delta_update_flag) {          |       |
   |         delta_magnitude                           | L(6)  |
   |         delta_sign                                | L(1)  |
   |       }                                           |       |
   |     }                                             |       |
   |     for (i = 0; i &lt; 4; i++) {                     |       |
   |       mb_mode_delta_update_flag                   | L(1)  |
   |       if (mb_mode_delta_update_flag) {            |       |
   |         delta_magnitude                           | L(6)  |
   |         delta_sign                                | L(1)  |
   |       }                                           |       |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_adj_enable indicates if the MB-level loop filter adjustment (based on the used reference frame and coding mode) is on for the current frame (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o loop_filter_adj_enable表示当前帧的MB级环路滤波器调整（基于使用的参考帧和编码模式）是否开启（第9.4节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mode_ref_lf_delta_update indicates if the delta values used in an adjustment are updated in the current frame (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 模式_ref_lf_delta_update表示调整中使用的delta值是否在当前帧中更新（第9.4节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ref_frame_delta_update_flag indicates if the adjustment delta value corresponding to a certain used reference frame is updated (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ref_frame_delta_update_标志表示是否更新了与某个使用的参考坐标系对应的调整delta值（第9.4节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o delta_magnitude is the absolute value of the delta value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o delta_震级是delta值的绝对值
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o delta_sign is the sign of the delta value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o delta_符号是delta值的符号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_mode_delta_update_flag indicates if the adjustment delta value corresponding to a certain MB prediction mode is updated (Section 9.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_mode_delta_update_标志指示是否更新了与某mb预测模式对应的调整delta值（第9.4节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | quant_indices()                                   | Type  |
   | ------------------------------------------------- | ----- |
   | y_ac_qi                                           | L(7)  |
   | y_dc_delta_present                                | L(1)  |
   | if (y_dc_delta_present) {                         |       |
   |   y_dc_delta_magnitude                            | L(4)  |
   |   y_dc_delta_sign                                 | L(1)  |
   | }                                                 |       |
   | y2_dc_delta_present                               | L(1)  |
   | if (y2_dc_delta_present) {                        |       |
   |   y2_dc_delta_magnitude                           | L(4)  |
   |   y2_dc_delta_sign                                | L(1)  |
   | }                                                 |       |
   | y2_ac_delta_present                               | L(1)  |
   | if (y2_ac_delta_present) {                        |       |
   |   y2_ac_delta_magnitude                           | L(4)  |
   |   y2_ac_delta_sign                                | L(1)  |
   | }                                                 |       |
   | uv_dc_delta_present                               | L(1)  |
   | if (uv_dc_delta_present) {                        |       |
   |   uv_dc_delta_magnitude                           | L(4)  |
   |   uv_dc_delta_sign                                | L(1)  |
   | }                                                 |       |
   | uv_ac_delta_present                               | L(1)  |
   | if (uv_ac_delta_present) {                        |       |
   |   uv_ac_delta_magnitude                           | L(4)  |
   |   uv_ac_delta_sign                                | L(1)  |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | quant_indices()                                   | Type  |
   | ------------------------------------------------- | ----- |
   | y_ac_qi                                           | L(7)  |
   | y_dc_delta_present                                | L(1)  |
   | if (y_dc_delta_present) {                         |       |
   |   y_dc_delta_magnitude                            | L(4)  |
   |   y_dc_delta_sign                                 | L(1)  |
   | }                                                 |       |
   | y2_dc_delta_present                               | L(1)  |
   | if (y2_dc_delta_present) {                        |       |
   |   y2_dc_delta_magnitude                           | L(4)  |
   |   y2_dc_delta_sign                                | L(1)  |
   | }                                                 |       |
   | y2_ac_delta_present                               | L(1)  |
   | if (y2_ac_delta_present) {                        |       |
   |   y2_ac_delta_magnitude                           | L(4)  |
   |   y2_ac_delta_sign                                | L(1)  |
   | }                                                 |       |
   | uv_dc_delta_present                               | L(1)  |
   | if (uv_dc_delta_present) {                        |       |
   |   uv_dc_delta_magnitude                           | L(4)  |
   |   uv_dc_delta_sign                                | L(1)  |
   | }                                                 |       |
   | uv_ac_delta_present                               | L(1)  |
   | if (uv_ac_delta_present) {                        |       |
   |   uv_ac_delta_magnitude                           | L(4)  |
   |   uv_ac_delta_sign                                | L(1)  |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_ac_qi is the dequantization table index used for the luma AC coefficients (and other coefficient groups if no delta value is present) (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_ac_qi是用于luma ac系数（以及其他系数组，如果不存在增量值）的去量化表索引（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the luma DC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_present表示流是否包含一个增量值，该增量值被添加到基线索引以获得luma dc系数去量化索引（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_magnitude is the magnitude of the delta value (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_震级是delta值的震级（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_sign is the sign of the delta value (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y_dc_delta_符号是delta值的符号（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y2_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the Y2 block DC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y2_dc_delta_present表示流是否包含添加到基线索引以获得y2块dc系数去量化索引的delta值（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y2_ac_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the Y2 block AC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o y2_ac_delta_present表示流是否包含一个增量值，该增量值被添加到基线索引以获得y2块ac系数去量化索引（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o uv_dc_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the chroma DC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o uv_dc_delta_present表示流是否包含添加到基线索引以获得色度dc系数去量化索引的delta值（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o uv_ac_delta_present indicates if the stream contains a delta value that is added to the baseline index to obtain the chroma AC coefficient dequantization index (Section 9.6)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o uv_ac_delta_present表示流是否包含添加到基线索引以获得色度ac系数去量化索引的delta值（第9.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | token_prob_update()                               | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = 0; i &lt; 4; i++) {                         |       |
   |   for (j = 0; j &lt; 8; j++) {                       |       |
   |     for (k = 0; k &lt; 3; k++) {                     |       |
   |       for (l = 0; l &lt; 11; l++) {                  |       |
   |         coeff_prob_update_flag                    | L(1)  |
   |         if (coeff_prob_update_flag)               |       |
   |           coeff_prob                              | L(8)  |
   |       }                                           |       |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | token_prob_update()                               | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = 0; i &lt; 4; i++) {                         |       |
   |   for (j = 0; j &lt; 8; j++) {                       |       |
   |     for (k = 0; k &lt; 3; k++) {                     |       |
   |       for (l = 0; l &lt; 11; l++) {                  |       |
   |         coeff_prob_update_flag                    | L(1)  |
   |         if (coeff_prob_update_flag)               |       |
   |           coeff_prob                              | L(8)  |
   |       }                                           |       |
   |     }                                             |       |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o coeff_prob_update_flag indicates if the corresponding branch probability is updated in the current frame (Section 13.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o coeff_prob_update_标志表示当前帧中是否更新了相应的分支概率（第13.4节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o coeff_prob is the new branch probability (Section 13.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o coeff_prob是新的分支概率（第13.4节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | mv_prob_update()                                  | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = 0; i &lt; 2; i++) {                         |       |
   |   for (j = 0; j &lt; 19; j++) {                      |       |
   |     mv_prob_update_flag                           | L(1)  |
   |     if (mv_prob_update_flag)                      |       |
   |       prob                                        | L(7)  |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | mv_prob_update()                                  | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = 0; i &lt; 2; i++) {                         |       |
   |   for (j = 0; j &lt; 19; j++) {                      |       |
   |     mv_prob_update_flag                           | L(1)  |
   |     if (mv_prob_update_flag)                      |       |
   |       prob                                        | L(7)  |
   |   }                                               |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_prob_update_flag indicates if the corresponding MV decoding probability is updated in the current frame (Section 17.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_prob_update_标志表示当前帧中是否更新了相应的mv解码概率（第17.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob is the updated probability (Section 17.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o prob是更新的概率（第17.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3. Macroblock Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19.3. 宏块数据
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | Macroblock Data                                   | Type  |
   | ------------------------------------------------- | ----- |
   | macroblock_header()                               |       |
   | residual_data()                                   |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | Macroblock Data                                   | Type  |
   | ------------------------------------------------- | ----- |
   | macroblock_header()                               |       |
   | residual_data()                                   |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | macroblock_header()                               | Type  |
   | ------------------------------------------------- | ----- |
   | if (update_mb_segmentation_map)                   |       |
   |   segment_id                                      | T     |
   | if (mb_no_skip_coeff)                             |       |
   |   mb_skip_coeff                                   | B(p)  |
   | if (!key_frame)                                   |       |
   |   is_inter_mb                                     | B(p)  |
   | if (is_inter_mb) {                                |       |
   |   mb_ref_frame_sel1                               | B(p)  |
   |   if (mb_ref_frame_sel1)                          |       |
   |     mb_ref_frame_sel2                             | B(p)  |
   |   mv_mode                                         | T     |
   |   if (mv_mode == SPLITMV) {                       |       |
   |     mv_split_mode                                 | T     |
   |     for (i = 0; i &lt; numMvs; i++) {                |       |
   |       sub_mv_mode                                 | T     |
   |       if (sub_mv_mode == NEWMV4x4) {              |       |
   |         read_mvcomponent()                        |       |
   |         read_mvcomponent()                        |       |
   |       }                                           |       |
   |     }                                             |       |
   |   } else if (mv_mode == NEWMV) {                  |       |
   |     read_mvcomponent()                            |       |
   |     read_mvcomponent()                            |       |
   |   }                                               |       |
   | } else { /* intra mb */                           |       |
   |   intra_y_mode                                    | T     |
   |   if (intra_y_mode == B_PRED) {                   |       |
   |     for (i = 0; i &lt; 16; i++)                      |       |
   |       intra_b_mode                                | T     |
   |   }                                               |       |
   |   intra_uv_mode                                   | T     |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | macroblock_header()                               | Type  |
   | ------------------------------------------------- | ----- |
   | if (update_mb_segmentation_map)                   |       |
   |   segment_id                                      | T     |
   | if (mb_no_skip_coeff)                             |       |
   |   mb_skip_coeff                                   | B(p)  |
   | if (!key_frame)                                   |       |
   |   is_inter_mb                                     | B(p)  |
   | if (is_inter_mb) {                                |       |
   |   mb_ref_frame_sel1                               | B(p)  |
   |   if (mb_ref_frame_sel1)                          |       |
   |     mb_ref_frame_sel2                             | B(p)  |
   |   mv_mode                                         | T     |
   |   if (mv_mode == SPLITMV) {                       |       |
   |     mv_split_mode                                 | T     |
   |     for (i = 0; i &lt; numMvs; i++) {                |       |
   |       sub_mv_mode                                 | T     |
   |       if (sub_mv_mode == NEWMV4x4) {              |       |
   |         read_mvcomponent()                        |       |
   |         read_mvcomponent()                        |       |
   |       }                                           |       |
   |     }                                             |       |
   |   } else if (mv_mode == NEWMV) {                  |       |
   |     read_mvcomponent()                            |       |
   |     read_mvcomponent()                            |       |
   |   }                                               |       |
   | } else { /* intra mb */                           |       |
   |   intra_y_mode                                    | T     |
   |   if (intra_y_mode == B_PRED) {                   |       |
   |     for (i = 0; i &lt; 16; i++)                      |       |
   |       intra_b_mode                                | T     |
   |   }                                               |       |
   |   intra_uv_mode                                   | T     |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o segment_id indicates to which segment the macroblock belongs (Section 10)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 段\ id指示宏块所属的段（第10节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_skip_coeff indicates whether the macroblock contains any coded coefficients or not (Section 11.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_skip_coeff表示宏块是否包含任何编码系数（第11.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o is_inter_mb indicates whether the macroblock is intra- or inter-coded (Section 16)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o is_inter_mb表示宏块是帧内编码还是帧间编码（第16节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_ref_frame_sel1 selects the reference frame to be used; last frame (0), golden/alternate (1) (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_ref_frame_sel1选择要使用的参考帧；最后一帧（0），金色/备选（1）（第16.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_ref_frame_sel2 selects whether the golden (0) or alternate reference frame (1) is used (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mb_ref_frame_sel2选择是使用黄金参考系（0）还是备用参考系（1）（第16.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_mode determines the macroblock motion vector mode (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_模式确定宏块运动矢量模式（第16.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_split_mode gives the macroblock partitioning specification and determines the number of motion vectors used (numMvs) (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o mv_split_模式给出宏块分区规范，并确定使用的运动矢量数（NUMMV）（第16.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sub_mv_mode determines the sub-macroblock motion vector mode for macroblocks coded using the SPLITMV motion vector mode (Section 16.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sub_mv_模式确定使用SPLITMV运动矢量模式编码的宏块的子宏块运动矢量模式（第16.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_y_mode selects the luminance intra-prediction mode (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 帧内模式选择亮度帧内预测模式（第16.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_b_mode selects the sub-macroblock luminance prediction mode for macroblocks coded using B_PRED mode (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 帧内b_模式为使用b_PRED模式编码的宏块选择子宏块亮度预测模式（第16.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o intra_uv_mode selects the chrominance intra-prediction mode (Section 16.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 帧内uv模式选择色度帧内预测模式（第16.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | residual_data()                                   | Type  |
   | ------------------------------------------------- | ----- |
   | if (!mb_skip_coeff) {                             |       |
   |   if ( (is_inter_mb &amp;&amp; mv_mode != SPLITMV) ||     |       |
   |        (!is_inter_mb &amp;&amp; intra_y_mode != B_PRED) ) |       |
   |     residual_block() /* Y2 */                     |       |
   |   for (i = 0; i &lt; 24; i++)                        |       |
   |     residual_block() /* 16 Y, 4 U, 4 V */         |       |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | residual_data()                                   | Type  |
   | ------------------------------------------------- | ----- |
   | if (!mb_skip_coeff) {                             |       |
   |   if ( (is_inter_mb &amp;&amp; mv_mode != SPLITMV) ||     |       |
   |        (!is_inter_mb &amp;&amp; intra_y_mode != B_PRED) ) |       |
   |     residual_block() /* Y2 */                     |       |
   |   for (i = 0; i &lt; 24; i++)                        |       |
   |     residual_block() /* 16 Y, 4 U, 4 V */         |       |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | residual_block()                                  | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = firstCoeff; i &lt; 16; i++) {               |       |
   |   token                                           | T     |
   |   if (token == EOB) break;                        |       |
   |   if (token_has_extra_bits)                       |       |
   |     extra_bits                                    | L(n)  |
   |   if (coefficient != 0)                           |       |
   |     sign                                          | L(1)  |
   | }                                                 |       |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | residual_block()                                  | Type  |
   | ------------------------------------------------- | ----- |
   | for (i = firstCoeff; i &lt; 16; i++) {               |       |
   |   token                                           | T     |
   |   if (token == EOB) break;                        |       |
   |   if (token_has_extra_bits)                       |       |
   |     extra_bits                                    | L(n)  |
   |   if (coefficient != 0)                           |       |
   |     sign                                          | L(1)  |
   | }                                                 |       |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o firstCoeff is 1 for luma blocks of macroblocks containing Y2 subblock; otherwise 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于包含Y2子块的宏块的luma块，firstCoeff为1；否则0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o token defines the value of the coefficient, the value range of the coefficient, or the end of block (Section 13.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 标记定义了系数的值、系数的值范围或块的末尾（第13.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o extra_bits determines the value of the coefficient within the value range defined by the token (Section 13.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 额外_位确定令牌定义的值范围内的系数值（第13.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sign indicates the sign of the coefficient (Section 13.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 符号表示系数的符号（第13.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. Attachment One: Reference Decoder Source Code
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. 附件一：参考解码器源代码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. bit_ops.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.1. 比特运算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef BIT_OPS_H
   #define BIT_OPS_H
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef BIT_OPS_H
   #define BIT_OPS_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Evaluates to a mask with n bits set */
   #define BITS_MASK(n) ((1&lt;&lt;(n))-1)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Evaluates to a mask with n bits set */
   #define BITS_MASK(n) ((1&lt;&lt;(n))-1)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Returns len bits, with the LSB at position bit */
   #define BITS_GET(val, bit, len) (((val)&gt;&gt;(bit))&amp;BITS_MASK(len))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Returns len bits, with the LSB at position bit */
   #define BITS_GET(val, bit, len) (((val)&gt;&gt;(bit))&amp;BITS_MASK(len))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. bool_decoder.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.2. bool_解码器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef BOOL_DECODER_H
   #define BOOL_DECODER_H
   #include &lt;stddef.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef BOOL_DECODER_H
   #define BOOL_DECODER_H
   #include &lt;stddef.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct bool_decoder
   {
       const unsigned char *input;      /* next compressed data byte */
       size_t               input_len;  /* length of the input buffer */
       unsigned int         range;      /* identical to encoder&#39;s
                                         * range */
       unsigned int         value;      /* contains at least 8
                                         * significant bits */
       int                  bit_count;  /* # of bits shifted out of
                                         * value, max 7 */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct bool_decoder
   {
       const unsigned char *input;      /* next compressed data byte */
       size_t               input_len;  /* length of the input buffer */
       unsigned int         range;      /* identical to encoder&#39;s
                                         * range */
       unsigned int         value;      /* contains at least 8
                                         * significant bits */
       int                  bit_count;  /* # of bits shifted out of
                                         * value, max 7 */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   init_bool_decoder(struct bool_decoder *d,
                     const unsigned char *start_partition,
                     size_t               sz)
   {
       if (sz &gt;= 2)
       {
           d-&gt;value = (start_partition[0] &lt;&lt; 8) /* first 2 input
                                                 * bytes */
                      | start_partition[1];
           d-&gt;input = start_partition + 2;      /* ptr to next byte */
           d-&gt;input_len = sz - 2;
       }
       else
       {
           d-&gt;value = 0;
           d-&gt;input = NULL;
           d-&gt;input_len = 0;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   init_bool_decoder(struct bool_decoder *d,
                     const unsigned char *start_partition,
                     size_t               sz)
   {
       if (sz &gt;= 2)
       {
           d-&gt;value = (start_partition[0] &lt;&lt; 8) /* first 2 input
                                                 * bytes */
                      | start_partition[1];
           d-&gt;input = start_partition + 2;      /* ptr to next byte */
           d-&gt;input_len = sz - 2;
       }
       else
       {
           d-&gt;value = 0;
           d-&gt;input = NULL;
           d-&gt;input_len = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       d-&gt;range = 255;    /* initial range is full */
       d-&gt;bit_count = 0;  /* have not yet shifted out any bits */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       d-&gt;range = 255;    /* initial range is full */
       d-&gt;bit_count = 0;  /* have not yet shifted out any bits */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get(struct bool_decoder *d, int probability)
   {
       /* range and split are identical to the corresponding values
          used by the encoder when this bool was written */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get(struct bool_decoder *d, int probability)
   {
       /* range and split are identical to the corresponding values
          used by the encoder when this bool was written */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int  split = 1 + (((d-&gt;range - 1) * probability) &gt;&gt; 8);
       unsigned int  SPLIT = split &lt;&lt; 8;
       int           retval;           /* will be 0 or 1 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int  split = 1 + (((d-&gt;range - 1) * probability) &gt;&gt; 8);
       unsigned int  SPLIT = split &lt;&lt; 8;
       int           retval;           /* will be 0 or 1 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (d-&gt;value &gt;= SPLIT)    /* encoded a one */
       {
           retval = 1;
           d-&gt;range -= split;  /* reduce range */
           d-&gt;value -= SPLIT;  /* subtract off left endpoint of
                                * interval */
       }
       else                  /* encoded a zero */
       {
           retval = 0;
           d-&gt;range = split; /* reduce range, no change in left
                              * endpoint */
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (d-&gt;value &gt;= SPLIT)    /* encoded a one */
       {
           retval = 1;
           d-&gt;range -= split;  /* reduce range */
           d-&gt;value -= SPLIT;  /* subtract off left endpoint of
                                * interval */
       }
       else                  /* encoded a zero */
       {
           retval = 0;
           d-&gt;range = split; /* reduce range, no change in left
                              * endpoint */
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       while (d-&gt;range &lt; 128)    /* shift out irrelevant value bits */
       {
           d-&gt;value &lt;&lt;= 1;
           d-&gt;range &lt;&lt;= 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       while (d-&gt;range &lt; 128)    /* shift out irrelevant value bits */
       {
           d-&gt;value &lt;&lt;= 1;
           d-&gt;range &lt;&lt;= 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (++d-&gt;bit_count == 8)  /* shift in new bits 8 at a time */
           {
               d-&gt;bit_count = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (++d-&gt;bit_count == 8)  /* shift in new bits 8 at a time */
           {
               d-&gt;bit_count = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (d-&gt;input_len)
               {
                   d-&gt;value |= *d-&gt;input++;
                   d-&gt;input_len--;
               }
           }
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (d-&gt;input_len)
               {
                   d-&gt;value |= *d-&gt;input++;
                   d-&gt;input_len--;
               }
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return retval;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return retval;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get_bit(struct bool_decoder *br)
   {
       return bool_get(br, 128);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get_bit(struct bool_decoder *br)
   {
       return bool_get(br, 128);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get_uint(struct bool_decoder *br, int bits)
   {
       int z = 0;
       int bit;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get_uint(struct bool_decoder *br, int bits)
   {
       int z = 0;
       int bit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (bit = bits - 1; bit &gt;= 0; bit--)
       {
           z |= (bool_get_bit(br) &lt;&lt; bit);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (bit = bits - 1; bit &gt;= 0; bit--)
       {
           z |= (bool_get_bit(br) &lt;&lt; bit);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return z;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return z;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get_int(struct bool_decoder *br, int bits)
   {
       int z = 0;
       int bit;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_get_int(struct bool_decoder *br, int bits)
   {
       int z = 0;
       int bit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (bit = bits - 1; bit &gt;= 0; bit--)
       {
           z |= (bool_get_bit(br) &lt;&lt; bit);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (bit = bits - 1; bit &gt;= 0; bit--)
       {
           z |= (bool_get_bit(br) &lt;&lt; bit);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return bool_get_bit(br) ? -z : z;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return bool_get_bit(br) ? -z : z;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_maybe_get_int(struct bool_decoder *br, int bits)
   {
       return bool_get_bit(br) ? bool_get_int(br, bits) : 0;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int bool_maybe_get_int(struct bool_decoder *br, int bits)
   {
       return bool_get_bit(br) ? bool_get_int(br, bits) : 0;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   bool_read_tree(struct bool_decoder *bool,
                  const int           *t,
                  const unsigned char *p)
   {
       int i = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   bool_read_tree(struct bool_decoder *bool,
                  const int           *t,
                  const unsigned char *p)
   {
       int i = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       while ((i = t[ i + bool_get(bool, p[i&gt;&gt;1])]) &gt; 0);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       while ((i = t[ i + bool_get(bool, p[i&gt;&gt;1])]) &gt; 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return -i;
   }
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return -i;
   }
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3. dequant_data.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.3. dequant_data.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int dc_q_lookup[128] =
   {
       4,    5,    6,    7,    8,    9,    10,   10,
       11,   12,   13,   14,   15,   16,   17,   17,
       18,   19,   20,   20,   21,   21,   22,   22,
       23,   23,   24,   25,   25,   26,   27,   28,
       29,   30,   31,   32,   33,   34,   35,   36,
       37,   37,   38,   39,   40,   41,   42,   43,
       44,   45,   46,   46,   47,   48,   49,   50,
       51,   52,   53,   54,   55,   56,   57,   58,
       59,   60,   61,   62,   63,   64,   65,   66,
       67,   68,   69,   70,   71,   72,   73,   74,
       75,   76,   76,   77,   78,   79,   80,   81,
       82,   83,   84,   85,   86,   87,   88,   89,
       91,   93,   95,   96,   98,   100,  101,  102,
       104,  106,  108,  110,  112,  114,  116,  118,
       122,  124,  126,  128,  130,  132,  134,  136,
       138,  140,  143,  145,  148,  151,  154,  157
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int dc_q_lookup[128] =
   {
       4,    5,    6,    7,    8,    9,    10,   10,
       11,   12,   13,   14,   15,   16,   17,   17,
       18,   19,   20,   20,   21,   21,   22,   22,
       23,   23,   24,   25,   25,   26,   27,   28,
       29,   30,   31,   32,   33,   34,   35,   36,
       37,   37,   38,   39,   40,   41,   42,   43,
       44,   45,   46,   46,   47,   48,   49,   50,
       51,   52,   53,   54,   55,   56,   57,   58,
       59,   60,   61,   62,   63,   64,   65,   66,
       67,   68,   69,   70,   71,   72,   73,   74,
       75,   76,   76,   77,   78,   79,   80,   81,
       82,   83,   84,   85,   86,   87,   88,   89,
       91,   93,   95,   96,   98,   100,  101,  102,
       104,  106,  108,  110,  112,  114,  116,  118,
       122,  124,  126,  128,  130,  132,  134,  136,
       138,  140,  143,  145,  148,  151,  154,  157
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const int ac_q_lookup[128] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态常量int ac_q_查找[128]={ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152,
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284 };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284 };
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4. dixie.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.4. 迪克西
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;bit_ops.h&#34;
   #include &#34;dixie.h&#34;
   #include &#34;vp8_prob_data.h&#34;
   #include &#34;dequant_data.h&#34;
   #include &#34;modemv.h&#34;
   #include &#34;tokens.h&#34;
   #include &#34;predict.h&#34;
   #include &#34;dixie_loopfilter.h&#34;
   #include &lt;string.h&gt;
   #include &lt;assert.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;bit_ops.h&#34;
   #include &#34;dixie.h&#34;
   #include &#34;vp8_prob_data.h&#34;
   #include &#34;dequant_data.h&#34;
   #include &#34;modemv.h&#34;
   #include &#34;tokens.h&#34;
   #include &#34;predict.h&#34;
   #include &#34;dixie_loopfilter.h&#34;
   #include &lt;string.h&gt;
   #include &lt;assert.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       FRAME_HEADER_SZ = 3,
       KEYFRAME_HEADER_SZ = 7
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       FRAME_HEADER_SZ = 3,
       KEYFRAME_HEADER_SZ = 7
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define ARRAY_COPY(a,b) {\
       assert(sizeof(a)==sizeof(b));memcpy(a,b,sizeof(a));}
   static void
   decode_entropy_header(struct vp8_decoder_ctx    *ctx,
                         struct bool_decoder       *bool,
                         struct vp8_entropy_hdr    *hdr)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define ARRAY_COPY(a,b) {\
       assert(sizeof(a)==sizeof(b));memcpy(a,b,sizeof(a));}
   static void
   decode_entropy_header(struct vp8_decoder_ctx    *ctx,
                         struct bool_decoder       *bool,
                         struct vp8_entropy_hdr    *hdr)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       int i, j, k, l;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       int i, j, k, l;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Read coefficient probability updates */
       for (i = 0; i &lt; BLOCK_TYPES; i++)
           for (j = 0; j &lt; COEFF_BANDS; j++)
               for (k = 0; k &lt; PREV_COEFF_CONTEXTS; k++)
                   for (l = 0; l &lt; ENTROPY_NODES; l++)
                       if (bool_get(bool,
                                    k_coeff_entropy_update_probs
                                        [i][j][k][l]))
                           hdr-&gt;coeff_probs[i][j][k][l] =
                               bool_get_uint(bool, 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Read coefficient probability updates */
       for (i = 0; i &lt; BLOCK_TYPES; i++)
           for (j = 0; j &lt; COEFF_BANDS; j++)
               for (k = 0; k &lt; PREV_COEFF_CONTEXTS; k++)
                   for (l = 0; l &lt; ENTROPY_NODES; l++)
                       if (bool_get(bool,
                                    k_coeff_entropy_update_probs
                                        [i][j][k][l]))
                           hdr-&gt;coeff_probs[i][j][k][l] =
                               bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Read coefficient skip mode probability */
       hdr-&gt;coeff_skip_enabled = bool_get_bit(bool);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Read coefficient skip mode probability */
       hdr-&gt;coeff_skip_enabled = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;coeff_skip_enabled)
           hdr-&gt;coeff_skip_prob = bool_get_uint(bool, 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;coeff_skip_enabled)
           hdr-&gt;coeff_skip_prob = bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Parse interframe probability updates */
       if (!ctx-&gt;frame_hdr.is_keyframe)
       {
           hdr-&gt;prob_inter = bool_get_uint(bool, 8);
           hdr-&gt;prob_last  = bool_get_uint(bool, 8);
           hdr-&gt;prob_gf    = bool_get_uint(bool, 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Parse interframe probability updates */
       if (!ctx-&gt;frame_hdr.is_keyframe)
       {
           hdr-&gt;prob_inter = bool_get_uint(bool, 8);
           hdr-&gt;prob_last  = bool_get_uint(bool, 8);
           hdr-&gt;prob_gf    = bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (bool_get_bit(bool))
               for (i = 0; i &lt; 4; i++)
                   hdr-&gt;y_mode_probs[i] = bool_get_uint(bool, 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (bool_get_bit(bool))
               for (i = 0; i &lt; 4; i++)
                   hdr-&gt;y_mode_probs[i] = bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (bool_get_bit(bool))
               for (i = 0; i &lt; 3; i++)
                   hdr-&gt;uv_mode_probs[i] = bool_get_uint(bool, 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (bool_get_bit(bool))
               for (i = 0; i &lt; 3; i++)
                   hdr-&gt;uv_mode_probs[i] = bool_get_uint(bool, 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 2; i++)
               for (j = 0; j &lt; MV_PROB_CNT; j++)
                   if (bool_get(bool, k_mv_entropy_update_probs[i][j]))
                   {
                       int x = bool_get_uint(bool, 7);
                       hdr-&gt;mv_probs[i][j] = x ? x &lt;&lt; 1 : 1;
                   }
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 2; i++)
               for (j = 0; j &lt; MV_PROB_CNT; j++)
                   if (bool_get(bool, k_mv_entropy_update_probs[i][j]))
                   {
                       int x = bool_get_uint(bool, 7);
                       hdr-&gt;mv_probs[i][j] = x ? x &lt;&lt; 1 : 1;
                   }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_reference_header(struct vp8_decoder_ctx    *ctx,
                           struct bool_decoder       *bool,
                           struct vp8_reference_hdr  *hdr)
   {
       unsigned int key = ctx-&gt;frame_hdr.is_keyframe;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_reference_header(struct vp8_decoder_ctx    *ctx,
                           struct bool_decoder       *bool,
                           struct vp8_reference_hdr  *hdr)
   {
       unsigned int key = ctx-&gt;frame_hdr.is_keyframe;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;refresh_gf    = key ? 1 : bool_get_bit(bool);
       hdr-&gt;refresh_arf   = key ? 1 : bool_get_bit(bool);
       hdr-&gt;copy_gf       = key ? 0 : !hdr-&gt;refresh_gf
                            ? bool_get_uint(bool, 2) : 0;
       hdr-&gt;copy_arf      = key ? 0 : !hdr-&gt;refresh_arf
                            ? bool_get_uint(bool, 2) : 0;
       hdr-&gt;sign_bias[GOLDEN_FRAME] = key ? 0 : bool_get_bit(bool);
       hdr-&gt;sign_bias[ALTREF_FRAME] = key ? 0 : bool_get_bit(bool);
       hdr-&gt;refresh_entropy = bool_get_bit(bool);
       hdr-&gt;refresh_last  = key ? 1 : bool_get_bit(bool);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;refresh_gf    = key ? 1 : bool_get_bit(bool);
       hdr-&gt;refresh_arf   = key ? 1 : bool_get_bit(bool);
       hdr-&gt;copy_gf       = key ? 0 : !hdr-&gt;refresh_gf
                            ? bool_get_uint(bool, 2) : 0;
       hdr-&gt;copy_arf      = key ? 0 : !hdr-&gt;refresh_arf
                            ? bool_get_uint(bool, 2) : 0;
       hdr-&gt;sign_bias[GOLDEN_FRAME] = key ? 0 : bool_get_bit(bool);
       hdr-&gt;sign_bias[ALTREF_FRAME] = key ? 0 : bool_get_bit(bool);
       hdr-&gt;refresh_entropy = bool_get_bit(bool);
       hdr-&gt;refresh_last  = key ? 1 : bool_get_bit(bool);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_quantizer_header(struct vp8_decoder_ctx    *ctx,
                           struct bool_decoder       *bool,
                           struct vp8_quant_hdr      *hdr)
   {
       int update;
       int last_q = hdr-&gt;q_index;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_quantizer_header(struct vp8_decoder_ctx    *ctx,
                           struct bool_decoder       *bool,
                           struct vp8_quant_hdr      *hdr)
   {
       int update;
       int last_q = hdr-&gt;q_index;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;q_index = bool_get_uint(bool, 7);
       update = last_q != hdr-&gt;q_index;
       update |= (hdr-&gt;y1_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;y2_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;y2_ac_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;uv_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;uv_ac_delta_q = bool_maybe_get_int(bool, 4));
       hdr-&gt;delta_update = update;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;q_index = bool_get_uint(bool, 7);
       update = last_q != hdr-&gt;q_index;
       update |= (hdr-&gt;y1_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;y2_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;y2_ac_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;uv_dc_delta_q = bool_maybe_get_int(bool, 4));
       update |= (hdr-&gt;uv_ac_delta_q = bool_maybe_get_int(bool, 4));
       hdr-&gt;delta_update = update;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void decode_and_init_token_partitions(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, const unsigned char *data, unsigned int sz, struct vp8_token_hdr *hdr)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态void decode_和_init_token_分区（struct vp8_decoder_ctx*ctx，struct bool_decoder*bool，const unsigned char*data，unsigned int sz，struct vp8_token_hdr*hdr）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;partitions = 1 &lt;&lt; bool_get_uint(bool, 2);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;partitions = 1 &lt;&lt; bool_get_uint(bool, 2);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (sz &lt; 3 *(hdr-&gt;partitions - 1))
           vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_CORRUPT_FRAME,
                              &#34;Truncated packet found parsing partition&#34;
                              &#34; lengths.&#34;);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (sz &lt; 3 *(hdr-&gt;partitions - 1))
           vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_CORRUPT_FRAME,
                              &#34;Truncated packet found parsing partition&#34;
                              &#34; lengths.&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sz -= 3 * (hdr-&gt;partitions - 1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sz -= 3 * (hdr-&gt;partitions - 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; hdr-&gt;partitions; i++)
       {
           if (i &lt; hdr-&gt;partitions - 1)
           {
               hdr-&gt;partition_sz[i] = (data[2] &lt;&lt; 16)
                                      | (data[1] &lt;&lt; 8) | data[0];
               data += 3;
           }
           else
               hdr-&gt;partition_sz[i] = sz;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; hdr-&gt;partitions; i++)
       {
           if (i &lt; hdr-&gt;partitions - 1)
           {
               hdr-&gt;partition_sz[i] = (data[2] &lt;&lt; 16)
                                      | (data[1] &lt;&lt; 8) | data[0];
               data += 3;
           }
           else
               hdr-&gt;partition_sz[i] = sz;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (sz &lt; hdr-&gt;partition_sz[i])
               vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_CORRUPT_FRAME,
                                  &#34;Truncated partition %d&#34;, i);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (sz &lt; hdr-&gt;partition_sz[i])
               vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_CORRUPT_FRAME,
                                  &#34;Truncated partition %d&#34;, i);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           sz -= hdr-&gt;partition_sz[i];
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           sz -= hdr-&gt;partition_sz[i];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; ctx-&gt;token_hdr.partitions; i++)
       {
           init_bool_decoder(&amp;ctx-&gt;tokens[i].bool, data,
                             ctx-&gt;token_hdr.partition_sz[i]);
           data += ctx-&gt;token_hdr.partition_sz[i];
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; ctx-&gt;token_hdr.partitions; i++)
       {
           init_bool_decoder(&amp;ctx-&gt;tokens[i].bool, data,
                             ctx-&gt;token_hdr.partition_sz[i]);
           data += ctx-&gt;token_hdr.partition_sz[i];
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void decode_loopfilter_header(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, struct vp8_loopfilter_hdr *hdr)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态无效解码\u loopfilter\u头（结构vp8\u解码器\u ctx*ctx，结构bool\u解码器*bool，结构vp8\u loopfilter\u hdr*hdr）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       if (ctx-&gt;frame_hdr.is_keyframe)
           memset(hdr, 0, sizeof(*hdr));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       if (ctx-&gt;frame_hdr.is_keyframe)
           memset(hdr, 0, sizeof(*hdr));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;use_simple    = bool_get_bit(bool);
       hdr-&gt;level         = bool_get_uint(bool, 6);
       hdr-&gt;sharpness     = bool_get_uint(bool, 3);
       hdr-&gt;delta_enabled = bool_get_bit(bool);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;use_simple    = bool_get_bit(bool);
       hdr-&gt;level         = bool_get_uint(bool, 6);
       hdr-&gt;sharpness     = bool_get_uint(bool, 3);
       hdr-&gt;delta_enabled = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;delta_enabled &amp;&amp; bool_get_bit(bool))
       {
           int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;delta_enabled &amp;&amp; bool_get_bit(bool))
       {
           int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; BLOCK_CONTEXTS; i++)
               hdr-&gt;ref_delta[i] = bool_maybe_get_int(bool, 6);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; BLOCK_CONTEXTS; i++)
               hdr-&gt;ref_delta[i] = bool_maybe_get_int(bool, 6);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; BLOCK_CONTEXTS; i++)
               hdr-&gt;mode_delta[i] = bool_maybe_get_int(bool, 6);
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; BLOCK_CONTEXTS; i++)
               hdr-&gt;mode_delta[i] = bool_maybe_get_int(bool, 6);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_segmentation_header(struct vp8_decoder_ctx *ctx,
                              struct bool_decoder    *bool,
                              struct vp8_segment_hdr *hdr)
   {
       if (ctx-&gt;frame_hdr.is_keyframe)
           memset(hdr, 0, sizeof(*hdr));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_segmentation_header(struct vp8_decoder_ctx *ctx,
                              struct bool_decoder    *bool,
                              struct vp8_segment_hdr *hdr)
   {
       if (ctx-&gt;frame_hdr.is_keyframe)
           memset(hdr, 0, sizeof(*hdr));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;enabled = bool_get_bit(bool);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;enabled = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;enabled)
       {
           int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;enabled)
       {
           int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           hdr-&gt;update_map = bool_get_bit(bool);
           hdr-&gt;update_data = bool_get_bit(bool);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           hdr-&gt;update_map = bool_get_bit(bool);
           hdr-&gt;update_data = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (hdr-&gt;update_data)
           {
               hdr-&gt;abs = bool_get_bit(bool);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (hdr-&gt;update_data)
           {
               hdr-&gt;abs = bool_get_bit(bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               for (i = 0; i &lt; MAX_MB_SEGMENTS; i++)
                   hdr-&gt;quant_idx[i] = bool_maybe_get_int(bool, 7);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               for (i = 0; i &lt; MAX_MB_SEGMENTS; i++)
                   hdr-&gt;quant_idx[i] = bool_maybe_get_int(bool, 7);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               for (i = 0; i &lt; MAX_MB_SEGMENTS; i++)
                   hdr-&gt;lf_level[i] = bool_maybe_get_int(bool, 6);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               for (i = 0; i &lt; MAX_MB_SEGMENTS; i++)
                   hdr-&gt;lf_level[i] = bool_maybe_get_int(bool, 6);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (hdr-&gt;update_map)
           {
               for (i = 0; i &lt; MB_FEATURE_TREE_PROBS; i++)
                   hdr-&gt;tree_probs[i] = bool_get_bit(bool)
                                        ? bool_get_uint(bool, 8)
                                        : 255;
           }
       }
       else
       {
           hdr-&gt;update_map = 0;
           hdr-&gt;update_data = 0;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (hdr-&gt;update_map)
           {
               for (i = 0; i &lt; MB_FEATURE_TREE_PROBS; i++)
                   hdr-&gt;tree_probs[i] = bool_get_bit(bool)
                                        ? bool_get_uint(bool, 8)
                                        : 255;
           }
       }
       else
       {
           hdr-&gt;update_map = 0;
           hdr-&gt;update_data = 0;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   dequant_global_init(struct dequant_factors dqf[MAX_MB_SEGMENTS])
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   dequant_global_init(struct dequant_factors dqf[MAX_MB_SEGMENTS])
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; MAX_MB_SEGMENTS; i++)
           dqf[i].quant_idx = -1;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; MAX_MB_SEGMENTS; i++)
           dqf[i].quant_idx = -1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   clamp_q(int q)
   {
       if (q &lt; 0) return 0;
       else if (q &gt; 127) return 127;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   clamp_q(int q)
   {
       if (q &lt; 0) return 0;
       else if (q &gt; 127) return 127;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return q;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return q;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   dc_q(int q)
   {
       return dc_q_lookup[clamp_q(q)];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   dc_q(int q)
   {
       return dc_q_lookup[clamp_q(q)];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   ac_q(int q)
   {
       return ac_q_lookup[clamp_q(q)];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   ac_q(int q)
   {
       return ac_q_lookup[clamp_q(q)];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   dequant_init(struct dequant_factors        factors[MAX_MB_SEGMENTS],
                const struct vp8_segment_hdr *seg,
                const struct vp8_quant_hdr   *quant_hdr)
   {
       int i, q;
       struct dequant_factors *dqf = factors;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   dequant_init(struct dequant_factors        factors[MAX_MB_SEGMENTS],
                const struct vp8_segment_hdr *seg,
                const struct vp8_quant_hdr   *quant_hdr)
   {
       int i, q;
       struct dequant_factors *dqf = factors;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; (seg-&gt;enabled ? MAX_MB_SEGMENTS : 1); i++)
       {
           q = quant_hdr-&gt;q_index;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; (seg-&gt;enabled ? MAX_MB_SEGMENTS : 1); i++)
       {
           q = quant_hdr-&gt;q_index;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (seg-&gt;enabled)
               q = (!seg-&gt;abs) ? q + seg-&gt;quant_idx[i]
                               : seg-&gt;quant_idx[i];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (seg-&gt;enabled)
               q = (!seg-&gt;abs) ? q + seg-&gt;quant_idx[i]
                               : seg-&gt;quant_idx[i];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (dqf-&gt;quant_idx != q || quant_hdr-&gt;delta_update)
           {
               dqf-&gt;factor[TOKEN_BLOCK_Y1][0] =
                   dc_q(q + quant_hdr-&gt;y1_dc_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_Y1][1] =
                   ac_q(q);
               dqf-&gt;factor[TOKEN_BLOCK_UV][0] =
                   dc_q(q + quant_hdr-&gt;uv_dc_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_UV][1] =
                   ac_q(q + quant_hdr-&gt;uv_ac_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_Y2][0] =
                   dc_q(q + quant_hdr-&gt;y2_dc_delta_q) * 2;
               dqf-&gt;factor[TOKEN_BLOCK_Y2][1] =
                   ac_q(q + quant_hdr-&gt;y2_ac_delta_q) * 155 / 100;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (dqf-&gt;quant_idx != q || quant_hdr-&gt;delta_update)
           {
               dqf-&gt;factor[TOKEN_BLOCK_Y1][0] =
                   dc_q(q + quant_hdr-&gt;y1_dc_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_Y1][1] =
                   ac_q(q);
               dqf-&gt;factor[TOKEN_BLOCK_UV][0] =
                   dc_q(q + quant_hdr-&gt;uv_dc_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_UV][1] =
                   ac_q(q + quant_hdr-&gt;uv_ac_delta_q);
               dqf-&gt;factor[TOKEN_BLOCK_Y2][0] =
                   dc_q(q + quant_hdr-&gt;y2_dc_delta_q) * 2;
               dqf-&gt;factor[TOKEN_BLOCK_Y2][1] =
                   ac_q(q + quant_hdr-&gt;y2_ac_delta_q) * 155 / 100;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (dqf-&gt;factor[TOKEN_BLOCK_Y2][1] &lt; 8)
                   dqf-&gt;factor[TOKEN_BLOCK_Y2][1] = 8;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (dqf-&gt;factor[TOKEN_BLOCK_Y2][1] &lt; 8)
                   dqf-&gt;factor[TOKEN_BLOCK_Y2][1] = 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (dqf-&gt;factor[TOKEN_BLOCK_UV][0] &gt; 132)
                   dqf-&gt;factor[TOKEN_BLOCK_UV][0] = 132;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (dqf-&gt;factor[TOKEN_BLOCK_UV][0] &gt; 132)
                   dqf-&gt;factor[TOKEN_BLOCK_UV][0] = 132;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               dqf-&gt;quant_idx = q;
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               dqf-&gt;quant_idx = q;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           dqf++;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           dqf++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_frame(struct vp8_decoder_ctx *ctx,
                const unsigned char    *data,
                unsigned int            sz)
   {
       vpx_codec_err_t  res;
       struct bool_decoder  bool;
       int                  i, row, partition;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_frame(struct vp8_decoder_ctx *ctx,
                const unsigned char    *data,
                unsigned int            sz)
   {
       vpx_codec_err_t  res;
       struct bool_decoder  bool;
       int                  i, row, partition;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;saved_entropy_valid = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;saved_entropy_valid = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if ((res = vp8_parse_frame_header(data, sz, &amp;ctx-&gt;frame_hdr)))
           vpx_internal_error(&amp;ctx-&gt;error, res,
                              &#34;Failed to parse frame header&#34;);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if ((res = vp8_parse_frame_header(data, sz, &amp;ctx-&gt;frame_hdr)))
           vpx_internal_error(&amp;ctx-&gt;error, res,
                              &#34;Failed to parse frame header&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (ctx-&gt;frame_hdr.is_experimental) vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_UNSUP_BITSTREAM, &#34;Experimental bitstreams not supported.&#34;);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（ctx-&gt;frame_hdr.是实验性的）vpx_内部错误（&amp;ctx-&gt;错误，vpx_编解码器_UNSUP_比特流，“不支持实验性比特流”）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       data += FRAME_HEADER_SZ;
       sz -= FRAME_HEADER_SZ;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       data += FRAME_HEADER_SZ;
       sz -= FRAME_HEADER_SZ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.is_keyframe)
       {
           data += KEYFRAME_HEADER_SZ;
           sz -= KEYFRAME_HEADER_SZ;
           ctx-&gt;mb_cols = (ctx-&gt;frame_hdr.kf.w + 15) / 16;
           ctx-&gt;mb_rows = (ctx-&gt;frame_hdr.kf.h + 15) / 16;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.is_keyframe)
       {
           data += KEYFRAME_HEADER_SZ;
           sz -= KEYFRAME_HEADER_SZ;
           ctx-&gt;mb_cols = (ctx-&gt;frame_hdr.kf.w + 15) / 16;
           ctx-&gt;mb_rows = (ctx-&gt;frame_hdr.kf.h + 15) / 16;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Start the bitreader for the header/entropy partition */
       init_bool_decoder(&amp;bool, data, ctx-&gt;frame_hdr.part0_sz);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Start the bitreader for the header/entropy partition */
       init_bool_decoder(&amp;bool, data, ctx-&gt;frame_hdr.part0_sz);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Skip the colorspace and clamping bits */
       if (ctx-&gt;frame_hdr.is_keyframe)
           if (bool_get_uint(&amp;bool, 2))
               vpx_internal_error(
                   &amp;ctx-&gt;error, VPX_CODEC_UNSUP_BITSTREAM,
                   &#34;Reserved bits not supported.&#34;);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Skip the colorspace and clamping bits */
       if (ctx-&gt;frame_hdr.is_keyframe)
           if (bool_get_uint(&amp;bool, 2))
               vpx_internal_error(
                   &amp;ctx-&gt;error, VPX_CODEC_UNSUP_BITSTREAM,
                   &#34;Reserved bits not supported.&#34;);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       decode_segmentation_header(ctx, &amp;bool, &amp;ctx-&gt;segment_hdr);
       decode_loopfilter_header(ctx, &amp;bool, &amp;ctx-&gt;loopfilter_hdr);
       decode_and_init_token_partitions(ctx,
                                        &amp;bool,
                                        data + ctx-&gt;frame_hdr.part0_sz,
                                        sz - ctx-&gt;frame_hdr.part0_sz,
                                        &amp;ctx-&gt;token_hdr);
       decode_quantizer_header(ctx, &amp;bool, &amp;ctx-&gt;quant_hdr);
       decode_reference_header(ctx, &amp;bool, &amp;ctx-&gt;reference_hdr);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       decode_segmentation_header(ctx, &amp;bool, &amp;ctx-&gt;segment_hdr);
       decode_loopfilter_header(ctx, &amp;bool, &amp;ctx-&gt;loopfilter_hdr);
       decode_and_init_token_partitions(ctx,
                                        &amp;bool,
                                        data + ctx-&gt;frame_hdr.part0_sz,
                                        sz - ctx-&gt;frame_hdr.part0_sz,
                                        &amp;ctx-&gt;token_hdr);
       decode_quantizer_header(ctx, &amp;bool, &amp;ctx-&gt;quant_hdr);
       decode_reference_header(ctx, &amp;bool, &amp;ctx-&gt;reference_hdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set keyframe entropy defaults.  These get updated on keyframes
        * regardless of the refresh_entropy setting.
        */
       if (ctx-&gt;frame_hdr.is_keyframe)
       {
           ARRAY_COPY(ctx-&gt;entropy_hdr.coeff_probs,
                      k_default_coeff_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.mv_probs,
                      k_default_mv_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.y_mode_probs,
                      k_default_y_mode_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.uv_mode_probs,
                      k_default_uv_mode_probs);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set keyframe entropy defaults.  These get updated on keyframes
        * regardless of the refresh_entropy setting.
        */
       if (ctx-&gt;frame_hdr.is_keyframe)
       {
           ARRAY_COPY(ctx-&gt;entropy_hdr.coeff_probs,
                      k_default_coeff_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.mv_probs,
                      k_default_mv_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.y_mode_probs,
                      k_default_y_mode_probs);
           ARRAY_COPY(ctx-&gt;entropy_hdr.uv_mode_probs,
                      k_default_uv_mode_probs);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!ctx-&gt;reference_hdr.refresh_entropy)
       {
           ctx-&gt;saved_entropy = ctx-&gt;entropy_hdr;
           ctx-&gt;saved_entropy_valid = 1;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!ctx-&gt;reference_hdr.refresh_entropy)
       {
           ctx-&gt;saved_entropy = ctx-&gt;entropy_hdr;
           ctx-&gt;saved_entropy_valid = 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       decode_entropy_header(ctx, &amp;bool, &amp;ctx-&gt;entropy_hdr);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       decode_entropy_header(ctx, &amp;bool, &amp;ctx-&gt;entropy_hdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       vp8_dixie_modemv_init(ctx);
       vp8_dixie_tokens_init(ctx);
       vp8_dixie_predict_init(ctx);
       dequant_init(ctx-&gt;dequant_factors, &amp;ctx-&gt;segment_hdr,
                    &amp;ctx-&gt;quant_hdr);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       vp8_dixie_modemv_init(ctx);
       vp8_dixie_tokens_init(ctx);
       vp8_dixie_predict_init(ctx);
       dequant_init(ctx-&gt;dequant_factors, &amp;ctx-&gt;segment_hdr,
                    &amp;ctx-&gt;quant_hdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (row = 0, partition = 0; row &lt; ctx-&gt;mb_rows; row++)
       {
           vp8_dixie_modemv_process_row(
               ctx, &amp;bool, row, 0, ctx-&gt;mb_cols);
           vp8_dixie_tokens_process_row(ctx, partition, row, 0,
                                        ctx-&gt;mb_cols);
           vp8_dixie_predict_process_row(ctx, row, 0, ctx-&gt;mb_cols);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (row = 0, partition = 0; row &lt; ctx-&gt;mb_rows; row++)
       {
           vp8_dixie_modemv_process_row(
               ctx, &amp;bool, row, 0, ctx-&gt;mb_cols);
           vp8_dixie_tokens_process_row(ctx, partition, row, 0,
                                        ctx-&gt;mb_cols);
           vp8_dixie_predict_process_row(ctx, row, 0, ctx-&gt;mb_cols);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;loopfilter_hdr.level &amp;&amp; row)
               vp8_dixie_loopfilter_process_row(ctx, row - 1, 0,
                                                ctx-&gt;mb_cols);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;loopfilter_hdr.level &amp;&amp; row)
               vp8_dixie_loopfilter_process_row(ctx, row - 1, 0,
                                                ctx-&gt;mb_cols);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (++partition == ctx-&gt;token_hdr.partitions)
               partition = 0;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (++partition == ctx-&gt;token_hdr.partitions)
               partition = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;loopfilter_hdr.level)
           vp8_dixie_loopfilter_process_row(
               ctx, row - 1, 0, ctx-&gt;mb_cols);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;loopfilter_hdr.level)
           vp8_dixie_loopfilter_process_row(
               ctx, row - 1, 0, ctx-&gt;mb_cols);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;frame_cnt++;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;frame_cnt++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!ctx-&gt;reference_hdr.refresh_entropy)
       {
           ctx-&gt;entropy_hdr = ctx-&gt;saved_entropy;
           ctx-&gt;saved_entropy_valid = 0;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!ctx-&gt;reference_hdr.refresh_entropy)
       {
           ctx-&gt;entropy_hdr = ctx-&gt;saved_entropy;
           ctx-&gt;saved_entropy_valid = 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Handle reference frame updates */
       if (ctx-&gt;reference_hdr.copy_arf == 1)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
       }
       else if (ctx-&gt;reference_hdr.copy_arf == 2)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Handle reference frame updates */
       if (ctx-&gt;reference_hdr.copy_arf == 1)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
       }
       else if (ctx-&gt;reference_hdr.copy_arf == 2)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.copy_gf == 1)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.copy_gf == 1)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       else if (ctx-&gt;reference_hdr.copy_gf == 2)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       else if (ctx-&gt;reference_hdr.copy_gf == 2)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_gf)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_gf)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[GOLDEN_FRAME]);
           ctx-&gt;ref_frames[GOLDEN_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_arf)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_arf)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[ALTREF_FRAME]);
           ctx-&gt;ref_frames[ALTREF_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_last)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
           ctx-&gt;ref_frames[LAST_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;reference_hdr.refresh_last)
       {
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[LAST_FRAME]);
           ctx-&gt;ref_frames[LAST_FRAME] =
               vp8_dixie_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_decode_init(struct vp8_decoder_ctx *ctx)
   {
       dequant_global_init(ctx-&gt;dequant_factors);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_decode_init(struct vp8_decoder_ctx *ctx)
   {
       dequant_global_init(ctx-&gt;dequant_factors);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define CHECK_FOR_UPDATE(lval,rval,update_flag) do {\
           unsigned int old = lval; \
           update_flag |= (old != (lval = rval)); \
       } while (0)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define CHECK_FOR_UPDATE(lval,rval,update_flag) do {\
           unsigned int old = lval; \
           update_flag |= (old != (lval = rval)); \
       } while (0)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_codec_err_t
   vp8_parse_frame_header(const unsigned char   *data,
                          unsigned int           sz,
                          struct vp8_frame_hdr  *hdr)
   {
       unsigned long raw;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_codec_err_t
   vp8_parse_frame_header(const unsigned char   *data,
                          unsigned int           sz,
                          struct vp8_frame_hdr  *hdr)
   {
       unsigned long raw;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (sz &lt; 10) return VPX_CODEC_CORRUPT_FRAME;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（sz&lt;10）返回VPX_编解码器_损坏_帧；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The frame header is defined as a three-byte little endian
        * value
        */
       raw = data[0] | (data[1] &lt;&lt; 8) | (data[2] &lt;&lt; 16);
       hdr-&gt;is_keyframe     = !BITS_GET(raw, 0, 1);
       hdr-&gt;version         = BITS_GET(raw, 1, 2);
       hdr-&gt;is_experimental = BITS_GET(raw, 3, 1);
       hdr-&gt;is_shown        = BITS_GET(raw, 4, 1);
       hdr-&gt;part0_sz        = BITS_GET(raw, 5, 19);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The frame header is defined as a three-byte little endian
        * value
        */
       raw = data[0] | (data[1] &lt;&lt; 8) | (data[2] &lt;&lt; 16);
       hdr-&gt;is_keyframe     = !BITS_GET(raw, 0, 1);
       hdr-&gt;version         = BITS_GET(raw, 1, 2);
       hdr-&gt;is_experimental = BITS_GET(raw, 3, 1);
       hdr-&gt;is_shown        = BITS_GET(raw, 4, 1);
       hdr-&gt;part0_sz        = BITS_GET(raw, 5, 19);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (sz &lt;= hdr-&gt;part0_sz + (hdr-&gt;is_keyframe ? 10 : 3))
           return VPX_CODEC_CORRUPT_FRAME;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (sz &lt;= hdr-&gt;part0_sz + (hdr-&gt;is_keyframe ? 10 : 3))
           return VPX_CODEC_CORRUPT_FRAME;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;frame_size_updated = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hdr-&gt;frame_size_updated = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;is_keyframe)
       {
           unsigned int update = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (hdr-&gt;is_keyframe)
       {
           unsigned int update = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Keyframe header consists of a three-byte sync code
            * followed by the width and height and associated scaling
            * factors.
            */
           if (data[3] != 0x9d || data[4] != 0x01 || data[5] != 0x2a)
               return VPX_CODEC_UNSUP_BITSTREAM;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Keyframe header consists of a three-byte sync code
            * followed by the width and height and associated scaling
            * factors.
            */
           if (data[3] != 0x9d || data[4] != 0x01 || data[5] != 0x2a)
               return VPX_CODEC_UNSUP_BITSTREAM;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           raw = data[6] | (data[7] &lt;&lt; 8)
                 | (data[8] &lt;&lt; 16) | (data[9] &lt;&lt; 24);
           CHECK_FOR_UPDATE(hdr-&gt;kf.w,       BITS_GET(raw,  0, 14),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.scale_w, BITS_GET(raw, 14,  2),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.h,       BITS_GET(raw, 16, 14),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.scale_h, BITS_GET(raw, 30,  2),
                            update);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           raw = data[6] | (data[7] &lt;&lt; 8)
                 | (data[8] &lt;&lt; 16) | (data[9] &lt;&lt; 24);
           CHECK_FOR_UPDATE(hdr-&gt;kf.w,       BITS_GET(raw,  0, 14),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.scale_w, BITS_GET(raw, 14,  2),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.h,       BITS_GET(raw, 16, 14),
                            update);
           CHECK_FOR_UPDATE(hdr-&gt;kf.scale_h, BITS_GET(raw, 30,  2),
                            update);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           hdr-&gt;frame_size_updated = update;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           hdr-&gt;frame_size_updated = update;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!hdr-&gt;kf.w || !hdr-&gt;kf.h)
               return VPX_CODEC_UNSUP_BITSTREAM;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!hdr-&gt;kf.w || !hdr-&gt;kf.h)
               return VPX_CODEC_UNSUP_BITSTREAM;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return VPX_CODEC_OK;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return VPX_CODEC_OK;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_codec_err_t
   vp8_dixie_decode_frame(struct vp8_decoder_ctx *ctx,
                          const unsigned char    *data,
                          unsigned int            sz)
   {
       volatile struct vp8_decoder_ctx *ctx_ = ctx;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_codec_err_t
   vp8_dixie_decode_frame(struct vp8_decoder_ctx *ctx,
                          const unsigned char    *data,
                          unsigned int            sz)
   {
       volatile struct vp8_decoder_ctx *ctx_ = ctx;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;error.error_code = VPX_CODEC_OK;
       ctx-&gt;error.has_detail = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;error.error_code = VPX_CODEC_OK;
       ctx-&gt;error.has_detail = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!setjmp(ctx-&gt;error.jmp))
           decode_frame(ctx, data, sz);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!setjmp(ctx-&gt;error.jmp))
           decode_frame(ctx, data, sz);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return ctx_-&gt;error.error_code;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return ctx_-&gt;error.error_code;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_decode_destroy(struct vp8_decoder_ctx *ctx)
   {
       vp8_dixie_predict_destroy(ctx);
       vp8_dixie_tokens_destroy(ctx);
       vp8_dixie_modemv_destroy(ctx);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_decode_destroy(struct vp8_decoder_ctx *ctx)
   {
       vp8_dixie_predict_destroy(ctx);
       vp8_dixie_tokens_destroy(ctx);
       vp8_dixie_modemv_destroy(ctx);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5. dixie.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.5. 迪克西
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef DIXIE_H
   #define DIXIE_H
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;bool_decoder.h&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef DIXIE_H
   #define DIXIE_H
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;bool_decoder.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_frame_hdr
   {
       unsigned int is_keyframe;      /* Frame is a keyframe */
       unsigned int is_experimental;  /* Frame is a keyframe */
       unsigned int version;          /* Bitstream version */
       unsigned int is_shown;         /* Frame is to be displayed. */
       unsigned int part0_sz;         /* Partition 0 length, in bytes */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_frame_hdr
   {
       unsigned int is_keyframe;      /* Frame is a keyframe */
       unsigned int is_experimental;  /* Frame is a keyframe */
       unsigned int version;          /* Bitstream version */
       unsigned int is_shown;         /* Frame is to be displayed. */
       unsigned int part0_sz;         /* Partition 0 length, in bytes */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct vp8_kf_hdr
       {
           unsigned int w;        /* Width */
           unsigned int h;        /* Height */
           unsigned int scale_w;  /* Scaling factor, Width */
           unsigned int scale_h;  /* Scaling factor, Height */
       } kf;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct vp8_kf_hdr
       {
           unsigned int w;        /* Width */
           unsigned int h;        /* Height */
           unsigned int scale_w;  /* Scaling factor, Width */
           unsigned int scale_h;  /* Scaling factor, Height */
       } kf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int frame_size_updated; /* Flag to indicate a resolution
                                         * update.
                                         */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int frame_size_updated; /* Flag to indicate a resolution
                                         * update.
                                         */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       MB_FEATURE_TREE_PROBS = 3,
       MAX_MB_SEGMENTS = 4
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       MB_FEATURE_TREE_PROBS = 3,
       MAX_MB_SEGMENTS = 4
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_segment_hdr
   {
       unsigned int         enabled;
       unsigned int         update_data;
       unsigned int         update_map;
       unsigned int         abs;    /* 0=deltas, 1=absolute values */
       unsigned int         tree_probs[MB_FEATURE_TREE_PROBS];
       int                  lf_level[MAX_MB_SEGMENTS];
       int                  quant_idx[MAX_MB_SEGMENTS];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_segment_hdr
   {
       unsigned int         enabled;
       unsigned int         update_data;
       unsigned int         update_map;
       unsigned int         abs;    /* 0=deltas, 1=absolute values */
       unsigned int         tree_probs[MB_FEATURE_TREE_PROBS];
       int                  lf_level[MAX_MB_SEGMENTS];
       int                  quant_idx[MAX_MB_SEGMENTS];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       BLOCK_CONTEXTS = 4
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       BLOCK_CONTEXTS = 4
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_loopfilter_hdr
   {
       unsigned int         use_simple;
       unsigned int         level;
       unsigned int         sharpness;
       unsigned int         delta_enabled;
       int                  ref_delta[BLOCK_CONTEXTS];
       int                  mode_delta[BLOCK_CONTEXTS];
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_loopfilter_hdr
   {
       unsigned int         use_simple;
       unsigned int         level;
       unsigned int         sharpness;
       unsigned int         delta_enabled;
       int                  ref_delta[BLOCK_CONTEXTS];
       int                  mode_delta[BLOCK_CONTEXTS];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       MAX_PARTITIONS = 8
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       MAX_PARTITIONS = 8
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_token_hdr
   {
       unsigned int        partitions;
       unsigned int        partition_sz[MAX_PARTITIONS];
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_token_hdr
   {
       unsigned int        partitions;
       unsigned int        partition_sz[MAX_PARTITIONS];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_quant_hdr
   {
       unsigned int       q_index;
       int                delta_update;
       int                y1_dc_delta_q;
       int                y2_dc_delta_q;
       int                y2_ac_delta_q;
       int                uv_dc_delta_q;
       int                uv_ac_delta_q;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_quant_hdr
   {
       unsigned int       q_index;
       int                delta_update;
       int                y1_dc_delta_q;
       int                y2_dc_delta_q;
       int                y2_ac_delta_q;
       int                uv_dc_delta_q;
       int                uv_ac_delta_q;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_reference_hdr
   {
       unsigned int refresh_last;
       unsigned int refresh_gf;
       unsigned int refresh_arf;
       unsigned int copy_gf;
       unsigned int copy_arf;
       unsigned int sign_bias[4];
       unsigned int refresh_entropy;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_reference_hdr
   {
       unsigned int refresh_last;
       unsigned int refresh_gf;
       unsigned int refresh_arf;
       unsigned int copy_gf;
       unsigned int copy_arf;
       unsigned int sign_bias[4];
       unsigned int refresh_entropy;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       BLOCK_TYPES        = 4,
       PREV_COEFF_CONTEXTS = 3,
       COEFF_BANDS         = 8,
       ENTROPY_NODES      = 11,
   };
   typedef unsigned char coeff_probs_table_t[BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS]
   [ENTROPY_NODES];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       BLOCK_TYPES        = 4,
       PREV_COEFF_CONTEXTS = 3,
       COEFF_BANDS         = 8,
       ENTROPY_NODES      = 11,
   };
   typedef unsigned char coeff_probs_table_t[BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS]
   [ENTROPY_NODES];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       MV_PROB_CNT = 2 + 8 - 1 + 10 /* from entropymv.h */
   };
   typedef unsigned char mv_component_probs_t[MV_PROB_CNT];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       MV_PROB_CNT = 2 + 8 - 1 + 10 /* from entropymv.h */
   };
   typedef unsigned char mv_component_probs_t[MV_PROB_CNT];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_entropy_hdr
   {
       coeff_probs_table_t   coeff_probs;
       mv_component_probs_t  mv_probs[2];
       unsigned int          coeff_skip_enabled;
       unsigned char         coeff_skip_prob;
       unsigned char         y_mode_probs[4];
       unsigned char         uv_mode_probs[3];
       unsigned char         prob_inter;
       unsigned char         prob_last;
       unsigned char         prob_gf;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_entropy_hdr
   {
       coeff_probs_table_t   coeff_probs;
       mv_component_probs_t  mv_probs[2];
       unsigned int          coeff_skip_enabled;
       unsigned char         coeff_skip_prob;
       unsigned char         y_mode_probs[4];
       unsigned char         uv_mode_probs[3];
       unsigned char         prob_inter;
       unsigned char         prob_last;
       unsigned char         prob_gf;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum reference_frame
   {
       CURRENT_FRAME,
       LAST_FRAME,
       GOLDEN_FRAME,
       ALTREF_FRAME,
       NUM_REF_FRAMES
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum reference_frame
   {
       CURRENT_FRAME,
       LAST_FRAME,
       GOLDEN_FRAME,
       ALTREF_FRAME,
       NUM_REF_FRAMES
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum prediction_mode
   {
       /* 16x16 intra modes */
       DC_PRED, V_PRED, H_PRED, TM_PRED, B_PRED,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum prediction_mode
   {
       /* 16x16 intra modes */
       DC_PRED, V_PRED, H_PRED, TM_PRED, B_PRED,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* 16x16 inter modes */
       NEARESTMV, NEARMV, ZEROMV, NEWMV, SPLITMV,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* 16x16 inter modes */
       NEARESTMV, NEARMV, ZEROMV, NEWMV, SPLITMV,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
MB_MODE_COUNT,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
MB_模式_计数，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* 4x4 intra modes */
       B_DC_PRED = 0, B_TM_PRED, B_VE_PRED, B_HE_PRED, B_LD_PRED,
       B_RD_PRED, B_VR_PRED, B_VL_PRED, B_HD_PRED, B_HU_PRED,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* 4x4 intra modes */
       B_DC_PRED = 0, B_TM_PRED, B_VE_PRED, B_HE_PRED, B_LD_PRED,
       B_RD_PRED, B_VR_PRED, B_VL_PRED, B_HD_PRED, B_HU_PRED,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* 4x4 inter modes */
       LEFT4X4, ABOVE4X4, ZERO4X4, NEW4X4,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* 4x4 inter modes */
       LEFT4X4, ABOVE4X4, ZERO4X4, NEW4X4,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 B_MODE_COUNT };
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B_模式_计数}；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum splitmv_partitioning
   {
       SPLITMV_16X8,
       SPLITMV_8X16,
       SPLITMV_8X8,
       SPLITMV_4X4
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum splitmv_partitioning
   {
       SPLITMV_16X8,
       SPLITMV_8X16,
       SPLITMV_8X8,
       SPLITMV_4X4
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef short filter_t[6];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef短过滤器[6]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef union mv
   {
       struct
       {
           int16_t x, y;
       }  d;
       uint32_t               raw;
   } mv_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef union mv
   {
       struct
       {
           int16_t x, y;
       }  d;
       uint32_t               raw;
   } mv_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct mb_base_info
   {
       unsigned char y_mode     : 4;
       unsigned char uv_mode    : 4;
       unsigned char segment_id : 2;
       unsigned char ref_frame  : 2;
       unsigned char skip_coeff : 1;
       unsigned char need_mc_border : 1;
       enum splitmv_partitioning  partitioning : 2;
       union mv      mv;
       unsigned int  eob_mask;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct mb_base_info
   {
       unsigned char y_mode     : 4;
       unsigned char uv_mode    : 4;
       unsigned char segment_id : 2;
       unsigned char ref_frame  : 2;
       unsigned char skip_coeff : 1;
       unsigned char need_mc_border : 1;
       enum splitmv_partitioning  partitioning : 2;
       union mv      mv;
       unsigned int  eob_mask;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct mb_info
   {
       struct mb_base_info base;
       union
       {
           union mv              mvs[16];
           enum prediction_mode  modes[16];
       } split;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct mb_info
   {
       struct mb_base_info base;
       union
       {
           union mv              mvs[16];
           enum prediction_mode  modes[16];
       } split;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* A &#34;token entropy context&#34; has 4 Y values, 2 U, 2 V, and 1 Y2 */
   typedef int token_entropy_ctx_t[4 + 2 + 2 + 1];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* A &#34;token entropy context&#34; has 4 Y values, 2 U, 2 V, and 1 Y2 */
   typedef int token_entropy_ctx_t[4 + 2 + 2 + 1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct token_decoder
   {
       struct bool_decoder  bool;
       token_entropy_ctx_t  left_token_entropy_ctx;
       short               *coeffs;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct token_decoder
   {
       struct bool_decoder  bool;
       token_entropy_ctx_t  left_token_entropy_ctx;
       short               *coeffs;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum token_block_type
   {
       TOKEN_BLOCK_Y1,
       TOKEN_BLOCK_UV,
       TOKEN_BLOCK_Y2,
       TOKEN_BLOCK_TYPES,
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum token_block_type
   {
       TOKEN_BLOCK_Y1,
       TOKEN_BLOCK_UV,
       TOKEN_BLOCK_Y2,
       TOKEN_BLOCK_TYPES,
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct dequant_factors
   {
       int   quant_idx;
       short factor[TOKEN_BLOCK_TYPES][2]; /* [ Y1, UV, Y2 ]
                                            * [ DC, AC ] */
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct dequant_factors
   {
       int   quant_idx;
       short factor[TOKEN_BLOCK_TYPES][2]; /* [ Y1, UV, Y2 ]
                                            * [ DC, AC ] */
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img
   {
       vpx_image_t  img;
       unsigned int ref_cnt;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img
   {
       vpx_image_t  img;
       unsigned int ref_cnt;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_decoder_ctx
   {
       struct vpx_internal_error_info  error;
       unsigned int                    frame_cnt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct vp8_decoder_ctx
   {
       struct vpx_internal_error_info  error;
       unsigned int                    frame_cnt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct vp8_frame_hdr            frame_hdr;
       struct vp8_segment_hdr          segment_hdr;
       struct vp8_loopfilter_hdr       loopfilter_hdr;
       struct vp8_token_hdr            token_hdr;
       struct vp8_quant_hdr            quant_hdr;
       struct vp8_reference_hdr        reference_hdr;
       struct vp8_entropy_hdr          entropy_hdr;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct vp8_frame_hdr            frame_hdr;
       struct vp8_segment_hdr          segment_hdr;
       struct vp8_loopfilter_hdr       loopfilter_hdr;
       struct vp8_token_hdr            token_hdr;
       struct vp8_quant_hdr            quant_hdr;
       struct vp8_reference_hdr        reference_hdr;
       struct vp8_entropy_hdr          entropy_hdr;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct vp8_entropy_hdr          saved_entropy;
       unsigned int                    saved_entropy_valid;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct vp8_entropy_hdr          saved_entropy;
       unsigned int                    saved_entropy_valid;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int                    mb_rows;
       unsigned int                    mb_cols;
       struct mb_info                 *mb_info_storage;
       struct mb_info                **mb_info_rows_storage;
       struct mb_info                **mb_info_rows;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int                    mb_rows;
       unsigned int                    mb_cols;
       struct mb_info                 *mb_info_storage;
       struct mb_info                **mb_info_rows_storage;
       struct mb_info                **mb_info_rows;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       token_entropy_ctx_t            *above_token_entropy_ctx;
       struct token_decoder            tokens[MAX_PARTITIONS];
       struct dequant_factors          dequant_factors[MAX_MB_SEGMENTS];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       token_entropy_ctx_t            *above_token_entropy_ctx;
       struct token_decoder            tokens[MAX_PARTITIONS];
       struct dequant_factors          dequant_factors[MAX_MB_SEGMENTS];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct ref_cnt_img              frame_strg[NUM_REF_FRAMES];
       struct ref_cnt_img             *ref_frames[NUM_REF_FRAMES];
       ptrdiff_t                       ref_frame_offsets[4];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct ref_cnt_img              frame_strg[NUM_REF_FRAMES];
       struct ref_cnt_img             *ref_frames[NUM_REF_FRAMES];
       ptrdiff_t                       ref_frame_offsets[4];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       const filter_t                 *subpixel_filters;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       const filter_t                 *subpixel_filters;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_decode_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_decode_init（结构vp8_decoder_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_decode_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_decode_destroy（结构vp8_decoder_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_parse_frame_header(const unsigned char *data, unsigned int sz, struct vp8_frame_hdr *hdr);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_编解码器_err_t vp8_parse_frame_头（const unsigned char*data，unsigned int sz，struct vp8_frame_hdr*hdr）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_codec_err_t vp8_dixie_decode_frame(struct vp8_decoder_ctx *ctx, const unsigned char *data, unsigned int sz);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
vpx_编解码器_err_t vp8_dixie_解码_帧（结构vp8_解码器_ctx*ctx，常量无符号字符*数据，无符号整数sz）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define CLAMP_255(x) ((x)&lt;0?0:((x)&gt;255?255:(x)))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define CLAMP_255(x) ((x)&lt;0?0:((x)&gt;255?255:(x)))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6. dixie_loopfilter.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.6. dixie_loopfilter.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;dixie_loopfilter.h&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;dixie_loopfilter.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define ABS(x) ((x) &gt;= 0 ? (x) : -(x))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define ABS(x) ((x) &gt;= 0 ? (x) : -(x))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define p3 pixels[-4*stride]
   #define p2 pixels[-3*stride]
   #define p1 pixels[-2*stride]
   #define p0 pixels[-1*stride]
   #define q0 pixels[ 0*stride]
   #define q1 pixels[ 1*stride]
   #define q2 pixels[ 2*stride]
   #define q3 pixels[ 3*stride]
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define p3 pixels[-4*stride]
   #define p2 pixels[-3*stride]
   #define p1 pixels[-2*stride]
   #define p0 pixels[-1*stride]
   #define q0 pixels[ 0*stride]
   #define q1 pixels[ 1*stride]
   #define q2 pixels[ 2*stride]
   #define q3 pixels[ 3*stride]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define static static int
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#定义静态整型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   saturate_int8(int x)
   {
       if (x &lt; -128)
           return -128;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   saturate_int8(int x)
   {
       if (x &lt; -128)
           return -128;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (x &gt; 127) return 127;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（x&gt;127）返回127；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return x;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return x;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   saturate_uint8(int x)
   {
       if (x &lt; 0)
           return 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   saturate_uint8(int x)
   {
       if (x &lt; 0)
           return 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (x &gt; 255) return 255;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（x&gt;255），则返回255；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return x;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return x;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   high_edge_variance(unsigned char *pixels,
                      int            stride,
                      int            hev_threshold)
   {
       return ABS(p1 - p0) &gt; hev_threshold ||
              ABS(q1 - q0) &gt; hev_threshold;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   high_edge_variance(unsigned char *pixels,
                      int            stride,
                      int            hev_threshold)
   {
       return ABS(p1 - p0) &gt; hev_threshold ||
              ABS(q1 - q0) &gt; hev_threshold;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   simple_threshold(unsigned char *pixels,
                    int            stride,
                    int            filter_limit)
   {
       return (ABS(p0 - q0) * 2 + (ABS(p1 - q1) &gt;&gt; 1)) &lt;= filter_limit;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   simple_threshold(unsigned char *pixels,
                    int            stride,
                    int            filter_limit)
   {
       return (ABS(p0 - q0) * 2 + (ABS(p1 - q1) &gt;&gt; 1)) &lt;= filter_limit;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   normal_threshold(unsigned char *pixels,
                    int            stride,
                    int            edge_limit,
                    int            interior_limit)
   {
       int E = edge_limit;
       int I = interior_limit;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   normal_threshold(unsigned char *pixels,
                    int            stride,
                    int            edge_limit,
                    int            interior_limit)
   {
       int E = edge_limit;
       int I = interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return simple_threshold(pixels, stride, 2 * E + I)
              &amp;&amp; ABS(p3 - p2) &lt;= I &amp;&amp; ABS(p2 - p1) &lt;= I
              &amp;&amp; ABS(p1 - p0) &lt;= I &amp;&amp; ABS(q3 - q2) &lt;= I
              &amp;&amp; ABS(q2 - q1) &lt;= I &amp;&amp; ABS(q1 - q0) &lt;= I;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return simple_threshold(pixels, stride, 2 * E + I)
              &amp;&amp; ABS(p3 - p2) &lt;= I &amp;&amp; ABS(p2 - p1) &lt;= I
              &amp;&amp; ABS(p1 - p0) &lt;= I &amp;&amp; ABS(q3 - q2) &lt;= I
              &amp;&amp; ABS(q2 - q1) &lt;= I &amp;&amp; ABS(q1 - q0) &lt;= I;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_common(unsigned char *pixels,
                 int            stride,
                 int            use_outer_taps)
   {
       int a, f1, f2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_common(unsigned char *pixels,
                 int            stride,
                 int            use_outer_taps)
   {
       int a, f1, f2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = 3 * (q0 - p0);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = 3 * (q0 - p0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (use_outer_taps)
           a += saturate_int8(p1 - q1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (use_outer_taps)
           a += saturate_int8(p1 - q1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = saturate_int8(a);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = saturate_int8(a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       f1 = ((a + 4 &gt; 127) ? 127 : a + 4) &gt;&gt; 3;
       f2 = ((a + 3 &gt; 127) ? 127 : a + 3) &gt;&gt; 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       f1 = ((a + 4 &gt; 127) ? 127 : a + 4) &gt;&gt; 3;
       f2 = ((a + 3 &gt; 127) ? 127 : a + 3) &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       p0 = saturate_uint8(p0 + f2);
       q0 = saturate_uint8(q0 - f1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       p0 = saturate_uint8(p0 + f2);
       q0 = saturate_uint8(q0 - f1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!use_outer_taps)
       {
           /* This handles the case of subblock_filter()
            * (from the bitstream guide.
            */
           a = (f1 + 1) &gt;&gt; 1;
           p1 = saturate_uint8(p1 + a);
           q1 = saturate_uint8(q1 - a);
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!use_outer_taps)
       {
           /* This handles the case of subblock_filter()
            * (from the bitstream guide.
            */
           a = (f1 + 1) &gt;&gt; 1;
           p1 = saturate_uint8(p1 + a);
           q1 = saturate_uint8(q1 - a);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_mb_edge(unsigned char *pixels,
                  int            stride)
   {
       int w, a;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_mb_edge(unsigned char *pixels,
                  int            stride)
   {
       int w, a;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       w = saturate_int8(saturate_int8(p1 - q1) + 3 * (q0 - p0));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       w = saturate_int8(saturate_int8(p1 - q1) + 3 * (q0 - p0));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = (27 * w + 63) &gt;&gt; 7;
       p0 = saturate_uint8(p0 + a);
       q0 = saturate_uint8(q0 - a);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = (27 * w + 63) &gt;&gt; 7;
       p0 = saturate_uint8(p0 + a);
       q0 = saturate_uint8(q0 - a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = (18 * w + 63) &gt;&gt; 7;
       p1 = saturate_uint8(p1 + a);
       q1 = saturate_uint8(q1 - a);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = (18 * w + 63) &gt;&gt; 7;
       p1 = saturate_uint8(p1 + a);
       q1 = saturate_uint8(q1 - a);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = (9 * w + 63) &gt;&gt; 7;
       p2 = saturate_uint8(p2 + a);
       q2 = saturate_uint8(q2 - a);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       a = (9 * w + 63) &gt;&gt; 7;
       p2 = saturate_uint8(p2 + a);
       q2 = saturate_uint8(q2 - a);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_mb_v_edge(unsigned char *src,
                    int            stride,
                    int            edge_limit,
                    int            interior_limit,
                    int            hev_threshold,
                    int            size)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_mb_v_edge(unsigned char *src,
                    int            stride,
                    int            edge_limit,
                    int            interior_limit,
                    int            hev_threshold,
                    int            size)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, 1, edge_limit, interior_limit))
           {
               if (high_edge_variance(src, 1, hev_threshold))
                   filter_common(src, 1, 1);
               else
                   filter_mb_edge(src, 1);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, 1, edge_limit, interior_limit))
           {
               if (high_edge_variance(src, 1, hev_threshold))
                   filter_common(src, 1, 1);
               else
                   filter_mb_edge(src, 1);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += stride;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_subblock_v_edge(unsigned char *src,
                          int            stride,
                          int            edge_limit,
                          int            interior_limit,
                          int            hev_threshold,
                          int            size)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_subblock_v_edge(unsigned char *src,
                          int            stride,
                          int            edge_limit,
                          int            interior_limit,
                          int            hev_threshold,
                          int            size)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, 1, edge_limit, interior_limit))
               filter_common(src, 1,
                             high_edge_variance(src, 1, hev_threshold));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, 1, edge_limit, interior_limit))
               filter_common(src, 1,
                             high_edge_variance(src, 1, hev_threshold));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += stride;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_mb_h_edge(unsigned char *src,
                    int            stride,
                    int            edge_limit,
                    int            interior_limit,
                    int            hev_threshold,
                    int            size)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_mb_h_edge(unsigned char *src,
                    int            stride,
                    int            edge_limit,
                    int            interior_limit,
                    int            hev_threshold,
                    int            size)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, stride, edge_limit,
                                interior_limit))
           {
               if (high_edge_variance(src, stride, hev_threshold))
                   filter_common(src, stride, 1);
               else
                   filter_mb_edge(src, stride);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, stride, edge_limit,
                                interior_limit))
           {
               if (high_edge_variance(src, stride, hev_threshold))
                   filter_common(src, stride, 1);
               else
                   filter_mb_edge(src, stride);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += 1;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += 1;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_subblock_h_edge(unsigned char *src,
                          int            stride,
                          int            edge_limit,
                          int            interior_limit,
                          int            hev_threshold,
                          int            size)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_subblock_h_edge(unsigned char *src,
                          int            stride,
                          int            edge_limit,
                          int            interior_limit,
                          int            hev_threshold,
                          int            size)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, stride, edge_limit,
                                interior_limit))
               filter_common(src, stride,
                             high_edge_variance(src, stride,
                                                hev_threshold));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 8 * size; i++)
       {
           if (normal_threshold(src, stride, edge_limit,
                                interior_limit))
               filter_common(src, stride,
                             high_edge_variance(src, stride,
                                                hev_threshold));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += 1;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += 1;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_v_edge_simple(unsigned char *src,
                        int            stride,
                        int            filter_limit)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_v_edge_simple(unsigned char *src,
                        int            stride,
                        int            filter_limit)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           if (simple_threshold(src, 1, filter_limit))
               filter_common(src, 1, 1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           if (simple_threshold(src, 1, filter_limit))
               filter_common(src, 1, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += stride;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_h_edge_simple(unsigned char *src,
                        int            stride,
                        int            filter_limit)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_h_edge_simple(unsigned char *src,
                        int            stride,
                        int            filter_limit)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           if (simple_threshold(src, stride, filter_limit))
               filter_common(src, stride, 1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           if (simple_threshold(src, stride, filter_limit))
               filter_common(src, stride, 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += 1;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           src += 1;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   calculate_filter_parameters(struct vp8_decoder_ctx *ctx,
                               struct mb_info         *mbi,
                               int                    *edge_limit_,
                               int                    *interior_limit_,
                               int                    *hev_threshold_)
   {
       int filter_level, interior_limit, hev_threshold;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   calculate_filter_parameters(struct vp8_decoder_ctx *ctx,
                               struct mb_info         *mbi,
                               int                    *edge_limit_,
                               int                    *interior_limit_,
                               int                    *hev_threshold_)
   {
       int filter_level, interior_limit, hev_threshold;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Reference code/spec seems to conflate filter_level and
        * edge_limit
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Reference code/spec seems to conflate filter_level and
        * edge_limit
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       filter_level = ctx-&gt;loopfilter_hdr.level;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       filter_level = ctx-&gt;loopfilter_hdr.level;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;segment_hdr.enabled)
       {
           if (!ctx-&gt;segment_hdr.abs)
               filter_level +=
                   ctx-&gt;segment_hdr.lf_level[mbi-&gt;base.segment_id];
           else
               filter_level =
                   ctx-&gt;segment_hdr.lf_level[mbi-&gt;base.segment_id];
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;segment_hdr.enabled)
       {
           if (!ctx-&gt;segment_hdr.abs)
               filter_level +=
                   ctx-&gt;segment_hdr.lf_level[mbi-&gt;base.segment_id];
           else
               filter_level =
                   ctx-&gt;segment_hdr.lf_level[mbi-&gt;base.segment_id];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt; 63)
           filter_level = 63;
       else if (filter_level &lt; 0)
           filter_level = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt; 63)
           filter_level = 63;
       else if (filter_level &lt; 0)
           filter_level = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;loopfilter_hdr.delta_enabled)
       {
           filter_level +=
               ctx-&gt;loopfilter_hdr.ref_delta[mbi-&gt;base.ref_frame];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;loopfilter_hdr.delta_enabled)
       {
           filter_level +=
               ctx-&gt;loopfilter_hdr.ref_delta[mbi-&gt;base.ref_frame];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.ref_frame == CURRENT_FRAME)
           {
               if (mbi-&gt;base.y_mode == B_PRED)
                   filter_level += ctx-&gt;loopfilter_hdr.mode_delta[0];
           }
           else if (mbi-&gt;base.y_mode == ZEROMV)
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[1];
           else if (mbi-&gt;base.y_mode == SPLITMV)
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[3];
           else
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[2];
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.ref_frame == CURRENT_FRAME)
           {
               if (mbi-&gt;base.y_mode == B_PRED)
                   filter_level += ctx-&gt;loopfilter_hdr.mode_delta[0];
           }
           else if (mbi-&gt;base.y_mode == ZEROMV)
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[1];
           else if (mbi-&gt;base.y_mode == SPLITMV)
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[3];
           else
               filter_level += ctx-&gt;loopfilter_hdr.mode_delta[2];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt; 63)
           filter_level = 63;
       else if (filter_level &lt; 0)
           filter_level = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt; 63)
           filter_level = 63;
       else if (filter_level &lt; 0)
           filter_level = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
interior_limit = filter_level;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
内部极限=过滤器水平；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;loopfilter_hdr.sharpness)
       {
           interior_limit &gt;&gt;= ctx-&gt;loopfilter_hdr.sharpness &gt; 4 ? 2 : 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;loopfilter_hdr.sharpness)
       {
           interior_limit &gt;&gt;= ctx-&gt;loopfilter_hdr.sharpness &gt; 4 ? 2 : 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (interior_limit &gt; 9 - ctx-&gt;loopfilter_hdr.sharpness)
               interior_limit = 9 - ctx-&gt;loopfilter_hdr.sharpness;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (interior_limit &gt; 9 - ctx-&gt;loopfilter_hdr.sharpness)
               interior_limit = 9 - ctx-&gt;loopfilter_hdr.sharpness;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (interior_limit &lt; 1) interior_limit = 1;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（内部极限&lt;1）内部极限=1；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hev_threshold = (filter_level &gt;= 15);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       hev_threshold = (filter_level &gt;= 15);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt;= 40)
           hev_threshold++;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt;= 40)
           hev_threshold++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt;= 20 &amp;&amp; !ctx-&gt;frame_hdr.is_keyframe)
           hev_threshold++;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (filter_level &gt;= 20 &amp;&amp; !ctx-&gt;frame_hdr.is_keyframe)
           hev_threshold++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       *edge_limit_ = filter_level;
       *interior_limit_ = interior_limit;
       *hev_threshold_ = hev_threshold;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       *edge_limit_ = filter_level;
       *interior_limit_ = interior_limit;
       *hev_threshold_ = hev_threshold;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_row_normal(struct vp8_decoder_ctx *ctx,
                     unsigned int            row,
                     unsigned int            start_col,
                     unsigned int            num_cols)
   {
       unsigned char  *y, *u, *v;
       int             stride, uv_stride;
       struct mb_info *mbi;
       unsigned int    col;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_row_normal(struct vp8_decoder_ctx *ctx,
                     unsigned int            row,
                     unsigned int            start_col,
                     unsigned int            num_cols)
   {
       unsigned char  *y, *u, *v;
       int             stride, uv_stride;
       struct mb_info *mbi;
       unsigned int    col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stride    = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       uv_stride = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_U];
       y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       u = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_U];
       v = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_V];
       y += (stride * row + start_col) * 16;
       u += (uv_stride * row + start_col) * 8;
       v += (uv_stride * row + start_col) * 8;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stride    = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       uv_stride = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_U];
       y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       u = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_U];
       v = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_V];
       y += (stride * row + start_col) * 16;
       u += (uv_stride * row + start_col) * 8;
       v += (uv_stride * row + start_col) * 8;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           int edge_limit, interior_limit, hev_threshold;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           int edge_limit, interior_limit, hev_threshold;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* TODO: Only need to recalculate every MB if segmentation is
            * enabled.
            */
           calculate_filter_parameters(ctx, mbi, &amp;edge_limit,
                                       &amp;interior_limit, &amp;hev_threshold);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* TODO: Only need to recalculate every MB if segmentation is
            * enabled.
            */
           calculate_filter_parameters(ctx, mbi, &amp;edge_limit,
                                       &amp;interior_limit, &amp;hev_threshold);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (edge_limit)
           {
               if (col)
               {
                   filter_mb_v_edge(y, stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 2);
                   filter_mb_v_edge(u, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
                   filter_mb_v_edge(v, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
               }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (edge_limit)
           {
               if (col)
               {
                   filter_mb_v_edge(y, stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 2);
                   filter_mb_v_edge(u, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
                   filter_mb_v_edge(v, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* NOTE: This conditional is actually dependent on the
                * number of coefficients decoded, not the skip flag as
                * coded in the bitstream.  The tokens task is expected
                * to set 31 if there is *any* non-zero data.
                */
               if (mbi-&gt;base.eob_mask
                   || mbi-&gt;base.y_mode == SPLITMV
                   || mbi-&gt;base.y_mode == B_PRED)
               {
                   filter_subblock_v_edge(y + 4, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(y + 8, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(y + 12, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(u + 4, uv_stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          1);
                   filter_subblock_v_edge(v + 4, uv_stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          1);
               }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* NOTE: This conditional is actually dependent on the
                * number of coefficients decoded, not the skip flag as
                * coded in the bitstream.  The tokens task is expected
                * to set 31 if there is *any* non-zero data.
                */
               if (mbi-&gt;base.eob_mask
                   || mbi-&gt;base.y_mode == SPLITMV
                   || mbi-&gt;base.y_mode == B_PRED)
               {
                   filter_subblock_v_edge(y + 4, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(y + 8, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(y + 12, stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          2);
                   filter_subblock_v_edge(u + 4, uv_stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          1);
                   filter_subblock_v_edge(v + 4, uv_stride, edge_limit,
                                          interior_limit, hev_threshold,
                                          1);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (row)
               {
                   filter_mb_h_edge(y, stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 2);
                   filter_mb_h_edge(u, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
                   filter_mb_h_edge(v, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
               }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (row)
               {
                   filter_mb_h_edge(y, stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 2);
                   filter_mb_h_edge(u, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
                   filter_mb_h_edge(v, uv_stride, edge_limit + 2,
                                    interior_limit, hev_threshold, 1);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (mbi-&gt;base.eob_mask
                   || mbi-&gt;base.y_mode == SPLITMV
                   || mbi-&gt;base.y_mode == B_PRED)
               {
                   filter_subblock_h_edge(y + 4 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(y + 8 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(y + 12 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(u + 4 * uv_stride, uv_stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 1);
                   filter_subblock_h_edge(v + 4 * uv_stride, uv_stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 1);
               }
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (mbi-&gt;base.eob_mask
                   || mbi-&gt;base.y_mode == SPLITMV
                   || mbi-&gt;base.y_mode == B_PRED)
               {
                   filter_subblock_h_edge(y + 4 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(y + 8 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(y + 12 * stride, stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 2);
                   filter_subblock_h_edge(u + 4 * uv_stride, uv_stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 1);
                   filter_subblock_h_edge(v + 4 * uv_stride, uv_stride,
                                          edge_limit, interior_limit,
                                          hev_threshold, 1);
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           y += 16;
           u += 8;
           v += 8;
           mbi++;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           y += 16;
           u += 8;
           v += 8;
           mbi++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_row_simple(struct vp8_decoder_ctx *ctx,
                     unsigned int            row,
                     unsigned int            start_col,
                     unsigned int            num_cols)
   {
       unsigned char  *y;
       int             stride;
       struct mb_info *mbi;
       unsigned int    col;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   filter_row_simple(struct vp8_decoder_ctx *ctx,
                     unsigned int            row,
                     unsigned int            start_col,
                     unsigned int            num_cols)
   {
       unsigned char  *y;
       int             stride;
       struct mb_info *mbi;
       unsigned int    col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
       stride    = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       y += (stride * row + start_col) * 16;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
       stride    = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       y += (stride * row + start_col) * 16;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           int edge_limit, interior_limit, hev_threshold;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           int edge_limit, interior_limit, hev_threshold;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* TODO: Only need to recalculate every MB if segmentation is
            * enabled.
            */
           calculate_filter_parameters(ctx, mbi, &amp;edge_limit,
                                       &amp;interior_limit, &amp;hev_threshold);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* TODO: Only need to recalculate every MB if segmentation is
            * enabled.
            */
           calculate_filter_parameters(ctx, mbi, &amp;edge_limit,
                                       &amp;interior_limit, &amp;hev_threshold);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (edge_limit) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if（边缘限制）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* NOTE: This conditional is actually dependent on the
                * number of coefficients decoded, not the skip flag as
                * coded in the bitstream.  The tokens task is expected
                * to set 31 if there is *any* non-zero data.
                */
               int filter_subblocks = (mbi-&gt;base.eob_mask
                                       || mbi-&gt;base.y_mode == SPLITMV
                                       || mbi-&gt;base.y_mode == B_PRED);
               int mb_limit = (edge_limit + 2) * 2 + interior_limit;
               int b_limit = edge_limit * 2 + interior_limit;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               /* NOTE: This conditional is actually dependent on the
                * number of coefficients decoded, not the skip flag as
                * coded in the bitstream.  The tokens task is expected
                * to set 31 if there is *any* non-zero data.
                */
               int filter_subblocks = (mbi-&gt;base.eob_mask
                                       || mbi-&gt;base.y_mode == SPLITMV
                                       || mbi-&gt;base.y_mode == B_PRED);
               int mb_limit = (edge_limit + 2) * 2 + interior_limit;
               int b_limit = edge_limit * 2 + interior_limit;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if (col) filter_v_edge_simple(y, stride, mb_limit);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if（col）filter_v_edge_simple（y、步幅、mb_限制）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (filter_subblocks)
               {
                   filter_v_edge_simple(y + 4, stride, b_limit);
                   filter_v_edge_simple(y + 8, stride, b_limit);
                   filter_v_edge_simple(y + 12, stride, b_limit);
               }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (filter_subblocks)
               {
                   filter_v_edge_simple(y + 4, stride, b_limit);
                   filter_v_edge_simple(y + 8, stride, b_limit);
                   filter_v_edge_simple(y + 12, stride, b_limit);
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if (row) filter_h_edge_simple(y, stride, mb_limit);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if（row）filter_h_edge_simple（y、步幅、mb_限制）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (filter_subblocks)
               {
                   filter_h_edge_simple(y + 4 * stride, stride,
                                        b_limit);
                   filter_h_edge_simple(y + 8 * stride, stride,
                                        b_limit);
                   filter_h_edge_simple(y + 12 * stride, stride,
                                        b_limit);
               }
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (filter_subblocks)
               {
                   filter_h_edge_simple(y + 4 * stride, stride,
                                        b_limit);
                   filter_h_edge_simple(y + 8 * stride, stride,
                                        b_limit);
                   filter_h_edge_simple(y + 12 * stride, stride,
                                        b_limit);
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           y += 16;
           mbi++;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           y += 16;
           mbi++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_loopfilter_process_row(struct vp8_decoder_ctx *ctx,
                                    unsigned int            row,
                                    unsigned int            start_col,
                                    unsigned int            num_cols)
   {
       if (ctx-&gt;loopfilter_hdr.use_simple)
           filter_row_simple(ctx, row, start_col, num_cols);
       else
           filter_row_normal(ctx, row, start_col, num_cols);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_loopfilter_process_row(struct vp8_decoder_ctx *ctx,
                                    unsigned int            row,
                                    unsigned int            start_col,
                                    unsigned int            num_cols)
   {
       if (ctx-&gt;loopfilter_hdr.use_simple)
           filter_row_simple(ctx, row, start_col, num_cols);
       else
           filter_row_normal(ctx, row, start_col, num_cols);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.7. dixie_loopfilter.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.7. dixie_loopfilter.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef DIXIE_LOOPFILTER_H
   #define DIXIE_LOOPFILTER_H
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef DIXIE_LOOPFILTER_H
   #define DIXIE_LOOPFILTER_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_loopfilter_process_row(struct vp8_decoder_ctx *ctx, unsigned int row, unsigned int start_col, unsigned int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_loopfilter_process_row（结构vp8_解码器_ctx*ctx，无符号整数行，无符号整数起始列，无符号整数列）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8. idct_add.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.8. idct\U add.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;idct_add.h&#34;
   #include &lt;assert.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;idct_add.h&#34;
   #include &lt;assert.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_walsh(const short *input, short *output)
   {
       int i;
       int a1, b1, c1, d1;
       int a2, b2, c2, d2;
       const short *ip = input;
       short *op = output;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_walsh(const short *input, short *output)
   {
       int i;
       int a1, b1, c1, d1;
       int a2, b2, c2, d2;
       const short *ip = input;
       short *op = output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[12];
           b1 = ip[4] + ip[8];
           c1 = ip[4] - ip[8];
           d1 = ip[0] - ip[12];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[12];
           b1 = ip[4] + ip[8];
           c1 = ip[4] - ip[8];
           d1 = ip[0] - ip[12];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[0] = a1 + b1;
           op[4] = c1 + d1;
           op[8] = a1 - b1;
           op[12] = d1 - c1;
           ip++;
           op++;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[0] = a1 + b1;
           op[4] = c1 + d1;
           op[8] = a1 - b1;
           op[12] = d1 - c1;
           ip++;
           op++;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip = output;
       op = output;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ip = output;
       op = output;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[3];
           b1 = ip[1] + ip[2];
           c1 = ip[1] - ip[2];
           d1 = ip[0] - ip[3];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[3];
           b1 = ip[1] + ip[2];
           c1 = ip[1] - ip[2];
           d1 = ip[0] - ip[3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           a2 = a1 + b1;
           b2 = c1 + d1;
           c2 = a1 - b1;
           d2 = d1 - c1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           a2 = a1 + b1;
           b2 = c1 + d1;
           c2 = a1 - b1;
           d2 = d1 - c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[0] = (a2 + 3) &gt;&gt; 3;
           op[1] = (b2 + 3) &gt;&gt; 3;
           op[2] = (c2 + 3) &gt;&gt; 3;
           op[3] = (d2 + 3) &gt;&gt; 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[0] = (a2 + 3) &gt;&gt; 3;
           op[1] = (b2 + 3) &gt;&gt; 3;
           op[2] = (c2 + 3) &gt;&gt; 3;
           op[3] = (d2 + 3) &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ip += 4;
           op += 4;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ip += 4;
           op += 4;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define cospi8sqrt2minus1 20091
   #define sinpi8sqrt2       35468
   #define rounding          0
   static void
   idct_columns(const short *input, short *output)
   {
       int i;
       int a1, b1, c1, d1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define cospi8sqrt2minus1 20091
   #define sinpi8sqrt2       35468
   #define rounding          0
   static void
   idct_columns(const short *input, short *output)
   {
       int i;
       int a1, b1, c1, d1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       const short *ip = input;
       short *op = output;
       int temp1, temp2;
       int shortpitch = 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       const short *ip = input;
       short *op = output;
       int temp1, temp2;
       int shortpitch = 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[8];
           b1 = ip[0] - ip[8];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = ip[0] + ip[8];
           b1 = ip[0] - ip[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = (ip[4] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           temp2 = ip[12] +
               ((ip[12] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           c1 = temp1 - temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = (ip[4] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           temp2 = ip[12] +
               ((ip[12] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = ip[4] +
               ((ip[4] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           temp2 = (ip[12] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           d1 = temp1 + temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = ip[4] +
               ((ip[4] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           temp2 = (ip[12] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[shortpitch*0] = a1 + d1;
           op[shortpitch*3] = a1 - d1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[shortpitch*0] = a1 + d1;
           op[shortpitch*3] = a1 - d1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[shortpitch*1] = b1 + c1;
           op[shortpitch*2] = b1 - c1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           op[shortpitch*1] = b1 + c1;
           op[shortpitch*2] = b1 - c1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ip++;
           op++;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ip++;
           op++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_idct_add(unsigned char        *recon,
                      const unsigned char  *predict,
                      int                   stride,
                      const short          *coeffs)
   {
       int i;
       int a1, b1, c1, d1, temp1, temp2;
       short tmp[16];
       idct_columns(coeffs, tmp);
       coeffs = tmp;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_idct_add(unsigned char        *recon,
                      const unsigned char  *predict,
                      int                   stride,
                      const short          *coeffs)
   {
       int i;
       int a1, b1, c1, d1, temp1, temp2;
       short tmp[16];
       idct_columns(coeffs, tmp);
       coeffs = tmp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = coeffs[0] + coeffs[2];
           b1 = coeffs[0] - coeffs[2];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 4; i++)
       {
           a1 = coeffs[0] + coeffs[2];
           b1 = coeffs[0] - coeffs[2];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = (coeffs[1] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           temp2 = coeffs[3] +
               ((coeffs[3] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           c1 = temp1 - temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = (coeffs[1] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           temp2 = coeffs[3] +
               ((coeffs[3] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           c1 = temp1 - temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = coeffs[1] +
               ((coeffs[1] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           temp2 = (coeffs[3] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           d1 = temp1 + temp2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           temp1 = coeffs[1] +
               ((coeffs[1] * cospi8sqrt2minus1 + rounding) &gt;&gt; 16);
           temp2 = (coeffs[3] * sinpi8sqrt2 + rounding) &gt;&gt; 16;
           d1 = temp1 + temp2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           recon[0] = CLAMP_255(predict[0] + ((a1 + d1 + 4) &gt;&gt; 3));
           recon[3] = CLAMP_255(predict[3] + ((a1 - d1 + 4) &gt;&gt; 3));
           recon[1] = CLAMP_255(predict[1] + ((b1 + c1 + 4) &gt;&gt; 3));
           recon[2] = CLAMP_255(predict[2] + ((b1 - c1 + 4) &gt;&gt; 3));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           recon[0] = CLAMP_255(predict[0] + ((a1 + d1 + 4) &gt;&gt; 3));
           recon[3] = CLAMP_255(predict[3] + ((a1 - d1 + 4) &gt;&gt; 3));
           recon[1] = CLAMP_255(predict[1] + ((b1 + c1 + 4) &gt;&gt; 3));
           recon[2] = CLAMP_255(predict[2] + ((b1 - c1 + 4) &gt;&gt; 3));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           coeffs += 4;
           recon += stride;
           predict += stride;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           coeffs += 4;
           recon += stride;
           predict += stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.9. idct_add.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.9. idct_add.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef IDCT_ADD_H
   #define IDCT_ADD_H
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef IDCT_ADD_H
   #define IDCT_ADD_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add_init（结构vp8_解码器_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add(unsigned char *recon, const unsigned char *predict, int stride, const short *coeffs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add（无符号字符*侦察，常数无符号字符*预测，整数步长，常数短*系数）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_walsh(const short *in, short *out);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_walsh(const short *in, short *out);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add_process_row(struct vp8_decoder_ctx *ctx, short *coeffs, unsigned int row, unsigned int start_col, unsigned int num_cols); #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_idct_add_process_row（结构vp8_decoder_ctx*ctx，short*coefs，unsigned int row，unsigned int start_col，unsigned int num cols）#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10. mem.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.10. 成员h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef VPX_PORTS_MEM_H
   #define VPX_PORTS_MEM_H
   #include &#34;vpx_config.h&#34;
   #include &#34;vpx_integer.h&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef VPX_PORTS_MEM_H
   #define VPX_PORTS_MEM_H
   #include &#34;vpx_config.h&#34;
   #include &#34;vpx_integer.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(__GNUC__) &amp;&amp; __GNUC__
   #define DECLARE_ALIGNED(n,typ,val)  typ val __attribute__ \
       ((aligned (n)))
   #elif defined(_MSC_VER)
   #define DECLARE_ALIGNED(n,typ,val)  __declspec(align(n)) typ val
   #else
   #warning No alignment directives known for this compiler.
   #define DECLARE_ALIGNED(n,typ,val)  typ val
   #endif
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(__GNUC__) &amp;&amp; __GNUC__
   #define DECLARE_ALIGNED(n,typ,val)  typ val __attribute__ \
       ((aligned (n)))
   #elif defined(_MSC_VER)
   #define DECLARE_ALIGNED(n,typ,val)  __declspec(align(n)) typ val
   #else
   #warning No alignment directives known for this compiler.
   #define DECLARE_ALIGNED(n,typ,val)  typ val
   #endif
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Declare an aligned array on the stack, for situations where the
    * stack pointer may not have the alignment we expect.  Creates an
    * array with a modified name, then defines val to be a pointer, and
    * aligns that pointer within the array.
    */
   #define DECLARE_ALIGNED_ARRAY(a,typ,val,n)\
   typ val##_[(n)+(a)/sizeof(typ)+1];\
   typ *val = (typ*)((((intptr_t)val##_)+(a)-1)&amp;((intptr_t)-(a)))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Declare an aligned array on the stack, for situations where the
    * stack pointer may not have the alignment we expect.  Creates an
    * array with a modified name, then defines val to be a pointer, and
    * aligns that pointer within the array.
    */
   #define DECLARE_ALIGNED_ARRAY(a,typ,val,n)\
   typ val##_[(n)+(a)/sizeof(typ)+1];\
   typ *val = (typ*)((((intptr_t)val##_)+(a)-1)&amp;((intptr_t)-(a)))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Indicates that the usage of the specified variable has been
    * audited to assure that it&#39;s safe to use uninitialized.  Silences
    * &#39;may be used uninitialized&#39; warnings on gcc.
    */
   #if defined(__GNUC__) &amp;&amp; __GNUC__
   #define UNINITIALIZED_IS_SAFE(x) x=x
   #else
   #define UNINITIALIZED_IS_SAFE(x) x
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Indicates that the usage of the specified variable has been
    * audited to assure that it&#39;s safe to use uninitialized.  Silences
    * &#39;may be used uninitialized&#39; warnings on gcc.
    */
   #if defined(__GNUC__) &amp;&amp; __GNUC__
   #define UNINITIALIZED_IS_SAFE(x) x=x
   #else
   #define UNINITIALIZED_IS_SAFE(x) x
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11. modemv.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.11. modemv.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;modemv_data.h&#34;
   #include &lt;stdlib.h&gt;
   #include &lt;assert.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;modemv_data.h&#34;
   #include &lt;stdlib.h&gt;
   #include &lt;assert.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct mv_clamp_rect
   {
       int to_left, to_right, to_top, to_bottom;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct mv_clamp_rect
   {
       int to_left, to_right, to_top, to_bottom;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static union mv
           clamp_mv(union mv raw, const struct mv_clamp_rect *bounds)
   {
       union mv newmv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static union mv
           clamp_mv(union mv raw, const struct mv_clamp_rect *bounds)
   {
       union mv newmv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       newmv.d.x = (raw.d.x &lt; bounds-&gt;to_left)
                   ? bounds-&gt;to_left : raw.d.x;
       newmv.d.x = (raw.d.x &gt; bounds-&gt;to_right)
                   ? bounds-&gt;to_right : newmv.d.x;
       newmv.d.y = (raw.d.y &lt; bounds-&gt;to_top)
                   ? bounds-&gt;to_top : raw.d.y;
       newmv.d.y = (raw.d.y &gt; bounds-&gt;to_bottom)
                   ? bounds-&gt;to_bottom : newmv.d.y;
       return newmv;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       newmv.d.x = (raw.d.x &lt; bounds-&gt;to_left)
                   ? bounds-&gt;to_left : raw.d.x;
       newmv.d.x = (raw.d.x &gt; bounds-&gt;to_right)
                   ? bounds-&gt;to_right : newmv.d.x;
       newmv.d.y = (raw.d.y &lt; bounds-&gt;to_top)
                   ? bounds-&gt;to_top : raw.d.y;
       newmv.d.y = (raw.d.y &gt; bounds-&gt;to_bottom)
                   ? bounds-&gt;to_bottom : newmv.d.y;
       return newmv;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   read_segment_id(struct bool_decoder *bool,
                   struct vp8_segment_hdr *seg)
   {
       return bool_get(bool, seg-&gt;tree_probs[0])
              ? 2 + bool_get(bool, seg-&gt;tree_probs[2])
              : bool_get(bool, seg-&gt;tree_probs[1]);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   read_segment_id(struct bool_decoder *bool,
                   struct vp8_segment_hdr *seg)
   {
       return bool_get(bool, seg-&gt;tree_probs[0])
              ? 2 + bool_get(bool, seg-&gt;tree_probs[2])
              : bool_get(bool, seg-&gt;tree_probs[1]);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static enum prediction_mode
   above_block_mode(const struct mb_info *this,
                    const struct mb_info *above,
                    unsigned int b)
   {
       if (b &lt; 4)
       {
           switch (above-&gt;base.y_mode)
           {
           case DC_PRED:
               return B_DC_PRED;
           case V_PRED:
               return B_VE_PRED;
           case H_PRED:
               return B_HE_PRED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static enum prediction_mode
   above_block_mode(const struct mb_info *this,
                    const struct mb_info *above,
                    unsigned int b)
   {
       if (b &lt; 4)
       {
           switch (above-&gt;base.y_mode)
           {
           case DC_PRED:
               return B_DC_PRED;
           case V_PRED:
               return B_VE_PRED;
           case H_PRED:
               return B_HE_PRED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           case TM_PRED:
               return B_TM_PRED;
           case B_PRED:
               return above-&gt;split.modes[b+12];
           default:
               assert(0);
           }
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           case TM_PRED:
               return B_TM_PRED;
           case B_PRED:
               return above-&gt;split.modes[b+12];
           default:
               assert(0);
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.modes[b-4];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.modes[b-4];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static enum prediction_mode
   left_block_mode(const struct mb_info *this,
                   const struct mb_info *left,
                   unsigned int b)
   {
       if (!(b &amp; 3))
       {
           switch (left-&gt;base.y_mode)
           {
           case DC_PRED:
               return B_DC_PRED;
           case V_PRED:
               return B_VE_PRED;
           case H_PRED:
               return B_HE_PRED;
           case TM_PRED:
               return B_TM_PRED;
           case B_PRED:
               return left-&gt;split.modes[b+3];
           default:
               assert(0);
           }
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static enum prediction_mode
   left_block_mode(const struct mb_info *this,
                   const struct mb_info *left,
                   unsigned int b)
   {
       if (!(b &amp; 3))
       {
           switch (left-&gt;base.y_mode)
           {
           case DC_PRED:
               return B_DC_PRED;
           case V_PRED:
               return B_VE_PRED;
           case H_PRED:
               return B_HE_PRED;
           case TM_PRED:
               return B_TM_PRED;
           case B_PRED:
               return left-&gt;split.modes[b+3];
           default:
               assert(0);
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.modes[b-1];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.modes[b-1];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_kf_mb_mode(struct mb_info      *this,
                     struct mb_info      *left,
                     struct mb_info      *above,
                     struct bool_decoder *bool)
   {
       int y_mode, uv_mode;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_kf_mb_mode(struct mb_info      *this,
                     struct mb_info      *left,
                     struct mb_info      *above,
                     struct bool_decoder *bool)
   {
       int y_mode, uv_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       y_mode = bool_read_tree(bool, kf_y_mode_tree, kf_y_mode_probs);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       y_mode = bool_read_tree(bool, kf_y_mode_tree, kf_y_mode_probs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (y_mode == B_PRED)
       {
           unsigned int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (y_mode == B_PRED)
       {
           unsigned int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               enum prediction_mode a = above_block_mode(this, above,
                                                         i);
               enum prediction_mode l = left_block_mode(this, left, i);
               enum prediction_mode b;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               enum prediction_mode a = above_block_mode(this, above,
                                                         i);
               enum prediction_mode l = left_block_mode(this, left, i);
               enum prediction_mode b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               b = bool_read_tree(bool, b_mode_tree,
                                  kf_b_mode_probs[a][l]);
               this-&gt;split.modes[i] = b;
           }
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               b = bool_read_tree(bool, b_mode_tree,
                                  kf_b_mode_probs[a][l]);
               this-&gt;split.modes[i] = b;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uv_mode = bool_read_tree(bool, uv_mode_tree, kf_uv_mode_probs);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uv_mode = bool_read_tree(bool, uv_mode_tree, kf_uv_mode_probs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = y_mode;
       this-&gt;base.uv_mode = uv_mode;
       this-&gt;base.mv.raw = 0;
       this-&gt;base.ref_frame = 0;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = y_mode;
       this-&gt;base.uv_mode = uv_mode;
       this-&gt;base.mv.raw = 0;
       this-&gt;base.ref_frame = 0;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_intra_mb_mode(struct mb_info         *this,
                        struct vp8_entropy_hdr *hdr,
                        struct bool_decoder    *bool)
   {
       /* Like decode_kf_mb_mode, but with probabilities transmitted in
        * the bitstream and no context on the above/left block mode.
        */
       int y_mode, uv_mode;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_intra_mb_mode(struct mb_info         *this,
                        struct vp8_entropy_hdr *hdr,
                        struct bool_decoder    *bool)
   {
       /* Like decode_kf_mb_mode, but with probabilities transmitted in
        * the bitstream and no context on the above/left block mode.
        */
       int y_mode, uv_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       y_mode = bool_read_tree(bool, y_mode_tree, hdr-&gt;y_mode_probs);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       y_mode = bool_read_tree(bool, y_mode_tree, hdr-&gt;y_mode_probs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (y_mode == B_PRED)
       {
           unsigned int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (y_mode == B_PRED)
       {
           unsigned int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               enum prediction_mode b;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               enum prediction_mode b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               b = bool_read_tree(bool, b_mode_tree,
                                  default_b_mode_probs);
               this-&gt;split.modes[i] = b;
           }
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               b = bool_read_tree(bool, b_mode_tree,
                                  default_b_mode_probs);
               this-&gt;split.modes[i] = b;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uv_mode = bool_read_tree(bool, uv_mode_tree, hdr-&gt;uv_mode_probs);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uv_mode = bool_read_tree(bool, uv_mode_tree, hdr-&gt;uv_mode_probs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = y_mode;
       this-&gt;base.uv_mode = uv_mode;
       this-&gt;base.mv.raw = 0;
       this-&gt;base.ref_frame = CURRENT_FRAME;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = y_mode;
       this-&gt;base.uv_mode = uv_mode;
       this-&gt;base.mv.raw = 0;
       this-&gt;base.ref_frame = CURRENT_FRAME;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   read_mv_component(struct bool_decoder *bool,
                     const unsigned char  mvc[MV_PROB_CNT])
   {
       enum {IS_SHORT, SIGN, SHORT, BITS = SHORT + 8 - 1,
             LONG_WIDTH = 10};
       int x = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   read_mv_component(struct bool_decoder *bool,
                     const unsigned char  mvc[MV_PROB_CNT])
   {
       enum {IS_SHORT, SIGN, SHORT, BITS = SHORT + 8 - 1,
             LONG_WIDTH = 10};
       int x = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (bool_get(bool, mvc[IS_SHORT])) /* Large */
       {
           int i = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (bool_get(bool, mvc[IS_SHORT])) /* Large */
       {
           int i = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 3; i++)
               x += bool_get(bool, mvc[BITS + i]) &lt;&lt; i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 3; i++)
               x += bool_get(bool, mvc[BITS + i]) &lt;&lt; i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Skip bit 3, which is sometimes implicit */
           for (i = LONG_WIDTH - 1; i &gt; 3; i--)
               x += bool_get(bool, mvc[BITS + i]) &lt;&lt; i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Skip bit 3, which is sometimes implicit */
           for (i = LONG_WIDTH - 1; i &gt; 3; i--)
               x += bool_get(bool, mvc[BITS + i]) &lt;&lt; i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!(x &amp; 0xFFF0)  ||  bool_get(bool, mvc[BITS + 3]))
               x += 8;
       }
       else   /* small */
           x = bool_read_tree(bool, small_mv_tree, mvc + SHORT);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!(x &amp; 0xFFF0)  ||  bool_get(bool, mvc[BITS + 3]))
               x += 8;
       }
       else   /* small */
           x = bool_read_tree(bool, small_mv_tree, mvc + SHORT);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (x &amp;&amp; bool_get(bool, mvc[SIGN]))
           x = -x;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (x &amp;&amp; bool_get(bool, mvc[SIGN]))
           x = -x;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return x &lt;&lt; 1;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return x &lt;&lt; 1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static mv_t
   above_block_mv(const struct mb_info *this,
                  const struct mb_info *above,
                  unsigned int          b)
   {
       if (b &lt; 4)
       {
           if (above-&gt;base.y_mode == SPLITMV)
               return above-&gt;split.mvs[b+12];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static mv_t
   above_block_mv(const struct mb_info *this,
                  const struct mb_info *above,
                  unsigned int          b)
   {
       if (b &lt; 4)
       {
           if (above-&gt;base.y_mode == SPLITMV)
               return above-&gt;split.mvs[b+12];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return above-&gt;base.mv;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return above-&gt;base.mv;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.mvs[b-4];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.mvs[b-4];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static mv_t
   left_block_mv(const struct mb_info *this,
                 const struct mb_info *left,
                 unsigned int          b)
   {
       if (!(b &amp; 3))
       {
           if (left-&gt;base.y_mode == SPLITMV)
               return left-&gt;split.mvs[b+3];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static mv_t
   left_block_mv(const struct mb_info *this,
                 const struct mb_info *left,
                 unsigned int          b)
   {
       if (!(b &amp; 3))
       {
           if (left-&gt;base.y_mode == SPLITMV)
               return left-&gt;split.mvs[b+3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return left-&gt;base.mv;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return left-&gt;base.mv;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.mvs[b-1];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return this-&gt;split.mvs[b-1];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static enum prediction_mode
   submv_ref(struct bool_decoder *bool, union mv l, union mv a)
   {
       enum subblock_mv_ref
       {
           SUBMVREF_NORMAL,
           SUBMVREF_LEFT_ZED,
           SUBMVREF_ABOVE_ZED,
           SUBMVREF_LEFT_ABOVE_SAME,
           SUBMVREF_LEFT_ABOVE_ZED
       };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static enum prediction_mode
   submv_ref(struct bool_decoder *bool, union mv l, union mv a)
   {
       enum subblock_mv_ref
       {
           SUBMVREF_NORMAL,
           SUBMVREF_LEFT_ZED,
           SUBMVREF_ABOVE_ZED,
           SUBMVREF_LEFT_ABOVE_SAME,
           SUBMVREF_LEFT_ABOVE_ZED
       };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int lez = !(l.raw);
       int aez = !(a.raw);
       int lea = l.raw == a.raw;
       enum subblock_mv_ref ctx = SUBMVREF_NORMAL;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int lez = !(l.raw);
       int aez = !(a.raw);
       int lea = l.raw == a.raw;
       enum subblock_mv_ref ctx = SUBMVREF_NORMAL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lea &amp;&amp; lez)
           ctx = SUBMVREF_LEFT_ABOVE_ZED;
       else if (lea)
           ctx = SUBMVREF_LEFT_ABOVE_SAME;
       else if (aez)
           ctx = SUBMVREF_ABOVE_ZED;
       else if (lez)
           ctx = SUBMVREF_LEFT_ZED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (lea &amp;&amp; lez)
           ctx = SUBMVREF_LEFT_ABOVE_ZED;
       else if (lea)
           ctx = SUBMVREF_LEFT_ABOVE_SAME;
       else if (aez)
           ctx = SUBMVREF_ABOVE_ZED;
       else if (lez)
           ctx = SUBMVREF_LEFT_ZED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return bool_read_tree(bool, submv_ref_tree,
                             submv_ref_probs2[ctx]);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return bool_read_tree(bool, submv_ref_tree,
                             submv_ref_probs2[ctx]);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   read_mv(struct bool_decoder  *bool,
           union mv             *mv,
           mv_component_probs_t  mvc[2])
   {
       mv-&gt;d.y = read_mv_component(bool, mvc[0]);
       mv-&gt;d.x = read_mv_component(bool, mvc[1]);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   read_mv(struct bool_decoder  *bool,
           union mv             *mv,
           mv_component_probs_t  mvc[2])
   {
       mv-&gt;d.y = read_mv_component(bool, mvc[0]);
       mv-&gt;d.x = read_mv_component(bool, mvc[1]);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   mv_bias(const struct mb_info *mb,
           const unsigned int   sign_bias[3],
           enum reference_frame ref_frame,
           union mv             *mv)
   {
       if (sign_bias[mb-&gt;base.ref_frame] ^ sign_bias[ref_frame])
       {
           mv-&gt;d.x *= -1;
           mv-&gt;d.y *= -1;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   mv_bias(const struct mb_info *mb,
           const unsigned int   sign_bias[3],
           enum reference_frame ref_frame,
           union mv             *mv)
   {
       if (sign_bias[mb-&gt;base.ref_frame] ^ sign_bias[ref_frame])
       {
           mv-&gt;d.x *= -1;
           mv-&gt;d.y *= -1;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum near_mv_v
   {
       CNT_BEST = 0,
       CNT_ZEROZERO = 0,
       CNT_NEAREST,
       CNT_NEAR,
       CNT_SPLITMV
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum near_mv_v
   {
       CNT_BEST = 0,
       CNT_ZEROZERO = 0,
       CNT_NEAREST,
       CNT_NEAR,
       CNT_SPLITMV
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   find_near_mvs(const struct mb_info   *this,
                 const struct mb_info   *left,
                 const struct mb_info   *above,
                 const unsigned int      sign_bias[3],
                 union  mv               near_mvs[4],
                 int                     cnt[4])
   {
       const struct mb_info *aboveleft = above - 1;
       union  mv             *mv = near_mvs;
       int                   *cntx = cnt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   find_near_mvs(const struct mb_info   *this,
                 const struct mb_info   *left,
                 const struct mb_info   *above,
                 const unsigned int      sign_bias[3],
                 union  mv               near_mvs[4],
                 int                     cnt[4])
   {
       const struct mb_info *aboveleft = above - 1;
       union  mv             *mv = near_mvs;
       int                   *cntx = cnt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Zero accumulators */
       mv[0].raw = mv[1].raw = mv[2].raw = 0;
       cnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Zero accumulators */
       mv[0].raw = mv[1].raw = mv[2].raw = 0;
       cnt[0] = cnt[1] = cnt[2] = cnt[3] = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above */
       if (above-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (above-&gt;base.mv.raw)
           {
               (++mv)-&gt;raw = above-&gt;base.mv.raw;
               mv_bias(above, sign_bias, this-&gt;base.ref_frame, mv);
               ++cntx;
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above */
       if (above-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (above-&gt;base.mv.raw)
           {
               (++mv)-&gt;raw = above-&gt;base.mv.raw;
               mv_bias(above, sign_bias, this-&gt;base.ref_frame, mv);
               ++cntx;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           *cntx += 2;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           *cntx += 2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process left */
       if (left-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (left-&gt;base.mv.raw)
           {
               union mv this_mv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process left */
       if (left-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (left-&gt;base.mv.raw)
           {
               union mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.raw = left-&gt;base.mv.raw;
               mv_bias(left, sign_bias, this-&gt;base.ref_frame, &amp;this_mv);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.raw = left-&gt;base.mv.raw;
               mv_bias(left, sign_bias, this-&gt;base.ref_frame, &amp;this_mv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.raw != mv-&gt;raw)
               {
                   (++mv)-&gt;raw = this_mv.raw;
                   ++cntx;
               }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.raw != mv-&gt;raw)
               {
                   (++mv)-&gt;raw = this_mv.raw;
                   ++cntx;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *cntx += 2;
           }
           else
               cnt[CNT_ZEROZERO] += 2;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *cntx += 2;
           }
           else
               cnt[CNT_ZEROZERO] += 2;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above left */
       if (aboveleft-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (aboveleft-&gt;base.mv.raw)
           {
               union mv this_mv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Process above left */
       if (aboveleft-&gt;base.ref_frame != CURRENT_FRAME)
       {
           if (aboveleft-&gt;base.mv.raw)
           {
               union mv this_mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.raw = aboveleft-&gt;base.mv.raw;
               mv_bias(aboveleft, sign_bias, this-&gt;base.ref_frame,
                       &amp;this_mv);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               this_mv.raw = aboveleft-&gt;base.mv.raw;
               mv_bias(aboveleft, sign_bias, this-&gt;base.ref_frame,
                       &amp;this_mv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.raw != mv-&gt;raw)
               {
                   (++mv)-&gt;raw = this_mv.raw;
                   ++cntx;
               }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (this_mv.raw != mv-&gt;raw)
               {
                   (++mv)-&gt;raw = this_mv.raw;
                   ++cntx;
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *cntx += 1;
           }
           else
               cnt[CNT_ZEROZERO] += 1;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               *cntx += 1;
           }
           else
               cnt[CNT_ZEROZERO] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* If we have three distinct MVs ... */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* If we have three distinct MVs ... */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (cnt[CNT_SPLITMV])
       {
           /* See if above-left MV can be merged with NEAREST */
           if (mv-&gt;raw == near_mvs[CNT_NEAREST].raw)
               cnt[CNT_NEAREST] += 1;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (cnt[CNT_SPLITMV])
       {
           /* See if above-left MV can be merged with NEAREST */
           if (mv-&gt;raw == near_mvs[CNT_NEAREST].raw)
               cnt[CNT_NEAREST] += 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cnt[CNT_SPLITMV] = ((above-&gt;base.y_mode == SPLITMV)
                           + (left-&gt;base.y_mode == SPLITMV)) * 2
                          + (aboveleft-&gt;base.y_mode == SPLITMV);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       cnt[CNT_SPLITMV] = ((above-&gt;base.y_mode == SPLITMV)
                           + (left-&gt;base.y_mode == SPLITMV)) * 2
                          + (aboveleft-&gt;base.y_mode == SPLITMV);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Swap near and nearest if necessary */
       if (cnt[CNT_NEAR] &gt; cnt[CNT_NEAREST])
       {
           int tmp;
           tmp = cnt[CNT_NEAREST];
           cnt[CNT_NEAREST] = cnt[CNT_NEAR];
           cnt[CNT_NEAR] = tmp;
           tmp = near_mvs[CNT_NEAREST].raw;
           near_mvs[CNT_NEAREST].raw = near_mvs[CNT_NEAR].raw;
           near_mvs[CNT_NEAR].raw = tmp;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Swap near and nearest if necessary */
       if (cnt[CNT_NEAR] &gt; cnt[CNT_NEAREST])
       {
           int tmp;
           tmp = cnt[CNT_NEAREST];
           cnt[CNT_NEAREST] = cnt[CNT_NEAR];
           cnt[CNT_NEAR] = tmp;
           tmp = near_mvs[CNT_NEAREST].raw;
           near_mvs[CNT_NEAREST].raw = near_mvs[CNT_NEAR].raw;
           near_mvs[CNT_NEAR].raw = tmp;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Use near_mvs[CNT_BEST] to store the &#34;best&#34; MV.  Note that this
        * storage shares the same address as near_mvs[CNT_ZEROZERO].
        */
       if (cnt[CNT_NEAREST] &gt;= cnt[CNT_BEST])
           near_mvs[CNT_BEST] = near_mvs[CNT_NEAREST];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Use near_mvs[CNT_BEST] to store the &#34;best&#34; MV.  Note that this
        * storage shares the same address as near_mvs[CNT_ZEROZERO].
        */
       if (cnt[CNT_NEAREST] &gt;= cnt[CNT_BEST])
           near_mvs[CNT_BEST] = near_mvs[CNT_NEAREST];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_split_mv(struct mb_info         *this,
                   const struct mb_info   *left,
                   const struct mb_info   *above,
                   struct vp8_entropy_hdr *hdr,
                   union  mv              *best_mv,
                   struct bool_decoder    *bool)
   {
       const int *partition;
       int        j, k, mask, partition_id;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_split_mv(struct mb_info         *this,
                   const struct mb_info   *left,
                   const struct mb_info   *above,
                   struct vp8_entropy_hdr *hdr,
                   union  mv              *best_mv,
                   struct bool_decoder    *bool)
   {
       const int *partition;
       int        j, k, mask, partition_id;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       partition_id = bool_read_tree(bool, split_mv_tree,
                                     split_mv_probs);
       partition = mv_partitions[partition_id];
       this-&gt;base.partitioning = partition_id;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       partition_id = bool_read_tree(bool, split_mv_tree,
                                     split_mv_probs);
       partition = mv_partitions[partition_id];
       this-&gt;base.partitioning = partition_id;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (j = 0, mask = 0; mask &lt; 65535; j++)
       {
           union mv mv, left_mv, above_mv;
           enum prediction_mode subblock_mode;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (j = 0, mask = 0; mask &lt; 65535; j++)
       {
           union mv mv, left_mv, above_mv;
           enum prediction_mode subblock_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Find the first subblock in this partition. */
           for (k = 0; j != partition[k]; k++);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Find the first subblock in this partition. */
           for (k = 0; j != partition[k]; k++);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Decode the next MV */
           left_mv = left_block_mv(this, left, k);
           above_mv = above_block_mv(this, above, k);
           subblock_mode = submv_ref(bool, left_mv,  above_mv);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Decode the next MV */
           left_mv = left_block_mv(this, left, k);
           above_mv = above_block_mv(this, above, k);
           subblock_mode = submv_ref(bool, left_mv,  above_mv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           switch (subblock_mode)
           {
           case LEFT4X4:
               mv = left_mv;
               break;
           case ABOVE4X4:
               mv = above_mv;
               break;
           case ZERO4X4:
               mv.raw = 0;
               break;
           case NEW4X4:
               read_mv(bool, &amp;mv, hdr-&gt;mv_probs);
               mv.d.x += best_mv-&gt;d.x;
               mv.d.y += best_mv-&gt;d.y;
               break;
           default:
               assert(0);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           switch (subblock_mode)
           {
           case LEFT4X4:
               mv = left_mv;
               break;
           case ABOVE4X4:
               mv = above_mv;
               break;
           case ZERO4X4:
               mv.raw = 0;
               break;
           case NEW4X4:
               read_mv(bool, &amp;mv, hdr-&gt;mv_probs);
               mv.d.x += best_mv-&gt;d.x;
               mv.d.y += best_mv-&gt;d.y;
               break;
           default:
               assert(0);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Fill the MVs for this partition */
           for (; k &lt; 16; k++)
               if (j == partition[k])
               {
                   this-&gt;split.mvs[k] = mv;
                   mask |= 1 &lt;&lt; k;
               }
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Fill the MVs for this partition */
           for (; k &lt; 16; k++)
               if (j == partition[k])
               {
                   this-&gt;split.mvs[k] = mv;
                   mask |= 1 &lt;&lt; k;
               }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   need_mc_border(union mv mv, int l, int t, int b_w, int w, int h)
   {
       int b, r;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   need_mc_border(union mv mv, int l, int t, int b_w, int w, int h)
   {
       int b, r;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get distance to edge for top-left pixel */
       l += (mv.d.x &gt;&gt; 3);
       t += (mv.d.y &gt;&gt; 3);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get distance to edge for top-left pixel */
       l += (mv.d.x &gt;&gt; 3);
       t += (mv.d.y &gt;&gt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get distance to edge for bottom-right pixel */
       r = w - (l + b_w);
       b = h - (t + b_w);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get distance to edge for bottom-right pixel */
       r = w - (l + b_w);
       b = h - (t + b_w);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return (l &gt;&gt; 1 &lt; 2 || r &gt;&gt; 1 &lt; 3 || t &gt;&gt; 1 &lt; 2 || b &gt;&gt; 1 &lt; 3);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return (l &gt;&gt; 1 &lt; 2 || r &gt;&gt; 1 &lt; 3 || t &gt;&gt; 1 &lt; 2 || b &gt;&gt; 1 &lt; 3);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_mvs(struct vp8_decoder_ctx       *ctx,
              struct mb_info               *this,
              const struct mb_info         *left,
              const struct mb_info         *above,
              const struct mv_clamp_rect   *bounds,
              struct bool_decoder          *bool)
   {
       struct vp8_entropy_hdr *hdr = &amp;ctx-&gt;entropy_hdr;
       union mv          near_mvs[4];
       union mv          clamped_best_mv;
       int               mv_cnts[4];
       unsigned char     probs[4];
       enum {BEST, NEAREST, NEAR};
       int x, y, w, h, b;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   decode_mvs(struct vp8_decoder_ctx       *ctx,
              struct mb_info               *this,
              const struct mb_info         *left,
              const struct mb_info         *above,
              const struct mv_clamp_rect   *bounds,
              struct bool_decoder          *bool)
   {
       struct vp8_entropy_hdr *hdr = &amp;ctx-&gt;entropy_hdr;
       union mv          near_mvs[4];
       union mv          clamped_best_mv;
       int               mv_cnts[4];
       unsigned char     probs[4];
       enum {BEST, NEAREST, NEAR};
       int x, y, w, h, b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.ref_frame = bool_get(bool, hdr-&gt;prob_last)
                              ? 2 + bool_get(bool, hdr-&gt;prob_gf)
                              : 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.ref_frame = bool_get(bool, hdr-&gt;prob_last)
                              ? 2 + bool_get(bool, hdr-&gt;prob_gf)
                              : 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       find_near_mvs(this, this - 1, above,
                     ctx-&gt;reference_hdr.sign_bias, near_mvs, mv_cnts);
       probs[0] = mv_counts_to_probs[mv_cnts[0]][0];
       probs[1] = mv_counts_to_probs[mv_cnts[1]][1];
       probs[2] = mv_counts_to_probs[mv_cnts[2]][2];
       probs[3] = mv_counts_to_probs[mv_cnts[3]][3];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       find_near_mvs(this, this - 1, above,
                     ctx-&gt;reference_hdr.sign_bias, near_mvs, mv_cnts);
       probs[0] = mv_counts_to_probs[mv_cnts[0]][0];
       probs[1] = mv_counts_to_probs[mv_cnts[1]][1];
       probs[2] = mv_counts_to_probs[mv_cnts[2]][2];
       probs[3] = mv_counts_to_probs[mv_cnts[3]][3];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = bool_read_tree(bool, mv_ref_tree, probs);
       this-&gt;base.uv_mode = this-&gt;base.y_mode;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.y_mode = bool_read_tree(bool, mv_ref_tree, probs);
       this-&gt;base.uv_mode = this-&gt;base.y_mode;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.need_mc_border = 0;
       x = (-bounds-&gt;to_left - 128) &gt;&gt; 3;
       y = (-bounds-&gt;to_top - 128) &gt;&gt; 3;
       w = ctx-&gt;mb_cols * 16;
       h = ctx-&gt;mb_rows * 16;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this-&gt;base.need_mc_border = 0;
       x = (-bounds-&gt;to_left - 128) &gt;&gt; 3;
       y = (-bounds-&gt;to_top - 128) &gt;&gt; 3;
       w = ctx-&gt;mb_cols * 16;
       h = ctx-&gt;mb_rows * 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (this-&gt;base.y_mode)
       {
       case NEARESTMV:
           this-&gt;base.mv = clamp_mv(near_mvs[NEAREST], bounds);
           break;
       case NEARMV:
           this-&gt;base.mv = clamp_mv(near_mvs[NEAR], bounds);
           break;
       case ZEROMV:
           this-&gt;base.mv.raw = 0;
           return; //skip need_mc_border check
       case NEWMV:
           clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
           read_mv(bool, &amp;this-&gt;base.mv, hdr-&gt;mv_probs);
           this-&gt;base.mv.d.x += clamped_best_mv.d.x;
           this-&gt;base.mv.d.y += clamped_best_mv.d.y;
           break;
       case SPLITMV:
       {
           union mv          chroma_mv[4] = {{{0}}};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (this-&gt;base.y_mode)
       {
       case NEARESTMV:
           this-&gt;base.mv = clamp_mv(near_mvs[NEAREST], bounds);
           break;
       case NEARMV:
           this-&gt;base.mv = clamp_mv(near_mvs[NEAR], bounds);
           break;
       case ZEROMV:
           this-&gt;base.mv.raw = 0;
           return; //skip need_mc_border check
       case NEWMV:
           clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
           read_mv(bool, &amp;this-&gt;base.mv, hdr-&gt;mv_probs);
           this-&gt;base.mv.d.x += clamped_best_mv.d.x;
           this-&gt;base.mv.d.y += clamped_best_mv.d.y;
           break;
       case SPLITMV:
       {
           union mv          chroma_mv[4] = {{{0}}};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
           decode_split_mv(this, left, above, hdr, &amp;clamped_best_mv,
                           bool);
           this-&gt;base.mv = this-&gt;split.mvs[15];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           clamped_best_mv = clamp_mv(near_mvs[BEST], bounds);
           decode_split_mv(this, left, above, hdr, &amp;clamped_best_mv,
                           bool);
           this-&gt;base.mv = this-&gt;split.mvs[15];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (b = 0; b &lt; 16; b++)
           {
               chroma_mv[(b&gt;&gt;1&amp;1) + (b&gt;&gt;2&amp;2)].d.x +=
                   this-&gt;split.mvs[b].d.x;
               chroma_mv[(b&gt;&gt;1&amp;1) + (b&gt;&gt;2&amp;2)].d.y +=
                   this-&gt;split.mvs[b].d.y;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (b = 0; b &lt; 16; b++)
           {
               chroma_mv[(b&gt;&gt;1&amp;1) + (b&gt;&gt;2&amp;2)].d.x +=
                   this-&gt;split.mvs[b].d.x;
               chroma_mv[(b&gt;&gt;1&amp;1) + (b&gt;&gt;2&amp;2)].d.y +=
                   this-&gt;split.mvs[b].d.y;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (need_mc_border(this-&gt;split.mvs[b],
               x + (b &amp; 3) * 4, y + (b &amp; ~3), 4, w, h))
               {
                   this-&gt;base.need_mc_border = 1;
                   break;
               }
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (need_mc_border(this-&gt;split.mvs[b],
               x + (b &amp; 3) * 4, y + (b &amp; ~3), 4, w, h))
               {
                   this-&gt;base.need_mc_border = 1;
                   break;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (b = 0; b &lt; 4; b++)
           {
               chroma_mv[b].d.x += 4 + 8 * (chroma_mv[b].d.x &gt;&gt; 31);
               chroma_mv[b].d.y += 4 + 8 * (chroma_mv[b].d.y &gt;&gt; 31);
               chroma_mv[b].d.x /= 4;
               chroma_mv[b].d.y /= 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (b = 0; b &lt; 4; b++)
           {
               chroma_mv[b].d.x += 4 + 8 * (chroma_mv[b].d.x &gt;&gt; 31);
               chroma_mv[b].d.y += 4 + 8 * (chroma_mv[b].d.y &gt;&gt; 31);
               chroma_mv[b].d.x /= 4;
               chroma_mv[b].d.y /= 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
//note we&#39;re passing in non-subsampled coordinates
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
//注意，我们传递的是非二次采样坐标
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (need_mc_border(chroma_mv[b],
               x + (b &amp; 1) * 8, y + (b &gt;&gt; 1) * 8, 16, w, h))
               {
                   this-&gt;base.need_mc_border = 1;
                   break;
               }
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (need_mc_border(chroma_mv[b],
               x + (b &amp; 1) * 8, y + (b &gt;&gt; 1) * 8, 16, w, h))
               {
                   this-&gt;base.need_mc_border = 1;
                   break;
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return; //skip need_mc_border check
       }
       default:
           assert(0);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return; //skip need_mc_border check
       }
       default:
           assert(0);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (need_mc_border(this-&gt;base.mv, x, y, 16, w, h))
           this-&gt;base.need_mc_border = 1;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (need_mc_border(this-&gt;base.mv, x, y, 16, w, h))
           this-&gt;base.need_mc_border = 1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_modemv_process_row(struct vp8_decoder_ctx *ctx,
   struct bool_decoder    *bool,
   int                     row,
   int                     start_col,
   int                     num_cols)
   {
       struct mb_info       *above, *this;
       unsigned int          col;
       struct mv_clamp_rect  bounds;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_modemv_process_row(struct vp8_decoder_ctx *ctx,
   struct bool_decoder    *bool,
   int                     row,
   int                     start_col,
   int                     num_cols)
   {
       struct mb_info       *above, *this;
       unsigned int          col;
       struct mv_clamp_rect  bounds;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this = ctx-&gt;mb_info_rows[row] + start_col;
       above = ctx-&gt;mb_info_rows[row - 1] + start_col;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       this = ctx-&gt;mb_info_rows[row] + start_col;
       above = ctx-&gt;mb_info_rows[row - 1] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate the eighth-pel MV bounds using a 1 MB border. */
       bounds.to_left   = -((start_col + 1) &lt;&lt; 7);
       bounds.to_right  = (ctx-&gt;mb_cols - start_col) &lt;&lt; 7;
       bounds.to_top    = -((row + 1) &lt;&lt; 7);
       bounds.to_bottom = (ctx-&gt;mb_rows - row) &lt;&lt; 7;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate the eighth-pel MV bounds using a 1 MB border. */
       bounds.to_left   = -((start_col + 1) &lt;&lt; 7);
       bounds.to_right  = (ctx-&gt;mb_cols - start_col) &lt;&lt; 7;
       bounds.to_top    = -((row + 1) &lt;&lt; 7);
       bounds.to_bottom = (ctx-&gt;mb_rows - row) &lt;&lt; 7;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           if (ctx-&gt;segment_hdr.update_map)
               this-&gt;base.segment_id = read_segment_id(bool,
               &amp;ctx-&gt;segment_hdr);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           if (ctx-&gt;segment_hdr.update_map)
               this-&gt;base.segment_id = read_segment_id(bool,
               &amp;ctx-&gt;segment_hdr);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;entropy_hdr.coeff_skip_enabled)
               this-&gt;base.skip_coeff = bool_get(bool,
               ctx-&gt;entropy_hdr.coeff_skip_prob);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;entropy_hdr.coeff_skip_enabled)
               this-&gt;base.skip_coeff = bool_get(bool,
               ctx-&gt;entropy_hdr.coeff_skip_prob);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;frame_hdr.is_keyframe)
           {
               if (!ctx-&gt;segment_hdr.update_map)
                   this-&gt;base.segment_id = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;frame_hdr.is_keyframe)
           {
               if (!ctx-&gt;segment_hdr.update_map)
                   this-&gt;base.segment_id = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               decode_kf_mb_mode(this, this - 1, above, bool);
           }
           else
           {
               if (bool_get(bool, ctx-&gt;entropy_hdr.prob_inter))
                   decode_mvs(ctx, this, this - 1, above, &amp;bounds,
                              bool);
               else
                   decode_intra_mb_mode(this, &amp;ctx-&gt;entropy_hdr, bool);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               decode_kf_mb_mode(this, this - 1, above, bool);
           }
           else
           {
               if (bool_get(bool, ctx-&gt;entropy_hdr.prob_inter))
                   decode_mvs(ctx, this, this - 1, above, &amp;bounds,
                              bool);
               else
                   decode_intra_mb_mode(this, &amp;ctx-&gt;entropy_hdr, bool);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               bounds.to_left -= 16 &lt;&lt; 3;
               bounds.to_right -= 16 &lt;&lt; 3;
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               bounds.to_left -= 16 &lt;&lt; 3;
               bounds.to_right -= 16 &lt;&lt; 3;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Advance to next mb */
           this++;
           above++;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Advance to next mb */
           this++;
           above++;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_modemv_init(struct vp8_decoder_ctx *ctx)
   {
       unsigned int    mbi_w, mbi_h, i;
       struct mb_info *mbi;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_modemv_init(struct vp8_decoder_ctx *ctx)
   {
       unsigned int    mbi_w, mbi_h, i;
       struct mb_info *mbi;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mbi_w = ctx-&gt;mb_cols + 1; /* For left border col */
       mbi_h = ctx-&gt;mb_rows + 1; /* For above border row */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mbi_w = ctx-&gt;mb_cols + 1; /* For left border col */
       mbi_h = ctx-&gt;mb_rows + 1; /* For above border row */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           free(ctx-&gt;mb_info_storage);
           ctx-&gt;mb_info_storage = NULL;
           free(ctx-&gt;mb_info_rows_storage);
           ctx-&gt;mb_info_rows_storage = NULL;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           free(ctx-&gt;mb_info_storage);
           ctx-&gt;mb_info_storage = NULL;
           free(ctx-&gt;mb_info_rows_storage);
           ctx-&gt;mb_info_rows_storage = NULL;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!ctx-&gt;mb_info_storage)
           ctx-&gt;mb_info_storage = calloc(mbi_w * mbi_h,
           sizeof(*ctx-&gt;mb_info_storage));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!ctx-&gt;mb_info_storage)
           ctx-&gt;mb_info_storage = calloc(mbi_w * mbi_h,
           sizeof(*ctx-&gt;mb_info_storage));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (!ctx-&gt;mb_info_rows_storage)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（！ctx-&gt;mb\u信息\u行\u存储）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ctx-&gt;mb_info_rows_storage = calloc(mbi_h,
           sizeof(*ctx-&gt;mb_info_rows_storage));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ctx-&gt;mb_info_rows_storage = calloc(mbi_h,
           sizeof(*ctx-&gt;mb_info_rows_storage));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set up row pointers */
       mbi = ctx-&gt;mb_info_storage + 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Set up row pointers */
       mbi = ctx-&gt;mb_info_storage + 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; mbi_h; i++)
       {
           ctx-&gt;mb_info_rows_storage[i] = mbi;
           mbi += mbi_w;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; mbi_h; i++)
       {
           ctx-&gt;mb_info_rows_storage[i] = mbi;
           mbi += mbi_w;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;mb_info_rows = ctx-&gt;mb_info_rows_storage + 1;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;mb_info_rows = ctx-&gt;mb_info_rows_storage + 1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_modemv_destroy(struct vp8_decoder_ctx *ctx)
   {
       free(ctx-&gt;mb_info_storage);
       ctx-&gt;mb_info_storage = NULL;
       free(ctx-&gt;mb_info_rows_storage);
       ctx-&gt;mb_info_rows_storage = NULL;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_modemv_destroy(struct vp8_decoder_ctx *ctx)
   {
       free(ctx-&gt;mb_info_storage);
       ctx-&gt;mb_info_storage = NULL;
       free(ctx-&gt;mb_info_rows_storage);
       ctx-&gt;mb_info_rows_storage = NULL;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.12. modemv.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.12. modemv.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef MODEMV_H
   #define MODEMV_H
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef MODEMV_H
   #define MODEMV_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_modemv_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无效vp8_dixie_modemv_init（结构vp8_解码器_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_modemv_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无效vp8_dixie_modemv_destroy（结构vp8_解码器_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_modemv_process_row(struct vp8_decoder_ctx *ctx, struct bool_decoder *bool, int row, int start_col, int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无效vp8_dixie_modemv_process_row（结构vp8_decoder_ctx*ctx，结构bool_decoder*bool，int row，int start_col，int num_cols）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13. modemv_data.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.13. modemv_data.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned char kf_y_mode_probs[] = { 145, 156, 163, 128};
   static const unsigned char kf_uv_mode_probs[] = { 142, 114, 183};
   static const unsigned char kf_b_mode_probs[10][10][9] =
   {
     { /* above mode 0 */
       { /* left mode 0 */ 231, 120,  48,  89, 115, 113, 120, 152, 112},
       { /* left mode 1 */ 152, 179,  64, 126, 170, 118,  46,  70,  95},
       { /* left mode 2 */ 175,  69, 143,  80,  85,  82,  72, 155, 103},
       { /* left mode 3 */  56,  58,  10, 171, 218, 189,  17,  13, 152},
       { /* left mode 4 */ 144,  71,  10,  38, 171, 213, 144,  34,  26},
       { /* left mode 5 */ 114,  26,  17, 163,  44, 195,  21,  10, 173},
       { /* left mode 6 */ 121,  24,  80, 195,  26,  62,  44,  64,  85},
       { /* left mode 7 */ 170,  46,  55,  19, 136, 160,  33, 206,  71},
       { /* left mode 8 */  63,  20,   8, 114, 114, 208,  12,   9, 226},
       { /* left mode 9 */  81,  40,  11,  96, 182,  84,  29,  16,  36}
     },
     { /* above mode 1 */
       { /* left mode 0 */ 134, 183,  89, 137,  98, 101, 106, 165, 148},
       { /* left mode 1 */  72, 187, 100, 130, 157, 111,  32,  75,  80},
       { /* left mode 2 */  66, 102, 167,  99,  74,  62,  40, 234, 128},
       { /* left mode 3 */  41,  53,   9, 178, 241, 141,  26,   8, 107},
       { /* left mode 4 */ 104,  79,  12,  27, 217, 255,  87,  17,   7},
       { /* left mode 5 */  74,  43,  26, 146,  73, 166,  49,  23, 157},
       { /* left mode 6 */  65,  38, 105, 160,  51,  52,  31, 115, 128},
       { /* left mode 7 */  87,  68,  71,  44, 114,  51,  15, 186,  23},
       { /* left mode 8 */  47,  41,  14, 110, 182, 183,  21,  17, 194},
       { /* left mode 9 */  66,  45,  25, 102, 197, 189,  23,  18,  22}
     },
     { /* above mode 2 */
       { /* left mode 0 */  88,  88, 147, 150,  42,  46,  45, 196, 205},
       { /* left mode 1 */  43,  97, 183, 117,  85,  38,  35, 179,  61},
       { /* left mode 2 */  39,  53, 200,  87,  26,  21,  43, 232, 171},
       { /* left mode 3 */  56,  34,  51, 104, 114, 102,  29,  93,  77},
       { /* left mode 4 */ 107,  54,  32,  26,  51,   1,  81,  43,  31},
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned char kf_y_mode_probs[] = { 145, 156, 163, 128};
   static const unsigned char kf_uv_mode_probs[] = { 142, 114, 183};
   static const unsigned char kf_b_mode_probs[10][10][9] =
   {
     { /* above mode 0 */
       { /* left mode 0 */ 231, 120,  48,  89, 115, 113, 120, 152, 112},
       { /* left mode 1 */ 152, 179,  64, 126, 170, 118,  46,  70,  95},
       { /* left mode 2 */ 175,  69, 143,  80,  85,  82,  72, 155, 103},
       { /* left mode 3 */  56,  58,  10, 171, 218, 189,  17,  13, 152},
       { /* left mode 4 */ 144,  71,  10,  38, 171, 213, 144,  34,  26},
       { /* left mode 5 */ 114,  26,  17, 163,  44, 195,  21,  10, 173},
       { /* left mode 6 */ 121,  24,  80, 195,  26,  62,  44,  64,  85},
       { /* left mode 7 */ 170,  46,  55,  19, 136, 160,  33, 206,  71},
       { /* left mode 8 */  63,  20,   8, 114, 114, 208,  12,   9, 226},
       { /* left mode 9 */  81,  40,  11,  96, 182,  84,  29,  16,  36}
     },
     { /* above mode 1 */
       { /* left mode 0 */ 134, 183,  89, 137,  98, 101, 106, 165, 148},
       { /* left mode 1 */  72, 187, 100, 130, 157, 111,  32,  75,  80},
       { /* left mode 2 */  66, 102, 167,  99,  74,  62,  40, 234, 128},
       { /* left mode 3 */  41,  53,   9, 178, 241, 141,  26,   8, 107},
       { /* left mode 4 */ 104,  79,  12,  27, 217, 255,  87,  17,   7},
       { /* left mode 5 */  74,  43,  26, 146,  73, 166,  49,  23, 157},
       { /* left mode 6 */  65,  38, 105, 160,  51,  52,  31, 115, 128},
       { /* left mode 7 */  87,  68,  71,  44, 114,  51,  15, 186,  23},
       { /* left mode 8 */  47,  41,  14, 110, 182, 183,  21,  17, 194},
       { /* left mode 9 */  66,  45,  25, 102, 197, 189,  23,  18,  22}
     },
     { /* above mode 2 */
       { /* left mode 0 */  88,  88, 147, 150,  42,  46,  45, 196, 205},
       { /* left mode 1 */  43,  97, 183, 117,  85,  38,  35, 179,  61},
       { /* left mode 2 */  39,  53, 200,  87,  26,  21,  43, 232, 171},
       { /* left mode 3 */  56,  34,  51, 104, 114, 102,  29,  93,  77},
       { /* left mode 4 */ 107,  54,  32,  26,  51,   1,  81,  43,  31},
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       { /* left mode 5 */  39,  28,  85, 171,  58, 165,  90,  98,  64},
       { /* left mode 6 */  34,  22, 116, 206,  23,  34,  43, 166,  73},
       { /* left mode 7 */  68,  25, 106,  22,  64, 171,  36, 225, 114},
       { /* left mode 8 */  34,  19,  21, 102, 132, 188,  16,  76, 124},
       { /* left mode 9 */  62,  18,  78,  95,  85,  57,  50,  48,  51}
     },
     { /* above mode 3 */
       { /* left mode 0 */ 193, 101,  35, 159, 215, 111,  89,  46, 111},
       { /* left mode 1 */  60, 148,  31, 172, 219, 228,  21,  18, 111},
       { /* left mode 2 */ 112, 113,  77,  85, 179, 255,  38, 120, 114},
       { /* left mode 3 */  40,  42,   1, 196, 245, 209,  10,  25, 109},
       { /* left mode 4 */ 100,  80,   8,  43, 154,   1,  51,  26,  71},
       { /* left mode 5 */  88,  43,  29, 140, 166, 213,  37,  43, 154},
       { /* left mode 6 */  61,  63,  30, 155,  67,  45,  68,   1, 209},
       { /* left mode 7 */ 142,  78,  78,  16, 255, 128,  34, 197, 171},
       { /* left mode 8 */  41,  40,   5, 102, 211, 183,   4,   1, 221},
       { /* left mode 9 */  51,  50,  17, 168, 209, 192,  23,  25,  82}
     },
     { /* above mode 4 */
       { /* left mode 0 */ 125,  98,  42,  88, 104,  85, 117, 175,  82},
       { /* left mode 1 */  95,  84,  53,  89, 128, 100, 113, 101,  45},
       { /* left mode 2 */  75,  79, 123,  47,  51, 128,  81, 171,   1},
       { /* left mode 3 */  57,  17,   5,  71, 102,  57,  53,  41,  49},
       { /* left mode 4 */ 115,  21,   2,  10, 102, 255, 166,  23,   6},
       { /* left mode 5 */  38,  33,  13, 121,  57,  73,  26,   1,  85},
       { /* left mode 6 */  41,  10,  67, 138,  77, 110,  90,  47, 114},
       { /* left mode 7 */ 101,  29,  16,  10,  85, 128, 101, 196,  26},
       { /* left mode 8 */  57,  18,  10, 102, 102, 213,  34,  20,  43},
       { /* left mode 9 */ 117,  20,  15,  36, 163, 128,  68,   1,  26}
     },
     { /* above mode 5 */
       { /* left mode 0 */ 138,  31,  36, 171,  27, 166,  38,  44, 229},
       { /* left mode 1 */  67,  87,  58, 169,  82, 115,  26,  59, 179},
       { /* left mode 2 */  63,  59,  90, 180,  59, 166,  93,  73, 154},
       { /* left mode 3 */  40,  40,  21, 116, 143, 209,  34,  39, 175},
       { /* left mode 4 */  57,  46,  22,  24, 128,   1,  54,  17,  37},
       { /* left mode 5 */  47,  15,  16, 183,  34, 223,  49,  45, 183},
       { /* left mode 6 */  46,  17,  33, 183,   6,  98,  15,  32, 183},
       { /* left mode 7 */  65,  32,  73, 115,  28, 128,  23, 128, 205},
       { /* left mode 8 */  40,   3,   9, 115,  51, 192,  18,   6, 223},
       { /* left mode 9 */  87,  37,   9, 115,  59,  77,  64,  21,  47}
     },
     { /* above mode 6 */
       { /* left mode 0 */ 104,  55,  44, 218,   9,  54,  53, 130, 226},
       { /* left mode 1 */  64,  90,  70, 205,  40,  41,  23,  26,  57},
       { /* left mode 2 */  54,  57, 112, 184,   5,  41,  38, 166, 213},
       { /* left mode 3 */  30,  34,  26, 133, 152, 116,  10,  32, 134},
       { /* left mode 4 */  75,  32,  12,  51, 192, 255, 160,  43,  51},
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       { /* left mode 5 */  39,  28,  85, 171,  58, 165,  90,  98,  64},
       { /* left mode 6 */  34,  22, 116, 206,  23,  34,  43, 166,  73},
       { /* left mode 7 */  68,  25, 106,  22,  64, 171,  36, 225, 114},
       { /* left mode 8 */  34,  19,  21, 102, 132, 188,  16,  76, 124},
       { /* left mode 9 */  62,  18,  78,  95,  85,  57,  50,  48,  51}
     },
     { /* above mode 3 */
       { /* left mode 0 */ 193, 101,  35, 159, 215, 111,  89,  46, 111},
       { /* left mode 1 */  60, 148,  31, 172, 219, 228,  21,  18, 111},
       { /* left mode 2 */ 112, 113,  77,  85, 179, 255,  38, 120, 114},
       { /* left mode 3 */  40,  42,   1, 196, 245, 209,  10,  25, 109},
       { /* left mode 4 */ 100,  80,   8,  43, 154,   1,  51,  26,  71},
       { /* left mode 5 */  88,  43,  29, 140, 166, 213,  37,  43, 154},
       { /* left mode 6 */  61,  63,  30, 155,  67,  45,  68,   1, 209},
       { /* left mode 7 */ 142,  78,  78,  16, 255, 128,  34, 197, 171},
       { /* left mode 8 */  41,  40,   5, 102, 211, 183,   4,   1, 221},
       { /* left mode 9 */  51,  50,  17, 168, 209, 192,  23,  25,  82}
     },
     { /* above mode 4 */
       { /* left mode 0 */ 125,  98,  42,  88, 104,  85, 117, 175,  82},
       { /* left mode 1 */  95,  84,  53,  89, 128, 100, 113, 101,  45},
       { /* left mode 2 */  75,  79, 123,  47,  51, 128,  81, 171,   1},
       { /* left mode 3 */  57,  17,   5,  71, 102,  57,  53,  41,  49},
       { /* left mode 4 */ 115,  21,   2,  10, 102, 255, 166,  23,   6},
       { /* left mode 5 */  38,  33,  13, 121,  57,  73,  26,   1,  85},
       { /* left mode 6 */  41,  10,  67, 138,  77, 110,  90,  47, 114},
       { /* left mode 7 */ 101,  29,  16,  10,  85, 128, 101, 196,  26},
       { /* left mode 8 */  57,  18,  10, 102, 102, 213,  34,  20,  43},
       { /* left mode 9 */ 117,  20,  15,  36, 163, 128,  68,   1,  26}
     },
     { /* above mode 5 */
       { /* left mode 0 */ 138,  31,  36, 171,  27, 166,  38,  44, 229},
       { /* left mode 1 */  67,  87,  58, 169,  82, 115,  26,  59, 179},
       { /* left mode 2 */  63,  59,  90, 180,  59, 166,  93,  73, 154},
       { /* left mode 3 */  40,  40,  21, 116, 143, 209,  34,  39, 175},
       { /* left mode 4 */  57,  46,  22,  24, 128,   1,  54,  17,  37},
       { /* left mode 5 */  47,  15,  16, 183,  34, 223,  49,  45, 183},
       { /* left mode 6 */  46,  17,  33, 183,   6,  98,  15,  32, 183},
       { /* left mode 7 */  65,  32,  73, 115,  28, 128,  23, 128, 205},
       { /* left mode 8 */  40,   3,   9, 115,  51, 192,  18,   6, 223},
       { /* left mode 9 */  87,  37,   9, 115,  59,  77,  64,  21,  47}
     },
     { /* above mode 6 */
       { /* left mode 0 */ 104,  55,  44, 218,   9,  54,  53, 130, 226},
       { /* left mode 1 */  64,  90,  70, 205,  40,  41,  23,  26,  57},
       { /* left mode 2 */  54,  57, 112, 184,   5,  41,  38, 166, 213},
       { /* left mode 3 */  30,  34,  26, 133, 152, 116,  10,  32, 134},
       { /* left mode 4 */  75,  32,  12,  51, 192, 255, 160,  43,  51},
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       { /* left mode 5 */  39,  19,  53, 221,  26, 114,  32,  73, 255},
       { /* left mode 6 */  31,   9,  65, 234,   2,  15,   1, 118,  73},
       { /* left mode 7 */  88,  31,  35,  67, 102,  85,  55, 186,  85},
       { /* left mode 8 */  56,  21,  23, 111,  59, 205,  45,  37, 192},
       { /* left mode 9 */  55,  38,  70, 124,  73, 102,   1,  34,  98}
     },
     { /* above mode 7 */
       { /* left mode 0 */ 102,  61,  71,  37,  34,  53,  31, 243, 192},
       { /* left mode 1 */  69,  60,  71,  38,  73, 119,  28, 222,  37},
       { /* left mode 2 */  68,  45, 128,  34,   1,  47,  11, 245, 171},
       { /* left mode 3 */  62,  17,  19,  70, 146,  85,  55,  62,  70},
       { /* left mode 4 */  75,  15,   9,   9,  64, 255, 184, 119,  16},
       { /* left mode 5 */  37,  43,  37, 154, 100, 163,  85, 160,   1},
       { /* left mode 6 */  63,   9,  92, 136,  28,  64,  32, 201,  85},
       { /* left mode 7 */  86,   6,  28,   5,  64, 255,  25, 248,   1},
       { /* left mode 8 */  56,   8,  17, 132, 137, 255,  55, 116, 128},
       { /* left mode 9 */  58,  15,  20,  82, 135,  57,  26, 121,  40}
     },
     { /* above mode 8 */
       { /* left mode 0 */ 164,  50,  31, 137, 154, 133,  25,  35, 218},
       { /* left mode 1 */  51, 103,  44, 131, 131, 123,  31,   6, 158},
       { /* left mode 2 */  86,  40,  64, 135, 148, 224,  45, 183, 128},
       { /* left mode 3 */  22,  26,  17, 131, 240, 154,  14,   1, 209},
       { /* left mode 4 */  83,  12,  13,  54, 192, 255,  68,  47,  28},
       { /* left mode 5 */  45,  16,  21,  91,  64, 222,   7,   1, 197},
       { /* left mode 6 */  56,  21,  39, 155,  60, 138,  23, 102, 213},
       { /* left mode 7 */  85,  26,  85,  85, 128, 128,  32, 146, 171},
       { /* left mode 8 */  18,  11,   7,  63, 144, 171,   4,   4, 246},
       { /* left mode 9 */  35,  27,  10, 146, 174, 171,  12,  26, 128}
     },
     { /* above mode 9 */
       { /* left mode 0 */ 190,  80,  35,  99, 180,  80, 126,  54,  45},
       { /* left mode 1 */  85, 126,  47,  87, 176,  51,  41,  20,  32},
       { /* left mode 2 */ 101,  75, 128, 139, 118, 146, 116, 128,  85},
       { /* left mode 3 */  56,  41,  15, 176, 236,  85,  37,   9,  62},
       { /* left mode 4 */ 146,  36,  19,  30, 171, 255,  97,  27,  20},
       { /* left mode 5 */  71,  30,  17, 119, 118, 255,  17,  18, 138},
       { /* left mode 6 */ 101,  38,  60, 138,  55,  70,  43,  26, 142},
       { /* left mode 7 */ 138,  45,  61,  62, 219,   1,  81, 188,  64},
       { /* left mode 8 */  32,  41,  20, 117, 151, 142,  20,  21, 163},
       { /* left mode 9 */ 112,  19,  12,  61, 195, 128,  48,   4,  24}
     }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       { /* left mode 5 */  39,  19,  53, 221,  26, 114,  32,  73, 255},
       { /* left mode 6 */  31,   9,  65, 234,   2,  15,   1, 118,  73},
       { /* left mode 7 */  88,  31,  35,  67, 102,  85,  55, 186,  85},
       { /* left mode 8 */  56,  21,  23, 111,  59, 205,  45,  37, 192},
       { /* left mode 9 */  55,  38,  70, 124,  73, 102,   1,  34,  98}
     },
     { /* above mode 7 */
       { /* left mode 0 */ 102,  61,  71,  37,  34,  53,  31, 243, 192},
       { /* left mode 1 */  69,  60,  71,  38,  73, 119,  28, 222,  37},
       { /* left mode 2 */  68,  45, 128,  34,   1,  47,  11, 245, 171},
       { /* left mode 3 */  62,  17,  19,  70, 146,  85,  55,  62,  70},
       { /* left mode 4 */  75,  15,   9,   9,  64, 255, 184, 119,  16},
       { /* left mode 5 */  37,  43,  37, 154, 100, 163,  85, 160,   1},
       { /* left mode 6 */  63,   9,  92, 136,  28,  64,  32, 201,  85},
       { /* left mode 7 */  86,   6,  28,   5,  64, 255,  25, 248,   1},
       { /* left mode 8 */  56,   8,  17, 132, 137, 255,  55, 116, 128},
       { /* left mode 9 */  58,  15,  20,  82, 135,  57,  26, 121,  40}
     },
     { /* above mode 8 */
       { /* left mode 0 */ 164,  50,  31, 137, 154, 133,  25,  35, 218},
       { /* left mode 1 */  51, 103,  44, 131, 131, 123,  31,   6, 158},
       { /* left mode 2 */  86,  40,  64, 135, 148, 224,  45, 183, 128},
       { /* left mode 3 */  22,  26,  17, 131, 240, 154,  14,   1, 209},
       { /* left mode 4 */  83,  12,  13,  54, 192, 255,  68,  47,  28},
       { /* left mode 5 */  45,  16,  21,  91,  64, 222,   7,   1, 197},
       { /* left mode 6 */  56,  21,  39, 155,  60, 138,  23, 102, 213},
       { /* left mode 7 */  85,  26,  85,  85, 128, 128,  32, 146, 171},
       { /* left mode 8 */  18,  11,   7,  63, 144, 171,   4,   4, 246},
       { /* left mode 9 */  35,  27,  10, 146, 174, 171,  12,  26, 128}
     },
     { /* above mode 9 */
       { /* left mode 0 */ 190,  80,  35,  99, 180,  80, 126,  54,  45},
       { /* left mode 1 */  85, 126,  47,  87, 176,  51,  41,  20,  32},
       { /* left mode 2 */ 101,  75, 128, 139, 118, 146, 116, 128,  85},
       { /* left mode 3 */  56,  41,  15, 176, 236,  85,  37,   9,  62},
       { /* left mode 4 */ 146,  36,  19,  30, 171, 255,  97,  27,  20},
       { /* left mode 5 */  71,  30,  17, 119, 118, 255,  17,  18, 138},
       { /* left mode 6 */ 101,  38,  60, 138,  55,  70,  43,  26, 142},
       { /* left mode 7 */ 138,  45,  61,  62, 219,   1,  81, 188,  64},
       { /* left mode 8 */  32,  41,  20, 117, 151, 142,  20,  21, 163},
       { /* left mode 9 */ 112,  19,  12,  61, 195, 128,  48,   4,  24}
     }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int kf_y_mode_tree[] =
   {
     -B_PRED, 2,
     4, 6,
     -DC_PRED, -V_PRED,
     -H_PRED, -TM_PRED
   };
   static const int y_mode_tree[] =
   {
     -DC_PRED, 2,
     4, 6,
     -V_PRED, -H_PRED,
     -TM_PRED, -B_PRED
   };
   static const int uv_mode_tree[6] =
   {
     -DC_PRED, 2,
     -V_PRED, 4,
     -H_PRED, -TM_PRED
   };
   static const int b_mode_tree[18] =
   {
     -B_DC_PRED, 2,               /* 0 = DC_NODE */
     -B_TM_PRED, 4,               /* 1 = TM_NODE */
     -B_VE_PRED, 6,               /* 2 = VE_NODE */
     8, 12,                       /* 3 = COM_NODE */
     -B_HE_PRED, 10,              /* 4 = HE_NODE */
     -B_RD_PRED, -B_VR_PRED,      /* 5 = RD_NODE */
     -B_LD_PRED, 14,              /* 6 = LD_NODE */
     -B_VL_PRED, 16,              /* 7 = VL_NODE */
     -B_HD_PRED, -B_HU_PRED       /* 8 = HD_NODE */
   };
   static const int small_mv_tree[14] =
   {
     2, 8,
     4, 6,
     -0, -1,
     -2, -3,
     10, 12,
     -4, -5,
     -6, -7
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int kf_y_mode_tree[] =
   {
     -B_PRED, 2,
     4, 6,
     -DC_PRED, -V_PRED,
     -H_PRED, -TM_PRED
   };
   static const int y_mode_tree[] =
   {
     -DC_PRED, 2,
     4, 6,
     -V_PRED, -H_PRED,
     -TM_PRED, -B_PRED
   };
   static const int uv_mode_tree[6] =
   {
     -DC_PRED, 2,
     -V_PRED, 4,
     -H_PRED, -TM_PRED
   };
   static const int b_mode_tree[18] =
   {
     -B_DC_PRED, 2,               /* 0 = DC_NODE */
     -B_TM_PRED, 4,               /* 1 = TM_NODE */
     -B_VE_PRED, 6,               /* 2 = VE_NODE */
     8, 12,                       /* 3 = COM_NODE */
     -B_HE_PRED, 10,              /* 4 = HE_NODE */
     -B_RD_PRED, -B_VR_PRED,      /* 5 = RD_NODE */
     -B_LD_PRED, 14,              /* 6 = LD_NODE */
     -B_VL_PRED, 16,              /* 7 = VL_NODE */
     -B_HD_PRED, -B_HU_PRED       /* 8 = HD_NODE */
   };
   static const int small_mv_tree[14] =
   {
     2, 8,
     4, 6,
     -0, -1,
     -2, -3,
     10, 12,
     -4, -5,
     -6, -7
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int mv_ref_tree[8] =
   {
     -ZEROMV, 2,
     -NEARESTMV, 4,
     -NEARMV, 6,
     -NEWMV, -SPLITMV
   };
   static const int submv_ref_tree[6] =
   {
     -LEFT4X4, 2,
     -ABOVE4X4, 4,
     -ZERO4X4, -NEW4X4
   };
   static const int split_mv_tree[6] =
   {
     -3, 2,
     -2, 4,
     -0, -1
   };
   static const unsigned char default_b_mode_probs[] =
   { 120,  90,  79, 133,  87,  85,  80, 111, 151};
   static const unsigned char mv_counts_to_probs[6][4] =
   {
     {   7,   1,   1, 143 },
     {  14,  18,  14, 107 },
     { 135,  64,  57,  68 },
     {  60,  56, 128,  65 },
     { 159, 134, 128,  34 },
     { 234, 188, 128,  28 }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const int mv_ref_tree[8] =
   {
     -ZEROMV, 2,
     -NEARESTMV, 4,
     -NEARMV, 6,
     -NEWMV, -SPLITMV
   };
   static const int submv_ref_tree[6] =
   {
     -LEFT4X4, 2,
     -ABOVE4X4, 4,
     -ZERO4X4, -NEW4X4
   };
   static const int split_mv_tree[6] =
   {
     -3, 2,
     -2, 4,
     -0, -1
   };
   static const unsigned char default_b_mode_probs[] =
   { 120,  90,  79, 133,  87,  85,  80, 111, 151};
   static const unsigned char mv_counts_to_probs[6][4] =
   {
     {   7,   1,   1, 143 },
     {  14,  18,  14, 107 },
     { 135,  64,  57,  68 },
     {  60,  56, 128,  65 },
     { 159, 134, 128,  34 },
     { 234, 188, 128,  28 }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   };
   static const unsigned char split_mv_probs[3] =
   { 110, 111, 150};
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   };
   static const unsigned char split_mv_probs[3] =
   { 110, 111, 150};
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned char submv_ref_probs2[5][3] =
   {
     { 147, 136, 18 },
     { 106, 145,  1 },
     { 179, 121,  1 },
     { 223,   1, 34 },
     { 208,   1,  1 }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned char submv_ref_probs2[5][3] =
   {
     { 147, 136, 18 },
     { 106, 145,  1 },
     { 179, 121,  1 },
     { 223,   1, 34 },
     { 208,   1,  1 }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const static int mv_partitions[4][16] =
   {
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1 },
     {0, 0, 1, 1, 0, 0, 1, 1, 0, 0,  1,  1,  0,  0,  1,  1 },
     {0, 0, 1, 1, 0, 0, 1, 1, 2, 2,  3,  3,  2,  2,  3,  3 },
     {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const static int mv_partitions[4][16] =
   {
     {0, 0, 0, 0, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1 },
     {0, 0, 1, 1, 0, 0, 1, 1, 0, 0,  1,  1,  0,  0,  1,  1 },
     {0, 0, 1, 1, 0, 0, 1, 1, 2, 2,  3,  3,  2,  2,  3,  3 },
     {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.14. predict.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.14. 预测
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;predict.h&#34;
   #include &#34;idct_add.h&#34;
   #include &#34;mem.h&#34;
   #include &lt;assert.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;dixie.h&#34;
   #include &#34;predict.h&#34;
   #include &#34;idct_add.h&#34;
   #include &#34;mem.h&#34;
   #include &lt;assert.h&gt;
   #include &lt;string.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       BORDER_PIXELS     = 16,
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       BORDER_PIXELS     = 16,
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const filter_t sixtap_filters[8] =
   {
       { 0,   0, 128,    0,   0,  0 },
       { 0,  -6, 123,   12,  -1,  0 },
       { 2, -11, 108,   36,  -8,  1 },
       { 0,  -9,  93,   50,  -6,  0 },
       { 3, -16,  77,   77, -16,  3 },
       { 0,  -6,  50,   93,  -9,  0 },
       { 1,  -8,  36,  108, -11,  2 },
       { 0,  -1,  12,  123,  -6,  0 }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const filter_t sixtap_filters[8] =
   {
       { 0,   0, 128,    0,   0,  0 },
       { 0,  -6, 123,   12,  -1,  0 },
       { 2, -11, 108,   36,  -8,  1 },
       { 0,  -9,  93,   50,  -6,  0 },
       { 3, -16,  77,   77, -16,  3 },
       { 0,  -6,  50,   93,  -9,  0 },
       { 1,  -8,  36,  108, -11,  2 },
       { 0,  -1,  12,  123,  -6,  0 }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const filter_t bilinear_filters[8] =
   {
       { 0,  0,  128,    0,   0,  0 },
       { 0,  0,  112,   16,   0,  0 },
       { 0,  0,   96,   32,   0,  0 },
       { 0,  0,   80,   48,   0,  0 },
       { 0,  0,   64,   64,   0,  0 },
       { 0,  0,   48,   80,   0,  0 },
       { 0,  0,   32,   96,   0,  0 },
       { 0,  0,   16,  112,   0,  0 }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const filter_t bilinear_filters[8] =
   {
       { 0,  0,  128,    0,   0,  0 },
       { 0,  0,  112,   16,   0,  0 },
       { 0,  0,   96,   32,   0,  0 },
       { 0,  0,   80,   48,   0,  0 },
       { 0,  0,   64,   64,   0,  0 },
       { 0,  0,   48,   80,   0,  0 },
       { 0,  0,   32,   96,   0,  0 },
       { 0,  0,   16,  112,   0,  0 }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_h_nxn(unsigned char *predict,
                 int            stride,
                 int            n)
   {
       unsigned char *left = predict - 1;
       int            i, j;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_h_nxn(unsigned char *predict,
                 int            stride,
                 int            n)
   {
       unsigned char *left = predict - 1;
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
           for (j = 0; j &lt; n; j++)
               predict[i *stride + j] = left[i * stride];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
           for (j = 0; j &lt; n; j++)
               predict[i *stride + j] = left[i * stride];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_v_nxn(unsigned char *predict,
                 int            stride,
                 int            n)
   {
       unsigned char *above = predict - stride;
       int            i, j;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_v_nxn(unsigned char *predict,
                 int            stride,
                 int            n)
   {
       unsigned char *above = predict - stride;
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
           for (j = 0; j &lt; n; j++)
               predict[i *stride + j] = above[j];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
           for (j = 0; j &lt; n; j++)
               predict[i *stride + j] = above[j];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_nxn(unsigned char *predict,
                  int            stride,
                  int            n)
   {
       /* Transposes the left column to the top row for later
        * consumption by the idct/recon stage
        */
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       unsigned char  p = above[-1];
       int            i, j;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_nxn(unsigned char *predict,
                  int            stride,
                  int            n)
   {
       /* Transposes the left column to the top row for later
        * consumption by the idct/recon stage
        */
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       unsigned char  p = above[-1];
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (j = 0; j &lt; n; j++)
       {
           for (i = 0; i &lt; n; i++)
               predict[i] = CLAMP_255(*left + above[i] - p);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (j = 0; j &lt; n; j++)
       {
           for (i = 0; i &lt; n; i++)
               predict[i] = CLAMP_255(*left + above[i] - p);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           predict += stride;
           left += stride;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           predict += stride;
           left += stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_dc_nxn(unsigned char *predict,
                  int            stride,
                  int            n)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            i, j, dc = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_dc_nxn(unsigned char *predict,
                  int            stride,
                  int            n)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            i, j, dc = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
       {
           dc += *left + above[i];
           left += stride;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
       {
           dc += *left + above[i];
           left += stride;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (n)
       {
       case 16:
           dc = (dc + 16) &gt;&gt; 5;
           break;
       case  8:
           dc = (dc + 8) &gt;&gt; 4;
           break;
       case  4:
           dc = (dc + 4) &gt;&gt; 3;
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (n)
       {
       case 16:
           dc = (dc + 16) &gt;&gt; 5;
           break;
       case  8:
           dc = (dc + 8) &gt;&gt; 4;
           break;
       case  4:
           dc = (dc + 4) &gt;&gt; 3;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
           for (j = 0; j &lt; n; j++)
               predict[i *stride + j] = dc;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; n; i++)
           for (j = 0; j &lt; n; j++)
               predict[i *stride + j] = dc;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_ve_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            i, j;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_ve_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            i, j;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = (above[-1] + 2 * above[0] + above[1] + 2) &gt;&gt; 2;
       predict[1] = (above[ 0] + 2 * above[1] + above[2] + 2) &gt;&gt; 2;
       predict[2] = (above[ 1] + 2 * above[2] + above[3] + 2) &gt;&gt; 2;
       predict[3] = (above[ 2] + 2 * above[3] + above[4] + 2) &gt;&gt; 2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = (above[-1] + 2 * above[0] + above[1] + 2) &gt;&gt; 2;
       predict[1] = (above[ 0] + 2 * above[1] + above[2] + 2) &gt;&gt; 2;
       predict[2] = (above[ 1] + 2 * above[2] + above[3] + 2) &gt;&gt; 2;
       predict[3] = (above[ 2] + 2 * above[3] + above[4] + 2) &gt;&gt; 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 1; i &lt; 4; i++)
           for (j = 0; j &lt; 4; j++)
               predict[i *stride + j] = predict[j];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 1; i &lt; 4; i++)
           for (j = 0; j &lt; 4; j++)
               predict[i *stride + j] = predict[j];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_he_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_he_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] +
                     left[stride] + 2) &gt;&gt; 2;
       predict += stride;
       left += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] + left[0] + 2) &gt;&gt; 2;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] =
       predict[1] =
       predict[2] =
       predict[3] = (left[-stride] + 2 * left[0] + left[0] + 2) &gt;&gt; 2;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_ld_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_ld_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[0] + 2 * above[1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[1] = pred1 = (above[1] + 2 * above[2] +
                             above[3] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (above[2] + 2 * above[3] +
                             above[4] + 2) &gt;&gt; 2;
       predict[3] = pred3 = (above[3] + 2 * above[4] +
                             above[5] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[0] + 2 * above[1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[1] = pred1 = (above[1] + 2 * above[2] +
                             above[3] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (above[2] + 2 * above[3] +
                             above[4] + 2) &gt;&gt; 2;
       predict[3] = pred3 = (above[3] + 2 * above[4] +
                             above[5] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred1;
       predict[1] = pred2;
       predict[2] = pred3;
       predict[3] = pred4 = (above[4] + 2 * above[5] +
                             above[6] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred1;
       predict[1] = pred2;
       predict[2] = pred3;
       predict[3] = pred4 = (above[4] + 2 * above[5] +
                             above[6] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred2;
       predict[1] = pred3;
       predict[2] = pred4;
       predict[3] = pred5 = (above[5] + 2 * above[6] +
                             above[7] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred2;
       predict[1] = pred3;
       predict[2] = pred4;
       predict[3] = pred5 = (above[5] + 2 * above[6] +
                             above[7] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred3;
       predict[1] = pred4;
       predict[2] = pred5;
       predict[3] = pred6 = (above[6] + 2 * above[7] +
                             above[7] + 2) &gt;&gt; 2;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred3;
       predict[1] = pred4;
       predict[2] = pred5;
       predict[3] = pred6 = (above[6] + 2 * above[7] +
                             above[7] + 2) &gt;&gt; 2;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_rd_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_rd_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 =
           (left[ 0] + 2 * above[-1] + above[0] + 2) &gt;&gt; 2;
       predict[1] = pred1 =
           (above[-1] + 2 * above[ 0] + above[1] + 2) &gt;&gt; 2;
       predict[2] = pred2 =
           (above[ 0] + 2 * above[ 1] + above[2] + 2) &gt;&gt; 2;
       predict[3] = pred3 =
           (above[ 1] + 2 * above[ 2] + above[3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 =
           (left[ 0] + 2 * above[-1] + above[0] + 2) &gt;&gt; 2;
       predict[1] = pred1 =
           (above[-1] + 2 * above[ 0] + above[1] + 2) &gt;&gt; 2;
       predict[2] = pred2 =
           (above[ 0] + 2 * above[ 1] + above[2] + 2) &gt;&gt; 2;
       predict[3] = pred3 =
           (above[ 1] + 2 * above[ 2] + above[3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 =
           (left[stride] + 2 * left[0] + above[-1] + 2) &gt;&gt; 2;
       predict[1] = pred0;
       predict[2] = pred1;
       predict[3] = pred2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 =
           (left[stride] + 2 * left[0] + above[-1] + 2) &gt;&gt; 2;
       predict[1] = pred0;
       predict[2] = pred1;
       predict[3] = pred2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred5 =
           (left[stride*2] + 2 * left[stride] + left[0] + 2) &gt;&gt; 2;
       predict[1] = pred4;
       predict[2] = pred0;
       predict[3] = pred1;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred5 =
           (left[stride*2] + 2 * left[stride] + left[0] + 2) &gt;&gt; 2;
       predict[1] = pred4;
       predict[2] = pred0;
       predict[3] = pred1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred6 = (left[stride*3] + 2 * left[stride*2] +
                             left[stride] + 2) &gt;&gt; 2;
       predict[1] = pred5;
       predict[2] = pred4;
       predict[3] = pred0;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred6 = (left[stride*3] + 2 * left[stride*2] +
                             left[stride] + 2) &gt;&gt; 2;
       predict[1] = pred5;
       predict[2] = pred4;
       predict[3] = pred0;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_vr_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_vr_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[-1] + above[0] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (above[ 0] + above[1] + 1) &gt;&gt; 1;
       predict[2] = pred2 = (above[ 1] + above[2] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (above[ 2] + above[3] + 1) &gt;&gt; 1;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[-1] + above[0] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (above[ 0] + above[1] + 1) &gt;&gt; 1;
       predict[2] = pred2 = (above[ 1] + above[2] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (above[ 2] + above[3] + 1) &gt;&gt; 1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 = (left[ 0] + 2 * above[-1] +
                             above[0] + 2) &gt;&gt; 2;
       predict[1] = pred5 = (above[-1] + 2 * above[ 0] +
                             above[1] + 2) &gt;&gt; 2;
       predict[2] = pred6 = (above[ 0] + 2 * above[ 1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[3] = pred7 = (above[ 1] + 2 * above[ 2] +
                             above[3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 = (left[ 0] + 2 * above[-1] +
                             above[0] + 2) &gt;&gt; 2;
       predict[1] = pred5 = (above[-1] + 2 * above[ 0] +
                             above[1] + 2) &gt;&gt; 2;
       predict[2] = pred6 = (above[ 0] + 2 * above[ 1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[3] = pred7 = (above[ 1] + 2 * above[ 2] +
                             above[3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred8 =
           (left[stride] + 2 * left[0] + above[-1] + 2) &gt;&gt; 2;
       predict[1] = pred0;
       predict[2] = pred1;
       predict[3] = pred2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred8 =
           (left[stride] + 2 * left[0] + above[-1] + 2) &gt;&gt; 2;
       predict[1] = pred0;
       predict[2] = pred1;
       predict[3] = pred2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred9 =
           (left[stride*2] + 2 * left[stride] + left[0] + 2) &gt;&gt; 2;
       predict[1] = pred4;
       predict[2] = pred5;
       predict[3] = pred6;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred9 =
           (left[stride*2] + 2 * left[stride] + left[0] + 2) &gt;&gt; 2;
       predict[1] = pred4;
       predict[2] = pred5;
       predict[3] = pred6;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_vl_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_vl_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[0] + above[1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (above[1] + above[2] + 1) &gt;&gt; 1;
       predict[2] = pred2 = (above[2] + above[3] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (above[3] + above[4] + 1) &gt;&gt; 1;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (above[0] + above[1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (above[1] + above[2] + 1) &gt;&gt; 1;
       predict[2] = pred2 = (above[2] + above[3] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (above[3] + above[4] + 1) &gt;&gt; 1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 = (above[0] + 2 * above[1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[1] = pred5 = (above[1] + 2 * above[2] +
                             above[3] + 2) &gt;&gt; 2;
       predict[2] = pred6 = (above[2] + 2 * above[3] +
                             above[4] + 2) &gt;&gt; 2;
       predict[3] = pred7 = (above[3] + 2 * above[4] +
                             above[5] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 = (above[0] + 2 * above[1] +
                             above[2] + 2) &gt;&gt; 2;
       predict[1] = pred5 = (above[1] + 2 * above[2] +
                             above[3] + 2) &gt;&gt; 2;
       predict[2] = pred6 = (above[2] + 2 * above[3] +
                             above[4] + 2) &gt;&gt; 2;
       predict[3] = pred7 = (above[3] + 2 * above[4] +
                             above[5] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred1;
       predict[1] = pred2;
       predict[2] = pred3;
       predict[3] = pred8 = (above[4] + 2 * above[5] +
                             above[6] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred1;
       predict[1] = pred2;
       predict[2] = pred3;
       predict[3] = pred8 = (above[4] + 2 * above[5] +
                             above[6] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred5;
       predict[1] = pred6;
       predict[2] = pred7;
       predict[3] = pred9 = (above[5] + 2 * above[6] +
                             above[7] + 2) &gt;&gt; 2;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred5;
       predict[1] = pred6;
       predict[2] = pred7;
       predict[3] = pred9 = (above[5] + 2 * above[6] +
                             above[7] + 2) &gt;&gt; 2;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_hd_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_hd_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       unsigned char *above = predict - stride;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6,
                      pred7, pred8, pred9;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (left[ 0] + above[-1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (left[ 0] + 2 * above[-1] +
                             above[0] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (above[-1] + 2 * above[ 0] +
                             above[1] + 2) &gt;&gt; 2;
       predict[3] = pred3 = (above[ 0] + 2 * above[ 1] +
                             above[2] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (left[ 0] + above[-1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (left[ 0] + 2 * above[-1] +
                             above[0] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (above[-1] + 2 * above[ 0] +
                             above[1] + 2) &gt;&gt; 2;
       predict[3] = pred3 = (above[ 0] + 2 * above[ 1] +
                             above[2] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 = (left[stride] + left[0] + 1) &gt;&gt; 1;
       predict[1] = pred5 = (left[stride] + 2 * left[0] +
                             above[-1] + 2) &gt;&gt; 2;
       predict[2] = pred0;
       predict[3] = pred1;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4 = (left[stride] + left[0] + 1) &gt;&gt; 1;
       predict[1] = pred5 = (left[stride] + 2 * left[0] +
                             above[-1] + 2) &gt;&gt; 2;
       predict[2] = pred0;
       predict[3] = pred1;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred6 = (left[stride*2] + left[stride] + 1) &gt;&gt; 1;
       predict[1] = pred7 = (left[stride*2] + 2 * left[stride] +
                             left[0] + 2) &gt;&gt; 2;
       predict[2] = pred4;
       predict[3] = pred5;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred6 = (left[stride*2] + left[stride] + 1) &gt;&gt; 1;
       predict[1] = pred7 = (left[stride*2] + 2 * left[stride] +
                             left[0] + 2) &gt;&gt; 2;
       predict[2] = pred4;
       predict[3] = pred5;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred8 = (left[stride*3] + left[stride*2] + 1) &gt;&gt; 1;
       predict[1] = pred9 = (left[stride*3] + 2 * left[stride*2] +
                             left[stride] + 2) &gt;&gt; 2;
       predict[2] = pred6;
       predict[3] = pred7;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred8 = (left[stride*3] + left[stride*2] + 1) &gt;&gt; 1;
       predict[1] = pred9 = (left[stride*3] + 2 * left[stride*2] +
                             left[stride] + 2) &gt;&gt; 2;
       predict[2] = pred6;
       predict[3] = pred7;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_hu_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_hu_4x4(unsigned char *predict,
                  int            stride)
   {
       unsigned char *left = predict - 1;
       int            pred0, pred1, pred2, pred3, pred4, pred5, pred6;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (left[stride*0] +
                             left[stride*1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (left[stride*0] + 2 * left[stride*1] +
                             left[stride*2] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (left[stride*1] + left[stride*2] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (left[stride*1] + 2 * left[stride*2] +
                             left[stride*3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred0 = (left[stride*0] +
                             left[stride*1] + 1) &gt;&gt; 1;
       predict[1] = pred1 = (left[stride*0] + 2 * left[stride*1] +
                             left[stride*2] + 2) &gt;&gt; 2;
       predict[2] = pred2 = (left[stride*1] + left[stride*2] + 1) &gt;&gt; 1;
       predict[3] = pred3 = (left[stride*1] + 2 * left[stride*2] +
                             left[stride*3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred2;
       predict[1] = pred3;
       predict[2] = pred4 = (left[stride*2] + left[stride*3] + 1) &gt;&gt; 1;
       predict[3] = pred5 = (left[stride*2] + 2 * left[stride*3] +
                             left[stride*3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred2;
       predict[1] = pred3;
       predict[2] = pred4 = (left[stride*2] + left[stride*3] + 1) &gt;&gt; 1;
       predict[3] = pred5 = (left[stride*2] + 2 * left[stride*3] +
                             left[stride*3] + 2) &gt;&gt; 2;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4;
       predict[1] = pred5;
       predict[2] = pred6 = left[stride*3];
       predict[3] = pred6;
       predict += stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred4;
       predict[1] = pred5;
       predict[2] = pred6 = left[stride*3];
       predict[3] = pred6;
       predict += stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred6;
       predict[1] = pred6;
       predict[2] = pred6;
       predict[3] = pred6;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict[0] = pred6;
       predict[1] = pred6;
       predict[2] = pred6;
       predict[3] = pred6;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_h_16x16(unsigned char *predict, int stride)
   {
       predict_h_nxn(predict, stride, 16);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_h_16x16(unsigned char *predict, int stride)
   {
       predict_h_nxn(predict, stride, 16);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_v_16x16(unsigned char *predict, int stride)
   {
       predict_v_nxn(predict, stride, 16);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_v_16x16(unsigned char *predict, int stride)
   {
       predict_v_nxn(predict, stride, 16);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_16x16(unsigned char *predict, int stride)
   {
       predict_tm_nxn(predict, stride, 16);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_16x16(unsigned char *predict, int stride)
   {
       predict_tm_nxn(predict, stride, 16);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_h_8x8(unsigned char *predict, int stride)
   {
       predict_h_nxn(predict, stride, 8);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_h_8x8(unsigned char *predict, int stride)
   {
       predict_h_nxn(predict, stride, 8);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_v_8x8(unsigned char *predict, int stride)
   {
       predict_v_nxn(predict, stride, 8);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_v_8x8(unsigned char *predict, int stride)
   {
       predict_v_nxn(predict, stride, 8);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_8x8(unsigned char *predict, int stride)
   {
       predict_tm_nxn(predict, stride, 8);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_8x8(unsigned char *predict, int stride)
   {
       predict_tm_nxn(predict, stride, 8);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_4x4(unsigned char *predict, int stride)
   {
       predict_tm_nxn(predict, stride, 4);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_tm_4x4(unsigned char *predict, int stride)
   {
       predict_tm_nxn(predict, stride, 4);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   copy_down(unsigned char           *recon,
             int                      stride)
   {
       /* Copy the four pixels above-right of subblock 3 to
        * above-right of subblocks 7, 11, and 15
        */
       uint32_t tmp, *copy = (void *)(recon + 16 - stride);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   copy_down(unsigned char           *recon,
             int                      stride)
   {
       /* Copy the four pixels above-right of subblock 3 to
        * above-right of subblocks 7, 11, and 15
        */
       uint32_t tmp, *copy = (void *)(recon + 16 - stride);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stride = stride / sizeof(unsigned int);
       tmp = *copy;
       copy += stride * 4;
       *copy = tmp;
       copy += stride * 4;
       *copy = tmp;
       copy += stride * 4;
       *copy = tmp;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stride = stride / sizeof(unsigned int);
       tmp = *copy;
       copy += stride * 4;
       *copy = tmp;
       copy += stride * 4;
       *copy = tmp;
       copy += stride * 4;
       *copy = tmp;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   b_pred(unsigned char  *predict,
          int             stride,
          struct mb_info *mbi,
          short          *coeffs)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   b_pred(unsigned char  *predict,
          int             stride,
          struct mb_info *mbi,
          short          *coeffs)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
copy_down(predict, stride);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
向下复制（预测、跨步）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           unsigned char *b_predict = predict + (i &amp; 3) * 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
       {
           unsigned char *b_predict = predict + (i &amp; 3) * 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           switch (mbi-&gt;split.modes[i])
           {
           case B_DC_PRED:
               predict_dc_nxn(b_predict, stride, 4);
               break;
           case B_TM_PRED:
               predict_tm_4x4(b_predict, stride);
               break;
           case B_VE_PRED:
               predict_ve_4x4(b_predict, stride);
               break;
           case B_HE_PRED:
               predict_he_4x4(b_predict, stride);
               break;
           case B_LD_PRED:
               predict_ld_4x4(b_predict, stride);
               break;
           case B_RD_PRED:
               predict_rd_4x4(b_predict, stride);
               break;
           case B_VR_PRED:
               predict_vr_4x4(b_predict, stride);
               break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           switch (mbi-&gt;split.modes[i])
           {
           case B_DC_PRED:
               predict_dc_nxn(b_predict, stride, 4);
               break;
           case B_TM_PRED:
               predict_tm_4x4(b_predict, stride);
               break;
           case B_VE_PRED:
               predict_ve_4x4(b_predict, stride);
               break;
           case B_HE_PRED:
               predict_he_4x4(b_predict, stride);
               break;
           case B_LD_PRED:
               predict_ld_4x4(b_predict, stride);
               break;
           case B_RD_PRED:
               predict_rd_4x4(b_predict, stride);
               break;
           case B_VR_PRED:
               predict_vr_4x4(b_predict, stride);
               break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           case B_VL_PRED:
               predict_vl_4x4(b_predict, stride);
               break;
           case B_HD_PRED:
               predict_hd_4x4(b_predict, stride);
               break;
           case B_HU_PRED:
               predict_hu_4x4(b_predict, stride);
               break;
           default:
               assert(0);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           case B_VL_PRED:
               predict_vl_4x4(b_predict, stride);
               break;
           case B_HD_PRED:
               predict_hd_4x4(b_predict, stride);
               break;
           case B_HU_PRED:
               predict_hu_4x4(b_predict, stride);
               break;
           default:
               assert(0);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           vp8_dixie_idct_add(b_predict, b_predict, stride, coeffs);
           coeffs += 16;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           vp8_dixie_idct_add(b_predict, b_predict, stride, coeffs);
           coeffs += 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if ((i &amp; 3) == 3)
           {
               predict += stride * 4;
           }
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if ((i &amp; 3) == 3)
           {
               predict += stride * 4;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态空隙
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   fixup_dc_coeffs(struct mb_info *mbi,
                   short          *coeffs)
   {
       short y2[16];
       int   i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   fixup_dc_coeffs(struct mb_info *mbi,
                   short          *coeffs)
   {
       short y2[16];
       int   i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       vp8_dixie_walsh(coeffs + 24 * 16, y2);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       vp8_dixie_walsh(coeffs + 24 * 16, y2);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
           coeffs[i*16] = y2[i];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; 16; i++)
           coeffs[i*16] = y2[i];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_intra_luma(unsigned char   *predict,
                      int              stride,
                      struct mb_info  *mbi,
                      short           *coeffs)
   {
       if (mbi-&gt;base.y_mode == B_PRED)
           b_pred(predict, stride, mbi, coeffs);
       else
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_intra_luma(unsigned char   *predict,
                      int              stride,
                      struct mb_info  *mbi,
                      short           *coeffs)
   {
       if (mbi-&gt;base.y_mode == B_PRED)
           b_pred(predict, stride, mbi, coeffs);
       else
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       {
           int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       {
           int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           switch (mbi-&gt;base.y_mode)
           {
           case DC_PRED:
               predict_dc_nxn(predict, stride, 16);
               break;
           case V_PRED:
               predict_v_16x16(predict, stride);
               break;
           case H_PRED:
               predict_h_16x16(predict, stride);
               break;
           case TM_PRED:
               predict_tm_16x16(predict, stride);
               break;
           default:
               assert(0);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           switch (mbi-&gt;base.y_mode)
           {
           case DC_PRED:
               predict_dc_nxn(predict, stride, 16);
               break;
           case V_PRED:
               predict_v_16x16(predict, stride);
               break;
           case H_PRED:
               predict_h_16x16(predict, stride);
               break;
           case TM_PRED:
               predict_tm_16x16(predict, stride);
               break;
           default:
               assert(0);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
fixup_dc_coeffs(mbi, coeffs);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
修正系数（mbi，系数）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               vp8_dixie_idct_add(predict, predict, stride, coeffs);
               coeffs += 16;
               predict += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; 16; i++)
           {
               vp8_dixie_idct_add(predict, predict, stride, coeffs);
               coeffs += 16;
               predict += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if ((i &amp; 3) == 3)
                   predict += stride * 4 - 16;
           }
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if ((i &amp; 3) == 3)
                   predict += stride * 4 - 16;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_intra_chroma(unsigned char   *predict_u,
                        unsigned char   *predict_v,
                        int              stride,
                        struct mb_info  *mbi,
                        short           *coeffs)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_intra_chroma(unsigned char   *predict_u,
                        unsigned char   *predict_v,
                        int              stride,
                        struct mb_info  *mbi,
                        short           *coeffs)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (mbi-&gt;base.uv_mode)
       {
       case DC_PRED:
           predict_dc_nxn(predict_u, stride, 8);
           predict_dc_nxn(predict_v, stride, 8);
           break;
       case V_PRED:
           predict_v_8x8(predict_u, stride);
           predict_v_8x8(predict_v, stride);
           break;
       case H_PRED:
           predict_h_8x8(predict_u, stride);
           predict_h_8x8(predict_v, stride);
           break;
       case TM_PRED:
           predict_tm_8x8(predict_u, stride);
           predict_tm_8x8(predict_v, stride);
           break;
       default:
           assert(0);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (mbi-&gt;base.uv_mode)
       {
       case DC_PRED:
           predict_dc_nxn(predict_u, stride, 8);
           predict_dc_nxn(predict_v, stride, 8);
           break;
       case V_PRED:
           predict_v_8x8(predict_u, stride);
           predict_v_8x8(predict_v, stride);
           break;
       case H_PRED:
           predict_h_8x8(predict_u, stride);
           predict_h_8x8(predict_v, stride);
           break;
       case TM_PRED:
           predict_tm_8x8(predict_u, stride);
           predict_tm_8x8(predict_v, stride);
           break;
       default:
           assert(0);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       coeffs += 16 * 16;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       coeffs += 16 * 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 16; i &lt; 20; i++)
       {
           vp8_dixie_idct_add(predict_u, predict_u, stride, coeffs);
           coeffs += 16;
           predict_u += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 16; i &lt; 20; i++)
       {
           vp8_dixie_idct_add(predict_u, predict_u, stride, coeffs);
           coeffs += 16;
           predict_u += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (i &amp; 1)
               predict_u += stride * 4 - 8;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (i &amp; 1)
               predict_u += stride * 4 - 8;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 20; i &lt; 24; i++)
       {
           vp8_dixie_idct_add(predict_v, predict_v, stride, coeffs);
           coeffs += 16;
           predict_v += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 20; i &lt; 24; i++)
       {
           vp8_dixie_idct_add(predict_v, predict_v, stride, coeffs);
           coeffs += 16;
           predict_v += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (i &amp; 1)
               predict_v += stride * 4 - 8;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (i &amp; 1)
               predict_v += stride * 4 - 8;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   sixtap_horiz(unsigned char       *output,
                int                  output_stride,
                const unsigned char *reference,
                int                  reference_stride,
                int                  cols,
                int                  rows,
                const filter_t       filter
               )
   {
       int r, c, temp;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   sixtap_horiz(unsigned char       *output,
                int                  output_stride,
                const unsigned char *reference,
                int                  reference_stride,
                int                  cols,
                int                  rows,
                const filter_t       filter
               )
   {
       int r, c, temp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (r = 0; r &lt; rows; r++)
       {
           for (c = 0; c &lt; cols; c++)
           {
               temp = (reference[-2] * filter[0]) +
                      (reference[-1] * filter[1]) +
                      (reference[ 0] * filter[2]) +
                      (reference[ 1] * filter[3]) +
                      (reference[ 2] * filter[4]) +
                      (reference[ 3] * filter[5]) +
                      64;
               temp &gt;&gt;= 7;
               output[c] = CLAMP_255(temp);
               reference++;
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (r = 0; r &lt; rows; r++)
       {
           for (c = 0; c &lt; cols; c++)
           {
               temp = (reference[-2] * filter[0]) +
                      (reference[-1] * filter[1]) +
                      (reference[ 0] * filter[2]) +
                      (reference[ 1] * filter[3]) +
                      (reference[ 2] * filter[4]) +
                      (reference[ 3] * filter[5]) +
                      64;
               temp &gt;&gt;= 7;
               output[c] = CLAMP_255(temp);
               reference++;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           reference += reference_stride - cols;
           output += output_stride;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           reference += reference_stride - cols;
           output += output_stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   sixtap_vert(unsigned char       *output,
               int                  output_stride,
               const unsigned char *reference,
               int                  reference_stride,
               int                  cols,
               int                  rows,
               const filter_t       filter
              )
   {
       int r, c, temp;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   sixtap_vert(unsigned char       *output,
               int                  output_stride,
               const unsigned char *reference,
               int                  reference_stride,
               int                  cols,
               int                  rows,
               const filter_t       filter
              )
   {
       int r, c, temp;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (r = 0; r &lt; rows; r++)
       {
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (r = 0; r &lt; rows; r++)
       {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (c = 0; c &lt; cols; c++)
           {
               temp = (reference[-2*reference_stride] * filter[0]) +
                      (reference[-1*reference_stride] * filter[1]) +
                      (reference[ 0*reference_stride] * filter[2]) +
                      (reference[ 1*reference_stride] * filter[3]) +
                      (reference[ 2*reference_stride] * filter[4]) +
                      (reference[ 3*reference_stride] * filter[5]) +
                      64;
               temp &gt;&gt;= 7;
               output[c] = CLAMP_255(temp);
               reference++;
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (c = 0; c &lt; cols; c++)
           {
               temp = (reference[-2*reference_stride] * filter[0]) +
                      (reference[-1*reference_stride] * filter[1]) +
                      (reference[ 0*reference_stride] * filter[2]) +
                      (reference[ 1*reference_stride] * filter[3]) +
                      (reference[ 2*reference_stride] * filter[4]) +
                      (reference[ 3*reference_stride] * filter[5]) +
                      64;
               temp &gt;&gt;= 7;
               output[c] = CLAMP_255(temp);
               reference++;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           reference += reference_stride - cols;
           output += output_stride;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           reference += reference_stride - cols;
           output += output_stride;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   sixtap_2d(unsigned char       *output,
             int                  output_stride,
             const unsigned char *reference,
             int                  reference_stride,
             int                  cols,
             int                  rows,
             int                  mx,
             int                  my,
             const filter_t       filters[8]
            )
   {
       DECLARE_ALIGNED(16, unsigned char, temp[16*(16+5)]);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   sixtap_2d(unsigned char       *output,
             int                  output_stride,
             const unsigned char *reference,
             int                  reference_stride,
             int                  cols,
             int                  rows,
             int                  mx,
             int                  my,
             const filter_t       filters[8]
            )
   {
       DECLARE_ALIGNED(16, unsigned char, temp[16*(16+5)]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sixtap_horiz(temp, 16,
                    reference - 2 * reference_stride, reference_stride,
                    cols, rows + 5, filters[mx]);
       sixtap_vert(output, output_stride,
                   temp + 2 * 16, 16,
                   cols, rows, filters[my]);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sixtap_horiz(temp, 16,
                    reference - 2 * reference_stride, reference_stride,
                    cols, rows + 5, filters[mx]);
       sixtap_vert(output, output_stride,
                   temp + 2 * 16, 16,
                   cols, rows, filters[my]);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct img_index
   {
       unsigned char *y, *u, *v;
       int            stride, uv_stride;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct img_index
   {
       unsigned char *y, *u, *v;
       int            stride, uv_stride;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned char *
   filter_block(unsigned char        *output,
                const unsigned char  *reference,
                int                   stride,
                const union mv       *mv,
                const filter_t        filters[8])
   {
       int mx, my;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned char *
   filter_block(unsigned char        *output,
                const unsigned char  *reference,
                int                   stride,
                const union mv       *mv,
                const filter_t        filters[8])
   {
       int mx, my;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Handle 0,0 as a special case.  TODO: Does this make it any
        * faster?
        */
       if (!mv-&gt;raw)
           return reference;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Handle 0,0 as a special case.  TODO: Does this make it any
        * faster?
        */
       if (!mv-&gt;raw)
           return reference;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mx = mv-&gt;d.x &amp; 7;
       my = mv-&gt;d.y &amp; 7;
       reference += ((mv-&gt;d.y &gt;&gt; 3) * stride) + (mv-&gt;d.x &gt;&gt; 3);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mx = mv-&gt;d.x &amp; 7;
       my = mv-&gt;d.y &amp; 7;
       reference += ((mv-&gt;d.y &gt;&gt; 3) * stride) + (mv-&gt;d.x &gt;&gt; 3);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mx | my)
       {
           sixtap_2d(output, stride, reference, stride, 4, 4, mx, my,
                     filters);
           reference = output;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mx | my)
       {
           sixtap_2d(output, stride, reference, stride, 4, 4, mx, my,
                     filters);
           reference = output;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return reference;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return reference;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   recon_1_block(unsigned char        *output,
                 const unsigned char  *reference,
                 int                   stride,
                 const union mv       *mv,
                 const filter_t        filters[8],
                 short                *coeffs,
                 struct mb_info       *mbi,
                 int                   b
                )
   {
       const unsigned char *predict;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   recon_1_block(unsigned char        *output,
                 const unsigned char  *reference,
                 int                   stride,
                 const union mv       *mv,
                 const filter_t        filters[8],
                 short                *coeffs,
                 struct mb_info       *mbi,
                 int                   b
                )
   {
       const unsigned char *predict;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict = filter_block(output, reference, stride, mv, filters);
       vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict = filter_block(output, reference, stride, mv, filters);
       vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static mv_t
   calculate_chroma_splitmv(struct mb_info *mbi,
                            int             b,
                            int             full_pixel)
   {
       int temp;
       union mv mv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static mv_t
   calculate_chroma_splitmv(struct mb_info *mbi,
                            int             b,
                            int             full_pixel)
   {
       int temp;
       union mv mv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp = mbi-&gt;split.mvs[b].d.x +
              mbi-&gt;split.mvs[b+1].d.x +
              mbi-&gt;split.mvs[b+4].d.x +
              mbi-&gt;split.mvs[b+5].d.x;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp = mbi-&gt;split.mvs[b].d.x +
              mbi-&gt;split.mvs[b+1].d.x +
              mbi-&gt;split.mvs[b+4].d.x +
              mbi-&gt;split.mvs[b+5].d.x;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (temp &lt; 0)
           temp -= 4;
       else
           temp += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (temp &lt; 0)
           temp -= 4;
       else
           temp += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mv.d.x = temp / 8;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mv.d.x = temp / 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp = mbi-&gt;split.mvs[b].d.y +
              mbi-&gt;split.mvs[b+1].d.y +
              mbi-&gt;split.mvs[b+4].d.y +
              mbi-&gt;split.mvs[b+5].d.y;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       temp = mbi-&gt;split.mvs[b].d.y +
              mbi-&gt;split.mvs[b+1].d.y +
              mbi-&gt;split.mvs[b+4].d.y +
              mbi-&gt;split.mvs[b+5].d.y;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (temp &lt; 0)
           temp -= 4;
       else
           temp += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (temp &lt; 0)
           temp -= 4;
       else
           temp += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mv.d.y = temp / 8;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       mv.d.y = temp / 8;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (full_pixel)
       {
           mv.d.x &amp;= ~7;
           mv.d.y &amp;= ~7;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (full_pixel)
       {
           mv.d.x &amp;= ~7;
           mv.d.y &amp;= ~7;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return mv;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return mv;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Note: We rely on the reconstructed border having the same stride
    * as the reference buffer because the filter_block can&#39;t adjust the
    * stride with its return value, only the reference pointer.
    */
   static void
   build_mc_border(unsigned char       *dst,
                   const unsigned char *src,
                   int                  stride,
                   int                  x,
                   int                  y,
                   int                  b_w,
                   int                  b_h,
                   int                  w,
                   int                  h
                  )
   {
       const unsigned char *ref_row;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Note: We rely on the reconstructed border having the same stride
    * as the reference buffer because the filter_block can&#39;t adjust the
    * stride with its return value, only the reference pointer.
    */
   static void
   build_mc_border(unsigned char       *dst,
                   const unsigned char *src,
                   int                  stride,
                   int                  x,
                   int                  y,
                   int                  b_w,
                   int                  b_h,
                   int                  w,
                   int                  h
                  )
   {
       const unsigned char *ref_row;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get a pointer to the start of the real data for this row */
       ref_row = src - x - y * stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get a pointer to the start of the real data for this row */
       ref_row = src - x - y * stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (y &gt;= h)
           ref_row += (h - 1) * stride;
       else if (y &gt; 0)
           ref_row += y * stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (y &gt;= h)
           ref_row += (h - 1) * stride;
       else if (y &gt; 0)
           ref_row += y * stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       do
       {
           int left, right = 0, copy;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       do
       {
           int left, right = 0, copy;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           left = x &lt; 0 ? -x : 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           left = x &lt; 0 ? -x : 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (left &gt; b_w) left = b_w;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
如果（左&gt;黑白）左=黑白；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (x + b_w &gt; w)
               right = x + b_w - w;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (x + b_w &gt; w)
               right = x + b_w - w;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (right &gt; b_w) right = b_w;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
如果（右&gt;黑白）右=黑白；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           copy = b_w - left - right;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           copy = b_w - left - right;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (left) memset(dst, ref_row[0], left);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if（左）memset（dst，参考行[0]，左）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (copy)
               memcpy(dst + left, ref_row + x + left, copy);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (copy)
               memcpy(dst + left, ref_row + x + left, copy);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (right)
               memset(dst + left + copy, ref_row[w-1], right);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (right)
               memset(dst + left + copy, ref_row[w-1], right);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           dst += stride;
           y++;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           dst += stride;
           y++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (y &lt; h &amp;&amp; y &gt; 0)
               ref_row += stride;
       }
       while (--b_h);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (y &lt; h &amp;&amp; y &gt; 0)
               ref_row += stride;
       }
       while (--b_h);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   recon_1_edge_block(unsigned char        *output,
                      unsigned char        *emul_block,
                      const unsigned char  *reference,
                      int                   stride,
                      const union mv       *mv,
                      const filter_t        filters[8],
                      short                *coeffs,
                      struct mb_info       *mbi,
                      int                   x,
                      int                   y,
                      int                   w,
                      int                   h,
                      int                   start_b
                     )
   {
       const unsigned char *predict;
       int                  b = start_b;
       const int            b_w = 4;
       const int            b_h = 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   recon_1_edge_block(unsigned char        *output,
                      unsigned char        *emul_block,
                      const unsigned char  *reference,
                      int                   stride,
                      const union mv       *mv,
                      const filter_t        filters[8],
                      short                *coeffs,
                      struct mb_info       *mbi,
                      int                   x,
                      int                   y,
                      int                   w,
                      int                   h,
                      int                   start_b
                     )
   {
       const unsigned char *predict;
       int                  b = start_b;
       const int            b_w = 4;
       const int            b_h = 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x += mv-&gt;d.x &gt;&gt; 3;
       y += mv-&gt;d.y &gt;&gt; 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x += mv-&gt;d.x &gt;&gt; 3;
       y += mv-&gt;d.y &gt;&gt; 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Need two pixels left/above, 3 right/below for 6-tap */
       if (x &lt; 2 || x + b_w - 1 + 3 &gt;= w || y &lt; 2 ||
           y + b_h - 1 + 3 &gt;= h)
       {
           reference += (mv-&gt;d.x &gt;&gt; 3) + (mv-&gt;d.y &gt;&gt; 3) * stride;
           build_mc_border(emul_block,
                           reference - 2 - 2 * stride, stride,
                           x - 2, y - 2, b_w + 5, b_h + 5, w, h);
           reference = emul_block + 2 * stride + 2;
           reference -= (mv-&gt;d.x &gt;&gt; 3) + (mv-&gt;d.y &gt;&gt; 3) * stride;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Need two pixels left/above, 3 right/below for 6-tap */
       if (x &lt; 2 || x + b_w - 1 + 3 &gt;= w || y &lt; 2 ||
           y + b_h - 1 + 3 &gt;= h)
       {
           reference += (mv-&gt;d.x &gt;&gt; 3) + (mv-&gt;d.y &gt;&gt; 3) * stride;
           build_mc_border(emul_block,
                           reference - 2 - 2 * stride, stride,
                           x - 2, y - 2, b_w + 5, b_h + 5, w, h);
           reference = emul_block + 2 * stride + 2;
           reference -= (mv-&gt;d.x &gt;&gt; 3) + (mv-&gt;d.y &gt;&gt; 3) * stride;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict = filter_block(output, reference, stride, mv, filters);
       vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       predict = filter_block(output, reference, stride, mv, filters);
       vp8_dixie_idct_add(output, predict, stride, coeffs + 16 * b);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_inter_emulated_edge(struct vp8_decoder_ctx  *ctx,
                               struct img_index        *img,
                               short                   *coeffs,
                               struct mb_info          *mbi,
                               int                      mb_col,
                               int                      mb_row)
   {
       /* TODO: Move this into its own buffer.  This only works because
        * we still have a border allocated.
        */
       unsigned char *emul_block = ctx-&gt;frame_strg[0].img.img_data;
       unsigned char *reference;
       unsigned char *output;
       ptrdiff_t      reference_offset;
       int            w, h, x, y, b;
       union mv       chroma_mv[4];
       unsigned char *u = img-&gt;u, *v = img-&gt;v;
       int            full_pixel = ctx-&gt;frame_hdr.version == 3;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   predict_inter_emulated_edge(struct vp8_decoder_ctx  *ctx,
                               struct img_index        *img,
                               short                   *coeffs,
                               struct mb_info          *mbi,
                               int                      mb_col,
                               int                      mb_row)
   {
       /* TODO: Move this into its own buffer.  This only works because
        * we still have a border allocated.
        */
       unsigned char *emul_block = ctx-&gt;frame_strg[0].img.img_data;
       unsigned char *reference;
       unsigned char *output;
       ptrdiff_t      reference_offset;
       int            w, h, x, y, b;
       union mv       chroma_mv[4];
       unsigned char *u = img-&gt;u, *v = img-&gt;v;
       int            full_pixel = ctx-&gt;frame_hdr.version == 3;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x = mb_col * 16;
       y = mb_row * 16;
       w = ctx-&gt;mb_cols * 16;
       h = ctx-&gt;mb_rows * 16;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x = mb_col * 16;
       y = mb_row * 16;
       w = ctx-&gt;mb_cols * 16;
       h = ctx-&gt;mb_rows * 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       output = img-&gt;y;
       reference_offset = ctx-&gt;ref_frame_offsets[mbi-&gt;base.ref_frame];
       reference = output + reference_offset;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       output = img-&gt;y;
       reference_offset = ctx-&gt;ref_frame_offsets[mbi-&gt;base.ref_frame];
       reference = output + reference_offset;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mbi-&gt;base.y_mode != SPLITMV)
       {
           union mv uvmv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mbi-&gt;base.y_mode != SPLITMV)
       {
           union mv uvmv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           uvmv = mbi-&gt;base.mv;
           uvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x &gt;&gt; 31) * 2) / 2;
           uvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y &gt;&gt; 31) * 2) / 2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           uvmv = mbi-&gt;base.mv;
           uvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x &gt;&gt; 31) * 2) / 2;
           uvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y &gt;&gt; 31) * 2) / 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (full_pixel)
           {
               uvmv.d.x &amp;= ~7;
               uvmv.d.y &amp;= ~7;
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (full_pixel)
           {
               uvmv.d.x &amp;= ~7;
               uvmv.d.y &amp;= ~7;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           chroma_mv[0] = uvmv;
           chroma_mv[1] = uvmv;
           chroma_mv[2] = uvmv;
           chroma_mv[3] = uvmv;
       }
       else
       {
           chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);
           chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);
           chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);
           chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           chroma_mv[0] = uvmv;
           chroma_mv[1] = uvmv;
           chroma_mv[2] = uvmv;
           chroma_mv[3] = uvmv;
       }
       else
       {
           chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);
           chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);
           chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);
           chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Luma */
       for (b = 0; b &lt; 16; b++)
       {
           union mv *ymv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Luma */
       for (b = 0; b &lt; 16; b++)
       {
           union mv *ymv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode != SPLITMV)
               ymv = &amp;mbi-&gt;base.mv;
           else
               ymv = mbi-&gt;split.mvs + b;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode != SPLITMV)
               ymv = &amp;mbi-&gt;base.mv;
           else
               ymv = mbi-&gt;split.mvs + b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
recon_1_edge_block(output, emul_block, reference, img-&gt;stride, ymv, ctx-&gt;subpixel_filters, coeffs, mbi, x, y, w, h, b);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
识别边缘块（输出、emul块、参考、img-&gt;步幅、ymv、ctx-&gt;亚像素过滤器、系数、mbi、x、y、w、h、b）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           x += 4;
           output += 4;
           reference += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           x += 4;
           output += 4;
           reference += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if ((b &amp; 3) == 3)
           {
               x -= 16;
               y += 4;
               output += 4 * img-&gt;stride - 16;
               reference += 4 * img-&gt;stride - 16;
           }
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if ((b &amp; 3) == 3)
           {
               x -= 16;
               y += 4;
               output += 4 * img-&gt;stride - 16;
               reference += 4 * img-&gt;stride - 16;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x = mb_col * 16;
       y = mb_row * 16;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       x = mb_col * 16;
       y = mb_row * 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Chroma */
       x &gt;&gt;= 1;
       y &gt;&gt;= 1;
       w &gt;&gt;= 1;
       h &gt;&gt;= 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Chroma */
       x &gt;&gt;= 1;
       y &gt;&gt;= 1;
       w &gt;&gt;= 1;
       h &gt;&gt;= 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 4; b++)
       {
           recon_1_edge_block(u, emul_block, u + reference_offset,
                              img-&gt;uv_stride,
                              &amp;chroma_mv[b], ctx-&gt;subpixel_filters,
                              coeffs, mbi, x, y, w, h, b + 16);
           recon_1_edge_block(v, emul_block, v + reference_offset,
                              img-&gt;uv_stride,
                              &amp;chroma_mv[b], ctx-&gt;subpixel_filters,
                              coeffs, mbi, x, y, w, h, b + 20);
           u += 4;
           v += 4;
           x += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 4; b++)
       {
           recon_1_edge_block(u, emul_block, u + reference_offset,
                              img-&gt;uv_stride,
                              &amp;chroma_mv[b], ctx-&gt;subpixel_filters,
                              coeffs, mbi, x, y, w, h, b + 16);
           recon_1_edge_block(v, emul_block, v + reference_offset,
                              img-&gt;uv_stride,
                              &amp;chroma_mv[b], ctx-&gt;subpixel_filters,
                              coeffs, mbi, x, y, w, h, b + 20);
           u += 4;
           v += 4;
           x += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (b &amp; 1)
           {
               x -= 8;
               y += 4;
               u += 4 * img-&gt;uv_stride - 8;
               v += 4 * img-&gt;uv_stride - 8;
           }
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (b &amp; 1)
           {
               x -= 8;
               y += 4;
               u += 4 * img-&gt;uv_stride - 8;
               v += 4 * img-&gt;uv_stride - 8;
           }
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static void predict_inter(struct vp8_decoder_ctx *ctx, struct img_index *img, short *coeffs, struct mb_info *mbi)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态void predict_inter（结构vp8_解码器_ctx*ctx，结构img_索引*img，short*系数，结构mb_信息*mbi）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       unsigned char *y = img-&gt;y;
       unsigned char *u = img-&gt;u;
       unsigned char *v = img-&gt;v;
       ptrdiff_t      reference_offset;
       union mv       chroma_mv[4];
       int            full_pixel = ctx-&gt;frame_hdr.version == 3;
       int b;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   {
       unsigned char *y = img-&gt;y;
       unsigned char *u = img-&gt;u;
       unsigned char *v = img-&gt;v;
       ptrdiff_t      reference_offset;
       union mv       chroma_mv[4];
       int            full_pixel = ctx-&gt;frame_hdr.version == 3;
       int b;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mbi-&gt;base.y_mode != SPLITMV)
       {
           union mv             uvmv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mbi-&gt;base.y_mode != SPLITMV)
       {
           union mv             uvmv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           uvmv = mbi-&gt;base.mv;
           uvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x &gt;&gt; 31) * 2) / 2;
           uvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y &gt;&gt; 31) * 2) / 2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           uvmv = mbi-&gt;base.mv;
           uvmv.d.x = (uvmv.d.x + 1 + (uvmv.d.x &gt;&gt; 31) * 2) / 2;
           uvmv.d.y = (uvmv.d.y + 1 + (uvmv.d.y &gt;&gt; 31) * 2) / 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (full_pixel)
           {
               uvmv.d.x &amp;= ~7;
               uvmv.d.y &amp;= ~7;
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (full_pixel)
           {
               uvmv.d.x &amp;= ~7;
               uvmv.d.y &amp;= ~7;
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           chroma_mv[0] =
               chroma_mv[1] =
                   chroma_mv[2] =
                       chroma_mv[3] = uvmv;
       }
       else
       {
           chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);
           chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);
           chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);
           chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           chroma_mv[0] =
               chroma_mv[1] =
                   chroma_mv[2] =
                       chroma_mv[3] = uvmv;
       }
       else
       {
           chroma_mv[0] = calculate_chroma_splitmv(mbi,  0, full_pixel);
           chroma_mv[1] = calculate_chroma_splitmv(mbi,  2, full_pixel);
           chroma_mv[2] = calculate_chroma_splitmv(mbi,  8, full_pixel);
           chroma_mv[3] = calculate_chroma_splitmv(mbi, 10, full_pixel);
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       reference_offset = ctx-&gt;ref_frame_offsets[mbi-&gt;base.ref_frame];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       reference_offset = ctx-&gt;ref_frame_offsets[mbi-&gt;base.ref_frame];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 16; b++)
       {
           union mv *ymv;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 16; b++)
       {
           union mv *ymv;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode != SPLITMV)
               ymv = &amp;mbi-&gt;base.mv;
           else
               ymv = mbi-&gt;split.mvs + b;
           recon_1_block(y, y + reference_offset, img-&gt;stride,
                         ymv, ctx-&gt;subpixel_filters, coeffs, mbi, b);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode != SPLITMV)
               ymv = &amp;mbi-&gt;base.mv;
           else
               ymv = mbi-&gt;split.mvs + b;
           recon_1_block(y, y + reference_offset, img-&gt;stride,
                         ymv, ctx-&gt;subpixel_filters, coeffs, mbi, b);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           y += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           y += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if ((b &amp; 3) == 3)
               y += 4 * img-&gt;stride - 16;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if ((b &amp; 3) == 3)
               y += 4 * img-&gt;stride - 16;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 4; b++)
       {
           recon_1_block(u, u + reference_offset,
                         img-&gt;uv_stride, &amp;chroma_mv[b],
                         ctx-&gt;subpixel_filters, coeffs, mbi, b + 16);
           recon_1_block(v, v + reference_offset,
                         img-&gt;uv_stride, &amp;chroma_mv[b],
                         ctx-&gt;subpixel_filters, coeffs, mbi, b + 20);
           u += 4;
           v += 4;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (b = 0; b &lt; 4; b++)
       {
           recon_1_block(u, u + reference_offset,
                         img-&gt;uv_stride, &amp;chroma_mv[b],
                         ctx-&gt;subpixel_filters, coeffs, mbi, b + 16);
           recon_1_block(v, v + reference_offset,
                         img-&gt;uv_stride, &amp;chroma_mv[b],
                         ctx-&gt;subpixel_filters, coeffs, mbi, b + 20);
           u += 4;
           v += 4;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (b &amp; 1)
           {
               u += 4 * img-&gt;uv_stride - 8;
               v += 4 * img-&gt;uv_stride - 8;
           }
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (b &amp; 1)
           {
               u += 4 * img-&gt;uv_stride - 8;
               v += 4 * img-&gt;uv_stride - 8;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_release_ref_frame(struct ref_cnt_img *rcimg)
   {
       if (rcimg)
       {
           assert(rcimg-&gt;ref_cnt);
           rcimg-&gt;ref_cnt--;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_release_ref_frame(struct ref_cnt_img *rcimg)
   {
       if (rcimg)
       {
           assert(rcimg-&gt;ref_cnt);
           rcimg-&gt;ref_cnt--;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_ref_frame(struct ref_cnt_img *rcimg)
   {
       rcimg-&gt;ref_cnt++;
       return rcimg;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_ref_frame(struct ref_cnt_img *rcimg)
   {
       rcimg-&gt;ref_cnt++;
       return rcimg;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
           if (frames[i].ref_cnt == 0)
           {
               frames[i].ref_cnt = 1;
               return &amp;frames[i];
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
           if (frames[i].ref_cnt == 0)
           {
               frames[i].ref_cnt = 1;
               return &amp;frames[i];
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       assert(0);
       return NULL;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       assert(0);
       return NULL;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   fixup_left(unsigned char        *predict,
              int                   width,
              int                   stride,
              unsigned int          row,
              enum prediction_mode  mode)
   {
       /* The left column of out-of-frame pixels is taken to be 129,
        * unless we&#39;re doing DC_PRED, in which case we duplicate the
        * above row, unless this is also row 0, in which case we use
        * 129.
        */
       unsigned char *left = predict - 1;
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   fixup_left(unsigned char        *predict,
              int                   width,
              int                   stride,
              unsigned int          row,
              enum prediction_mode  mode)
   {
       /* The left column of out-of-frame pixels is taken to be 129,
        * unless we&#39;re doing DC_PRED, in which case we duplicate the
        * above row, unless this is also row 0, in which case we use
        * 129.
        */
       unsigned char *left = predict - 1;
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode == DC_PRED &amp;&amp; row)
       {
           unsigned char *above = predict - stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode == DC_PRED &amp;&amp; row)
       {
           unsigned char *above = predict - stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; width; i++)
           {
               *left = above[i];
               left += stride;
           }
       }
       else
       {
           /* Need to re-set the above row, in case the above MB was
            * DC_PRED.
            */
           left -= stride;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; width; i++)
           {
               *left = above[i];
               left += stride;
           }
       }
       else
       {
           /* Need to re-set the above row, in case the above MB was
            * DC_PRED.
            */
           left -= stride;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = -1; i &lt; width; i++)
           {
               *left = 129;
               left += stride;
           }
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = -1; i &lt; width; i++)
           {
               *left = 129;
               left += stride;
           }
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   fixup_above(unsigned char        *predict,
               int                   width,
               int                   stride,
               unsigned int          col,
               enum prediction_mode  mode)
   {
       /* The above row of out-of-frame pixels is taken to be 127,
        * unless we&#39;re doing DC_PRED, in which case we duplicate the
        * left col, unless this is also col 0, in which case we use
        * 127.
        */
       unsigned char *above = predict - stride;
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   fixup_above(unsigned char        *predict,
               int                   width,
               int                   stride,
               unsigned int          col,
               enum prediction_mode  mode)
   {
       /* The above row of out-of-frame pixels is taken to be 127,
        * unless we&#39;re doing DC_PRED, in which case we duplicate the
        * left col, unless this is also col 0, in which case we use
        * 127.
        */
       unsigned char *above = predict - stride;
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode == DC_PRED &amp;&amp; col)
       {
           unsigned char *left = predict - 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode == DC_PRED &amp;&amp; col)
       {
           unsigned char *left = predict - 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; width; i++)
           {
               above[i] = *left;
               left += stride;
           }
       }
       else
           /* Need to re-set the left col, in case the last MB was
            * DC_PRED.
            */
           memset(above - 1, 127, width + 1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; width; i++)
           {
               above[i] = *left;
               left += stride;
           }
       }
       else
           /* Need to re-set the left col, in case the last MB was
            * DC_PRED.
            */
           memset(above - 1, 127, width + 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       memset(above + width, 127, 4); // for above-right subblock modes
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       memset(above + width, 127, 4); // for above-right subblock modes
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_init(struct vp8_decoder_ctx *ctx) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_init（结构vp8_解码器_ctx*ctx）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int i;
       unsigned char *this_frame_base;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       int i;
       unsigned char *this_frame_base;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           for (i = 0; i &lt; NUM_REF_FRAMES; i++)
           {
               unsigned int w = ctx-&gt;mb_cols * 16 + BORDER_PIXELS * 2;
               unsigned int h = ctx-&gt;mb_rows * 16 + BORDER_PIXELS * 2;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           for (i = 0; i &lt; NUM_REF_FRAMES; i++)
           {
               unsigned int w = ctx-&gt;mb_cols * 16 + BORDER_PIXELS * 2;
               unsigned int h = ctx-&gt;mb_rows * 16 + BORDER_PIXELS * 2;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               vpx_img_free(&amp;ctx-&gt;frame_strg[i].img);
               ctx-&gt;frame_strg[i].ref_cnt = 0;
               ctx-&gt;ref_frames[i] = NULL;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               vpx_img_free(&amp;ctx-&gt;frame_strg[i].img);
               ctx-&gt;frame_strg[i].ref_cnt = 0;
               ctx-&gt;ref_frames[i] = NULL;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
if (!vpx_img_alloc(&amp;ctx-&gt;frame_strg[i].img, IMG_FMT_I420, w, h, 16)) vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_MEM_ERROR, &#34;Failed to allocate %dx%d&#34; &#34; framebuffer&#34;, w, h);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
如果（！vpx\u img\u alloc（&amp;ctx-&gt;frame\u strg[i].img，img\u FMT\u I420，w，h，16））vpx\u内部错误（&amp;ctx-&gt;error，vpx\u CODEC\u MEM\u error，“无法分配%dx%d”“framebuffer”，w，h）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               vpx_img_set_rect(&amp;ctx-&gt;frame_strg[i].img, BORDER_PIXELS,
                   BORDER_PIXELS, ctx-&gt;frame_hdr.kf.w,
                   ctx-&gt;frame_hdr.kf.h);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               vpx_img_set_rect(&amp;ctx-&gt;frame_strg[i].img, BORDER_PIXELS,
                   BORDER_PIXELS, ctx-&gt;frame_hdr.kf.w,
                   ctx-&gt;frame_hdr.kf.h);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;frame_hdr.version)
               ctx-&gt;subpixel_filters = bilinear_filters;
           else
               ctx-&gt;subpixel_filters = sixtap_filters;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (ctx-&gt;frame_hdr.version)
               ctx-&gt;subpixel_filters = bilinear_filters;
           else
               ctx-&gt;subpixel_filters = sixtap_filters;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Find a free framebuffer to predict into */
       if (ctx-&gt;ref_frames[CURRENT_FRAME])
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Find a free framebuffer to predict into */
       if (ctx-&gt;ref_frames[CURRENT_FRAME])
           vp8_dixie_release_ref_frame(ctx-&gt;ref_frames[CURRENT_FRAME]);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;ref_frames[CURRENT_FRAME] =
           vp8_dixie_find_free_ref_frame(ctx-&gt;frame_strg);
       this_frame_base = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.img_data;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       ctx-&gt;ref_frames[CURRENT_FRAME] =
           vp8_dixie_find_free_ref_frame(ctx-&gt;frame_strg);
       this_frame_base = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.img_data;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate offsets to the other reference frames */
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
       {
           struct ref_cnt_img  *ref = ctx-&gt;ref_frames[i];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate offsets to the other reference frames */
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
       {
           struct ref_cnt_img  *ref = ctx-&gt;ref_frames[i];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ctx-&gt;ref_frame_offsets[i] =
               ref ? ref-&gt;img.img_data - this_frame_base : 0;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           ctx-&gt;ref_frame_offsets[i] =
               ref ? ref-&gt;img.img_data - this_frame_base : 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* TODO: No need to do this on every frame... */
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* TODO: No need to do this on every frame... */
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_predict_destroy(struct vp8_decoder_ctx *ctx)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_predict_destroy(struct vp8_decoder_ctx *ctx)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
       {
           vpx_img_free(&amp;ctx-&gt;frame_strg[i].img);
           ctx-&gt;frame_strg[i].ref_cnt = 0;
           ctx-&gt;ref_frames[i] = NULL;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; NUM_REF_FRAMES; i++)
       {
           vpx_img_free(&amp;ctx-&gt;frame_strg[i].img);
           ctx-&gt;frame_strg[i].ref_cnt = 0;
           ctx-&gt;ref_frames[i] = NULL;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_predict_process_row(struct vp8_decoder_ctx *ctx,
                                 unsigned int            row,
                                 unsigned int            start_col,
                                 unsigned int            num_cols)
   {
       struct img_index img;
       struct mb_info *mbi;
       unsigned int    col;
       short          *coeffs;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_predict_process_row(struct vp8_decoder_ctx *ctx,
                                 unsigned int            row,
                                 unsigned int            start_col,
                                 unsigned int            num_cols)
   {
       struct img_index img;
       struct mb_info *mbi;
       unsigned int    col;
       short          *coeffs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
       img.stride =
           ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       img.uv_stride =
           ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_U];
       img.y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       img.u = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_U];
       img.v = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_V];
       img.y += (img.stride * row + start_col) * 16;
       img.u += (img.uv_stride * row + start_col) * 8;
       img.v += (img.uv_stride * row + start_col) * 8;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
       coeffs = ctx-&gt;tokens[row &amp;
           (ctx-&gt;token_hdr.partitions - 1)].coeffs +
           25 * 16 * start_col;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Adjust pointers based on row, start_col */
       img.stride =
           ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_Y];
       img.uv_stride =
           ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.stride[PLANE_U];
       img.y = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_Y];
       img.u = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_U];
       img.v = ctx-&gt;ref_frames[CURRENT_FRAME]-&gt;img.planes[PLANE_V];
       img.y += (img.stride * row + start_col) * 16;
       img.u += (img.uv_stride * row + start_col) * 8;
       img.v += (img.uv_stride * row + start_col) * 8;
       mbi = ctx-&gt;mb_info_rows[row] + start_col;
       coeffs = ctx-&gt;tokens[row &amp;
           (ctx-&gt;token_hdr.partitions - 1)].coeffs +
           25 * 16 * start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Fix up the out-of-frame pixels */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Fix up the out-of-frame pixels */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (start_col == 0)
       {
           fixup_left(img.y, 16, img.stride, row, mbi-&gt;base.y_mode);
           fixup_left(img.u, 8, img.uv_stride, row, mbi-&gt;base.uv_mode);
           fixup_left(img.v, 8, img.uv_stride, row, mbi-&gt;base.uv_mode);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (start_col == 0)
       {
           fixup_left(img.y, 16, img.stride, row, mbi-&gt;base.y_mode);
           fixup_left(img.u, 8, img.uv_stride, row, mbi-&gt;base.uv_mode);
           fixup_left(img.v, 8, img.uv_stride, row, mbi-&gt;base.uv_mode);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (row == 0)
               *(img.y - img.stride - 1) = 127;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (row == 0)
               *(img.y - img.stride - 1) = 127;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           if (row == 0)
           {
               fixup_above(img.y, 16, img.stride, col,
                           mbi-&gt;base.y_mode);
               fixup_above(img.u, 8, img.uv_stride, col,
                           mbi-&gt;base.uv_mode);
               fixup_above(img.v, 8, img.uv_stride, col,
                           mbi-&gt;base.uv_mode);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           if (row == 0)
           {
               fixup_above(img.y, 16, img.stride, col,
                           mbi-&gt;base.y_mode);
               fixup_above(img.u, 8, img.uv_stride, col,
                           mbi-&gt;base.uv_mode);
               fixup_above(img.v, 8, img.uv_stride, col,
                           mbi-&gt;base.uv_mode);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode &lt;= B_PRED)
           {
               predict_intra_luma(img.y, img.stride, mbi, coeffs);
               predict_intra_chroma(img.u, img.v, img.uv_stride, mbi,
                                    coeffs);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.y_mode &lt;= B_PRED)
           {
               predict_intra_luma(img.y, img.stride, mbi, coeffs);
               predict_intra_chroma(img.u, img.v, img.uv_stride, mbi,
                                    coeffs);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           else
           {
               if (mbi-&gt;base.y_mode != SPLITMV) // &amp;&amp; != BPRED
                   fixup_dc_coeffs(mbi, coeffs);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           else
           {
               if (mbi-&gt;base.y_mode != SPLITMV) // &amp;&amp; != BPRED
                   fixup_dc_coeffs(mbi, coeffs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (mbi-&gt;base.need_mc_border)
                   predict_inter_emulated_edge(ctx, &amp;img, coeffs, mbi,
                                               col, row);
               else
                   predict_inter(ctx, &amp;img, coeffs, mbi);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (mbi-&gt;base.need_mc_border)
                   predict_inter_emulated_edge(ctx, &amp;img, coeffs, mbi,
                                               col, row);
               else
                   predict_inter(ctx, &amp;img, coeffs, mbi);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Advance to the next macroblock */
           mbi++;
           img.y += 16;
           img.u += 8;
           img.v += 8;
           coeffs += 25 * 16;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Advance to the next macroblock */
           mbi++;
           img.y += 16;
           img.u += 8;
           img.v += 8;
           coeffs += 25 * 16;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (col == ctx-&gt;mb_cols)
       {
           /* Extend the last row by four pixels for intra-prediction.
            * This will be propagated later by copy_down.
            */
           uint32_t *extend = (uint32_t *)(img.y + 15 * img.stride);
           uint32_t  val = 0x01010101 * img.y[-1 + 15 * img.stride];
           *extend = val;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (col == ctx-&gt;mb_cols)
       {
           /* Extend the last row by four pixels for intra-prediction.
            * This will be propagated later by copy_down.
            */
           uint32_t *extend = (uint32_t *)(img.y + 15 * img.stride);
           uint32_t  val = 0x01010101 * img.y[-1 + 15 * img.stride];
           *extend = val;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.15. predict.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.15. 预测
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef PREDICT_H
   #define PREDICT_H
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef PREDICT_H
   #define PREDICT_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_init（结构vp8_解码器_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无效vp8_dixie_预测_销毁（结构vp8_解码器_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_process_row(struct vp8_decoder_ctx *ctx, unsigned int row, unsigned int start_col, unsigned int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_predict_process_row（结构vp8_decoder_ctx*ctx，无符号整数行，无符号整数起始列，无符号整数列）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_release_ref_frame(struct ref_cnt_img *rcimg);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无效vp8释放参考帧（结构参考cnt img*rcimg）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_ref_frame(struct ref_cnt_img *rcimg);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_ref_frame(struct ref_cnt_img *rcimg);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct ref_cnt_img *
   vp8_dixie_find_free_ref_frame(struct ref_cnt_img *frames);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.16. tokens.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.16. 代币
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;dixie.h&#34;
   #include &#34;tokens.h&#34;
   #include &lt;stdlib.h&gt;
   #include &lt;string.h&gt;
   #include &lt;malloc.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #include &#34;vpx_codec_internal.h&#34;
   #include &#34;dixie.h&#34;
   #include &#34;tokens.h&#34;
   #include &lt;stdlib.h&gt;
   #include &lt;string.h&gt;
   #include &lt;malloc.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       EOB_CONTEXT_NODE,
       ZERO_CONTEXT_NODE,
       ONE_CONTEXT_NODE,
       LOW_VAL_CONTEXT_NODE,
       TWO_CONTEXT_NODE,
       THREE_CONTEXT_NODE,
       HIGH_LOW_CONTEXT_NODE,
       CAT_ONE_CONTEXT_NODE,
       CAT_THREEFOUR_CONTEXT_NODE,
       CAT_THREE_CONTEXT_NODE,
       CAT_FIVE_CONTEXT_NODE
   };
   enum
   {
       ZERO_TOKEN,
       ONE_TOKEN,
       TWO_TOKEN,
       THREE_TOKEN,
       FOUR_TOKEN,
       DCT_VAL_CATEGORY1,
       DCT_VAL_CATEGORY2,
       DCT_VAL_CATEGORY3,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum
   {
       EOB_CONTEXT_NODE,
       ZERO_CONTEXT_NODE,
       ONE_CONTEXT_NODE,
       LOW_VAL_CONTEXT_NODE,
       TWO_CONTEXT_NODE,
       THREE_CONTEXT_NODE,
       HIGH_LOW_CONTEXT_NODE,
       CAT_ONE_CONTEXT_NODE,
       CAT_THREEFOUR_CONTEXT_NODE,
       CAT_THREE_CONTEXT_NODE,
       CAT_FIVE_CONTEXT_NODE
   };
   enum
   {
       ZERO_TOKEN,
       ONE_TOKEN,
       TWO_TOKEN,
       THREE_TOKEN,
       FOUR_TOKEN,
       DCT_VAL_CATEGORY1,
       DCT_VAL_CATEGORY2,
       DCT_VAL_CATEGORY3,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       DCT_VAL_CATEGORY4,
       DCT_VAL_CATEGORY5,
       DCT_VAL_CATEGORY6,
       DCT_EOB_TOKEN,
       MAX_ENTROPY_TOKENS
   };
   struct extrabits
   {
       short         min_val;
       short         length;
       unsigned char probs[12];
   };
   static const unsigned int left_context_index[25] =
   {
       0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
       4, 4, 5, 5, 6, 6, 7, 7, 8
   };
   static const unsigned int above_context_index[25] =
   {
       0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,
       4, 5, 4, 5, 6, 7, 6, 7, 8
   };
   #define X(n) ((n) * PREV_COEFF_CONTEXTS * ENTROPY_NODES)
   static const unsigned int bands_x[16] =
   {
       X(0), X(1), X(2), X(3), X(6), X(4), X(5), X(6),
       X(6), X(6), X(6), X(6), X(6), X(6), X(6), X(7)
   };
   #undef X
   static const struct extrabits extrabits[MAX_ENTROPY_TOKENS] =
   {
       { 0, -1, {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //ZERO_TOKEN
       { 1, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //ONE_TOKEN
       { 2, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //TWO_TOKEN
       { 3, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //THREE_TOKEN
       { 4, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //FOUR_TOKEN
       { 5, 0,  {159,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY1
       { 7, 1,  {145, 165,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY2
       {11, 2,  {140, 148, 173,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY3
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       DCT_VAL_CATEGORY4,
       DCT_VAL_CATEGORY5,
       DCT_VAL_CATEGORY6,
       DCT_EOB_TOKEN,
       MAX_ENTROPY_TOKENS
   };
   struct extrabits
   {
       short         min_val;
       short         length;
       unsigned char probs[12];
   };
   static const unsigned int left_context_index[25] =
   {
       0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,
       4, 4, 5, 5, 6, 6, 7, 7, 8
   };
   static const unsigned int above_context_index[25] =
   {
       0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,
       4, 5, 4, 5, 6, 7, 6, 7, 8
   };
   #define X(n) ((n) * PREV_COEFF_CONTEXTS * ENTROPY_NODES)
   static const unsigned int bands_x[16] =
   {
       X(0), X(1), X(2), X(3), X(6), X(4), X(5), X(6),
       X(6), X(6), X(6), X(6), X(6), X(6), X(6), X(7)
   };
   #undef X
   static const struct extrabits extrabits[MAX_ENTROPY_TOKENS] =
   {
       { 0, -1, {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //ZERO_TOKEN
       { 1, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //ONE_TOKEN
       { 2, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //TWO_TOKEN
       { 3, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //THREE_TOKEN
       { 4, 0,  {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //FOUR_TOKEN
       { 5, 0,  {159,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY1
       { 7, 1,  {145, 165,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY2
       {11, 2,  {140, 148, 173,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY3
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       {19, 3,  {135, 140, 155, 176,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY4
       {35, 4,  {130, 134, 141, 157, 180,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY5
       {67, 10, {129, 130, 133, 140, 153, 177,
                 196, 230, 243, 254, 254,   0 } }, //DCT_VAL_CATEGORY6
       { 0, -1, {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, // EOB TOKEN
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       {19, 3,  {135, 140, 155, 176,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY4
       {35, 4,  {130, 134, 141, 157, 180,   0,
                   0,   0,   0,   0,   0,   0 } }, //DCT_VAL_CATEGORY5
       {67, 10, {129, 130, 133, 140, 153, 177,
                 196, 230, 243, 254, 254,   0 } }, //DCT_VAL_CATEGORY6
       { 0, -1, {  0,   0,   0,   0,   0,   0,
                   0,   0,   0,   0,   0,   0 } }, // EOB TOKEN
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned int zigzag[16] =
   {
       0,  1,  4,  8,  5,  2,  3,  6,  9, 12, 13, 10,  7, 11, 14, 15
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const unsigned int zigzag[16] =
   {
       0,  1,  4,  8,  5,  2,  3,  6,  9, 12, 13, 10,  7, 11, 14, 15
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_AND_APPLYSIGN(value_to_sign) \
       v = (bool_get_bit(bool) ? -value_to_sign \
                               : value_to_sign) * dqf[!!c];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_AND_APPLYSIGN(value_to_sign) \
       v = (bool_get_bit(bool) ? -value_to_sign \
                               : value_to_sign) * dqf[!!c];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_AND_BRANCH_IF_ZERO(probability,branch) \
       if (!bool_get(bool, probability)) goto branch;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_AND_BRANCH_IF_ZERO(probability,branch) \
       if (!bool_get(bool, probability)) goto branch;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_AND_LOOP_IF_ZERO(probability,branch) \
       if (!bool_get(bool, probability)) \
       { \
           prob = type_probs; \
           if (c&lt;15) {\
               ++c; \
               prob += bands_x[c]; \
               goto branch; \
           }\
           else \
               goto BLOCK_FINISHED; /* for malformed input */\
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_AND_LOOP_IF_ZERO(probability,branch) \
       if (!bool_get(bool, probability)) \
       { \
           prob = type_probs; \
           if (c&lt;15) {\
               ++c; \
               prob += bands_x[c]; \
               goto branch; \
           }\
           else \
               goto BLOCK_FINISHED; /* for malformed input */\
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val) \
       DECODE_AND_APPLYSIGN(val) \
       prob = type_probs + (ENTROPY_NODES*2); \
       if (c &lt; 15){\
           b_tokens[zigzag[c]] = v; \
           ++c; \
           goto DO_WHILE; }\
       b_tokens[zigzag[15]] = v; \
       goto BLOCK_FINISHED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val) \
       DECODE_AND_APPLYSIGN(val) \
       prob = type_probs + (ENTROPY_NODES*2); \
       if (c &lt; 15){\
           b_tokens[zigzag[c]] = v; \
           ++c; \
           goto DO_WHILE; }\
       b_tokens[zigzag[15]] = v; \
       goto BLOCK_FINISHED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_EXTRABIT_AND_ADJUST_VAL(t,bits_count)\
       val += bool_get(bool, extrabits[t].probs[bits_count]) &lt;&lt; \
       bits_count;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define DECODE_EXTRABIT_AND_ADJUST_VAL(t,bits_count)\
       val += bool_get(bool, extrabits[t].probs[bits_count]) &lt;&lt; \
       bits_count;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   decode_mb_tokens(struct bool_decoder  *bool,
                    token_entropy_ctx_t   left,
                    token_entropy_ctx_t   above,
                    short                *tokens,
                    enum prediction_mode  mode,
                    coeff_probs_table_t   probs,
                    short                 factor[TOKEN_BLOCK_TYPES][2])
   {
       int            i, stop, type;
       int            c, t, v;
       int            val, bits_count;
       int            eob_mask;
       short         *b_tokens;   // tokens for this block
       unsigned char *type_probs; // probabilities for this block type
       unsigned char *prob;
       short         *dqf;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static int
   decode_mb_tokens(struct bool_decoder  *bool,
                    token_entropy_ctx_t   left,
                    token_entropy_ctx_t   above,
                    short                *tokens,
                    enum prediction_mode  mode,
                    coeff_probs_table_t   probs,
                    short                 factor[TOKEN_BLOCK_TYPES][2])
   {
       int            i, stop, type;
       int            c, t, v;
       int            val, bits_count;
       int            eob_mask;
       short         *b_tokens;   // tokens for this block
       unsigned char *type_probs; // probabilities for this block type
       unsigned char *prob;
       short         *dqf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
eob_mask = 0;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
eob_掩码=0；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode != B_PRED &amp;&amp; mode != SPLITMV)
       {
           i = 24;
           stop = 24;
           type = 1;
           b_tokens = tokens + 24 * 16;
           dqf = factor[TOKEN_BLOCK_Y2];
       }
       else
       {
           i = 0;
           stop = 16;
           type = 3;
           b_tokens = tokens;
           dqf = factor[TOKEN_BLOCK_Y1];
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode != B_PRED &amp;&amp; mode != SPLITMV)
       {
           i = 24;
           stop = 24;
           type = 1;
           b_tokens = tokens + 24 * 16;
           dqf = factor[TOKEN_BLOCK_Y2];
       }
       else
       {
           i = 0;
           stop = 16;
           type = 3;
           b_tokens = tokens;
           dqf = factor[TOKEN_BLOCK_Y1];
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Save a pointer to the coefficient probs for the current type.
        * Need to repeat this whenever type changes.
        */
       type_probs = probs[type][0][0];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Save a pointer to the coefficient probs for the current type.
        * Need to repeat this whenever type changes.
        */
       type_probs = probs[type][0][0];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   BLOCK_LOOP:
       t = left[left_context_index[i]] + above[above_context_index[i]];
       c = !type; /* all blocks start at 0 except type 0, which starts
                   * at 1. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   BLOCK_LOOP:
       t = left[left_context_index[i]] + above[above_context_index[i]];
       c = !type; /* all blocks start at 0 except type 0, which starts
                   * at 1. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       prob = type_probs;
       prob += t * ENTROPY_NODES;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       prob = type_probs;
       prob += t * ENTROPY_NODES;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   DO_WHILE:
       prob += bands_x[c];
       DECODE_AND_BRANCH_IF_ZERO(prob[EOB_CONTEXT_NODE],
         BLOCK_FINISHED);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   DO_WHILE:
       prob += bands_x[c];
       DECODE_AND_BRANCH_IF_ZERO(prob[EOB_CONTEXT_NODE],
         BLOCK_FINISHED);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CHECK_0_:
       DECODE_AND_LOOP_IF_ZERO(prob[ZERO_CONTEXT_NODE], CHECK_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[ONE_CONTEXT_NODE],
                                 ONE_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[LOW_VAL_CONTEXT_NODE],
                                 LOW_VAL_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[HIGH_LOW_CONTEXT_NODE],
                                 HIGH_LOW_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREEFOUR_CONTEXT_NODE],
                                 CAT_THREEFOUR_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_FIVE_CONTEXT_NODE],
                                 CAT_FIVE_CONTEXT_NODE_0_);
       val = extrabits[DCT_VAL_CATEGORY6].min_val;
       bits_count = extrabits[DCT_VAL_CATEGORY6].length;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CHECK_0_:
       DECODE_AND_LOOP_IF_ZERO(prob[ZERO_CONTEXT_NODE], CHECK_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[ONE_CONTEXT_NODE],
                                 ONE_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[LOW_VAL_CONTEXT_NODE],
                                 LOW_VAL_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[HIGH_LOW_CONTEXT_NODE],
                                 HIGH_LOW_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREEFOUR_CONTEXT_NODE],
                                 CAT_THREEFOUR_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_FIVE_CONTEXT_NODE],
                                 CAT_FIVE_CONTEXT_NODE_0_);
       val = extrabits[DCT_VAL_CATEGORY6].min_val;
       bits_count = extrabits[DCT_VAL_CATEGORY6].length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       do
       {
           DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY6,
             bits_count);
           bits_count --;
       }
       while (bits_count &gt;= 0);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       do
       {
           DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY6,
             bits_count);
           bits_count --;
       }
       while (bits_count &gt;= 0);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
解码、签名、写入、校验、退出（val）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_FIVE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY5].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 4);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 3);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_FIVE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY5].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 4);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 3);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY5, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_THREEFOUR_CONTEXT_NODE_0_:
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREE_CONTEXT_NODE],
                                 CAT_THREE_CONTEXT_NODE_0_);
       val = extrabits[DCT_VAL_CATEGORY4].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 3);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_THREEFOUR_CONTEXT_NODE_0_:
       DECODE_AND_BRANCH_IF_ZERO(prob[CAT_THREE_CONTEXT_NODE],
                                 CAT_THREE_CONTEXT_NODE_0_);
       val = extrabits[DCT_VAL_CATEGORY4].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 3);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY4, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_THREE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY3].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_THREE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY3].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 2);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY3, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HIGH_LOW_CONTEXT_NODE_0_: DECODE_AND_BRANCH_IF_ZERO(prob[CAT_ONE_CONTEXT_NODE], CAT_ONE_CONTEXT_NODE_0_);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
高\u低\u上下文\u节点\u 0 \u：如果\u为零，则解码\u和\u分支\u（prob[CAT\u ONE\u CONTEXT\u NODE]，CAT\u ONE\u CONTEXT\u节点\u 0）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       val = extrabits[DCT_VAL_CATEGORY2].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       val = extrabits[DCT_VAL_CATEGORY2].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 1);
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY2, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_ONE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY1].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY1, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CAT_ONE_CONTEXT_NODE_0_:
       val = extrabits[DCT_VAL_CATEGORY1].min_val;
       DECODE_EXTRABIT_AND_ADJUST_VAL(DCT_VAL_CATEGORY1, 0);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(val);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LOW_VAL_CONTEXT_NODE_0_:
       DECODE_AND_BRANCH_IF_ZERO(prob[TWO_CONTEXT_NODE],
                                 TWO_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[THREE_CONTEXT_NODE],
                                 THREE_CONTEXT_NODE_0_);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(4);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   LOW_VAL_CONTEXT_NODE_0_:
       DECODE_AND_BRANCH_IF_ZERO(prob[TWO_CONTEXT_NODE],
                                 TWO_CONTEXT_NODE_0_);
       DECODE_AND_BRANCH_IF_ZERO(prob[THREE_CONTEXT_NODE],
                                 THREE_CONTEXT_NODE_0_);
       DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(4);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
THREE_CONTEXT_NODE_0_: DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(3);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
三个上下文节点：解码、签名、写入、校验、退出（3）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TWO_CONTEXT_NODE_0_: DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(2);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
两个\u上下文\u节点\u 0\u：解码\u签名\u写入\u系数\u和\u检查\u退出（2）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ONE_CONTEXT_NODE_0_:
       DECODE_AND_APPLYSIGN(1);
       prob = type_probs + ENTROPY_NODES;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ONE_CONTEXT_NODE_0_:
       DECODE_AND_APPLYSIGN(1);
       prob = type_probs + ENTROPY_NODES;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (c &lt; 15)
       {
           b_tokens[zigzag[c]] = v;
           ++c;
           goto DO_WHILE;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (c &lt; 15)
       {
           b_tokens[zigzag[c]] = v;
           ++c;
           goto DO_WHILE;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       b_tokens[zigzag[15]] = v;
   BLOCK_FINISHED:
       eob_mask |= (c &gt; 1) &lt;&lt; i;
       t = (c != !type);   // any non-zero data?
       eob_mask |= t &lt;&lt; 31;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       b_tokens[zigzag[15]] = v;
   BLOCK_FINISHED:
       eob_mask |= (c &gt; 1) &lt;&lt; i;
       t = (c != !type);   // any non-zero data?
       eob_mask |= t &lt;&lt; 31;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       left[left_context_index[i]] = above[above_context_index[i]] = t;
       b_tokens += 16;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       left[left_context_index[i]] = above[above_context_index[i]] = t;
       b_tokens += 16;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       i++;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       i++;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (i &lt; stop) goto BLOCK_LOOP;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（i&lt;stop）转到BLOCK_循环；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (i == 25)
       {
           type = 0;
           i = 0;
           stop = 16;
           type_probs = probs[type][0][0];
           b_tokens = tokens;
           dqf = factor[TOKEN_BLOCK_Y1];
           goto BLOCK_LOOP;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (i == 25)
       {
           type = 0;
           i = 0;
           stop = 16;
           type_probs = probs[type][0][0];
           b_tokens = tokens;
           dqf = factor[TOKEN_BLOCK_Y1];
           goto BLOCK_LOOP;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (i == 16)
       {
           type = 2;
           type_probs = probs[type][0][0];
           stop = 24;
           dqf = factor[TOKEN_BLOCK_UV];
           goto BLOCK_LOOP;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (i == 16)
       {
           type = 2;
           type_probs = probs[type][0][0];
           stop = 24;
           dqf = factor[TOKEN_BLOCK_UV];
           goto BLOCK_LOOP;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return eob_mask;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return eob_mask;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   reset_row_context(token_entropy_ctx_t *left)
   {
       memset(left, 0, sizeof(*left));
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   reset_row_context(token_entropy_ctx_t *left)
   {
       memset(left, 0, sizeof(*left));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   reset_above_context(token_entropy_ctx_t *above, unsigned int cols)
   {
       memset(above, 0, cols * sizeof(*above));
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   reset_above_context(token_entropy_ctx_t *above, unsigned int cols)
   {
       memset(above, 0, cols * sizeof(*above));
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   reset_mb_context(token_entropy_ctx_t  *left,
                    token_entropy_ctx_t  *above,
                    enum prediction_mode  mode)
   {
       /* Reset the macroblock context on the left and right.  We have
        * to preserve the context of the second order block if this mode
        * would not have updated it.
        */
       memset(left, 0, sizeof((*left)[0]) * 8);
       memset(above, 0, sizeof((*above)[0]) * 8);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void
   reset_mb_context(token_entropy_ctx_t  *left,
                    token_entropy_ctx_t  *above,
                    enum prediction_mode  mode)
   {
       /* Reset the macroblock context on the left and right.  We have
        * to preserve the context of the second order block if this mode
        * would not have updated it.
        */
       memset(left, 0, sizeof((*left)[0]) * 8);
       memset(above, 0, sizeof((*above)[0]) * 8);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode != B_PRED &amp;&amp; mode != SPLITMV)
       {
           (*left)[8] = 0;
           (*above)[8] = 0;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (mode != B_PRED &amp;&amp; mode != SPLITMV)
       {
           (*left)[8] = 0;
           (*above)[8] = 0;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,
                                unsigned int            partition,
                                unsigned int            row,
                                unsigned int            start_col,
                                unsigned int            num_cols)
   {
       struct token_decoder *tokens = &amp;ctx-&gt;tokens[partition];
       short              coeffs = tokens-&gt;coeffs + 25 * 16 * start_col;
       unsigned int       col;
       token_entropy_ctx_t  *above = ctx-&gt;above_token_entropy_ctx
                                     + start_col;
       token_entropy_ctx_t  *left = &amp;tokens-&gt;left_token_entropy_ctx;
       struct mb_info       *mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx,
                                unsigned int            partition,
                                unsigned int            row,
                                unsigned int            start_col,
                                unsigned int            num_cols)
   {
       struct token_decoder *tokens = &amp;ctx-&gt;tokens[partition];
       short              coeffs = tokens-&gt;coeffs + 25 * 16 * start_col;
       unsigned int       col;
       token_entropy_ctx_t  *above = ctx-&gt;above_token_entropy_ctx
                                     + start_col;
       token_entropy_ctx_t  *left = &amp;tokens-&gt;left_token_entropy_ctx;
       struct mb_info       *mbi = ctx-&gt;mb_info_rows[row] + start_col;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (row == 0)
           reset_above_context(above, num_cols);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (row == 0)
           reset_above_context(above, num_cols);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (start_col == 0)
           reset_row_context(left);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (start_col == 0)
           reset_row_context(left);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           memset(coeffs, 0, 25 * 16 * sizeof(short));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (col = start_col; col &lt; start_col + num_cols; col++)
       {
           memset(coeffs, 0, 25 * 16 * sizeof(short));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.skip_coeff)
           {
               reset_mb_context(left, above, mbi-&gt;base.y_mode);
               mbi-&gt;base.eob_mask = 0;
           }
           else
           {
               struct dequant_factors *dqf;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (mbi-&gt;base.skip_coeff)
           {
               reset_mb_context(left, above, mbi-&gt;base.y_mode);
               mbi-&gt;base.eob_mask = 0;
           }
           else
           {
               struct dequant_factors *dqf;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               dqf = ctx-&gt;dequant_factors  + mbi-&gt;base.segment_id;
               mbi-&gt;base.eob_mask =
                   decode_mb_tokens(&amp;tokens-&gt;bool,
                                    *left, *above,
                                    coeffs,
                                    mbi-&gt;base.y_mode,
                                    ctx-&gt;entropy_hdr.coeff_probs,
                                    dqf-&gt;factor);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               dqf = ctx-&gt;dequant_factors  + mbi-&gt;base.segment_id;
               mbi-&gt;base.eob_mask =
                   decode_mb_tokens(&amp;tokens-&gt;bool,
                                    *left, *above,
                                    coeffs,
                                    mbi-&gt;base.y_mode,
                                    ctx-&gt;entropy_hdr.coeff_probs,
                                    dqf-&gt;factor);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           above++;
           mbi++;
           coeffs += 25 * 16;
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           above++;
           mbi++;
           coeffs += 25 * 16;
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_tokens_init(struct vp8_decoder_ctx *ctx)
   {
       unsigned int  partitions = ctx-&gt;token_hdr.partitions;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_tokens_init(struct vp8_decoder_ctx *ctx)
   {
       unsigned int  partitions = ctx-&gt;token_hdr.partitions;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           unsigned int i;
           unsigned int coeff_row_sz =
               ctx-&gt;mb_cols * 25 * 16 * sizeof(short);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (ctx-&gt;frame_hdr.frame_size_updated)
       {
           unsigned int i;
           unsigned int coeff_row_sz =
               ctx-&gt;mb_cols * 25 * 16 * sizeof(short);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; partitions; i++)
           {
               free(ctx-&gt;tokens[i].coeffs);
               ctx-&gt;tokens[i].coeffs = memalign(16, coeff_row_sz);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           for (i = 0; i &lt; partitions; i++)
           {
               free(ctx-&gt;tokens[i].coeffs);
               ctx-&gt;tokens[i].coeffs = memalign(16, coeff_row_sz);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (!ctx-&gt;tokens[i].coeffs)
                   vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_MEM_ERROR,
                                      NULL);
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (!ctx-&gt;tokens[i].coeffs)
                   vpx_internal_error(&amp;ctx-&gt;error, VPX_CODEC_MEM_ERROR,
                                      NULL);
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           free(ctx-&gt;above_token_entropy_ctx);
           ctx-&gt;above_token_entropy_ctx =
               calloc(ctx-&gt;mb_cols,
               sizeof(*ctx-&gt;above_token_entropy_ctx));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           free(ctx-&gt;above_token_entropy_ctx);
           ctx-&gt;above_token_entropy_ctx =
               calloc(ctx-&gt;mb_cols,
               sizeof(*ctx-&gt;above_token_entropy_ctx));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!ctx-&gt;above_token_entropy_ctx)
               vpx_internal_error(&amp;ctx-&gt;error,
               VPX_CODEC_MEM_ERROR, NULL);
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (!ctx-&gt;above_token_entropy_ctx)
               vpx_internal_error(&amp;ctx-&gt;error,
               VPX_CODEC_MEM_ERROR, NULL);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_tokens_destroy(struct vp8_decoder_ctx *ctx)
   {
       int i;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void
   vp8_dixie_tokens_destroy(struct vp8_decoder_ctx *ctx)
   {
       int i;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; MAX_PARTITIONS; i++)
           free(ctx-&gt;tokens[i].coeffs);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       for (i = 0; i &lt; MAX_PARTITIONS; i++)
           free(ctx-&gt;tokens[i].coeffs);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       free(ctx-&gt;above_token_entropy_ctx);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       free(ctx-&gt;above_token_entropy_ctx);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.17. tokens.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.17. 代币
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef TOKENS_H
   #define TOKENS_H
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
   #ifndef TOKENS_H
   #define TOKENS_H
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_init(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_令牌_init（结构vp8_解码器_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_destroy(struct vp8_decoder_ctx *ctx);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作废vp8_dixie_令牌_销毁（结构vp8_解码器_ctx*ctx）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_process_row(struct vp8_decoder_ctx *ctx, unsigned int partition, unsigned int row, unsigned int start_col, unsigned int num_cols);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void vp8_dixie_tokens_process_row（结构vp8_decoder_ctx*ctx，无符号整数分区，无符号整数行，无符号整数起始列，无符号整数列）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.18. vp8_prob_data.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.18. vp8_prob_data.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_coeff_entropy_update_probs[BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS]
   [ENTROPY_NODES] =
   {
       {
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},
               {249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},
               {234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_coeff_entropy_update_probs[BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS]
   [ENTROPY_NODES] =
   {
       {
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255},
               {249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255},
               {234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},
               {250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
       {
           {
               {217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},
               {234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255},
           },
           {
               {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255},
               {250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
       {
           {
               {217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255},
               {234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255},
           },
           {
               {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
       {
           {
               {186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},
               {234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},
               {251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255},
           },
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
       {
           {
               {186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255},
               {234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255},
               {251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255},
           },
           {
               {255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
       {
           {
               {248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},
               {248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},
               {248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
       {
           {
               {248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255},
               {248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255},
               {248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255},
           },
           {
               {255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255},
               {250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           {
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
               {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255},
           },
       },
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char k_default_y_mode_probs [] = { 112, 86, 140, 37};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态常量无符号字符k_default_y_mode_probs[]={112,86,140,37}；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static const unsigned char k_default_uv_mode_probs [] = { 162, 101, 204};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态常量无符号字符k_default_uv_mode_probs[]={162101204}；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_default_coeff_probs [BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS][ENTROPY_NODES] =
   {
       { /* block type 0 */
           { /* coeff band 0 */
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 1 */
               { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},
               { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},
               { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128}
           },
           { /* coeff band 2 */
               {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},
               { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},
               {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128}
           },
           { /* coeff band 3 */
               {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},
               { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},
               {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128}
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_default_coeff_probs [BLOCK_TYPES][COEFF_BANDS]
   [PREV_COEFF_CONTEXTS][ENTROPY_NODES] =
   {
       { /* block type 0 */
           { /* coeff band 0 */
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 1 */
               { 253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128},
               { 189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128},
               { 106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128}
           },
           { /* coeff band 2 */
               {   1,  98, 248, 255, 236, 226, 255, 255, 128, 128, 128},
               { 181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128},
               {  78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128}
           },
           { /* coeff band 3 */
               {   1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128},
               { 184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128},
               {  77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 4 */
               {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},
               { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},
               {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},
               { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},
               { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},
               { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},
               {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128}
           },
           { /* coeff band 7 */
               {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 1 */
           { /* coeff band 0 */
               { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},
               { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},
               {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128}
           },
           { /* coeff band 1 */
               {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},
               { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},
               {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128}
           },
           { /* coeff band 2 */
               {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},
               {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},
               {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128}
           },
           { /* coeff band 3 */
               {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},
               { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},
               {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128}
           },
           { /* coeff band 4 */
               {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},
               {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},
               {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128}
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 4 */
               {   1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128},
               { 170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128},
               {  37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128},
               { 207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128},
               { 102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128},
               { 177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128},
               {  80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128}
           },
           { /* coeff band 7 */
               {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 246,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 1 */
           { /* coeff band 0 */
               { 198,  35, 237, 223, 193, 187, 162, 160, 145, 155,  62},
               { 131,  45, 198, 221, 172, 176, 220, 157, 252, 221,   1},
               {  68,  47, 146, 208, 149, 167, 221, 162, 255, 223, 128}
           },
           { /* coeff band 1 */
               {   1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128},
               { 184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128},
               {  81,  99, 181, 242, 176, 190, 249, 202, 255, 255, 128}
           },
           { /* coeff band 2 */
               {   1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128},
               {  99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128},
               {  23,  91, 163, 242, 170, 187, 247, 210, 255, 255, 128}
           },
           { /* coeff band 3 */
               {   1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128},
               { 109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128},
               {  44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128}
           },
           { /* coeff band 4 */
               {   1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128},
               {  94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128},
               {  22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 5 */
               {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},
               { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},
               {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},
               { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},
               {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128}
           },
           { /* coeff band 7 */
               {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},
               { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},
               { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 2 */
           { /* coeff band 0 */
               { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},
               { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},
               {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128}
           },
           { /* coeff band 1 */
               {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},
               { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},
               { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128}
           },
           { /* coeff band 2 */
               {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},
               { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},
               {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128}
           },
           { /* coeff band 3 */
               {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},
               { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},
               { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 4 */
               {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},
               { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},
               { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 5 */
               {   1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128},
               { 124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128},
               {  35,  77, 181, 251, 193, 211, 255, 205, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128},
               { 121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128},
               {  45,  99, 188, 251, 195, 217, 255, 224, 128, 128, 128}
           },
           { /* coeff band 7 */
               {   1,   1, 251, 255, 213, 255, 128, 128, 128, 128, 128},
               { 203,   1, 248, 255, 255, 128, 128, 128, 128, 128, 128},
               { 137,   1, 177, 255, 224, 255, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 2 */
           { /* coeff band 0 */
               { 253,   9, 248, 251, 207, 208, 255, 192, 128, 128, 128},
               { 175,  13, 224, 243, 193, 185, 249, 198, 255, 255, 128},
               {  73,  17, 171, 221, 161, 179, 236, 167, 255, 234, 128}
           },
           { /* coeff band 1 */
               {   1,  95, 247, 253, 212, 183, 255, 255, 128, 128, 128},
               { 239,  90, 244, 250, 211, 209, 255, 255, 128, 128, 128},
               { 155,  77, 195, 248, 188, 195, 255, 255, 128, 128, 128}
           },
           { /* coeff band 2 */
               {   1,  24, 239, 251, 218, 219, 255, 205, 128, 128, 128},
               { 201,  51, 219, 255, 196, 186, 128, 128, 128, 128, 128},
               {  69,  46, 190, 239, 201, 218, 255, 228, 128, 128, 128}
           },
           { /* coeff band 3 */
               {   1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128},
               { 223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128},
               { 141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 4 */
               {   1,  16, 248, 255, 255, 128, 128, 128, 128, 128, 128},
               { 190,  36, 230, 255, 236, 255, 128, 128, 128, 128, 128},
               { 149,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 6 */
               {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},
               { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},
               {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 7 */
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 3 */
           { /* coeff band 0 */
               { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},
               { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},
               {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128}
           },
           { /* coeff band 1 */
               {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},
               { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},
               {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128}
           },
           { /* coeff band 2 */
               {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},
               { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},
               {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128}
           },
           { /* coeff band 3 */
               {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},
               { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},
               {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128}
           },
           { /* coeff band 4 */
               {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},
               { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},
               {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},
               { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},
               {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},
               { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},
               {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128}
           },
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 6 */
               {   1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128},
               { 213,  62, 250, 255, 255, 128, 128, 128, 128, 128, 128},
               {  55,  93, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           },
           { /* coeff band 7 */
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128},
               { 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       },
       { /* block type 3 */
           { /* coeff band 0 */
               { 202,  24, 213, 235, 186, 191, 220, 160, 240, 175, 255},
               { 126,  38, 182, 232, 169, 184, 228, 174, 255, 187, 128},
               {  61,  46, 138, 219, 151, 178, 240, 170, 255, 216, 128}
           },
           { /* coeff band 1 */
               {   1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128},
               { 166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128},
               {  39,  77, 162, 232, 172, 180, 245, 178, 255, 255, 128}
           },
           { /* coeff band 2 */
               {   1,  52, 220, 246, 198, 199, 249, 220, 255, 255, 128},
               { 124,  74, 191, 243, 183, 193, 250, 221, 255, 255, 128},
               {  24,  71, 130, 219, 154, 170, 243, 182, 255, 255, 128}
           },
           { /* coeff band 3 */
               {   1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128},
               { 149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128},
               {  28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128}
           },
           { /* coeff band 4 */
               {   1,  81, 230, 252, 204, 203, 255, 192, 128, 128, 128},
               { 123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128},
               {  20,  95, 153, 243, 164, 173, 255, 203, 128, 128, 128}
           },
           { /* coeff band 5 */
               {   1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128},
               { 168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128},
               {  47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128}
           },
           { /* coeff band 6 */
               {   1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128},
               { 141,  84, 213, 252, 201, 202, 255, 219, 128, 128, 128},
               {  42,  80, 160, 240, 162, 185, 255, 205, 128, 128, 128}
           },
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 7 */
               {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           { /* coeff band 7 */
               {   1,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 244,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128},
               { 238,   1, 255, 128, 128, 128, 128, 128, 128, 128, 128}
           }
       }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_mv_entropy_update_probs[2][MV_PROB_CNT] =
   {
       {
           237,
           246,
           253, 253, 254, 254, 254, 254, 254,
           254, 254, 254, 254, 254, 250, 250, 252, 254, 254
       },
       {
           231,
           243,
           245, 253, 254, 254, 254, 254, 254,
           254, 254, 254, 254, 254, 251, 251, 254, 254, 254
       }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_mv_entropy_update_probs[2][MV_PROB_CNT] =
   {
       {
           237,
           246,
           253, 253, 254, 254, 254, 254, 254,
           254, 254, 254, 254, 254, 250, 250, 252, 254, 254
       },
       {
           231,
           243,
           245, 253, 254, 254, 254, 254, 254,
           254, 254, 254, 254, 254, 251, 251, 254, 254, 254
       }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_default_mv_probs[2][MV_PROB_CNT] =
   {
       {                                                  // row
           162,                                           // is short
           128,                                           // sign
           225, 146, 172, 147, 214,  39, 156,             // short tree
           128, 129, 132,  75, 145, 178, 206, 239, 254, 254 // long bits
       },
       {
           164,
           128,
           204, 170, 119, 235, 140, 230, 228,
           128, 130, 130,  74, 148, 180, 203, 236, 254, 254
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static const
   unsigned char k_default_mv_probs[2][MV_PROB_CNT] =
   {
       {                                                  // row
           162,                                           // is short
           128,                                           // sign
           225, 146, 172, 147, 214,  39, 156,             // short tree
           128, 129, 132,  75, 145, 178, 206, 239, 254, 254 // long bits
       },
       {
           164,
           128,
           204, 170, 119, 235, 140, 230, 228,
           128, 130, 130,  74, 148, 180, 203, 236, 254, 254
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       }
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       }
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.19. vpx_codec_internal.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.19. vpx_编解码器_internal.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file vpx_codec_internal.h
    * \brief Describes the decoder algorithm interface for algorithm
    *        implementations.
    *
    * This file defines the private structures and data types that are
    * only relevant to implementing an algorithm, as opposed to using
    * it.
    *
    * To create a decoder algorithm class, an interface structure is put
    * into the global namespace:
    *     &lt;pre&gt;
    *     my_codec.c:
    *       vpx_codec_iface_t my_codec = {
    *           &#34;My Codec v1.0&#34;,
    *           VPX_CODEC_ALG_ABI_VERSION,
    *           ...
    *       };
    *     &lt;/pre&gt;
    *
    * An application instantiates a specific decoder instance by using
    * vpx_codec_init() and a pointer to the algorithm&#39;s interface
    * structure:
    *     &lt;pre&gt;
    *     my_app.c:
    *       extern vpx_codec_iface_t my_codec;
    *       {
    *           vpx_codec_ctx_t algo;
    *           res = vpx_codec_init(&amp;algo, &amp;my_codec);
    *       }
    *     &lt;/pre&gt;
    *
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file vpx_codec_internal.h
    * \brief Describes the decoder algorithm interface for algorithm
    *        implementations.
    *
    * This file defines the private structures and data types that are
    * only relevant to implementing an algorithm, as opposed to using
    * it.
    *
    * To create a decoder algorithm class, an interface structure is put
    * into the global namespace:
    *     &lt;pre&gt;
    *     my_codec.c:
    *       vpx_codec_iface_t my_codec = {
    *           &#34;My Codec v1.0&#34;,
    *           VPX_CODEC_ALG_ABI_VERSION,
    *           ...
    *       };
    *     &lt;/pre&gt;
    *
    * An application instantiates a specific decoder instance by using
    * vpx_codec_init() and a pointer to the algorithm&#39;s interface
    * structure:
    *     &lt;pre&gt;
    *     my_app.c:
    *       extern vpx_codec_iface_t my_codec;
    *       {
    *           vpx_codec_ctx_t algo;
    *           res = vpx_codec_init(&amp;algo, &amp;my_codec);
    *       }
    *     &lt;/pre&gt;
    *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    * Once initialized, the instance is managed using other functions
    * from the vpx_codec_* family.
    */
   #ifndef VPX_CODEC_INTERNAL_H
   #define VPX_CODEC_INTERNAL_H
   #include &#34;vpx_decoder.h&#34;
   #include &lt;stdarg.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    * Once initialized, the instance is managed using other functions
    * from the vpx_codec_* family.
    */
   #ifndef VPX_CODEC_INTERNAL_H
   #define VPX_CODEC_INTERNAL_H
   #include &#34;vpx_decoder.h&#34;
   #include &lt;stdarg.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Current ABI version number
    *
    * \internal
    * If this file is altered in any way that changes the Application
    * Binary Interface (ABI), this value must be bumped.  Examples
    * include, but are not limited to, changing types, removing or
    * reassigning enums, adding/removing/rearranging fields to
    * structures.
    */
   #define VPX_CODEC_INTERNAL_ABI_VERSION (3)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Current ABI version number
    *
    * \internal
    * If this file is altered in any way that changes the Application
    * Binary Interface (ABI), this value must be bumped.  Examples
    * include, but are not limited to, changing types, removing or
    * reassigning enums, adding/removing/rearranging fields to
    * structures.
    */
   #define VPX_CODEC_INTERNAL_ABI_VERSION (3)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef struct vpx_codec_alg_priv vpx_codec_alg_priv_t;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef struct vpx_codec_alg_priv vpx_codec_alg_priv；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief init function pointer prototype
    *
    * Performs algorithm-specific initialization of the decoder context.
    * This function is called by the generic vpx_codec_init() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx   Pointer to this instance&#39;s context
    * \retval #VPX_CODEC_OK
    *     The input stream was recognized and decoder initialized.
    * \retval #VPX_CODEC_MEM_ERROR
    *     Memory operation failed.
    */
   typedef vpx_codec_err_t (*vpx_codec_init_fn_t)(vpx_codec_ctx_t *ctx);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief init function pointer prototype
    *
    * Performs algorithm-specific initialization of the decoder context.
    * This function is called by the generic vpx_codec_init() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx   Pointer to this instance&#39;s context
    * \retval #VPX_CODEC_OK
    *     The input stream was recognized and decoder initialized.
    * \retval #VPX_CODEC_MEM_ERROR
    *     Memory operation failed.
    */
   typedef vpx_codec_err_t (*vpx_codec_init_fn_t)(vpx_codec_ctx_t *ctx);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief destroy function pointer prototype
    *
    * Performs algorithm-specific destruction of the decoder context.
    * This function is called by the generic vpx_codec_destroy() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx   Pointer to this instance&#39;s context
    * \retval #VPX_CODEC_OK
    *     The input stream was recognized and decoder initialized.
    * \retval #VPX_CODEC_MEM_ERROR
    *     Memory operation failed.
    */
   typedef vpx_codec_err_t (*vpx_codec_destroy_fn_t)(
       vpx_codec_alg_priv_t *ctx);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief destroy function pointer prototype
    *
    * Performs algorithm-specific destruction of the decoder context.
    * This function is called by the generic vpx_codec_destroy() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx   Pointer to this instance&#39;s context
    * \retval #VPX_CODEC_OK
    *     The input stream was recognized and decoder initialized.
    * \retval #VPX_CODEC_MEM_ERROR
    *     Memory operation failed.
    */
   typedef vpx_codec_err_t (*vpx_codec_destroy_fn_t)(
       vpx_codec_alg_priv_t *ctx);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief parse stream info function pointer prototype
    *
    * Performs high level parsing of the bitstream.  This function is
    * called by the generic vpx_codec_parse_stream() wrapper function,
    * so plugins implementing this interface may trust the input
    * parameters to be properly initialized.
    *
    * \param[in]      data    Pointer to a block of data to parse
    * \param[in]      data_sz Size of the data buffer
    * \param[in,out]  si      Pointer to stream info to update.  The
    *                         size member \ref MUST be properly
    *                         initialized, but \ref MAY be clobbered by
    *                         the algorithm.  This parameter \ref MAY
    *                         be NULL.
    *
    * \retval #VPX_CODEC_OK
    *     Bitstream is parsable and stream information updated
    */
   typedef vpx_codec_err_t (*vpx_codec_peek_si_fn_t)(
       const uint8_t         *data,
       unsigned int           data_sz,
       vpx_codec_stream_info_t *si);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief parse stream info function pointer prototype
    *
    * Performs high level parsing of the bitstream.  This function is
    * called by the generic vpx_codec_parse_stream() wrapper function,
    * so plugins implementing this interface may trust the input
    * parameters to be properly initialized.
    *
    * \param[in]      data    Pointer to a block of data to parse
    * \param[in]      data_sz Size of the data buffer
    * \param[in,out]  si      Pointer to stream info to update.  The
    *                         size member \ref MUST be properly
    *                         initialized, but \ref MAY be clobbered by
    *                         the algorithm.  This parameter \ref MAY
    *                         be NULL.
    *
    * \retval #VPX_CODEC_OK
    *     Bitstream is parsable and stream information updated
    */
   typedef vpx_codec_err_t (*vpx_codec_peek_si_fn_t)(
       const uint8_t         *data,
       unsigned int           data_sz,
       vpx_codec_stream_info_t *si);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Return information about the current stream.
    *
    * Returns information about the stream that has been parsed during
    * decoding.
    *
    * \param[in]      ctx     Pointer to this instance&#39;s context
    * \param[in,out]  si      Pointer to stream info to update.  The
    *                         size member \ref MUST be properly
    *                         initialized, but \ref MAY be clobbered by
    *                         the algorithm.  This parameter \ref MAY
    *                         be NULL.
    *
    * \retval #VPX_CODEC_OK
    *     Bitstream is parsable and stream information updated
    */
   typedef vpx_codec_err_t (*vpx_codec_get_si_fn_t)(
       vpx_codec_alg_priv_t    *ctx,
       vpx_codec_stream_info_t *si);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Return information about the current stream.
    *
    * Returns information about the stream that has been parsed during
    * decoding.
    *
    * \param[in]      ctx     Pointer to this instance&#39;s context
    * \param[in,out]  si      Pointer to stream info to update.  The
    *                         size member \ref MUST be properly
    *                         initialized, but \ref MAY be clobbered by
    *                         the algorithm.  This parameter \ref MAY
    *                         be NULL.
    *
    * \retval #VPX_CODEC_OK
    *     Bitstream is parsable and stream information updated
    */
   typedef vpx_codec_err_t (*vpx_codec_get_si_fn_t)(
       vpx_codec_alg_priv_t    *ctx,
       vpx_codec_stream_info_t *si);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief control function pointer prototype
    *
    * This function is used to exchange algorithm-specific data with the
    * decoder instance.  This can be used to implement features specific
    * to a particular algorithm.
    *
    * This function is called by the generic vpx_codec_control() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.  However, this
    * interface does not provide type safety for the exchanged data or
    * assign meanings to the control codes.  Those details should be
    * specified in the algorithm&#39;s header file.  In particular, the
    * ctrl_id parameter is guaranteed to exist in the algorithm&#39;s
    * control mapping table, and the data parameter may be NULL.
    *
    *
    * \param[in]     ctx       Pointer to this instance&#39;s context
    * \param[in]     ctrl_id   Algorithm-specific control identifier
    * \param[in,out] data      Data to exchange with algorithm instance.
    *
    * \retval #VPX_CODEC_OK
    *     The internal state data was deserialized.
    */
   typedef vpx_codec_err_t (*vpx_codec_control_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       int                   ctrl_id,
       va_list               ap);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief control function pointer prototype
    *
    * This function is used to exchange algorithm-specific data with the
    * decoder instance.  This can be used to implement features specific
    * to a particular algorithm.
    *
    * This function is called by the generic vpx_codec_control() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.  However, this
    * interface does not provide type safety for the exchanged data or
    * assign meanings to the control codes.  Those details should be
    * specified in the algorithm&#39;s header file.  In particular, the
    * ctrl_id parameter is guaranteed to exist in the algorithm&#39;s
    * control mapping table, and the data parameter may be NULL.
    *
    *
    * \param[in]     ctx       Pointer to this instance&#39;s context
    * \param[in]     ctrl_id   Algorithm-specific control identifier
    * \param[in,out] data      Data to exchange with algorithm instance.
    *
    * \retval #VPX_CODEC_OK
    *     The internal state data was deserialized.
    */
   typedef vpx_codec_err_t (*vpx_codec_control_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       int                   ctrl_id,
       va_list               ap);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief control function pointer mapping
    *
    * This structure stores the mapping between control identifiers and
    * implementing functions.  Each algorithm provides a list of these
    * mappings.  This list is searched by the vpx_codec_control()
    * wrapper function to determine which function to invoke.  The
    * special value {0, NULL} is used to indicate end-of-list, and must
    * be present.  The special value {0, &lt;non-null&gt;} can be used as a
    * catch-all mapping.  This implies that ctrl_id values chosen by the
    * algorithm \ref MUST be non-zero.
    */
   typedef const struct
   {
       int                    ctrl_id;
       vpx_codec_control_fn_t   fn;
   } vpx_codec_ctrl_fn_map_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief control function pointer mapping
    *
    * This structure stores the mapping between control identifiers and
    * implementing functions.  Each algorithm provides a list of these
    * mappings.  This list is searched by the vpx_codec_control()
    * wrapper function to determine which function to invoke.  The
    * special value {0, NULL} is used to indicate end-of-list, and must
    * be present.  The special value {0, &lt;non-null&gt;} can be used as a
    * catch-all mapping.  This implies that ctrl_id values chosen by the
    * algorithm \ref MUST be non-zero.
    */
   typedef const struct
   {
       int                    ctrl_id;
       vpx_codec_control_fn_t   fn;
   } vpx_codec_ctrl_fn_map_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief decode data function pointer prototype
    *
    * Processes a buffer of coded data.  If the processing results in a
    * new decoded frame becoming available, #VPX_CODEC_CB_PUT_SLICE and
    * #VPX_CODEC_CB_PUT_FRAME events are generated as appropriate.
    * This function is called by the generic vpx_codec_decode() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx         Pointer to this instance&#39;s context
    * \param[in] data        Pointer to this block of new coded data.
    *                        If NULL, a #VPX_CODEC_CB_PUT_FRAME event is
    *                        posted for the previously decoded frame.
    * \param[in] data_sz     Size of the coded data, in bytes.
    *
    * \return Returns #VPX_CODEC_OK if the coded data was processed
    *         completely and future pictures can be decoded without
    *         error.  Otherwise, see the descriptions of the other error
    *         codes in ::vpx_codec_err_t for recoverability
    *         capabilities.
    */
   typedef vpx_codec_err_t (*vpx_codec_decode_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       const uint8_t         *data,
       unsigned int     data_sz,
       void        *user_priv,
       long         deadline);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief decode data function pointer prototype
    *
    * Processes a buffer of coded data.  If the processing results in a
    * new decoded frame becoming available, #VPX_CODEC_CB_PUT_SLICE and
    * #VPX_CODEC_CB_PUT_FRAME events are generated as appropriate.
    * This function is called by the generic vpx_codec_decode() wrapper
    * function, so plugins implementing this interface may trust the
    * input parameters to be properly initialized.
    *
    * \param[in] ctx         Pointer to this instance&#39;s context
    * \param[in] data        Pointer to this block of new coded data.
    *                        If NULL, a #VPX_CODEC_CB_PUT_FRAME event is
    *                        posted for the previously decoded frame.
    * \param[in] data_sz     Size of the coded data, in bytes.
    *
    * \return Returns #VPX_CODEC_OK if the coded data was processed
    *         completely and future pictures can be decoded without
    *         error.  Otherwise, see the descriptions of the other error
    *         codes in ::vpx_codec_err_t for recoverability
    *         capabilities.
    */
   typedef vpx_codec_err_t (*vpx_codec_decode_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       const uint8_t         *data,
       unsigned int     data_sz,
       void        *user_priv,
       long         deadline);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Decoded frames iterator
    *
    * Iterates over a list of the frames available for display.  The
    * iterator storage should be initialized to NULL to start the
    * iteration.  Iteration is complete when this function returns NULL.
    *
    * The list of available frames becomes valid upon completion of the
    * vpx_codec_decode call, and remains valid until the next call to
    * vpx_codec_decode.
    *
    * \param[in]     ctx      Pointer to this instance&#39;s context
    * \param[in out] iter     Iterator storage, initialized to NULL
    *
    * \return Returns a pointer to an image, if one is ready for
    *         display.  Frames produced will always be in PTS
    *         (presentation time stamp) order.
    */
   typedef vpx_image_t*(*vpx_codec_get_frame_fn_t)(
       vpx_codec_alg_priv_t *ctx,
       vpx_codec_iter_t     *iter);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Decoded frames iterator
    *
    * Iterates over a list of the frames available for display.  The
    * iterator storage should be initialized to NULL to start the
    * iteration.  Iteration is complete when this function returns NULL.
    *
    * The list of available frames becomes valid upon completion of the
    * vpx_codec_decode call, and remains valid until the next call to
    * vpx_codec_decode.
    *
    * \param[in]     ctx      Pointer to this instance&#39;s context
    * \param[in out] iter     Iterator storage, initialized to NULL
    *
    * \return Returns a pointer to an image, if one is ready for
    *         display.  Frames produced will always be in PTS
    *         (presentation time stamp) order.
    */
   typedef vpx_image_t*(*vpx_codec_get_frame_fn_t)(
       vpx_codec_alg_priv_t *ctx,
       vpx_codec_iter_t     *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*\brief External Memory Allocation memory map get iterator
    *
    * Iterates over a list of the memory maps requested by the decoder.
    * The iterator storage should be initialized to NULL to start the
    * iteration.  Iteration is complete when this function returns NULL.
    *
    * \param[in out] iter     Iterator storage, initialized to NULL
    *
    * \return Returns a pointer to a memory segment descriptor, or NULL
    *         to indicate end-of-list.
    */
   typedef vpx_codec_err_t (*vpx_codec_get_mmap_fn_t)(
       const vpx_codec_ctx_t      *ctx,
       vpx_codec_mmap_t           *mmap,
       vpx_codec_iter_t           *iter);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*\brief External Memory Allocation memory map get iterator
    *
    * Iterates over a list of the memory maps requested by the decoder.
    * The iterator storage should be initialized to NULL to start the
    * iteration.  Iteration is complete when this function returns NULL.
    *
    * \param[in out] iter     Iterator storage, initialized to NULL
    *
    * \return Returns a pointer to a memory segment descriptor, or NULL
    *         to indicate end-of-list.
    */
   typedef vpx_codec_err_t (*vpx_codec_get_mmap_fn_t)(
       const vpx_codec_ctx_t      *ctx,
       vpx_codec_mmap_t           *mmap,
       vpx_codec_iter_t           *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*\brief External Memory Allocation memory map set iterator
    *
    * Sets a memory descriptor inside the decoder instance.
    *
    * \param[in] ctx      Pointer to this instance&#39;s context
    * \param[in] mmap     Memory map to store.
    *
    * \retval #VPX_CODEC_OK
    *     The memory map was accepted and stored.
    * \retval #VPX_CODEC_MEM_ERROR
    *     The memory map was rejected.
    */
   typedef vpx_codec_err_t (*vpx_codec_set_mmap_fn_t)(
       vpx_codec_ctx_t         *ctx,
       const vpx_codec_mmap_t  *mmap);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*\brief External Memory Allocation memory map set iterator
    *
    * Sets a memory descriptor inside the decoder instance.
    *
    * \param[in] ctx      Pointer to this instance&#39;s context
    * \param[in] mmap     Memory map to store.
    *
    * \retval #VPX_CODEC_OK
    *     The memory map was accepted and stored.
    * \retval #VPX_CODEC_MEM_ERROR
    *     The memory map was rejected.
    */
   typedef vpx_codec_err_t (*vpx_codec_set_mmap_fn_t)(
       vpx_codec_ctx_t         *ctx,
       const vpx_codec_mmap_t  *mmap);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef vpx_codec_err_t (*vpx_codec_encode_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       const vpx_image_t     *img,
       vpx_codec_pts_t        pts,
       unsigned long          duration,
       vpx_enc_frame_flags_t  flags,
       unsigned long          deadline);
   typedef const vpx_codec_cx_pkt_t*(*vpx_codec_get_cx_data_fn_t)(
       vpx_codec_alg_priv_t *ctx,
       vpx_codec_iter_t     *iter);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef vpx_codec_err_t (*vpx_codec_encode_fn_t)(
       vpx_codec_alg_priv_t  *ctx,
       const vpx_image_t     *img,
       vpx_codec_pts_t        pts,
       unsigned long          duration,
       vpx_enc_frame_flags_t  flags,
       unsigned long          deadline);
   typedef const vpx_codec_cx_pkt_t*(*vpx_codec_get_cx_data_fn_t)(
       vpx_codec_alg_priv_t *ctx,
       vpx_codec_iter_t     *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef vpx_codec_err_t
   (*vpx_codec_enc_config_set_fn_t)(
       vpx_codec_alg_priv_t       *ctx,
       const vpx_codec_enc_cfg_t  *cfg);
   typedef vpx_fixed_buf_t *
   (*vpx_codec_get_global_headers_fn_t)(vpx_codec_alg_priv_t   *ctx);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef vpx_codec_err_t
   (*vpx_codec_enc_config_set_fn_t)(
       vpx_codec_alg_priv_t       *ctx,
       const vpx_codec_enc_cfg_t  *cfg);
   typedef vpx_fixed_buf_t *
   (*vpx_codec_get_global_headers_fn_t)(vpx_codec_alg_priv_t   *ctx);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef vpx_image_t *
   (*vpx_codec_get_preview_frame_fn_t)(vpx_codec_alg_priv_t   *ctx);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef vpx_image_t *
   (*vpx_codec_get_preview_frame_fn_t)(vpx_codec_alg_priv_t   *ctx);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief usage configuration mapping
    *
    * This structure stores the mapping between usage identifiers and
    * configuration structures.  Each algorithm provides a list of these
    * mappings.  This list is searched by the
    * vpx_codec_enc_config_default() wrapper function to determine which
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief usage configuration mapping
    *
    * This structure stores the mapping between usage identifiers and
    * configuration structures.  Each algorithm provides a list of these
    * mappings.  This list is searched by the
    * vpx_codec_enc_config_default() wrapper function to determine which
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    * config to return.  The special value {-1, {0}} is used to indicate
    * end-of-list, and must be present.  At least one mapping must be
    * present, in addition to the end-of-list.
    *
    */
   typedef const struct
   {
       int                 usage;
       vpx_codec_enc_cfg_t cfg;
   } vpx_codec_enc_cfg_map_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    * config to return.  The special value {-1, {0}} is used to indicate
    * end-of-list, and must be present.  At least one mapping must be
    * present, in addition to the end-of-list.
    *
    */
   typedef const struct
   {
       int                 usage;
       vpx_codec_enc_cfg_t cfg;
   } vpx_codec_enc_cfg_map_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define NOT_IMPLEMENTED 0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#定义未实现0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Decoder algorithm interface
    *
    * All decoders \ref MUST expose a variable of this type.
    */
   struct vpx_codec_iface
   {
       const char               *name;
       int                       abi_version;
       vpx_codec_caps_t          caps;
       vpx_codec_init_fn_t       init;
       vpx_codec_destroy_fn_t    destroy;
       vpx_codec_ctrl_fn_map_t  *ctrl_maps;
       vpx_codec_get_mmap_fn_t   get_mmap;
       vpx_codec_set_mmap_fn_t   set_mmap;
       struct
       {
           vpx_codec_peek_si_fn_t    peek_si;
           vpx_codec_get_si_fn_t     get_si;
           vpx_codec_decode_fn_t     decode;
           vpx_codec_get_frame_fn_t  get_frame;
       } dec;
       struct
       {
           vpx_codec_enc_cfg_map_t           *cfg_maps;
           vpx_codec_encode_fn_t              encode;
           vpx_codec_get_cx_data_fn_t         get_cx_data;
           vpx_codec_enc_config_set_fn_t      cfg_set;
           vpx_codec_get_global_headers_fn_t  get_glob_hdrs;
           vpx_codec_get_preview_frame_fn_t   get_preview;
       } enc;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Decoder algorithm interface
    *
    * All decoders \ref MUST expose a variable of this type.
    */
   struct vpx_codec_iface
   {
       const char               *name;
       int                       abi_version;
       vpx_codec_caps_t          caps;
       vpx_codec_init_fn_t       init;
       vpx_codec_destroy_fn_t    destroy;
       vpx_codec_ctrl_fn_map_t  *ctrl_maps;
       vpx_codec_get_mmap_fn_t   get_mmap;
       vpx_codec_set_mmap_fn_t   set_mmap;
       struct
       {
           vpx_codec_peek_si_fn_t    peek_si;
           vpx_codec_get_si_fn_t     get_si;
           vpx_codec_decode_fn_t     decode;
           vpx_codec_get_frame_fn_t  get_frame;
       } dec;
       struct
       {
           vpx_codec_enc_cfg_map_t           *cfg_maps;
           vpx_codec_encode_fn_t              encode;
           vpx_codec_get_cx_data_fn_t         get_cx_data;
           vpx_codec_enc_config_set_fn_t      cfg_set;
           vpx_codec_get_global_headers_fn_t  get_glob_hdrs;
           vpx_codec_get_preview_frame_fn_t   get_preview;
       } enc;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Callback function pointer / user data pair storage */
   typedef struct vpx_codec_priv_cb_pair
   {
       union
       {
           vpx_codec_put_frame_cb_fn_t    put_frame;
           vpx_codec_put_slice_cb_fn_t    put_slice;
       };
       void                            *user_priv;
   } vpx_codec_priv_cb_pair_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Callback function pointer / user data pair storage */
   typedef struct vpx_codec_priv_cb_pair
   {
       union
       {
           vpx_codec_put_frame_cb_fn_t    put_frame;
           vpx_codec_put_slice_cb_fn_t    put_slice;
       };
       void                            *user_priv;
   } vpx_codec_priv_cb_pair_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Instance private storage
    *
    * This structure is allocated by the algorithm&#39;s init function.  It
    * can be extended in one of two ways.  First, a second, algorithm
    * specific structure can be allocated and the priv member pointed to
    * it.  Alternatively, this structure can be made the first member of
    * the algorithm-specific structure, and the pointer casted to the
    * proper type.
    */
   struct vpx_codec_priv
   {
       unsigned int                    sz;
       vpx_codec_iface_t              *iface;
       struct vpx_codec_alg_priv      *alg_priv;
       const char                     *err_detail;
       vpx_codec_flags_t               init_flags;
       struct
       {
           vpx_codec_priv_cb_pair_t    put_frame_cb;
           vpx_codec_priv_cb_pair_t    put_slice_cb;
       } dec;
       struct
       {
           struct vpx_fixed_buf        cx_data_dst_buf;
           unsigned int                cx_data_pad_before;
           unsigned int                cx_data_pad_after;
           vpx_codec_cx_pkt_t          cx_data_pkt;
       } enc;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\brief Instance private storage
    *
    * This structure is allocated by the algorithm&#39;s init function.  It
    * can be extended in one of two ways.  First, a second, algorithm
    * specific structure can be allocated and the priv member pointed to
    * it.  Alternatively, this structure can be made the first member of
    * the algorithm-specific structure, and the pointer casted to the
    * proper type.
    */
   struct vpx_codec_priv
   {
       unsigned int                    sz;
       vpx_codec_iface_t              *iface;
       struct vpx_codec_alg_priv      *alg_priv;
       const char                     *err_detail;
       vpx_codec_flags_t               init_flags;
       struct
       {
           vpx_codec_priv_cb_pair_t    put_frame_cb;
           vpx_codec_priv_cb_pair_t    put_slice_cb;
       } dec;
       struct
       {
           struct vpx_fixed_buf        cx_data_dst_buf;
           unsigned int                cx_data_pad_before;
           unsigned int                cx_data_pad_after;
           vpx_codec_cx_pkt_t          cx_data_pkt;
       } enc;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #undef VPX_CTRL_USE_TYPE
   #define VPX_CTRL_USE_TYPE(id, typ) \
       static typ id##__value(va_list args) \
       {return va_arg(args, typ);} \
       static typ id##__convert(void *x)\
       {\
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #undef VPX_CTRL_USE_TYPE
   #define VPX_CTRL_USE_TYPE(id, typ) \
       static typ id##__value(va_list args) \
       {return va_arg(args, typ);} \
       static typ id##__convert(void *x)\
       {\
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           union\
           {\
               void *x;\
               typ   d;\
           } u;\
           u.x = x;\
           return u.d;\
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           union\
           {\
               void *x;\
               typ   d;\
           } u;\
           u.x = x;\
           return u.d;\
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #undef VPX_CTRL_USE_TYPE_DEPRECATED
   #define VPX_CTRL_USE_TYPE_DEPRECATED(id, typ) \
       static typ id##__value(va_list args) \
       {return va_arg(args, typ);} \
       static typ id##__convert(void *x)\
       {\
           union\
           {\
               void *x;\
               typ   d;\
           } u;\
           u.x = x;\
           return u.d;\
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #undef VPX_CTRL_USE_TYPE_DEPRECATED
   #define VPX_CTRL_USE_TYPE_DEPRECATED(id, typ) \
       static typ id##__value(va_list args) \
       {return va_arg(args, typ);} \
       static typ id##__convert(void *x)\
       {\
           union\
           {\
               void *x;\
               typ   d;\
           } u;\
           u.x = x;\
           return u.d;\
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define CAST(id, arg) id##__value(arg)
   #define RECAST(id, x) id##__convert(x)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define CAST(id, arg) id##__value(arg)
   #define RECAST(id, x) id##__convert(x)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Internal Utility Functions
    *
    * The following functions are intended to be used inside algorithms
    * as utilities for manipulating vpx_codec_* data structures.
    */
   struct vpx_codec_pkt_list
   {
       unsigned int            cnt;
       unsigned int            max;
       struct vpx_codec_cx_pkt pkts[1];
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Internal Utility Functions
    *
    * The following functions are intended to be used inside algorithms
    * as utilities for manipulating vpx_codec_* data structures.
    */
   struct vpx_codec_pkt_list
   {
       unsigned int            cnt;
       unsigned int            max;
       struct vpx_codec_cx_pkt pkts[1];
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define vpx_codec_pkt_list_decl(n)\
       union {struct vpx_codec_pkt_list head;\
           struct {struct vpx_codec_pkt_list head;\
               struct vpx_codec_cx_pkt    pkts[n];} alloc;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define vpx_codec_pkt_list_decl(n)\
       union {struct vpx_codec_pkt_list head;\
           struct {struct vpx_codec_pkt_list head;\
               struct vpx_codec_cx_pkt    pkts[n];} alloc;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define vpx_codec_pkt_list_init(m)\
       (m)-&gt;alloc.head.cnt = 0,\
       (m)-&gt;alloc.head.max = \
       sizeof((m)-&gt;alloc.pkts) / sizeof((m)-&gt;alloc.pkts[0])
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define vpx_codec_pkt_list_init(m)\
       (m)-&gt;alloc.head.cnt = 0,\
       (m)-&gt;alloc.head.max = \
       sizeof((m)-&gt;alloc.pkts) / sizeof((m)-&gt;alloc.pkts[0])
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int vpx_codec_pkt_list_add(struct vpx_codec_pkt_list *, const struct vpx_codec_cx_pkt *);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
int vpx_编解码器_pkt_列表_添加（结构vpx_编解码器_pkt_列表*，常量结构vpx_编解码器_cx_pkt*）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const vpx_codec_cx_pkt_t*
   vpx_codec_pkt_list_get(struct vpx_codec_pkt_list *list,
                          vpx_codec_iter_t           *iter);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   const vpx_codec_cx_pkt_t*
   vpx_codec_pkt_list_get(struct vpx_codec_pkt_list *list,
                          vpx_codec_iter_t           *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #include &lt;stdio.h&gt;
   #include &lt;setjmp.h&gt;
   struct vpx_internal_error_info
   {
       vpx_codec_err_t  error_code;
       int              has_detail;
       char             detail[80];
       int              setjmp;
       jmp_buf          jmp;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #include &lt;stdio.h&gt;
   #include &lt;setjmp.h&gt;
   struct vpx_internal_error_info
   {
       vpx_codec_err_t  error_code;
       int              has_detail;
       char             detail[80];
       int              setjmp;
       jmp_buf          jmp;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void vpx_internal_error(struct vpx_internal_error_info *info,
                                  vpx_codec_err_t                 error,
                                  const char                     *fmt,
                                  ...)
   {
       va_list ap;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   static void vpx_internal_error(struct vpx_internal_error_info *info,
                                  vpx_codec_err_t                 error,
                                  const char                     *fmt,
                                  ...)
   {
       va_list ap;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       info-&gt;error_code = error;
       info-&gt;has_detail = 0;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       info-&gt;error_code = error;
       info-&gt;has_detail = 0;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (fmt)
       {
           size_t  sz = sizeof(info-&gt;detail);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (fmt)
       {
           size_t  sz = sizeof(info-&gt;detail);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           info-&gt;has_detail = 1;
           va_start(ap, fmt);
           vsnprintf(info-&gt;detail, sz - 1, fmt, ap);
           va_end(ap);
           info-&gt;detail[sz-1] = &#39;\0&#39;;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           info-&gt;has_detail = 1;
           va_start(ap, fmt);
           vsnprintf(info-&gt;detail, sz - 1, fmt, ap);
           va_end(ap);
           info-&gt;detail[sz-1] = &#39;\0&#39;;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (info-&gt;setjmp)
           longjmp(info-&gt;jmp, info-&gt;error_code);
   }
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (info-&gt;setjmp)
           longjmp(info-&gt;jmp, info-&gt;error_code);
   }
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.20. vpx_decoder.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.20. vpx_解码器.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\defgroup decoder Decoder Algorithm Interface
    * \ingroup codec
    * This abstraction allows applications using this decoder to easily
    * support multiple video formats with minimal code duplication.
    * This section describes the interface common to all decoders.
    * @{
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\defgroup decoder Decoder Algorithm Interface
    * \ingroup codec
    * This abstraction allows applications using this decoder to easily
    * support multiple video formats with minimal code duplication.
    * This section describes the interface common to all decoders.
    * @{
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file vpx_decoder.h
    * \brief Describes the decoder algorithm interface to applications.
    *
    * This file describes the interface between an application and a
    * video decoder algorithm.
    *
    */
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
   #ifndef VPX_DECODER_H
   #define VPX_DECODER_H
   #include &#34;vpx_codec.h&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file vpx_decoder.h
    * \brief Describes the decoder algorithm interface to applications.
    *
    * This file describes the interface between an application and a
    * video decoder algorithm.
    *
    */
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
   #ifndef VPX_DECODER_H
   #define VPX_DECODER_H
   #include &#34;vpx_codec.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Current ABI version number
        *
        * \internal
        * If this file is altered in any way that changes the ABI, this
        * value must be bumped.  Examples include, but are not limited
        * to, changing types, removing or reassigning enums,
        * adding/removing/rearranging fields to structures
        */
   #define VPX_DECODER_ABI_VERSION (2 + VPX_CODEC_ABI_VERSION)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Current ABI version number
        *
        * \internal
        * If this file is altered in any way that changes the ABI, this
        * value must be bumped.  Examples include, but are not limited
        * to, changing types, removing or reassigning enums,
        * adding/removing/rearranging fields to structures
        */
   #define VPX_DECODER_ABI_VERSION (2 + VPX_CODEC_ABI_VERSION)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*! \brief Decoder capabilities bitfield
        *
        *  Each decoder advertises the capabilities it supports as part
        *  of its ::vpx_codec_iface_t interface structure.  Capabilities
        *  are extra interfaces or functionality, and are not required
        *  to be supported by a decoder.
        *
        *  The available flags are specified by VPX_CODEC_CAP_* defines.
        */
   #define VPX_CODEC_CAP_PUT_SLICE  0x10000 /**&lt; Will issue put_slice
       callbacks */
   #define VPX_CODEC_CAP_PUT_FRAME  0x20000 /**&lt; Will issue put_frame
       callbacks */
   #define VPX_CODEC_CAP_POSTPROC   0x40000 /**&lt; Can postprocess decoded
       frame */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*! \brief Decoder capabilities bitfield
        *
        *  Each decoder advertises the capabilities it supports as part
        *  of its ::vpx_codec_iface_t interface structure.  Capabilities
        *  are extra interfaces or functionality, and are not required
        *  to be supported by a decoder.
        *
        *  The available flags are specified by VPX_CODEC_CAP_* defines.
        */
   #define VPX_CODEC_CAP_PUT_SLICE  0x10000 /**&lt; Will issue put_slice
       callbacks */
   #define VPX_CODEC_CAP_PUT_FRAME  0x20000 /**&lt; Will issue put_frame
       callbacks */
   #define VPX_CODEC_CAP_POSTPROC   0x40000 /**&lt; Can postprocess decoded
       frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*! \brief Initialization-time Feature Enabling
        *
        *  Certain codec features must be known at initialization time,
        *  to allow for proper memory allocation.
        *
        *  The available flags are specified by VPX_CODEC_USE_* defines.
        */
   #define VPX_CODEC_USE_POSTPROC   0x10000 /**&lt; Postprocess decoded
       frame */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*! \brief Initialization-time Feature Enabling
        *
        *  Certain codec features must be known at initialization time,
        *  to allow for proper memory allocation.
        *
        *  The available flags are specified by VPX_CODEC_USE_* defines.
        */
   #define VPX_CODEC_USE_POSTPROC   0x10000 /**&lt; Postprocess decoded
       frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Stream properties
        *
        * This structure is used to query or set properties of the
        * decoded stream.  Algorithms may extend this structure with
        * data specific to their bitstream by setting the sz member
        * appropriately.
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Stream properties
        *
        * This structure is used to query or set properties of the
        * decoded stream.  Algorithms may extend this structure with
        * data specific to their bitstream by setting the sz member
        * appropriately.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       typedef struct vpx_codec_stream_info
       {
           unsigned int sz;    /**&lt; Size of this structure */
           unsigned int w;     /**&lt; Width (or 0 for unknown/default) */
           unsigned int h;     /**&lt; Height (or 0 for unknown/default) */
           unsigned int is_kf; /**&lt; Current frame is a keyframe */
       } vpx_codec_stream_info_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       typedef struct vpx_codec_stream_info
       {
           unsigned int sz;    /**&lt; Size of this structure */
           unsigned int w;     /**&lt; Width (or 0 for unknown/default) */
           unsigned int h;     /**&lt; Height (or 0 for unknown/default) */
           unsigned int is_kf; /**&lt; Current frame is a keyframe */
       } vpx_codec_stream_info_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* REQUIRED FUNCTIONS
        *
        * The following functions are required to be implemented for all
        * decoders.  They represent the base case functionality expected
        * of all decoders.
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* REQUIRED FUNCTIONS
        *
        * The following functions are required to be implemented for all
        * decoders.  They represent the base case functionality expected
        * of all decoders.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialization Configurations
        *
        * This structure is used to pass init time configuration options
        * to the decoder.
        */
       typedef struct vpx_codec_dec_cfg
       {
           unsigned int threads; /**&lt; Maximum number of threads to use,
               default 1 */
           unsigned int w;      /**&lt; Width */
           unsigned int h;      /**&lt; Height */
       } vpx_codec_dec_cfg_t; /**&lt; alias for struct vpx_codec_dec_cfg */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialization Configurations
        *
        * This structure is used to pass init time configuration options
        * to the decoder.
        */
       typedef struct vpx_codec_dec_cfg
       {
           unsigned int threads; /**&lt; Maximum number of threads to use,
               default 1 */
           unsigned int w;      /**&lt; Width */
           unsigned int h;      /**&lt; Height */
       } vpx_codec_dec_cfg_t; /**&lt; alias for struct vpx_codec_dec_cfg */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_codec_dec_init convenience
        * macro instead of this function directly, to ensure that the
        * ABI version number parameter is properly initialized.
        *
        * In XMA mode (activated by setting VPX_CODEC_USE_XMA in the
        * flags parameter), the storage pointed to by the cfg parameter
        * must be kept readable and stable until all memory maps have
        * been set.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        * \param[in]    iface   Pointer to the algorithm interface to
        *                       use.
        * \param[in]    cfg     Configuration to use, if known.  May be
        *                       NULL.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_codec_dec_init convenience
        * macro instead of this function directly, to ensure that the
        * ABI version number parameter is properly initialized.
        *
        * In XMA mode (activated by setting VPX_CODEC_USE_XMA in the
        * flags parameter), the storage pointed to by the cfg parameter
        * must be kept readable and stable until all memory maps have
        * been set.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        * \param[in]    iface   Pointer to the algorithm interface to
        *                       use.
        * \param[in]    cfg     Configuration to use, if known.  May be
        *                       NULL.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
        * \param[in]    ver     ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_CODEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_CODEC_MEM_ERROR
        *     Memory allocation failed.
        */
       vpx_codec_err_t vpx_codec_dec_init_ver(
           vpx_codec_ctx_t      *ctx,
           vpx_codec_iface_t    *iface,
           vpx_codec_dec_cfg_t  *cfg,
           vpx_codec_flags_t     flags,
           int                   ver);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags
        * \param[in]    ver     ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_CODEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_CODEC_MEM_ERROR
        *     Memory allocation failed.
        */
       vpx_codec_err_t vpx_codec_dec_init_ver(
           vpx_codec_ctx_t      *ctx,
           vpx_codec_iface_t    *iface,
           vpx_codec_dec_cfg_t  *cfg,
           vpx_codec_flags_t     flags,
           int                   ver);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Convenience macro for vpx_codec_dec_init_ver()
        *
        * Ensures the ABI version parameter is properly set.
        */
   #define vpx_codec_dec_init(ctx, iface, cfg, flags) \
       vpx_codec_dec_init_ver(ctx, iface, cfg, flags, \
       VPX_DECODER_ABI_VERSION)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Convenience macro for vpx_codec_dec_init_ver()
        *
        * Ensures the ABI version parameter is properly set.
        */
   #define vpx_codec_dec_init(ctx, iface, cfg, flags) \
       vpx_codec_dec_init_ver(ctx, iface, cfg, flags, \
       VPX_DECODER_ABI_VERSION)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Parse stream info from a buffer
        *
        * Performs high level parsing of the bitstream.  Construction of
        * a decoder context is not necessary.  Can be used to determine
        * if the bitstream is of the proper format, and to extract
        * information from the stream.
        *
        * \param[in]      iface   Pointer to the algorithm interface
        * \param[in]      data    Pointer to a block of data to parse
        * \param[in]      data_sz Size of the data buffer
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member
        *                         \ref MUST be properly initialized, but
        *                         \ref MAY be clobbered by the
        *                         algorithm.  This parameter \ref MAY be
        *                         NULL.
        *
        * \retval #VPX_CODEC_OK
        *     Bitstream is parsable and stream information updated
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Parse stream info from a buffer
        *
        * Performs high level parsing of the bitstream.  Construction of
        * a decoder context is not necessary.  Can be used to determine
        * if the bitstream is of the proper format, and to extract
        * information from the stream.
        *
        * \param[in]      iface   Pointer to the algorithm interface
        * \param[in]      data    Pointer to a block of data to parse
        * \param[in]      data_sz Size of the data buffer
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member
        *                         \ref MUST be properly initialized, but
        *                         \ref MAY be clobbered by the
        *                         algorithm.  This parameter \ref MAY be
        *                         NULL.
        *
        * \retval #VPX_CODEC_OK
        *     Bitstream is parsable and stream information updated
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_codec_err_t vpx_codec_peek_stream_info( vpx_codec_iface_t *iface, const uint8_t *data, unsigned int data_sz, vpx_codec_stream_info_t *si);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_编解码器_err_t vpx_编解码器_peek_stream_信息（vpx_编解码器_iface_t*iface、const uint8_t*数据、无符号整数数据_sz、vpx_编解码器_stream_信息_t*si）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return information about the current stream.
        *
        * Returns information about the stream that has been parsed
        * during decoding.
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member \ref MUST be properly
        *                         initialized, but \ref MAY be clobbered
        *                         by the algorithm.  This parameter \ref
        *                         MAY be NULL.
        *
        * \retval #VPX_CODEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_codec_err_t vpx_codec_get_stream_info(
           vpx_codec_ctx_t         *ctx,
           vpx_codec_stream_info_t *si);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return information about the current stream.
        *
        * Returns information about the stream that has been parsed
        * during decoding.
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member \ref MUST be properly
        *                         initialized, but \ref MAY be clobbered
        *                         by the algorithm.  This parameter \ref
        *                         MAY be NULL.
        *
        * \retval #VPX_CODEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_codec_err_t vpx_codec_get_stream_info(
           vpx_codec_ctx_t         *ctx,
           vpx_codec_stream_info_t *si);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decode data
        *
        * Processes a buffer of coded data.  If the processing results
        * in a new decoded frame becoming available, PUT_SLICE and
        * PUT_FRAME events may be generated, as appropriate.  Encoded
        * data \ref MUST be passed in DTS (decode time stamp) order.
        * Frames produced will always be in PTS (presentation time
        * stamp) order.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] data         Pointer to this block of new coded
        *                         data.  If NULL, a
        *                         VPX_CODEC_CB_PUT_FRAME event is posted
        *                         for the previously decoded frame.
        * \param[in] data_sz      Size of the coded data, in bytes.
        * \param[in] user_priv    Application-specific data to associate
        *                         with this frame.
        * \param[in] deadline     Soft deadline the decoder should
        *                         attempt to meet, in us.  Set to zero
        *                         for unlimited.
        *
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decode data
        *
        * Processes a buffer of coded data.  If the processing results
        * in a new decoded frame becoming available, PUT_SLICE and
        * PUT_FRAME events may be generated, as appropriate.  Encoded
        * data \ref MUST be passed in DTS (decode time stamp) order.
        * Frames produced will always be in PTS (presentation time
        * stamp) order.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] data         Pointer to this block of new coded
        *                         data.  If NULL, a
        *                         VPX_CODEC_CB_PUT_FRAME event is posted
        *                         for the previously decoded frame.
        * \param[in] data_sz      Size of the coded data, in bytes.
        * \param[in] user_priv    Application-specific data to associate
        *                         with this frame.
        * \param[in] deadline     Soft deadline the decoder should
        *                         attempt to meet, in us.  Set to zero
        *                         for unlimited.
        *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \return Returns #VPX_CODEC_OK if the coded data was processed
        *         completely and future pictures can be decoded without
        *         error.  Otherwise, see the descriptions of the other
        *         error codes in ::vpx_codec_err_t for recoverability
        *         capabilities.
        */
       vpx_codec_err_t vpx_codec_decode(vpx_codec_ctx_t    *ctx,
                                        const uint8_t        *data,
                                        unsigned int            data_sz,
                                        void               *user_priv,
                                        long                deadline);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \return Returns #VPX_CODEC_OK if the coded data was processed
        *         completely and future pictures can be decoded without
        *         error.  Otherwise, see the descriptions of the other
        *         error codes in ::vpx_codec_err_t for recoverability
        *         capabilities.
        */
       vpx_codec_err_t vpx_codec_decode(vpx_codec_ctx_t    *ctx,
                                        const uint8_t        *data,
                                        unsigned int            data_sz,
                                        void               *user_priv,
                                        long                deadline);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoded frames iterator
        *
        * Iterates over a list of the frames available for display.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * NULL.
        *
        * The list of available frames becomes valid upon completion of
        * the vpx_codec_decode call, and remains valid until the next
        * call to vpx_codec_decode.
        *
        * \param[in]     ctx      Pointer to this instance&#39;s context
        * \param[in,out] iter     Iterator storage, initialized to NULL
        *
        * \return Returns a pointer to an image, if one is ready for
        *         display.  Frames produced will always be in PTS
        *         (presentation time stamp) order.
        */
       vpx_image_t *vpx_codec_get_frame(vpx_codec_ctx_t  *ctx,
                                        vpx_codec_iter_t *iter);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoded frames iterator
        *
        * Iterates over a list of the frames available for display.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * NULL.
        *
        * The list of available frames becomes valid upon completion of
        * the vpx_codec_decode call, and remains valid until the next
        * call to vpx_codec_decode.
        *
        * \param[in]     ctx      Pointer to this instance&#39;s context
        * \param[in,out] iter     Iterator storage, initialized to NULL
        *
        * \return Returns a pointer to an image, if one is ready for
        *         display.  Frames produced will always be in PTS
        *         (presentation time stamp) order.
        */
       vpx_image_t *vpx_codec_get_frame(vpx_codec_ctx_t  *ctx,
                                        vpx_codec_iter_t *iter);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_frame Frame-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_CODEC_CAP_PUT_FRAME
        * capability.  Calling these functions for codecs that don&#39;t
        * advertise this capability will result in an error code being
        * returned, usually VPX_CODEC_ERROR
        * @{
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_frame Frame-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_CODEC_CAP_PUT_FRAME
        * capability.  Calling these functions for codecs that don&#39;t
        * advertise this capability will result in an error code being
        * returned, usually VPX_CODEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put frame callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of decoded image data.
        */
       typedef void (*vpx_codec_put_frame_cb_fn_t)(
           void        *user_priv,
           const vpx_image_t *img);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put frame callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of decoded image data.
        */
       typedef void (*vpx_codec_put_frame_cb_fn_t)(
           void        *user_priv,
           const vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of frame completion.
        *
        * Registers a given function to be called when a decoded frame
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_CODEC_OK
        *     Callback successfully registered.
        * \retval #VPX_CODEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_codec_err_t vpx_codec_register_put_frame_cb(
           vpx_codec_ctx_t             *ctx,
           vpx_codec_put_frame_cb_fn_t  cb,
           void                        *user_priv);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of frame completion.
        *
        * Registers a given function to be called when a decoded frame
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_CODEC_OK
        *     Callback successfully registered.
        * \retval #VPX_CODEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_codec_err_t vpx_codec_register_put_frame_cb(
           vpx_codec_ctx_t             *ctx,
           vpx_codec_put_frame_cb_fn_t  cb,
           void                        *user_priv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_frame */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_slice Slice-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_CODEC_CAP_PUT_SLICE
        * capability.  Calling these functions for codecs that don&#39;t
        * advertise this capability will result in an error code being
        * returned, usually VPX_CODEC_ERROR
        * @{
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_slice Slice-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_CODEC_CAP_PUT_SLICE
        * capability.  Calling these functions for codecs that don&#39;t
        * advertise this capability will result in an error code being
        * returned, usually VPX_CODEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put slice callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of partially decoded image
        * data.
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put slice callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of partially decoded image
        * data.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       typedef void (*vpx_codec_put_slice_cb_fn_t)(
           void         *user_priv,
           const vpx_image_t      *img,
           const vpx_image_rect_t *valid,
           const vpx_image_rect_t *update);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       typedef void (*vpx_codec_put_slice_cb_fn_t)(
           void         *user_priv,
           const vpx_image_t      *img,
           const vpx_image_rect_t *valid,
           const vpx_image_rect_t *update);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of slice completion.
        *
        * Registers a given function to be called when a decoded slice
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_CODEC_OK
        *     Callback successfully registered.
        * \retval #VPX_CODEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_codec_err_t vpx_codec_register_put_slice_cb(
           vpx_codec_ctx_t             *ctx,
           vpx_codec_put_slice_cb_fn_t  cb,
           void                        *user_priv);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of slice completion.
        *
        * Registers a given function to be called when a decoded slice
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_CODEC_OK
        *     Callback successfully registered.
        * \retval #VPX_CODEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_codec_err_t vpx_codec_register_put_slice_cb(
           vpx_codec_ctx_t             *ctx,
           vpx_codec_put_slice_cb_fn_t  cb,
           void                        *user_priv);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_slice*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_slice*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup decoder*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup decoder*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #ifdef __cplusplus
   }
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #ifdef __cplusplus
   }
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   #include &#34;vpx_decoder_compat.h&#34;
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   #include &#34;vpx_decoder_compat.h&#34;
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.21. vpx_decoder_compat.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.21. vpx_解码器_compat.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\defgroup decoder Common Decoder Algorithm Interface
    * This abstraction allows applications using this decoder to easily
    * support multiple video formats with minimal code duplication.
    * This section describes the interface common to all codecs.
    * @{
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\defgroup decoder Common Decoder Algorithm Interface
    * This abstraction allows applications using this decoder to easily
    * support multiple video formats with minimal code duplication.
    * This section describes the interface common to all codecs.
    * @{
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file
    * \brief Provides a compatibility layer between version 1 and 2 of
    * this API.
    *
    * This interface has been deprecated.  Only existing code should
    * make use of this interface, and therefore, it is only thinly
    * documented.  Existing code should be ported to the vpx_codec_*
    * API.
    */
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file
    * \brief Provides a compatibility layer between version 1 and 2 of
    * this API.
    *
    * This interface has been deprecated.  Only existing code should
    * make use of this interface, and therefore, it is only thinly
    * documented.  Existing code should be ported to the vpx_codec_*
    * API.
    */
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_DECODER_COMPAT_H #define VPX_DECODER_COMPAT_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_解码器兼容#定义VPX_解码器兼容#
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoder algorithm return codes */
       typedef enum {
           /*!\brief Operation completed without error */
           VPX_DEC_OK = VPX_CODEC_OK,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoder algorithm return codes */
       typedef enum {
           /*!\brief Operation completed without error */
           VPX_DEC_OK = VPX_CODEC_OK,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief Unspecified error */
           VPX_DEC_ERROR = VPX_CODEC_ERROR,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief Unspecified error */
           VPX_DEC_ERROR = VPX_CODEC_ERROR,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief Memory operation failed */
           VPX_DEC_MEM_ERROR = VPX_CODEC_MEM_ERROR,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief Memory operation failed */
           VPX_DEC_MEM_ERROR = VPX_CODEC_MEM_ERROR,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief ABI version mismatch */
           VPX_DEC_ABI_MISMATCH = VPX_CODEC_ABI_MISMATCH,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief ABI version mismatch */
           VPX_DEC_ABI_MISMATCH = VPX_CODEC_ABI_MISMATCH,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief The given bitstream is not supported.
            *
            * The bitstream was unable to be parsed at the highest
            * level.  The decoder is unable to proceed.  This error \ref
            * SHOULD be treated as fatal to the stream.
            */
           VPX_DEC_UNSUP_BITSTREAM = VPX_CODEC_UNSUP_BITSTREAM,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief The given bitstream is not supported.
            *
            * The bitstream was unable to be parsed at the highest
            * level.  The decoder is unable to proceed.  This error \ref
            * SHOULD be treated as fatal to the stream.
            */
           VPX_DEC_UNSUP_BITSTREAM = VPX_CODEC_UNSUP_BITSTREAM,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief Encoded bitstream uses an unsupported feature
            *
            * The decoder does not implement a feature required by the
            * encoder.  This return code should only be used for
            * features that prevent future pictures from being properly
            * decoded.  This error \ref MAY be treated as fatal to the
            * stream or \ref MAY be treated as fatal to the current
            * Group of Pictures (GOP).
            */
           VPX_DEC_UNSUP_FEATURE = VPX_CODEC_UNSUP_FEATURE,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief Encoded bitstream uses an unsupported feature
            *
            * The decoder does not implement a feature required by the
            * encoder.  This return code should only be used for
            * features that prevent future pictures from being properly
            * decoded.  This error \ref MAY be treated as fatal to the
            * stream or \ref MAY be treated as fatal to the current
            * Group of Pictures (GOP).
            */
           VPX_DEC_UNSUP_FEATURE = VPX_CODEC_UNSUP_FEATURE,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief The coded data for this stream is corrupt or
            * incomplete
            *
            * There was a problem decoding the current frame.  This
            * return code should only be used for failures that prevent
            * future pictures from being properly decoded.  This error
            * \ref MAY be treated as fatal to the stream or \ref MAY be
            * treated as fatal to the current GOP.  If decoding is
            * continued for the current GOP, artifacts may be present.
            */
           VPX_DEC_CORRUPT_FRAME = VPX_CODEC_CORRUPT_FRAME,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief The coded data for this stream is corrupt or
            * incomplete
            *
            * There was a problem decoding the current frame.  This
            * return code should only be used for failures that prevent
            * future pictures from being properly decoded.  This error
            * \ref MAY be treated as fatal to the stream or \ref MAY be
            * treated as fatal to the current GOP.  If decoding is
            * continued for the current GOP, artifacts may be present.
            */
           VPX_DEC_CORRUPT_FRAME = VPX_CODEC_CORRUPT_FRAME,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief An application-supplied parameter is not valid.
            *
            */
           VPX_DEC_INVALID_PARAM = VPX_CODEC_INVALID_PARAM,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief An application-supplied parameter is not valid.
            *
            */
           VPX_DEC_INVALID_PARAM = VPX_CODEC_INVALID_PARAM,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief An iterator reached the end of list.
            *
            */
           VPX_DEC_LIST_END = VPX_CODEC_LIST_END
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /*!\brief An iterator reached the end of list.
            *
            */
           VPX_DEC_LIST_END = VPX_CODEC_LIST_END
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       }
       vpx_dec_err_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       }
       vpx_dec_err_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*! \brief Decoder capabilities bitfield
        *
        *  Each decoder advertises the capabilities it supports as part
        *  of its ::vpx_dec_iface_t interface structure.  Capabilities
        *  are extra interfaces or functionality, and are not required
        *  to be supported by a decoder.
        *
        *  The available flags are specified by VPX_DEC_CAP_* defines.
        */
       typedef int vpx_dec_caps_t;
   #define VPX_DEC_CAP_PUT_SLICE  0x0001 /**&lt; Will issue put_slice
                                            callbacks */
   #define VPX_DEC_CAP_PUT_FRAME  0x0002 /**&lt; Will issue put_frame
                                            callbacks */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*! \brief Decoder capabilities bitfield
        *
        *  Each decoder advertises the capabilities it supports as part
        *  of its ::vpx_dec_iface_t interface structure.  Capabilities
        *  are extra interfaces or functionality, and are not required
        *  to be supported by a decoder.
        *
        *  The available flags are specified by VPX_DEC_CAP_* defines.
        */
       typedef int vpx_dec_caps_t;
   #define VPX_DEC_CAP_PUT_SLICE  0x0001 /**&lt; Will issue put_slice
                                            callbacks */
   #define VPX_DEC_CAP_PUT_FRAME  0x0002 /**&lt; Will issue put_frame
                                            callbacks */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define VPX_DEC_CAP_XMA        0x0004 /**&lt; Supports External Memory
                                            Allocation */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define VPX_DEC_CAP_XMA        0x0004 /**&lt; Supports External Memory
                                            Allocation */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Stream properties
        *
        * This structure is used to query or set properties of the
        * decoded stream.  Algorithms may extend this structure with
        * data specific to their bitstream by setting the sz member
        * appropriately.
        */
   #if 1
       typedef vpx_codec_stream_info_t vpx_dec_stream_info_t;
   #else
       typedef struct
       {
           unsigned int sz;    /**&lt; Size of this structure */
           unsigned int w;     /**&lt; Width (or 0 for unknown/default) */
           unsigned int h;     /**&lt; Height (or 0 for unknown/default) */
           unsigned int is_kf; /**&lt; Current frame is a keyframe */
       } vpx_dec_stream_info_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Stream properties
        *
        * This structure is used to query or set properties of the
        * decoded stream.  Algorithms may extend this structure with
        * data specific to their bitstream by setting the sz member
        * appropriately.
        */
   #if 1
       typedef vpx_codec_stream_info_t vpx_dec_stream_info_t;
   #else
       typedef struct
       {
           unsigned int sz;    /**&lt; Size of this structure */
           unsigned int w;     /**&lt; Width (or 0 for unknown/default) */
           unsigned int h;     /**&lt; Height (or 0 for unknown/default) */
           unsigned int is_kf; /**&lt; Current frame is a keyframe */
       } vpx_dec_stream_info_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoder interface structure.
        *
        * Contains function pointers and other data private to the
        * decoder implementation.  This structure is opaque to the
        * application.
        */
       typedef const struct vpx_codec_iface vpx_dec_iface_t;
       typedef       struct vpx_codec_priv  vpx_dec_priv_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoder interface structure.
        *
        * Contains function pointers and other data private to the
        * decoder implementation.  This structure is opaque to the
        * application.
        */
       typedef const struct vpx_codec_iface vpx_dec_iface_t;
       typedef       struct vpx_codec_priv  vpx_dec_priv_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Iterator
        *
        * Opaque storage used for iterating over lists.
        */
       typedef vpx_codec_iter_t vpx_dec_iter_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Iterator
        *
        * Opaque storage used for iterating over lists.
        */
       typedef vpx_codec_iter_t vpx_dec_iter_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoder context structure
        *
        * All decoders \ref MUST support this context structure fully.
        * In general, this data should be considered private to the
        * decoder algorithm, and not be manipulated or examined by the
        * calling application.  Applications may reference the &#39;name&#39;
        * member to get a printable description of the algorithm.
        */
   #if 1
       typedef vpx_codec_ctx_t vpx_dec_ctx_t;
   #else
       typedef struct
       {
           const char          *name;  /**&lt; Printable interface name */
           vpx_dec_iface_t     *iface; /**&lt; Interface pointers */
           vpx_dec_err_t        err;   /**&lt; Last returned error */
           vpx_dec_priv_t      *priv;  /**&lt; Algorithm private storage */
       } vpx_dec_ctx_t;
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoder context structure
        *
        * All decoders \ref MUST support this context structure fully.
        * In general, this data should be considered private to the
        * decoder algorithm, and not be manipulated or examined by the
        * calling application.  Applications may reference the &#39;name&#39;
        * member to get a printable description of the algorithm.
        */
   #if 1
       typedef vpx_codec_ctx_t vpx_dec_ctx_t;
   #else
       typedef struct
       {
           const char          *name;  /**&lt; Printable interface name */
           vpx_dec_iface_t     *iface; /**&lt; Interface pointers */
           vpx_dec_err_t        err;   /**&lt; Last returned error */
           vpx_dec_priv_t      *priv;  /**&lt; Algorithm private storage */
       } vpx_dec_ctx_t;
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return the build configuration
        *
        * Returns a printable string containing an encoded version of
        * the build configuration.  This may be useful to vpx support.
        *
        */
       const char *vpx_dec_build_config(void) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return the build configuration
        *
        * Returns a printable string containing an encoded version of
        * the build configuration.  This may be useful to vpx support.
        *
        */
       const char *vpx_dec_build_config(void) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return the name for a given interface
        *
        * Returns a human readable string for name of the given decoder
        * interface.
        *
        * \param[in]    iface     Interface pointer
        *
        */
       const char *vpx_dec_iface_name(
           vpx_dec_iface_t *iface) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return the name for a given interface
        *
        * Returns a human readable string for name of the given decoder
        * interface.
        *
        * \param[in]    iface     Interface pointer
        *
        */
       const char *vpx_dec_iface_name(
           vpx_dec_iface_t *iface) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Convert error number to printable string
        *
        * Returns a human readable string for the last error returned
        * by the algorithm.  The returned error will be one line and
        * will not contain any newline characters.
        *
        *
        * \param[in]    err     Error number.
        *
        */
       const char *vpx_dec_err_to_string(vpx_dec_err_t  err) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Convert error number to printable string
        *
        * Returns a human readable string for the last error returned
        * by the algorithm.  The returned error will be one line and
        * will not contain any newline characters.
        *
        *
        * \param[in]    err     Error number.
        *
        */
       const char *vpx_dec_err_to_string(vpx_dec_err_t  err) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Retrieve error synopsis for decoder context
        *
        * Returns a human readable string for the last error returned by
        * the algorithm.  The returned error will be one line and will
        * not contain any newline characters.
        *
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        *
        */
       const char *vpx_dec_error(vpx_dec_ctx_t  *ctx) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Retrieve error synopsis for decoder context
        *
        * Returns a human readable string for the last error returned by
        * the algorithm.  The returned error will be one line and will
        * not contain any newline characters.
        *
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        *
        */
       const char *vpx_dec_error(vpx_dec_ctx_t  *ctx) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Retrieve detailed error information for decoder context
        *
        * Returns a human readable string providing detailed information
        * about the last error.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        *
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Retrieve detailed error information for decoder context
        *
        * Returns a human readable string providing detailed information
        * about the last error.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \retval NULL
        *     No detailed information is available.
        */
       const char *vpx_dec_error_detail(vpx_dec_ctx_t  *ctx) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \retval NULL
        *     No detailed information is available.
        */
       const char *vpx_dec_error_detail(vpx_dec_ctx_t  *ctx) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* REQUIRED FUNCTIONS
        *
        * The following functions are required to be implemented for all
        * decoders.  They represent the base case functionality expected
        * of all decoders.
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* REQUIRED FUNCTIONS
        *
        * The following functions are required to be implemented for all
        * decoders.  They represent the base case functionality expected
        * of all decoders.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_dec_init convenience macro
        * instead of this function directly, to ensure that the ABI
        * version number parameter is properly initialized.
        *
        * \param[in]   ctx    Pointer to this instance&#39;s context.
        * \param[in]   iface  Pointer to the algorithm interface to use.
        * \param[in]   ver    ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_DEC_MEM_ERROR
        *     Memory allocation failed.
        */
       vpx_dec_err_t vpx_dec_init_ver(
           vpx_dec_ctx_t    *ctx,
           vpx_dec_iface_t  *iface,
           int               ver) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_dec_init convenience macro
        * instead of this function directly, to ensure that the ABI
        * version number parameter is properly initialized.
        *
        * \param[in]   ctx    Pointer to this instance&#39;s context.
        * \param[in]   iface  Pointer to the algorithm interface to use.
        * \param[in]   ver    ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_DEC_MEM_ERROR
        *     Memory allocation failed.
        */
       vpx_dec_err_t vpx_dec_init_ver(
           vpx_dec_ctx_t    *ctx,
           vpx_dec_iface_t  *iface,
           int               ver) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#define vpx_dec_init(ctx, iface) \ vpx_dec_init_ver(ctx, iface, VPX_DECODER_ABI_VERSION)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#定义vpx_dec_init（ctx，iface）\vpx_dec_init版本（ctx，iface，vpx_解码器ABI_版本）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Destroy a decoder instance
        *
        * Destroys a decoder context, freeing any associated memory
        * buffers.
        *
        * \param[in] ctx   Pointer to this instance&#39;s context
        *
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Destroy a decoder instance
        *
        * Destroys a decoder context, freeing any associated memory
        * buffers.
        *
        * \param[in] ctx   Pointer to this instance&#39;s context
        *
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \retval #VPX_DEC_MEM_ERROR
        *     Memory allocation failed.
        */
       vpx_dec_err_t vpx_dec_destroy(vpx_dec_ctx_t *ctx) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        * \retval #VPX_DEC_MEM_ERROR
        *     Memory allocation failed.
        */
       vpx_dec_err_t vpx_dec_destroy(vpx_dec_ctx_t *ctx) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Get the capabilities of an algorithm.
        *
        * Retrieves the capabilities bitfield from the algorithm&#39;s
        * interface.
        *
        * \param[in] iface   Pointer to the algorithm interface
        *
        */
       vpx_dec_caps_t vpx_dec_get_caps(
           vpx_dec_iface_t *iface) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Get the capabilities of an algorithm.
        *
        * Retrieves the capabilities bitfield from the algorithm&#39;s
        * interface.
        *
        * \param[in] iface   Pointer to the algorithm interface
        *
        */
       vpx_dec_caps_t vpx_dec_get_caps(
           vpx_dec_iface_t *iface) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Parse stream info from a buffer
        *
        * Performs high level parsing of the bitstream.  Construction of
        * a decoder context is not necessary.  Can be used to determine
        * if the bitstream is of the proper format, and to extract
        * information from the stream.
        *
        * \param[in]      iface   Pointer to the algorithm interface
        * \param[in]      data    Pointer to a block of data to parse
        * \param[in]      data_sz Size of the data buffer
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member \ref MUST be properly
        *                         initialized, but \ref MAY be
        *                         clobbered by the algorithm.  This
        *                         parameter \ref MAY be NULL.
        *
        * \retval #VPX_DEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_dec_err_t vpx_dec_peek_stream_info(
                                vpx_dec_iface_t       *iface,
                                const uint8_t         *data,
                                unsigned int           data_sz,
                                vpx_dec_stream_info_t *si) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Parse stream info from a buffer
        *
        * Performs high level parsing of the bitstream.  Construction of
        * a decoder context is not necessary.  Can be used to determine
        * if the bitstream is of the proper format, and to extract
        * information from the stream.
        *
        * \param[in]      iface   Pointer to the algorithm interface
        * \param[in]      data    Pointer to a block of data to parse
        * \param[in]      data_sz Size of the data buffer
        * \param[in,out]  si      Pointer to stream info to update.  The
        *                         size member \ref MUST be properly
        *                         initialized, but \ref MAY be
        *                         clobbered by the algorithm.  This
        *                         parameter \ref MAY be NULL.
        *
        * \retval #VPX_DEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_dec_err_t vpx_dec_peek_stream_info(
                                vpx_dec_iface_t       *iface,
                                const uint8_t         *data,
                                unsigned int           data_sz,
                                vpx_dec_stream_info_t *si) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return information about the current stream.
        *
        * Returns information about the stream that has been parsed
        * during decoding.
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context
        * \param[in,out]  si      Pointer to stream info to update.
        *                         The size member \ref MUST be properly
        *                         initialized, but \ref MAY be clobbered
        *                         by the algorithm.  This parameter \ref
        *                         MAY be NULL.
        *
        * \retval #VPX_DEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_dec_err_t vpx_dec_get_stream_info(
           vpx_dec_ctx_t         *ctx,
           vpx_dec_stream_info_t *si) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Return information about the current stream.
        *
        * Returns information about the stream that has been parsed
        * during decoding.
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context
        * \param[in,out]  si      Pointer to stream info to update.
        *                         The size member \ref MUST be properly
        *                         initialized, but \ref MAY be clobbered
        *                         by the algorithm.  This parameter \ref
        *                         MAY be NULL.
        *
        * \retval #VPX_DEC_OK
        *     Bitstream is parsable and stream information updated
        */
       vpx_dec_err_t vpx_dec_get_stream_info(
           vpx_dec_ctx_t         *ctx,
           vpx_dec_stream_info_t *si) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Control algorithm
        *
        * This function is used to exchange algorithm-specific data with
        * the decoder instance.  This can be used to implement features
        * specific to a particular algorithm.
        *
        * This wrapper function dispatches the request to the helper
        * function associated with the given ctrl_id.  It tries to call
        * this function transparently, but will return #VPX_DEC_ERROR if
        * the request could not be dispatched.
        *
        * \param[in]     ctx          Pointer to this instance&#39;s context
        * \param[in]     ctrl_id      Algorithm-specific control
        *                             identifier
        * \param[in,out] data         Data to exchange with algorithm
        *                             instance.
        *
        * \retval #VPX_DEC_OK
        *     The control request was processed.
        * \retval #VPX_DEC_ERROR
        *     The control request was not processed.
        * \retval #VPX_DEC_INVALID_PARAM
        *     The data was not valid.
        */
       vpx_dec_err_t vpx_dec_control(vpx_dec_ctx_t  *ctx,
                                     int             ctrl_id,
                                     void           *data) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Control algorithm
        *
        * This function is used to exchange algorithm-specific data with
        * the decoder instance.  This can be used to implement features
        * specific to a particular algorithm.
        *
        * This wrapper function dispatches the request to the helper
        * function associated with the given ctrl_id.  It tries to call
        * this function transparently, but will return #VPX_DEC_ERROR if
        * the request could not be dispatched.
        *
        * \param[in]     ctx          Pointer to this instance&#39;s context
        * \param[in]     ctrl_id      Algorithm-specific control
        *                             identifier
        * \param[in,out] data         Data to exchange with algorithm
        *                             instance.
        *
        * \retval #VPX_DEC_OK
        *     The control request was processed.
        * \retval #VPX_DEC_ERROR
        *     The control request was not processed.
        * \retval #VPX_DEC_INVALID_PARAM
        *     The data was not valid.
        */
       vpx_dec_err_t vpx_dec_control(vpx_dec_ctx_t  *ctx,
                                     int             ctrl_id,
                                     void           *data) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decode data
        *
        * Processes a buffer of coded data.  If the processing results
        * in a new decoded frame becoming available,
        * #VPX_DEC_CB_PUT_SLICE and #VPX_DEC_CB_PUT_FRAME events may be
        * generated, as appropriate.  Encoded data \ref MUST be passed
        * in DTS (decode time stamp) order.  Frames produced will always
        * be in PTS (presentation time stamp) order.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] data         Pointer to this block of new coded
        *                         data.  If NULL, a VPX_DEC_CB_PUT_FRAME
        *                         event is posted for the previously
        *                         decoded frame.
        * \param[in] data_sz      Size of the coded data, in bytes.
        * \param[in] user_priv    Application-specific data to associate
        *                         with this frame.
        * \param[in] rel_pts      PTS relative to the previous frame, in
        *                         us.  If unknown or unavailable, set to
        *                         zero.
        *
        * \return Returns #VPX_DEC_OK if the coded data was processed
        *         completely and future pictures can be decoded without
        *         error.  Otherwise, see the descriptions of the other
        *         error codes in ::vpx_dec_err_t for recoverability
        *         capabilities.
        */
       vpx_dec_err_t vpx_dec_decode(
           vpx_dec_ctx_t  *ctx,
           uint8_t        *data,
           unsigned int    data_sz,
           void           *user_priv,
           int             rel_pts) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decode data
        *
        * Processes a buffer of coded data.  If the processing results
        * in a new decoded frame becoming available,
        * #VPX_DEC_CB_PUT_SLICE and #VPX_DEC_CB_PUT_FRAME events may be
        * generated, as appropriate.  Encoded data \ref MUST be passed
        * in DTS (decode time stamp) order.  Frames produced will always
        * be in PTS (presentation time stamp) order.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] data         Pointer to this block of new coded
        *                         data.  If NULL, a VPX_DEC_CB_PUT_FRAME
        *                         event is posted for the previously
        *                         decoded frame.
        * \param[in] data_sz      Size of the coded data, in bytes.
        * \param[in] user_priv    Application-specific data to associate
        *                         with this frame.
        * \param[in] rel_pts      PTS relative to the previous frame, in
        *                         us.  If unknown or unavailable, set to
        *                         zero.
        *
        * \return Returns #VPX_DEC_OK if the coded data was processed
        *         completely and future pictures can be decoded without
        *         error.  Otherwise, see the descriptions of the other
        *         error codes in ::vpx_dec_err_t for recoverability
        *         capabilities.
        */
       vpx_dec_err_t vpx_dec_decode(
           vpx_dec_ctx_t  *ctx,
           uint8_t        *data,
           unsigned int    data_sz,
           void           *user_priv,
           int             rel_pts) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoded frames iterator
        *
        * Iterates over a list of the frames available for display.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * NULL.
        *
        * The list of available frames becomes valid upon completion of
        * the vpx_dec_decode call, and remains valid until the next call
        * to vpx_dec_decode.
        *
        * \param[in]     ctx      Pointer to this instance&#39;s context
        * \param[in out] iter     Iterator storage, initialized to NULL
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Decoded frames iterator
        *
        * Iterates over a list of the frames available for display.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * NULL.
        *
        * The list of available frames becomes valid upon completion of
        * the vpx_dec_decode call, and remains valid until the next call
        * to vpx_dec_decode.
        *
        * \param[in]     ctx      Pointer to this instance&#39;s context
        * \param[in out] iter     Iterator storage, initialized to NULL
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *
        * \return Returns a pointer to an image, if one is ready for
        *         display.  Frames produced will always be in PTS
        *         (presentation time stamp) order.
        */
       vpx_image_t *vpx_dec_get_frame(vpx_dec_ctx_t  *ctx,
                                      vpx_dec_iter_t *iter) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *
        * \return Returns a pointer to an image, if one is ready for
        *         display.  Frames produced will always be in PTS
        *         (presentation time stamp) order.
        */
       vpx_image_t *vpx_dec_get_frame(vpx_dec_ctx_t  *ctx,
                                      vpx_dec_iter_t *iter) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_frame Frame-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_PUT_FRAME capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR @{
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_frame Frame-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_PUT_FRAME capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put frame callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of decoded image data.
        */
       typedef void (*vpx_dec_put_frame_cb_fn_t)(
               void          *user_priv,
               const vpx_image_t *img);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put frame callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of decoded image data.
        */
       typedef void (*vpx_dec_put_frame_cb_fn_t)(
               void          *user_priv,
               const vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of frame completion.
        *
        * Registers a given function to be called when a decoded frame
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_DEC_OK
        *     Callback successfully registered.
        * \retval #VPX_DEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_dec_err_t vpx_dec_register_put_frame_cb(
               vpx_dec_ctx_t             *ctx,
               vpx_dec_put_frame_cb_fn_t  cb,
               void                      *user_priv) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of frame completion.
        *
        * Registers a given function to be called when a decoded frame
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_DEC_OK
        *     Callback successfully registered.
        * \retval #VPX_DEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_dec_err_t vpx_dec_register_put_frame_cb(
               vpx_dec_ctx_t             *ctx,
               vpx_dec_put_frame_cb_fn_t  cb,
               void                      *user_priv) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_frame */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_frame */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_slice Slice-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_PUT_SLICE capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR
        * @{
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_put_slice Slice-Based Decoding Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_PUT_SLICE capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put slice callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of partially decoded image
        * data.
        */
       typedef void (*vpx_dec_put_slice_cb_fn_t)(void        *user_priv,
               const vpx_image_t      *img,
               const vpx_image_rect_t *valid,
               const vpx_image_rect_t *update);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief put slice callback prototype
        *
        * This callback is invoked by the decoder to notify the
        * application of the availability of partially decoded image
        * data.
        */
       typedef void (*vpx_dec_put_slice_cb_fn_t)(void        *user_priv,
               const vpx_image_t      *img,
               const vpx_image_rect_t *valid,
               const vpx_image_rect_t *update);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of slice completion.
        *
        * Registers a given function to be called when a decoded slice
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_DEC_OK
        *     Callback successfully registered.
        * \retval #VPX_DEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_dec_err_t vpx_dec_register_put_slice_cb(vpx_dec_ctx_t   *ctx,
               vpx_dec_put_slice_cb_fn_t  cb,
               void                      *user_priv) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Register for notification of slice completion.
        *
        * Registers a given function to be called when a decoded slice
        * is available.
        *
        * \param[in] ctx          Pointer to this instance&#39;s context
        * \param[in] cb           Pointer to the callback function
        * \param[in] user_priv    User&#39;s private data
        *
        * \retval #VPX_DEC_OK
        *     Callback successfully registered.
        * \retval #VPX_DEC_ERROR
        *     Decoder context not initialized, or algorithm not capable
        *     of posting slice completion.
        */
       vpx_dec_err_t vpx_dec_register_put_slice_cb(vpx_dec_ctx_t   *ctx,
               vpx_dec_put_slice_cb_fn_t  cb,
               void                      *user_priv) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_slice*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_put_slice*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_xma External Memory Allocation Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_XMA capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR
        * @{
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\defgroup cap_xma External Memory Allocation Functions
        *
        * The following functions are required to be implemented for all
        * decoders that advertise the VPX_DEC_CAP_XMA capability.
        * Calling these functions for codecs that don&#39;t advertise this
        * capability will result in an error code being returned,
        * usually VPX_DEC_ERROR
        * @{
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Memory Map Entry
        *
        * This structure is used to contain the properties of a memory
        * segment.  It is populated by the decoder in the request phase,
        * and by the calling application once the requested allocation
        * has been performed.
        */
   #if 1
   #define VPX_DEC_MEM_ZERO     0x1  /**&lt; Segment must be zeroed by
                                          allocation */
   #define VPX_DEC_MEM_WRONLY   0x2  /**&lt; Segment need not be
                                          readable */
   #define VPX_DEC_MEM_FAST     0x4  /**&lt; Place in fast memory, if
                                          available */
       typedef struct vpx_codec_mmap vpx_dec_mmap_t;
   #else
       typedef struct vpx_dec_mmap
       {
           /*
            * The following members are set by the codec when requesting
            * a segment
            */
           unsigned int   id;     /**&lt; identifier for the segment&#39;s
                                       contents */
           unsigned long  sz;     /**&lt; size of the segment, in bytes */
           unsigned int   align;  /**&lt; required alignment of the
                                       segment, in bytes */
           unsigned int   flags;  /**&lt; bitfield containing segment
                                       properties */
   #define VPX_DEC_MEM_ZERO     0x1  /**&lt; Segment must be zeroed by
                                          allocation */
   #define VPX_DEC_MEM_WRONLY   0x2  /**&lt; Segment need not be
                                          readable */
   #define VPX_DEC_MEM_FAST     0x4  /**&lt; Place in fast memory, if
                                          available */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Memory Map Entry
        *
        * This structure is used to contain the properties of a memory
        * segment.  It is populated by the decoder in the request phase,
        * and by the calling application once the requested allocation
        * has been performed.
        */
   #if 1
   #define VPX_DEC_MEM_ZERO     0x1  /**&lt; Segment must be zeroed by
                                          allocation */
   #define VPX_DEC_MEM_WRONLY   0x2  /**&lt; Segment need not be
                                          readable */
   #define VPX_DEC_MEM_FAST     0x4  /**&lt; Place in fast memory, if
                                          available */
       typedef struct vpx_codec_mmap vpx_dec_mmap_t;
   #else
       typedef struct vpx_dec_mmap
       {
           /*
            * The following members are set by the codec when requesting
            * a segment
            */
           unsigned int   id;     /**&lt; identifier for the segment&#39;s
                                       contents */
           unsigned long  sz;     /**&lt; size of the segment, in bytes */
           unsigned int   align;  /**&lt; required alignment of the
                                       segment, in bytes */
           unsigned int   flags;  /**&lt; bitfield containing segment
                                       properties */
   #define VPX_DEC_MEM_ZERO     0x1  /**&lt; Segment must be zeroed by
                                          allocation */
   #define VPX_DEC_MEM_WRONLY   0x2  /**&lt; Segment need not be
                                          readable */
   #define VPX_DEC_MEM_FAST     0x4  /**&lt; Place in fast memory, if
                                          available */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* The following members are to be filled in by the
            * allocation function */
           void          *base;   /**&lt; pointer to the allocated
                                       segment */
           void (*dtor)(struct vpx_dec_mmap *map);  /**&lt; destructor to
                                                         call */
           void          *priv;   /**&lt; allocator private storage */
       } vpx_dec_mmap_t;
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* The following members are to be filled in by the
            * allocation function */
           void          *base;   /**&lt; pointer to the allocated
                                       segment */
           void (*dtor)(struct vpx_dec_mmap *map);  /**&lt; destructor to
                                                         call */
           void          *priv;   /**&lt; allocator private storage */
       } vpx_dec_mmap_t;
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance in external allocation
        * mode
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_dec_xma_init convenience
        * macro instead of this function directly, to ensure that the
        * ABI version number parameter is properly initialized.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        * \param[in]    iface   Pointer to the algorithm interface to
        *                       use.
        * \param[in]    ver     ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        */
       vpx_dec_err_t vpx_dec_xma_init_ver(vpx_dec_ctx_t    *ctx,
                                          vpx_dec_iface_t  *iface,
                                          int           ver) DEPRECATED;
   #define vpx_dec_xma_init(ctx, iface) \
       vpx_dec_xma_init_ver(ctx, iface, VPX_DECODER_ABI_VERSION)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Initialize a decoder instance in external allocation
        * mode
        *
        * Initializes a decoder context using the given interface.
        * Applications should call the vpx_dec_xma_init convenience
        * macro instead of this function directly, to ensure that the
        * ABI version number parameter is properly initialized.
        *
        * \param[in]    ctx     Pointer to this instance&#39;s context.
        * \param[in]    iface   Pointer to the algorithm interface to
        *                       use.
        * \param[in]    ver     ABI version number.  Must be set to
        *                       VPX_DECODER_ABI_VERSION
        * \retval #VPX_DEC_OK
        *     The decoder algorithm initialized.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        */
       vpx_dec_err_t vpx_dec_xma_init_ver(vpx_dec_ctx_t    *ctx,
                                          vpx_dec_iface_t  *iface,
                                          int           ver) DEPRECATED;
   #define vpx_dec_xma_init(ctx, iface) \
       vpx_dec_xma_init_ver(ctx, iface, VPX_DECODER_ABI_VERSION)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Iterate over the list of segments to allocate.
        *
        * Iterates over a list of the segments to allocate.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * VPX_DEC_LIST_END.  The amount of memory needed to allocate is
        * dependent upon the size of the encoded stream.  This means
        * that the stream info structure must be known at allocation
        * time.  It can be populated with the vpx_dec_peek_stream_info()
        * function.  In cases where the stream to be decoded is not
        * available at allocation time, a fixed size must be requested.
        * The decoder will not be able to decode streams larger than the
        * size used at allocation time.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Iterate over the list of segments to allocate.
        *
        * Iterates over a list of the segments to allocate.  The
        * iterator storage should be initialized to NULL to start the
        * iteration.  Iteration is complete when this function returns
        * VPX_DEC_LIST_END.  The amount of memory needed to allocate is
        * dependent upon the size of the encoded stream.  This means
        * that the stream info structure must be known at allocation
        * time.  It can be populated with the vpx_dec_peek_stream_info()
        * function.  In cases where the stream to be decoded is not
        * available at allocation time, a fixed size must be requested.
        * The decoder will not be able to decode streams larger than the
        * size used at allocation time.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context.
        * \param[out]     mmap    Pointer to the memory map entry to
        *                         populate.
        * \param[in]      si      Pointer to the stream info.
        * \param[in out]  iter    Iterator storage, initialized to NULL
        *
        * \retval #VPX_DEC_OK
        *     The memory map entry was populated.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        * \retval #VPX_DEC_MEM_ERROR
        *     Unable to determine segment size from stream info.
        */
       vpx_dec_err_t vpx_dec_get_mem_map(
           vpx_dec_ctx_t                *ctx,
           vpx_dec_mmap_t               *mmap,
           const vpx_dec_stream_info_t  *si,
           vpx_dec_iter_t               *iter) DEPRECATED;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        *
        * \param[in]      ctx     Pointer to this instance&#39;s context.
        * \param[out]     mmap    Pointer to the memory map entry to
        *                         populate.
        * \param[in]      si      Pointer to the stream info.
        * \param[in out]  iter    Iterator storage, initialized to NULL
        *
        * \retval #VPX_DEC_OK
        *     The memory map entry was populated.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        * \retval #VPX_DEC_MEM_ERROR
        *     Unable to determine segment size from stream info.
        */
       vpx_dec_err_t vpx_dec_get_mem_map(
           vpx_dec_ctx_t                *ctx,
           vpx_dec_mmap_t               *mmap,
           const vpx_dec_stream_info_t  *si,
           vpx_dec_iter_t               *iter) DEPRECATED;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Identify allocated segments to decoder instance
        *
        * Stores a list of allocated segments in the decoder.  Segments
        * \ref MUST be passed in the order they are read from
        * vpx_dec_get_mem_map(), but may be passed in groups of any
        * size.  Segments \ref MUST be set only once.  The allocation
        * function \ref MUST ensure that the vpx_dec_mmap_t::base member
        * is non-NULL.  If the segment requires cleanup handling (e.g.,
        * calling free() or close()) then the vpx_dec_mmap_t::dtor
        * member \ref MUST be populated.
        *
        * \param[in]      ctx       Pointer to this instance&#39;s context.
        * \param[in]      mmaps     Pointer to the first memory map
        *                           entry in the list.
        * \param[in]      num_maps  Number of entries being set at this
        *                           time
        *
        * \retval #VPX_DEC_OK
        *     The segment was stored in the decoder context.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        * \retval #VPX_DEC_MEM_ERROR
        *     Segment base address was not set, or segment was already
        * stored.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Identify allocated segments to decoder instance
        *
        * Stores a list of allocated segments in the decoder.  Segments
        * \ref MUST be passed in the order they are read from
        * vpx_dec_get_mem_map(), but may be passed in groups of any
        * size.  Segments \ref MUST be set only once.  The allocation
        * function \ref MUST ensure that the vpx_dec_mmap_t::base member
        * is non-NULL.  If the segment requires cleanup handling (e.g.,
        * calling free() or close()) then the vpx_dec_mmap_t::dtor
        * member \ref MUST be populated.
        *
        * \param[in]      ctx       Pointer to this instance&#39;s context.
        * \param[in]      mmaps     Pointer to the first memory map
        *                           entry in the list.
        * \param[in]      num_maps  Number of entries being set at this
        *                           time
        *
        * \retval #VPX_DEC_OK
        *     The segment was stored in the decoder context.
        * \retval #VPX_DEC_ERROR
        *     Decoder does not support XMA mode.
        * \retval #VPX_DEC_MEM_ERROR
        *     Segment base address was not set, or segment was already
        * stored.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
*/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
*/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_dec_err_t vpx_dec_set_mem_map( vpx_dec_ctx_t *ctx, vpx_dec_mmap_t *mmaps, unsigned int num_maps) DEPRECATED;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_dec_err_t vpx_dec_set_mem_map（vpx_dec_ctx_t*ctx，vpx_dec_mmap_t*mmaps，无符号整数映射）已弃用；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_xma*/
       /*!@} - end defgroup decoder*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!@} - end defgroup cap_xma*/
       /*!@} - end defgroup decoder*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #endif
   #ifdef __cplusplus
   }
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #endif
   #ifdef __cplusplus
   }
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.22. vpx_image.c
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.22. vpx_image.c
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #include &lt;stdlib.h&gt;
   #include &lt;string.h&gt;
   #include &#34;vpx/vpx_image.h&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #include &lt;stdlib.h&gt;
   #include &lt;string.h&gt;
   #include &#34;vpx/vpx_image.h&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
static vpx_image_t *img_alloc_helper(vpx_image_t *img, vpx_img_fmt_t fmt, unsigned int d_w, unsigned int d_h, unsigned int stride_align, unsigned char *img_data) {
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态vpx_image_t*img_alloc_helper（vpx_image_t*img，vpx_img_fmt_t fmt，无符号整数d_w，无符号整数d_h，无符号整数步长对齐，无符号字符*img_数据）{
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int  h, w, s, xcs, ycs, bps;
       int           align;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       unsigned int  h, w, s, xcs, ycs, bps;
       int           align;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Treat align==0 like align==1 */
       if (!stride_align)
           stride_align = 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Treat align==0 like align==1 */
       if (!stride_align)
           stride_align = 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Validate alignment (must be power of 2) */
       if (stride_align &amp; (stride_align - 1))
           goto fail;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Validate alignment (must be power of 2) */
       if (stride_align &amp; (stride_align - 1))
           goto fail;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get sample size for this format */
       switch (fmt)
       {
       case VPX_IMG_FMT_RGB32:
       case VPX_IMG_FMT_RGB32_LE:
       case VPX_IMG_FMT_ARGB:
       case VPX_IMG_FMT_ARGB_LE:
           bps = 32;
           break;
       case VPX_IMG_FMT_RGB24:
       case VPX_IMG_FMT_BGR24:
           bps = 24;
           break;
       case VPX_IMG_FMT_RGB565:
       case VPX_IMG_FMT_RGB565_LE:
       case VPX_IMG_FMT_RGB555:
       case VPX_IMG_FMT_RGB555_LE:
       case VPX_IMG_FMT_UYVY:
       case VPX_IMG_FMT_YUY2:
       case VPX_IMG_FMT_YVYU:
           bps = 16;
           break;
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           bps = 12;
           break;
       default:
           bps = 16;
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get sample size for this format */
       switch (fmt)
       {
       case VPX_IMG_FMT_RGB32:
       case VPX_IMG_FMT_RGB32_LE:
       case VPX_IMG_FMT_ARGB:
       case VPX_IMG_FMT_ARGB_LE:
           bps = 32;
           break;
       case VPX_IMG_FMT_RGB24:
       case VPX_IMG_FMT_BGR24:
           bps = 24;
           break;
       case VPX_IMG_FMT_RGB565:
       case VPX_IMG_FMT_RGB565_LE:
       case VPX_IMG_FMT_RGB555:
       case VPX_IMG_FMT_RGB555_LE:
       case VPX_IMG_FMT_UYVY:
       case VPX_IMG_FMT_YUY2:
       case VPX_IMG_FMT_YVYU:
           bps = 16;
           break;
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           bps = 12;
           break;
       default:
           bps = 16;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get chroma shift values for this format */
       switch (fmt)
       {
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           xcs = 1;
           break;
       default:
           xcs = 0;
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Get chroma shift values for this format */
       switch (fmt)
       {
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           xcs = 1;
           break;
       default:
           xcs = 0;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (fmt)
       {
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           ycs = 1;
           break;
       default:
           ycs = 0;
           break;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       switch (fmt)
       {
       case VPX_IMG_FMT_I420:
       case VPX_IMG_FMT_YV12:
       case VPX_IMG_FMT_VPXI420:
       case VPX_IMG_FMT_VPXYV12:
           ycs = 1;
           break;
       default:
           ycs = 0;
           break;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate storage sizes given the chroma subsampling */
       align = (1 &lt;&lt; xcs) - 1;
       w = (d_w + align) &amp; ~align;
       align = (1 &lt;&lt; ycs) - 1;
       h = (d_h + align) &amp; ~align;
       s = (fmt &amp; VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
       s = (s + stride_align - 1) &amp; ~(stride_align - 1);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate storage sizes given the chroma subsampling */
       align = (1 &lt;&lt; xcs) - 1;
       w = (d_w + align) &amp; ~align;
       align = (1 &lt;&lt; ycs) - 1;
       h = (d_h + align) &amp; ~align;
       s = (fmt &amp; VPX_IMG_FMT_PLANAR) ? w : bps * w / 8;
       s = (s + stride_align - 1) &amp; ~(stride_align - 1);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Allocate the new image */
       if (!img)
       {
           img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Allocate the new image */
       if (!img)
       {
           img = (vpx_image_t *)calloc(1, sizeof(vpx_image_t));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
if (!img) goto fail;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
如果（！img）转到失败；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           img-&gt;self_allocd = 1;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           img-&gt;self_allocd = 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       else
       {
           memset(img, 0, sizeof(vpx_image_t));
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       else
       {
           memset(img, 0, sizeof(vpx_image_t));
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;img_data = img_data;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;img_data = img_data;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!img_data)
       {
           img-&gt;img_data = malloc((fmt &amp; VPX_IMG_FMT_PLANAR) ?
             h * w * bps / 8 : h * s);
           img-&gt;img_data_owner = 1;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (!img_data)
       {
           img-&gt;img_data = malloc((fmt &amp; VPX_IMG_FMT_PLANAR) ?
             h * w * bps / 8 : h * s);
           img-&gt;img_data_owner = 1;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if (!img-&gt;img_data) goto fail;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果（！img-&gt;img_data）转到失败；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;fmt = fmt;
       img-&gt;w = w;
       img-&gt;h = h;
       img-&gt;x_chroma_shift = xcs;
       img-&gt;y_chroma_shift = ycs;
       img-&gt;bps = bps;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;fmt = fmt;
       img-&gt;w = w;
       img-&gt;h = h;
       img-&gt;x_chroma_shift = xcs;
       img-&gt;y_chroma_shift = ycs;
       img-&gt;bps = bps;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate strides */
       img-&gt;stride[VPX_PLANE_Y] = img-&gt;stride[VPX_PLANE_ALPHA] = s;
       img-&gt;stride[VPX_PLANE_U] = img-&gt;stride[VPX_PLANE_V] = s &gt;&gt; xcs;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Calculate strides */
       img-&gt;stride[VPX_PLANE_Y] = img-&gt;stride[VPX_PLANE_ALPHA] = s;
       img-&gt;stride[VPX_PLANE_U] = img-&gt;stride[VPX_PLANE_V] = s &gt;&gt; xcs;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Default viewport to entire image */
       if (!vpx_img_set_rect(img, 0, 0, d_w, d_h))
           return img;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* Default viewport to entire image */
       if (!vpx_img_set_rect(img, 0, 0, d_w, d_h))
           return img;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   fail:
       vpx_img_free(img);
       return NULL;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   fail:
       vpx_img_free(img);
       return NULL;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_image_t *vpx_img_alloc(vpx_image_t  *img,
                              vpx_img_fmt_t fmt,
                              unsigned int  d_w,
                              unsigned int  d_h,
                              unsigned int  stride_align)
   {
       return img_alloc_helper(img, fmt, d_w, d_h, stride_align, NULL);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_image_t *vpx_img_alloc(vpx_image_t  *img,
                              vpx_img_fmt_t fmt,
                              unsigned int  d_w,
                              unsigned int  d_h,
                              unsigned int  stride_align)
   {
       return img_alloc_helper(img, fmt, d_w, d_h, stride_align, NULL);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_image_t *vpx_img_wrap(vpx_image_t  *img,
                             vpx_img_fmt_t fmt,
                             unsigned int  d_w,
                             unsigned int  d_h,
                             unsigned int  stride_align,
                             unsigned char       *img_data)
   {
       return img_alloc_helper(img, fmt, d_w, d_h, stride_align,
         img_data);
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   vpx_image_t *vpx_img_wrap(vpx_image_t  *img,
                             vpx_img_fmt_t fmt,
                             unsigned int  d_w,
                             unsigned int  d_h,
                             unsigned int  stride_align,
                             unsigned char       *img_data)
   {
       return img_alloc_helper(img, fmt, d_w, d_h, stride_align,
         img_data);
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int vpx_img_set_rect(vpx_image_t  *img,
                        unsigned int  x,
                        unsigned int  y,
                        unsigned int  w,
                        unsigned int  h)
   {
       unsigned char      *data;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   int vpx_img_set_rect(vpx_image_t  *img,
                        unsigned int  x,
                        unsigned int  y,
                        unsigned int  w,
                        unsigned int  h)
   {
       unsigned char      *data;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (x + w &lt;= img-&gt;w &amp;&amp; y + h &lt;= img-&gt;h)
       {
           img-&gt;d_w = w;
           img-&gt;d_h = h;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if (x + w &lt;= img-&gt;w &amp;&amp; y + h &lt;= img-&gt;h)
       {
           img-&gt;d_w = w;
           img-&gt;d_h = h;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Calculate plane pointers */
           if (!(img-&gt;fmt &amp; VPX_IMG_FMT_PLANAR))
           {
               img-&gt;planes[VPX_PLANE_PACKED] =
                   img-&gt;img_data + x * img-&gt;bps / 8 + y *
                     img-&gt;stride[VPX_PLANE_PACKED];
           }
           else
           {
               data = img-&gt;img_data;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Calculate plane pointers */
           if (!(img-&gt;fmt &amp; VPX_IMG_FMT_PLANAR))
           {
               img-&gt;planes[VPX_PLANE_PACKED] =
                   img-&gt;img_data + x * img-&gt;bps / 8 + y *
                     img-&gt;stride[VPX_PLANE_PACKED];
           }
           else
           {
               data = img-&gt;img_data;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (img-&gt;fmt &amp; VPX_IMG_FMT_HAS_ALPHA)
               {
                   img-&gt;planes[VPX_PLANE_ALPHA] =
                       data + x + y * img-&gt;stride[VPX_PLANE_ALPHA];
                   data += img-&gt;h * img-&gt;stride[VPX_PLANE_ALPHA];
               }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (img-&gt;fmt &amp; VPX_IMG_FMT_HAS_ALPHA)
               {
                   img-&gt;planes[VPX_PLANE_ALPHA] =
                       data + x + y * img-&gt;stride[VPX_PLANE_ALPHA];
                   data += img-&gt;h * img-&gt;stride[VPX_PLANE_ALPHA];
               }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               img-&gt;planes[VPX_PLANE_Y] =
                 data + x + y * img-&gt;stride[VPX_PLANE_Y];
               data += img-&gt;h * img-&gt;stride[VPX_PLANE_Y];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               img-&gt;planes[VPX_PLANE_Y] =
                 data + x + y * img-&gt;stride[VPX_PLANE_Y];
               data += img-&gt;h * img-&gt;stride[VPX_PLANE_Y];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (!(img-&gt;fmt &amp; VPX_IMG_FMT_UV_FLIP))
               {
                   img-&gt;planes[VPX_PLANE_U] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
                   data += (img-&gt;h &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
                   img-&gt;planes[VPX_PLANE_V] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
               }
               else
               {
                   img-&gt;planes[VPX_PLANE_V] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
                   data += (img-&gt;h &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
                   img-&gt;planes[VPX_PLANE_U] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
               }
           }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               if (!(img-&gt;fmt &amp; VPX_IMG_FMT_UV_FLIP))
               {
                   img-&gt;planes[VPX_PLANE_U] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
                   data += (img-&gt;h &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
                   img-&gt;planes[VPX_PLANE_V] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
               }
               else
               {
                   img-&gt;planes[VPX_PLANE_V] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
                   data += (img-&gt;h &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_V];
                   img-&gt;planes[VPX_PLANE_U] = data
                                          + (x &gt;&gt; img-&gt;x_chroma_shift)
                                          + (y &gt;&gt; img-&gt;y_chroma_shift) *
                                            img-&gt;stride[VPX_PLANE_U];
               }
           }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return 0;
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           return 0;
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return -1;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       return -1;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vpx_img_flip(vpx_image_t *img)
   {
       /* Note: In the calculation pointer adjustment calculation, we
        * want the rhs to be promoted to a signed type.  Section 6.3.1.8
        * of the ISO C99 standard [ISO-C99] indicates that if the
        * adjustment parameter is unsigned, the stride parameter will be
        * promoted to unsigned, causing errors when the lhs is a larger
        * type than the rhs.
        */
       img-&gt;planes[VPX_PLANE_Y] += (signed)
         (img-&gt;d_h - 1) * img-&gt;stride[VPX_PLANE_Y];
       img-&gt;stride[VPX_PLANE_Y] = -img-&gt;stride[VPX_PLANE_Y];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vpx_img_flip(vpx_image_t *img)
   {
       /* Note: In the calculation pointer adjustment calculation, we
        * want the rhs to be promoted to a signed type.  Section 6.3.1.8
        * of the ISO C99 standard [ISO-C99] indicates that if the
        * adjustment parameter is unsigned, the stride parameter will be
        * promoted to unsigned, causing errors when the lhs is a larger
        * type than the rhs.
        */
       img-&gt;planes[VPX_PLANE_Y] += (signed)
         (img-&gt;d_h - 1) * img-&gt;stride[VPX_PLANE_Y];
       img-&gt;stride[VPX_PLANE_Y] = -img-&gt;stride[VPX_PLANE_Y];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_U] += (signed)
         ((img-&gt;d_h &gt;&gt; img-&gt;y_chroma_shift) - 1)
                               * img-&gt;stride[VPX_PLANE_U];
       img-&gt;stride[VPX_PLANE_U] = -img-&gt;stride[VPX_PLANE_U];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_U] += (signed)
         ((img-&gt;d_h &gt;&gt; img-&gt;y_chroma_shift) - 1)
                               * img-&gt;stride[VPX_PLANE_U];
       img-&gt;stride[VPX_PLANE_U] = -img-&gt;stride[VPX_PLANE_U];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_V] += (signed)
                               ((img-&gt;d_h &gt;&gt; img-&gt;y_chroma_shift) - 1) *
                               img-&gt;stride[VPX_PLANE_V];
       img-&gt;stride[VPX_PLANE_V] = -img-&gt;stride[VPX_PLANE_V];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_V] += (signed)
                               ((img-&gt;d_h &gt;&gt; img-&gt;y_chroma_shift) - 1) *
                               img-&gt;stride[VPX_PLANE_V];
       img-&gt;stride[VPX_PLANE_V] = -img-&gt;stride[VPX_PLANE_V];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_ALPHA] += (signed)
         (img-&gt;d_h - 1) * img-&gt;stride[VPX_PLANE_ALPHA];
       img-&gt;stride[VPX_PLANE_ALPHA] = -img-&gt;stride[VPX_PLANE_ALPHA];
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       img-&gt;planes[VPX_PLANE_ALPHA] += (signed)
         (img-&gt;d_h - 1) * img-&gt;stride[VPX_PLANE_ALPHA];
       img-&gt;stride[VPX_PLANE_ALPHA] = -img-&gt;stride[VPX_PLANE_ALPHA];
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vpx_img_free(vpx_image_t *img)
   {
       if (img)
       {
           if (img-&gt;img_data &amp;&amp; img-&gt;img_data_owner)
               free(img-&gt;img_data);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   void vpx_img_free(vpx_image_t *img)
   {
       if (img)
       {
           if (img-&gt;img_data &amp;&amp; img-&gt;img_data_owner)
               free(img-&gt;img_data);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (img-&gt;self_allocd)
               free(img);
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           if (img-&gt;self_allocd)
               free(img);
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.23. vpx_image.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.23. vpx_image.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    * Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    * Use of this source code is governed by a BSD-style license
    * that can be found in the LICENSE file in the root of the source
    * tree.  An additional intellectual property rights grant can be
    * found in the file PATENTS.  All contributing project authors may
    * be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file
    * \brief Describes the vpx image descriptor and associated
    * operations
    *
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*!\file
    * \brief Describes the vpx image descriptor and associated
    * operations
    *
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #ifdef __cplusplus
   extern &#34;C&#34; {
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_IMAGE_H #define VPX_IMAGE_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_图像#定义VPX_图像#
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Current ABI version number
        *
        * \internal
        * If this file is altered in any way that changes the ABI, this
        * value must be bumped.  Examples include, but are not limited
        * to, changing types, removing or reassigning enums,
        * adding/removing/rearranging fields to structures
        */
   #define VPX_IMAGE_ABI_VERSION (1) /**&lt;\hideinitializer*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Current ABI version number
        *
        * \internal
        * If this file is altered in any way that changes the ABI, this
        * value must be bumped.  Examples include, but are not limited
        * to, changing types, removing or reassigning enums,
        * adding/removing/rearranging fields to structures
        */
   #define VPX_IMAGE_ABI_VERSION (1) /**&lt;\hideinitializer*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define VPX_IMG_FMT_PLANAR     0x100  /**&lt; Image is a planar
                                              format */
   #define VPX_IMG_FMT_UV_FLIP    0x200  /**&lt; V plane precedes U plane
                                              in memory */
   #define VPX_IMG_FMT_HAS_ALPHA  0x400  /**&lt; Image has an alpha channel
                                              component */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #define VPX_IMG_FMT_PLANAR     0x100  /**&lt; Image is a planar
                                              format */
   #define VPX_IMG_FMT_UV_FLIP    0x200  /**&lt; V plane precedes U plane
                                              in memory */
   #define VPX_IMG_FMT_HAS_ALPHA  0x400  /**&lt; Image has an alpha channel
                                              component */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief List of supported image formats */
       typedef enum vpx_img_fmt {
           VPX_IMG_FMT_NONE,
           VPX_IMG_FMT_RGB24,      /**&lt; 24 bit per pixel packed RGB */
           VPX_IMG_FMT_RGB32,      /**&lt; 32 bit per pixel packed 0RGB */
           VPX_IMG_FMT_RGB565,     /**&lt; 16 bit per pixel, 565 */
           VPX_IMGFMT_RGB555,      /**&lt; 16 bit per pixel, 555 */
           VPX_IMG_FMT_UYVY,       /**&lt; UYVY packed YUV */
           VPX_IMG_FMT_YUY2,       /**&lt; YUYV packed YUV */
           VPX_IMG_FMT_YVYU,       /**&lt; YVYU packed YUV */
           VPX_IMG_FMT_BGR24,      /**&lt; 24 bit per pixel packed BGR */
           VPX_IMG_FMT_RGB32_LE,   /**&lt; 32 bit packed BGR0 */
           VPX_IMG_FMT_ARGB,       /**&lt; 32 bit packed ARGB, alpha=255 */
           VPX_IMG_FMT_ARGB_LE,    /**&lt; 32 bit packed BGRA, alpha=255 */
           VPX_IMG_FMT_RGB565_LE,  /**&lt; 16 bit per pixel,
                                        gggbbbbb rrrrrggg */
           VPX_IMG_FMT_RGB555_LE,  /**&lt; 16 bit per pixel,
                                        gggbbbbb 0rrrrrgg */
           VPX_IMG_FMT_YV12    = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 1, /**&lt; planar YVU */
           VPX_IMG_FMT_I420    = VPX_IMG_FMT_PLANAR | 2,
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief List of supported image formats */
       typedef enum vpx_img_fmt {
           VPX_IMG_FMT_NONE,
           VPX_IMG_FMT_RGB24,      /**&lt; 24 bit per pixel packed RGB */
           VPX_IMG_FMT_RGB32,      /**&lt; 32 bit per pixel packed 0RGB */
           VPX_IMG_FMT_RGB565,     /**&lt; 16 bit per pixel, 565 */
           VPX_IMGFMT_RGB555,      /**&lt; 16 bit per pixel, 555 */
           VPX_IMG_FMT_UYVY,       /**&lt; UYVY packed YUV */
           VPX_IMG_FMT_YUY2,       /**&lt; YUYV packed YUV */
           VPX_IMG_FMT_YVYU,       /**&lt; YVYU packed YUV */
           VPX_IMG_FMT_BGR24,      /**&lt; 24 bit per pixel packed BGR */
           VPX_IMG_FMT_RGB32_LE,   /**&lt; 32 bit packed BGR0 */
           VPX_IMG_FMT_ARGB,       /**&lt; 32 bit packed ARGB, alpha=255 */
           VPX_IMG_FMT_ARGB_LE,    /**&lt; 32 bit packed BGRA, alpha=255 */
           VPX_IMG_FMT_RGB565_LE,  /**&lt; 16 bit per pixel,
                                        gggbbbbb rrrrrggg */
           VPX_IMG_FMT_RGB555_LE,  /**&lt; 16 bit per pixel,
                                        gggbbbbb 0rrrrrgg */
           VPX_IMG_FMT_YV12    = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 1, /**&lt; planar YVU */
           VPX_IMG_FMT_I420    = VPX_IMG_FMT_PLANAR | 2,
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           VPX_IMG_FMT_VPXYV12 = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 3, /** &lt; planar 4:2:0 format with
                                            vpx color space */
           VPX_IMG_FMT_VPXI420 = VPX_IMG_FMT_PLANAR | 4   /** &lt; planar
             4:2:0 format with vpx color space */
       }
       vpx_img_fmt_t; /**&lt; alias for enum vpx_img_fmt */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           VPX_IMG_FMT_VPXYV12 = VPX_IMG_FMT_PLANAR |
             VPX_IMG_FMT_UV_FLIP | 3, /** &lt; planar 4:2:0 format with
                                            vpx color space */
           VPX_IMG_FMT_VPXI420 = VPX_IMG_FMT_PLANAR | 4   /** &lt; planar
             4:2:0 format with vpx color space */
       }
       vpx_img_fmt_t; /**&lt; alias for enum vpx_img_fmt */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   /** \deprecated Use #VPX_IMG_FMT_PLANAR */
   #define IMG_FMT_PLANAR         VPX_IMG_FMT_PLANAR
   /** \deprecated Use #VPX_IMG_FMT_UV_FLIP */
   #define IMG_FMT_UV_FLIP        VPX_IMG_FMT_UV_FLIP
   /** \deprecated Use #VPX_IMG_FMT_HAS_ALPHA */
   #define IMG_FMT_HAS_ALPHA      VPX_IMG_FMT_HAS_ALPHA
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   /** \deprecated Use #VPX_IMG_FMT_PLANAR */
   #define IMG_FMT_PLANAR         VPX_IMG_FMT_PLANAR
   /** \deprecated Use #VPX_IMG_FMT_UV_FLIP */
   #define IMG_FMT_UV_FLIP        VPX_IMG_FMT_UV_FLIP
   /** \deprecated Use #VPX_IMG_FMT_HAS_ALPHA */
   #define IMG_FMT_HAS_ALPHA      VPX_IMG_FMT_HAS_ALPHA
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Deprecated list of supported image formats
        * \deprecated New code should use #vpx_img_fmt
        */
   #define img_fmt   vpx_img_fmt
       /*!\brief alias for enum img_fmt.
        * \deprecated New code should use #vpx_img_fmt_t
        */
   #define img_fmt_t vpx_img_fmt_t
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Deprecated list of supported image formats
        * \deprecated New code should use #vpx_img_fmt
        */
   #define img_fmt   vpx_img_fmt
       /*!\brief alias for enum img_fmt.
        * \deprecated New code should use #vpx_img_fmt_t
        */
   #define img_fmt_t vpx_img_fmt_t
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /** \deprecated Use #VPX_IMG_FMT_NONE */
   #define IMG_FMT_NONE       VPX_IMG_FMT_NONE
   /** \deprecated Use #VPX_IMG_FMT_RGB24 */
   #define IMG_FMT_RGB24      VPX_IMG_FMT_RGB24
   /** \deprecated Use #VPX_IMG_FMT_RGB32 */
   #define IMG_FMT_RGB32      VPX_IMG_FMT_RGB32
   /** \deprecated Use #VPX_IMG_FMT_RGB565 */
   #define IMG_FMT_RGB565     VPX_IMG_FMT_RGB565
   /** \deprecated Use #VPX_IMG_FMT_RGB555 */
   #define IMG_FMT_RGB555     VPX_IMG_FMT_RGB555
   /** \deprecated Use #VPX_IMG_FMT_UYVY */
   #define IMG_FMT_UYVY       VPX_IMG_FMT_UYVY
   /** \deprecated Use #VPX_IMG_FMT_YUY2 */
   #define IMG_FMT_YUY2       VPX_IMG_FMT_YUY2
   /** \deprecated Use #VPX_IMG_FMT_YVYU */
   #define IMG_FMT_YVYU       VPX_IMG_FMT_YVYU
   /** \deprecated Use #VPX_IMG_FMT_BGR24 */
   #define IMG_FMT_BGR24      VPX_IMG_FMT_BGR24
   /**&lt; \deprecated Use #VPX_IMG_FMT_RGB32_LE */
   #define IMG_FMT_RGB32_LE   VPX_IMG_FMT_RGB32_LE
   /** \deprecated Use #VPX_IMG_FMT_ARGB */
   #define IMG_FMT_ARGB       VPX_IMG_FMT_ARGB
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /** \deprecated Use #VPX_IMG_FMT_NONE */
   #define IMG_FMT_NONE       VPX_IMG_FMT_NONE
   /** \deprecated Use #VPX_IMG_FMT_RGB24 */
   #define IMG_FMT_RGB24      VPX_IMG_FMT_RGB24
   /** \deprecated Use #VPX_IMG_FMT_RGB32 */
   #define IMG_FMT_RGB32      VPX_IMG_FMT_RGB32
   /** \deprecated Use #VPX_IMG_FMT_RGB565 */
   #define IMG_FMT_RGB565     VPX_IMG_FMT_RGB565
   /** \deprecated Use #VPX_IMG_FMT_RGB555 */
   #define IMG_FMT_RGB555     VPX_IMG_FMT_RGB555
   /** \deprecated Use #VPX_IMG_FMT_UYVY */
   #define IMG_FMT_UYVY       VPX_IMG_FMT_UYVY
   /** \deprecated Use #VPX_IMG_FMT_YUY2 */
   #define IMG_FMT_YUY2       VPX_IMG_FMT_YUY2
   /** \deprecated Use #VPX_IMG_FMT_YVYU */
   #define IMG_FMT_YVYU       VPX_IMG_FMT_YVYU
   /** \deprecated Use #VPX_IMG_FMT_BGR24 */
   #define IMG_FMT_BGR24      VPX_IMG_FMT_BGR24
   /**&lt; \deprecated Use #VPX_IMG_FMT_RGB32_LE */
   #define IMG_FMT_RGB32_LE   VPX_IMG_FMT_RGB32_LE
   /** \deprecated Use #VPX_IMG_FMT_ARGB */
   #define IMG_FMT_ARGB       VPX_IMG_FMT_ARGB
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /** \deprecated Use #VPX_IMG_FMT_ARGB_LE */
   #define IMG_FMT_ARGB_LE    VPX_IMG_FMT_ARGB_LE
   /** \deprecated Use #VPX_IMG_FMT_RGB565_LE */
   #define IMG_FMT_RGB565_LE  VPX_IMG_FMT_RGB565_LE
   /** \deprecated Use #VPX_IMG_FMT_RGB555_LE */
   #define IMG_FMT_RGB555_LE  VPX_IMG_FMT_RGB555_LE
   /** \deprecated Use #VPX_IMG_FMT_YV12 */
   #define IMG_FMT_YV12       VPX_IMG_FMT_YV12
   /** \deprecated Use #VPX_IMG_FMT_I420 */
   #define IMG_FMT_I420       VPX_IMG_FMT_I420
   /** \deprecated Use #VPX_IMG_FMT_VPXYV12 */
   #define IMG_FMT_VPXYV12    VPX_IMG_FMT_VPXYV12
   /** \deprecated Use #VPX_IMG_FMT_VPXI420 */
   #define IMG_FMT_VPXI420    VPX_IMG_FMT_VPXI420
   #endif /* VPX_CODEC_DISABLE_COMPAT */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /** \deprecated Use #VPX_IMG_FMT_ARGB_LE */
   #define IMG_FMT_ARGB_LE    VPX_IMG_FMT_ARGB_LE
   /** \deprecated Use #VPX_IMG_FMT_RGB565_LE */
   #define IMG_FMT_RGB565_LE  VPX_IMG_FMT_RGB565_LE
   /** \deprecated Use #VPX_IMG_FMT_RGB555_LE */
   #define IMG_FMT_RGB555_LE  VPX_IMG_FMT_RGB555_LE
   /** \deprecated Use #VPX_IMG_FMT_YV12 */
   #define IMG_FMT_YV12       VPX_IMG_FMT_YV12
   /** \deprecated Use #VPX_IMG_FMT_I420 */
   #define IMG_FMT_I420       VPX_IMG_FMT_I420
   /** \deprecated Use #VPX_IMG_FMT_VPXYV12 */
   #define IMG_FMT_VPXYV12    VPX_IMG_FMT_VPXYV12
   /** \deprecated Use #VPX_IMG_FMT_VPXI420 */
   #define IMG_FMT_VPXI420    VPX_IMG_FMT_VPXI420
   #endif /* VPX_CODEC_DISABLE_COMPAT */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /**\brief Image Descriptor */
       typedef struct vpx_image
       {
           vpx_img_fmt_t fmt; /**&lt; Image Format */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /**\brief Image Descriptor */
       typedef struct vpx_image
       {
           vpx_img_fmt_t fmt; /**&lt; Image Format */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Image storage dimensions */
           unsigned int  w;   /**&lt; Stored image width */
           unsigned int  h;   /**&lt; Stored image height */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Image storage dimensions */
           unsigned int  w;   /**&lt; Stored image width */
           unsigned int  h;   /**&lt; Stored image height */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Image display dimensions */
           unsigned int  d_w;   /**&lt; Displayed image width */
           unsigned int  d_h;   /**&lt; Displayed image height */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Image display dimensions */
           unsigned int  d_w;   /**&lt; Displayed image width */
           unsigned int  d_h;   /**&lt; Displayed image height */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Chroma subsampling info */
           unsigned int  x_chroma_shift;   /**&lt; subsampling order, X */
           unsigned int  y_chroma_shift;   /**&lt; subsampling order, Y */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Chroma subsampling info */
           unsigned int  x_chroma_shift;   /**&lt; subsampling order, X */
           unsigned int  y_chroma_shift;   /**&lt; subsampling order, Y */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Image data pointers. */
   #define VPX_PLANE_PACKED 0  /**&lt; To be used for all packed formats */
   #define VPX_PLANE_Y      0  /**&lt; Y (Luminance) plane */
   #define VPX_PLANE_U      1  /**&lt; U (Chroma) plane */
   #define VPX_PLANE_V      2  /**&lt; V (Chroma) plane */
   #define VPX_PLANE_ALPHA  3  /**&lt; A (Transparency) plane */
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   #define PLANE_PACKED     VPX_PLANE_PACKED
   #define PLANE_Y          VPX_PLANE_Y
   #define PLANE_U          VPX_PLANE_U
   #define PLANE_V          VPX_PLANE_V
   #define PLANE_ALPHA      VPX_PLANE_ALPHA
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* Image data pointers. */
   #define VPX_PLANE_PACKED 0  /**&lt; To be used for all packed formats */
   #define VPX_PLANE_Y      0  /**&lt; Y (Luminance) plane */
   #define VPX_PLANE_U      1  /**&lt; U (Chroma) plane */
   #define VPX_PLANE_V      2  /**&lt; V (Chroma) plane */
   #define VPX_PLANE_ALPHA  3  /**&lt; A (Transparency) plane */
   #if !defined(VPX_CODEC_DISABLE_COMPAT) || !VPX_CODEC_DISABLE_COMPAT
   #define PLANE_PACKED     VPX_PLANE_PACKED
   #define PLANE_Y          VPX_PLANE_Y
   #define PLANE_U          VPX_PLANE_U
   #define PLANE_V          VPX_PLANE_V
   #define PLANE_ALPHA      VPX_PLANE_ALPHA
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           unsigned char *planes[4];  /**&lt; pointer to the top-left pixel
           q                               for each plane */
           int    stride[4];  /**&lt; stride between rows for each plane */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           unsigned char *planes[4];  /**&lt; pointer to the top-left pixel
           q                               for each plane */
           int    stride[4];  /**&lt; stride between rows for each plane */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           int    bps; /**&lt; bits per sample (for packed formats) */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           int    bps; /**&lt; bits per sample (for packed formats) */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* The following member may be set by the application to
            * associate data with this image.
            */
           void   *user_priv; /**&lt; may be set by the application to
                                    associate data with this image. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* The following member may be set by the application to
            * associate data with this image.
            */
           void   *user_priv; /**&lt; may be set by the application to
                                    associate data with this image. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* The following members should be treated as private. */
           unsigned char *img_data;       /**&lt; private */
           int      img_data_owner; /**&lt; private */
           int      self_allocd;    /**&lt; private */
       } vpx_image_t; /**&lt; alias for struct vpx_image */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           /* The following members should be treated as private. */
           unsigned char *img_data;       /**&lt; private */
           int      img_data_owner; /**&lt; private */
           int      self_allocd;    /**&lt; private */
       } vpx_image_t; /**&lt; alias for struct vpx_image */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /**\brief Representation of a rectangle on a surface */
       typedef struct vpx_image_rect
       {
           unsigned int x; /**&lt; leftmost column */
           unsigned int y; /**&lt; topmost row */
           unsigned int w; /**&lt; width */
           unsigned int h; /**&lt; height */
       } vpx_image_rect_t; /**&lt; alias for struct vpx_image_rect */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /**\brief Representation of a rectangle on a surface */
       typedef struct vpx_image_rect
       {
           unsigned int x; /**&lt; leftmost column */
           unsigned int y; /**&lt; topmost row */
           unsigned int w; /**&lt; width */
           unsigned int h; /**&lt; height */
       } vpx_image_rect_t; /**&lt; alias for struct vpx_image_rect */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Open a descriptor, allocating storage for the
        * underlying image
        *
        * Returns a descriptor for storing an image of the given format.
        * The storage for the descriptor is allocated on the heap.
        *
        * \param[in]    img       Pointer to storage for descriptor.
        *                         If this parameter is NULL, the storage
        *                         for the descriptor will be allocated
        *                         on the heap.
        * \param[in]    fmt       Format for the image
        * \param[in]    d_w       Width of the image
        * \param[in]    d_h       Height of the image
        * \param[in]    align     Alignment, in bytes, of each row in
        *                         the image.
        *
        * \return Returns a pointer to the initialized image descriptor.
        *         If the img parameter is non-null, the value of the img
        *         parameter will be returned.
        */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Open a descriptor, allocating storage for the
        * underlying image
        *
        * Returns a descriptor for storing an image of the given format.
        * The storage for the descriptor is allocated on the heap.
        *
        * \param[in]    img       Pointer to storage for descriptor.
        *                         If this parameter is NULL, the storage
        *                         for the descriptor will be allocated
        *                         on the heap.
        * \param[in]    fmt       Format for the image
        * \param[in]    d_w       Width of the image
        * \param[in]    d_h       Height of the image
        * \param[in]    align     Alignment, in bytes, of each row in
        *                         the image.
        *
        * \return Returns a pointer to the initialized image descriptor.
        *         If the img parameter is non-null, the value of the img
        *         parameter will be returned.
        */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_image_t *vpx_img_alloc(vpx_image_t *img, vpx_img_fmt_t fmt, unsigned int d_w, unsigned int d_h, unsigned int align);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
vpx_image_t*vpx_img_alloc（vpx_image_t*img，vpx_img_fmt_t fmt，无符号整数d_w，无符号整数d_h，无符号整数对齐）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Open a descriptor, using existing storage for the
        * underlying image
        *
        * Returns a descriptor for storing an image of the given format.
        * The storage for descriptor has been allocated elsewhere, and a
        * descriptor is desired to &#34;wrap&#34; that storage.
        *
        * \param[in]    img       Pointer to storage for descriptor.
        *                         If this parameter is NULL, the storage
        *                         for the descriptor will be
        *                         allocated on the heap.
        * \param[in]    fmt       Format for the image
        * \param[in]    d_w       Width of the image
        * \param[in]    d_h       Height of the image
        * \param[in]    align     Alignment, in bytes, of each row in
        *                         the image.
        * \param[in]    img_data  Storage to use for the image
        *
        * \return Returns a pointer to the initialized image descriptor.
        *         If the img parameter is non-null, the value of the img
        *         parameter will be returned.
        */
       vpx_image_t *vpx_img_wrap(vpx_image_t  *img,
                                 vpx_img_fmt_t fmt,
                                 unsigned int d_w,
                                 unsigned int d_h,
                                 unsigned int align,
                                 unsigned char      *img_data);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Open a descriptor, using existing storage for the
        * underlying image
        *
        * Returns a descriptor for storing an image of the given format.
        * The storage for descriptor has been allocated elsewhere, and a
        * descriptor is desired to &#34;wrap&#34; that storage.
        *
        * \param[in]    img       Pointer to storage for descriptor.
        *                         If this parameter is NULL, the storage
        *                         for the descriptor will be
        *                         allocated on the heap.
        * \param[in]    fmt       Format for the image
        * \param[in]    d_w       Width of the image
        * \param[in]    d_h       Height of the image
        * \param[in]    align     Alignment, in bytes, of each row in
        *                         the image.
        * \param[in]    img_data  Storage to use for the image
        *
        * \return Returns a pointer to the initialized image descriptor.
        *         If the img parameter is non-null, the value of the img
        *         parameter will be returned.
        */
       vpx_image_t *vpx_img_wrap(vpx_image_t  *img,
                                 vpx_img_fmt_t fmt,
                                 unsigned int d_w,
                                 unsigned int d_h,
                                 unsigned int align,
                                 unsigned char      *img_data);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Set the rectangle identifying the displayed portion of
        * the image
        *
        * Updates the displayed rectangle (aka viewport) on the image
        * surface to match the specified coordinates and size.
        *
        * \param[in]    img       Image descriptor
        * \param[in]    x         leftmost column
        * \param[in]    y         topmost row
        * \param[in]    w         width
        * \param[in]    h         height
        *
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Set the rectangle identifying the displayed portion of
        * the image
        *
        * Updates the displayed rectangle (aka viewport) on the image
        * surface to match the specified coordinates and size.
        *
        * \param[in]    img       Image descriptor
        * \param[in]    x         leftmost column
        * \param[in]    y         topmost row
        * \param[in]    w         width
        * \param[in]    h         height
        *
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 * \return 0 if the requested rectangle is valid, non-zero * otherwise. */ int vpx_img_set_rect(vpx_image_t *img, unsigned int x, unsigned int y, unsigned int w, unsigned int h);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
*\如果请求的矩形有效，则返回0，否则返回非零。*/int vpx_img_set_rect（vpx_image_t*img，无符号int x，无符号int y，无符号int w，无符号int h）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Flip the image vertically (top for bottom)
        *
        * Adjusts the image descriptor&#39;s pointers and strides to make
        * the image be referenced upside-down.
        *
        * \param[in]    img       Image descriptor
        */
       void vpx_img_flip(vpx_image_t *img);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Flip the image vertically (top for bottom)
        *
        * Adjusts the image descriptor&#39;s pointers and strides to make
        * the image be referenced upside-down.
        *
        * \param[in]    img       Image descriptor
        */
       void vpx_img_flip(vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Close an image descriptor
        *
        * Frees all allocated storage associated with an image
        * descriptor.
        *
        * \param[in]    img       Image descriptor
        */
       void vpx_img_free(vpx_image_t *img);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /*!\brief Close an image descriptor
        *
        * Frees all allocated storage associated with an image
        * descriptor.
        *
        * \param[in]    img       Image descriptor
        */
       void vpx_img_free(vpx_image_t *img);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #endif
   #ifdef __cplusplus
   }
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #endif
   #ifdef __cplusplus
   }
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.24. vpx_integer.h
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.24. vpx_整数.h
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- Begin code block --------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /*
    *  Copyright (c) 2010, 2011, Google Inc.  All rights reserved.
    *
    *  Use of this source code is governed by a BSD-style license
    *  that can be found in the LICENSE file in the root of the source
    *  tree.  An additional intellectual property rights grant can be
    *  found in the file PATENTS.  All contributing project authors may
    *  be found in the AUTHORS file in the root of the source tree.
    */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef VPX_INTEGER_H #define VPX_INTEGER_H
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#如果ndef VPX_INTEGER#H#定义VPX_INTEGER#H
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* get ptrdiff_t, size_t, wchar_t, NULL */
   #include &lt;stddef.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* get ptrdiff_t, size_t, wchar_t, NULL */
   #include &lt;stddef.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(_MSC_VER) || defined(VPX_EMULATE_INTTYPES)
   typedef signed char  int8_t;
   typedef signed short int16_t;
   typedef signed int   int32_t;
   typedef unsigned char  uint8_t;
   typedef unsigned short uint16_t;
   typedef unsigned int   uint32_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(_MSC_VER) || defined(VPX_EMULATE_INTTYPES)
   typedef signed char  int8_t;
   typedef signed short int16_t;
   typedef signed int   int32_t;
   typedef unsigned char  uint8_t;
   typedef unsigned short uint16_t;
   typedef unsigned int   uint32_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(_MSC_VER)
   typedef signed __int64   int64_t;
   typedef unsigned __int64 uint64_t;
   #define PRId64 &#34;I64d&#34;
   #endif
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(_MSC_VER)
   typedef signed __int64   int64_t;
   typedef unsigned __int64 uint64_t;
   #define PRId64 &#34;I64d&#34;
   #endif
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #ifdef HAVE_ARMV6
   typedef unsigned int int_fast16_t;
   #else
   typedef signed short int_fast16_t;
   #endif
   typedef signed char int_fast8_t;
   typedef unsigned char uint_fast8_t;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #ifdef HAVE_ARMV6
   typedef unsigned int int_fast16_t;
   #else
   typedef signed short int_fast16_t;
   #endif
   typedef signed char int_fast8_t;
   typedef unsigned char uint_fast8_t;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#ifndef _UINTPTR_T_DEFINED typedef unsigned int uintptr_t; #endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#如果定义的类型定义为无符号整数UINTPTR#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#else
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#否则
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Most platforms have the C99 standard integer types. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* Most platforms have the C99 standard integer types. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(__cplusplus) &amp;&amp; !defined(__STDC_FORMAT_MACROS)
   #define __STDC_FORMAT_MACROS
   #endif
   #include &lt;stdint.h&gt;
   #include &lt;inttypes.h&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   #if defined(__cplusplus) &amp;&amp; !defined(__STDC_FORMAT_MACROS)
   #define __STDC_FORMAT_MACROS
   #endif
   #include &lt;stdint.h&gt;
   #include &lt;inttypes.h&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#endif
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
#恩迪夫
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ---- End code block ----------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.25. AUTHORS File
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.25. 作者档案
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Aaron Watry &lt;awatry@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Aaron Watry &lt;awatry@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Adrian Grange &lt;agrange@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Adrian Grange &lt;agrange@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Alex Converse &lt;alex.converse@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Alex Converse &lt;alex.converse@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Andoni Morales Alastruey &lt;ylatuya@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Andoni Morales Alastruey &lt;ylatuya@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Andres Mejia &lt;mcitadel@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Andres Mejia &lt;mcitadel@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Attila Nagy &lt;attilanagy@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Attila Nagy &lt;attilanagy@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Fabio Pedretti &lt;fabio.ped@libero.it&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Fabio Pedretti &lt;fabio.ped@libero.it&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Frank Galligan &lt;fgalligan@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Frank Galligan &lt;fgalligan@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Fredrik Soederquist &lt;fs@opera.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Fredrik Soederquist &lt;fs@opera.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Fritz Koenig &lt;frkoenig@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Fritz Koenig &lt;frkoenig@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Gaute Strokkenes &lt;gaute.strokkenes@broadcom.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Gaute Strokkenes &lt;gaute.strokkenes@broadcom.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Giuseppe Scrivano &lt;gscrivano@gnu.org&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Giuseppe Scrivano &lt;gscrivano@gnu.org&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Guillermo Ballester Valor &lt;gbvalor@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Guillermo Ballester Valor &lt;gbvalor@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Henrik Lundin &lt;hlundin@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Henrik Lundin &lt;hlundin@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   James Berry &lt;jamesberry@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   James Berry &lt;jamesberry@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   James Zern &lt;jzern@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   James Zern &lt;jzern@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Jan Kratochvil &lt;jan.kratochvil@redhat.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Jan Kratochvil &lt;jan.kratochvil@redhat.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Jeff Muizelaar &lt;jmuizelaar@mozilla.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Jeff Muizelaar &lt;jmuizelaar@mozilla.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Jim Bankoski &lt;jimbankoski@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Jim Bankoski &lt;jimbankoski@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Johann Koenig &lt;johannkoenig@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Johann Koenig &lt;johannkoenig@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   John Koleszar &lt;jkoleszar@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   John Koleszar &lt;jkoleszar@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Justin Clift &lt;justin@salasaga.org&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Justin Clift &lt;justin@salasaga.org&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Justin Lebar &lt;justin.lebar@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Justin Lebar &lt;justin.lebar@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Luca Barbato &lt;lu_zero@gentoo.org&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Luca Barbato &lt;lu_zero@gentoo.org&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Makoto Kato &lt;makoto.kt@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Makoto Kato &lt;makoto.kt@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Martin Ettl &lt;ettl.martin78@googlemail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Martin Ettl &lt;ettl.martin78@googlemail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Michael Kohler &lt;michaelkohler@live.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Michael Kohler &lt;michaelkohler@live.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Mikhal Shemer &lt;mikhal@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Mikhal Shemer &lt;mikhal@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pascal Massimino &lt;pascal.massimino@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pascal Massimino &lt;pascal.massimino@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Patrik Westin &lt;patrik.westin@gmail.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Patrik Westin &lt;patrik.westin@gmail.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Paul Wilkins &lt;paulwilkins@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Paul Wilkins &lt;paulwilkins@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pavol Rusnak &lt;stick@gk2.sk&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pavol Rusnak &lt;stick@gk2.sk&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Philip Jaegenstedt &lt;philipj@opera.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Philip Jaegenstedt &lt;philipj@opera.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Scott LaVarnway &lt;slavarnway@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Scott LaVarnway &lt;slavarnway@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Tero Rintaluoma &lt;teror@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Tero Rintaluoma &lt;teror@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timothy B. Terriberry &lt;tterribe@xiph.org&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timothy B. Terriberry &lt;tterribe@xiph.org&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Tom Finegan &lt;tomfinegan@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Tom Finegan &lt;tomfinegan@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Yaowu Xu &lt;yaowu@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Yaowu Xu &lt;yaowu@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Yunqing Wang &lt;yunqingwang@google.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Yunqing Wang &lt;yunqingwang@google.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
谷歌公司。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Mozilla Foundation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mozilla基金会
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Xiph.Org Foundation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XIPH.org基金会
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.26. LICENSE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.26. 许可证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2010, 2011, Google Inc. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（c）201012011，谷歌公司保留所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在满足以下条件的情况下，允许以源代码和二进制格式重新分发和使用，无论是否修改：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 源代码的重新分发必须保留上述版权声明、此条件列表和以下免责声明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以二进制形式重新分发时，必须在分发时提供的文档和/或其他材料中复制上述版权声明、本条件列表和以下免责声明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Neither the name of Google nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 未经事先书面许可，谷歌及其贡献者的姓名不得用于支持或推广源自本软件的产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#34;AS IS&#34; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本软件由版权所有者和贡献者“按原样”提供，不承担任何明示或暗示的担保，包括但不限于对适销性和特定用途适用性的暗示担保。在任何情况下，版权持有人或贡献者均不对任何直接、间接、偶然、特殊、惩戒性或后果性损害（包括但不限于替代商品或服务的采购；使用、数据或利润的损失；或业务中断）负责，无论是在合同中还是在任何责任理论下，严格责任，或因使用本软件而产生的侵权行为（包括疏忽或其他），即使告知可能发生此类损害。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.27. PATENTS
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20.27. 专利权
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional IP Rights Grant (Patents)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
额外知识产权授予（专利）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;This implementation&#34; means the copyrightable works distributed by Google as part of the WebM Project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“本实施”是指谷歌作为WebM项目的一部分发布的受版权保护的作品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Google hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, transfer, and otherwise run, modify and propagate the contents of this implementation of VP8, where such license applies only to those patent claims, both currently owned by Google and acquired in the future, licensable by Google that are necessarily infringed by this implementation of VP8. This grant does not include claims that would be infringed only as a consequence of further modification of this implementation. If you or your agent or exclusive licensee institute or order or agree to the institution of patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that this implementation of VP8 or any code incorporated within this implementation of VP8 constitutes direct or contributory patent infringement, or inducement of patent infringement, then any patent rights granted to you under this License for this implementation of VP8 shall terminate as of the date such litigation is filed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
谷歌特此授予您永久的、全球范围的、非排他性的、免费的、免版税的、不可撤销的（本节规定的除外）专利许可，以制作、制作、使用、提供销售、销售、进口、转让以及以其他方式运行、修改和传播VP8实施的内容，如果此类许可仅适用于谷歌目前拥有的和未来获得的、可由谷歌许可的、因VP8实施而必然受到侵犯的专利权利要求。本授权不包括仅因进一步修改本实施而被侵犯的索赔。如果您或您的代理人或独家被许可人针对任何实体提起专利诉讼（包括诉讼中的交叉索赔或反诉），声称VP8的实施或VP8实施中包含的任何代码构成直接或共同的专利侵权，或专利侵权的诱因，则根据本许可证授予您的、用于实施VP8的任何专利权应自提起诉讼之日起终止。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A VP8 decoder should take appropriate security considerations into account, as outlined in [RFC4732] and [RFC3552]. It is extremely important that a decoder be robust against malicious payloads. Malicious payloads must not cause the decoder to overrun its allocated memory or to consume inordinate resources. Although encoder issues are typically rarer, the same applies to an encoder. Malicious stream data must not cause the encoder to misbehave, as this might allow an attacker access to transcoding gateways.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VP8解码器应考虑适当的安全因素，如[RFC4732]和[RFC3552]所述。解码器对恶意有效负载具有鲁棒性是非常重要的。恶意有效负载不得导致解码器超出其分配的内存或消耗过多的资源。虽然编码器问题通常比较少见，但同样的情况也适用于编码器。恶意流数据不得导致编码器行为不当，因为这可能允许攻击者访问转码网关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. Normative Reference
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bell] Bell, T., Cleary, J., and I. Witten, &#34;Text Compression&#34;, 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bell]Bell，T.，Cleary，J.，和I.Witten，“文本压缩”，1990年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISO-C99] International Organization for Standardization, &#34;Information technology -- Programming languages -- C&#34;, ISO/IEC 9899:1999, 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ISO-C99]国际标准化组织，“信息技术——编程语言——C”，ISO/IEC 9899:1999，1999。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ITU-R_BT.601] International Telecommunication Union, &#34;ITU BT.601-7: Studio encoding parameters of digital television for standard 4:3 and wide screen 16:9 aspect ratios&#34;, March 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ITU-R_BT.601]国际电信联盟，“ITU BT.601-7：标准4:3和宽屏幕16:9纵横比数字电视的演播室编码参数”，2011年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kernighan] Kernighan, B. and D. Ritchie, &#34;The C Programming Language (2nd edition)&#34;, April 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Kernighan]Kernighan，B.和D.Ritchie，“C编程语言（第二版）”，1988年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Loeffler] Loeffler, C., Ligtenberg , A., and G. Moschytz, &#34;Practical Fast 1-D DCT Algorithms with 11 Multiplications&#34;, May 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Loeffler]Loeffler，C.，Ligtenberg，A.，和G.Moschytz，“具有11次乘法的实用快速1-D DCT算法”，1989年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3552] Rescorla, E. and B. Korver, &#34;Guidelines for Writing RFC Text on Security Considerations&#34;, BCP 72, RFC 3552, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3552]Rescorla，E.和B.Korver，“关于安全考虑的RFC文本编写指南”，BCP 72，RFC 3552，2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4732] Handley, M., Ed., Rescorla, E., Ed., and IAB, &#34;Internet Denial-of-Service Considerations&#34;, RFC 4732, December 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4732]Handley，M.，Ed.，Rescorla，E.，Ed.，和IAB，“互联网拒绝服务注意事项”，RFC 47322006年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shannon] Shannon, C., &#34;A Mathematical Theory of Communication&#34;, Bell System Technical Journal Vol. 27, pp. 379-423 and 623-656, July and October 1948.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shannon]Shannon，C.，“通信的数学理论”，《贝尔系统技术期刊》第27卷，379-423和623-656页，1948年7月和10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
James Bankoski Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
詹姆斯·班科斯基谷歌公司。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jimbankoski@google.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jimbankoski@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
John Koleszar Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
约翰·科莱萨谷歌公司。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jkoleszar@google.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jkoleszar@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lou Quillio Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
卢·奎利奥谷歌公司。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: louquillio@google.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: louquillio@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Janne Salonen Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Janne Salonen谷歌公司。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jsalonen@google.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jsalonen@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Paul Wilkins Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保罗·威尔金斯谷歌公司。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: paulwilkins@google.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: paulwilkins@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Yaowu Xu Google Inc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
耀武旭谷歌有限公司。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: yaowu@google.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: yaowu@google.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
