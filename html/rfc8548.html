<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 8548: Cryptographic Protection of TCP Streams (tcpcrypt)中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC8548 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
         
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8548</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc8548">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 8548: Cryptographic Protection of TCP Streams (tcpcrypt) 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc8548">
              https://datatracker.ietf.org/doc/html/rfc8548
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 8548</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         A. Bittau
Request for Comments: 8548                                        Google
Category: Experimental                                         D. Giffin
ISSN: 2070-1721                                      Stanford University
                                                              M. Handley
                                               University College London
                                                             D. Mazieres
                                                     Stanford University
                                                                Q. Slack
                                                             Sourcegraph
                                                                E. Smith
                                                       Kestrel Institute
                                                                May 2019
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         A. Bittau
Request for Comments: 8548                                        Google
Category: Experimental                                         D. Giffin
ISSN: 2070-1721                                      Stanford University
                                                              M. Handley
                                               University College London
                                                             D. Mazieres
                                                     Stanford University
                                                                Q. Slack
                                                             Sourcegraph
                                                                E. Smith
                                                       Kestrel Institute
                                                                May 2019
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Cryptographic Protection of TCP Streams (tcpcrypt)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
TCP流的加密保护（tcpcrypt）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies &#34;tcpcrypt&#34;, a TCP encryption protocol designed for use in conjunction with the TCP Encryption Negotiation Option (TCP-ENO). Tcpcrypt coexists with middleboxes by tolerating resegmentation, NATs, and other manipulations of the TCP header. The protocol is self-contained and specifically tailored to TCP implementations, which often reside in kernels or other environments in which large external software dependencies can be undesirable. Because the size of TCP options is limited, the protocol requires one additional one-way message latency to perform key exchange before application data can be transmitted. However, the extra latency can be avoided between two hosts that have recently established a previous tcpcrypt connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档指定了“tcpcrypt”，这是一种TCP加密协议，设计用于与TCP加密协商选项（TCP-ENO）结合使用。Tcpcrypt通过允许重新分段、NAT和TCP报头的其他操作与中间盒共存。该协议是自包含的，专门针对TCP实现而定制，TCP实现通常驻留在内核或其他环境中，在这些环境中，可能不需要大型外部软件依赖关系。由于TCP选项的大小有限，协议需要额外的单向消息延迟来执行密钥交换，然后才能传输应用程序数据。但是，在最近建立了先前tcpcrypt连接的两台主机之间可以避免额外的延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件不是互联网标准跟踪规范；它是为检查、实验实施和评估而发布的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档为互联网社区定义了一个实验协议。本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。并非IESG批准的所有文件都适用于任何级别的互联网标准；见RFC 7841第2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc8548.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问https://www.rfc-editor.org/info/rfc8548.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2019 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权（c）2019 IETF信托基金和被确定为文件作者的人员。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(https://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
   2.  Requirements Language . . . . . . . . . . . . . . . . . . . .   4
   3.  Encryption Protocol . . . . . . . . . . . . . . . . . . . . .   4
     3.1.  Cryptographic Algorithms  . . . . . . . . . . . . . . . .   4
     3.2.  Protocol Negotiation  . . . . . . . . . . . . . . . . . .   6
     3.3.  Key Exchange  . . . . . . . . . . . . . . . . . . . . . .   7
     3.4.  Session ID  . . . . . . . . . . . . . . . . . . . . . . .  10
     3.5.  Session Resumption  . . . . . . . . . . . . . . . . . . .  10
     3.6.  Data Encryption and Authentication  . . . . . . . . . . .  14
     3.7.  TCP Header Protection . . . . . . . . . . . . . . . . . .  16
     3.8.  Rekeying  . . . . . . . . . . . . . . . . . . . . . . . .  16
     3.9.  Keep-Alive  . . . . . . . . . . . . . . . . . . . . . . .  17
   4.  Encodings . . . . . . . . . . . . . . . . . . . . . . . . . .  18
     4.1.  Key-Exchange Messages . . . . . . . . . . . . . . . . . .  18
     4.2.  Encryption Frames . . . . . . . . . . . . . . . . . . . .  20
       4.2.1.  Plaintext . . . . . . . . . . . . . . . . . . . . . .  20
       4.2.2.  Associated Data . . . . . . . . . . . . . . . . . . .  21
       4.2.3.  Frame ID  . . . . . . . . . . . . . . . . . . . . . .  21
     4.3.  Constant Values . . . . . . . . . . . . . . . . . . . . .  22
   5.  Key-Agreement Schemes . . . . . . . . . . . . . . . . . . . .  22
   6.  AEAD Algorithms . . . . . . . . . . . . . . . . . . . . . . .  24
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  24
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  25
     8.1.  Asymmetric Roles  . . . . . . . . . . . . . . . . . . . .  27
     8.2.  Verified Liveness . . . . . . . . . . . . . . . . . . . .  27
     8.3.  Mandatory Key-Agreement Schemes . . . . . . . . . . . . .  27
   9.  Experiments . . . . . . . . . . . . . . . . . . . . . . . . .  28
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  29
     10.2.  Informative References . . . . . . . . . . . . . . . . .  30
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  31
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4
   2.  Requirements Language . . . . . . . . . . . . . . . . . . . .   4
   3.  Encryption Protocol . . . . . . . . . . . . . . . . . . . . .   4
     3.1.  Cryptographic Algorithms  . . . . . . . . . . . . . . . .   4
     3.2.  Protocol Negotiation  . . . . . . . . . . . . . . . . . .   6
     3.3.  Key Exchange  . . . . . . . . . . . . . . . . . . . . . .   7
     3.4.  Session ID  . . . . . . . . . . . . . . . . . . . . . . .  10
     3.5.  Session Resumption  . . . . . . . . . . . . . . . . . . .  10
     3.6.  Data Encryption and Authentication  . . . . . . . . . . .  14
     3.7.  TCP Header Protection . . . . . . . . . . . . . . . . . .  16
     3.8.  Rekeying  . . . . . . . . . . . . . . . . . . . . . . . .  16
     3.9.  Keep-Alive  . . . . . . . . . . . . . . . . . . . . . . .  17
   4.  Encodings . . . . . . . . . . . . . . . . . . . . . . . . . .  18
     4.1.  Key-Exchange Messages . . . . . . . . . . . . . . . . . .  18
     4.2.  Encryption Frames . . . . . . . . . . . . . . . . . . . .  20
       4.2.1.  Plaintext . . . . . . . . . . . . . . . . . . . . . .  20
       4.2.2.  Associated Data . . . . . . . . . . . . . . . . . . .  21
       4.2.3.  Frame ID  . . . . . . . . . . . . . . . . . . . . . .  21
     4.3.  Constant Values . . . . . . . . . . . . . . . . . . . . .  22
   5.  Key-Agreement Schemes . . . . . . . . . . . . . . . . . . . .  22
   6.  AEAD Algorithms . . . . . . . . . . . . . . . . . . . . . . .  24
   7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  24
   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  25
     8.1.  Asymmetric Roles  . . . . . . . . . . . . . . . . . . . .  27
     8.2.  Verified Liveness . . . . . . . . . . . . . . . . . . . .  27
     8.3.  Mandatory Key-Agreement Schemes . . . . . . . . . . . . .  27
   9.  Experiments . . . . . . . . . . . . . . . . . . . . . . . . .  28
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  29
     10.2.  Informative References . . . . . . . . . . . . . . . . .  30
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Authors&#39; Addresses  . . . . . . . . . . . . . . . . . . . . . . .  31
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes tcpcrypt, an extension to TCP for cryptographic protection of session data. Tcpcrypt was designed to meet the following goals:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档描述了tcpcrypt，它是TCP的一个扩展，用于会话数据的加密保护。Tcpcrypt旨在实现以下目标：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Meet the requirements of the TCP Encryption Negotiation Option (TCP-ENO) [RFC8547] for protecting connection data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 满足TCP加密协商选项（TCP-ENO）[RFC8547]保护连接数据的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Be amenable to small, self-contained implementations inside TCP stacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 易于在TCP堆栈中实现小型的、自包含的实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Minimize additional latency at connection startup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 最小化连接启动时的额外延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As much as possible, prevent connection failure in the presence of NATs and other middleboxes that might normalize traffic or otherwise manipulate TCP segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 尽可能防止NAT和其他可能使流量正常化或操纵TCP段的中间盒出现连接故障。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Operate independently of IP addresses, making it possible to authenticate resumed sessions efficiently even when either end changes IP address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 独立于IP地址进行操作，使得即使任意一端更改IP地址，也可以有效地对恢复的会话进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A companion document [TCPINC-API] describes recommended interfaces for configuring certain parameters of this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配套文件[TCPINC-API]描述了配置该协议某些参数的推荐接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 需求语言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”在所有大写字母出现时（如图所示）应按照BCP 14[RFC2119][RFC8174]所述进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Encryption Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 加密协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the operation of the tcpcrypt protocol. The wire format of all messages is specified in Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍tcpcrypt协议的操作。第4节规定了所有消息的有线格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Cryptographic Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 密码算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Setting up a tcpcrypt connection employs three types of cryptographic algorithms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
设置tcpcrypt连接使用三种类型的加密算法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A key agreement scheme is used with a short-lived public key to agree upon a shared secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 密钥协商方案与短期公钥一起使用，以协商共享密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An extract function is used to generate a pseudo-random key (PRK) from some initial keying material produced by the key agreement scheme. The notation Extract(S, IKM) denotes the output of the extract function with salt S and initial keying material IKM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 提取函数用于从密钥协商方案产生的一些初始密钥材料生成伪随机密钥（PRK）。符号Extract（S，IKM）表示带有salt S和初始键控材料IKM的Extract函数的输出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A collision-resistant pseudo-random function (CPRF) is used to generate multiple cryptographic keys from a pseudo-random key, typically the output of the extract function. The CPRF produces an arbitrary amount of Output Keying Material (OKM), and we use the notation CPRF(K, CONST, L) to designate the first L bytes of the OKM produced by the CPRF when parameterized by key K and the constant CONST.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 抗冲突伪随机函数（CPRF）用于从伪随机密钥（通常是提取函数的输出）生成多个加密密钥。CPRF生成任意数量的输出键控材料（OKM），我们使用符号CPRF（K，CONST，L）指定CPRF生成的OKM的前L个字节（当由键K和常量CONST参数化时）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Extract and CPRF functions used by the tcpcrypt variants defined in this document are the Extract and Expand functions of the HMAC-based Key Derivation Function (HKDF) [RFC5869], which is built on Keyed-Hashing for Message Authentication (HMAC) [RFC2104]. These are defined as follows in terms of the function HMAC-Hash(key, value) for a negotiated Hash function such as SHA-256; the symbol &#34;|&#34; denotes concatenation, and the counter concatenated to the right of CONST occupies a single octet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档中定义的tcpcrypt变体使用的提取和CPRF函数是基于HMAC的密钥派生函数（HKDF）[RFC5869]的提取和扩展函数，该函数基于消息身份验证（HMAC）[RFC2104]的密钥散列。根据协商散列函数（如SHA-256）的函数HMAC散列（键、值），这些函数定义如下；符号“|”表示连接，连接到常量右侧的计数器占用一个八位字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           HKDF-Extract(salt, IKM) -&gt; PRK
              PRK = HMAC-Hash(salt, IKM)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           HKDF-Extract(salt, IKM) -&gt; PRK
              PRK = HMAC-Hash(salt, IKM)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
HKDF-Expand(PRK, CONST, L) -&gt; OKM T(0) = empty string (zero length) T(1) = HMAC-Hash(PRK, T(0) | CONST | 0x01) T(2) = HMAC-Hash(PRK, T(1) | CONST | 0x02) T(3) = HMAC-Hash(PRK, T(2) | CONST | 0x03) ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
HKDF Expand（PRK，CONST，L）-&gt;okmt（0）=空字符串（零长度）T（1）=HMAC散列（PRK，T（0）| CONST | 0x01）T（2）=HMAC散列（PRK，T（1）| CONST | 0x02）T（3）=HMAC散列（PRK，T（2）| CONST | 0x03）。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              OKM  = first L octets of T(1) | T(2) | T(3) | ...
              where L &lt;= 255*OutputLength(Hash)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              OKM  = first L octets of T(1) | T(2) | T(3) | ...
              where L &lt;= 255*OutputLength(Hash)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Figure 1: HKDF Functions Used for Key Derivation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
图1：用于密钥派生的HKDF函数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, once tcpcrypt has been successfully set up and encryption keys have been derived, an algorithm for Authenticated Encryption with Associated Data (AEAD) is used to protect the confidentiality and integrity of all transmitted application data. AEAD algorithms use a single key to encrypt their input data and also to generate a cryptographic tag to accompany the resulting ciphertext; when decryption is performed, the tag allows authentication of the encrypted data and of optional associated plaintext data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，一旦成功设置tcpcrypt并导出加密密钥，将使用关联数据认证加密算法（AEAD）来保护所有传输的应用程序数据的机密性和完整性。AEAD算法使用单个密钥对其输入数据进行加密，并生成一个加密标签以伴随产生的密文；当执行解密时，标签允许对加密数据和可选的关联明文数据进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Protocol Negotiation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 协议谈判
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt depends on TCP-ENO [RFC8547] to negotiate whether encryption will be enabled for a connection as well as which key-agreement scheme to use. TCP-ENO negotiates the use of a particular TCP encryption protocol (TEP) by including protocol identifiers in ENO suboptions. This document associates four TEP identifiers with the tcpcrypt protocol as listed in Table 4 of Section 7. Each identifier indicates the use of a particular key-agreement scheme, with an associated CPRF and length parameter. Future standards can associate additional TEP identifiers with tcpcrypt following the assignment policy specified by TCP-ENO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt依赖TCP-ENO[RFC8547]协商是否为连接启用加密以及使用哪个密钥协议方案。TCP-ENO通过在ENO子选项中包含协议标识符来协商特定TCP加密协议（TEP）的使用。本文件将四个TEP标识符与第7节表4中列出的tcpcrypt协议相关联。每个标识符指示特定密钥协商方案的使用，并带有相关的CPRF和长度参数。未来的标准可以根据TCP-ENO指定的分配策略将额外的TEP标识符与tcpcrypt相关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An active opener that wishes to negotiate the use of tcpcrypt includes an ENO option in its SYN segment. That option includes suboptions with tcpcrypt TEP identifiers indicating the key-agreement schemes it is willing to enable. The active opener MAY additionally include suboptions indicating support for encryption protocols other than tcpcrypt, as well as global suboptions as specified by TCP-ENO.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
希望协商使用tcpcrypt的主动开证人在其SYN段中包括ENO选项。该选项包括带有tcpcrypt-TEP标识符的子选项，该标识符指示它愿意启用的关键协议方案。主动开启器还可以包括指示对除tcpcrypt之外的加密协议的支持的子选项，以及由TCP-ENO指定的全局子选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a passive opener receives an ENO option including tcpcrypt TEPs that it supports, it MAY then attach an ENO option to its SYN-ACK segment, including solely the TEP it wishes to enable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果被动开启器接收到包含其支持的tcpcrypt TEP的ENO选项，则可将ENO选项附加到其SYN-ACK段，仅包括其希望启用的TEP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To establish distinct roles for the two hosts in each connection, tcpcrypt depends on the role-negotiation mechanism of TCP-ENO. As one result of the negotiation process, TCP-ENO assigns hosts unique roles abstractly called &#34;A&#34; at one end of the connection and &#34;B&#34; at the other. Generally, an active opener plays the &#34;A&#34; role and a passive opener plays the &#34;B&#34; role, but in the case of simultaneous open, an additional mechanism breaks the symmetry and assigns a distinct role to each host. TCP-ENO uses the terms &#34;host A&#34; and &#34;host B&#34; to identify each end of a connection uniquely; this document employs those terms in the same way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了在每个连接中为两台主机建立不同的角色，tcpcrypt依赖于TCP-ENO的角色协商机制。作为协商过程的一个结果，TCP-ENO在连接的一端为主机分配抽象称为“A”的唯一角色，在另一端为主机分配抽象称为“B”的唯一角色。通常，主动开启器扮演“A”角色，被动开启器扮演“B”角色，但在同时开启的情况下，另一种机制会打破对称性，并为每个主机分配不同的角色。TCP-ENO使用术语“主机A”和“主机B”来唯一标识连接的每一端；本文件以同样的方式使用这些术语。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An ENO suboption includes a flag &#34;v&#34; which indicates the presence of associated variable-length data. In order to propose fresh key agreement with a particular tcpcrypt TEP, a host sends a one-byte suboption containing the TEP identifier and v = 0. In order to propose session resumption (described further below) with a particular TEP, a host sends a variable-length suboption containing the TEP identifier, the flag v = 1, an identifier derived from a session secret previously negotiated with the same host and the same TEP, and a nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ENO子选项包括一个标志“v”，表示存在相关的可变长度数据。为了提出与特定tcpcrypt-TEP的新密钥协议，主机发送一个包含TEP标识符和v=0的单字节子选项。为了使用特定TEP建议会话恢复（下文将进一步描述），主机发送一个可变长度的子选项，其中包含TEP标识符、标志v=1、从先前与同一主机和同一TEP协商的会话秘密派生的标识符以及nonce。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once two hosts have exchanged SYN segments, TCP-ENO defines the negotiated TEP to be the last valid TEP identifier in the SYN segment of host B (that is, the passive opener in the absence of simultaneous open) that also occurs in that of host A. If there is no such TEP, hosts MUST disable TCP-ENO and tcpcrypt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦两台主机交换了SYN段，TCP-ENO将协商的TEP定义为主机B的SYN段中的最后一个有效TEP标识符（即，在没有同时打开的情况下的被动开启器），该标识符也发生在主机A的SYN段中。如果没有此类TEP，主机必须禁用TCP-ENO和tcpcrypt。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the negotiated TEP was sent by host B with v = 0, it means that fresh key agreement will be performed as described in Section 3.3. If, on the other hand, host B sent the TEP with v = 1 and both hosts sent appropriate resumption identifiers in their suboption data, then the key-exchange messages will be omitted in favor of determining keys via session resumption as described in Section 3.5. With session resumption, protected application data MAY be sent immediately as detailed in Section 3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果协商的TEP是由主机B以v=0发送的，则表示将按照第3.3节所述执行新密钥协议。另一方面，如果主机B发送了v=1的TEP，并且两台主机都在其子选项数据中发送了适当的恢复标识符，则密钥交换消息将被省略，以便通过会话恢复来确定密钥，如第3.5节所述。通过会话恢复，可立即发送受保护的应用程序数据，详见第3.6节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the negotiated TEP is determined without reference to the &#34;v&#34; bits in ENO suboptions, so if host A offers resumption with a particular TEP and host B replies with a non-resumption suboption with the same TEP, that could become the negotiated TEP, in which case fresh key agreement will be performed. That is, sending a resumption suboption also implies willingness to perform fresh key agreement with the indicated TEP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，协商的TEP是在不参考ENO子选项中的“v”位的情况下确定的，因此，如果主机A提供具有特定TEP的恢复，而主机B使用具有相同TEP的非恢复子选项进行回复，则可能成为协商的TEP，在这种情况下，将执行新密钥协议。也就是说，发送恢复子选项还意味着愿意与指定的TEP执行新的密钥协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As REQUIRED by TCP-ENO, once a host has both sent and received an ACK segment containing a valid ENO option, encryption MUST be enabled and plaintext application data MUST NOT ever be exchanged on the connection. If the negotiated TEP is among those listed in Table 4, a host MUST follow the protocol described in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据TCP-ENO的要求，一旦主机发送和接收到包含有效ENO选项的ACK段，就必须启用加密，并且不能在连接上交换明文应用程序数据。如果协商的TEP在表4中列出，则主机必须遵循本文档中描述的协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Key Exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 密钥交换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following successful negotiation of a tcpcrypt TEP, all further signaling is performed in the Data portion of TCP segments. Except when resumption was negotiated (described in Section 3.5), the two hosts perform key exchange through two messages, Init1 and Init2, at the start of the data streams of host A and host B, respectively. These messages MAY span multiple TCP segments and need not end at a segment boundary. However, the segment containing the last byte of an Init1 or Init2 message MUST have TCP&#39;s push flag (PSH) set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在成功协商tcpcrypt-TEP之后，在TCP段的数据部分执行所有进一步的信令。除非协商恢复（如第3.5节所述），否则两台主机分别在主机A和主机B的数据流开始处通过两条消息Init1和Init2执行密钥交换。这些消息可能跨越多个TCP段，不需要在段边界处结束。但是，包含Init1或Init2消息最后一个字节的段必须设置TCP的推送标志（PSH）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key exchange protocol, in abstract, proceeds as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密钥交换协议抽象地进行如下操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       A -&gt; B:  Init1 = { INIT1_MAGIC, sym_cipher_list, N_A, Pub_A }
       B -&gt; A:  Init2 = { INIT2_MAGIC, sym_cipher, N_B, Pub_B }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       A -&gt; B:  Init1 = { INIT1_MAGIC, sym_cipher_list, N_A, Pub_A }
       B -&gt; A:  Init2 = { INIT2_MAGIC, sym_cipher, N_B, Pub_B }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The concrete format of these messages is specified in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.1节规定了这些信息的具体格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameters are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参数定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o INIT1_MAGIC, INIT2_MAGIC: Constants defined in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o INIT1_-MAGIC，INIT2_-MAGIC：第4.3节中定义的常数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher_list: A list of identifiers of symmetric ciphers (AEAD algorithms) acceptable to host A. These are specified in Table 5 of Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher_list：主机A可接受的对称密码（AEAD算法）标识符列表。第7节表5中规定了这些标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher: The symmetric cipher selected by host B from the sym_cipher_list sent by host A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o sym_cipher：主机B从主机A发送的sym_cipher_列表中选择的对称密码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N_A, N_B: Nonces chosen at random by hosts A and B, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N_A，N_B：主机A和主机B分别随机选择的nonce。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Pub_A, Pub_B: Ephemeral public keys for hosts A and B, respectively. These, as well as their corresponding private keys, are short-lived values that MUST be refreshed frequently. The private keys SHOULD NOT ever be written to persistent storage. The security risks associated with the storage of these keys are discussed in Section 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Pub_A，Pub_B：分别用于主机A和主机B的临时公钥。这些值及其相应的私钥都是短期值，必须经常刷新。私钥永远不应写入持久存储。第8节讨论了与存储这些密钥相关的安全风险。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a host receives an ephemeral public key from its peer and a key-validation step fails (see Section 5), it MUST abort the connection and raise an error condition distinct from the end-of-file condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果主机从其对等方接收到临时公钥，并且密钥验证步骤失败（请参阅第5节），则必须中止连接并引发与文件结束条件不同的错误条件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ephemeral secret ES is the result of the key-agreement algorithm (see Section 5) indicated by the negotiated TEP. The inputs to the algorithm are the local host&#39;s ephemeral private key and the remote host&#39;s ephemeral public key. For example, host A would compute ES using its own private key (not transmitted) and host B&#39;s public key, Pub_B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
短暂秘密ES是协商TEP指示的密钥协商算法（见第5节）的结果。算法的输入是本地主机的临时私钥和远程主机的临时公钥。例如，主机A将使用自己的私钥（未传输）和主机B的公钥Pub_B计算ES。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two sides then compute a pseudo-random key, PRK, from which all session secrets are derived, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，双方计算一个伪随机密钥PRK，所有会话机密都从该密钥中派生，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
PRK = Extract(N_A, eno_transcript | Init1 | Init2 | ES)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
PRK=摘录（N_A，eno_转录本|初始1 |初始2 | ES）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Above, &#34;|&#34; denotes concatenation, eno_transcript is the protocol-negotiation transcript defined in Section 4.8 of [RFC8547], and Init1 and Init2 are the transmitted encodings of the messages described in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上面，“|”表示串联，eno_转录本是[RFC8547]第4.8节中定义的协议协商转录本，Init1和Init2是第4.1节中描述的消息的传输编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A series of session secrets are computed from PRK as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从PRK计算一系列会话机密，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
ss[0] = PRK ss[i] = CPRF(ss[i-1], CONST_NEXTK, K_LEN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
ss[0]=PRK ss[i]=CPRF（ss[i-1]，CONST_NEXTK，K_LEN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value ss[0] is used to generate all key material for the current connection. The values ss[i] for i &gt; 0 are used by session resumption to avoid public key cryptography when establishing subsequent connections between the same two hosts as described in Section 3.5. The CONST_* values are constants defined in Section 4.3. The length K_LEN depends on the tcpcrypt TEP in use, and is specified in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值ss[0]用于生成当前连接的所有关键材质。会话恢复使用i&gt;0的值ss[i]，以避免在相同的两台主机之间建立后续连接时使用公钥加密，如第3.5节所述。常量值是第4.3节中定义的常量。长度K_LEN取决于使用的tcpcrypt TEP，并在第5节中规定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a session secret ss[i], the two sides compute a series of master keys as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定会话密钥ss[i]，双方计算一系列主密钥，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              mk[0] = CPRF(ss[i], CONST_REKEY | sn[i], K_LEN)
              mk[j] = CPRF(mk[j-1], CONST_REKEY, K_LEN)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              mk[0] = CPRF(ss[i], CONST_REKEY | sn[i], K_LEN)
              mk[j] = CPRF(mk[j-1], CONST_REKEY, K_LEN)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process of advancing through the series of master keys is described in Section 3.8. The values represented by sn[i] are session nonces. For the initial session with i = 0, the session nonce is zero bytes long. The values for subsequent sessions are derived from fresh connection data as described in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3.8节描述了通过主钥匙系列前进的过程。sn[i]表示的值是会话nonce。对于i=0的初始会话，会话nonce的长度为零字节。后续会话的值源自第3.5节所述的新连接数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, each master key mk[j] is used to generate traffic keys for protecting application data using authenticated encryption:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，每个主密钥mk[j]用于生成流量密钥，以使用经过身份验证的加密来保护应用程序数据：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       k_ab[j] = CPRF(mk[j], CONST_KEY_A, ae_key_len + ae_nonce_len)
       k_ba[j] = CPRF(mk[j], CONST_KEY_B, ae_key_len + ae_nonce_len)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       k_ab[j] = CPRF(mk[j], CONST_KEY_A, ae_key_len + ae_nonce_len)
       k_ba[j] = CPRF(mk[j], CONST_KEY_B, ae_key_len + ae_nonce_len)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the first session derived from fresh key agreement, traffic keys k_ab[j] are used by host A to encrypt and host B to decrypt, while keys k_ba[j] are used by host B to encrypt and host A to decrypt. In a resumed session, as described more thoroughly in Section 3.5, each host uses the keys in the same way as it did in the original session, regardless of its role in the current session; for example, if a host played role &#34;A&#34; in the first session, it will use keys k_ab[j] to encrypt in each derived session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在源于新密钥协议的第一会话中，主机A使用流量密钥k_ab[j]进行加密，主机B使用密钥k_ba[j]进行解密，主机B使用密钥k_ba[j]进行加密，主机A使用密钥进行解密。如第3.5节所述，在续会中，无论主机在当前会话中的角色如何，每个主机都以与原始会话相同的方式使用密钥；例如，如果主机在第一个会话中扮演“a”角色，它将在每个派生会话中使用密钥k_ab[j]进行加密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values ae_key_len and ae_nonce_len depend on the authenticated-encryption algorithm selected and are given in Table 3 of Section 6. The algorithm uses the first ae_key_len bytes of each traffic key as an authenticated-encryption key, and it uses the following ae_nonce_len bytes as a nonce randomizer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ae_key_len和ae_nonce_len的值取决于选择的认证加密算法，并在第6节的表3中给出。该算法使用每个流量密钥的第一个ae_密钥字节作为经过身份验证的加密密钥，并使用以下ae_nonce_len字节作为nonce随机化器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations SHOULD provide an interface allowing the user to specify, for a particular connection, the set of AEAD algorithms to advertise in sym_cipher_list (when playing role &#34;A&#34;) and also the order of preference to use when selecting an algorithm from those offered (when playing role &#34;B&#34;). A companion document [TCPINC-API] describes recommended interfaces for this purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现应提供一个接口，允许用户为特定连接指定要在sym_cipher_列表中公布的AEAD算法集（扮演角色“a”）以及从提供的算法中选择算法时使用的优先顺序（扮演角色“B”）。配套文件[TCPINC-API]描述了为此目的推荐的接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After host B sends Init2 or host A receives it, that host MAY immediately begin transmitting protected application data as described in Section 3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在主机B发送Init2或主机A接收到Init2后，该主机可立即开始传输受保护的应用程序数据，如第3.6节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If host A receives Init2 with a sym_cipher value that was not present in the sym_cipher_list it previously transmitted in Init1, it MUST abort the connection and raise an error condition distinct from the end-of-file condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果主机A接收到的Init2的sym_密码值不在其先前在Init1中传输的sym_密码列表中，则它必须中止连接并引发与文件结束条件不同的错误条件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout this document, to &#34;abort the connection&#34; means to issue the &#34;Abort&#34; command as described in Section 3.8 of [RFC793]. That is, the TCP connection is destroyed, RESET is transmitted, and the local user is alerted to the abort event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本文件中，“中止连接”是指按照[RFC793]第3.8节的规定发出“中止”命令。也就是说，TCP连接被破坏，重置被传输，本地用户收到中止事件的警报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Session ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 会话ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENO requires each TEP to define a session ID value that uniquely identifies each encrypted connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENO要求每个TEP定义唯一标识每个加密连接的会话ID值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A tcpcrypt session ID begins with the byte transmitted by host B that contains the negotiated TEP identifier along with the &#34;v&#34; bit. The remainder of the ID is derived from the session secret and session nonce, as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcrypt会话ID以主机B传输的字节开始，该字节包含协商的TEP标识符以及“v”位。ID的其余部分来自会话机密和会话nonce，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
session_id[i] = TEP-byte | CPRF(ss[i], CONST_SESSID | sn[i], K_LEN)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
会话id[i]=TEP字节| CPRF（ss[i]，CONST|u sessiond | sn[i]，K|LEN）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Again, the length K_LEN depends on the TEP and is specified in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同样，长度K_LEN取决于TEP，并在第5节中规定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Session Resumption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 复会
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If two hosts have previously negotiated a session with secret ss[i-1], they can establish a new connection without public-key operations using ss[i], the next session secret in the sequence derived from the original PRK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果两台主机先前已与机密ss[i-1]协商会话，则它们可以使用ss[i]建立新连接，而无需公钥操作，该序列中的下一个会话机密来自原始PRK。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host signals its willingness to resume with a particular session secret by sending a SYN segment with a resumption suboption, i.e., an ENO suboption containing the negotiated TEP identifier of the previous session, half of the resumption identifier for the new session, and a resumption nonce.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主机通过发送具有恢复子选项的SYN段（即，包含前一会话的协商TEP标识符的ENO子选项、新会话的恢复标识符的一半以及恢复nonce）来表示其愿意使用特定会话秘密恢复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resumption nonce MUST have a minimum length of zero bytes and maximum length of eight bytes. The value MUST be chosen randomly or using a mechanism that guarantees uniqueness even in the face of virtual-machine cloning or other re-execution of the same session. An attacker who can force either side of a connection to reuse a session secret with the same nonce will completely break the security
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
恢复nonce的最小长度必须为零字节，最大长度必须为八字节。该值必须随机选择，或者使用一种机制来保证唯一性，即使在面临虚拟机克隆或相同会话的其他重新执行时也是如此。攻击者可以强制连接的任何一方以相同的时间重复使用会话机密，这将完全破坏安全性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
of tcpcrypt. Reuse of session secrets is possible in the event of virtual-machine cloning or reuse of system-level hibernation state. Implementations SHOULD provide an API through which to set the resumption nonce length and MUST default to eight bytes if they cannot prohibit the reuse of session secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcrypt公司。在虚拟机克隆或重用系统级休眠状态的情况下，可以重用会话机密。实现应该提供一个API，通过该API设置恢复的nonce长度，如果不能禁止会话机密的重用，则必须默认为8个字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The resumption identifier is calculated from a session secret ss[i] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
恢复标识符根据会话秘密ss[i]计算，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
resume[i] = CPRF(ss[i], CONST_RESUME, 18)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
简历[i]=CPRF（ss[i]，简历，18）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To name a session for resumption, a host sends either the first or second half of the resumption identifier according to the role it played in the original session with secret ss[0].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要命名要恢复的会话，主机将根据其在原始会话中与机密ss[0]扮演的角色发送恢复标识符的前半部分或后半部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host that originally played role &#34;A&#34; and wishes to resume from a cached session sends a suboption with the first half of the resumption identifier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最初扮演“A”角色并希望从缓存会话恢复的主机将发送一个子选项，其中包含恢复标识符的前半部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         byte     0      1             9      10
              +------+------+--...--+------+------+--...--+------+
              | TEP- |   resume[i]{0..8}   |       nonce_a       |
              | byte |                     |                     |
              +------+------+--...--+------+------+--...--+------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         byte     0      1             9      10
              +------+------+--...--+------+------+--...--+------+
              | TEP- |   resume[i]{0..8}   |       nonce_a       |
              | byte |                     |                     |
              +------+------+--...--+------+------+--...--+------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 2: Resumption suboption sent when original role was &#34;A&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
图2：当原始角色为“A”时发送的恢复子选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TEP-byte contains a tcpcrypt TEP identifier and v = 1. The nonce value MUST have length between 0 and 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEP字节包含tcpcrypt TEP标识符，v=1。nonce值的长度必须介于0和8字节之间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a host that originally played role &#34;B&#34; sends a suboption with the second half of the resumption identifier:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类似地，最初扮演角色“B”的主机发送带有恢复标识符后半部分的子选项：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         byte     0      1             9      10
              +------+------+--...--+------+------+--...--+------+
              | TEP- |   resume[i]{9..17}  |       nonce_b       |
              | byte |                     |                     |
              +------+------+--...--+------+------+--...--+------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         byte     0      1             9      10
              +------+------+--...--+------+------+--...--+------+
              | TEP- |   resume[i]{9..17}  |       nonce_b       |
              | byte |                     |                     |
              +------+------+--...--+------+------+--...--+------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 3: Resumption suboption sent when original role was &#34;B&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
图3：当原始角色为“B”时发送的恢复子选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TEP-byte contains a tcpcrypt TEP identifier and v = 1. The nonce value MUST have length between 0 and 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEP字节包含tcpcrypt TEP标识符，v=1。nonce值的长度必须介于0和8字节之间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a passive opener receives a resumption suboption containing an identifier-half that names a session secret that it has cached, and the subobtion&#39;s TEP matches the TEP used in the previous session, it SHOULD (with exceptions specified below) agree to resume from the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果被动开启器接收到一个恢复子选项，该子选项包含命名其缓存的会话机密的标识符的一半，并且该子选项的TEP与上一个会话中使用的TEP匹配，则该子选项（以下指定的例外情况除外）应同意从
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cached session by sending its own resumption suboption, which will contain the other half of the identifier. Otherwise, it MUST NOT agree to resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过发送自己的恢复子选项（将包含标识符的另一半）来缓存会话。否则，它决不能同意恢复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a passive opener does not agree to resumption with a particular TEP, it MAY either request fresh key exchange by responding with a non-resumption suboption using the same TEP or else respond to any other received TEP suboption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果被动开启器不同意使用特定TEP恢复，它可以通过使用相同TEP的非恢复子选项响应请求新密钥交换，或者响应任何其他接收到的TEP子选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a passive opener receives an ENO suboption with a TEP identifier and v = 1, but the suboption data is less than 9 bytes in length, it MUST behave as if the same TEP had been sent with v = 0. That is, the suboption MUST be interpreted as an offer to negotiate fresh key exchange with that TEP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果被动开启器接收到具有TEP标识符且v=1的ENO子选项，但子选项数据长度小于9字节，则其行为必须与发送相同TEP且v=0时的行为相同。也就是说，子选项必须解释为与该TEP协商新密钥交换的提议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an active opener sends a resumption suboption with a particular TEP and the appropriate half of a resumption identifier, and then, in the same TCP handshake, it receives a resumption suboption with the same TEP and an identifier-half that does not match that resumption identifier, it MUST ignore that suboption. In the typical case that this was the only ENO suboption received, this means the host MUST disable TCP-ENO and tcpcrypt; it MUST NOT send any more ENO options and MUST NOT encrypt the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果活动开启器发送具有特定TEP和相应一半恢复标识符的恢复子选项，然后在同一TCP握手中，它接收到具有相同TEP和与该恢复标识符不匹配的标识符一半的恢复子选项，则它必须忽略该子选项。在典型情况下，这是收到的唯一ENO子选项，这意味着主机必须禁用TCP-ENO和tcpcrypt；它不能再发送任何ENO选项，也不能加密连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a host concludes that TCP-ENO negotiation has succeeded for some TEP that was received in a resumption suboption, it MUST then enable encryption with that TEP using the cached session secret. To do this, it first constructs sn[i] as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当主机断定恢复子选项中接收到的某个TEP的TCP-ENO协商已成功时，它必须使用缓存的会话密钥启用该TEP的加密。为此，它首先构造sn[i]，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
sn[i] = nonce_a | nonce_b
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
sn[i]=nonce_a | nonce_b
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Master keys are then computed from s[i] and sn[i] as described in Section 3.3 as well as from application data encrypted as described in Section 3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后根据第3.3节所述的s[i]和sn[i]以及第3.6节所述的加密应用程序数据计算主密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The session ID (Section 3.4) is constructed in the same way for resumed sessions as it is for fresh ones. In this case, the first byte will always have v = 1. The remainder of the ID is derived from the cached session secret and the session nonce that was generated during resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话ID（第3.4节）的构造方式与新会话的构造方式相同。在这种情况下，第一个字节将始终具有v=1。ID的其余部分来自缓存的会话机密和恢复期间生成的会话nonce。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case of simultaneous open where TCP-ENO is able to establish asymmetric roles, two hosts that simultaneously send SYN segments with compatible resumption suboptions MAY resume the associated session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在同时开放的情况下，TCP-ENO能够建立非对称角色，同时发送SYN段的两台主机可以使用兼容的恢复子选项恢复相关会话。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a particular SYN segment, a host SHOULD NOT send more than one resumption suboption (because this consumes TCP option space and is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在特定的SYN段中，主机不应发送多个恢复子选项（因为这会占用TCP选项空间，并且是无效的）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unlikely to be a useful practice), and it MUST NOT send more than one resumption suboption with the same TEP identifier. But in addition to any resumption suboptions, an active opener MAY include non-resumption suboptions describing other TEPs it supports (in addition to the TEP in the resumption suboption).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不太可能是有用的做法），并且它不能发送多个具有相同TEP标识符的恢复子选项。但除了任何恢复子选项外，活动开启器还可能包括描述其支持的其他TEP的非恢复子选项（除了恢复子选项中的TEP）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After using the session secret ss[i] to compute mk[0], implementations SHOULD compute and cache ss[i+1] for possible use by a later session and then erase ss[i] from memory. Hosts MAY retain ss[i+1] until it is used or the memory needs to be reclaimed. Hosts SHOULD NOT write any session secrets to non-volatile storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在使用会话秘密ss[i]来计算mk[0]之后，实现应该计算并缓存ss[i+1]，以供以后的会话使用，然后从内存中删除ss[i]。主机可能会保留ss[i+1]，直到它被使用或需要回收内存。主机不应将任何会话机密写入非易失性存储。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When proposing resumption, the active opener MUST use the lowest value of &#34;i&#34; that has not already been used (successfully or not) to negotiate resumption with the same host and for the same original session secret ss[0].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
建议恢复时，活动开启器必须使用尚未（成功或未成功）用于与同一主机和同一原始会话密钥ss协商恢复的最低值“i”[0]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A given session secret ss[i] MUST NOT be used to secure more than one TCP connection. To prevent this, a host MUST NOT resume with a session secret if it has ever enabled encryption in the past with the same secret, in either role. In the event that two hosts simultaneously send SYN segments to each other that propose resumption with the same session secret but with both segments not part of a simultaneous open, both connections would need to revert to fresh key exchange. To avoid this limitation, implementations MAY choose to implement session resumption such that all session secrets derived from a given ss[0] are used for either passive or active opens at the same host, not both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定的会话机密ss[i]不能用于保护多个TCP连接。为了防止出现这种情况，如果主机以前在任何一个角色中使用相同的密钥启用过加密，则不得使用会话密钥恢复。如果两台主机同时向另一台主机发送SYN段，这些SYN段建议使用相同的会话密钥恢复，但两个段都不是同时打开的一部分，则两个连接都需要恢复到新密钥交换。为了避免这种限制，实现可以选择实现会话恢复，以便从给定ss[0]派生的所有会话机密都用于同一主机上的被动或主动打开，而不是同时用于被动或主动打开。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If two hosts have previously negotiated a tcpcrypt session, either host MAY later initiate session resumption regardless of which host was the active opener or played the &#34;A&#34; role in the previous session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果两台主机先前协商了tcpcrypt会话，则无论哪台主机是活动的开启者或在上一个会话中扮演了“a”角色，任何一台主机都可以稍后启动会话恢复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, a given host MUST either encrypt with keys k_ab[j] for all sessions derived from the same original session secret ss[0], or with keys k_ba[j]. Thus, which keys a host uses to send segments is not affected by the role it plays in the current connection: it depends only on whether the host played the &#34;A&#34; or &#34;B&#34; role in the initial session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
但是，给定的主机必须使用密钥k_ab[j]对从同一原始会话密钥ss[0]派生的所有会话进行加密，或者使用密钥k_ba[j]进行加密。因此，主机用于发送段的键不受其在当前连接中扮演的角色的影响：它只取决于主机在初始会话中扮演的是“a”还是“B”角色。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations that cache session secrets MUST provide a means for applications to control that caching. In particular, when an application requests a new TCP connection, it MUST have a way to specify two policies for the duration of the connection: 1) that resumption requests will be ignored, and thus fresh key exchange will be necessary; and 2) that no session secrets will be cached. (These policies can be specified independently or as a unit.) And for an established connection, an application MUST have a means to cause any
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
缓存会话机密的实现必须为应用程序提供控制该缓存的方法。特别是，当一个应用程序请求一个新的TCP连接时，它必须有一种方法在连接期间指定两个策略：1）将忽略恢复请求，因此需要进行新的密钥交换；2）不会缓存任何会话机密。（这些策略可以单独指定，也可以作为一个单元指定。）对于已建立的连接，应用程序必须具有导致任何
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cache state that was used in or resulted from establishing the connection to be flushed. A companion document [TCPINC-API] describes recommended interfaces for this purpose.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在建立要刷新的连接时使用或产生的缓存状态。配套文件[TCPINC-API]描述了为此目的推荐的接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Data Encryption and Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 数据加密和认证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following key exchange (or its omission via session resumption), all further communication in a tcpcrypt-enabled connection is carried out within delimited encryption frames that are encrypted and authenticated using the agreed-upon keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在密钥交换（或通过会话恢复省略密钥）之后，tcpcrypt启用连接中的所有进一步通信都在使用约定密钥加密和验证的分隔加密帧内执行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protection is provided via algorithms for Authenticated Encryption with Associated Data (AEAD). The permitted algorithms are listed in Table 5 of Section 7. Additional algorithms can be specified in the future according to the policy in that section. One algorithm is selected during the negotiation described in Section 3.3. The lengths ae_key_len and ae_nonce_len associated with each algorithm are found in Table 3 of Section 6 along with requirements for which algorithms MUST be implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这种保护是通过相关数据的认证加密算法（AEAD）提供的。第7节表5列出了允许的算法。将来可以根据该部分中的策略指定其他算法。在第3.3节所述的协商过程中选择一种算法。与每种算法相关的长度ae_key_len和ae_nonce_len见第6节表3，以及必须实施算法的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The format of an encryption frame is specified in Section 4.2. A sending host breaks its stream of application data into a series of chunks. Each chunk is placed in the data field of a plaintext value, which is then encrypted to yield a frame&#39;s ciphertext field. Chunks MUST be small enough that the ciphertext (whose length depends on the AEAD cipher used, and is generally slightly longer than the plaintext) has length less than 2^16 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.2节规定了加密帧的格式。发送主机将其应用程序数据流分成一系列块。每个区块被放置在一个明文值的数据字段中，然后对其进行加密以生成一个帧的密文字段。块必须足够小，以使密文（其长度取决于所使用的AEAD密码，通常略长于明文）的长度小于2^16字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An &#34;associated data&#34; value (see Section 4.2.2) is constructed for the frame. It contains the frame&#39;s control field and the length of the ciphertext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为框架构造“相关数据”值（见第4.2.2节）。它包含帧的控制字段和密文的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A &#34;frame ID&#34; value (see Section 4.2.3) is also constructed for the frame, but not explicitly transmitted. It contains a 64-bit offset field whose integer value is the zero-indexed byte offset of the beginning of the current encryption frame in the underlying TCP datastream. (That is, the offset in the framing stream, not the plaintext application stream.) The offset is then left-padded with zero-valued bytes to form a value of length ae_nonce_len. Because it is strictly necessary for the security of the AEAD algorithms specified in this document, an implementation MUST NOT ever transmit distinct frames with the same frame ID value under the same encryption key. In particular, a retransmitted TCP segment MUST contain the same payload bytes for the same TCP sequence numbers, and a host MUST NOT transmit more than 2^64 bytes in the underlying TCP datastream (which would cause the offset field to wrap) before rekeying as described in Section 3.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还为帧构造了“帧ID”值（见第4.2.3节），但未明确传输。它包含一个64位偏移量字段，其整数值是底层TCP数据流中当前加密帧开头的零索引字节偏移量。（也就是说，帧流中的偏移量，而不是明文应用程序流中的偏移量。）然后用零值字节填充偏移量，以形成长度ae_nonce_len的值。由于本文档中规定的AEAD算法的安全性是严格必要的，因此实现不得在相同的加密密钥下传输具有相同帧ID值的不同帧。特别是，对于相同的TCP序列号，重新传输的TCP段必须包含相同的有效负载字节，并且在按照第3.8节所述重新键入之前，主机在底层TCP数据流中传输的字节不得超过2^64字节（这将导致偏移字段换行）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keys for AEAD encryption are taken from the traffic key k_ab[j] or k_ba[j] for some &#34;j&#34;, according to the host&#39;s role as described in Section 3.3. First, the appropriate traffic key is divided into two parts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据第3.3节所述的主机角色，AEAD加密密钥取自某些“j”的流量密钥k_ab[j]或k_ba[j]。首先，适当的通信密钥分为两部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      ae_key_len + ae_nonce_len - 1
                                                       |
        byte  0                    ae_key_len          |
              |                           |            |
              v                           v            v
            +----+----+--...--+----+----+----+--...--+----+
            |             K             |        NR       |
            +----+----+--...--+----+----+----+--...--+----+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                      ae_key_len + ae_nonce_len - 1
                                                       |
        byte  0                    ae_key_len          |
              |                           |            |
              v                           v            v
            +----+----+--...--+----+----+----+--...--+----+
            |             K             |        NR       |
            +----+----+--...--+----+----+----+--...--+----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 4: Format of Traffic Key
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
图4：流量密钥的格式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With reference to the &#34;AEAD Interface&#34; described in Section 2 of [RFC5116], the first ae_key_len bytes of the traffic key provide the AEAD key K. The remaining ae_nonce_len bytes provide a nonce randomizer value NR, which is combined via bitwise exclusive-or with the frame ID to yield N, the AEAD nonce for the frame:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考[RFC5116]第2节中描述的“AEAD接口”，通信密钥的第一个AEAD密钥字节提供AEAD密钥K。剩余的AEAD nonce len字节提供一个nonce随机化值NR，该值通过位异或与帧ID组合，以产生N，帧的AEAD nonce：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                            N = frame_ID XOR NR
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                            N = frame_ID XOR NR
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining AEAD inputs, P and A, are provided by the frame&#39;s plaintext value and associated data, respectively. The output of the AEAD operation, C, is transmitted in the frame&#39;s ciphertext field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其余AEAD输入P和A分别由帧的明文值和相关数据提供。AEAD操作的输出C在帧的密文字段中传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a frame is received, tcpcrypt reconstructs the associated data and frame ID values (the former contains only data sent in the clear, and the latter is implicit in the TCP stream), computes the nonce N as above, and provides these and the ciphertext value to the AEAD decryption operation. The output of this operation is either a plaintext value P or the special symbol FAIL. In the latter case, the implementation SHOULD abort the connection and raise an error condition distinct from the end-of-file condition. But if none of the TCP segment(s) containing the frame have been acknowledged and retransmission could potentially result in a valid frame, an implementation MAY instead drop these segments (and renege if they have been selectively acknowledged (SACKed), according to Section 8 of [RFC2018]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收到帧时，tcpcrypt重建相关数据和帧ID值（前者仅包含以明文发送的数据，后者隐含在TCP流中），如上所述计算nonce N，并将这些值和密文值提供给AEAD解密操作。此操作的输出为明文值P或特殊符号FAIL。在后一种情况下，实现应该中止连接并引发与文件结束条件不同的错误条件。但是，如果包含该帧的TCP段中没有一个（或多个）已被确认，并且重新传输可能会导致有效帧，则实现可能会放弃这些段（并且根据[RFC2018]第8节，如果它们已被选择性确认（撤销），则会放弃）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. TCP Header Protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. TCP头保护
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ciphertext field of the encryption frame contains protected versions of certain TCP header values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加密帧的密文字段包含某些TCP头值的受保护版本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the URGp bit is set, the urgent field indicates an offset from the current frame&#39;s beginning offset; the sum of these offsets gives the index of the last byte of urgent data in the application datastream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当设置URGp位时，紧急字段指示与当前帧的开始偏移的偏移；这些偏移量的总和给出了应用程序数据流中紧急数据的最后一个字节的索引。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST set the FINp bit on the last frame it sends in the connection (unless it aborts the connection) and MUST NOT set FINp on any other frame.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送方必须在其在连接中发送的最后一帧上设置FINp位（除非中止连接），并且不得在任何其他帧上设置FINp。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP sets the FIN flag when a sender has no more data, which with tcpcrypt means setting FIN on the segment containing the last byte of the last frame. However, a receiver MUST report the end-of-file condition to the connection&#39;s local user when and only when it receives a frame with the FINp bit set. If a host receives a segment with the TCP FIN flag set but the received datastream including this segment does not contain a frame with FINp set, the host SHOULD abort the connection and raise an error condition distinct from the end-of-file condition. But if there are unacknowledged segments whose retransmission could potentially result in a valid frame, the host MAY instead drop the segment with the TCP FIN flag set (and renege if it has been SACKed, according to Section 8 of [RFC2018]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP在发送方没有更多数据时设置FIN标志，这与tcpcrypt一起意味着在包含最后一帧最后一个字节的段上设置FIN。但是，当且仅当接收器接收到设置了FINp位的帧时，必须向连接的本地用户报告文件结束情况。如果主机接收到设置了TCP FIN标志的段，但接收到的包含该段的数据流不包含设置了FINp的帧，则主机应中止连接并引发与文件结束条件不同的错误条件。但是，如果存在未确认的段，其重新传输可能会导致有效帧，则主机可能会丢弃设置了TCP FIN标志的段（并且根据[RFC2018]的第8节，如果该段已被撤销，则放弃）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. Rekeying
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. 重新键入
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rekeying allows hosts to wipe from memory keys that could decrypt previously transmitted segments. It also allows the use of AEAD ciphers that can securely encrypt only a bounded number of messages under a given key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过重新设置密钥，主机可以从内存中擦除可以解密先前传输的段的密钥。它还允许使用AEAD密码，该密码只能在给定密钥下安全加密有限数量的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 3.3, a master key mk[j] is used to generate two encryption keys k_ab[j] and k_ba[j]. We refer to these as a key set with generation number &#34;j&#34;. Each host maintains both a local generation number that determines which key set it uses to encrypt outgoing frames and a remote generation number equal to the highest generation used in frames received from its peer. Initially, these two generation numbers are set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第3.3节所述，主密钥mk[j]用于生成两个加密密钥k_ab[j]和k_ba[j]。我们将其称为具有生成编号“j”的密钥集。每个主机都维护一个本地生成号，该生成号确定其用于加密传出帧的密钥集，以及一个远程生成号，该生成号等于从其对等机接收的帧中使用的最高生成数。最初，这两个代数设置为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host MAY increment its local generation number beyond the remote generation number it has recorded. We call this action &#34;initiating rekeying&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主机可以将其本地生成号增加到其记录的远程生成号之外。我们称之为“启动密钥更新”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a host has incremented its local generation number and uses the new key set for the first time to encrypt an outgoing frame, it MUST set rekey = 1 for that frame. It MUST set rekey = 0 in all other cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当主机增加其本地生成号并首次使用新密钥集加密传出帧时，它必须为该帧设置rekey=1。在所有其他情况下，它必须将rekey设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a host receives a frame with rekey = 1, it increments its record of the remote generation number. If the remote generation number is now greater than the local generation number, the receiver MUST immediately increment its local generation number to match. Moreover, if the receiver has not yet transmitted a segment with the FIN flag set, it MUST immediately send a frame (with empty application data if necessary) with rekey = 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当主机接收到rekey=1的帧时，它会增加其远程生成号的记录。如果远程发电编号现在大于本地发电编号，则接收器必须立即增加其本地发电编号以匹配。此外，如果接收器尚未发送设置了FIN标志的段，则必须立即发送rekey=1的帧（如有必要，应用程序数据为空）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A host MUST NOT initiate more than one concurrent rekey operation if it has no data to send; that is, it MUST NOT initiate rekeying with an empty encryption frame more than once while its record of the remote generation number is less than its own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果主机没有数据要发送，则不得启动多个并发密钥更新操作；也就是说，当其远程生成号的记录小于自己的记录时，它不能多次使用空加密帧启动密钥更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that when parts of the datastream are retransmitted, TCP requires that implementations always send the same data bytes for the same TCP sequence numbers. Thus, frame data in retransmitted segments MUST be encrypted with the same key as when it was first transmitted, regardless of the current local generation number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，当部分数据流被重新传输时，TCP要求实现始终为相同的TCP序列号发送相同的数据字节。因此，重传段中的帧数据必须使用与第一次传输时相同的密钥加密，而与当前本地生成号无关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations SHOULD delete older-generation keys from memory once they have received all frames they will need to decrypt with the old keys and have encrypted all outgoing frames under the old keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦实现接收到所有需要用旧密钥解密的帧，并对旧密钥下的所有传出帧进行加密，就应该从内存中删除旧一代密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. Keep-Alive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. 活命
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of using TCP keep-alives to verify that the remote endpoint is still responsive, tcpcrypt implementations SHOULD employ the rekeying mechanism for this purpose, as follows. When necessary, a host SHOULD probe the liveness of its peer by initiating rekeying and transmitting a new frame immediately (with empty application data if necessary).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcrypt实现不应使用TCP keep alives来验证远程端点是否仍然有响应，而应为此目的使用密钥更新机制，如下所示。必要时，主机应通过启动密钥更新并立即发送新帧（必要时使用空应用程序数据）来探测其对等方的活动性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 3.8, a host receiving a frame encrypted under a generation number greater than its own MUST increment its own generation number and (if it has not already transmitted a segment with FIN set) immediately transmit a new frame (with zero-length application data if necessary).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第3.8节所述，接收根据大于其自身的生成号加密的帧的主机必须增加其自身的生成号，并且（如果尚未发送具有FIN set的段）立即发送新帧（如有必要，使用零长度应用数据）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MAY use TCP keep-alives for purposes that do not require endpoint authentication, as discussed in Section 8.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第8.2节所述，实现可以将TCP keep alives用于不需要端点身份验证的目的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Encodings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 编码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides byte-level encodings for values transmitted or computed by the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节为协议传输或计算的值提供字节级编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Key-Exchange Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 密钥交换消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Init1 message has the following encoding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Init1消息具有以下编码：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       byte   0       1       2       3
          +-------+-------+-------+-------+
          |          INIT1_MAGIC          |
          |                               |
          +-------+-------+-------+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       byte   0       1       2       3
          +-------+-------+-------+-------+
          |          INIT1_MAGIC          |
          |                               |
          +-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  4        5      6       7
              +-------+-------+-------+-------+
              |          message_len          |
              |              = M              |
              +-------+-------+-------+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  4        5      6       7
              +-------+-------+-------+-------+
              |          message_len          |
              |              = M              |
              +-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  8
              +--------+-----+----+-----+----+---...---+-----+-----+
              |nciphers|sym_      |sym_      |         |sym_       |
              | = K    |cipher[0] |cipher[1] |         |cipher[K-1]|
              +--------+-----+----+-----+----+---...---+-----+-----+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  8
              +--------+-----+----+-----+----+---...---+-----+-----+
              |nciphers|sym_      |sym_      |         |sym_       |
              | = K    |cipher[0] |cipher[1] |         |cipher[K-1]|
              +--------+-----+----+-----+----+---...---+-----+-----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               2*K + 9                     2*K + 9 + N_A_LEN
                  |                         |
                  v                         v
              +-------+---...---+-------+-------+---...---+-------+
              |           N_A           |          Pub_A          |
              |                         |                         |
              +-------+---...---+-------+-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               2*K + 9                     2*K + 9 + N_A_LEN
                  |                         |
                  v                         v
              +-------+---...---+-------+-------+---...---+-------+
              |           N_A           |          Pub_A          |
              |                         |                         |
              +-------+---...---+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                  M - 1
              +-------+---...---+-------+
              |         ignored         |
              |                         |
              +-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                  M - 1
              +-------+---...---+-------+
              |         ignored         |
              |                         |
              +-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constant INIT1_MAGIC is defined in Section 4.3. The four-byte field message_len gives the length of the entire Init1 message, encoded as a big-endian integer. The nciphers field contains an integer value that specifies the number of two-byte symmetric-cipher identifiers that follow. The sym_cipher[i] identifiers indicate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.3节定义了常数INIT1_MAGIC。四字节字段消息_len给出整个Init1消息的长度，编码为大端整数。nciphers字段包含一个整数值，该整数值指定后面的两字节对称密码标识符的数量。sym_密码[i]标识符表示
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cryptographic algorithms in Table 5 in Section 7. The length N_A_LEN and the length of Pub_A are both determined by the negotiated TEP as described in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第7节表5中的加密算法。长度N_A_LEN和长度Pub_A均由第5节所述的协商TEP确定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of this protocol MUST construct Init1 such that the ignored field has zero length; that is, they MUST construct the message such that its end, as determined by message_len, coincides with the end of the field Pub_A. When receiving Init1, however, implementations MUST permit and ignore any bytes following Pub_A.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该协议的实现必须构造Init1，以便忽略的字段长度为零；也就是说，它们必须构造消息，使其结尾（由message_len确定）与字段Pub_A的结尾一致。但是，当接收Init1时，实现必须允许并忽略Pub_A之后的任何字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Init2 message has the following encoding:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Init2消息具有以下编码：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       byte   0       1       2       3
          +-------+-------+-------+-------+
          |          INIT2_MAGIC          |
          |                               |
          +-------+-------+-------+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       byte   0       1       2       3
          +-------+-------+-------+-------+
          |          INIT2_MAGIC          |
          |                               |
          +-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  4        5      6       7       8       9
              +-------+-------+-------+-------+-------+-------+
              |          message_len          |  sym_cipher   |
              |              = M              |               |
              +-------+-------+-------+-------+-------+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  4        5      6       7       8       9
              +-------+-------+-------+-------+-------+-------+
              |          message_len          |  sym_cipher   |
              |              = M              |               |
              +-------+-------+-------+-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  10                      10 + N_B_LEN
                  |                         |
                  v                         v
              +-------+---...---+-------+-------+---...---+-------+
              |           N_B           |          Pub_B          |
              |                         |                         |
              +-------+---...---+-------+-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  10                      10 + N_B_LEN
                  |                         |
                  v                         v
              +-------+---...---+-------+-------+---...---+-------+
              |           N_B           |          Pub_B          |
              |                         |                         |
              +-------+---...---+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                  M - 1
              +-------+---...---+-------+
              |          ignored        |
              |                         |
              +-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                  M - 1
              +-------+---...---+-------+
              |          ignored        |
              |                         |
              +-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The constant INIT2_MAGIC is defined in Section 4.3. The four-byte field message_len gives the length of the entire Init2 message, encoded as a big-endian integer. The sym_cipher value is a selection from the symmetric-cipher identifiers in the previously-received Init1 message. The length N_B_LEN and the length of Pub_B are both determined by the negotiated TEP as described in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.3节定义了常数INIT2_MAGIC。四字节字段消息_len给出整个Init2消息的长度，编码为大端整数。sym_密码值是从先前收到的Init1消息中的对称密码标识符中选择的。长度N_B_LEN和长度Pub_B均由第5节所述的协商TEP确定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations of this protocol MUST construct Init2 such that the field &#34;ignored&#34; has zero length; that is, they MUST construct the message such that its end, as determined by message_len, coincides with the end of the Pub_B field. When receiving Init2, however, implementations MUST permit and ignore any bytes following Pub_B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该协议的实现必须构造Init2，使得字段“忽略”的长度为零；也就是说，他们必须构造消息，以便消息的结尾（由message_len确定）与Pub_B字段的结尾一致。但是，在接收Init2时，实现必须允许并忽略发布后的任何字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Encryption Frames
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 加密帧
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An encryption frame comprises a control byte and a length-prefixed ciphertext value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加密帧包括控制字节和长度前缀密文值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte   0       1       2       3               clen+2
             +-------+-------+-------+-------+---...---+-------+
             |control|      clen     |        ciphertext       |
             +-------+-------+-------+-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte   0       1       2       3               clen+2
             +-------+-------+-------+-------+---...---+-------+
             |control|      clen     |        ciphertext       |
             +-------+-------+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The field clen is an integer in big-endian format and gives the length of the ciphertext field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字段clen是一个大端格式的整数，给出密文字段的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The control field has this structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
控制字段具有以下结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  bit     7                 1       0
                      +-------+---...---+-------+-------+
                      |          cres           | rekey |
                      +-------+---...---+-------+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  bit     7                 1       0
                      +-------+---...---+-------+-------+
                      |          cres           | rekey |
                      +-------+---...---+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The seven-bit field cres is reserved; implementations MUST set these bits to zero when sending and MUST ignore them when receiving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留七位字段cres；实现在发送时必须将这些位设置为零，在接收时必须忽略它们。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the rekey field is described in Section 3.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3.8节描述了密钥字段的使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Plaintext
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. 明文
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ciphertext field is the result of applying the negotiated authenticated-encryption algorithm to a plaintext value, which has one of these two formats:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密文字段是将协商认证加密算法应用于明文值的结果，明文值具有以下两种格式之一：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte   0       1               plen-1
             +-------+-------+---...---+-------+
             | flags |           data          |
             +-------+-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte   0       1               plen-1
             +-------+-------+---...---+-------+
             | flags |           data          |
             +-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte   0       1       2       3               plen-1
             +-------+-------+-------+-------+---...---+-------+
             | flags |    urgent     |          data           |
             +-------+-------+-------+-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte   0       1       2       3               plen-1
             +-------+-------+-------+-------+---...---+-------+
             | flags |    urgent     |          data           |
             +-------+-------+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(Note that clen in the previous section will generally be greater than plen, as the ciphertext produced by the authenticated-encryption scheme both encrypts the application data and provides redundancy with which to verify its integrity.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（请注意，上一节中的clen通常大于plen，因为通过身份验证的加密方案生成的密文既加密了应用程序数据，又提供了冗余以验证其完整性。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The flags field has this structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flags字段具有以下结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               bit    7    6    5    4    3    2    1    0
                   +----+----+----+----+----+----+----+----+
                   |            fres             |URGp|FINp|
                   +----+----+----+----+----+----+----+----+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               bit    7    6    5    4    3    2    1    0
                   +----+----+----+----+----+----+----+----+
                   |            fres             |URGp|FINp|
                   +----+----+----+----+----+----+----+----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The six-bit field fres is reserved; implementations MUST set these six bits to zero when sending, and MUST ignore them when receiving.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留六位场fres；实现在发送时必须将这六位设置为零，在接收时必须忽略它们。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the URGp bit is set, it indicates that the urgent field is present, and thus that the plaintext value has the second structure variant above; otherwise, the first variant is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当设置URGp位时，它指示存在紧急字段，因此明文值具有上述第二结构变量；否则，将使用第一种变体。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the urgent field and of the flag bits is described in Section 3.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3.7节描述了紧急字段和标志位的含义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Associated Data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 关联数据
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An encryption frame&#39;s associated data (which is supplied to the AEAD algorithm when decrypting the ciphertext and verifying the frame&#39;s integrity) has this format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加密帧的关联数据（在解密密文和验证帧的完整性时提供给AEAD算法）具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       byte   0       1       2
                          +-------+-------+-------+
                          |control|     clen      |
                          +-------+-------+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       byte   0       1       2
                          +-------+-------+-------+
                          |control|     clen      |
                          +-------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It contains the same values as the frame&#39;s control and clen fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
它包含与帧的控件和clen字段相同的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. Frame ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3. 帧ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, a frame ID (used to construct the nonce for the AEAD algorithm) has this format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，帧ID（用于构造AEAD算法的nonce）具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte  0            ae_nonce_len - 8    ae_nonce_len - 1
                |                   |             |
                v                   v             v
             +-----+--...--+-----+-----+--...--+-----+
             |  0  |       |  0  |       offset      |
             +-----+--...--+-----+-----+--...--+-----+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          byte  0            ae_nonce_len - 8    ae_nonce_len - 1
                |                   |             |
                v                   v             v
             +-----+--...--+-----+-----+--...--+-----+
             |  0  |       |  0  |       offset      |
             +-----+--...--+-----+-----+--...--+-----+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 8-byte offset field contains an integer in big-endian format. Its value is specified in Section 3.6. Zero-valued bytes are prepended to the offset field to form a structure of length ae_nonce_len.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8字节偏移量字段包含一个大端格式的整数。其值在第3.6节中规定。零值字节在偏移量字段前面，以形成长度为ae_nonce_len的结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Constant Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 定值
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The table below defines values for the constants used in the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下表定义了协议中使用的常数值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       +------------+--------------+
                       | Value      | Name         |
                       +------------+--------------+
                       | 0x01       | CONST_NEXTK  |
                       | 0x02       | CONST_SESSID |
                       | 0x03       | CONST_REKEY  |
                       | 0x04       | CONST_KEY_A  |
                       | 0x05       | CONST_KEY_B  |
                       | 0x06       | CONST_RESUME |
                       | 0x15101a0e | INIT1_MAGIC  |
                       | 0x097105e0 | INIT2_MAGIC  |
                       +------------+--------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       +------------+--------------+
                       | Value      | Name         |
                       +------------+--------------+
                       | 0x01       | CONST_NEXTK  |
                       | 0x02       | CONST_SESSID |
                       | 0x03       | CONST_REKEY  |
                       | 0x04       | CONST_KEY_A  |
                       | 0x05       | CONST_KEY_B  |
                       | 0x06       | CONST_RESUME |
                       | 0x15101a0e | INIT1_MAGIC  |
                       | 0x097105e0 | INIT2_MAGIC  |
                       +------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
Table 1: Constant Values Used in the Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
表1：协议中使用的常量值
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Key-Agreement Schemes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 密钥协议方案
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TEP negotiated via TCP-ENO indicates the use of one of the key-agreement schemes named in Table 4 in Section 7. For example, TCPCRYPT_ECDHE_P256 names the tcpcrypt protocol using ECDHE-P256 together with the CPRF and length parameters specified below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过TCP-ENO协商的TEP表明使用了第7节表4中指定的一个关键协议方案。例如，TCPCRYPT_ECDHE_P256使用ECDHE-P256以及下面指定的CPRF和长度参数命名TCPCRYPT协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the TEPs specified in this document require the use of HKDF-Expand-SHA256 as the CPRF, and these lengths for nonces and session secrets:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中规定的所有TEP都要求使用HKDF-Expand-SHA256作为CPRF，并且这些长度用于非当前值和会话机密：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
N_A_LEN: 32 bytes N_B_LEN: 32 bytes K_LEN: 32 bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
N_A_LEN:32字节N_B_LEN:32字节K_LEN:32字节
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future documents assigning additional TEPs for use with tcpcrypt might specify different values for the lengths above. Note that the minimum session ID length specified by TCP-ENO, together with the way tcpcrypt constructs session IDs, implies that K_LEN MUST have length at least 32 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将来分配额外TEP用于tcpcrypt的文档可能会为上述长度指定不同的值。请注意，TCP-ENO指定的最小会话ID长度以及tcpcrypt构造会话ID的方式意味着K_LEN的长度必须至少为32字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key-agreement schemes ECDHE-P256 and ECDHE-P521 employ the Elliptic Curve Secret Value Derivation Primitive, Diffie-Hellman version
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密钥协商方案ECDHE-P256和ECDHE-P521采用椭圆曲线秘密值推导原语Diffie-Hellman版本
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(ECSVDP-DH) defined in [IEEE-1363]. The named curves are defined in [NIST-DSS]. When the public-key values Pub_A and Pub_B are transmitted as described in Section 4.1, they are encoded with the &#34;Elliptic Curve Point to Octet String Conversion Primitive&#34; described in Section E.2.3 of [IEEE-1363] and are prefixed by a two-byte length in big-endian format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ECSVDP-DH）定义见[IEEE-1363]。命名曲线在[NIST-DSS]中定义。当按照第4.1节所述传输公钥值Pub_A和Pub_B时，它们使用[IEEE-1363]第E.2.3节所述的“椭圆曲线点到八位字符串转换原语”进行编码，并以大端格式的两字节长度作为前缀：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              byte   0       1       2               L - 1
                 +-------+-------+-------+---...---+-------+
                 |   pubkey_len  |          pubkey         |
                 |      = L      |                         |
                 +-------+-------+-------+---...---+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              byte   0       1       2               L - 1
                 +-------+-------+-------+---...---+-------+
                 |   pubkey_len  |          pubkey         |
                 |      = L      |                         |
                 +-------+-------+-------+---...---+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST encode these pubkey values in &#34;compressed format&#34;. Implementations MUST validate these pubkey values according to the algorithm in Section A.16.10 of [IEEE-1363].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现必须以“压缩格式”对这些pubkey值进行编码。实施必须根据[IEEE-1363]第A.16.10节中的算法验证这些公钥值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key-agreement schemes ECDHE-Curve25519 and ECDHE-Curve448 perform the Diffie-Hellman protocol using the functions X25519 and X448, respectively. Implementations SHOULD compute these functions using the algorithms described in [RFC7748]. When they do so, implementations MUST check whether the computed Diffie-Hellman shared secret is the all-zero value and abort if so, as described in Section 6 of [RFC7748]. Alternative implementations of these functions SHOULD abort when either input forces the shared secret to one of a small set of values as discussed in Section 7 of [RFC7748].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密钥协商方案ECDHE-Curve25519和ECDHE-Curve448分别使用函数X25519和X448执行Diffie-Hellman协议。实现应使用[RFC7748]中描述的算法计算这些函数。当他们这样做时，实现必须检查计算的Diffie-Hellman共享机密是否为全零值，如果是，则中止，如[RFC7748]第6节所述。如[RFC7748]第7节所述，当任一输入将共享机密强制为一小组值之一时，这些函数的替代实现应中止。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For these schemes, public-key values Pub_A and Pub_B are transmitted directly with no length prefix: 32 bytes for ECDHE-Curve25519 and 56 bytes for ECDHE-Curve448.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于这些方案，公钥值Pub_A和Pub_B直接传输，没有长度前缀：ECDHE-curve2519为32字节，ECDHE-Curve448为56字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 2 below specifies the requirement levels of the four TEPs specified in this document. In particular, all implementations of tcpcrypt MUST support TCPCRYPT_ECDHE_Curve25519. However, system administrators MAY configure which TEPs a host will negotiate independent of these implementation requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下表2规定了本文件中规定的四个TEP的要求级别。特别是，tcpcrypt的所有实现必须支持tcpcrypt_ECDHE_Curve25519。但是，系统管理员可以独立于这些实现要求来配置主机将协商的TEP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                +-------------+---------------------------+
                | Requirement | TEP                       |
                +-------------+---------------------------+
                | REQUIRED    | TCPCRYPT_ECDHE_Curve25519 |
                | RECOMMENDED | TCPCRYPT_ECDHE_Curve448   |
                | OPTIONAL    | TCPCRYPT_ECDHE_P256       |
                | OPTIONAL    | TCPCRYPT_ECDHE_P521       |
                +-------------+---------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                +-------------+---------------------------+
                | Requirement | TEP                       |
                +-------------+---------------------------+
                | REQUIRED    | TCPCRYPT_ECDHE_Curve25519 |
                | RECOMMENDED | TCPCRYPT_ECDHE_Curve448   |
                | OPTIONAL    | TCPCRYPT_ECDHE_P256       |
                | OPTIONAL    | TCPCRYPT_ECDHE_P521       |
                +-------------+---------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Table 2: Requirements for Implementation of TEPs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
表2：执行TEPs的要求
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. AEAD Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. AEAD算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses sym_cipher identifiers in the messages Init1 and Init2 (see Section 3.3) to negotiate the use of AEAD algorithms; the values of these identifiers are given in Table 5 in Section 7. The algorithms AEAD_AES_128_GCM and AEAD_AES_256_GCM are specified in [RFC5116]. The algorithm AEAD_CHACHA20_POLY1305 is specified in [RFC8439].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件使用消息Init1和Init2（见第3.3节）中的sym_密码标识符协商AEAD算法的使用；第7节表5给出了这些标识符的值。[RFC5116]中规定了AEAD_AES_128_GCM和AEAD_AES_256_GCM算法。[RFC8439]中规定了算法AEAD_CHACHA20_POLY1305。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations MUST support certain AEAD algorithms according to Table 3. Note that system administrators MAY configure which algorithms a host will negotiate independently of these requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据表3，实现必须支持某些AEAD算法。请注意，系统管理员可以配置主机将独立于这些要求协商的算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, this document uses the lengths ae_key_len and ae_nonce_len to specify aspects of encryption and data formats. These values depend on the negotiated AEAD algorithm, also according to the table below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，本文档使用长度ae_key_len和ae_nonce_len来指定加密和数据格式的各个方面。根据下表，这些值取决于协商的AEAD算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +------------------------+-------------+------------+--------------+
   | AEAD Algorithm         | Requirement | ae_key_len | ae_nonce_len |
   +------------------------+-------------+------------+--------------+
   | AEAD_AES_128_GCM       | REQUIRED    | 16 bytes   | 12 bytes     |
   | AEAD_AES_256_GCM       | RECOMMENDED | 32 bytes   | 12 bytes     |
   | AEAD_CHACHA20_POLY1305 | RECOMMENDED | 32 bytes   | 12 bytes     |
   +------------------------+-------------+------------+--------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +------------------------+-------------+------------+--------------+
   | AEAD Algorithm         | Requirement | ae_key_len | ae_nonce_len |
   +------------------------+-------------+------------+--------------+
   | AEAD_AES_128_GCM       | REQUIRED    | 16 bytes   | 12 bytes     |
   | AEAD_AES_256_GCM       | RECOMMENDED | 32 bytes   | 12 bytes     |
   | AEAD_CHACHA20_POLY1305 | RECOMMENDED | 32 bytes   | 12 bytes     |
   +------------------------+-------------+------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Table 3: Requirement and Lengths for Each AEAD Algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
表3：每个AEAD算法的要求和长度
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. IANA考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For use with TCP-ENO&#39;s negotiation mechanism, tcpcrypt&#39;s TEP identifiers have been incorporated in IANA&#39;s &#34;TCP Encryption Protocol Identifiers&#34; registry under the &#34;Transmission Control Protocol (TCP) Parameters&#34; registry, as in Table 4. The various key-agreement schemes used by these tcpcrypt variants are defined in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了与TCP-ENO的协商机制一起使用，tcpcrypt的TEP标识符已并入IANA的“传输控制协议（TCP）参数”注册表下的“TCP加密协议标识符”注册表中，如表4所示。第5节定义了这些tcpcrypt变体使用的各种密钥协议方案。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             +-------+---------------------------+-----------+
             | Value | Meaning                   | Reference |
             +-------+---------------------------+-----------+
             | 0x21  | TCPCRYPT_ECDHE_P256       | [RFC8548] |
             | 0x22  | TCPCRYPT_ECDHE_P521       | [RFC8548] |
             | 0x23  | TCPCRYPT_ECDHE_Curve25519 | [RFC8548] |
             | 0x24  | TCPCRYPT_ECDHE_Curve448   | [RFC8548] |
             +-------+---------------------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             +-------+---------------------------+-----------+
             | Value | Meaning                   | Reference |
             +-------+---------------------------+-----------+
             | 0x21  | TCPCRYPT_ECDHE_P256       | [RFC8548] |
             | 0x22  | TCPCRYPT_ECDHE_P521       | [RFC8548] |
             | 0x23  | TCPCRYPT_ECDHE_Curve25519 | [RFC8548] |
             | 0x24  | TCPCRYPT_ECDHE_Curve448   | [RFC8548] |
             +-------+---------------------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Table 4: TEP Identifiers for Use with tcpcrypt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
表4:tcpcrypt使用的TEP标识符
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Section 6, this document defines the use of several AEAD algorithms for encrypting application data. To name these
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第6节中，本文档定义了几种AEAD算法用于加密应用程序数据。命名这些
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
algorithms, the tcpcrypt protocol uses two-byte identifiers in the range 0x0001 to 0xFFFF, inclusively, for which IANA maintains a new &#34;tcpcrypt AEAD Algorithms&#34; registry under the &#34;Transmission Control Protocol (TCP) Parameters&#34; registry. The initial values for this registry are given in Table 5. Future assignments are to be made upon satisfying either of two policies defined in [RFC8126]: &#34;IETF Review&#34; or (for non-IETF stream specifications) &#34;Expert Review with RFC Required.&#34; IANA will furthermore provide early allocation [RFC7120] to facilitate testing before RFCs are finalized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
算法，tcpcrypt协议使用0x0001到0xFFFF范围内的两个字节标识符，IANA在“传输控制协议（TCP）参数”注册表下为其维护一个新的“tcpcrypt AEAD算法”注册表。表5给出了该注册表的初始值。未来的任务将在满足[RFC8126]中定义的两项政策中的一项后进行：“IETF审查”或（对于非IETF流规范）“需要RFC的专家审查”。IANA还将提供早期分配[RFC7120]，以便于在RFC最终确定之前进行测试。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        +--------+------------------------+----------------------+
        | Value  | AEAD Algorithm         | Reference            |
        +--------+------------------------+----------------------+
        | 0x0001 | AEAD_AES_128_GCM       | [RFC8548], Section 6 |
        | 0x0002 | AEAD_AES_256_GCM       | [RFC8548], Section 6 |
        | 0x0010 | AEAD_CHACHA20_POLY1305 | [RFC8548], Section 6 |
        +--------+------------------------+----------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        +--------+------------------------+----------------------+
        | Value  | AEAD Algorithm         | Reference            |
        +--------+------------------------+----------------------+
        | 0x0001 | AEAD_AES_128_GCM       | [RFC8548], Section 6 |
        | 0x0002 | AEAD_AES_256_GCM       | [RFC8548], Section 6 |
        | 0x0010 | AEAD_CHACHA20_POLY1305 | [RFC8548], Section 6 |
        +--------+------------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
Table 5: Authenticated-Encryption Algorithms for Use with tcpcrypt
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
表5:tcpcrypt使用的认证加密算法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the security considerations of TCP-ENO apply to tcpcrypt. In particular, tcpcrypt does not protect against active network attackers unless applications authenticate the session ID. If it can be established that the session IDs computed at each end of the connection match, then tcpcrypt guarantees that no man-in-the-middle attacks occurred unless the attacker has broken the underlying cryptographic primitives, e.g., Elliptic Curve Diffie-Hellman (ECDH). A proof of this property for an earlier version of the protocol has been published [tcpcrypt].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP-ENO的所有安全注意事项都适用于tcpcrypt。特别是，除非应用程序对会话ID进行身份验证，否则tcpcrypt不会防止主动网络攻击者。如果可以确定在连接的每一端计算的会话ID匹配，然后，tcpcrypt保证不会发生中间人攻击，除非攻击者破坏了底层加密原语，例如椭圆曲线Diffie-Hellman（ECDH）。已发布协议早期版本的此属性证明[tcpcrypt]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure middlebox compatibility, tcpcrypt does not protect TCP headers. Therefore, the protocol is vulnerable to denial-of-service from off-path attackers just as plain TCP is. Possible attacks include desynchronizing the underlying TCP stream, injecting RST or FIN segments, and forging rekey bits. These attacks will cause a tcpcrypt connection to hang or fail with an error, but not in any circumstance where plain TCP could continue uncorrupted. Implementations MUST give higher-level software a way to distinguish such errors from a clean end-of-stream (indicated by an authenticated FINp bit) so that applications can avoid semantic truncation attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了确保中间盒兼容性，tcpcrypt不保护TCP头。因此，与普通TCP一样，该协议也容易受到非路径攻击者的拒绝服务攻击。可能的攻击包括取消底层TCP流的同步、注入RST或FIN段以及伪造密钥位。这些攻击将导致tcpcrypt连接挂起或失败并出现错误，但在任何情况下，普通TCP都无法继续正常运行。实现必须为高级软件提供一种方法，将此类错误与干净的流端（由经过身份验证的FINp位指示）区分开来，以便应用程序能够避免语义截断攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no &#34;key confirmation&#34; step in tcpcrypt. This is not needed because tcpcrypt&#39;s threat model includes the possibility of a connection to an adversary. If key negotiation is compromised and yields two different keys, failed integrity checks on every subsequent frame will cause the connection either to hang or to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
tcpcrypt中没有“密钥确认”步骤。这是不必要的，因为tcpcrypt的威胁模型包括与对手连接的可能性。如果密钥协商被破坏并产生两个不同的密钥，则在每个后续帧上失败的完整性检查将导致连接挂起或中断
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
abort. This is not a new threat as an active attacker can achieve the same results against a plain TCP connection by injecting RST segments or modifying sequence and acknowledgement numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中止这不是一个新的威胁，因为主动攻击者可以通过注入RST段或修改序列号和确认号来获得与普通TCP连接相同的结果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt uses short-lived public keys to provide forward secrecy; once an implementation removes these keys from memory, a compromise of the system will not provide any means to derive the session secrets for past connections. All currently-specified key agreement schemes involve key agreement based on Ephemeral Elliptic Curve Diffie-Hellman (ECDHE), meaning a new key pair can be efficiently computed for each connection. If implementations reuse these parameters, they MUST limit the lifetime of the private parameters as far as is practical in order to minimize the number of past connections that are vulnerable. Of course, placing private keys in persistent storage introduces severe risks that they will not be destroyed reliably and in a timely fashion, and it SHOULD be avoided whenever possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt使用短期公钥提供前向保密性；一旦实现从内存中删除这些密钥，系统的折衷方案将无法提供任何方法来获取过去连接的会话机密。目前所有指定的密钥协商方案都涉及基于瞬时椭圆曲线Diffie-Hellman（ECDHE）的密钥协商，这意味着可以为每个连接高效地计算新的密钥对。如果实现重用这些参数，那么它们必须尽可能地限制私有参数的生存期，以尽量减少易受攻击的过去连接的数量。当然，将私钥放置在持久性存储中会带来严重的风险，即它们不会被可靠及时地销毁，因此应尽可能避免。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attackers cannot force passive openers to move forward in their session resumption chain without guessing the content of the resumption identifier, which will be difficult without key knowledge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻击者无法强迫被动开启者在会话恢复链中向前移动而不猜测恢复标识符的内容，如果没有关键知识，这将很困难。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cipher-suites specified in this document all use HMAC-SHA256 to implement the collision-resistant pseudo-random function denoted by CPRF. A collision-resistant function is one for which, for sufficiently large L, an attacker cannot find two distinct inputs (K_1, CONST_1) and (K_2, CONST_2) such that CPRF(K_1, CONST_1, L) = CPRF(K_2, CONST_2, L). Collision resistance is important to assure the uniqueness of session IDs, which are generated using the CPRF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档中指定的密码套件都使用HMAC-SHA256来实现由CPRF表示的抗冲突伪随机函数。抗冲突函数是指，对于足够大的L，攻击者无法找到两个不同的输入（K_1，CONST_1）和（K_2，CONST_2），使得CPRF（K_1，CONST_1，L）=CPRF（K_2，CONST_2，L）。冲突抵抗对于确保使用CPRF生成的会话ID的唯一性非常重要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, many of tcpcrypt&#39;s cryptographic functions require random input, and thus any host implementing tcpcrypt MUST have access to a cryptographically-secure source of randomness or pseudo-randomness. [RFC4086] provides recommendations on how to achieve this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，tcpcrypt的许多加密函数需要随机输入，因此任何实现tcpcrypt的主机都必须能够访问加密安全的随机性或伪随机性源。[RFC4086]提供了如何实现这一目标的建议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most implementations will rely on a device&#39;s pseudo-random generator, seeded from hardware events and a seed carried over from the previous boot. Once a pseudo-random generator has been properly seeded, it can generate effectively arbitrary amounts of pseudo-random data. However, until a pseudo-random generator has been seeded with sufficient entropy, not only will tcpcrypt be insecure, it will reveal information that further weakens the security of the pseudo-random generator, potentially harming other applications. As REQUIRED by TCP-ENO, implementations MUST NOT send ENO options unless they have access to an adequate source of randomness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大多数实现将依赖于设备的伪随机生成器，该生成器是从硬件事件和上一次引导时遗留下来的种子生成的。一旦对伪随机生成器进行了适当的种子设定，它就可以有效地生成任意数量的伪随机数据。但是，除非伪随机生成器具有足够的熵，否则tcpcrypt不仅不安全，而且还会泄露进一步削弱伪随机生成器安全性的信息，可能会损害其他应用程序。按照TCP-ENO的要求，除非实现能够访问足够的随机性源，否则它们不得发送ENO选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Asymmetric Roles
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 不对称角色
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt transforms a shared pseudo-random key (PRK) into cryptographic traffic keys for each direction. Doing so requires an asymmetry in the protocol, as the key derivation function must be perturbed differently to generate different keys in each direction. Tcpcrypt includes other asymmetries in the roles of the two hosts, such as the process of negotiating algorithms (e.g., proposing vs. selecting cipher suites).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tcpcrypt将共享伪随机密钥（PRK）转换为每个方向的加密通信密钥。这样做需要协议中的不对称性，因为密钥派生函数必须受到不同的扰动，才能在每个方向上生成不同的密钥。Tcpcrypt包括两个主机角色中的其他不对称性，例如协商算法的过程（例如，提出与选择密码套件）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Verified Liveness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 证实的活性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many hosts implement TCP keep-alives [RFC1122] as an option for applications to ensure that the other end of a TCP connection still exists even when there is no data to be sent. A TCP keep-alive segment carries a sequence number one prior to the beginning of the send window and may carry one byte of &#34;garbage&#34; data. Such a segment causes the remote side to send an acknowledgment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
许多主机将TCP keep alives[RFC1122]作为应用程序的一个选项来实现，以确保即使在没有要发送的数据时，TCP连接的另一端仍然存在。TCP保持活动段在发送窗口开始之前携带一个序列号1，并且可能携带一个字节的“垃圾”数据。这样的段会导致远程端发送确认。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unfortunately, tcpcrypt cannot cryptographically verify keep-alive acknowledgments. Therefore, an attacker could prolong the existence of a session at one host after the other end of the connection no longer exists. (Such an attack might prevent a process with sensitive data from exiting, giving an attacker more time to compromise a host and extract the sensitive data.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不幸的是，tcpcrypt无法以加密方式验证保持活动状态确认。因此，在连接的另一端不再存在后，攻击者可以延长一台主机上会话的存在时间。（此类攻击可能会阻止包含敏感数据的进程退出，从而使攻击者有更多时间危害主机并提取敏感数据。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To counter this threat, tcpcrypt specifies a way to stimulate the remote host to send verifiably fresh and authentic data, described in Section 3.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了应对这种威胁，tcpcrypt指定了一种方法来刺激远程主机发送可验证的新数据和真实数据，如第3.9节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP keep-alive mechanism has also been used for its effects on intermediate nodes in the network, such as preventing flow state from expiring at NAT boxes or firewalls. As these purposes do not require the authentication of endpoints, implementations MAY safely accomplish them using either the existing TCP keep-alive mechanism or tcpcrypt&#39;s verified keep-alive mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP保持活动机制还用于对网络中的中间节点产生影响，例如防止流状态在NAT盒或防火墙处过期。由于这些目的不需要对端点进行身份验证，实现可以使用现有的TCP保持活动机制或tcpcrypt的验证保持活动机制安全地完成这些目的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. Mandatory Key-Agreement Schemes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3. 强制性密钥协议方案
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document mandates that tcpcrypt implementations provide support for at least one key-agreement scheme: ECDHE using Curve25519. This choice of a single mandatory algorithm is the result of a difficult tradeoff between cryptographic diversity and the ease and security of actual deployment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档要求tcpcrypt实现至少支持一个密钥协议方案：使用Curve2519的ECDHE。选择单一强制算法是在加密多样性与实际部署的易用性和安全性之间进行艰难权衡的结果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF&#39;s appraisal of best current practice on this matter [RFC7696] says, &#34;Ideally, two independent sets of mandatory-to-implement algorithms will be specified, allowing for a primary suite
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对这方面最佳实践的评估[RFC7696]说，“理想情况下，将指定两套独立的强制算法来实现算法，允许一个主套件
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and a secondary suite. This approach ensures that the secondary suite is widely deployed if a flaw is found in the primary one.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还有一套二级套房。这种方法可确保在主套件中发现缺陷时广泛部署辅助套件。”
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To meet that ideal, it might appear natural to also mandate ECDHE using P-256. However, implementing the Diffie-Hellman function using NIST elliptic curves (including those specified for use with tcpcrypt, P-256 and P-521) appears to be very difficult to achieve without introducing vulnerability to side-channel attacks [NIST-fail]. Although well-trusted implementations are available as part of large cryptographic libraries, these can be difficult to extract for use in operating-system kernels where tcpcrypt is usually best implemented. In contrast, the characteristics of Curve25519 together with its recent popularity has led to many safe and efficient implementations, including some that fit naturally into the kernel environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了实现这一理想，还要求ECDHE使用P-256似乎很自然。然而，使用NIST椭圆曲线（包括指定用于tcpcrypt、P-256和P-521的椭圆曲线）实现Diffie-Hellman函数，如果不引入侧通道攻击漏洞，似乎很难实现[NIST失败]。尽管可靠的实现可以作为大型加密库的一部分使用，但在通常实现tcpcrypt的操作系统内核中，很难提取这些实现以供使用。相比之下，Curve25519的特性及其最近的流行已经导致了许多安全高效的实现，包括一些自然适合内核环境的实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696] insists that, &#34;The selected algorithms need to be resistant to side-channel attacks and also meet the performance, power, and code size requirements on a wide variety of platforms.&#34; On this principle, tcpcrypt excludes the NIST curves from the set of mandatory-to-implement key-agreement algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696]坚持认为，“所选算法需要抵抗旁道攻击，并满足各种平台上的性能、功率和代码大小要求。”根据这一原则，tcpcrypt将NIST曲线排除在强制实施密钥协商算法的集合之外。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lastly, this document encourages support for key agreement with Curve448, categorizing it as RECOMMENDED. Curve448 appears likely to admit safe and efficient implementations. However, support is not REQUIRED because existing implementations might not yet be sufficiently well proven.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，本文档鼓励支持Curve448的关键协议，并按建议对其进行分类。Curve448似乎很可能允许安全高效的实现。然而，不需要支持，因为现有的实现可能还没有得到充分的验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Experiments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 实验
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some experience will be required to determine whether the tcpcrypt protocol can be deployed safely and successfully across the diverse environments of the global internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
需要一些经验来确定tcpcrypt协议是否可以在全球互联网的不同环境中安全成功地部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Safety means that TCP implementations that support tcpcrypt are able to communicate reliably in all the same settings as they would without tcpcrypt. As described in Section 9 of [RFC8547], this property can be subverted if middleboxes strip ENO options from non-SYN segments after allowing them in SYN segments, or if the particular communication patterns of tcpcrypt offend the policies of middleboxes doing deep-packet inspection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全性意味着支持tcpcrypt的TCP实现能够在所有相同的设置下可靠地通信，就像在没有tcpcrypt的情况下一样。如[RFC8547]第9节所述，如果在SYN段中允许非SYN段中的ENO选项后，中间盒从非SYN段中剥离ENO选项，或者如果tcpcrypt的特定通信模式违反了进行深度数据包检查的中间盒的策略，则此属性可能被破坏。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Success, in addition to safety, means hosts that implement tcpcrypt actually enable encryption when connecting to one another. This property depends on the network&#39;s treatment of the TCP-ENO handshake and can be subverted if middleboxes merely strip unknown TCP options or terminate TCP connections and relay data back and forth unencrypted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了安全之外，成功还意味着实现tcpcrypt的主机在相互连接时实际上启用了加密。此属性取决于网络对TCP-ENO握手的处理方式，如果中间盒仅剥离未知的TCP选项或终止TCP连接并在未加密的情况下来回中继数据，则此属性可能会被破坏。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ease of implementation will be a further challenge to deployment. Because tcpcrypt requires encryption operations on frames that may span TCP segments, kernel implementations are forced to buffer segments in different ways than are necessary for plain TCP. More implementation experience will show how much additional code complexity is required in various operating systems and what kind of performance effects can be expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
易于实施将是对部署的进一步挑战。由于tcpcrypt需要对可能跨越TCP段的帧执行加密操作，因此内核实现被迫以不同于普通TCP所需的方式缓冲段。更多的实现经验将显示在各种操作系统中需要多少额外的代码复杂性，以及可以预期的性能影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE-1363] IEEE, &#34;IEEE Standard Specifications for Public-Key Cryptography&#34;, IEEE Standard 1363-2000, DOI 10.1109/IEEESTD.2000.92292.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IEEE-1363]IEEE，“IEEE公钥加密标准规范”，IEEE标准1363-2000，DOI 10.1109/IEEESTD.2000.92292。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST-DSS] National Institute of Standards and Technology (NIST), &#34;Digital Signature Standard (DSS)&#34;, FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST-DSS]国家标准与技术研究所（NIST），“数字签名标准（DSS）”，FIPS PUB 186-4，DOI 10.6028/NIST.FIPS.186-42013年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, &lt;https://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]Postel，J.，“传输控制协议”，标准7，RFC 793，DOI 10.17487/RFC0793，1981年9月&lt;https://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, DOI 10.17487/RFC2018, October 1996, &lt;https://www.rfc-editor.org/info/rfc2018&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018]Mathis，M.，Mahdavi，J.，Floyd，S.，和A.Romanow，“TCP选择性确认选项”，RFC 2018，DOI 10.17487/RFC2018，1996年10月&lt;https://www.rfc-editor.org/info/rfc2018&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication&#34;, RFC 2104, DOI 10.17487/RFC2104, February 1997, &lt;https://www.rfc-editor.org/info/rfc2104&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2104]Krawczyk，H.，Bellare，M.，和R.Canetti，“HMAC：用于消息认证的键控哈希”，RFC 2104，DOI 10.17487/RFC2104，1997年2月&lt;https://www.rfc-editor.org/info/rfc2104&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，DOI 10.17487/RFC2119，1997年3月&lt;https://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5116] McGrew, D., &#34;An Interface and Algorithms for Authenticated Encryption&#34;, RFC 5116, DOI 10.17487/RFC5116, January 2008, &lt;https://www.rfc-editor.org/info/rfc5116&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5116]McGrew，D.“认证加密的接口和算法”，RFC 5116，DOI 10.17487/RFC5116，2008年1月&lt;https://www.rfc-editor.org/info/rfc5116&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5869] Krawczyk, H. and P. Eronen, &#34;HMAC-based Extract-and-Expand Key Derivation Function (HKDF)&#34;, RFC 5869, DOI 10.17487/RFC5869, May 2010, &lt;https://www.rfc-editor.org/info/rfc5869&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5869]Krawczyk，H.和P.Eronen，“基于HMAC的提取和扩展密钥派生函数（HKDF）”，RFC 5869，DOI 10.17487/RFC5869，2010年5月&lt;https://www.rfc-editor.org/info/rfc5869&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7120] Cotton, M., &#34;Early IANA Allocation of Standards Track Code Points&#34;, BCP 100, RFC 7120, DOI 10.17487/RFC7120, January 2014, &lt;https://www.rfc-editor.org/info/rfc7120&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7120]Cotton，M.，“标准轨道代码点的早期IANA分配”，BCP 100，RFC 7120，DOI 10.17487/RFC7120，2014年1月&lt;https://www.rfc-editor.org/info/rfc7120&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7748] Langley, A., Hamburg, M., and S. Turner, &#34;Elliptic Curves for Security&#34;, RFC 7748, DOI 10.17487/RFC7748, January 2016, &lt;https://www.rfc-editor.org/info/rfc7748&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7748]兰利，A.，汉堡，M.和S.特纳，“安全的椭圆曲线”，RFC 7748，DOI 10.17487/RFC7748，2016年1月&lt;https://www.rfc-editor.org/info/rfc7748&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8126] Cotton, M., Leiba, B., and T. Narten, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, &lt;https://www.rfc-editor.org/info/rfc8126&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8126]Cotton，M.，Leiba，B.，和T.Narten，“在RFC中编写IANA考虑事项部分的指南”，BCP 26，RFC 8126，DOI 10.17487/RFC8126，2017年6月&lt;https://www.rfc-editor.org/info/rfc8126&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174] Leiba, B., &#34;Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words&#34;, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, &lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8174]Leiba，B.，“RFC 2119关键词中大写与小写的歧义”，BCP 14，RFC 8174，DOI 10.17487/RFC8174，2017年5月&lt;https://www.rfc-editor.org/info/rfc8174&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8439] Nir, Y. and A. Langley, &#34;ChaCha20 and Poly1305 for IETF Protocols&#34;, RFC 8439, DOI 10.17487/RFC8439, June 2018, &lt;https://www.rfc-editor.org/info/rfc8439&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8439]Nir，Y.和A.Langley，“IETF协议的ChaCha20和Poly1305”，RFC 8439，DOI 10.17487/RFC8439，2018年6月&lt;https://www.rfc-editor.org/info/rfc8439&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8547] Bittau, A., Giffin, D., Handley, M., Mazieres, D., and E. Smith, &#34;TCP-ENO: Encryption Negotiation Option&#34;, RFC 8547, DOI 10.17487/RFC8547, May 2019, &lt;https://www.rfc-editor.org/info/rfc8547&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8547]Bittau，A.，Giffin，D.，Handley，M.，Mazieres，D.，和E.Smith，“TCP-ENO：加密协商选项”，RFC 8547，DOI 10.17487/RFC8547，2019年5月&lt;https://www.rfc-editor.org/info/rfc8547&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST-fail] Bernstein, D. and T. Lange, &#34;Failures in NIST&#39;s ECC Standards&#34;, January 2016, &lt;https://cr.yp.to/newelliptic/nistecc-20160106.pdf&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[NIST失败]Bernstein，D.和T.Lange，“NIST ECC标准的失败”，2016年1月&lt;https://cr.yp.to/newelliptic/nistecc-20160106.pdf&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, &lt;https://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]Braden，R.，Ed.“互联网主机的要求-通信层”，STD 3，RFC 1122，DOI 10.17487/RFC1122，1989年10月&lt;https://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, &lt;https://www.rfc-editor.org/info/rfc4086&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086]Eastlake 3rd，D.，Schiller，J.，和S.Crocker，“安全的随机性要求”，BCP 106，RFC 4086，DOI 10.17487/RFC4086，2005年6月&lt;https://www.rfc-editor.org/info/rfc4086&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696] Housley, R., &#34;Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms&#34;, BCP 201, RFC 7696, DOI 10.17487/RFC7696, November 2015, &lt;https://www.rfc-editor.org/info/rfc7696&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7696]Housley，R.，“加密算法敏捷性和选择强制算法的指南”，BCP 201，RFC 7696，DOI 10.17487/RFC7696，2015年11月&lt;https://www.rfc-editor.org/info/rfc7696&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[tcpcrypt] Bittau, A., Hamburg, M., Handley, M., Mazieres, D., and D. Boneh, &#34;The case for ubiquitous transport-level encryption&#34;, USENIX Security Symposium, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[tcpcrypt]Bittau，A.，Hamburg，M.，Handley，M.，Mazieres，D.，和D.Boneh，“无处不在的传输级加密案例”，USENIX安全研讨会，2010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCPINC-API] Bittau, A., Boneh, D., Giffin, D., Handley, M., Mazieres, D., and E. Smith, &#34;Interface Extensions for TCP-ENO and tcpcrypt&#34;, Work in Progress, draft-ietf-tcpinc-api-06, June 2018.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCPINC-API]Bittau，A.，Boneh，D.，Giffin，D.，Handley，M.，Mazieres，D.，和E.Smith，“TCP-ENO和tcpcrypt的接口扩展”，正在进行的工作，草案-ietf-TCPINC-API-06，2018年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
致谢
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We are grateful for contributions, help, discussions, and feedback from the TCPINC Working Group and from other IETF reviewers, including Marcelo Bagnulo, David Black, Bob Briscoe, Jana Iyengar, Stephen Kent, Tero Kivinen, Mirja Kuhlewind, Yoav Nir, Christoph Paasch, Eric Rescorla, Kyle Rose, and Dale Worley.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们感谢TCPINC工作组和其他IETF评审员的贡献、帮助、讨论和反馈，包括Marcelo Bagnulo、David Black、Bob Briscoe、Jana Iyengar、Stephen Kent、Tero Kivinen、Mirja Kuhlewind、Yoav Nir、Christoph Paasch、Eric Rescorla、Kyle Rose和Dale Worley。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This work was funded by gifts from Intel (to Brad Karp) and from Google; by NSF award CNS-0716806 (A Clean-Slate Infrastructure for Information Flow Control); by DARPA CRASH under contract #N66001-10-2-4088; and by the Stanford Secure Internet of Things Project.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这项工作是由英特尔（Brad Karp）和谷歌（Google）捐赠的；由NSF授予CNS-0716806（信息流控制的全新基础设施）；根据合同#N66001-10-2-4088，由DARPA坠毁；斯坦福安全物联网项目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
贡献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dan Boneh and Michael Hamburg were coauthors of the draft that became this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dan Boneh和Michael Hamburg是成为本文件的草案的共同作者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andrea Bittau Google 345 Spear Street San Francisco, CA 94105 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andrea Bittau Google 345枪街旧金山，CA 94105美利坚合众国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: bittau@google.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: bittau@google.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Daniel B. Giffin Stanford University 353 Serra Mall, Room 288 Stanford, CA 94305 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Daniel B.Giffin斯坦福大学353 Serra Mall，美国加利福尼亚州斯坦福市288室，邮编94305
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: daniel@beech-grove.net
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: daniel@beech-grove.net
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark Handley University College London Gower St. London WC1E 6BT United Kingdom
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
英国马克·汉德利大学学院伦敦高尔街WC1E 6BT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: M.Handley@cs.ucl.ac.uk
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: M.Handley@cs.ucl.ac.uk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Mazieres Stanford University 353 Serra Mall, Room 290 Stanford, CA 94305 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
David Mazieres斯坦福大学353 Serra Mall，290室，美国加利福尼亚州斯坦福94305
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: dm@uun.org
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: dm@uun.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Quinn Slack Sourcegraph 121 2nd St Ste 200 San Francisco, CA 94105 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
奎因松弛SurcCurgScript 121第二ST STE 200旧金山，CA 94105美利坚合众国
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: sqs@sourcegraph.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: sqs@sourcegraph.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eric W. Smith Kestrel Institute 3260 Hillview Avenue Palo Alto, CA 94304 United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eric W.Smith Kestrel研究所美国加利福尼亚州帕洛阿尔托Hillview大道3260号，邮编94304
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: eric.smith@kestrel.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: eric.smith@kestrel.edu
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
