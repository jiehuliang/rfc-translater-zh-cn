<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 3385:  Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations  中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3385</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3385">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 3385:  Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations  中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc3385">
              https://datatracker.ietf.org/doc/html/rfc3385
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 3385</strong></span><br>
          <span class="updated_by">翻译编辑 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                       D. Sheinwald
Request for Comments: 3385                                     J. Satran
Category: Informational                                              IBM
                                                               P. Thaler
                                                              V. Cavanna
                                                                 Agilent
                                                          September 2002
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                       D. Sheinwald
Request for Comments: 3385                                     J. Satran
Category: Informational                                              IBM
                                                               P. Thaler
                                                              V. Cavanna
                                                                 Agilent
                                                          September 2002
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Internet Protocol Small Computer System Interface (iSCSI) Cyclic Redundancy Check (CRC)/Checksum Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Internet协议小型计算机系统接口（iSCSI）循环冗余校验（CRC）/校验和注意事项
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本备忘录的状况
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2002). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2002年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this memo, we attempt to give some estimates for the probability of undetected errors to facilitate the selection of an error detection code for the Internet Protocol Small Computer System Interface (iSCSI).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本备忘录中，我们试图对未检测到的错误的概率进行一些估计，以便于为Internet协议小型计算机系统接口（iSCSI）选择错误检测代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will also attempt to compare Cyclic Redundancy Checks (CRCs) with other checksum forms (e.g., Fletcher, Adler, weighted checksums), as permitted by available data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在可用数据允许的情况下，我们还将尝试将循环冗余校验（CRC）与其他校验和形式（如Fletcher、Adler、加权校验和）进行比较。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cyclic Redundancy Check (CRC) codes [Peterson] are shortened cyclic codes used for error detection. A number of CRC codes have been adopted in standards: ATM, IEC, IEEE, CCITT, IBM-SDLC, and more [Baicheva]. The most important expectation from this kind of code is a very low probability for undetected errors. The probability of undetected errors in such codes has been, and still is, subject to extensive studies that have included both analytical models and simulations. Those codes have been used extensively in communications and magnetic recording as they demonstrate good &#34;burst error&#34; detection capabilities, but are also good at detecting several independent bit errors. Hardware implementations are very simple and well known; their simplicity has made them popular with hardware
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
循环冗余校验（CRC）码[Peterson]是用于错误检测的缩短循环码。许多CRC码已在标准中采用：ATM、IEC、IEEE、CCITT、IBM-SDLC等[Baicheva]。这类代码最重要的期望是未检测到错误的概率非常低。此类代码中未检测到错误的概率一直受到广泛研究的影响，包括分析模型和模拟。这些代码已广泛用于通信和磁记录，因为它们具有良好的“突发错误”检测能力，但也擅长检测多个独立的位错误。硬件实现非常简单且众所周知；它们的简单性使得它们在硬件中很受欢迎
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
developers for many years. However, algorithms and software for effective implementations of CRC are now also widely available [Williams].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
很多年的开发者。然而，有效实现CRC的算法和软件现在也广泛可用[Williams]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probability of undetected errors depends on the polynomial selected to generate the code, the error distribution (error model), and the data length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未检测到错误的概率取决于选择生成代码的多项式、错误分布（错误模型）和数据长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Error Models and Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 错误模型和目标
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will analyze the code behavior under two conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们将在两种情况下分析代码行为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- noisy channel - burst errors with an average length of n bits - low noise channel - independent single bit errors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 噪声信道-平均长度为n位的突发错误-低噪声信道独立的单位错误
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Burst errors are the prevalent natural phenomenon on communication lines and recording media. The numbers quoted for them revolve around the BER (bit error rate). However, those numbers are frequently nothing more than a reflection of the Burst Error Rate multiplied by the average burst length. In field engineering tests, three numbers are usually quoted together -- BER, error-free-seconds and severely-error-seconds; this illustrates our point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
突发错误是通信线路和记录媒体上普遍存在的自然现象。为它们引用的数字围绕着BER（误码率）旋转。然而，这些数字通常只是突发错误率乘以平均突发长度的反映。在现场工程测试中，通常同时引用三个数字——误码率、无错误秒数和严重错误秒数；这说明了我们的观点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even beyond communication and recording media, the effects of errors will be bursty. An example of this is a memory error that will affect more than a single bit and the total effect will not be very different from the communication error, or software errors that occur while manipulating packets will have a burst effect. Software errors also result in burst errors. In addition, serial internal interconnects will make this type of error the most common within machines as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
即使在通信和记录媒体之外，错误的影响也将是突发性的。这方面的一个例子是内存错误，它将影响一个以上的位，并且总体效果与通信错误没有太大区别，或者在操作数据包时发生的软件错误将产生突发效应。软件错误也会导致突发错误。此外，串行内部互连也会使这种类型的错误在机器中最常见。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also analyze the effects of single independent bit errors, since these may be caused by certain defects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们还分析了单个独立位错误的影响，因为这些错误可能是由某些缺陷引起的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On burst, we assume an average burst error duration of bd, which at a given transmission rate s, will result in an average burst of a = bd*s bits. (E.g., an average burst duration of 3 ns at 1Gbs gives an average burst of 3 bits.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在突发情况下，我们假设bd的平均突发错误持续时间，在给定传输速率s下，将导致a=bd*s位的平均突发。（例如，1Gbs的平均突发持续时间为3 ns，则平均突发时间为3位。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the burst error rate, we will take 10^-10. The numbers quoted for BER on wired communication channels are between 10^-10 to 10^-12 and we consider the BER as burst-error-rate*average-burst-length. Nevertheless, please keep in mind that if the channel includes wireless links, the error rates may be substantially higher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于突发错误率，我们将取10^-10。有线通信信道上的误码率为10～10～10 ^ 12，误码率为突发差错率*平均突发长度。然而，请记住，如果信道包括无线链路，则错误率可能会大大提高。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For independent single bit errors, we assume a 10^-11 error rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于独立的单比特错误，我们假设错误率为10^-11。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the error detection mechanisms will have to transport large amounts of data (petabytes=10^16 bits) without errors, we will target very low probabilities for undetected errors for all block lengths (at 10Gb/s that much data can be sent in less than 2 weeks on a single link).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于错误检测机制必须在没有错误的情况下传输大量数据（PB=10^16位），因此我们将针对所有块长度的未检测到错误的概率非常低（在10Gb/s的情况下，许多数据可以在不到2周的时间内在单个链路上发送）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternatively, as iSCSI has to perform efficiently, we will require that the error detection capability of a selected protection mechanism be very good, at least up to block lengths of 8k bytes (64kbits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
或者，由于iSCSI必须高效执行，我们将要求所选保护机制的错误检测能力非常好，至少达到8k字节（64kbits）的块长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The error detection capability should keep the probability of undetected errors at values that would be &#34;next-to-impossible&#34;. We recognize, however, that such attributes are hard to quantify and we resorted to physics. The value 10^23 is the Avogadro number while 10^45 is the number of atoms in the known Universe (or it was many years ago when we read about it) and those are the bounds of incertitude we could live with. (10^-23 at worst and 10^-45 if we can afford it.) For 8k blocks, the per/bit equivalent would be (10^-28 to 10^-50).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误检测能力应将未检测到错误的概率保持在“几乎不可能”的值。然而，我们认识到，这些属性很难量化，我们求助于物理。值10^23是阿伏伽德罗数，而10^45是已知宇宙中的原子数（或者是多年前我们读到它时的原子数），这些是我们可以承受的不确定性的界限。（最坏情况下为10^-23，如果我们负担得起，则为10^-45。）对于8k块，每比特的等效值为（10^-28到10^-50）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Background and Literature Survey
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 背景与文献综述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each codeword of a binary (n,k) CRC code C consists of n = k+r bits. The block of r parity bits is computed from the block of k information bits. The code has a degree r generator polynomial g(x).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二进制（n，k）CRC码C的每个码字由n=k+r位组成。r奇偶校验位块由k个信息位块计算而来。该代码有一个r次生成多项式g（x）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The code is linear in the sense that the bitwise addition of any two codewords yields a codeword.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该代码是线性的，即任意两个码字的按位相加产生一个码字。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the minimal m such that g(x) divides (x^m)-1, either n=m, and the code C comprises the set D of all the multiplications of g(x) modulo (x^m)-1, or n&lt;m, and C is obtained from D by shortening each word in the latter in m-n specific positions. (This also reduces the number of words since all zero words are then discarded and duplicates are not maintained.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于最小m，使得g（x）除以（x^m）-1，或者n=m，并且代码C包括g（x）模（x^m）-1的所有乘法的集合D，或者n&lt;m，并且C通过在m-n特定位置缩短后者中的每个字从D获得。（这也减少了字数，因为所有零字都会被丢弃，并且不会保留重复的字数。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error detection at the receiving end is made by computing the parity bits from the received information block, and comparing them with the received parity bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收端的错误检测是通过从接收到的信息块计算奇偶校验位，并将其与接收到的奇偶校验位进行比较来实现的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An undetected error occurs when the received word c&#39; is a codeword, but is different from the c that is transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收到的字c&#39;是码字，但与发送的c不同时，会发生未检测到的错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is only possible when the error pattern e=c&#39;-c is a codeword by itself (because of the linearity of the code). The performance of a CRC code is measured by the probability Pud of undetected channel errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
只有当错误模式e=c&#39;-c本身是一个码字时（由于代码的线性），这才可能发生。CRC码的性能由未检测到的信道错误的概率Pud来衡量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let Ai denote the number of codewords of weight i, (i.e., with i 1- bits). For a binary symmetric channel (BSC), with sporadic, independent bit error ratio of probability 0&lt;=epsilon&lt;=0.5, the probability of undetected errors for the code C is thus given by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
让Ai表示权重为i的码字数（即，具有i 1位）。对于二元对称信道（BSC），具有概率0&lt;=ε&lt;=0.5的偶发独立误码率，因此代码C的未检测到错误的概率由下式给出：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Pud(C,epsilon) = Sigma[for i=d to n] (Ai*(epsilon^i)*(1-epsilon)^(n-i))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Pud(C,epsilon) = Sigma[for i=d to n] (Ai*(epsilon^i)*(1-epsilon)^(n-i))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where d is the distance of the code: the minimal weight difference between two codewords in C which, by the linearity of the code, is also the minimal weight of any codeword in the code. Pud can also be expressed by the weight distribution of the dual code: the set of words each of which is orthogonal (bitwise AND yields an even number of 1-bits) to every word of C. The fact that Pud can be computed using the dual code is extremely important; while the number of codewords in the code is 2^k, the number of codewords in the dual code is 2^r. k is in the orders of thousands, and r in the order of 16 or 24 or 32. If we use Bi to denote the number of codewords in the dual code which are of weight i, then ([LinCostello]):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中d是代码的距离：C中两个码字之间的最小重量差，根据代码的线性度，它也是代码中任何码字的最小重量。Pud也可以通过双代码的权重分布来表示：每个字的集合与C的每个字正交（按位并产生偶数个1位）。可以使用双代码计算Pud的事实非常重要；代码中的码字数为2^k，而双代码中的码字数为2^r。k的数量级为千，r的数量级为16、24或32。如果我们使用Bi表示双重代码中权重为i的码字数，那么（[LinCostello]）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Pud (C,epsilon) = 2^-r Sigma [for i=0 to n] Bi*(1-2*epsilon)^i -
(1-epsilon)^n
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Pud (C,epsilon) = 2^-r Sigma [for i=0 to n] Bi*(1-2*epsilon)^i -
(1-epsilon)^n
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf [Wolf94o] introduced an efficient algorithm for enumerating all the codewords of a code and finding their weight distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf[Wolf94o]介绍了一种高效的算法，用于枚举代码的所有码字并找到它们的权重分布。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf [Wolf82] found that, counter to what was assumed, (1) there exist codes for which Pud(C,epsilon)&gt;Pud(C,0.5) for some epsilon not=0.5 and (2) Pud is not always increasing for 0&lt;=epsilon&lt;=0.5. The value of what was assumed to be the worst Pud is Pud(C,0.5)=(2^- r) - (2^-n). This stems from the fact that with epsilon=0.5, all 2^n received words are equally likely and out of them 2^(n-r)-1 will be accepted as codewords of no errors, although they are different from the codeword transmitted. Previously Pud had been assumed to equal [2^(n-r)-1]/(2^n-1) or the ratio of the number of non-zero multiples of the polynomial of degree less than n (each such multiple is undetected) and the number of possible error polynomials. With either formula Pud approaches 1/2^r as n approaches infinity, but Wolf&#39;s formula is more accurate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf[Wolf82]发现，与假设相反，（1）存在一些代码，其中Pud（C，epsilon）&gt;Pud（C，0.5）对于某些epsilon不=0.5，（2）对于0&lt;=epsilon&lt;=0.5，Pud并不总是增加。假设最差的Pud的值为Pud（C，0.5）=（2^-r）-（2^-n）。这源于epsilon=0.5时，所有2^n接收字的可能性相同，其中2^（n-r）-1将被接受为无错误的码字，尽管它们与传输的码字不同。先前，假定Pud等于[2^（n-r）-1]/（2^ n-1）或小于n次多项式的非零倍数的数量与可能误差多项式的数量之比（未检测到每个此类倍数）。当n接近无穷大时，Pud或Pud的公式都接近1/2^r，但Wolf的公式更精确。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Wolf [Wolf94j] investigated the CCITT code of r=16 parity bits.  This
   code is a member of the family of (shortened codes of) BCH codes of
   length 2^(r-1) -1 (r=16 in the CCITT 16-bit case) generated by a
   polynomial of the form g(x) =(x+1)p(x) with p(x) being a primitive
   polynomial of degree r-1 (=15 in this case).  These codes have a BCH
   design distance of 4.  That is, the minimal distance between any two
   codewords in the code is at least 4 bits (which is earned by the fact
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Wolf [Wolf94j] investigated the CCITT code of r=16 parity bits.  This
   code is a member of the family of (shortened codes of) BCH codes of
   length 2^(r-1) -1 (r=16 in the CCITT 16-bit case) generated by a
   polynomial of the form g(x) =(x+1)p(x) with p(x) being a primitive
   polynomial of degree r-1 (=15 in this case).  These codes have a BCH
   design distance of 4.  That is, the minimal distance between any two
   codewords in the code is at least 4 bits (which is earned by the fact
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
that the sequence of powers of alpha, the root of p(x), which are roots of g(x), includes three consecutive powers -- alpha^0, alpha^1, alpha^2). Hence, every 3 single bit errors are detectable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
α的幂序列，p（x）的根，即g（x）的根，包括三个连续的幂——α^0，α^1，α^2）。因此，每3个单比特错误都是可检测的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf found that different shortened versions of a given code, of the same codeword length, perform the same (independent of which specific indexes are omitted from the original code). He also found that for the unshortened codes, all primitive polynomials yield codes of the same performance. But for the shortened versions, the choice of the primitive polynomial does make a difference. Wolf [Wolf94j] found a primitive polynomial which (when multiplied by x+1) yields a generating polynomial that outperforms the CCITT one by an order of magnitude. For 32-bit redundancy bits, he found an example of two polynomials that differ in their probability of undetected burst of length 33 by 4 orders of magnitude.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf发现给定代码的不同缩短版本，相同的码字长度，执行相同的操作（与原始代码中省略的特定索引无关）。他还发现，对于未排序的代码，所有原始多项式产生的代码性能相同。但对于缩短版本，选择原始多项式确实会产生不同。Wolf[Wolf94j]发现了一个原始多项式，当乘以x+1时，生成多项式的性能比CCITT多项式高出一个数量级。对于32位冗余位，他发现了两个多项式的示例，它们的未检测到长度为33的突发概率相差4个数量级。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It so happens, that for some shortened codes, the minimum distance, or the distribution of the weights, is better than for others derived from different unshortened codes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事实上，对于某些缩短的代码，最小距离或权重分布要比从不同的未排序代码派生的其他代码好。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Baicheva, et. al. [Baicheva] made a comprehensive comparison of different generating polynomials of degree 16 of the form g(x) = (x+1)p(x), and of other forms. They computed their Pud for code lengths up to 1024 bits. They measured their &#34;goodness&#34; -- if Pud(C,epsilon) &lt;= Pud(C,0.5) and being &#34;well-behaved&#34; -- if Pud(C,epsilon) increases with epsilon in the range (0,0.5). The paper gives a comprehensive table that lists which of the polynomials is good and which is well-behaved for different length ranges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Baicheva等人[Baicheva]对g（x）=（x+1）p（x）和其他形式的16次不同生成多项式进行了综合比较。他们计算了长达1024位的代码长度的Pud。他们测量他们的“善良”——如果Pud（C，epsilon）&lt;=Pud（C，0.5）并且表现“良好”——如果Pud（C，epsilon）在（0,0.5）范围内随epsilon增加。本文给出了一个综合表，列出了哪些多项式是好的，哪些多项式在不同的长度范围内表现良好。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a single burst error, Wolf [Wolf94J] suggested the model of (b:p) burst -- the errors only occur within a span of b bits, and within that span, the errors occur randomly, with a bit error probability 0 &lt;= p &lt;= 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于单个突发错误，Wolf[Wolf94J]提出了（b:p）突发的模型——错误只发生在b位的范围内，在该范围内，错误随机发生，误码概率为0&lt;=p&lt;=1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For p=0.5, which used to be considered the worst case, it is well known [Wolf94J] that the probability of undetected one burst error of length b &lt;= r is 0, of length b=r+1 is 2^-(r-1), and of b &gt; r+1, is 2^-r, independently of the choice of the primitive polynomial.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于过去被视为最坏情况的p=0.5，众所周知[Wolf94J]，未被检测到的一个突发错误的概率为：长度b&lt;=r为0，长度b=r+1为2^-（r-1），以及长度b&gt;r+1为2^-r，与原始多项式的选择无关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With Wolf&#39;s definition, where p can be different from 0.5, indeed it was found that for a given b there are values of p, different from 0.5 which maximize the probability of undetected (b:p) burst error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据Wolf的定义，p可以不同于0.5，事实上，对于给定的b，p的值不同于0.5，这使得未检测（b:p）突发错误的概率最大化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf proved that for a given code, for all b in the range r &lt; b &lt; n, the conditional probability of undetected error for the (n, n-r) code, given that a (b:p) burst occurred, is equal to the probability of undetected errors for the same code (the same generating polynomial), shortened to block length b, when this shortened code is used with a binary symmetric channel with channel (sporadic, independent) bit error probability p.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wolf证明，对于给定的代码，对于r&lt;b&lt;n范围内的所有b，如果（b:p）突发发生，（n，n-r）代码未检测到错误的条件概率等于相同代码（相同生成多项式）未检测到错误的概率，缩短为块长b，当此缩短码用于信道（零星、独立）误码概率为p的二进制对称信道时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the IEEE-802.3 used CRC32, Fujiwara et al. [Fujiwara89] measured the weights of all words of all shortened versions of the IEEE 802.3 code of 32 check bits. This code is generated by a primitive polynomial of degree 32:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于使用CRC32的IEEE-802.3，Fujiwara等人[Fujiwara89]测量了32个校验位的IEEE 802.3代码的所有缩短版本的所有字的权重。此代码由32次原始多项式生成：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
g(x) = x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1 and hence the designed distance of it is only 3. This distance holds for codes as long as 2^32-1. However, the frame format of the MAC (Media Access Control) of the data link layer in IEEE 802.3, as well as that of the data link layer for the Ethernet (1980) forbid lengths exceeding 12,144 bits. Thus, only such bounded lengths are investigated in [Fujiwara89]. For shortened versions, the minimum distance was found to be 4 for lengths 4096 to 12,144; 5 for lengths 512 to 2048; and even 15 for lengths 33 through 42. A chart of results of calculations of Pud is presented in [Fujiwara89] from which we can see that for codes of length 12,144 and BSC of epsilon = 10^-5 - 10^-4, Pud(12,144,epsilon)= 10^-14 - 10^-13 and for epsilon = 10^-4 - 10^-3, Pud(512,epsilon) = 10^-15, Pud(1024,epsilon) = 10^-14, Pud(2048,epsilon) = 10^-13, Pud(4096,epsilon) = 10^-12 - 10^-11, and Pud(8192,epsilon) = 10^-10 which is rather close to 2^-32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
g（x）=x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1，因此其设计距离仅为3。此距离适用于长度为2^32-1的代码。然而，IEEE 802.3中数据链路层的MAC（媒体访问控制）的帧格式以及以太网的数据链路层（1980）的帧格式禁止长度超过12144位。因此，在[Fujiwara89]中只研究了这种有界长度。对于缩短版本，发现长度4096至12144的最小距离为4；长度为512至2048时为5；从33到42的长度为15。[Fujiwara89]中给出了Pud的计算结果图表，从中我们可以看到，对于长度为12144且BSC为ε=10^-5-10^-4的代码，Pud（12144，ε）=10^-14-10^-13，对于ε=10^-4-10^-3，Pud（512，ε）=10^-15，Pud（1024，ε）=10^-14，Pud（2048，ε）=10^-13，Pud（4096，ε）=10^-11，Pud（8192，ε）=10^-10，相当接近于2^-32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Castagnoli, et. al. [Castagnoli93] extended Fujiwara&#39;s technique for efficiently calculating the minimum distance through the weight distribution of the dual code and explored a large number of CRC codes with 24 and 32 redundancy bit. They explored several codes built as a multiplication of several lower degree irreducible polynomials.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Castagnoli等人[Castagnoli 93]扩展了Fujiwara的技术，通过双码的权重分布有效地计算最小距离，并探索了大量具有24位和32位冗余的CRC码。他们研究了几个由几个低阶不可约多项式乘法而成的代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the popular class of (x+1)*deg31-irreducible-polynomial they explored 47000 polynomials (not all the possible ones). The best they found has d=6 up to block lengths of 5275 and d=4 up to 2^31-1 (bits).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在流行的（x+1）*deg31不可约多项式中，他们研究了47000个多项式（并非所有可能的多项式）。他们发现最好的数据块长度为5275的d=6和2^31-1（位）的d=4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The investigation was done in 1993 with a special purpose processor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这项调查是在1993年用一种专用处理器进行的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By comparison, the IEEE-802 code has d=4 up to at least 64,000 bits (Fujikura stopped looking at 12,144) and d=3 up to 2^32-1 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相比之下，IEEE-802代码的d=4高达至少64000位（藤仓不再看12144位），d=3高达2^32-1位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CRC32/4 (we will refer to it as CRC32C for the remainder of this memo) is 11EDC6F41; IEEE-802 CRC is 104C11DB7, denoting the coefficients as a bit vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CRC32/4（在本备忘录的其余部分，我们将其称为CRC32C）为11EDC6F41；IEEE-802 CRC为104C11DB7，表示系数为位向量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Stone98] evaluated the performance of CRC (the AAL5 CRC that is the same as IEEE802) and the TCP and Fletcher checksums on large amounts of data. The results of this experiment indicate a serious weakness of the checksums on real-data that stems from the fact that checksums do not spread the &#34;hot spots&#34; in input data. However, the results show that Fletcher behaves by a factor of 2 better than the regular TCP checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Stone98]评估了CRC（AAL5 CRC，与IEEE802相同）以及TCP和Fletcher校验和在大量数据上的性能。这个实验的结果表明，真实数据上的校验和存在一个严重的弱点，这是因为校验和不会扩散输入数据中的“热点”。然而，结果表明Fletcher的性能比常规TCP校验和好2倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Probability of Undetected Errors - Burst Error
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 未检测到错误的概率-突发错误
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 CRC32C (Derivations from [Wolf94j])
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 CRC32C（从[Wolf94j]衍生）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Wolf [Wolf94j] found a 32-bit polynomial of the form g(x) = (1+x)p(x)
   for which the conditional probability of undetected error, given that
   a burst of length 33 occurred, is at most (i.e., maximized over all
   possible channel bit error probabilities within the burst) 4 * 10^-
   10.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Wolf [Wolf94j] found a 32-bit polynomial of the form g(x) = (1+x)p(x)
   for which the conditional probability of undetected error, given that
   a burst of length 33 occurred, is at most (i.e., maximized over all
   possible channel bit error probabilities within the burst) 4 * 10^-
   10.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We will now figure the probability of undetected error, given that a burst of length 34 occurred, using the result derived in this paper, namely that for a given code, for all b in the range 32 &lt; b &lt; n, the conditional probability of undetected error for the (n, n-32) code, given that a (b:p) burst occurred, is equal to the probability of undetected errors for the same code (the same generating polynomial), shortened to block length b, when this shortened code is used with a binary symmetric channel with channel (sporadic, independent) bit error probability p.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在，我们将使用本文得出的结果，计算未检测到错误的概率，假设发生了长度为34的突发，即对于给定代码，对于32&lt;b&lt;n范围内的所有b，假设发生了（b:p）突发，则（n，n-32）代码未检测到错误的条件概率，等于相同代码（相同生成多项式）未检测到错误的概率，缩短为块长度b，当此缩短代码与信道（零星、独立）误码概率p的二进制对称信道一起使用时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The approximation formula for Pud of sporadic errors, if the weights Ai are distributed binomially, is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果权重Ai为二元分布，则偶发误差Pud的近似公式为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pud(C, epsilon) =~= Sigma[for i=d to n] ((n choose i) / 2^r )*(1- epsilon)^(n-i) * epsilon^i .
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pud（C，epsilon）=~=Sigma[对于i=d到n]（（n选择i）/2^r）*（1-epsilon）^（n-i）*epsilon^i。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assuming a very small epsilon, this expression is dominated by i=d. From [Fujiwara89] we know that for 32-bit CRC, for such small n, d=15. Thus, when n grows from 33 to 34, we find that the approximation of Pud grows by (34 choose 15) / (33 choose 15) = 34/19; when n grows further to 35, Pud grows by another 35/20.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设一个很小的ε，这个表达式由i=d控制。从[Fujiwara89]我们知道，对于32位CRC，对于如此小的n，d=15。因此，当n从33增长到34时，我们发现Pud的近似值增长（34选择15）/（33选择15）=34/19；当n进一步增长到35时，Pud再增长35/20。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taking, from Wolf [Wolf94j], the most generous conditional probability, computed with the bit error probability p* that maximizes Pub(p|b), we derive: Pud(p*|33) = 4 x 10^{-10}, yielding Pud(p*|34) = 7.15 x 10^{-10} and Pud(p*|35) = 1.25 x 10^{-9}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从Wolf[Wolf94j]中，取最大化Pub（p | b）的误码概率p*计算出的最慷慨的条件概率，我们得出：Pud（p*| 33）=4x10^{-10}，得到Pud（p*| 34）=7.15x10^{-10}和Pud（p*| 35）=1.25x10^-9}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the density function of the burst length, we assume the Rayleigh density function (the discretization thereof to integers), which is the density of the absolute values of complex numbers of Gauss distribution:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于突发长度的密度函数，我们假设瑞利密度函数（将其离散为整数），它是高斯分布复数绝对值的密度：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
f(x) = x / a^2 exp {-x^2 / 2a^2 } , x&gt;0 .
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
f（x）=x/a^2 exp{-x^2/2a^2}，x&gt;0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This density function has a peak at the parameter a and it decreases smoothly as x increases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该密度函数在参数a处有一个峰值，并且随着x的增加，它会平滑地减小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We take three consecutive bits as the most common burst event once an error does occur, and thus a=3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦发生错误，我们将三个连续的位作为最常见的突发事件，因此a=3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, the probability that a burst of length b occurs in a specific position is the burst error rate, which we estimate as 10^{-10}, times f(b). Calculating for b=33 we find f(33) = 1.94 x 10^{-26}. Together, we found that the probability that a burst of length 33 occurred, starting at a specific position, is 1.94 x 10^{-36}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在，长度为b的突发在特定位置发生的概率是突发错误率，我们估计为10^{-10}，乘以f（b）。计算b=33，我们发现f（33）=1.94x10^{-26}。总之，我们发现从特定位置开始发生长度为33的突发的概率为1.94 x 10^{-36}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multiplying this by the generous upper bound on the probability that this burst error is not detected, Pud(p*|33), we get that the probability that a burst occurred at a specific position, and is not detected, is 7.79 x 10 ^{-46}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将其乘以该突发错误未被检测到的概率的上界Pud（p*| 33），我们得到突发发生在特定位置且未被检测到的概率为7.79 x 10^{-46}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Going again along this path of calculations, this time for b=34 we find that f(34) = 4.85*10^{-28}. Multiplying by 10^{-10} and by Pud(p*|34) = 7.15*10^{-10} we find that the probability that a burst of length 34 occurred at a specific position, and is not detected, is 3.46*10^{-47}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
再次沿着这条计算路径，这次对于b=34，我们发现f（34）=4.85*10^{-28}。乘以10^{-10}和Pud（p*|34）=7.15*10^{-10}，我们发现长度为34的突发发生在特定位置且未被检测到的概率为3.46*10^{-47}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Last, computing for b=35, we get 1*10^{-29} * 10^{-10} * 1.25*10^{-9} = 1.25*10^{-48}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，计算b=35，我们得到1*10^{-29}*10^{-10}*1.25*10^{-9}=1.25*10^{-48}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It looks like the total can be approximated at 10^-45 which is within the bounds of what we are looking for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
看起来总数可以近似为10^-45，这在我们正在寻找的范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When we multiply this by the length of the code (because thus far we calculated for a specific position) we have 10^-45 * 6.5*10^4 = 6.5*10^-41 as an upper bound on the probability of undetected burst error for a code of length 8K Bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当我们将其乘以代码长度时（因为到目前为止我们计算的是特定位置），我们得到10^-45*6.5*10^4=6.5*10^-41作为长度为8K字节的代码未检测到突发错误概率的上限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can also apply this overestimation for IEEE 802.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们也可以将这种高估应用于IEEE 802.3。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comment: 2^{-32} = 2.33*10^{-10}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
评论：2^{-32}=2.33*10^{-10}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Probability of Undetected Errors - Independent Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 未检测到错误的概率-独立错误
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 CRC (Derivations from [Castagnoli93])
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 CRC（从[Castagnoli93]衍生）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is reported in [Castagnoli93] that for BER = epsilon=10^-6, Pud for a single bit error, for a code of length 8KB, for both cases, IEEE-802.3 and CRC32C is 10^{-20}. They also report that CRC32C has distance 4, and IEEE either 3 or 4 for this code length. From this, and the minimum distance of the code of this length, we conclude that with our estimation of epsilon, namely 10^{-11}, we should multiply the reported result by {10^{-5}}^4 = 10^{-20} for CRC32C, and either 10^{-15} or 10^{-20} for IEEE802.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Castagnoli93]中报告，对于BER=epsilon=10^-6，对于单比特错误的Pud，对于长度为8KB的代码，对于这两种情况，IEEE-802.3和CRC32C都是10^{-20}。他们还报告说，CRC32C的距离为4，而IEEE的代码长度为3或4。从这一点，以及这个长度的代码的最小距离，我们得出结论，根据我们对ε的估计，即10^{-11}，我们应该将报告的结果乘以{10^{-5}}^4=10^{-20}（对于CRC32C），或者乘以10^{-15}或者乘以10^{-20}（对于IEEE802.3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Checksums
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 校验和
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For independent bit errors, Pud of CRC is approximately 12,000 better than Fletcher, and 22,000 better than Adler. For burst errors, by the simple examples that exist for three consecutive values that can produce an undetected burst, we take the factor to be at least the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于独立位错误，CRC的Pud比Fletcher大约好12000，比Adler好22000。对于突发错误，通过存在三个连续值的简单示例，可以产生未检测到的突发，我们认为因子至少是相同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If in three consecutive bytes, the error values are x, -2x, x then the error is undetected. Even for this error pattern alone, the conditional probability of undetected error, assuming a uniform distribution of data, is 2^-16 = 1.5 * 10^-5. The probability that a burst of length 3 bytes occurs, is f(24) = 3*10^-14. Together: 4.5*10^-19. Multiplying this by the length of the code, we get close to 4.5*10^-16, way worse than the vicinity of 10^-40.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在三个连续字节中，错误值为x，-2x，x，则未检测到错误。即使仅此错误模式，假设数据分布均匀，未检测到错误的条件概率为2^-16=1.5*10^-5。发生长度为3字节的突发的概率为f（24）=3*10^-14。合计：4.5*10^-19。将其乘以代码的长度，我们得到接近4.5*10^-16，比10^-40附近差得多。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The numbers in the table in Section 7 below reflect a more &#34;tolerant&#34; difference (10*4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面第7节表格中的数字反映了一个更“宽容”的差异（10*4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Incremental CRC Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 增量CRC更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some protocols the packet header changes frequently. If the CRC includes the changing part, the CRC will have to be recomputed. This raises two issues:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在某些协议中，数据包头经常变化。如果CRC包括更改部分，则必须重新计算CRC。这引发了两个问题：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- the complete computation is expensive - the packet is not protected against unwanted changes between the last check and the recomputation
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
- 完整的计算是昂贵的-数据包在最后一次检查和重新计算之间不会受到不必要的更改的保护
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fortunately, changes in the header do not imply a need for completed CRC computation. The reason is the linearity of the CRC function. Namely, with I1 and I2 denoting two equal-length blocks of information bits, CRC(I) denoting the CRC check bits calculated for I, and + denoting bitwise modulo-2 addition, we have CRC(I1+I2) = CRC(I1)+CRC(I2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
幸运的是，标头中的更改并不意味着需要完成CRC计算。原因是CRC函数的线性。即，I1和I2表示两个等长的信息位块，CRC（I）表示为I计算的CRC校验位，+表示按位模2加法，我们得到CRC（I1+I2）=CRC（I1）+CRC（I2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hence, for an IP packet, made of a header h followed by data d followed by CRC bits c = CRC(h d), arriving at a node, which updates header h to become h&#39;, the implied update of c is an addition of CRC(h&#39;-h 0), where 0 is an all 0 block of the length of the data block d, and addition and subtraction are bitwise modulo 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，对于由报头h后跟数据d后跟CRC比特c＝CRC（hd）构成的IP分组，其到达将报头h更新为h’的节点，c的隐含更新是CRC（h’-h0）的加法，其中0是数据块d的长度的全0块，并且加法和减法是按位模2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We know that a predetermined permutation of bits does not change distance and weight statistics of the codewords. It follows that such a transformation does not change the probability of undetected errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们知道，预先确定的比特排列不会改变码字的距离和权重统计。因此，这种转换不会改变未检测到错误的概率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We can then conceive the packet as if it was built from data d followed by header h, compute the CRC accordingly, c=CRC(d h), and update at the node with an addition of CRC(0 h&#39;-h)=CRC(h&#39;-h), but on transmission, send the header part before the data and the CRC bits. This will allow a faster computation of the CRC, while still letting the header part lead (no change to the protocol).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，我们可以设想数据包，就好像它是由数据d后跟报头h构建的一样，相应地计算CRC，c=CRC（DH），并在节点处使用CRC（0H&#39;-h）=CRC（h&#39;-h）的加法进行更新，但在传输时，发送数据和CRC位之前的报头部分。这将允许更快地计算CRC，同时仍然允许报头部分引导（不改变协议）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error detection, i.e., computing the CRC bits by the data and header parts that arrive, and comparing them with the CRC part that arrives together with them, can be done at the final, end-target node only, and the detected errors will include unwanted changes introduced by the intermediate nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误检测，即，通过到达的数据和报头部分计算CRC位，并将其与连同它们一起到达的CRC部分进行比较，只能在最终的、最终的目标节点上进行，并且检测到的错误将包括中间节点引入的不需要的改变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The analysis of the undetected error probability remains valid according to the following rationale:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据以下基本原理，未检测到的错误概率分析仍然有效：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet started its way as a codeword. On its way, several codewords were added to it (any information followed by the corresponding CRC is a codeword). Let e denote the totality of errors added to the packet, on its long, multi-hop journey. Because the code is linear (i.e., the sum of two codewords is also a codeword) the packet arriving to the end-target node is some codeword + e, and hence, as in our preceding analysis, e is undetected if and only if it is a codeword by itself. This fact is the basis of our above analysis, and hence that analysis applies here too. (See a detailed discussion at [braun01].)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这个数据包最初是一个码字。在此过程中，添加了几个码字（相应CRC后面的任何信息都是码字）。让e表示在数据包长的多跳过程中添加到数据包中的错误总数。由于代码是线性的（即，两个码字之和也是一个码字），到达最终目标节点的数据包是某个码字+e，因此，如我们前面的分析中所述，当且仅当e本身是一个码字时，e才未被检测到。这一事实是我们上述分析的基础，因此该分析在这里也适用。（参见[braun01]中的详细讨论。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Complexity of Hardware Implementation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 硬件实现的复杂性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comparing the cost of various CRC polynomials, we used a tool available at http://www.easics.com/webtools/crctool to implement CRC generators/checkers for various CRC polynomials. The program gives either Verilog or VHDL code after specifying a polynomial, as well as the number of data bits, k, to be handled in one clock cycle. For a serial implementation, k would be one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比较各种CRC多项式的成本，我们使用了http://www.easics.com/webtools/crctool 为各种CRC多项式实现CRC生成器/校验器。该程序在指定多项式以及在一个时钟周期内要处理的数据位数k后，给出Verilog或VHDL代码。对于串行实现，k是一个。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cost for either one generator or checker is shown in the following table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下表显示了一台发电机或检查器的成本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The number of 2-input XOR gates, for an un-optimized implementation, required for various values of k:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于未优化的实现，各种k值所需的2输入异或门的数量：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----------------------------------------------+
   | Polynomial  | k=32     | k=64     | k=128    |
   +----------------------------------------------+
   | CCITT-CRC32 | 488      | 740      | 1430     |
   +----------------------------------------------+
   | IEEE-802    | 872      | 1390     | 2518     |
   +----------------------------------------------+
   | CRC32Q(Wolf)| 944      | 1444     | 2534     |
   +----------------------------------------------+
   | CRC32C      | 1036     | 1470     | 2490     |
   +----------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----------------------------------------------+
   | Polynomial  | k=32     | k=64     | k=128    |
   +----------------------------------------------+
   | CCITT-CRC32 | 488      | 740      | 1430     |
   +----------------------------------------------+
   | IEEE-802    | 872      | 1390     | 2518     |
   +----------------------------------------------+
   | CRC32Q(Wolf)| 944      | 1444     | 2534     |
   +----------------------------------------------+
   | CRC32C      | 1036     | 1470     | 2490     |
   +----------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After optimizing (sharing terms) and in terms of Cells (4 cells per 2 input AND, 7 cells per 2 input XOR, 3 cells per inverter) the cost for two candidate polynomials is shown in the following table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在优化（共享项）和单元（每2个输入4个单元，每2个输入7个单元，异或，每逆变器3个单元）后，两个候选多项式的成本如下表所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------------------+
   | Polynomial  | k=32     | k=64     |
   +-----------------------------------+
   | CCITT-CRC32 | 1855     | 3572     |
   +-----------------------------------+
   | CRC32C      | 4784     | 7111     |
   +-----------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------------------+
   | Polynomial  | k=32     | k=64     |
   +-----------------------------------+
   | CCITT-CRC32 | 1855     | 3572     |
   +-----------------------------------+
   | CRC32C      | 4784     | 7111     |
   +-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For 32-bit datapath, CCITT-CRC32 requires 40% of the number of cells required by the CRC32C. For a 64-bit datapath, CCITT-CRC32 requires 50% of the number of cells.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于32位数据路径，CCITT-CRC32需要CRC32C所需单元数的40%。对于64位数据路径，CCITT-CRC32需要50%的单元数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The total size of one of our smaller chips is roughly 1 million cells. The fraction represented by the CRC circuit is less than 1%.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们的一个较小芯片的总尺寸约为100万个电池。CRC电路表示的分数小于1%。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Implementation of CRC32C
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. CRC32C的实现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 A Serial Implementation in Hardware
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 串行硬件实现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A serial implementation that processes one data bit at a time and performs simultaneous multiplication of the data polynomial by x^32 and division by the CRC32C polynomial is described in the following Verilog [ieee1364] code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面的Verilog[ieee1364]代码描述了一种串行实现，该串行实现一次处理一个数据位，并同时执行数据多项式与x^32的乘法和与CRC32C多项式的除法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /////////////////////////////////////////////////////////////////////
   //File: CRC32_D1.v
   //Date: Tue Feb 26 02:47:05 2002
   //
   //Copyright (C) 1999 Easics NV.
   //This source file may be used and distributed without restriction
   //provided that this copyright statement is not removed from the file
   //and that any derivative work contains the original copyright notice
   //and the associated disclaimer.
   //
   //THIS SOURCE FILE IS PROVIDED &#34;AS IS&#34; AND WITHOUT ANY EXPRESS
   //OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   //WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   //
   //Purpose: Verilog module containing a synthesizable CRC function
   //* polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)
   //* data width: 1
   //
   //Info: jand@easics.be (Jan Decaluwe)
   //http://www.easics.com
   /////////////////////////////////////////////////////////////////////
   module CRC32_D1;
   // polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)
   // data width: 1
   function [31:0] nextCRC32_D1;
   input Data;
   input [31:0] CRC;
   reg [0:0] D;
   reg [31:0] C;
   reg [31:0] NewCRC;
   begin
   D[0] = Data;
   C = CRC;
   NewCRC[0] = D[0] ^ C[31];
   NewCRC[1] = D[0] ^ C[0] ^ C[31];
   NewCRC[2] = D[0] ^ C[1] ^ C[31];
   NewCRC[3] = C[2];
   NewCRC[4] = D[0] ^ C[3] ^ C[31];
   NewCRC[5] = D[0] ^ C[4] ^ C[31];
   NewCRC[6] = C[5];
   NewCRC[7] = D[0] ^ C[6] ^ C[31];
   NewCRC[8] = D[0] ^ C[7] ^ C[31];
   NewCRC[9] = C[8];
   NewCRC[10] = D[0] ^ C[9] ^ C[31];
   NewCRC[11] = D[0] ^ C[10] ^ C[31];
   NewCRC[12] = D[0] ^ C[11] ^ C[31];
   NewCRC[13] = C[12];
   NewCRC[14] = C[13];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /////////////////////////////////////////////////////////////////////
   //File: CRC32_D1.v
   //Date: Tue Feb 26 02:47:05 2002
   //
   //Copyright (C) 1999 Easics NV.
   //This source file may be used and distributed without restriction
   //provided that this copyright statement is not removed from the file
   //and that any derivative work contains the original copyright notice
   //and the associated disclaimer.
   //
   //THIS SOURCE FILE IS PROVIDED &#34;AS IS&#34; AND WITHOUT ANY EXPRESS
   //OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   //WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   //
   //Purpose: Verilog module containing a synthesizable CRC function
   //* polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)
   //* data width: 1
   //
   //Info: jand@easics.be (Jan Decaluwe)
   //http://www.easics.com
   /////////////////////////////////////////////////////////////////////
   module CRC32_D1;
   // polynomial: (0 1 2 4 5 7 8 10 11 12 16 22 23 26 32)
   // data width: 1
   function [31:0] nextCRC32_D1;
   input Data;
   input [31:0] CRC;
   reg [0:0] D;
   reg [31:0] C;
   reg [31:0] NewCRC;
   begin
   D[0] = Data;
   C = CRC;
   NewCRC[0] = D[0] ^ C[31];
   NewCRC[1] = D[0] ^ C[0] ^ C[31];
   NewCRC[2] = D[0] ^ C[1] ^ C[31];
   NewCRC[3] = C[2];
   NewCRC[4] = D[0] ^ C[3] ^ C[31];
   NewCRC[5] = D[0] ^ C[4] ^ C[31];
   NewCRC[6] = C[5];
   NewCRC[7] = D[0] ^ C[6] ^ C[31];
   NewCRC[8] = D[0] ^ C[7] ^ C[31];
   NewCRC[9] = C[8];
   NewCRC[10] = D[0] ^ C[9] ^ C[31];
   NewCRC[11] = D[0] ^ C[10] ^ C[31];
   NewCRC[12] = D[0] ^ C[11] ^ C[31];
   NewCRC[13] = C[12];
   NewCRC[14] = C[13];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   NewCRC[15] = C[14];
   NewCRC[16] = D[0] ^ C[15] ^ C[31];
   NewCRC[17] = C[16];
   NewCRC[18] = C[17];
   NewCRC[19] = C[18];
   NewCRC[20] = C[19];
   NewCRC[21] = C[20];
   NewCRC[22] = D[0] ^ C[21] ^ C[31];
   NewCRC[23] = D[0] ^ C[22] ^ C[31];
   NewCRC[24] = C[23];
   NewCRC[25] = C[24];
   NewCRC[26] = D[0] ^ C[25] ^ C[31];
   NewCRC[27] = C[26];
   NewCRC[28] = C[27];
   NewCRC[29] = C[28];
   NewCRC[30] = C[29];
   NewCRC[31] = C[30];
   nextCRC32_D1 = NewCRC;
   end
   endfunction
   endmodule
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   NewCRC[15] = C[14];
   NewCRC[16] = D[0] ^ C[15] ^ C[31];
   NewCRC[17] = C[16];
   NewCRC[18] = C[17];
   NewCRC[19] = C[18];
   NewCRC[20] = C[19];
   NewCRC[21] = C[20];
   NewCRC[22] = D[0] ^ C[21] ^ C[31];
   NewCRC[23] = D[0] ^ C[22] ^ C[31];
   NewCRC[24] = C[23];
   NewCRC[25] = C[24];
   NewCRC[26] = D[0] ^ C[25] ^ C[31];
   NewCRC[27] = C[26];
   NewCRC[28] = C[27];
   NewCRC[29] = C[28];
   NewCRC[30] = C[29];
   NewCRC[31] = C[30];
   nextCRC32_D1 = NewCRC;
   end
   endfunction
   endmodule
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 A Parallel Implementation in Hardware
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 硬件上的并行实现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A parallel implementation that processes 32 data bits at a time is described in the following Verilog [ieee1364] code. In software implementations, the next state logic is typically implemented by means of tables indexed by the input and the current state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面的Verilog[ieee1364]代码描述了一种一次处理32个数据位的并行实现。在软件实现中，下一状态逻辑通常通过由输入和当前状态索引的表来实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /////////////////////////////////////////////////////////////////////
   //File: CRC32_D32.v
   //Date: Tue Feb 26 02:50:08 2002
   //
   //Copyright (C) 1999 Easics NV.
   //This source file may be used and distributed without restriction
   //provided that this copyright statement is not removed from the file
   //and that any derivative work contains the original copyright notice
   //and the associated disclaimer.
   //
   //THIS SOURCE FILE IS PROVIDED &#34;AS IS&#34; AND WITHOUT ANY EXPRESS
   //OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   //WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   //
   //Purpose: Verilog module containing a synthesizable CRC function
   //* polynomial: p(0 to 32) := &#34;100000101111011000111011011110001&#34;
   //* data width: 32
   //
   //Info: jand@easics.be (Jan Decaluwe)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /////////////////////////////////////////////////////////////////////
   //File: CRC32_D32.v
   //Date: Tue Feb 26 02:50:08 2002
   //
   //Copyright (C) 1999 Easics NV.
   //This source file may be used and distributed without restriction
   //provided that this copyright statement is not removed from the file
   //and that any derivative work contains the original copyright notice
   //and the associated disclaimer.
   //
   //THIS SOURCE FILE IS PROVIDED &#34;AS IS&#34; AND WITHOUT ANY EXPRESS
   //OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
   //WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
   //
   //Purpose: Verilog module containing a synthesizable CRC function
   //* polynomial: p(0 to 32) := &#34;100000101111011000111011011110001&#34;
   //* data width: 32
   //
   //Info: jand@easics.be (Jan Decaluwe)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //http://www.easics.com
   /////////////////////////////////////////////////////////////////////
   module CRC32_D32;
   // polynomial: p(0 to 32) := &#34;100000101111011000111011011110001&#34;
   // data width: 32
   // convention: the first serial data bit is D[31]
   function [31:0] nextCRC32_D32;
   input [31:0] Data;
   input [31:0] CRC;
   reg [31:0] D;
   reg [31:0] C;
   reg [31:0] NewCRC;
   begin
   D = Data;
   C = CRC;
   NewCRC[0] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^ D[23]
   ^
   D[21] ^ D[18] ^ D[17] ^ D[16] ^ D[12] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^ C[4] ^ C[5] ^
   C[6] ^ C[7] ^ C[8] ^ C[9] ^ C[12] ^ C[16] ^ C[17] ^
   C[18] ^ C[21] ^ C[23] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^
   C[30] ^ C[31];
   NewCRC[1] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[26] ^ D[24] ^ D[22]
   ^
   D[19] ^ D[18] ^ D[17] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[5] ^ D[1] ^ C[1] ^ C[5] ^ C[6] ^ C[7] ^
   C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[17] ^ C[18] ^ C[19] ^
   C[22] ^ C[24] ^ C[26] ^ C[27] ^ C[28] ^ C[29] ^ C[31];
   NewCRC[2] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[23] ^ D[20]
   ^
   D[19] ^ D[18] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[2] ^ C[2] ^ C[6] ^ C[7] ^ C[8] ^ C[9] ^
   C[10] ^ C[11] ^ C[14] ^ C[18] ^ C[19] ^ C[20] ^ C[23] ^
   C[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[3] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[24] ^ D[21]
   ^
   D[20] ^ D[19] ^ D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[8] ^ D[7] ^ D[3] ^ C[3] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^
   C[11] ^ C[12] ^ C[15] ^ C[19] ^ C[20] ^ C[21] ^ C[24] ^
   C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[4] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[25] ^ D[22] ^ D[21]
   ^
   D[20] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[8] ^ D[4] ^ C[4] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[12] ^ C[13] ^ C[16] ^ C[20] ^ C[21] ^ C[22] ^ C[25] ^
   C[27] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[5] = D[31] ^ D[30] ^ D[28] ^ D[26] ^ D[23] ^ D[22] ^ D[21]
   ^
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //http://www.easics.com
   /////////////////////////////////////////////////////////////////////
   module CRC32_D32;
   // polynomial: p(0 to 32) := &#34;100000101111011000111011011110001&#34;
   // data width: 32
   // convention: the first serial data bit is D[31]
   function [31:0] nextCRC32_D32;
   input [31:0] Data;
   input [31:0] CRC;
   reg [31:0] D;
   reg [31:0] C;
   reg [31:0] NewCRC;
   begin
   D = Data;
   C = CRC;
   NewCRC[0] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^ D[23]
   ^
   D[21] ^ D[18] ^ D[17] ^ D[16] ^ D[12] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^ C[4] ^ C[5] ^
   C[6] ^ C[7] ^ C[8] ^ C[9] ^ C[12] ^ C[16] ^ C[17] ^
   C[18] ^ C[21] ^ C[23] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^
   C[30] ^ C[31];
   NewCRC[1] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[26] ^ D[24] ^ D[22]
   ^
   D[19] ^ D[18] ^ D[17] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[5] ^ D[1] ^ C[1] ^ C[5] ^ C[6] ^ C[7] ^
   C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[17] ^ C[18] ^ C[19] ^
   C[22] ^ C[24] ^ C[26] ^ C[27] ^ C[28] ^ C[29] ^ C[31];
   NewCRC[2] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[23] ^ D[20]
   ^
   D[19] ^ D[18] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^
   D[7] ^ D[6] ^ D[2] ^ C[2] ^ C[6] ^ C[7] ^ C[8] ^ C[9] ^
   C[10] ^ C[11] ^ C[14] ^ C[18] ^ C[19] ^ C[20] ^ C[23] ^
   C[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[3] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[24] ^ D[21]
   ^
   D[20] ^ D[19] ^ D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[8] ^ D[7] ^ D[3] ^ C[3] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^
   C[11] ^ C[12] ^ C[15] ^ C[19] ^ C[20] ^ C[21] ^ C[24] ^
   C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[4] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[25] ^ D[22] ^ D[21]
   ^
   D[20] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[8] ^ D[4] ^ C[4] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[12] ^ C[13] ^ C[16] ^ C[20] ^ C[21] ^ C[22] ^ C[25] ^
   C[27] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[5] = D[31] ^ D[30] ^ D[28] ^ D[26] ^ D[23] ^ D[22] ^ D[21]
   ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[5] ^ C[5] ^ C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^
   C[14] ^ C[17] ^ C[21] ^ C[22] ^ C[23] ^ C[26] ^ C[28] ^
   C[30] ^ C[31];
   NewCRC[6] = D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[22]
   ^
   D[21] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^ D[11] ^
   D[10] ^ D[9] ^ D[8] ^ D[7] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^
   C[4] ^ C[5] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[21] ^ C[22] ^
   C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[7] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23]
   ^
   D[22] ^ D[18] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[12] ^
   D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^ D[5] ^ D[1] ^
   C[1] ^ C[5] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[12] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[18] ^ C[22] ^
   C[23] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[8] = D[25] ^ D[24] ^ D[21] ^ D[19] ^ D[15] ^ D[13] ^ D[11]
   ^
   D[10] ^ D[8] ^ D[5] ^ D[4] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^
   C[4] ^ C[5] ^ C[8] ^ C[10] ^ C[11] ^ C[13] ^ C[15] ^
   C[19] ^ C[21] ^ C[24] ^ C[25];
   NewCRC[9] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[23] ^ D[22] ^ D[21]
   ^
   D[20] ^ D[18] ^ D[17] ^ D[14] ^ D[11] ^ D[8] ^ D[7] ^
   D[4] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[4] ^
   C[7] ^ C[8] ^ C[11] ^ C[14] ^ C[17] ^ C[18] ^ C[20] ^
   C[21] ^ C[22] ^ C[23] ^ C[27] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[10] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^
   D[22] ^
   D[19] ^ D[17] ^ D[16] ^ D[15] ^ D[7] ^ D[6] ^ D[2] ^
   D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[6] ^ C[7] ^ C[15] ^
   C[16] ^ C[17] ^ C[19] ^ C[22] ^ C[24] ^ C[25] ^ C[26] ^
   C[27] ^ C[29] ^ C[30];
   NewCRC[11] = D[21] ^ D[20] ^ D[12] ^ D[9] ^ D[6] ^ D[5] ^ D[4] ^
   D[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[3] ^
   C[4] ^ C[5] ^ C[6] ^ C[9] ^ C[12] ^ C[20] ^ C[21];
   NewCRC[12] = D[22] ^ D[21] ^ D[13] ^ D[10] ^ D[7] ^ D[6] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^
   C[5] ^ C[6] ^ C[7] ^ C[10] ^ C[13] ^ C[21] ^ C[22];
   NewCRC[13] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^
   D[22] ^
   D[21] ^ D[18] ^ D[17] ^ D[16] ^ D[14] ^ D[12] ^ D[11] ^
   D[9] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[9] ^
   C[11] ^ C[12] ^ C[14] ^ C[16] ^ C[17] ^ C[18] ^ C[21] ^
   C[22] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[14] = D[30] ^ D[29] ^ D[25] ^ D[22] ^ D[21] ^ D[19] ^
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^
   D[5] ^ C[5] ^ C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^
   C[14] ^ C[17] ^ C[21] ^ C[22] ^ C[23] ^ C[26] ^ C[28] ^
   C[30] ^ C[31];
   NewCRC[6] = D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[22]
   ^
   D[21] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^ D[11] ^
   D[10] ^ D[9] ^ D[8] ^ D[7] ^ D[5] ^ D[4] ^ D[0] ^ C[0] ^
   C[4] ^ C[5] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[21] ^ C[22] ^
   C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[7] = D[31] ^ D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23]
   ^
   D[22] ^ D[18] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[12] ^
   D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^ D[5] ^ D[1] ^
   C[1] ^ C[5] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^
   C[12] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[18] ^ C[22] ^
   C[23] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[8] = D[25] ^ D[24] ^ D[21] ^ D[19] ^ D[15] ^ D[13] ^ D[11]
   ^
   D[10] ^ D[8] ^ D[5] ^ D[4] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^
   C[4] ^ C[5] ^ C[8] ^ C[10] ^ C[11] ^ C[13] ^ C[15] ^
   C[19] ^ C[21] ^ C[24] ^ C[25];
   NewCRC[9] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[23] ^ D[22] ^ D[21]
   ^
   D[20] ^ D[18] ^ D[17] ^ D[14] ^ D[11] ^ D[8] ^ D[7] ^
   D[4] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[4] ^
   C[7] ^ C[8] ^ C[11] ^ C[14] ^ C[17] ^ C[18] ^ C[20] ^
   C[21] ^ C[22] ^ C[23] ^ C[27] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[10] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^
   D[22] ^
   D[19] ^ D[17] ^ D[16] ^ D[15] ^ D[7] ^ D[6] ^ D[2] ^
   D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[6] ^ C[7] ^ C[15] ^
   C[16] ^ C[17] ^ C[19] ^ C[22] ^ C[24] ^ C[25] ^ C[26] ^
   C[27] ^ C[29] ^ C[30];
   NewCRC[11] = D[21] ^ D[20] ^ D[12] ^ D[9] ^ D[6] ^ D[5] ^ D[4] ^
   D[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[3] ^
   C[4] ^ C[5] ^ C[6] ^ C[9] ^ C[12] ^ C[20] ^ C[21];
   NewCRC[12] = D[22] ^ D[21] ^ D[13] ^ D[10] ^ D[7] ^ D[6] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^
   C[5] ^ C[6] ^ C[7] ^ C[10] ^ C[13] ^ C[21] ^ C[22];
   NewCRC[13] = D[31] ^ D[30] ^ D[28] ^ D[27] ^ D[26] ^ D[25] ^
   D[22] ^
   D[21] ^ D[18] ^ D[17] ^ D[16] ^ D[14] ^ D[12] ^ D[11] ^
   D[9] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[9] ^
   C[11] ^ C[12] ^ C[14] ^ C[16] ^ C[17] ^ C[18] ^ C[21] ^
   C[22] ^ C[25] ^ C[26] ^ C[27] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[14] = D[30] ^ D[29] ^ D[25] ^ D[22] ^ D[21] ^ D[19] ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[16] ^
   D[15] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^ D[6] ^
   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^
   C[6] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[15] ^
   C[16] ^ C[19] ^ C[21] ^ C[22] ^ C[25] ^ C[29] ^ C[30];
   NewCRC[15] = D[31] ^ D[30] ^ D[26] ^ D[23] ^ D[22] ^ D[20] ^
   D[17] ^
   D[16] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^
   C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^ C[14] ^ C[16] ^
   C[17] ^ C[20] ^ C[22] ^ C[23] ^ C[26] ^ C[30] ^ C[31];
   NewCRC[16] = D[31] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^ D[18] ^
   D[17] ^
   D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
   D[5] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[5] ^ C[7] ^ C[8] ^
   C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[15] ^ C[17] ^ C[18] ^
   C[21] ^ C[23] ^ C[24] ^ C[27] ^ C[31];
   NewCRC[17] = D[28] ^ D[25] ^ D[24] ^ D[22] ^ D[19] ^ D[18] ^
   D[16] ^
   D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^
   D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^
   C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^ C[19] ^ C[22] ^
   C[24] ^ C[25] ^ C[28];
   NewCRC[18] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[21] ^
   D[20] ^
   D[19] ^ D[18] ^ D[16] ^ D[14] ^ D[13] ^ D[11] ^ D[10] ^
   D[8] ^ D[6] ^ D[0] ^ C[0] ^ C[6] ^ C[8] ^ C[10] ^ C[11] ^
   C[13] ^ C[14] ^ C[16] ^ C[18] ^ C[19] ^ C[20] ^ C[21] ^
   C[27] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[19] = D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23] ^ D[22] ^
   D[20] ^
   D[19] ^ D[18] ^ D[16] ^ D[15] ^ D[14] ^ D[11] ^ D[8] ^
   D[6] ^ D[5] ^ D[4] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[4] ^
   C[5] ^ C[6] ^ C[8] ^ C[11] ^ C[14] ^ C[15] ^ C[16] ^
   C[18] ^ C[19] ^ C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[26] ^
   C[27] ^ C[29];
   NewCRC[20] = D[31] ^ D[25] ^ D[24] ^ D[20] ^ D[19] ^ D[18] ^
   D[15] ^
   D[8] ^ D[4] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^
   C[4] ^ C[8] ^ C[15] ^ C[18] ^ C[19] ^ C[20] ^ C[24] ^
   C[25] ^ C[31];
   NewCRC[21] = D[26] ^ D[25] ^ D[21] ^ D[20] ^ D[19] ^ D[16] ^ D[9]
   ^
   D[5] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[5] ^
   C[9] ^ C[16] ^ C[19] ^ C[20] ^ C[21] ^ C[25] ^ C[26];
   NewCRC[22] = D[31] ^ D[30] ^ D[28] ^ D[25] ^ D[23] ^ D[22] ^
   D[20] ^
   D[18] ^ D[16] ^ D[12] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[16] ^
   D[15] ^ D[13] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^ D[6] ^
   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^
   C[6] ^ C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[13] ^ C[15] ^
   C[16] ^ C[19] ^ C[21] ^ C[22] ^ C[25] ^ C[29] ^ C[30];
   NewCRC[15] = D[31] ^ D[30] ^ D[26] ^ D[23] ^ D[22] ^ D[20] ^
   D[17] ^
   D[16] ^ D[14] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^
   C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[11] ^ C[14] ^ C[16] ^
   C[17] ^ C[20] ^ C[22] ^ C[23] ^ C[26] ^ C[30] ^ C[31];
   NewCRC[16] = D[31] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^ D[18] ^
   D[17] ^
   D[15] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
   D[5] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[5] ^ C[7] ^ C[8] ^
   C[9] ^ C[10] ^ C[11] ^ C[12] ^ C[15] ^ C[17] ^ C[18] ^
   C[21] ^ C[23] ^ C[24] ^ C[27] ^ C[31];
   NewCRC[17] = D[28] ^ D[25] ^ D[24] ^ D[22] ^ D[19] ^ D[18] ^
   D[16] ^
   D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[9] ^ D[8] ^ D[6] ^
   D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^ C[9] ^ C[10] ^
   C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^ C[19] ^ C[22] ^
   C[24] ^ C[25] ^ C[28];
   NewCRC[18] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[21] ^
   D[20] ^
   D[19] ^ D[18] ^ D[16] ^ D[14] ^ D[13] ^ D[11] ^ D[10] ^
   D[8] ^ D[6] ^ D[0] ^ C[0] ^ C[6] ^ C[8] ^ C[10] ^ C[11] ^
   C[13] ^ C[14] ^ C[16] ^ C[18] ^ C[19] ^ C[20] ^ C[21] ^
   C[27] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[19] = D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[23] ^ D[22] ^
   D[20] ^
   D[19] ^ D[18] ^ D[16] ^ D[15] ^ D[14] ^ D[11] ^ D[8] ^
   D[6] ^ D[5] ^ D[4] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[4] ^
   C[5] ^ C[6] ^ C[8] ^ C[11] ^ C[14] ^ C[15] ^ C[16] ^
   C[18] ^ C[19] ^ C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[26] ^
   C[27] ^ C[29];
   NewCRC[20] = D[31] ^ D[25] ^ D[24] ^ D[20] ^ D[19] ^ D[18] ^
   D[15] ^
   D[8] ^ D[4] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^
   C[4] ^ C[8] ^ C[15] ^ C[18] ^ C[19] ^ C[20] ^ C[24] ^
   C[25] ^ C[31];
   NewCRC[21] = D[26] ^ D[25] ^ D[21] ^ D[20] ^ D[19] ^ D[16] ^ D[9]
   ^
   D[5] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[5] ^
   C[9] ^ C[16] ^ C[19] ^ C[20] ^ C[21] ^ C[25] ^ C[26];
   NewCRC[22] = D[31] ^ D[30] ^ D[28] ^ D[25] ^ D[23] ^ D[22] ^
   D[20] ^
   D[18] ^ D[16] ^ D[12] ^ D[10] ^ D[9] ^ D[8] ^ D[7] ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[5] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[5] ^
   C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[12] ^ C[16] ^ C[18] ^
   C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[23] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^
   D[19] ^
   D[18] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[7] ^
   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^
   C[7] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^
   C[19] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[24] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^
   D[20] ^
   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[8] ^
   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^
   C[8] ^ C[11] ^ C[12] ^ C[13] ^ C[14] ^ C[17] ^ C[19] ^
   C[20] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[25] = D[29] ^ D[28] ^ D[25] ^ D[23] ^ D[20] ^ D[17] ^
   D[16] ^
   D[15] ^ D[14] ^ D[13] ^ D[8] ^ D[6] ^ D[4] ^ D[3] ^
   D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^
   C[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^ C[23] ^
   C[25] ^ C[28] ^ C[29];
   NewCRC[26] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^
   D[23] ^
   D[15] ^ D[14] ^ D[12] ^ D[8] ^ D[6] ^ D[3] ^ D[1] ^
   D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[6] ^ C[8] ^ C[12] ^ C[14] ^
   C[15] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^
   C[31];
   NewCRC[27] = D[31] ^ D[29] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^
   D[18] ^
   D[17] ^ D[15] ^ D[13] ^ D[12] ^ D[8] ^ D[6] ^ D[5] ^
   D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[5] ^ C[6] ^
   C[8] ^ C[12] ^ C[13] ^ C[15] ^ C[17] ^ C[18] ^ C[21] ^
   C[23] ^ C[24] ^ C[27] ^ C[29] ^ C[31];
   NewCRC[28] = D[31] ^ D[27] ^ D[26] ^ D[24] ^ D[23] ^ D[22] ^
   D[21] ^
   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[8] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^
   C[3] ^ C[4] ^ C[5] ^ C[8] ^ C[12] ^ C[13] ^ C[14] ^
   C[17] ^ C[19] ^ C[21] ^ C[22] ^ C[23] ^ C[24] ^ C[26] ^
   C[27] ^ C[31];
   NewCRC[29] = D[28] ^ D[27] ^ D[25] ^ D[24] ^ D[23] ^ D[22] ^
   D[20] ^
   D[18] ^ D[15] ^ D[14] ^ D[13] ^ D[9] ^ D[6] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^
   C[5] ^ C[6] ^ C[9] ^ C[13] ^ C[14] ^ C[15] ^ C[18] ^
   C[20] ^ C[22] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28];
   NewCRC[30] = D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[23] ^
   D[21] ^
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[5] ^ D[3] ^ D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[5] ^
   C[7] ^ C[8] ^ C[9] ^ C[10] ^ C[12] ^ C[16] ^ C[18] ^
   C[20] ^ C[22] ^ C[23] ^ C[25] ^ C[28] ^ C[30] ^ C[31];
   NewCRC[23] = D[30] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^
   D[19] ^
   D[18] ^ D[16] ^ D[13] ^ D[12] ^ D[11] ^ D[10] ^ D[7] ^
   D[5] ^ D[3] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[5] ^
   C[7] ^ C[10] ^ C[11] ^ C[12] ^ C[13] ^ C[16] ^ C[18] ^
   C[19] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^ C[30];
   NewCRC[24] = D[31] ^ D[30] ^ D[29] ^ D[28] ^ D[26] ^ D[25] ^
   D[20] ^
   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[11] ^ D[8] ^
   D[6] ^ D[4] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[4] ^ C[6] ^
   C[8] ^ C[11] ^ C[12] ^ C[13] ^ C[14] ^ C[17] ^ C[19] ^
   C[20] ^ C[25] ^ C[26] ^ C[28] ^ C[29] ^ C[30] ^ C[31];
   NewCRC[25] = D[29] ^ D[28] ^ D[25] ^ D[23] ^ D[20] ^ D[17] ^
   D[16] ^
   D[15] ^ D[14] ^ D[13] ^ D[8] ^ D[6] ^ D[4] ^ D[3] ^
   D[2] ^ D[0] ^ C[0] ^ C[2] ^ C[3] ^ C[4] ^ C[6] ^ C[8] ^
   C[13] ^ C[14] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^ C[23] ^
   C[25] ^ C[28] ^ C[29];
   NewCRC[26] = D[31] ^ D[29] ^ D[28] ^ D[27] ^ D[25] ^ D[24] ^
   D[23] ^
   D[15] ^ D[14] ^ D[12] ^ D[8] ^ D[6] ^ D[3] ^ D[1] ^
   D[0] ^ C[0] ^ C[1] ^ C[3] ^ C[6] ^ C[8] ^ C[12] ^ C[14] ^
   C[15] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28] ^ C[29] ^
   C[31];
   NewCRC[27] = D[31] ^ D[29] ^ D[27] ^ D[24] ^ D[23] ^ D[21] ^
   D[18] ^
   D[17] ^ D[15] ^ D[13] ^ D[12] ^ D[8] ^ D[6] ^ D[5] ^
   D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^ C[5] ^ C[6] ^
   C[8] ^ C[12] ^ C[13] ^ C[15] ^ C[17] ^ C[18] ^ C[21] ^
   C[23] ^ C[24] ^ C[27] ^ C[29] ^ C[31];
   NewCRC[28] = D[31] ^ D[27] ^ D[26] ^ D[24] ^ D[23] ^ D[22] ^
   D[21] ^
   D[19] ^ D[17] ^ D[14] ^ D[13] ^ D[12] ^ D[8] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ D[0] ^ C[0] ^ C[1] ^ C[2] ^
   C[3] ^ C[4] ^ C[5] ^ C[8] ^ C[12] ^ C[13] ^ C[14] ^
   C[17] ^ C[19] ^ C[21] ^ C[22] ^ C[23] ^ C[24] ^ C[26] ^
   C[27] ^ C[31];
   NewCRC[29] = D[28] ^ D[27] ^ D[25] ^ D[24] ^ D[23] ^ D[22] ^
   D[20] ^
   D[18] ^ D[15] ^ D[14] ^ D[13] ^ D[9] ^ D[6] ^ D[5] ^
   D[4] ^ D[3] ^ D[2] ^ D[1] ^ C[1] ^ C[2] ^ C[3] ^ C[4] ^
   C[5] ^ C[6] ^ C[9] ^ C[13] ^ C[14] ^ C[15] ^ C[18] ^
   C[20] ^ C[22] ^ C[23] ^ C[24] ^ C[25] ^ C[27] ^ C[28];
   NewCRC[30] = D[29] ^ D[28] ^ D[26] ^ D[25] ^ D[24] ^ D[23] ^
   D[21] ^
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[19] ^ D[16] ^ D[15] ^ D[14] ^ D[10] ^ D[7] ^ D[6] ^
   D[5] ^ D[4] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[4] ^ C[5] ^
   C[6] ^ C[7] ^ C[10] ^ C[14] ^ C[15] ^ C[16] ^ C[19] ^
   C[21] ^ C[23] ^ C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29];
   NewCRC[31] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^
   D[22] ^
   D[20] ^ D[17] ^ D[16] ^ D[15] ^ D[11] ^ D[8] ^ D[7] ^
   D[6] ^ D[5] ^ D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[5] ^ C[6] ^
   C[7] ^ C[8] ^ C[11] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^
   C[22] ^ C[24] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30];
   nextCRC32_D32 = NewCRC;
   end
   endfunction
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   D[19] ^ D[16] ^ D[15] ^ D[14] ^ D[10] ^ D[7] ^ D[6] ^
   D[5] ^ D[4] ^ D[3] ^ D[2] ^ C[2] ^ C[3] ^ C[4] ^ C[5] ^
   C[6] ^ C[7] ^ C[10] ^ C[14] ^ C[15] ^ C[16] ^ C[19] ^
   C[21] ^ C[23] ^ C[24] ^ C[25] ^ C[26] ^ C[28] ^ C[29];
   NewCRC[31] = D[30] ^ D[29] ^ D[27] ^ D[26] ^ D[25] ^ D[24] ^
   D[22] ^
   D[20] ^ D[17] ^ D[16] ^ D[15] ^ D[11] ^ D[8] ^ D[7] ^
   D[6] ^ D[5] ^ D[4] ^ D[3] ^ C[3] ^ C[4] ^ C[5] ^ C[6] ^
   C[7] ^ C[8] ^ C[11] ^ C[15] ^ C[16] ^ C[17] ^ C[20] ^
   C[22] ^ C[24] ^ C[25] ^ C[26] ^ C[27] ^ C[29] ^ C[30];
   nextCRC32_D32 = NewCRC;
   end
   endfunction
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 Some Hardware Implementation Comments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 一些硬件实现注释
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The iSCSI spec specifies that the most significant 32 bits of the data be complemented prior to performing the CRC computation. For most implementations of the CRC algorithm, such as the ones described here, which perform simultaneous multiplication by x^32 and division by the CRC polynomial, this is equivalent to initializing the CRC register to ones regardless of the CRC polynomial. For other implementations, in particular one that only performs division by the CRC polynomial (and for which the prescribed multiplication by x^32 is performed externally) initializing the CRC register to ones does not have the same effect as complementing the most significant 32 bits of the message. With such implementations, for the CRC32c polynomial, initializing the CRC register to 0x2a26f826 has the same effect as complementing the most significant 32 bits of the data. See reference [Tuikov&amp;Cavanna] for more details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iSCSI规范规定，在执行CRC计算之前，对数据的最高有效32位进行补充。对于CRC算法的大多数实现，例如这里描述的，执行x^32的同时乘法和CRC多项式的除法，这相当于将CRC寄存器初始化为1，而不管CRC多项式如何。对于其他实现，尤其是仅执行CRC多项式除法（且外部执行规定的x^32乘法）的实现，将CRC寄存器初始化为1与补充消息的最高有效32位的效果不同。对于这样的实现，对于CRC32c多项式，将CRC寄存器初始化为0x2a26f826与补充数据的最高有效32位具有相同的效果。更多详情请参见参考文献[Tuikov&amp;Cavanna]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4 Fast Hardware Implementation References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.4 快速硬件实现参考
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fast hardware implementations start from a canonic scheme (as the one presented in 7.2) and optimize it based on different criteria. Two classic papers on this subject are [Albertengo1990] and [Glaise1997]. A more modern (and systematic) approach can be found in [Shie2001] and [Sprachman2001].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
快速硬件实现从规范方案（如7.2中所示）开始，并基于不同标准对其进行优化。关于这一主题的两篇经典论文是[Albertengo1990]和[Glaise1997]。在[Shie2001]和[2001]中可以找到一种更现代（更系统）的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Summary and Conclusions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 摘要和结论
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following table is a summary of the error detection capabilities of the different codes analyzed. In the table, d is the minimal distance at block length block (in bits), i/byte - software instructions/byte, Table size (if table lookup needed), T-look number of lookups/byte, Pudb - Pud burst and Puds - Pud sporadic:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下表总结了所分析的不同代码的错误检测能力。在表中，d是块长度块（位）、i/字节-软件指令/字节、表大小（如果需要查表）、T-查找数/字节、Pudb-Pud突发和Puds-Pud突发的最小距离：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------------------------------------------+
   | Code      |d| Block |i/Byte|Tsize|T-look| Pudb   | Puds   |
   +-----------------------------------------------------------+
   | Fletcher32|3| 2^19  | 2    |  -  | -    | 10^-37 | 10^-36 |
   +-----------------------------------------------------------+
   | Adler32   |3| 2^19  | 3    |  -  | -    | 10^-36 | 10^-35 |
   +-----------------------------------------------------------+
   | IEEE-802  |3| 2^16  | 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |
   +-----------------------------------------------------------+
   | CRC32C    |3| 2^31-1| 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |
   +-----------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------------------------------------------+
   | Code      |d| Block |i/Byte|Tsize|T-look| Pudb   | Puds   |
   +-----------------------------------------------------------+
   | Fletcher32|3| 2^19  | 2    |  -  | -    | 10^-37 | 10^-36 |
   +-----------------------------------------------------------+
   | Adler32   |3| 2^19  | 3    |  -  | -    | 10^-36 | 10^-35 |
   +-----------------------------------------------------------+
   | IEEE-802  |3| 2^16  | 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |
   +-----------------------------------------------------------+
   | CRC32C    |3| 2^31-1| 2.75 | 2^18| 0.5/b| 10^-41 | 10^-40 |
   +-----------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The probabilities for undetected errors in the above table are computed assuming uniformly distributed data. For real data - that can be biased - [Stone98], checksums behave substantially worse than CRCs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设数据均匀分布，计算上表中未检测到错误的概率。对于可能有偏差的真实数据[Stone98]，校验和的表现比CRC差得多。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Considering the protection level it offers, the lack of sensitivity for biased data and the large block it can protect, we think that CRC32C is a good choice as a basic error detection mechanism for iSCSI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑到它提供的保护级别、对有偏数据缺乏敏感性以及它可以保护的大数据块，我们认为CRC32C是一个很好的选择，可以作为iSCSI的基本错误检测机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Please observe also that burst errors characterized by a fixed average time will have a higher impact on error detection capability as the speed of the channels (machines and networks) increases. The only way to keep the Pud within bounds for the long-term is to reduce the BER by using better coding of lower levels of the channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还请注意，随着信道（机器和网络）速度的增加，以固定平均时间为特征的突发错误将对错误检测能力产生更大的影响。长期保持Pud在一定范围内的唯一方法是通过对较低级别的信道进行更好的编码来降低误码率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These codes detect unintentional changes to data such as those caused by noise. In an environment where an attacker can change the data, it can also change the error-detection code to match the new data. Therefore, the error-detection codes overviewed here do not provide protection against attacks. Indeed, these codes are not intended for security purposes; they are meant to be used within some application, and the application&#39;s threat model and security design control the security considerations for the use of the CRC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些代码检测数据的意外更改，例如由噪声引起的更改。在攻击者可以更改数据的环境中，攻击者还可以更改错误检测代码以匹配新数据。因此，此处概述的错误检测代码不能提供针对攻击的保护。事实上，这些代码并非出于安全目的；它们用于某些应用程序中，应用程序的威胁模型和安全设计控制使用CRC的安全考虑。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References and Bibliography
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 参考文献和参考书目
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Albertengo1990] G. Albertengo, R. Sisto, &#34;Parallel CRC Generation IEEE Micro&#34;, Vol. 10, No. 5, October 1990, pp. 63- 71.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Albertengo1990]G.Albertengo，R.Sisto，“并行CRC生成IEEE Micro”，第10卷，第5期，1990年10月，第63-71页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Arazi] B Arazi, &#34;A commonsense Approach to the Theory of Error Correcting codes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Arazi]B Arazi，“纠错码理论的常识方法”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Baicheva] T Baicheva, S Dodunekov and P Kazakov, &#34;Undetected error probability performance of cyclic redundancy-check codes of 16-bit redundancy&#34;, IEEE Proceedings on Communications, 147:253-256, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Baicheva]T Baicheva，S Dodunekov和P Kazakov，“16位冗余循环冗余校验码的未检测错误概率性能”，IEEE通信学报，147:253-256，2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Black] &#34;Fast CRC32 in Software&#34; by Richard Black, 1994, at www.cl.cam.ac.uk/Research/SRG/bluebook/21/crc/crc. html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[黑色]“软件中的快速CRC32”，Richard Black，1994年，www.cl.cam.ac.uk/Research/SRG/bluebook/21/crc/crc。html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Castagnoli93] Guy Castagnoli, Stefan Braeuer and Martin Herrman &#34;Optimization of Cyclic Redundancy-Check Codes with 24 and 32 Parity Bits&#34;, IEEE Transact. on Communications, Vol. 41, No. 6, June 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Castagnoli93]Guy Castagnoli、Stefan Braeuer和Martin Herrman，“具有24和32奇偶校验位的循环冗余校验码的优化”，IEEE Transact。《来文》，第41卷，第6期，1993年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[braun01] Florian Braun and Marcel Waldvogel, &#34;Fast Incremental CRC Updates for IP over ATM Networks&#34;, IEEE, High Performance Switching and Routing, 2001, pp. 48-52.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[braun01]Florian Braun和Marcel Waldvogel，“ATM网络上IP的快速增量CRC更新”，IEEE，高性能交换和路由，2001年，第48-52页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FITS] &#34;NASA FITS documents&#34; at http://heasarc.gsfc.nasa. gov/docs/heasarc/ofwg/docs/general/checksum/node26. html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[适合]“NASA适合文件”在http://heasarc.gsfc.nasa. gov/docs/heasrc/ofwg/docs/general/checksum/node26。html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Fujiwara89] Toru Fujiwara, Tadao Kasami, and Shu Lin, &#34;Error detecting capabilities of the shortened hamming codes adopted forerror detection in IEEE standard 802.3&#34;, IEEE Transactions on Communications, COM-37:986989, September 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Fujiwara89]Toru Fujiwara，Tadao Kasami和Shu Lin，“IEEE标准802.3中用于错误检测的缩短汉明码的错误检测能力”，IEEE通信事务，COM-37:9869891989年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Glaise1997] Glaise, R. J., &#34;A two-step computation of cyclic redundancy code CRC-32 for ATM networks&#34;, IBM Journal of Research and Development, Volume 41, Number 6, 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Glaise1997]Glaise，R.J.，“ATM网络循环冗余码CRC-32的两步计算”，IBM研究与发展杂志，第41卷，第6期，1997年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ieee1364] IEEE Standard Hardware Description Language Based on the Verilog Hardware Description Language, IEEE Standard 1364-1995, December 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ieee1364]基于Verilog硬件描述语言的IEEE标准硬件描述语言，IEEE标准1364-1995，1995年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LinCostello] S. Lin and D.J. Costello, Jr., &#34;Error Control Coding: Fundamentals and Applications&#34;, Englewood Cliffs, NJ: Prentice Hall, 1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[LinCostello]S.Lin和D.J.Costello，Jr.，“差错控制编码：基础和应用”，新泽西州恩格尔伍德悬崖：普伦蒂斯大厅，1983年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Peterson] W Wesley Peterson &amp; E J Weldon - Error Correcting Codes - First Edition 1961/Second Edition 1972.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Peterson]W Wesley Peterson&amp;E J Weldon-纠错码-1961年第一版/1972年第二版。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2026] Bradner, S., &#34;The Internet Standards Process -- Revision 3&#34;, BCP 9, RFC 2026, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2026]Bradner，S.，“互联网标准过程——第3版”，BCP 9，RFC 2026，1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ritter] Ritter, T. 1986. The Great CRC Mystery. Dr. Dobb&#39;s Journal of Software Tools. February. 11(2): 26-34, 76-83.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ritter]Ritter，T.1986年。大秘密。Dobb博士的软件工具杂志。二月11(2): 26-34, 76-83.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Polynomials] &#34;Information on Primitive and Irreducible Polynomials&#34; at http://www.theory.csc.uvic.ca/~cos/ inf/neck/PolyInfo.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[多项式]“关于本原多项式和不可约多项式的信息”，见http://www.theory.csc.uvic.ca/~cos/inf/neck/PolyInfo.html。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1146] Zweig, J. and C. Partridge, &#34;TCP Alternate Checksum Options&#34;, RFC 1146, March 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1146]Zweig，J.和C.Partridge，“TCP备用校验和选项”，RFC 11461990年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1950] Deutsch, P. and J. Gailly, &#34;ZLIB Compressed Data Format Specification version 3.3&#34;, RFC 1950, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1950]Deutsch，P.和J.Gailly，“ZLIB压缩数据格式规范3.3版”，RFC1950，1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shie2001] Ming-Der Shieh, et. al, &#34;A Systematic Approach for Parallel CRC Computations&#34;, Journal of Information Science and Engineering, Vol.17 No.3, pp.445-461.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Shie2001]明德谢等，“并行CRC计算的系统方法”，《信息科学与工程杂志》，第17卷第3期，445-461页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sprachman2001] Michael Sprachman, &#34;Automatic Generation of Parallel CRC Circuits&#34;, IEEE Design &amp; Test May-June 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sprachman 2001]Michael Sprachman，“并行CRC电路的自动生成”，IEEE设计与测试，2001年5月至6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Stone98] J. Stone et. al., &#34;Performance of Checksums and CRC&#39;s over Real Data&#34;, IEEE/ACM Transactions on Networking, Vol. 6, No. 5, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Stone98]J.Stone等人，“校验和和和CRC对真实数据的性能”，IEEE/ACM网络交易，第6卷，第5期，1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [Williams]       Ross Williams - A PAINLESS GUIDE TO CRC ERROR
                    DETECTION ALGORITHMS widely available on the net -
                    (e.g., ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [Williams]       Ross Williams - A PAINLESS GUIDE TO CRC ERROR
                    DETECTION ALGORITHMS widely available on the net -
                    (e.g., ftp.adelaide.edu.au/pub/rocksoft/crc_v3.txt)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf82] J.K. Wolf, Arnold Michelson and Allen Levesque, &#34;On the probability of undetected error for linear block codes&#34;, IEEE Transactions on Communications, COM-30: 317-324, 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf82]J.K.Wolf，Arnold Michelson和Allen Levesque，“关于线性分组码未检测到错误的概率”，IEEE通信交易，COM-30:317-324，1982。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf88] J.K. Wolf, R.D. Blackeney, &#34;An Exact Evaluation of the Probability of Undetected Error for Certain Shortened Binary CRC Codes&#34;, Proc. MILCOM - IEEE 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf88]J.K.Wolf，R.D.Blackeney，“某些缩短二进制CRC码未检测到错误概率的精确评估”，Proc。MILCOM-IEEE 1988。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf94J] J.K. Wolf and Dexter Chun, &#34;The single burst error detection performance of binary cyclic codes&#34;, IEEE Transactions on Communications COM-42:11-13, January 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf94J]J.K.Wolf和Dexter Chun，“二进制循环码的单突发错误检测性能”，IEEE通信事务COM-42:11-13，1994年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf94O] Dexter Chun and J.K. Wolf, &#34;Special Hardware for computing the probability of undetected error for certain binary crc codes and test results&#34;, IEEE Transactions on Communications, COM-42:2769-2772.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Wolf94O]Dexter Chun和J.K.Wolf，“计算某些二进制crc码未检测到错误概率的特殊硬件和测试结果”，IEEE通信交易，COM-42:2769-2772。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Tuikov&amp;Cavanna] Luben Tuikov and Vicente Cavanna, &#34;The iSCSI CRC32C Digest and the Simultaneous Multiply and Divide Algorithm&#34;, January 30, 2002. White paper distributed to the IETF ips iSCSI reflector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Tuikov和Cavanna]Luben Tuikov和Vicente Cavanna，“iSCSI CRC32C摘要和同步乘除算法”，2002年1月30日。分发给IETF ips iSCSI反射器的白皮书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We would like to thank Matt Wakeley for providing us with the motivation to co-author this paper and for helpful discussions on the subject matter, during his employment with Agilent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们要感谢Matt Wakeley，感谢他在安捷伦任职期间为我们提供了共同撰写本文的动力，并就主题进行了有益的讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 作者地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Julian Satran IBM, Haifa Research Lab MATAM - Advanced Technology Center Haifa 31905, Israel EMail: julian_satran@il.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Julian Satran IBM，海法研究实验室MATAM-高级技术中心海法31905，以色列电子邮件：Julian_satran@il.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dafna Sheinwald IBM, Haifa Research Lab MATAM - Advanced Technology Center Haifa 31905, Israel EMail: Dafna_Sheinwald@il.ibm.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dafna Sheinwald IBM，海法研究实验室MATAM-以色列海法先进技术中心31905电子邮件：Dafna_Sheinwald@il.ibm.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pat Thaler Agilent Technologies 1101 Creekside Ridge Drive Suite 100, M/S RH21 Roseville, CA 95661 EMail: pat_thaler@agilent.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pat Thaler Agilent Technologies 1101 Creekside Ridge Drive Suite 100，南加利福尼亚州罗斯维尔RH21号，邮编95661电子邮件：Pat_thaler@agilent.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vicente Cavanna Agilent Technologies 1101 Creekside Ridge Drive Suite 100, M/S RH21 Roseville, CA 95661 EMail: vince_cavanna@agilent.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
维森特·卡瓦纳·安捷伦科技有限公司，地址：加利福尼亚州罗斯维尔市西南RH21号克里克赛德山脊大道1101号套房，邮编：95661电子邮件：文斯_cavanna@agilent.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. 完整版权声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2002). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2002年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
确认
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC编辑功能的资金目前由互联网协会提供。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
