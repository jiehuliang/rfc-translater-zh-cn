<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 5681: TCP Congestion Control中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC 5681: TCP Congestion Control中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">5681</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc5681">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 5681: TCP Congestion Control 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc5681">
              https://datatracker.ietf.org/doc/html/rfc5681
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 5681</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          M. Allman
Request for Comments: 5681                                     V. Paxson
Obsoletes: 2581                                                     ICSI
Category: Standards Track                                     E. Blanton
                                                       Purdue University
                                                          September 2009
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          M. Allman
Request for Comments: 5681                                     V. Paxson
Obsoletes: 2581                                                     ICSI
Category: Standards Track                                     E. Blanton
                                                       Purdue University
                                                          September 2009
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
TCP Congestion Control
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-25">
拥挤控制算法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines TCP&#39;s four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods. This document obsoletes RFC 2581.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档定义了TCP的四种交织的拥塞控制算法：慢启动、拥塞避免、快速重传和快速恢复。此外，本文档还规定了TCP在相对较长的空闲时间后应如何开始传输，并讨论了各种确认生成方法。本文件废除了RFC 2581。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（c）2009 IETF信托基金和确定为文件作者的人员。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents in effect on the date of publication of this document (http://trustee.ietf.org/license-info). Please review these documents carefully, as they describe your rights and restrictions with respect to this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和IETF信托在本文件出版之日生效的与IETF文件有关的法律规定的约束(http://trustee.ietf.org/license-info). 请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件可能包含2008年11月10日之前发布或公开的IETF文件或IETF贡献中的材料。控制某些材料版权的人员可能未授予IETF信托允许在IETF标准流程之外修改此类材料的权利。在未从控制此类材料版权的人员处获得充分许可的情况下，不得在IETF标准流程之外修改本文件，其衍生作品可能会
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不得在IETF标准流程之外创建，除非将其格式化以RFC形式发布，或将其翻译成英语以外的语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table Of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................2
   2. Definitions .....................................................3
   3. Congestion Control Algorithms ...................................4
      3.1. Slow Start and Congestion Avoidance ........................4
      3.2. Fast Retransmit/Fast Recovery ..............................8
   4. Additional Considerations ......................................10
      4.1. Restarting Idle Connections ...............................10
      4.2. Generating Acknowledgments ................................11
      4.3. Loss Recovery Mechanisms ..................................12
   5. Security Considerations ........................................13
   6. Changes between RFC 2001 and RFC 2581 ..........................13
   7. Changes Relative to RFC 2581 ...................................14
   8. Acknowledgments ................................................15
   9. References .....................................................15
      9.1. Normative References ......................................15
      9.2. Informative References ....................................16
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................2
   2. Definitions .....................................................3
   3. Congestion Control Algorithms ...................................4
      3.1. Slow Start and Congestion Avoidance ........................4
      3.2. Fast Retransmit/Fast Recovery ..............................8
   4. Additional Considerations ......................................10
      4.1. Restarting Idle Connections ...............................10
      4.2. Generating Acknowledgments ................................11
      4.3. Loss Recovery Mechanisms ..................................12
   5. Security Considerations ........................................13
   6. Changes between RFC 2001 and RFC 2581 ..........................13
   7. Changes Relative to RFC 2581 ...................................14
   8. Acknowledgments ................................................15
   9. References .....................................................15
      9.1. Normative References ......................................15
      9.2. Informative References ....................................16
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies four TCP [RFC793] congestion control algorithms: slow start, congestion avoidance, fast retransmit and fast recovery. These algorithms were devised in [Jac88] and [Jac90]. Their use with TCP is standardized in [RFC1122]. Additional early work in additive-increase, multiplicative-decrease congestion control is given in [CJ89].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档指定了四种TCP[RFC793]拥塞控制算法：慢启动、拥塞避免、快速重传和快速恢复。这些算法是在[Jac88]和[Jac90]中设计的。[RFC1122]中对其与TCP的使用进行了标准化。[CJ89]中给出了加性增加、乘性减少拥塞控制的其他早期工作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that [Ste94] provides examples of these algorithms in action and [WS95] provides an explanation of the source code for the BSD implementation of these algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，[Ste94]提供了这些算法的实例，[WS95]提供了这些算法的BSD实现的源代码解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to specifying these congestion control algorithms, this document specifies what TCP connections should do after a relatively long idle period, as well as specifying and clarifying some of the issues pertaining to TCP ACK generation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了指定这些拥塞控制算法外，本文档还指定了TCP连接在相对较长的空闲时间后应该做什么，以及指定和澄清与TCP ACK生成相关的一些问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes [RFC2581], which in turn obsoleted [RFC2001].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件淘汰了[RFC2581]，而后者又淘汰了[RFC2001]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is organized as follows. Section 2 provides various definitions that will be used throughout the document. Section 3 provides a specification of the congestion control algorithms. Section 4 outlines concerns related to the congestion control algorithms and finally, section 5 outlines security considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件的组织结构如下。第2节提供了贯穿本文件的各种定义。第3节提供了拥塞控制算法的规范。第4节概述了与拥塞控制算法相关的问题，最后，第5节概述了安全注意事项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC2119]中所述进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides the definition of several terms that will be used throughout the remainder of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节提供了本文件其余部分将使用的几个术语的定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SEGMENT: A segment is ANY TCP/IP data or acknowledgment packet (or both).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
段：段是任何TCP/IP数据或确认数据包（或两者）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SENDER MAXIMUM SEGMENT SIZE (SMSS): The SMSS is the size of the largest segment that the sender can transmit. This value can be based on the maximum transmission unit of the network, the path MTU discovery [RFC1191, RFC4821] algorithm, RMSS (see next item), or other factors. The size does not include the TCP/IP headers and options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送方最大段大小（SMSS）：SMSS是发送方可以传输的最大段的大小。该值可以基于网络的最大传输单位、路径MTU发现[RFC1191、RFC4821]算法、RMS（见下一项）或其他因素。该大小不包括TCP/IP头和选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECEIVER MAXIMUM SEGMENT SIZE (RMSS): The RMSS is the size of the largest segment the receiver is willing to accept. This is the value specified in the MSS option sent by the receiver during connection startup. Or, if the MSS option is not used, it is 536 bytes [RFC1122]. The size does not include the TCP/IP headers and options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收器最大段大小（RMSS）：RMSS是接收器愿意接受的最大段的大小。这是连接启动期间接收器发送的MSS选项中指定的值。或者，如果未使用MSS选项，则为536字节[RFC1122]。该大小不包括TCP/IP头和选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FULL-SIZED SEGMENT: A segment that contains the maximum number of data bytes permitted (i.e., a segment containing SMSS bytes of data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全尺寸段：包含允许的最大数据字节数的段（即，包含SMSS字节数据的段）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RECEIVER WINDOW (rwnd): The most recently advertised receiver window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收者窗口（rwnd）：最近公布的接收者窗口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CONGESTION WINDOW (cwnd): A TCP state variable that limits the amount of data a TCP can send. At any given time, a TCP MUST NOT send data with a sequence number higher than the sum of the highest acknowledged sequence number and the minimum of cwnd and rwnd.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拥塞窗口（cwnd）：限制TCP可以发送的数据量的TCP状态变量。在任何给定时间，TCP发送的数据的序列号不得高于最高确认序列号与最小cwnd和rwnd之和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
INITIAL WINDOW (IW): The initial window is the size of the sender&#39;s congestion window after the three-way handshake is completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始窗口（IW）：初始窗口是三方握手完成后发送方拥塞窗口的大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LOSS WINDOW (LW): The loss window is the size of the congestion window after a TCP sender detects loss using its retransmission timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
丢失窗口（LW）：丢失窗口是TCP发送方使用其重传计时器检测到丢失后拥塞窗口的大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RESTART WINDOW (RW): The restart window is the size of the congestion window after a TCP restarts transmission after an idle period (if the slow start algorithm is used; see section 4.1 for more discussion).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新启动窗口（RW）：重新启动窗口是TCP在空闲时间后重新启动传输后拥塞窗口的大小（如果使用慢启动算法；有关更多讨论，请参阅第4.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FLIGHT SIZE: The amount of data that has been sent but not yet cumulatively acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
航班大小：已发送但尚未累计确认的数据量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DUPLICATE ACKNOWLEDGMENT: An acknowledgment is considered a &#34;duplicate&#34; in the following algorithms when (a) the receiver of the ACK has outstanding data, (b) the incoming acknowledgment carries no data, (c) the SYN and FIN bits are both off, (d) the acknowledgment number is equal to the greatest acknowledgment received on the given connection (TCP.UNA from [RFC793]) and (e) the advertised window in the incoming acknowledgment equals the advertised window in the last incoming acknowledgment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重复确认：在以下算法中，当（a）确认接收器有未完成的数据，（b）传入确认没有数据，（c）SYN和FIN位都关闭，（d）确认号等于给定连接上接收到的最大确认时，确认被视为“重复”（来自[RFC793]的TCP.UNA）和（e）传入确认中的播发窗口等于上次传入确认中的播发窗口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Alternatively, a TCP that utilizes selective acknowledgments (SACKs) [RFC2018, RFC2883] can leverage the SACK information to determine when an incoming ACK is a &#34;duplicate&#34; (e.g., if the ACK contains previously unknown SACK information).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
或者，利用选择性确认（SACK）[RFC2018，RFC2883]的TCP可以利用SACK信息来确定何时传入的ACK是“重复的”（例如，如果ACK包含以前未知的SACK信息）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Congestion Control Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 拥塞控制算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines the four congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery, developed in [Jac88] and [Jac90]. In some situations, it may be beneficial for a TCP sender to be more conservative than the algorithms allow; however, a TCP MUST NOT be more aggressive than the following algorithms allow (that is, MUST NOT send data when the value of cwnd computed by the following algorithms would not allow the data to be sent).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节定义了[Jac88]和[Jac90]中开发的四种拥塞控制算法：慢启动、拥塞避免、快速重传和快速恢复。在某些情况下，TCP发送方比算法允许的更保守可能是有益的；但是，TCP不得比以下算法允许的攻击性更强（即，当以下算法计算的cwnd值不允许发送数据时，不得发送数据）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, note that the algorithms specified in this document work in terms of using loss as the signal of congestion. Explicit Congestion Notification (ECN) could also be used as specified in [RFC3168].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，请注意，本文中指定的算法在使用损耗作为拥塞信号方面起作用。也可以按照[RFC3168]中的规定使用显式拥塞通知（ECN）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Slow Start and Congestion Avoidance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 慢启动和拥塞避免
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The slow start and congestion avoidance algorithms MUST be used by a TCP sender to control the amount of outstanding data being injected into the network. To implement these algorithms, two variables are added to the TCP per-connection state. The congestion window (cwnd) is a sender-side limit on the amount of data the sender can transmit into the network before receiving an acknowledgment (ACK), while the receiver&#39;s advertised window (rwnd) is a receiver-side limit on the amount of outstanding data. The minimum of cwnd and rwnd governs data transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP发送方必须使用慢启动和拥塞避免算法来控制注入网络的未完成数据量。为了实现这些算法，每个连接状态的TCP中添加了两个变量。拥塞窗口（cwnd）是发送方在接收确认（ACK）之前可以向网络传输的数据量的发送方侧限制，而接收方的广告窗口（rwnd）是未完成数据量的接收方侧限制。cwnd和rwnd的最小值控制数据传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another state variable, the slow start threshold (ssthresh), is used to determine whether the slow start or congestion avoidance algorithm is used to control data transmission, as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
另一个状态变量，慢启动阈值（ssthresh），用于确定是否使用慢启动或拥塞避免算法来控制数据传输，如下所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Beginning transmission into a network with unknown conditions requires TCP to slowly probe the network to determine the available capacity, in order to avoid congesting the network with an inappropriately large burst of data. The slow start algorithm is used for this purpose at the beginning of a transfer, or after repairing loss detected by the retransmission timer. Slow start additionally serves to start the &#34;ACK clock&#34; used by the TCP sender to release data into the network in the slow start, congestion avoidance, and loss recovery algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
开始向未知条件下的网络传输时，需要TCP缓慢探测网络以确定可用容量，以避免网络因数据量过大而拥塞。为此，在传输开始时或在修复重传计时器检测到的丢失后，使用慢启动算法。慢速启动还用于启动TCP发送方使用的“ACK时钟”，以慢速启动、拥塞避免和丢失恢复算法将数据释放到网络中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IW, the initial value of cwnd, MUST be set using the following guidelines as an upper bound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IW是cwnd的初始值，必须使用以下准则作为上限进行设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   If SMSS &gt; 2190 bytes:
       IW = 2 * SMSS bytes and MUST NOT be more than 2 segments
   If (SMSS &gt; 1095 bytes) and (SMSS &lt;= 2190 bytes):
       IW = 3 * SMSS bytes and MUST NOT be more than 3 segments
   if SMSS &lt;= 1095 bytes:
       IW = 4 * SMSS bytes and MUST NOT be more than 4 segments
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   If SMSS &gt; 2190 bytes:
       IW = 2 * SMSS bytes and MUST NOT be more than 2 segments
   If (SMSS &gt; 1095 bytes) and (SMSS &lt;= 2190 bytes):
       IW = 3 * SMSS bytes and MUST NOT be more than 3 segments
   if SMSS &lt;= 1095 bytes:
       IW = 4 * SMSS bytes and MUST NOT be more than 4 segments
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As specified in [RFC3390], the SYN/ACK and the acknowledgment of the SYN/ACK MUST NOT increase the size of the congestion window. Further, if the SYN or SYN/ACK is lost, the initial window used by a sender after a correctly transmitted SYN MUST be one segment consisting of at most SMSS bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如[RFC3390]所述，SYN/ACK和SYN/ACK的确认不得增加拥塞窗口的大小。此外，如果SYN或SYN/ACK丢失，发送方在正确传输SYN后使用的初始窗口必须是一个最多包含SMSS字节的段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A detailed rationale and discussion of the IW setting is provided in [RFC3390].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3390]中提供了IW设置的详细原理和讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When initial congestion windows of more than one segment are implemented along with Path MTU Discovery [RFC1191], and the MSS being used is found to be too large, the congestion window cwnd SHOULD be reduced to prevent large bursts of smaller segments. Specifically, cwnd SHOULD be reduced by the ratio of the old segment size to the new segment size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当在路径MTU发现[RFC1191]的同时实现多个段的初始拥塞窗口时，并且发现所使用的MSS太大，则应减小拥塞窗口cwnd以防止较小段的大突发。具体而言，cwnd应减少旧段大小与新段大小的比率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial value of ssthresh SHOULD be set arbitrarily high (e.g., to the size of the largest possible advertised window), but ssthresh MUST be reduced in response to congestion. Setting ssthresh as high as possible allows the network conditions, rather than some arbitrary host limit, to dictate the sending rate. In cases where the end systems have a solid understanding of the network path, more carefully setting the initial ssthresh value may have merit (e.g., such that the end host does not create congestion along the path).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssthresh的初始值应设置为任意高（例如，最大可能广告窗口的大小），但ssthresh必须减小以响应拥塞。将ssthresh设置为尽可能高的值，允许网络条件而不是某些任意主机限制来决定发送速率。在终端系统对网络路径有深入了解的情况下，更仔细地设置初始ssthresh值可能有好处（例如，终端主机不会沿路径造成拥塞）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The slow start algorithm is used when cwnd &lt; ssthresh, while the congestion avoidance algorithm is used when cwnd &gt; ssthresh. When cwnd and ssthresh are equal, the sender may use either slow start or congestion avoidance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当cwnd&lt;ssthresh时使用慢启动算法，当cwnd&gt;ssthresh时使用拥塞避免算法。当cwnd和ssthresh相等时，发送方可以使用慢启动或拥塞避免。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During slow start, a TCP increments cwnd by at most SMSS bytes for each ACK received that cumulatively acknowledges new data. Slow start ends when cwnd exceeds ssthresh (or, optionally, when it reaches it, as noted above) or when congestion is observed. While traditionally TCP implementations have increased cwnd by precisely SMSS bytes upon receipt of an ACK covering new data, we RECOMMEND that TCP implementations increase cwnd, per:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在慢启动过程中，对于接收到的每个累计确认新数据的ACK，TCP最多将cwnd增加SMSS字节。慢启动在cwnd超过ssthresh（或者，可以选择，当它达到ssthresh时，如上所述）或观察到拥塞时结束。虽然传统的TCP实现在接收到覆盖新数据的ACK时将cwnd精确地增加了SMSS字节，但我们建议TCP实现增加cwnd，具体如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
cwnd += min (N, SMSS) (2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
cwnd+=min（N，SMSS）（2）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where N is the number of previously unacknowledged bytes acknowledged in the incoming ACK. This adjustment is part of Appropriate Byte Counting [RFC3465] and provides robustness against misbehaving receivers that may attempt to induce a sender to artificially inflate cwnd using a mechanism known as &#34;ACK Division&#34; [SCWA99]. ACK Division consists of a receiver sending multiple ACKs for a single TCP data segment, each acknowledging only a portion of its data. A TCP that increments cwnd by SMSS for each such ACK will inappropriately inflate the amount of data injected into the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中，N是传入ACK中先前未确认的字节数。此调整是适当字节计数[RFC3465]的一部分，并提供了针对可能试图诱导发送方使用称为“ACK Division”[SCWA99]的机制人为膨胀cwnd的行为不端接收器的鲁棒性。ACK分割包括一个接收器为单个TCP数据段发送多个ACK，每个ACK只确认其数据的一部分。对于每个这样的ACK，通过SMSS增加cwnd的TCP将不适当地增加注入网络的数据量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During congestion avoidance, cwnd is incremented by roughly 1 full-sized segment per round-trip time (RTT). Congestion avoidance continues until congestion is detected. The basic guidelines for incrementing cwnd during congestion avoidance are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在避免拥塞期间，cwnd每往返时间（RTT）大约增加1个完整大小的段。拥塞避免将继续，直到检测到拥塞为止。在避免拥塞期间增加cwnd的基本准则是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* MAY increment cwnd by SMSS bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 可以按SMSS字节递增cwnd
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* SHOULD increment cwnd per equation (2) once per RTT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 应根据方程式（2）每RTT增加一次cwnd
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* MUST NOT increment cwnd by more than SMSS bytes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* cwnd的增量不得超过SMSS字节
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that [RFC3465] allows for cwnd increases of more than SMSS bytes for incoming acknowledgments during slow start on an experimental basis; however, such behavior is not allowed as part of the standard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们注意到，[RFC3465]在实验基础上允许慢启动期间接收确认的cwnd增加超过SMSS字节；但是，此类行为不允许作为标准的一部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED way to increase cwnd during congestion avoidance is to count the number of bytes that have been acknowledged by ACKs for new data. (A drawback of this implementation is that it requires maintaining an additional state variable.) When the number of bytes acknowledged reaches cwnd, then cwnd can be incremented by up to SMSS bytes. Note that during congestion avoidance, cwnd MUST NOT be
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
建议在避免拥塞期间增加cwnd的方法是统计ACK为新数据确认的字节数。（此实现的一个缺点是需要维护一个额外的状态变量。）当确认的字节数达到cwnd时，cwnd最多可以增加SMSS字节。请注意，在避免拥塞期间，不得使用cwnd
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
increased by more than SMSS bytes per RTT. This method both allows TCPs to increase cwnd by one segment per RTT in the face of delayed ACKs and provides robustness against ACK Division attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每RTT增加超过SMSS字节。该方法既允许TCP在面临延迟ACK时将cwnd每RTT增加一段，又提供了对抗ACK分割攻击的鲁棒性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another common formula that a TCP MAY use to update cwnd during congestion avoidance is given in equation (3):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
等式（3）中给出了TCP在避免拥塞期间用于更新cwnd的另一个常用公式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      cwnd += SMSS*SMSS/cwnd                     (3)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      cwnd += SMSS*SMSS/cwnd                     (3)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This adjustment is executed on every incoming ACK that acknowledges new data. Equation (3) provides an acceptable approximation to the underlying principle of increasing cwnd by 1 full-sized segment per RTT. (Note that for a connection in which the receiver is acknowledging every-other packet, (3) is less aggressive than allowed -- roughly increasing cwnd every second RTT.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此调整在确认新数据的每个传入ACK上执行。方程式（3）提供了一个可接受的近似值，用于将cwnd每RTT增加1个完整尺寸段的基本原理。（请注意，对于接收器每隔一个数据包确认一次的连接，（3）的攻击性比允许的要小——大约每秒钟RTT增加一次cwnd。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: Since integer arithmetic is usually used in TCP implementations, the formula given in equation (3) can fail to increase cwnd when the congestion window is larger than SMSS*SMSS. If the above formula yields 0, the result SHOULD be rounded up to 1 byte.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现说明：由于TCP实现中通常使用整数算法，当拥塞窗口大于SMSS*SMSS时，等式（3）中给出的公式可能无法增加cwnd。如果上述公式得出0，则结果应向上舍入到1字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: Older implementations have an additional additive constant on the right-hand side of equation (3). This is incorrect and can actually lead to diminished performance [RFC2525].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现说明：旧的实现在等式（3）的右侧有一个附加的加法常数。这是不正确的，实际上会导致性能降低[RFC2525]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: Some implementations maintain cwnd in units of bytes, while others in units of full-sized segments. The latter will find equation (3) difficult to use, and may prefer to use the counting approach discussed in the previous paragraph.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现说明：一些实现以字节为单位维护cwnd，而另一些实现以全尺寸段为单位。后者将发现等式（3）难以使用，可能更倾向于使用上一段中讨论的计数方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a TCP sender detects segment loss using the retransmission timer and the given segment has not yet been resent by way of the retransmission timer, the value of ssthresh MUST be set to no more than the value given in equation (4):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当TCP发送方使用重传计时器检测到段丢失，且给定段尚未通过重传计时器重新发送时，ssthresh的值必须设置为不大于等式（4）中给出的值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ssthresh = max (FlightSize / 2, 2*SMSS)            (4)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ssthresh = max (FlightSize / 2, 2*SMSS)            (4)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where, as discussed above, FlightSize is the amount of outstanding data in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中，如上所述，FlightSize是网络中未完成的数据量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the other hand, when a TCP sender detects segment loss using the retransmission timer and the given segment has already been retransmitted by way of the retransmission timer at least once, the value of ssthresh is held constant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
另一方面，当TCP发送方使用重传定时器检测到段丢失并且给定段已经通过重传定时器至少重传一次时，ssthresh的值保持恒定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation Note: An easy mistake to make is to simply use cwnd, rather than FlightSize, which in some implementations may incidentally increase well beyond rwnd.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现说明：一个容易犯的错误是简单地使用cwnd，而不是FlightSize，在某些实现中，FlightSize可能会意外地增加到远远超过rwnd。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, upon a timeout (as specified in [RFC2988]) cwnd MUST be set to no more than the loss window, LW, which equals 1 full-sized segment (regardless of the value of IW). Therefore, after retransmitting the dropped segment the TCP sender uses the slow start algorithm to increase the window from 1 full-sized segment to the new value of ssthresh, at which point congestion avoidance again takes over.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，在超时时（如[RFC2988]中所规定），必须将cwnd设置为不超过丢失窗口LW，该窗口等于1个完整大小的段（无论IW的值如何）。因此，在重新传输丢弃的段后，TCP发送方使用慢启动算法将窗口从1个全尺寸段增加到新的ssthresh值，此时拥塞避免再次接管。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As shown in [FF96] and [RFC3782], slow-start-based loss recovery after a timeout can cause spurious retransmissions that trigger duplicate acknowledgments. The reaction to the arrival of these duplicate ACKs in TCP implementations varies widely. This document does not specify how to treat such acknowledgments, but does note this as an area that may benefit from additional attention, experimentation and specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如[FF96]和[RFC3782]所示，超时后缓慢的基于启动的丢失恢复可能会导致伪重传，从而触发重复确认。在TCP实现中，对这些重复ACK的到达的反应差异很大。本文件并未具体说明如何处理此类确认，但指出这是一个可以从额外关注、实验和规范中获益的领域。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Fast Retransmit/Fast Recovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 快速重传/快速恢复
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TCP receiver SHOULD send an immediate duplicate ACK when an out-of-order segment arrives. The purpose of this ACK is to inform the sender that a segment was received out-of-order and which sequence number is expected. From the sender&#39;s perspective, duplicate ACKs can be caused by a number of network problems. First, they can be caused by dropped segments. In this case, all segments after the dropped segment will trigger duplicate ACKs until the loss is repaired. Second, duplicate ACKs can be caused by the re-ordering of data segments by the network (not a rare event along some network paths [Pax97]). Finally, duplicate ACKs can be caused by replication of ACK or data segments by the network. In addition, a TCP receiver SHOULD send an immediate ACK when the incoming segment fills in all or part of a gap in the sequence space. This will generate more timely information for a sender recovering from a loss through a retransmission timeout, a fast retransmit, or an advanced loss recovery algorithm, as outlined in section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当出现故障的数据段到达时，TCP接收器应立即发送重复的ACK。此ACK的目的是通知发送方接收到的数据段顺序错误，以及预期的序列号。从发送方的角度来看，重复的ACK可能由许多网络问题引起。首先，它们可能是由删除的段引起的。在这种情况下，丢弃的段之后的所有段将触发重复ACK，直到丢失得到修复。其次，重复的ACK可能是由网络对数据段重新排序引起的（在某些网络路径[Pax97]上这不是罕见的事件）。最后，网络复制ACK或数据段可能导致重复ACK。此外，当传入段填充序列空间中的全部或部分间隙时，TCP接收器应立即发送ACK。这将为通过重传超时、快速重传或高级丢失恢复算法从丢失中恢复的发送方生成更及时的信息，如第4.3节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TCP sender SHOULD use the &#34;fast retransmit&#34; algorithm to detect and repair loss, based on incoming duplicate ACKs. The fast retransmit algorithm uses the arrival of 3 duplicate ACKs (as defined in section 2, without any intervening ACKs which move SND.UNA) as an indication that a segment has been lost. After receiving 3 duplicate ACKs, TCP performs a retransmission of what appears to be the missing segment, without waiting for the retransmission timer to expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP发送方应使用“快速重传”算法根据传入的重复确认检测和修复丢失。快速重传算法使用3个重复ack的到达（如第2节所定义，没有任何移动SND.UNA的中间ack）作为段丢失的指示。在接收到3个重复的ACK后，TCP将对丢失的段执行重传，而不等待重传计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the fast retransmit algorithm sends what appears to be the missing segment, the &#34;fast recovery&#34; algorithm governs the transmission of new data until a non-duplicate ACK arrives. The reason for not performing slow start is that the receipt of the duplicate ACKs not only indicates that a segment has been lost, but also that segments are most likely leaving the network (although a massive segment duplication by the network can invalidate this conclusion). In other words, since the receiver can only generate a duplicate ACK when a segment has arrived, that segment has left the network and is in the receiver&#39;s buffer, so we know it is no longer consuming network resources. Furthermore, since the ACK &#34;clock&#34; [Jac88] is preserved, the TCP sender can continue to transmit new segments (although transmission must continue using a reduced cwnd, since loss is an indication of congestion).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在快速重传算法发送看似丢失的数据段后，“快速恢复”算法控制新数据的传输，直到非重复ACK到达。不执行慢速启动的原因是，接收到重复的ACK不仅表明某个段已丢失，而且还表明该段极有可能离开网络（尽管网络的大量段复制可能会使该结论无效）。换句话说，由于接收器只能在一个段到达时生成一个重复的ACK，因此该段已经离开网络并在接收器的缓冲区中，因此我们知道它不再消耗网络资源。此外，由于保留了ACK“clock”[Jac88]，TCP发送方可以继续传输新的段（尽管传输必须使用减少的cwnd继续，因为丢失是拥塞的指示）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fast retransmit and fast recovery algorithms are implemented together as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
快速重传和快速恢复算法一起实现，如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. On the first and second duplicate ACKs received at a sender, a TCP SHOULD send a segment of previously unsent data per [RFC3042] provided that the receiver&#39;s advertised window allows, the total FlightSize would remain less than or equal to cwnd plus 2*SMSS, and that new data is available for transmission. Further, the TCP sender MUST NOT change cwnd to reflect these two segments [RFC3042]. Note that a sender using SACK [RFC2018] MUST NOT send new data unless the incoming duplicate acknowledgment contains new SACK information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 在发送方接收到的第一个和第二个重复ACK上，TCP应根据[RFC3042]发送先前未发送的数据段，前提是接收方的广告窗口允许，总FlightSize将保持小于或等于cwnd加2*SMS，并且新数据可用于传输。此外，TCP发送方不得更改cwnd以反映这两个段[RFC3042]。请注意，使用SACK[RFC2018]的发送方不得发送新数据，除非传入的重复确认包含新的SACK信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. When the third duplicate ACK is received, a TCP MUST set ssthresh to no more than the value given in equation (4). When [RFC3042] is in use, additional data sent in limited transmit MUST NOT be included in this calculation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 当接收到第三个重复ACK时，TCP必须将ssthresh设置为不超过等式（4）中给出的值。使用[RFC3042]时，在有限传输中发送的附加数据不得包含在此计算中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. The lost segment starting at SND.UNA MUST be retransmitted and cwnd set to ssthresh plus 3*SMSS. This artificially &#34;inflates&#34; the congestion window by the number of segments (three) that have left the network and which the receiver has buffered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 必须重新传输从SND.UNA开始的丢失段，并将cwnd设置为ssthresh加3*SMSS。这会通过离开网络并由接收方缓冲的段数（三个）人为地“膨胀”拥塞窗口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. For each additional duplicate ACK received (after the third), cwnd MUST be incremented by SMSS. This artificially inflates the congestion window in order to reflect the additional segment that has left the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 对于接收到的每一个额外的重复ACK（在第三次之后），cwnd必须由SMS递增。这会人为地增大拥塞窗口，以反映已离开网络的附加网段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note: [SCWA99] discusses a receiver-based attack whereby many bogus duplicate ACKs are sent to the data sender in order to artificially inflate cwnd and cause a higher than appropriate
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
注：[SCWA99]讨论了一种基于接收者的攻击，即向数据发送者发送许多虚假的重复ACK，以人为地使cwnd膨胀并导致高于适当值的攻击
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
sending rate to be used. A TCP MAY therefore limit the number of times cwnd is artificially inflated during loss recovery to the number of outstanding segments (or, an approximation thereof).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
要使用的发送速率。因此，TCP可将cwnd在损失恢复期间人为膨胀的次数限制为未完成段的数量（或其近似值）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note: When an advanced loss recovery mechanism (such as outlined in section 4.3) is not in use, this increase in FlightSize can cause equation (4) to slightly inflate cwnd and ssthresh, as some of the segments between SND.UNA and SND.NXT are assumed to have left the network but are still reflected in FlightSize.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
注：当高级损失恢复机制（如第4.3节所述）未使用时，FlightSize的增加可能导致等式（4）略微膨胀cwnd和ssthresh，因为假定SND.UNA和SND.NXT之间的一些段已离开网络，但仍反映在FlightSize中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. When previously unsent data is available and the new value of cwnd and the receiver&#39;s advertised window allow, a TCP SHOULD send 1*SMSS bytes of previously unsent data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 当以前未发送的数据可用且cwnd的新值和接收器的播发窗口允许时，TCP应发送1*SMSS字节以前未发送的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. When the next ACK arrives that acknowledges previously unacknowledged data, a TCP MUST set cwnd to ssthresh (the value set in step 2). This is termed &#34;deflating&#34; the window.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 当下一个确认之前未确认的数据的ACK到达时，TCP必须将cwnd设置为ssthresh（步骤2中设置的值）。这被称为“放气”窗口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This ACK should be the acknowledgment elicited by the retransmission from step 3, one RTT after the retransmission (though it may arrive sooner in the presence of significant out-of-order delivery of data segments at the receiver). Additionally, this ACK should acknowledge all the intermediate segments sent between the lost segment and the receipt of the third duplicate ACK, if none of these were lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
此ACK应为从步骤3开始的重传所引发的确认，即重传后一个RTT（尽管在接收器处存在严重的数据段无序交付时，它可能更快到达）。此外，如果所有中间段均未丢失，则此ACK应确认在丢失段和收到第三个重复ACK之间发送的所有中间段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: This algorithm is known to generally not recover efficiently from multiple losses in a single flight of packets [FF96]. Section 4.3 below addresses such cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：已知该算法通常不能有效地从单个数据包的多次丢失中恢复[FF96]。下文第4.3节论述了此类情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Additional Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 其他考虑事项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Restarting Idle Connections
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 重新启动空闲连接
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A known problem with the TCP congestion control algorithms described above is that they allow a potentially inappropriate burst of traffic to be transmitted after TCP has been idle for a relatively long period of time. After an idle period, TCP cannot use the ACK clock to strobe new segments into the network, as all the ACKs have drained from the network. Therefore, as specified above, TCP can potentially send a cwnd-size line-rate burst into the network after an idle period. In addition, changing network conditions may have rendered TCP&#39;s notion of the available end-to-end network capacity between two endpoints, as estimated by cwnd, inaccurate during the course of a long idle period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述TCP拥塞控制算法的一个已知问题是，它们允许在TCP空闲相当长一段时间后传输可能不适当的流量突发。空闲时间过后，TCP无法使用ACK时钟将新段选通到网络中，因为所有ACK都已从网络中排出。因此，如上所述，TCP可能在空闲期后向网络发送cwnd大小的线速率突发。此外，不断变化的网络条件可能使TCP关于两个端点之间可用端到端网络容量的概念（如cwnd所估计的）在长时间空闲期间变得不准确。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jac88] recommends that a TCP use slow start to restart transmission after a relatively long idle period. Slow start serves to restart the ACK clock, just as it does at the beginning of a transfer. This mechanism has been widely deployed in the following manner. When TCP has not received a segment for more than one retransmission timeout, cwnd is reduced to the value of the restart window (RW) before transmission begins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jac88]建议TCP在相对较长的空闲时间后使用慢速启动重新启动传输。慢速启动用于重新启动ACK时钟，就像在传输开始时一样。该机制已通过以下方式广泛部署。当TCP在一个以上的重传超时时间内没有收到一个段时，cwnd将在传输开始之前减少到重新启动窗口（RW）的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the purposes of this standard, we define RW = min(IW,cwnd).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本标准中，我们定义了RW=min（IW，cwnd）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the last time a segment was received to determine whether or not to decrease cwnd can fail to deflate cwnd in the common case of persistent HTTP connections [HTH98]. In this case, a Web server receives a request before transmitting data to the Web client. The reception of the request makes the test for an idle connection fail, and allows the TCP to begin transmission with a possibly inappropriately large cwnd.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在持久HTTP连接的常见情况下，使用最后一次接收段的时间来确定是否减少cwnd可能无法减少cwnd[HTH98]。在这种情况下，Web服务器在将数据传输到Web客户端之前接收请求。接收到请求会导致空闲连接测试失败，并允许TCP使用可能不适当的大cwnd开始传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, a TCP SHOULD set cwnd to no more than RW before beginning transmission if the TCP has not sent data in an interval exceeding the retransmission timeout.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，如果TCP没有在超过重传超时的时间间隔内发送数据，则在开始传输之前，TCP应将cwnd设置为不超过RW。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Generating Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 生成确认
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The delayed ACK algorithm specified in [RFC1122] SHOULD be used by a TCP receiver. When using delayed ACKs, a TCP receiver MUST NOT excessively delay acknowledgments. Specifically, an ACK SHOULD be generated for at least every second full-sized segment, and MUST be generated within 500 ms of the arrival of the first unacknowledged packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接收器应使用[RFC1122]中指定的延迟ACK算法。使用延迟确认时，TCP接收器不得过度延迟确认。具体而言，应至少每秒钟生成一个全尺寸段的ACK，并且必须在第一个未确认数据包到达后500 ms内生成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirement that an ACK &#34;SHOULD&#34; be generated for at least every second full-sized segment is listed in [RFC1122] in one place as a SHOULD and another as a MUST. Here we unambiguously state it is a SHOULD. We also emphasize that this is a SHOULD, meaning that an implementor should indeed only deviate from this requirement after careful consideration of the implications. See the discussion of &#34;Stretch ACK violation&#34; in [RFC2525] and the references therein for a discussion of the possible performance problems with generating ACKs less frequently than every second full-sized segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]中列出了至少每秒钟生成一个完整尺寸段的ACK“应”的要求，其中一处为“应”，另一处为“必须”。在这里，我们毫不含糊地表示，这是一个应该。我们还强调，这是一个应该，也就是说，实施者确实应该在仔细考虑其影响后才偏离这一要求。请参阅[RFC2525]中关于“拉伸ACK冲突”的讨论以及其中的参考文献，以了解生成ACK的频率低于每秒钟全尺寸段的可能性能问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, the sender and receiver may not agree on what constitutes a full-sized segment. An implementation is deemed to comply with this requirement if it sends at least one acknowledgment every time it receives 2*RMSS bytes of new data from the sender, where RMSS is the Maximum Segment Size specified by the receiver to the sender (or the default value of 536 bytes, per [RFC1122], if the receiver does not specify an MSS option during connection
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在某些情况下，发送方和接收方可能无法就什么构成完整的数据段达成一致。如果实现在每次从发送方接收到2*RMSS字节的新数据时发送至少一个确认，则视为符合此要求，其中RMSS是接收方向发送方指定的最大段大小（或根据[RFC1122]的536字节的默认值），如果接收器在连接期间未指定MSS选项
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
establishment). The sender may be forced to use a segment size less than RMSS due to the maximum transmission unit (MTU), the path MTU discovery algorithm or other factors. For instance, consider the case when the receiver announces an RMSS of X bytes but the sender ends up using a segment size of Y bytes (Y &lt; X) due to path MTU discovery (or the sender&#39;s MTU size). The receiver will generate stretch ACKs if it waits for 2*X bytes to arrive before an ACK is sent. Clearly this will take more than 2 segments of size Y bytes. Therefore, while a specific algorithm is not defined, it is desirable for receivers to attempt to prevent this situation, for example, by acknowledging at least every second segment, regardless of size. Finally, we repeat that an ACK MUST NOT be delayed for more than 500 ms waiting on a second full-sized segment to arrive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
机构）。由于最大传输单元（MTU）、路径MTU发现算法或其他因素，发送方可能被迫使用小于rms的段大小。例如，考虑当接收方宣布X字节的RMSS，但发送者由于路径MTU发现（或发送者MTU大小）而使用Y字节（Y＜X）的段大小结束时。如果接收器在发送ACK之前等待2*X字节到达，它将生成拉伸ACK。显然，这将需要2个以上大小为Y字节的段。因此，虽然未定义特定算法，但是期望接收机尝试防止这种情况，例如，通过至少确认每一秒段，而不管大小。最后，我们重申，在等待第二个完整段到达时，ACK的延迟不得超过500 ms。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Out-of-order data segments SHOULD be acknowledged immediately, in order to accelerate loss recovery. To trigger the fast retransmit algorithm, the receiver SHOULD send an immediate duplicate ACK when it receives a data segment above a gap in the sequence space. To provide feedback to senders recovering from losses, the receiver SHOULD send an immediate ACK when it receives a data segment that fills in all or part of a gap in the sequence space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应立即确认无序数据段，以加快丢失恢复。为了触发快速重传算法，当接收器接收到序列空间中间隙上方的数据段时，应立即发送重复ACK。为了向从丢失中恢复的发送方提供反馈，接收方应在接收到填补序列空间中全部或部分空白的数据段时立即发送ACK。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TCP receiver MUST NOT generate more than one ACK for every incoming segment, other than to update the offered window as the receiving application consumes new data (see [RFC813] and page 42 of [RFC793]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP接收器不得为每个传入段生成多个ACK，除非在接收应用程序使用新数据时更新提供的窗口（请参见[RFC813]和[RFC793]第42页）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Loss Recovery Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 损失恢复机制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of loss recovery algorithms that augment fast retransmit and fast recovery have been suggested by TCP researchers and specified in the RFC series. While some of these algorithms are based on the TCP selective acknowledgment (SACK) option [RFC2018], such as [FF96], [MM96a], [MM96b], and [RFC3517], others do not require SACKs, such as [Hoe96], [FF96], and [RFC3782]. The non-SACK algorithms use &#34;partial acknowledgments&#34; (ACKs that cover previously unacknowledged data, but not all the data outstanding when loss was detected) to trigger retransmissions. While this document does not standardize any of the specific algorithms that may improve fast retransmit/fast recovery, these enhanced algorithms are implicitly allowed, as long as they follow the general principles of the basic four algorithms outlined above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP研究人员提出了许多增强快速重传和快速恢复的丢失恢复算法，并在RFC系列中进行了详细说明。虽然其中一些算法基于TCP选择性确认（SACK）选项[RFC2018]，如[FF96]、[MM96a]、[MM96b]和[RFC3517]，但其他算法不需要SACK，如[Hoe96]、[FF96]和[RFC3782]。非SACK算法使用“部分确认”（包括以前未确认的数据，但不是检测到丢失时所有未确认的数据的确认）来触发重传。虽然本文件未对可能改进快速重传/快速恢复的任何特定算法进行标准化，但这些增强算法是隐含允许的，只要它们遵循上述四种基本算法的一般原则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
That is, when the first loss in a window of data is detected, ssthresh MUST be set to no more than the value given by equation (4). Second, until all lost segments in the window of data in question are repaired, the number of segments transmitted in each RTT MUST be no more than half the number of outstanding segments when the loss was detected. Finally, after all loss in the given window of segments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
也就是说，当检测到数据窗口中的第一个丢失时，ssthresh必须设置为不大于等式（4）给出的值。其次，在修复相关数据窗口中所有丢失的段之前，每个RTT中传输的段数不得超过检测到丢失时未完成段数的一半。最后，在给定的段窗口中发生所有损失之后
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
has been successfully retransmitted, cwnd MUST be set to no more than ssthresh and congestion avoidance MUST be used to further increase cwnd. Loss in two successive windows of data, or the loss of a retransmission, should be taken as two indications of congestion and, therefore, cwnd (and ssthresh) MUST be lowered twice in this case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已成功重新传输，cwnd必须设置为不超过ssthresh，并且必须使用拥塞避免来进一步增加cwnd。两个连续的数据窗口中的丢失或重新传输的丢失应被视为拥塞的两个迹象，因此，在这种情况下，cwnd（和ssthresh）必须降低两次。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We RECOMMEND that TCP implementors employ some form of advanced loss recovery that can cope with multiple losses in a window of data. The algorithms detailed in [RFC3782] and [RFC3517] conform to the general principles outlined above. We note that while these are not the only two algorithms that conform to the above general principles these two algorithms have been vetted by the community and are currently on the Standards Track.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们建议TCP实现者采用某种形式的高级丢失恢复，可以在一个数据窗口中处理多个丢失。[RFC3782]和[RFC3517]中详述的算法符合上述一般原则。我们注意到，虽然这不是符合上述一般原则的唯一两种算法，但这两种算法已经过社区审查，目前已进入标准轨道。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document requires a TCP to diminish its sending rate in the presence of retransmission timeouts and the arrival of duplicate acknowledgments. An attacker can therefore impair the performance of a TCP connection by either causing data packets or their acknowledgments to be lost, or by forging excessive duplicate acknowledgments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档要求TCP在存在重传超时和重复确认到达时降低其发送速率。因此，攻击者可以导致数据包或其确认丢失，或伪造过多的重复确认，从而损害TCP连接的性能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In response to the ACK division attack outlined in [SCWA99], this document RECOMMENDS increasing the congestion window based on the number of bytes newly acknowledged in each arriving ACK rather than by a particular constant on each arriving ACK (as outlined in section 3.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
针对[SCWA99]中概述的ACK分割攻击，本文件建议根据每个到达ACK中新确认的字节数，而不是每个到达ACK上的特定常数（如第3.1节所述），增加拥塞窗口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Internet, to a considerable degree, relies on the correct implementation of these algorithms in order to preserve network stability and avoid congestion collapse. An attacker could cause TCP endpoints to respond more aggressively in the face of congestion by forging excessive duplicate acknowledgments or excessive acknowledgments for new data. Conceivably, such an attack could drive a portion of the network into congestion collapse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
互联网在很大程度上依赖于这些算法的正确实现，以保持网络稳定并避免拥塞崩溃。攻击者可以伪造过多的重复确认或过多的新数据确认，从而使TCP端点在遇到拥塞时做出更积极的响应。可以想象，这样的攻击会导致部分网络陷入拥塞崩溃。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Changes between RFC 2001 and RFC 2581
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. RFC 2001和RFC 2581之间的变化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2001] was extensively rewritten editorially and it is not feasible to itemize the list of changes between [RFC2001] and [RFC2581]. The intention of [RFC2581] was to not change any of the recommendations given in [RFC2001], but to further clarify cases that were not discussed in detail in [RFC2001]. Specifically, [RFC2581] suggested what TCP connections should do after a relatively long idle period, as well as specified and clarified some of the issues
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2001]被编辑广泛重写，无法逐项列出[RFC2001]和[RFC2581]之间的变更列表。[RFC2581]的目的是不改变[RFC2001]中给出的任何建议，而是进一步澄清[RFC2001]中未详细讨论的案例。具体而言，[RFC2581]建议了TCP连接在相对较长的空闲时间后应该做什么，并指定和澄清了一些问题
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
pertaining to TCP ACK generation. Finally, the allowable upper bound for the initial congestion window was raised from one to two segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于修饰或说明TCP确认生成。最后，将初始拥塞窗口的允许上限从一段提高到两段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Changes Relative to RFC 2581
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 与RFC 2581相关的变更
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A specific definition for &#34;duplicate acknowledgment&#34; has been added, based on the definition used by BSD TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据BSD TCP使用的定义，添加了“重复确认”的特定定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The document now notes that what to do with duplicate ACKs after the retransmission timer has fired is future work and explicitly unspecified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档现在指出，在重新传输计时器启动后，如何处理重复的ACK是未来的工作，本文档中明确未指定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial window requirements were changed to allow Larger Initial Windows as standardized in [RFC3390]. Additionally, the steps to take when an initial window is discovered to be too large due to Path MTU Discovery [RFC1191] are detailed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始窗口要求已更改，以允许[RFC3390]中标准化的较大初始窗口。此外，还详细说明了由于路径MTU发现[RFC1191]而发现初始窗口过大时要采取的步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The recommended initial value for ssthresh has been changed to say that it SHOULD be arbitrarily high, where it was previously MAY. This is to provide additional guidance to implementors on the matter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ssthresh的建议初始值已更改为任意高，与之前的值相同。这是为了就这一问题向实施者提供额外的指导。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
During slow start, the usage of Appropriate Byte Counting [RFC3465] with L=1*SMSS is explicitly recommended. The method of increasing cwnd given in [RFC2581] is still explicitly allowed. Byte counting during congestion avoidance is also recommended, while the method from [RFC2581] and other safe methods are still allowed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在慢启动期间，明确建议使用L=1*SMS的适当字节计数[RFC3465]。[RFC2581]中给出的增加cwnd的方法仍然是明确允许的。还建议在避免拥塞期间进行字节计数，同时仍然允许使用[RFC2581]中的方法和其他安全方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The treatment of ssthresh on retransmission timeout was clarified. In particular, ssthresh must be set to half the FlightSize on the first retransmission of a given segment and then is held constant on subsequent retransmissions of the same segment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
阐明了在重传超时时ssthresh的处理方法。特别是，ssthresh必须在给定段的第一次重传时设置为FlightSize的一半，然后在同一段的后续重传时保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The description of fast retransmit and fast recovery has been clarified, and the use of Limited Transmit [RFC3042] is now recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
快速重传和快速恢复的描述已经澄清，现在建议使用有限传输[RFC3042]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCPs now MAY limit the number of duplicate ACKs that artificially inflate cwnd during loss recovery to the number of segments outstanding to avoid the duplicate ACK spoofing attack described in [SCWA99].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP现在可以将丢失恢复期间人为膨胀cwnd的重复ACK数量限制为未完成的段数，以避免[SCWA99]中描述的重复ACK欺骗攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The restart window has been changed to min(IW,cwnd) from IW. This behavior was described as &#34;experimental&#34; in [RFC2581].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新启动窗口已从IW更改为min（IW，cwnd）。这种行为在[RFC2581]中被描述为“实验性”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is now recommended that TCP implementors implement an advanced loss recovery algorithm conforming to the principles outlined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在建议TCP实施者实施符合本文档中概述的原则的高级丢失恢复算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security considerations have been updated to discuss ACK division and recommend byte counting as a counter to this attack.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全注意事项已更新，以讨论ACK划分，并建议将字节计数作为对抗此攻击的一种手段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The core algorithms we describe were developed by Van Jacobson [Jac88, Jac90]. In addition, Limited Transmit [RFC3042] was developed in conjunction with Hari Balakrishnan and Sally Floyd. The initial congestion window size specified in this document is a result of work with Sally Floyd and Craig Partridge [RFC2414, RFC3390].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们描述的核心算法是由Van Jacobson[Jac88，Jac90]开发的。此外，与Hari Balakrishnan和Sally Floyd共同开发了有限传输[RFC3042]。本文件中规定的初始拥塞窗口大小是Sally Floyd和Craig Partridge[RFC2414，RFC3390]合作的结果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W. Richard (&#34;Rich&#34;) Stevens wrote the first version of this document [RFC2001] and co-authored the second version [RFC2581]. This present version much benefits from his clarity and thoughtfulness of description, and we are grateful for Rich&#39;s contributions in elucidating TCP congestion control, as well as in more broadly helping us understand numerous issues relating to networking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W.Richard（“Rich”）Stevens编写了本文件的第一个版本[RFC2001]，并与他人共同编写了第二个版本[RFC2581]。本版本得益于他的清晰和周到的描述，我们感谢Rich在阐明TCP拥塞控制以及更广泛地帮助我们理解与网络相关的众多问题方面所做的贡献。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We wish to emphasize that the shortcomings and mistakes of this document are solely the responsibility of the current authors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们希望强调，本文件的缺点和错误完全是现任作者的责任。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the text from this document is taken from &#34;TCP/IP Illustrated, Volume 1: The Protocols&#34; by W. Richard Stevens (Addison-Wesley, 1994) and &#34;TCP/IP Illustrated, Volume 2: The Implementation&#34; by Gary R. Wright and W. Richard Stevens (Addison-Wesley, 1995). This material is used with the permission of Addison-Wesley.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件的部分文本摘自W.Richard Stevens（Addison Wesley，1994）的“TCP/IP图解，第1卷：协议”和Gary R.Wright和W.Richard Stevens（Addison Wesley，1995）的“TCP/IP图解，第2卷：实现”。本材料经Addison Wesley许可使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anil Agarwal, Steve Arden, Neal Cardwell, Noritoshi Demizu, Gorry Fairhurst, Kevin Fall, John Heffner, Alfred Hoenes, Sally Floyd, Reiner Ludwig, Matt Mathis, Craig Partridge, and Joe Touch contributed a number of helpful suggestions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
阿尼尔·阿加瓦尔、史蒂夫·阿登、尼尔·卡德威尔、诺里托·德米祖、戈里·费尔赫斯特、凯文·福尔、约翰·赫夫纳、阿尔弗雷德·霍恩斯、萨利·弗洛伊德、雷纳·路德维格、马特·马蒂斯、克雷格·帕特里奇和乔·图奇提出了许多有益的建议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]Postel，J.，“传输控制协议”，标准7，RFC 793，1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]Braden，R.，Ed.“互联网主机的要求-通信层”，STD 3，RFC 1122，1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191] Mogul, J. and S. Deering, &#34;Path MTU discovery&#34;, RFC 1191, November 1990.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191]Mogul，J.和S.Deering，“MTU发现路径”，RFC1191，1990年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CJ89] Chiu, D. and R. Jain, &#34;Analysis of the Increase/Decrease Algorithms for Congestion Avoidance in Computer Networks&#34;, Journal of Computer Networks and ISDN Systems, vol. 17, no. 1, pp. 1-14, June 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CJ89]Chiu，D.和R.Jain，“计算机网络中避免拥塞的增加/减少算法分析”，《计算机网络和ISDN系统杂志》，第17卷，第1期，第1-14页，1989年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FF96] Fall, K. and S. Floyd, &#34;Simulation-based Comparisons of Tahoe, Reno and SACK TCP&#34;, Computer Communication Review, July 1996, ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FF96]Fall，K.和S.Floyd，“基于模拟的塔霍河、雷诺和萨克TCP的比较”，《计算机通信评论》，1996年7月，ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hoe96] Hoe, J., &#34;Improving the Start-up Behavior of a Congestion Control Scheme for TCP&#34;, In ACM SIGCOMM, August 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Hoe96]Hoe，J.“改进TCP拥塞控制方案的启动行为”，载于ACM SIGCOMM，1996年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTH98] Hughes, A., Touch, J., and J. Heidemann, &#34;Issues in TCP Slow-Start Restart After Idle&#34;, Work in Progress, March 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTH98]Hughes，A.，Touch，J.，和J.Heidemann，“空闲后TCP缓慢启动重启的问题”，正在进行的工作，1998年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jac88] Jacobson, V., &#34;Congestion Avoidance and Control&#34;, Computer Communication Review, vol. 18, no. 4, pp. 314-329, Aug. 1988. ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jac88]Jacobson，V.，“拥塞避免和控制”，《计算机通信评论》，第18卷，第4期，第314-329页，1988年8月。ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jac90] Jacobson, V., &#34;Modified TCP Congestion Avoidance Algorithm&#34;, end2end-interest mailing list, April 30, 1990. ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jac90]Jacobson，V.，“改进的TCP拥塞避免算法”，end2end interest邮件列表，1990年4月30日。ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [MM96a]   Mathis, M. and J. Mahdavi, &#34;Forward Acknowledgment:
             Refining TCP Congestion Control&#34;, Proceedings of
             SIGCOMM&#39;96, August, 1996, Stanford, CA.  Available from
             http://www.psc.edu/networking/papers/papers.html
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [MM96a]   Mathis, M. and J. Mahdavi, &#34;Forward Acknowledgment:
             Refining TCP Congestion Control&#34;, Proceedings of
             SIGCOMM&#39;96, August, 1996, Stanford, CA.  Available from
             http://www.psc.edu/networking/papers/papers.html
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MM96b] Mathis, M. and J. Mahdavi, &#34;TCP Rate-Halving with Bounding Parameters&#34;, Technical report. Available from http://www.psc.edu/networking/papers/FACKnotes/current.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MM96b]Mathis，M.和J.Mahdavi，“带边界参数的TCP速率减半”，技术报告。可从http://www.psc.edu/networking/papers/FACKnotes/current.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pax97] Paxson, V., &#34;End-to-End Internet Packet Dynamics&#34;, Proceedings of SIGCOMM &#39;97, Cannes, France, Sep. 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pax97]Paxson，V.，“端到端互联网数据包动力学”，1997年9月于法国戛纳举行的SIGCOMM&#39;97会议录。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC813] Clark, D., &#34;Window and Acknowledgement Strategy in TCP&#34;, RFC 813, July 1982.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC813]Clark，D.，“TCP中的窗口和确认策略”，RFC813，1982年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2001] Stevens, W., &#34;TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms&#34;, RFC 2001, January 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2001]Stevens，W.“TCP慢启动、拥塞避免、快速重传和快速恢复算法”，RFC 2001，1997年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, &#34;TCP Selective Acknowledgment Options&#34;, RFC 2018, October 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2018]Mathis，M.，Mahdavi，J.，Floyd，S.，和A.Romanow，“TCP选择性确认选项”，RFC 2018，1996年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2414] Allman, M., Floyd, S., and C. Partridge, &#34;Increasing TCP&#39;s Initial Window&#34;, RFC 2414, September 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2414]奥尔曼，M.，弗洛伊德，S.，和C.帕特里奇，“增加TCP的初始窗口”，RFC2414141998年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2525] Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner, J., Heavens, I., Lahey, K., Semke, J., and B. Volz, &#34;Known TCP Implementation Problems&#34;, RFC 2525, March 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2525]Paxson，V.，Allman，M.，Dawson，S.，Fenner，W.，Griner，J.，Skys，I.，Lahey，K.，Semke，J.，和B.Volz，“已知的TCP实施问题”，RFC 25251999年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2581] Allman, M., Paxson, V., and W. Stevens, &#34;TCP Congestion Control&#34;, RFC 2581, April 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2581]Allman，M.，Paxson，V.和W.Stevens，“TCP拥塞控制”，RFC 25811999年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, &#34;An Extension to the Selective Acknowledgement (SACK) Option for TCP&#34;, RFC 2883, July 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2883]Floyd，S.，Mahdavi，J.，Mathis，M.，和M.Podolsky，“TCP选择性确认（SACK）选项的扩展”，RFC 28832000年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2988] Paxson, V. and M. Allman, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 2988, November 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2988]Paxson，V.和M.Allman，“计算TCP的重传计时器”，RFC 2988，2000年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3042] Allman, M., Balakrishnan, H., and S. Floyd, &#34;Enhancing TCP&#39;s Loss Recovery Using Limited Transmit&#34;, RFC 3042, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3042]Allman，M.，Balakrishnan，H.，和S.Floyd，“使用有限传输增强TCP的丢失恢复”，RFC 3042，2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168]Ramakrishnan，K.，Floyd，S.，和D.Black，“向IP添加显式拥塞通知（ECN）”，RFC 3168，2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3390] Allman, M., Floyd, S., and C. Partridge, &#34;Increasing TCP&#39;s Initial Window&#34;, RFC 3390, October 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3390]奥尔曼，M.，弗洛伊德，S.，和C.帕特里奇，“增加TCP的初始窗口”，RFC3390，2002年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3465] Allman, M., &#34;TCP Congestion Control with Appropriate Byte Counting (ABC)&#34;, RFC 3465, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3465]Allman，M.，“具有适当字节计数的TCP拥塞控制（ABC）”，RFC 3465，2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3517] Blanton, E., Allman, M., Fall, K., and L. Wang, &#34;A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP&#34;, RFC 3517, April 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3517]Blanton，E.，Allman，M.，Fall，K.，和L.Wang，“基于保守选择确认（SACK）的TCP丢失恢复算法”，RFC 3517，2003年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782] Floyd, S., Henderson, T., and A. Gurtov, &#34;The NewReno Modification to TCP&#39;s Fast Recovery Algorithm&#34;, RFC 3782, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3782]Floyd，S.，Henderson，T.，和A.Gurtov，“TCP快速恢复算法的NewReno修改”，RFC 3782，2004年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821] Mathis, M. and J. Heffner, &#34;Packetization Layer Path MTU Discovery&#34;, RFC 4821, March 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821]Mathis，M.和J.Heffner，“打包层路径MTU发现”，RFC 48212007年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCWA99] Savage, S., Cardwell, N., Wetherall, D., and T. Anderson, &#34;TCP Congestion Control With a Misbehaving Receiver&#34;, ACM Computer Communication Review, 29(5), October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCWA99]Savage，S.，Cardwell，N.，Wetheral，D.，和T.Anderson，“使用行为不正常接收器的TCP拥塞控制”，ACM计算机通信评论，29（5），1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ste94] Stevens, W., &#34;TCP/IP Illustrated, Volume 1: The Protocols&#34;, Addison-Wesley, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ste94]Stevens，W.“TCP/IP图解，第1卷：协议”，Addison-Wesley，1994年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WS95] Wright, G. and W. Stevens, &#34;TCP/IP Illustrated, Volume 2: The Implementation&#34;, Addison-Wesley, 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[WS95]Wright，G.和W.Stevens，“TCP/IP图解，第2卷：实现”，Addison-Wesley，1995年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark Allman International Computer Science Institute (ICSI) 1947 Center Street Suite 600 Berkeley, CA 94704-1198 Phone: +1 440 235 1792 EMail: mallman@icir.org http://www.icir.org/mallman/
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
马克·奥尔曼国际计算机科学研究所（ICSI）1947年加利福尼亚州伯克利中心街600号套房94704-1198电话：+1 440 235 1792电子邮件：mallman@icir.org http://www.icir.org/mallman/
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Vern Paxson
   International Computer Science Institute (ICSI)
   1947 Center Street
   Suite 600
   Berkeley, CA 94704-1198
   Phone: +1 510/642-4274 x302
   EMail: vern@icir.org
   http://www.icir.org/vern/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Vern Paxson
   International Computer Science Institute (ICSI)
   1947 Center Street
   Suite 600
   Berkeley, CA 94704-1198
   Phone: +1 510/642-4274 x302
   EMail: vern@icir.org
   http://www.icir.org/vern/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Ethan Blanton
   Purdue University Computer Sciences
   305 North University Street
   West Lafayette, IN  47907
   EMail: eblanton@cs.purdue.edu
   http://www.cs.purdue.edu/homes/eblanton/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Ethan Blanton
   Purdue University Computer Sciences
   305 North University Street
   West Lafayette, IN  47907
   EMail: eblanton@cs.purdue.edu
   http://www.cs.purdue.edu/homes/eblanton/
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
