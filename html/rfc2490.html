<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 2490:  A Simulation Model for IP Multicast with RSVP 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC2490 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">打赏</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2490</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2490">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 2490:  A Simulation Model for IP Multicast with RSVP  中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc2490">
              https://datatracker.ietf.org/doc/html/rfc2490
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 2490</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                         M. Pullen
Request for Comments: 2490                      George Mason University
Category: Informational                                      R. Malghan
                                                   Hitachi Data Systems
                                                                L. Lavu
                                                           Bay Networks
                                                                G. Duan
                                                                 Oracle
                                                                  J. Ma
                                                              NewBridge
                                                                 H. Nah
                                                George Mason University
                                                           January 1999
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                         M. Pullen
Request for Comments: 2490                      George Mason University
Category: Informational                                      R. Malghan
                                                   Hitachi Data Systems
                                                                L. Lavu
                                                           Bay Networks
                                                                G. Duan
                                                                 Oracle
                                                                  J. Ma
                                                              NewBridge
                                                                 H. Nah
                                                George Mason University
                                                           January 1999
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
A Simulation Model for IP Multicast with RSVP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
基于RSVP的IP组播仿真模型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本备忘录的状况
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1999年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a detailed model of IPv4 multicast with RSVP that has been developed using the OPNET simulation package [4], with protocol procedures defined in the C language. The model was developed to allow investigation of performance constraints on routing but should have wide applicability in the Internet multicast/resource reservation community. We are making this model publicly available with the intention that it can be used to provide expanded studies of resource-reserved multicasting.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档描述了使用OPNET仿真包[4]开发的带有RSVP的IPv4多播的详细模型，协议过程用C语言定义。该模型旨在研究路由的性能约束，但在Internet多播/资源预留社区中应具有广泛的适用性。我们将此模型公开，目的是它可以用于提供资源保留多播的扩展研究。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Background 2 2. The OPNET Simulation Environment 3 3. IP Multicast Model 3 3.1 Address Format 3 3.2 Network Layer 4 3.3 Node layer 5 4. RSVP Model 13 4.1 RSVP Application 13
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 背景2。OPNET仿真环境3。IP多播模型3 3.1地址格式3 3.2网络层4 3.3节点层5 4。RSVP型号13 4.1 RSVP应用13
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 4.2 RSVP on Routers 14 4.3 RSVP on Hosts 17 5. Multicast Routing Model Interface 19 5.1 Creation of multicast routing processor node 19 5.2 Interfacing processor nodes 19 5.3 Interrupt Generation 21 5.4 Modifications of modules in the process model 22 6. OSPF and MOSPF Models 23 6.1 Init 23 6.2 Idle 23 6.3 BCOspfLsa 23 6.4 BCMospfLsa 23 6.5 Arr 23 6.6 Hello_pks 24 6.7 Mospfspfcalc 24 6.8 Ospfspfcalc 25 6.9 UpstrNode 25 6.10 DABRA 25 7. DVMRP Model 26 7.1 Init 26 7.2 Idle 26 7.3 Probe_Send State 26 7.4 Report_Send 26 7.5 Prune _Send 26 7.6 Graft_send 27 7.7 Arr_Pkt 27 7.8 Route_Calc 28 7.9 Timer 28 8. Simulation performance 28 9. Future Work 29 10. Security Considerations 29 11. References 29 Authors&#39; Addresses 30 Full Copyright Statement 31
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.2路由器上的RSVP 14 4.3主机上的RSVP 17 5。多播路由模型接口19 5.1多播路由处理器节点19 5.2接口处理器节点19 5.3中断生成21 5.4过程模型22 6中模块的修改。OSPF和MOSPF型号23 6.1初始23 6.2空闲23 6.3 BCOspfLsa 23 6.4 BCMospfLsa 23 6.5 Arr 23 6.6 Hello_pks 24 6.7 Mospfspfcalc 24 6.8 OSPFPFCALC 25 6.9 UpstrNode 25 6.10 DABRA 25 7。DVMRP型号26 7.1初始26 7.2空闲26 7.3探测发送状态26 7.4报告发送26 7.5修剪发送26 7.6嫁接发送27 7.7传送27 7.8路由计算28 7.9计时器28 8。模拟性能28 9。今后的工作29 10。安全考虑29 11。参考文献29作者地址30完整版权声明31
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 出身背景
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The successful deployment of IP multicasting [1] and its availability in the Mbone has led to continuing increase in real-time multimedia Internet applications. Because the Internet has traditionally supported only a best-effort quality of service, there is considerable interest to create mechanisms that will allow adequate resources to be reserved in networks using the Internet protocol suite, such that the quality of real-time traffic such as video, voice, and distributed simulation can be sustained at specified levels. The RSVP protocol [2] has been developed for this purpose and is the subject of ongoing implementation efforts. Although the developers of RSVP have used simulation in their design process, no
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP多播[1]的成功部署及其在Mbone中的可用性导致了实时多媒体互联网应用的持续增长。由于互联网传统上只支持尽力而为的服务质量，因此有相当大的兴趣创建机制，允许在使用互联网协议套件的网络中保留足够的资源，以确保实时通信的质量，如视频、语音、，分布式仿真可以在指定的级别上进行。RSVP协议[2]是为此目的而制定的，是正在进行的实施工作的主题。尽管RSVP的开发人员在设计过程中使用了模拟，但没有
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
simulation of IPmc with RSVP has been generally available for analysis of the performance and prediction of the behavior of these protocols. The simulation model described here was developed to fill this gap, and is explicitly intended to be made available to the IETF community.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用RSVP对IPmc进行模拟，通常可用于分析这些协议的性能和预测其行为。本文描述的仿真模型是为了填补这一空白而开发的，并且明确旨在向IETF社区提供。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. The OPNET Simulation Environment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. OPNET仿真环境
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Optimized Network Engineering Tools (OPNET) is a commercial simulation product of the MIL3 company of Arlington, VA. It employs a Discrete Event Simulation approach that allows large numbers of closely-spaced events in a sizable network to be represented accurately and efficiently. OPNET uses a modeling approach where networks are built of components interconnected by perfect links that can be degraded at will. Each component&#39;s behavior is modeled as a state-transition diagram. The process that takes place in each state is described by a program in the C language. We believe this makes the OPNET-based models relatively easy to port to other modeling environments. This family of models is compatible with OPNET 3.5. The following sections describe the state-transition models and process code for the IPmc and RSVP models we have created using OPNET. Please note that an OPNET layer is not necessarily equivalent to a layer in a network stack, but shares with a stack layer the property that it is a highly modular software element with well defined interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
优化网络工程工具（OPNET）是弗吉尼亚州阿灵顿市MIL3公司的一种商业模拟产品。它采用离散事件模拟方法，允许准确有效地表示大型网络中大量密集事件。OPNET使用了一种建模方法，其中网络由可随意降级的完美链路互连的组件构成。每个组件的行为都建模为状态转换图。每个状态下发生的过程由C语言的程序描述。我们相信这使得基于OPNET的模型相对容易移植到其他建模环境。该系列型号与OPNET 3.5兼容。以下各节描述了我们使用OPNET创建的IPmc和RSVP模型的状态转换模型和过程代码。请注意，OPNET层不一定等同于网络堆栈中的层，而是与堆栈层共享一个特性，即它是一个具有良好定义接口的高度模块化软件元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IP Multicast Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. IP多播模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following processing takes place in the indicated modules. Each subsection below describes in detail a layer in the host and the router that can be simulated with the help of the corresponding OPNET network layer or node layer or the process layer, starting from physical layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下处理在所示模块中进行。下面的每一小节都详细描述了主机和路由器中的一个层，该层可以从物理层开始，借助相应的OPNET网络层或节点层或过程层进行模拟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Address format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 地址格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The OPNET IP model has only one type of addressing denoted by &#34;X.Y&#34; where X is 24 bits long and Y is 8 bits long, corresponding to an IPv4 Class C network. The X indicates the destination or the source network number and Y indicates the destination or the source node number. In our model X = 500 is reserved for multicast traffic. For multicast traffic the value of Y indicates the group to which the packet belongs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPNET IP模型只有一种类型的寻址，用“X.Y”表示，其中X为24位长，Y为8位长，对应于IPv4 C类网络。X表示目的地或源网络号，Y表示目的地或源节点号。在我们的模型中，X=500是为多播流量保留的。对于多播流量，Y值表示数据包所属的组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Network Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 网络层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 1 describes an example network topology built using the OPNET network editor. This network consists of two backbone routers BBR1, BBR2, three area border routers ABR1, ABR2, ABR3 and six subnets F1, through F6. As OPNET has no full duplex link model, each connecting link is modeled as two simplex links enabling bidirectional traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图1描述了使用OPNET网络编辑器构建的网络拓扑示例。该网络由两个主干路由器BBR1、BBR2、三个区域边界路由器ABR1、ABR2、ABR3和六个子网F1至F6组成。由于OPNET没有全双工链路模型，每个连接链路被建模为两个单工链路，从而实现双向通信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
[Figure 1: Network Layer of Debug Model]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
[图1：调试模型的网络层]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1 Attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1 属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The attributes of the elements of the network layer are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
网络层元素的属性为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. Area Border Routers and Backbone Routers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. 区域边界路由器和骨干路由器
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. IP address of each active interface of each router (network_id.node_id) 2. Service rate of the IP layer (packets/sec) 3. Transmission speeds of each active interface (bits/sec)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. 每个路由器的每个活动接口的IP地址（网络id.节点id）2。IP层的服务速率（数据包/秒）3。每个活动接口的传输速度（位/秒）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. Subnets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. 子网
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. IP address of each active interface of the router in the subnet 2. IP address of the hosts in each of the subnet. 3. Service rate of the IP layer in the subnet router and the hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. 子网2中路由器的每个活动接口的IP地址。每个子网中主机的IP地址。3.子网路由器和主机中IP层的服务速率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Simplex links
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. 单工链路
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. Propagation delay in the links 2. The process model to be used for simulating the simplex links (this means whether animation is included or not).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. 链路中的传播延迟2。用于模拟单工链接的过程模型（这意味着是否包含动画）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2 LAN Subnets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2 局域网子网
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 2 shows the FDDI ring as used in a subnet. The subnet will have one router and one or more hosts. The router in the subnet is included to route the traffic between the FDDI ring or Ethernet in the corresponding subnet and the external network. The subnet router is connected on one end to Ethernet or FDDI ring and normally also is connected to an area border router on another interface (the area border routers may be connected to more than one backbone router). In the Ethernet all the hosts are connected to the bus, while in FDDI the hosts are interconnected in a ring as illustrated in Figure 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图2显示了子网中使用的FDDI环。子网将有一个路由器和一个或多个主机。子网中的路由器用于在相应子网中的FDDI环或以太网与外部网络之间路由流量。子网路由器一端连接到以太网或FDDI环，通常也连接到另一接口上的区域边界路由器（区域边界路由器可以连接到多个主干路由器）。在以太网中，所有主机都连接到总线，而在FDDI中，主机在环中互连，如图2所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
[Figure 2: FDDI Ring Subnet Layer]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
[图2:FDDI环子网层]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FDDI provides general purpose networking at 100 Mb/sec transmission rates for large numbers of communicating stations configured in a ring topology. Use of ring bandwidth is controlled through a timed token rotation protocol, wherein stations must receive a token and meet with a set of timing and priority criteria before transmitting frames. In order to accommodate network applications in which response times are critical, FDDI provides for deterministic availability of ring bandwidth by defining a synchronous transmission service. Asynchronous frame transmission requests dynamically share the remaining ring bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FDDI以100 Mb/s的传输速率为环形拓扑中配置的大量通信站提供通用网络。环路带宽的使用通过定时令牌旋转协议进行控制，其中站点必须在发送帧之前接收令牌并满足一组定时和优先级标准。为了适应响应时间至关重要的网络应用，FDDI通过定义同步传输服务来提供环带宽的确定可用性。异步帧传输请求动态共享剩余的环带宽。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ethernet is a bus-based local area network (LAN) technology. The operation of the LAN is managed by a media access protocol (MAC) following the IEEE 802.3 standard, providing Carrier Sense Multiple Access with Collision Detection (CSMA/CD) for the LAN channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以太网是一种基于总线的局域网（LAN）技术。LAN的操作由遵循IEEE 802.3标准的媒体访问协议（MAC）管理，为LAN信道提供带冲突检测的载波侦听多址接入（CSMA/CD）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Node layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 节点层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses the internal structure of hosts and routers with the help of node level illustrations built using the Node editor of OPNET.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节借助使用OPNET节点编辑器构建的节点级插图，讨论主机和路由器的内部结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1 Basic OPNET elements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1 基本OPNET元素
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic elements of a node level illustration are
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点级插图的基本元素包括
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. Processor nodes: Processor nodes are used for processing incoming packets and generating packets with a specified packet format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. 处理器节点：处理器节点用于处理传入数据包并生成具有指定数据包格式的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. Queue node: Queue nodes are a superset of processor nodes. In addition to the capabilities of processor nodes, queue nodes also have capability to store packets in one or more queues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. 队列节点：队列节点是处理器节点的超集。除了处理器节点的功能外，队列节点还可以在一个或多个队列中存储数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Transmitter and Receiver nodes: Transmitters simulate the link behavior effect of packet transmission and Receivers simulate the receiving effects of packet reception. The transmission rate is an attribute of the transmitter and receiving rate is an attribute of the receiver. These values together decide the transmission delay of a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. 发送方和接收方节点：发送方模拟数据包传输的链路行为效应，接收方模拟数据包接收的接收效应。传输速率是发射机的属性，接收速率是接收机的属性。这些值一起决定数据包的传输延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. Packet streams: Packet streams are used to interconnect the above described nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. 分组流：分组流用于互连上述节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. Statistic streams: Statistic streams are used to convey information between the different nodes: Processor, Queue, Transmitters and Receivers nodes respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. 统计流：统计流用于在不同节点之间传递信息：处理器、队列、发送器和接收器节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2 Host description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2 主机描述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The host model built using OPNET has a layered structure. Different from the OPNET layers (Network, Node and Process layer) that describe the network at different levels, protocol stack elements are implemented at OPNET nodes. Figure 3 shows the node level structure of a FDDI host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用OPNET构建的主机模型具有分层结构。与在不同级别描述网络的OPNET层（网络、节点和进程层）不同，协议栈元素在OPNET节点上实现。图3显示了FDDI主机的节点级结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
[Figure 3: Node Level of Host]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
[图3：主机的节点级别]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. MAC queue node: The MAC interfaces on one side to the physical layer through the transmitter (phy_tx) and receiver (phy_rx) and also provides services to the IP layer. Use of ring bandwidth is controlled through a timed token rotation protocol, wherein hosts must receive a token and meet with a set of timing and priority criteria before transmitting frames. When a frame arrives at the MAC node, the node performs one of the following actions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. MAC队列节点：MAC通过发送器（phy_tx）和接收器（phy_rx）在一侧与物理层接口，并向IP层提供服务。通过定时令牌轮换协议控制环带宽的使用，其中主机必须在发送帧之前接收令牌并满足一组定时和优先级标准。当帧到达MAC节点时，该节点执行以下操作之一：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. If the owner of the frame is this MAC, the MAC layer destroys the frame since the frame has finished circulating through the FDDI ring. 2. if the frame is destined for this host, the MAC layer makes a copy of the frame, decapsulates the frame and sends the descapsulated frame (packet) to the IP layer. The original frame is transmitted to the next host in the FDDI ring 3. if the owner of the frame is any other host and the frame is not destined for this host, the frame is forwarded to the adjacent host.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
1. 如果帧的所有者是该MAC，则MAC层将销毁该帧，因为该帧已完成在FDDI环中的循环。2.如果该帧的目的地是该主机，则MAC层制作该帧的副本，对该帧进行去封装，并将解封装的帧（数据包）发送到IP层。原始帧被发送到FDDI环3中的下一主机。如果帧的所有者是任何其他主机，并且帧的目的地不是该主机，则帧将转发到相邻主机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. ADDR_TRANS processor node: The next layer above the MAC layer is the addr_trans processor node. This layer provides service to the IP layer by carrying out the function of translating the IP address to physical interface address. This layer accepts packets from the IP layer with the next node information, maps the next node information to a physical address and forwards the packet for transmission. This service is required only in one direction from the IP layer to the MAC layer. Since queuing is not done at this level, a processor node is used to accomplish the address translation function, from IP to MAC address (ARP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. ADDR_TRANS processor节点：MAC层之上的下一层是ADDR_TRANS processor节点。该层通过执行将IP地址转换为物理接口地址的功能，向IP层提供服务。该层接受来自IP层的具有下一节点信息的数据包，将下一节点信息映射到物理地址，并转发该数据包以进行传输。该服务仅在从IP层到MAC层的一个方向上需要。由于排队不是在这个级别完成的，因此处理器节点用于完成从IP地址到MAC地址（ARP）的地址转换功能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. IP queue node: Network routing/forwarding in the hierarchy is implemented here. IP layer provides service for the layers above which are the different higher level protocols by utilizing the services provided by the MAC layer. For packets arriving from the MAC layer, the IP layer decapsulates the packet and forwards the information to an upper layer protocol based upon the value of the protocol ID in the IP header. For packets arriving from upper layer protocols, the IP layer obtains the destination address, calculates
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. IP队列节点：这里实现层次结构中的网络路由/转发。IP层通过利用MAC层提供的服务为上面的层提供服务，这些层是不同的高层协议。对于来自MAC层的分组，IP层解除对分组的封装，并基于IP报头中的协议ID的值将信息转发给上层协议。对于来自上层协议的数据包，IP层获取目标地址，计算
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the next node address from the routing table, encapsulates it with a IP header and forwards the packet to the addr_trans node with the next node information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由表中的下一个节点地址，用一个IP报头将其封装，并用下一个节点信息将数据包转发给addr_trans节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IP node is a queue node. It is in this layer that packets incur delay which simulates the processing capability of a host and queueing for use of the outgoing link. A packet arrival to the IP layer will be queued and experience delay when it finds another packet already being transmitted, plus possibly other packets queued for transmission. The packets arriving at the IP layer are queued and operate with a first-in first-out (FIFO) discipline. The queue size, service rate of the IP layer are both promoted attributes, specified at the simulation run level by the environment file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP节点是一个队列节点。正是在这一层中，数据包产生延迟，这模拟了主机的处理能力，并排队等待使用传出链路。到达IP层的数据包将被排队，当它发现另一个数据包已经被传输，可能还有其他排队等待传输的数据包时，会经历延迟。到达IP层的数据包排队，并按照先进先出（FIFO）原则进行操作。IP层的队列大小和服务速率都是提升属性，由环境文件在模拟运行级别指定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. IGMP processor node: The models described above are standard components available in OPNET libraries. We have added to these the host multicast protocol model IGMP_host, the router multicast model IGMP_gwy, and the unicast best-effort protocol model UBE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. IGMP处理器节点：上述模型是OPNET库中可用的标准组件。我们在其中添加了主机多播协议模型IGMP_host、路由器多播模型IGMP_gwy和单播尽力而为协议模型UBE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IGMP_host node (Figure 4) is a process node. Packets are not queued in this layer. IGMP_host provides unique group management services for the multicast applications utilizing the services provided by the IP layer. IGMP_host maintains a single table which consists of group membership information of the application above the IGMP layer. The function performed by the IGMP_host layer depends upon the type of the packet received and the source of the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMP_主机节点（图4）是一个进程节点。数据包不在此层排队。IGMP_主机利用IP层提供的服务为多播应用程序提供独特的组管理服务。IGMP_主机维护一个表，其中包含IGMP层上方应用程序的组成员信息。IGMP_主机层执行的功能取决于接收的分组的类型和分组的源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
[Figure 4: IGMP process on hosts]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
[图4：主机上的IGMP进程]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IGMP_host layer expects certain type of packets from the application layer and from the network:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMP_主机层需要来自应用层和网络的特定类型的数据包：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Accept join group requests from the application layer (which can be one or more applications): IGMP_host maintains a table which consists of the membership information for each group. When a application sends a join request, it requests to join a specific group N. The membership information is updated. This new group membership information has to be conveyed to the nearest router and to the MAC layer. If the IGMP_host is already a member ofthis group (i.e. if another application above the IGMP_host is a member of the group N), the IGMP_host does not have to send a message to the router or indicate to the MAC layer. If the IGMP_host is not a member currently, the IGMP_host generates a join request for the group N (this is called a &#34;response&#34; in RFC 1112) and forwards it to the IP layer to be sent to the nearest router. In addition the IGMP_host also conveys this membership information to the MAC layer interfacing to the physical layer through the OPNET &#34;statistic wire&#34; connected from the IGMP_host to the MAC layer, so
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 接受来自应用层（可以是一个或多个应用程序）的加入组请求：IGMP_主机维护一个表，其中包含每个组的成员信息。当应用程序发送加入请求时，它请求加入特定的组N。成员信息将更新。这个新的组成员信息必须传送到最近的路由器和MAC层。如果IGMP_主机已经是该组的成员（即，如果IGMP_主机之上的另一应用程序是组N的成员），则IGMP_主机不必向路由器发送消息或向MAC层指示。如果IGMP_主机当前不是成员，则IGMP_主机为组N生成加入请求（在RFC 1112中称为“响应”），并将其转发到IP层以发送到最近的路由器。此外，IGMP_主机还通过从IGMP_主机连接到MAC层的OPNET“统计线”将该成员信息传送到与物理层接口的MAC层，因此
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 that the MAC layer knows the membership information immediately and begins to accept the frames destined for the group N. (An OPNET statistic wire is a virtual path to send information between OPNET models.) 2. Accept queries arriving from the nearest router and send responses based on the membership information in the multicast table at the IGMP_host layer: A query is a message from a router inquiring each host on the router&#39;s interface about group membership information. When the IGMP_host receives a query, it looks up the multicast group membership table, to determine if any of the host&#39;s applications are registered for any group. If any registration exists, the IGMP_host schedules an event to generate a response after a random amount of time corresponding to each active group. The Ethernet example in Figure 5 and the description in the following section describes the scenario.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC层立即知道成员信息并开始接受发送给组N的帧（OPNET统计线是在OPNET模型之间发送信息的虚拟路径）。接受来自最近路由器的查询，并根据IGMP_主机层的多播表中的成员信息发送响应：查询是来自路由器的消息，询问路由器接口上的每个主机有关组成员信息。当IGMP_主机接收到查询时，它会查找多播组成员表，以确定主机的任何应用程序是否为任何组注册。如果存在任何注册，IGMP_主机将安排一个事件，以便在与每个活动组相对应的随机时间后生成响应。图5中的以太网示例和下一节中的描述描述了该场景。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                   ---------------------------------------
                        |        |         |         |
                        |        |         |         |
                      +---+    +---+     +---+     +---+
                      | H1|    | H2|     | H3|     | R |
                      +---+    +---+     +---+     +---+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                   ---------------------------------------
                        |        |         |         |
                        |        |         |         |
                      +---+    +---+     +---+     +---+
                      | H1|    | H2|     | H3|     | R |
                      +---+    +---+     +---+     +---+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Figure 5: An Ethernet example of IGMP response schedule
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
图5:IGMP响应计划的以太网示例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The router R interfaces with the subnet on one interface I1 and to reach the hosts. To illustrate this let us assume that hosts H1 and H3 are members of group N1 and H2 is a member of group N2. When the router sends a query, all the hosts receive the query at the same time t0. IGMP_host in H1 schedules an event to generate a response at a randomly generated time t1 (t1 &gt;= t0) which will indicate the host H1 is a member of group N1. Similarly H2 will schedule an event to generate a response at t2 (t2 &gt;= t0)to indicate membership in group N2 and H3 at t3 (t3 &gt;= t0) to indicate membership in group N3. When the responses are generated, the responses are sent with destination address set to the multicast group address. Thus all member hosts of a group will receive the responses sent by the other hosts in the subnet who are members of the same group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器R在一个接口I1上与子网连接，并到达主机。为了说明这一点，让我们假设主机H1和H3是组N1的成员，H2是组N2的成员。当路由器发送查询时，所有主机同时接收该查询t0。H1中的IGMP_主机调度事件以在随机生成的时间t1（t1&gt;=t0）生成响应，这将指示主机H1是组N1的成员。类似地，H2将安排一个事件，以在t2（t2&gt;=t0）处生成响应，以指示在组N2中的成员身份，并在t3（t3&gt;=t0）处生成H3，以指示在组N3中的成员身份。生成响应时，发送的响应的目标地址设置为多播组地址。因此，组的所有成员主机将接收子网中属于同一组的其他主机发送的响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In the above example if t1 &lt; t3, IGMP_host in H1 will generate a response to update the membership in group N1 before H3 does and H3 will also receive this response in addition to the router. When IGMP_host in H3 receives the response sent by H1, IGMP_host in H3 cancels the event scheduled at time t3, since a response for that group has been sent to the router. To make this work, the events
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在上面的示例中，如果t1&lt;t3，H1中的IGMP_主机将在H3之前生成更新组N1中的成员资格的响应，并且H3除了路由器之外还将接收该响应。当H3中的IGMP_主机接收到H1发送的响应时，H3中的IGMP_主机取消在时间t3安排的事件，因为该组的响应已发送到路由器。为了让这一切顺利进行
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 to generate response to queries are scheduled randomly, and the interval for scheduling the above described event is forced to be less than the interval at which router sends the queries. 3. Accept responses sent by the other hosts in the subnet if any application layer is a member of the group to which the packet is destined. 4. Accept terminate group requests from the Application layer. These requests are generated by application layer when a application decides to leave a group. The IGMP_host updates the group information table and subsequently will not send any response corresponding to this group (unless another application is a member of this group). When a router does not receive any response for a group in certain amount of time on a specific interface, membership of that interface is canceled in that group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成对查询的响应是随机调度的，并且调度上述事件的间隔被迫小于路由器发送查询的间隔。3.如果任何应用层是数据包目的地组的成员，则接受子网中其他主机发送的响应。4.接受来自应用层的终止组请求。当应用程序决定离开组时，这些请求由应用程序层生成。IGMP_主机更新组信息表，随后不会发送与此组对应的任何响应（除非另一个应用程序是此组的成员）。当路由器在特定接口上的特定时间内未收到组的任何响应时，该接口在该组中的成员资格将被取消。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. Unicast best-effort (UBE) processor node: This node is used to generate a best effort traffic in the Internet based on the User Datagram Protocol (UDP). The objective of this node is to model the background traffic in a network. This traffic does not use the services provided by RSVP. UBE node aims to create the behaviors observed in a network which has one type of application using the services provided by RSVP to achieve specific levels of QoS and the best effort traffic which uses the services provided by only the underlying IP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. 单播最大努力（UBE）处理器节点：该节点用于根据用户数据报协议（UDP）在Internet上生成最大努力流量。该节点的目标是对网络中的后台流量进行建模。此流量不使用RSVP提供的服务。UBE节点旨在创建在网络中观察到的行为，该网络具有一种类型的应用程序，使用RSVP提供的服务来实现特定级别的QoS和仅使用底层IP提供的服务的尽力而为的流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UBE node generates traffic to a randomly generated IP address so as to model competing traffic in the network from applications such as FTP. The packets generated are sent to the IP layer which routes the packet based upon the information in the routing table. The attributes of the UBE node are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UBE节点生成到随机生成的IP地址的流量，以便对来自诸如FTP之类的应用程序的网络中的竞争流量进行建模。生成的分组被发送到IP层，IP层根据路由表中的信息路由分组。UBE节点的属性包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Session InterArrival Time (IAT): is the variable used to schedule an event to begin a session. The UBE node generates an exponentially distributed random variable with mean Session IAT and begins to generate data traffic at that time. 2. Data IAT: When the UBE generates data traffic, the interarrival times between data packets is Data IAT. A decrease in the value of Data IAT increases the severity of congestion in the network. 3. Session-min and Session-max: When the UBE node starts generating data traffic it remains in that session for a random period which is uniformly distributed between Session-min and Session-max.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 会话到达间隔时间（IAT）：用于安排事件以开始会话的变量。UBE节点使用平均会话IAT生成指数分布的随机变量，并在此时开始生成数据流量。2.数据IAT：当UBE生成数据流量时，数据包之间的间隔时间为数据IAT。数据IAT值的降低会增加网络拥塞的严重性。3.会话最小值和会话最大值：当UBE节点开始生成数据流量时，它将在该会话中保留一段随机时间，该时间段均匀分布在会话最小值和会话最大值之间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
f. Multicast Application processor node: The application layer consists of one or more application nodes which are process nodes. These nodes use the services provided by lower layer protocols IGMP, RSVP and IP. The Application layer models the requests and traffic generated by Application layer programs. Attributes of the application layer are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
f. 多播应用程序处理器节点：应用程序层由一个或多个作为进程节点的应用程序节点组成。这些节点使用低层协议IGMP、RSVP和IP提供的服务。应用层对应用层程序生成的请求和流量进行建模。应用层的属性包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Session IAT: is the variable used to schedule an event to begin a session. The Application node generates an exponentially distributed random variable with mean Session IAT and begins to generate information for a specific group at that time and also accept packets belonging to that group. 2. Data IAT: When Application node generates data traffic, the inter arrival time between the packets uses Data IAT variable as the argument. The distribution can be any of the available distribution functions in OPNET. 3. Session-min and Session-max: When an application joins a session the duration for which the application stays in that session is bounded by Session-min and Session-max. A uniformly distributed random variable between Session-min and Session-max is generated for this purpose. At any given time each node will have zero or one flow(s) of data. 4. NGRPS: This variable is used by the application generating multicast traffic to bound the value of the group to which an application requests the IGMP to join. The group is selected at random from the range [0,NGRPS-1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 会话IAT：用于安排事件以开始会话的变量。应用程序节点生成具有平均会话IAT的指数分布随机变量，并开始生成特定组的信息，同时还接受属于该组的数据包。2.数据IAT：当应用节点生成数据流量时，数据包之间的到达时间使用数据IAT变量作为参数。分发可以是OPNET中的任何可用分发函数。3.会话最小值和会话最大值：当应用程序加入会话时，应用程序在该会话中的持续时间受会话最小值和会话最大值的限制。为此，会在会话最小值和会话最大值之间生成一个均匀分布的随机变量。在任何给定时间，每个节点都将有零个或一个数据流。4.NGRPS：生成多播通信的应用程序使用此变量来绑定应用程序请求IGMP加入的组的值。从[0，NGRPS-1]范围内随机选择该组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
[Figure 6: Node Level of Gateway]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
[图6：网关的节点级别]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3 Router description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.3 路由器描述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
There are two types of routers in the model, a router serving a subnet and a backbone router. A subnet router has all the functions of a backbone router and in addition also has a interface to the underlying subnet which can be either a FDDI network or a Ethernet subnet. In the following section the subnet router will be discussed in detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
模型中有两种类型的路由器，一种为子网服务的路由器和一种骨干路由器。子网路由器具有主干路由器的所有功能，此外还具有与底层子网的接口，底层子网可以是FDDI网络或以太网子网。下一节将详细讨论子网路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 6 shows the node level model of a subnet router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
图6显示了子网路由器的节点级模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a. The queueing technique implemented in the router is a combination of input and output queueing. The nodes rx1 to rx10 are the receivers connected to incoming links. The router in Figure 6 has a physical interface to the FDDI ring or Ethernet, which consists of the queue node MAC, transmitter phy_tx, and the receiver phy_rx. The backbone routers will not have a MAC layer. The services provided and the functions of the MAC layer are the same as the MAC layer in the host discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
a. 路由器中实现的排队技术是输入和输出排队的组合。节点rx1到rx10是连接到传入链路的接收器。图6中的路由器有一个到FDDI环或以太网的物理接口，它由队列节点MAC、发射机phy_tx和接收机phy_rx组成。主干路由器将没有MAC层。MAC层提供的服务和功能与上面讨论的主机中的MAC层相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
There is one major difference between the MAC node in a subnet router and that in a host. The MAC node in a subnet router accepts all arriving multicast packets unlike the MAC in a host which accepts only the multicast packets for groups of which the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
子网路由器中的MAC节点与主机中的MAC节点有一个主要区别。子网路由器中的MAC节点接受所有到达的多播数据包，这与主机中的MAC不同，主机中的MAC只接受多播数据包，而主机中的MAC只接受多播数据包所在的组
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
host is a member. For this reason the statistic wire from the IGMP to MAC layer does not exist in a router (also because a subnet router does not have an application layer).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
主持人是会员。因此，路由器中不存在从IGMP到MAC层的统计线（也因为子网路由器没有应用层）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
b. Addr_trans: The link layer in the router hierarchy is the addr_trans processor node which provides the service of translating the IP address to a physical address. The addr_trans node was described above under the host model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
b. Addr_trans：路由器层次结构中的链路层是Addr_trans处理器节点，它提供将IP地址转换为物理地址的服务。addr_trans节点在上述主机模型下进行了描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
c. IP layer: The router IP layer which provides services to the upper layer transport protocols and also performs routing based upon the information in the routing table. The IP layer maintains two routing tables and one group membership table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
c. IP层：路由器IP层，为上层传输协议提供服务，并根据路由表中的信息执行路由。IP层维护两个路由表和一个组成员表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The tables used by the router model are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器模型使用的表包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 1. Unicast routing table: This table is an single array of one dimension, which is used to route packets generated by the UDP process node in the hosts. If no route is known to a particular IP address, the corresponding entry is set to a default route. 2. Multicast routing table: This table is a N by I array where N is the maximum number of multicast groups in the model and I is the number of interfaces in the router. This table is used to route multicast packets. The routing table in a router is set by an upper layer routing protocol (see section 4 below). When the IP layer receives a multicast packet with a session_id corresponding to a session which is utilizing the MOSFP, it looks up the multicast routing table to obtain the next hop. 3. Group membership table: This table is used to maintain group membership information of all the interfaces of the router. This table which is also an N by I array is set by the IGMP layer protocol. The routing protocols use this information in the group membership table to calculate and set the routes in the Multicast routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1.单播路由表：该表是一个一维数组，用于路由主机中UDP进程节点生成的数据包。如果特定IP地址不知道路由，则将相应条目设置为默认路由。2.多播路由表：该表是一个N×I数组，其中N是模型中多播组的最大数量，I是路由器中的接口数量。此表用于路由多播数据包。路由器中的路由表由上层路由协议设置（见下文第4节）。当IP层接收到具有与正在使用MOSFP的会话相对应的会话id的多播分组时，它查找多播路由表以获得下一跳。3.组成员表：该表用于维护路由器所有接口的组成员信息。该表也是一个N×I数组，由IGMP层协议设置。路由协议使用组成员表中的此信息来计算和设置多播路由表中的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sub-queues: The IP node has three subqueues, which implement queuing based upon the priority of arriving packets from the neighboring routers or the underlying subnet. The queue with index 0 has the highest priority. When a packet arrives at the IP node, the packets are inserted into the appropriate sub-queue based on the priority of their traffic category: control traffic, resource- reserved traffic, or best effort traffic. A non-preemptive priority is used in servicing the packets. After the servicing, packets are sent to the one of the output queues or the MAC. The packets progress through these queues until the transmitter becomes available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子队列：IP节点有三个子队列，它们根据从相邻路由器或底层子网到达的数据包的优先级实现排队。索引为0的队列具有最高优先级。当数据包到达IP节点时，数据包将根据其流量类别的优先级（控制流量、资源保留流量或尽力而为流量）插入相应的子队列。非抢占优先级用于服务数据包。服务完成后，数据包被发送到其中一个输出队列或MAC。数据包在这些队列中前进，直到发送器可用为止。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attributes of the IP node are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP节点的属性包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Unique IP address for each interface (a set of transmitter and receiver constitute an interface). 2. Service rate: the rate with which packets are serviced at the router. 3. Queue size: size of each of the sub queues used to store incoming packets based on the priority can be specified individually
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 每个接口的唯一IP地址（一组发射机和接收机构成一个接口）。2.服务速率：在路由器上为数据包提供服务的速率。3.队列大小：可以单独指定用于根据优先级存储传入数据包的每个子队列的大小
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. Output queues: The output queues perform the function of queueing the packets received by the IP layer when the transmitter is busy. A significant amount of queuing takes place in the output queues only if the throughput of the IP node approaches the transmission capacity of the links. The only attribute of the queue node is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. 输出队列：当发送器忙时，输出队列执行将IP层接收的数据包排队的功能。只有当IP节点的吞吐量接近链路的传输容量时，输出队列中才会出现大量排队。队列节点的唯一属性是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Queue size: size of the queue in each queue node. If the queue is full when a packet is received, that packet is dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
队列大小：每个队列节点中队列的大小。如果接收到数据包时队列已满，则该数据包将被丢弃。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. IGMP Node: Also modeled in the router is the IGMP for implementing multicasting, the routing protocol, and RSVP for providing specific QoS setup.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. IGMP节点：路由器中还建模了用于实现多播的IGMP、路由协议和用于提供特定QoS设置的RSVP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IGMP node implements the IGMP protocol as defined in RFC 1112. The IGMP node at a router (Figure 7) is different from the one at a host. The functions of the IGMP node at a router are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMP节点实现RFC 1112中定义的IGMP协议。路由器上的IGMP节点（图7）与主机上的IGMP节点不同。路由器上IGMP节点的功能包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. IGMP node at a router sends queries at regular intervals on all its interfaces. 2. When IGMP receives a response to the queries sent, IGMP updates the multicast Group membership table in the IP node and triggers on MOSPF LSA update. 3. Every time the IGMP sends a query, it also updates the multicast group membership table in the IP node if no response has been received on for the group on any interface, indicating that a interface is no longer a member of that group. This update is done only on entries which indicate an active membership for a group on a interface where the router has not received a response for the last query sent. 4. The routing protocol (see ection 4 below) uses the information in the group membership table to calculate the routes and update the multicast routing table. 5. When the IGMP receives a query (an IGMP at router can receive a query from a directly connected neighboring router), the IGMP node creates a response for each of the groups it is a member of on all the interfaces except the one through which the query was received. 6. The IGMP node on a backbone router is disabled, because IGMP is only used when a router has hosts on its subnet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 路由器上的IGMP节点定期在其所有接口上发送查询。2.当IGMP收到对发送的查询的响应时，IGMP更新IP节点中的多播组成员表，并触发MOSPF LSA更新。3.每次IGMP发送查询时，如果在任何接口上没有收到该组的响应，则它也会更新IP节点中的多播组成员资格表，表明该接口不再是该组的成员。此更新仅在路由器未收到上次发送的查询响应的接口上指示组的活动成员身份的条目上执行。4.路由协议（见下文第4节）使用组成员表中的信息计算路由并更新多播路由表。5.当IGMP接收到查询（路由器上的IGMP可以从直接连接的相邻路由器接收查询）时，IGMP节点在所有接口上为其所属的每个组创建响应，但接收查询的接口除外。6.主干路由器上的IGMP节点被禁用，因为IGMP仅在路由器的子网上有主机时使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
[Figure 7: IGMP process on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
[图7：路由器上的IGMP过程]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. RSVP model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. RSVP模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current version of the RSVP model supports only fixed-filter reservation style. The following processing takes place in the indicated modules. The model is current with [2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSVP模型的当前版本仅支持固定筛选器保留样式。以下处理在所示模块中进行。该模型与[2]一致。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 RSVP APPLICATION
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 RSVP应用程序
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1 初始化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initializes all variables and loads the distribution functions for Multicast Group IDs, Data, termination of the session. Transit to Idle state after completing all the initializations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始化所有变量并加载多播组ID、数据和会话终止的分发函数。完成所有初始化后转换到空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2 Idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2 闲置的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state has transitions to two states, Join and Data_Send. It transit to Join state at the time that the application is scheduled to join a session or terminate the current session, transit to Data_Send state when the application is going to send data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态转换为两种状态：连接和数据发送。它在应用程序计划加入会话或终止当前会话时转换为加入状态，在应用程序要发送数据时转换为数据发送状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3 Join
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3 参加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Application will send a session call to local RSVP daemon. In response it receives the session Id from the Local daemon. This makes a sender or receiver call. The multicast group id is selected randomly from a uniform distribution. While doing a sender call the application will write all its sender information in a global session directory.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序将向本地RSVP守护进程发送会话调用。作为响应，它从本地守护进程接收会话Id。这会发出发送方或接收方呼叫。多播组id是从均匀分布中随机选择的。在执行发送方调用时，应用程序会将其所有发送方信息写入全局会话目录。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the application is acting as a receiver it will check for the sender information in the session directory for the multicast group that it wants to join to and make a receive call to the local RSVP daemon. Along with the session and receive calls, it makes an IGMP join call.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果应用程序充当接收器，它将检查会话目录中要加入的多播组的发送者信息，并向本地RSVP守护程序发出接收调用。除了会话和接收呼叫之外，它还发出一个IGMP加入呼叫。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the application chooses to terminate the session to which it was registered, it will send a release call to the local RSVP daemon and a terminate call to IGMP daemon. After completing these functions it will return to the idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果应用程序选择终止其注册到的会话，它将向本地RSVP守护程序发送释放调用，并向IGMP守护程序发送终止调用。完成这些功能后，它将返回空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
[Figure 8: RSVP process on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
[图8：路由器上的RSVP过程]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4 Data_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4 数据发送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Creates a data packet and sends it to a multicast destination that it selects. It update a counter to keep track of how many packets that it has sent. This state on default returns to Idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
创建数据包并将其发送到它选择的多播目的地。它会更新一个计数器来跟踪它发送了多少数据包。默认情况下，此状态返回到空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 RSVP on Routers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 路由器上的RSVP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 8 shows the process model of RSVP on routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图8显示了路由器上RSVP的过程模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1 初始化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state calls a function called RouterInitialize which will initialize all the router variables. This state will go to Idle state after completing these functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态调用名为RouterInitialize的函数，该函数将初始化所有路由器变量。完成这些功能后，此状态将变为空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2 Idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2 闲置的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Idle state transit to Arr state upon receiving a packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收到数据包后，空闲状态转换为Arr状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3 Arr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.3 啊
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state checks for the type of the packet arrived and calls the appropriate function depending on the type of message received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态检查到达的数据包的类型，并根据收到的消息类型调用相应的函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. PathMsgPro: This function was invoked by the Arr state when a path message is received. Before it was called, OSPF routing had been recomputed to get the latest routing table for forwarding the Path Message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. PathMsgPro：当收到path消息时，Arr状态调用此函数。在调用之前，已重新计算OSPF路由，以获取用于转发路径消息的最新路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. It first checks for a Path state block which has a matching destination address and if the sender port or sender address or destination port does not match the values of the Session object of the Path state block, it sends an path error message and returns. (At present the application does not send any error messages, we print this error message on the console.) 2. If a PSB is found whose Session Object and Sender Template Object matches with that of the path message received, the current PSB becomes the forwarding PSB. 3. Search for the PSB whose session and sender template matches the corresponding objects in the path message and whose incoming interface matches the IncInterface. If such a PSB is found and the if the Previous Hop Address, Next Hop Address, and SenderTspec Object doesn&#39;t match that of path message then the values of path message is copied into the path state block and Path Refresh Needed flag is turned on. If the Previous Hop Address, Next Hop
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 它首先检查具有匹配目标地址的路径状态块，如果发送方端口或发送方地址或目标端口与路径状态块的会话对象的值不匹配，则发送路径错误消息并返回。（目前应用程序不发送任何错误消息，我们在控制台上打印此错误消息。）2。如果发现一个PSB的会话对象和发送方模板对象与接收到的path消息的会话对象和发送方模板对象匹配，则当前PSB将成为转发PSB。3.搜索其会话和发送方模板与路径消息中的相应对象匹配且其传入接口与InInterface匹配的PSB。如果找到这样的PSB，并且如果上一个跃点地址、下一个跃点地址和SenderSpec对象与path message的不匹配，则path message的值将复制到path state块中，并且启用path Refresh Needed标志。如果选择上一个跃点地址，则选择下一个跃点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 Address of PSB differs from the path message then the Resv Refresh Needed flag is also turned on, and the Current PSB is made equal to this PSB. 4. If a matching PSB is not found then a new PSB is created and and Path Refresh Needed Flag is turned on, and the Current PSB is made equal to this PSB. 5. If Path Refresh Needed Flag is on, Current PSB is copied into forwarding PSB and Path Refresh Sequence is executed. To execute this function called PathRefresh is used. Path Refresh is sent to every interface that is in the outgoing interfaces list of forwarding path state block. 6. Search for a Reservation State Block whose filter spec object matches with the Sender Template Object of the forwarding PSB and whose Outgoing Interface matches one of the entry in the forwarding PSB&#39;s outgoing interface list. If found then a Resv Refresh message to the Previous Hop Address in the forwarding PSB and execute the Update Traffic Control sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PSB的地址与path消息不同，则Resv Refresh REQUIRED标志也将打开，并且当前PSB将与此PSB相等。4.如果未找到匹配的PSB，则会创建一个新的PSB，并启用“需要路径刷新”标志，使当前PSB等于此PSB。5.若“需要路径刷新”标志处于启用状态，则当前PSB将复制到转发PSB中，并执行路径刷新序列。要执行此函数，请使用名为PathRefresh的函数。路径刷新发送到转发路径状态块的传出接口列表中的每个接口。6.搜索保留状态块，其筛选器规范对象与转发PSB的发件人模板对象匹配，其传出接口与转发PSB的传出接口列表中的一个条目匹配。如果找到，则向转发PSB中的前一跳地址发送Resv刷新消息，并执行更新流量控制序列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. PathRefresh: This function is called from PathMsgPro. It creates the Path message sends the message through the outgoing interface that is specified by the PathMsgPro.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. PathRefresh：从PathMsgPro调用此函数。它创建路径消息，通过PathMsgPro指定的传出接口发送消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. ResvMsgPro: This function was invoked by the Arr state when a Resv message is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. ResvMsgPro：当收到Resv消息时，Arr状态调用此函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Determine the outgoing interface and check for the PSB whose Source Address and Session Objects match the ones in the Resv message. 2. If such a PSB is not found then send a ResvErr message saying that No Path Information is available. (We have not implemented this message, we only print an error message on the console.) 3. Check for incompatible styles and process the flow descriptor list to make reservations, checking the PSB list for the sender information. If no sender information is available through the PSB list then send an Error message saying that No Sender information. For all the matching PSBs found, if the Refresh PHOP list doesn&#39;t have the Previous Hop Address of the PSB then add the Previous Hop Address to the Refresh PHOP list. 4. Check for matching Reservation State Block (RSB) whose Session and Filter Spec Object matches that of Resv message. If no such RSB is found then create a new RSB from the Resv Message and set the NeworMod flag On. Call this RSB as activeRSB. Turn on the Resv Refresh Needed Flag. 5. If a matching RSB is found, call this as activeRSB and if the FlowSpec and Scope objects of this RSB differ from that of Resv Message copy the Resv message Flowspec and Scope objects to the ActiveRSB and set the NeworMod flag On.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 确定传出接口并检查其源地址和会话对象与Resv消息中的对象匹配的PSB。2.如果找不到这样的PSB，则发送ResvErr消息，说明没有可用的路径信息。（我们没有实现此消息，我们只在控制台上打印错误消息。）3。检查不兼容的样式并处理流描述符列表以进行保留，检查PSB列表以获取发送者信息。如果PSB列表中没有可用的发件人信息，则发送一条错误消息，说明没有发件人信息。对于找到的所有匹配PSB，如果刷新PHOP列表没有PSB的上一个跃点地址，则将上一个跃点地址添加到刷新PHOP列表中。4.检查其会话和筛选器规范对象与Resv消息的会话和筛选器规范对象匹配的保留状态块（RSB）。如果没有找到这样的RSB，则从Resv消息创建一个新的RSB，并将NeworMod标志设置为On。将此RSB称为activeRSB。启用Resv Refresh REQUIRED标志。5.如果找到匹配的RSB，则将其称为activeRSB，如果此RSB的FlowSpec和Scope对象与Resv消息的不同，则将Resv消息FlowSpec和Scope对象复制到activeRSB，并启用NeworMod标志。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Call the Update Traffic Control Sequence. This is done by calling the function UpdateTrafficControl 7. If Resv Refresh Needed Flag is On then send a ResvRefresh message for each Previous Hop in the Refresh PHOP List. This is done by calling the ResvRefresh function for every Previous Hop in the Refresh PHOP List.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 调用更新流量控制序列。这是通过调用函数updateRafficControl 7来完成的。如果Resv Refresh REQUIRED标志处于启用状态，则为Refresh PHOP列表中的每个前一个跃点发送ResvRefresh消息。这是通过为刷新PHOP列表中的每个前一跳调用ResvRefresh函数来完成的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. ResvRefresh: this function is called by both PathMsgPro and ResvMsgPro with RSB and Previous Hop as input. The function constructs the Resv Message from the RSB and sends the message to the Previous Hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. ResvRefresh:PathMsgPro和ResvMsgPro以RSB和上一跳作为输入调用此函数。该函数从RSB构造Resv消息，并将该消息发送到上一跳。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. PathTearPro: This function is invoked by the Arr state when a PathTear message is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. PathTearPro：当收到PathTear消息时，Arr状态将调用此函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Search for PSB whose Session Object and Sender Template Object matches that of the arrived PathTear message. 2. If such a PSB is not found do nothing and return. 3. If a matching PSB is found, a PathTear message is sent to all the outgoing interfaces that are listed in the Outgoing Interface list of the PSB. 4. Search for all the RSB whose Filter Spec Object matches the Sender Template Object of the PSB and if the Outgoing Interface of this RSB is listed in the PSB&#39;s Outgoing interface list delete the RSB. 5. Delete the PSB and return.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 搜索其会话对象和发件人模板对象与到达的Path催泪邮件的会话对象和发件人模板对象匹配的PSB。2.如果未找到此类PSB，则不执行任何操作并返回。3.如果找到匹配的PSB，则会向PSB的传出接口列表中列出的所有传出接口发送PathTear消息。4.搜索其筛选器规范对象与PSB的发件人模板对象匹配的所有RSB，如果此RSB的传出接口列在PSB的传出接口列表中，则删除该RSB。5.删除PSB并返回。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
f. ResvTearPro: This function is invoked by the Arr state when a ResvTear message is received. 1. Determine the Outgoing Interface. 2. Process the flow descriptor list of the arrived ResvTear message. 3. Check for the RSB whose Session Object, Filter Spec Object matches that of ResvTear message and if there is no such RSB return. 4. If such an RSB is found and Resv Refresh Needed Flag is on send ResvTear message to all the Previous Hops that are in Refresh PHOP List. 5. Finally delete the RSB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
f. ResvTearPro：当接收到ResvTear消息时，Arr状态将调用此函数。1.确定传出接口。2.处理到达的ResvTear消息的流描述符列表。3.检查会话对象Filter Spec Object与ResvTear message的会话对象Filter Spec Object匹配的RSB，以及是否没有此类RSB返回。4.如果找到这样一个RSB，并且Resv Refresh REQUIRED标志为on，则向Refresh PHOP列表中的所有先前跃点发送ResvTear消息。5.最后删除RSB。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
g. ResvConfPro: This function is invoked by the Arr state when a ResvConf message is received. The Resv Confirm is forwarded to the IP address that was in the Resv Confirm Object of the received ResvConf message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
g. ResvConfPro：当接收到ResvConf消息时，Arr状态将调用此函数。Resv确认被转发到接收到的ResvConf消息的Resv确认对象中的IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h. UpdateTrafficControl: This function is called by PathMsgPro and ResvMsgPro and input to this function is RSB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
h. UpdateRafficControl：此函数由PathMsgPro和ResvMsgPro调用，此函数的输入为RSB。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The RSB list is searched for a matching RSB that matches the Session Object, and Filter Spec Object with the input RSB. 2. Effective Kernel TC_Flowspec are computed for all these RSB&#39;s.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 将在RSB列表中搜索与会话对象匹配的RSB，并使用输入RSB筛选规范对象。2.计算所有这些RSB的有效内核TC_流规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If the Filter Spec Object of the RSB doesn&#39;t match the one of the Filter Spec Object in the TC Filter Spec List then add the Filter Spec Object to the TC Filter Spec List. 4. If the FlowSpec Object of the input RSB is greater than the TC_Flowspec then turn on the Is_Biggest flag. 5. Search for the matching Traffic Control State Block(TCSB) whose Session Object, Outgoing Interface, and Filter Spec Object matches with those of the Input RSB. 6. If such a TCSB is not found create a new TCSB. 7. If matching TCSB is found modify the reservations. 8. If Is_Biggest flag is on turn on the Resv Refresh Needed Flag flag, else send a ResvConf Message to the IP address in the ResvConfirm Object of the input RSB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 如果RSB的过滤器规格对象与TC过滤器规格列表中的过滤器规格对象不匹配，则将过滤器规格对象添加到TC过滤器规格列表中。4.如果输入RSB的FlowSpec对象大于TC_FlowSpec，则打开is_最大标志。5.搜索匹配的交通控制状态块（TCSB），其会话对象、传出接口和筛选器规范对象与输入RSB的会话对象、传出接口和筛选器规范对象匹配。6.如果未找到此类TCSB，请创建新的TCSB。7.如果找到匹配的TCSB，请修改保留。8.如果启用了Is_最大标志，则启用Resv Refresh Needed标志，否则将向输入RSB的ResvConfig对象中的IP地址发送ResvConf消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.4 pathmsg: The functions to be done by this state are done through the function call PathMsgPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.4 pathmsg：通过上述函数调用PathMsgPro完成此状态下要完成的函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.5 resvmsg: The functions that would be done by this state are done through the function call ResvMsgPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.5 resvmsg：通过上述函数调用ResvMsgPro完成此状态下的函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.6 ptearmsg: The functions that would be done by this state are done through the function call PathTearPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.6 ptearmsg：此状态下将完成的函数通过上述函数调用PathTearPro完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.7 rtearmsg: The functions that would be done by this state are done through the function call ResvTearPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.7 rtearmsg：通过上述函数调用ResvTearPro完成此状态下的函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.8 rconfmsg: The functions that would be done by this state are done through the function call ResvConfPro described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.2.8 rconfmsg：通过上述函数调用ResvConfPro完成此状态下的函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 RSVP on Hosts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 主机上的RSVP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 9 shows the process of RSVP on hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图9显示了主机上RSVP的过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1 初始化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initializes all the variables. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始化所有变量。默认转换为空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
[Figure 9: RSVP process on hosts]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
[图9：主机上的RSVP流程]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2 idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2 闲置的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state transit to the Arr state on packet arrival.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该状态在数据包到达时转换为Arr状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3 Arr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3 啊
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state calls the appropriate functions depending on the type of message received. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态根据收到的消息类型调用相应的函数。默认转换为空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. MakeSessionCall: This function is called from the Arr state whenever a Session call is received from the local application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. MakeSessionCall：每当从本地应用程序接收到会话调用时，就会从Arr状态调用此函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Search for the Session Information. 2. If one is found return the corresponding Session Id. 3. If the session information is not found assign a new session Id to the session to the corresponding session. 4. Make an UpCall to the local application with this Session Id.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 搜索会话信息。2.如果找到一个，则返回相应的会话Id.3。如果未找到会话信息，请将新会话Id分配给相应会话的会话。4.使用此会话Id向上调用本地应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. MakeSenderCall: This function is called from the Arr state whenever a Sender call is received from the local application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. MakeSenderCall：每当从本地应用程序接收到发送方调用时，就会从Arr状态调用此函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Get the information corresponding to the Session Id and create a Path message corresponding to this session. 2. A copy of the packet is buffered and used by the host to send the PATH message periodically. 3. This packet is sent to the IP layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 获取与会话Id对应的信息，并创建与此会话对应的路径消息。2.数据包的副本被缓冲并由主机用于定期发送PATH消息。3.该数据包被发送到IP层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. MakeReserveCall: This function is called from the Arr state whenever a Reserve call is received from the local application. This function will create and send a Resv message. Also, the packet is buffered for later use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. MakeReserveCall：每当从本地应用程序接收到保留调用时，就会从Arr状态调用此函数。此函数将创建并发送Resv消息。此外，数据包被缓冲以供以后使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. MakeReleaseCall: This function is called from the Arr state whenever a Release call is received from the local application. This function will generate a PathTear message if the local application is sender or generates a ResvTear message if the local application is receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. MakeReleaseCall：每当从本地应用程序接收到释放调用时，就会从Arr状态调用此函数。如果本地应用程序是发送方，则此函数将生成PathTear消息；如果本地应用程序是接收方，则此函数将生成ResvTear消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.3.4 Session This state&#39;s function is performed by the MakeSessionCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.3.4 会话此状态的函数由MakeSessionCall函数执行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5 Sender
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5 发件人
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state&#39;s function is han by the MakeSenderCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态的函数由MakeSenderCall函数调用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.3.6 Reserve This state&#39;s function is performed by the MakeReserveCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
4.3.6 保留此状态的函数由MakeReserveCall函数执行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.7 Release
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.7 释放
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state&#39;s function is performed by the MakeReleaseCall function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态的函数由MakeReleaseCall函数执行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Multicast Routing Model Interface
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 多播路由模型接口
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because this set of models was intended particularly to enable evaluation by simulation of various multicast routing protocols, we give particular attention in this section to the steps necessary to interface a routing protocol model to the other models. We have available implementations of DVMRP and OSPF, which we will describe below. Instructions for invoking these models are contained in a separate User&#39;s Guide for the models.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于这组模型旨在通过模拟各种多播路由协议来实现评估，因此我们在本节中特别关注将路由协议模型连接到其他模型所需的步骤。我们有DVMRP和OSPF的可用实现，我们将在下面描述。调用这些模型的说明包含在单独的模型用户指南中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Creation of multicast routing processor node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 多播路由处理器节点的创建
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interfacing a multicast routing protocol using the OPNET Simulation package requires the creation of a new routing processor node in the node editor and linking it via packet streams. Packet streams are unidirectional links used to interconnect processor nodes, queue nodes, transmitters and receiver nodes. A duplex connection between two nodes is represented by using two unidirectional links to connect the two nodes to and from each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用OPNET仿真包连接多播路由协议需要在节点编辑器中创建新的路由处理器节点，并通过数据包流将其链接。分组流是用于互连处理器节点、队列节点、发射机和接收机节点的单向链路。两个节点之间的双工连接表示为使用两个单向链路将两个节点相互连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A multicast routing processor node is created in the node editor and links are created to and from the processors(duplex connection) that interact with this module, the IGMP processor node and the IP processor node. Within the node editor, a new processor node can be created by selecting the button for processor creation (plain gray node on the node editor control panel) and by clicking on the desired location in the node editor to place the node. Upon creation of the processor node, the name of the processor can be specified by right clicking on the mouse button and entering the name value on the attribute box presented. Links to and from this node are generated by selecting the packet stream button (represented by two gray nodes connected with a solid green arrow on the node editor control panel), left clicking on the mouse button to specify the source of the link and right clicking on the mouse button to mark the destination of the link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在节点编辑器中创建多播路由处理器节点，并在与此模块、IGMP处理器节点和IP处理器节点交互的处理器之间创建链接（双工连接）。在节点编辑器中，通过选择处理器创建按钮（节点编辑器控制面板上的纯灰色节点）并单击节点编辑器中的所需位置以放置节点，可以创建新的处理器节点。创建处理器节点后，可以通过右键单击鼠标按钮并在显示的属性框中输入名称值来指定处理器的名称。通过选择“数据包流”按钮（由节点编辑器控制面板上的两个灰色节点连接绿色实心箭头表示），左键单击鼠标按钮以指定链接的来源，右键单击鼠标按钮以标记链接的目的地，可以生成与此节点之间的链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Interfacing processor nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 接口处理器节点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The multicast routing processor node is linked to the IP processor node and the IGMP processor node each with a duplex connection. A duplex connection between two nodes is represented by two uni-directional links interconnecting them providing a bidirectional flow of information or interrupts, as shown in Figure 6. The IP processor node (in the subnet router) interfaces with the multicast routing processor node, the unicast routing processor node, the Resource Reservation processor node(RSVP), the ARP processor node( only on
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播路由处理器节点通过双工连接链接到IP处理器节点和IGMP处理器节点。两个节点之间的双工连接由两个单向链路表示，它们相互连接，提供双向信息流或中断，如图6所示。IP处理器节点（在子网路由器中）与多播路由处理器节点、单播路由处理器节点、资源预留处理器节点（RSVP）、ARP处理器节点（仅在
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
subnet routers and hosts), the IGMP processor node, and finally the MAC processor node (only on subnet routers and hosts) each with a duplex connection with exceptions for ARP and MAC nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子网路由器和主机），IGMP处理器节点，最后是MAC处理器节点（仅在子网路由器和主机上），每个节点都具有双工连接，但ARP和MAC节点除外。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1 Interfacing ARP and MAC processor nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.1 连接ARP和MAC处理器节点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The service of the ARP node is required only in the direction from the IP layer to the MAC layer(requiring only a unidirectional link from IP processor node to ARP processor node). The MAC processor node on the subnet router receives multicast packets destined for all multicast groups in the subnet, in contrast to the MAC node on subnet hosts which only receives multicast packets destined specifically for its multicast group. The MAC node connects to the IP processor node with a single uni-directional link from it to the IP node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ARP节点的服务仅在从IP层到MAC层的方向上需要（只需要从IP处理器节点到ARP处理器节点的单向链路）。子网路由器上的MAC处理器节点接收目的地为子网中所有多播组的多播数据包，而子网主机上的MAC节点仅接收目的地为其多播组的多播数据包。MAC节点通过从它到IP节点的单个单向链路连接到IP处理器节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2 Interfacing IGMP, IP, and multicast routing processor nodes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2 接口IGMP、IP和多播路由处理器节点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IGMP processor node interacts with the multicast routing processor node, unicast routing processor node, and the IP processor node. Because the IGMP node is linked to the IP node, it is thus able to update the group membership table(in this model, the group membership table is represented by the local interface(interface 0) of the multicast routing table data structure) within the IP node. This update triggers a signal to the multicast routing processor node from the IGMP node causing it to reassess the multicast routing table within the IP node. If the change in the group membership table warrants a modification of the multicast routing table, the multicast routing processor node interacts with the IP node to modify the current multicast routing table according to the new group membership information updated by IGMP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMP处理器节点与多播路由处理器节点、单播路由处理器节点和IP处理器节点交互。由于IGMP节点链接到IP节点，因此它能够更新IP节点内的组成员表（在此模型中，组成员表由多播路由表数据结构的本地接口（接口0）表示）。此更新触发来自IGMP节点的多播路由处理器节点的信号，使其重新评估IP节点内的多播路由表。如果组成员资格表中的更改保证修改多播路由表，则多播路由处理器节点与IP节点交互，以根据IGMP更新的新组成员资格信息修改当前多播路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.1 Modification of group membership table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.1 组成员表的修改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change in the group membership occurs with the decision at a host to leave or join a particular multicast group. The IGMP process on the gateway periodically sends out queries to the IGMP processes on hosts within the subnet in an attempt to determine which hosts currently are receiving packets from particular groups. Not receiving a response for a pending IGMP host query specific to a group indicates to the gateway IGMP that no host belonging to the particular group exists in the subnet. This occurs when the last remaining member of a multicast group in the subnet leaves. In this case the IGMP processor node updates the group membership able and triggers a modification of the multicast routing table by alerting the multicast routing processor node. A prune message specific to the group is initiated and propagated upward establishing a prune state for the interface leading to the present subnet, effectively removing this subnet from the group-specific multicast spanning tree
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当主机决定离开或加入某个特定的多播组时，组成员身份发生变化。网关上的IGMP进程定期向子网内主机上的IGMP进程发送查询，以确定哪些主机当前正在从特定组接收数据包。未收到特定于某个组的挂起IGMP主机查询的响应向网关IGMP指示子网中不存在属于特定组的主机。当子网中多播组的最后一个剩余成员离开时，会发生这种情况。在这种情况下，IGMP处理器节点更新组成员资格，并通过向多播路由处理器节点发出警报来触发对多播路由表的修改。启动并向上传播特定于组的修剪消息，为通向当前子网的接口建立修剪状态，从而有效地从特定于组的多播生成树中删除该子网
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
and potentially leading to additional pruning of spanning tree edges as the prune message travels higher up the tree. Joining a multicast group is also managed by the IGMP process which updates the group membership table leading to a possible modification of the multicast routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当剪枝消息在树的更高位置传播时，可能会导致生成树边缘的额外剪枝。加入多播组也由IGMP进程管理，IGMP进程更新组成员表，从而可能修改多播路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.2 Dependency on unicast routing protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2.2.2 对单播路由协议的依赖性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The multicast routing protocol is dependent on a unicast routing protocol (RIP or OSPF) to handle multicast routing. The next hop interface to the source of the packet received, or the upstream interface, is determined using the unicast routing protocol to trace the reverse path back to the source of the packet. If the packet received arrived on this upstream interface, then the packet can be propagated downstream through its downstream interfaces (excluding the interface in which the packet was received). Otherwise, the packet is deemed to be a duplicate and dropped, halting the propagation of the packet downstream. This repeated reverse path checking and broadcasting eventually generates the spanning tree for multicast routing of packets. To determine the reverse path forward interface of a received multicast packet propagated up from the IP layer, the multicast routing processor node retrieves a copy of the unicast routing table from the IP processor node and uses it to recalculate the multicast routing table in the IP processor node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播路由协议依赖于单播路由协议（RIP或OSPF）来处理多播路由。使用单播路由协议确定到所接收分组的源的下一跳接口或上行接口，以将反向路径追溯回分组的源。如果接收到的数据包到达该上游接口，则该数据包可以通过其下游接口（不包括接收数据包的接口）向下游传播。否则，该分组被认为是重复的并被丢弃，从而停止该分组在下游的传播。这种重复的反向路径检查和广播最终生成数据包多播路由的生成树。为了确定从IP层向上传播的接收到的多播分组的反向路径转发接口，多播路由处理器节点从IP处理器节点检索单播路由表的副本，并使用它重新计算IP处理器节点中的多播路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Interrupt Generation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 中断生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the OPNET tools, interrupts to the multicast routing processor node are generated in several ways. One is the arrival of a multicast packet along a packet stream (at the multicast routing processor node) when the packet is received by the MAC node and propagated up the IP node where upon discarding the IP header determination is made as to which upper layer protocol to send the packet. A second type of interrupt generation occurs by remote interrupts from the IGMP process alerting the multicast routing process of an update in the group membership table. A third occurs when the specific source/group (S,G) entry for a multicast packet received at the IP node does not exist in the current multicast routing table and a new entry needs to be created. The IP node generates an interrupt to the multicast routing processor node informing it to create a new source/group entry on the multicast routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用OPNET工具，可以通过多种方式生成对多播路由处理器节点的中断。一个是当分组被MAC节点接收并向上传播到IP节点时，多播分组沿着分组流到达（在多播路由处理器节点处），其中在丢弃IP报头时确定发送分组的上层协议。第二种类型的中断由来自IGMP进程的远程中断产生，该远程中断向多播路由进程发出组成员资格表中更新的警报。第三种情况发生在当前多播路由表中不存在在IP节点接收的多播分组的特定源/组（S，G）条目并且需要创建新条目时。IP节点向多播路由处理器节点生成一个中断，通知它在多播路由表上创建一个新的源/组条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 Types of interrupts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.1 中断类型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The process interrupts generated within the OPNET model can be handled by specifying the types of interrupts and the conditions for the interrupts using the interrupt code, integer number representing
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OPNET模型中生成的进程中断可以通过使用中断代码（整数表示）指定中断类型和中断条件来处理
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the condition for a specific interrupt. The conditions for interrupts are specified on the interrupt stream linking the interrupt generating state and the state resulting from the interrupt. For self-interrupts (interrupts occurring among states within the same process), interrupts of type OPC_INTRPT_SELF are used. For remote interrupts (interprocess interrupts), the conditions for specific interrupts are specified from the idle state to the state resulting from the interrupt within the remote process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定中断的条件。中断条件在连接中断生成状态和中断产生状态的中断流上指定。对于自中断（在同一进程内的状态之间发生的中断），使用OPC_INTRPT_self类型的中断。对于远程中断（进程间中断），特定中断的条件从空闲状态指定为远程进程内中断产生的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remote interrupts are of type, OPC_INTRPT_REMOTE. A third type of interrupt is the OPC_INTRPT_STRM, which is triggered when packets arrive via a packet stream, indicating its arrival. The condition of this interrupt is also specified from the idle state to the resultant state by the interrupt condition stream defined by a unique interrupt code. For all of these interrupts, the interrupt code is provided within the header block (written in C language) of the interrupted process. When the condition for the interrupt becomes true, a transition is made to the resultant state specified by the interrupt stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
远程中断类型为OPC_INTRPT_remote。第三种类型的中断是OPC_INTRPT_STRM，当数据包通过数据包流到达时触发，指示其到达。该中断的条件也由唯一中断代码定义的中断条件流指定，从空闲状态到结果状态。对于所有这些中断，中断代码都在中断进程的头块（用C语言编写）中提供。当中断条件变为真时，转换到中断流指定的结果状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2 Conditions for interrupts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3.2 中断条件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several interrupt connections exist to interface the IGMP processor node, IP processor node , and the multicast routing processor node with each other in the present OPNET Simulation Model. Also, the IP processor node interfaces with the unicast routing protocol which interfaces with the IGMP processor node. An OPC_INTRPT_STRM interrupt is generated when a multicast packet arrives via a packet stream from the IP processor node to the multicast routing processor node. A remote interrupt of type, OPC_INTRPT_REMOTE, is generated from the IGMP process to the IP process when a member of a group relinquishes membership from a particular group or a new member is added to a group. This new membership is updated in the group membership table located in the IP node by the IGMP process which also generates a remote interrupt to the multicast routing protocol process, causing a recalculation of the multicast routing table in the IP module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在目前的OPNET仿真模型中，存在多个中断连接以将IGMP处理器节点、IP处理器节点和多播路由处理器节点相互连接。此外，IP处理器节点与单播路由协议接口，单播路由协议与IGMP处理器节点接口。当多播数据包通过数据包流从IP处理器节点到达多播路由处理器节点时，将生成OPC_INTRPT_STRM中断。当组成员从特定组中放弃成员资格或向组中添加新成员时，从IGMP进程到IP进程生成类型为OPC_INTRPT_remote的远程中断。IGMP进程在位于IP节点的组成员资格表中更新此新成员资格，IGMP进程还生成对多播路由协议进程的远程中断，从而导致重新计算IP模块中的多播路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 Modifications of modules in the process model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 流程模型中模块的修改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Modifications of routing protocol modules (in fact all of the modules in the process model) are made transparently throughout the network using the OPNET Simulation tools. An addition or modification of a routing module in any subnet will reflect on all the subnets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用OPNET仿真工具在整个网络中透明地修改路由协议模块（实际上是流程模型中的所有模块）。在任何子网中添加或修改路由模块将反映在所有子网上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. OSPF and MOSPF Models
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. OSPF和MOSPF模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF and MOSPF models [5] are implemented in the OSPF model containing fourteen states. They only exist on routers. Figure 10 shows the process model. The following processing takes place in the indicated modules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OSPF和MOSPF模型[5]在包含14个状态的OSPF模型中实现。它们只存在于路由器上。图10显示了流程模型。以下处理在所示模块中进行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1 初始化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state initializes all the router variables. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态初始化所有路由器变量。默认转换为空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2 闲置的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state has several transitions. If a packet arrives it transits to arr state. Depending on interrupts received it will transit to BCOspfLsa, BCMospfLsa, hello_pks state. In future versions, links coming up or down will also cause a transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态有几个转换。如果数据包到达，它将转换为arr状态。根据收到的中断，它将传输到BCOspfLsa、BCMospfLsa、hello_pks状态。在未来的版本中，上下链接也会导致转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 BCOspfLsa
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3 BCOspfLsa
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transition to this state from idle state is executed whenever the condition send_ospf_lsa is true, which happens when the network is being initialized, and when ospf_lsa_refresh_timout occurs. This state will create Router, Network, Summary Link State Advertisements and pack all of them into an Link State Update packet. The Link State Update Packet is sent to the IP layer with a destination address of AllSPFRouters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
只要条件send_ospf_lsa为真，就会执行从空闲状态到该状态的转换，这发生在网络初始化时，以及发生ospf_lsa_刷新超时时。此状态将创建路由器、网络、摘要链路状态播发，并将它们全部打包到链路状态更新数据包中。链路状态更新数据包被发送到IP层，目标地址为AllSPFRouters。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
[Figure 10: OSPF and MOSPF process model on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
[图10：路由器上的OSPF和MOSPF进程模型]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 BCMospfLsa
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4 BCMospfLsa
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transition to this state from idle state is executed whenever the condition send_mospf_lsa is true. This state will create Group Membership Link State Advertisement and pack them into Mospf Link State Update Packet. This Mospf Link State Update Packet is sent to IP layer with a destination address of AllSPFRouters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
只要条件send_mospf_lsa为真，就会执行从空闲状态到该状态的转换。此状态将创建组成员链接状态公告，并将其打包到Mospf链接状态更新数据包中。这个Mospf链路状态更新包被发送到IP层，目标地址为AllSPFRouters。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5 arr
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5 啊
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The arr state checks the type of packet that is received upon a packet arrival. It calls the following functions depending on the protocol Id of the packet received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
arr状态检查数据包到达时接收的数据包类型。它根据接收到的数据包的协议Id调用以下函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. OspfPkPro: Depending on the type of OSPF/MOSPF packet received the function calls the following functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. OSPFPKRO：根据收到的OSPF/MOSPF数据包的类型，函数调用以下函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. HelloPk_pro: This function is called whenever a hello packet is received. This function updates the router&#39;s neighbor information, which is later used while sending the different LSAs. 2. OspfLsUpdatePk_pro: This function is called when an OSPF LSA update packet is received (router LSA, network LSA, or summary LSA). If the Router is an Area Border Router or if the LSA belongs to the Area whose Area Id is the Routers Area Id, then it is searched to determine whether this LSA already exists in the Link State database. If it exists and if the existing LSA&#39;s LS Sequence Number is less than the received LSA&#39;s LS Sequence Number the existing LSA was replaced with the received one. The function processes the Network LSA only if it is a designated router or Area Border Router. It processes the Summary LSA only if the router is a Area Border Router. The function also turns on the trigger ospfspfcalc which is the condition for the transition from arr state to ospfspfcalc. 3. MospfLsUpdatePk_pro: This function is called when a MOSPF LSA update packet is received. It updates the group membership link state database of the router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. HelloPk_pro：每当收到hello数据包时，就会调用此函数。此功能更新路由器的邻居信息，稍后在发送不同的LSA时使用。2.OSPFLSA更新包：当收到OSPF LSA更新包（路由器LSA、网络LSA或摘要LSA）时，调用此函数。如果路由器是区域边界路由器，或者如果LSA属于其区域Id为路由器区域Id的区域，则将对其进行搜索以确定链路状态数据库中是否已存在此LSA。如果存在，并且如果现有LSA的LS序列号小于接收到的LSA的LS序列号，则现有LSA将替换为接收到的LSA。仅当网络LSA是指定路由器或区域边界路由器时，该功能才处理该网络LSA。仅当路由器是区域边界路由器时，它才处理摘要LSA。该功能还打开触发OSPFSCALC，这是从arr状态转换到OSPFSCALC的条件。3.MospfLsUpdatePk_pro：当收到MOSPF LSA更新数据包时调用此函数。它更新路由器的组成员链接状态数据库。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6 hello_pks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6 你好
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello packets are created and sent with destination address of AllSPFRouters. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello数据包被创建并发送，目标地址为AllSPFRouters。默认转换为空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7 mospfspfcalc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7 mospfspfcalc
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following functions are used to calculate the shortest path tree and routing table. This state transit to upstr_node upon detupstrnode condition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下函数用于计算最短路径树和路由表。此状态在detupstrnode条件下转移到upstr_节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. CandListInit: Depending upon the SourceNet of the datagram, the candidate lists are initialized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. CandListInit：根据数据报的源网，候选列表被初始化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. MospfCandAddPro: The vertex link is examined and if the other end of the link is not a stub network and is not already in the candidate list it is added to the candidate list after calculating the cost to that vertex. If this other end of the link is already on the shortest path tree and the calculated cost is less than the one that shows in the shortest path tree entry update the shortest path tree to show the calculated cost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. MospfCandAddPro：检查顶点链接，如果链接的另一端不是存根网络且不在候选列表中，则在计算该顶点的成本后将其添加到候选列表中。如果链接的另一端已在最短路径树上，且计算的成本小于最短路径树条目中显示的成本，则更新最短路径树以显示计算的成本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. MospfSPFTreeCalc: The vertex that is closest to the root that is in the candidate list is added to the shortest path tree and its link is considered for possible inclusions in the candidate list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. MospfSPFTreeCalc：最靠近候选列表中的根的顶点将添加到最短路径树，并考虑其链接是否可能包含在候选列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. MCRoutetableCalc: Multicast routing table is calculated using the information of the MOSPF shortest Path tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. MCRoutetableCalc：使用MOSPF最短路径树的信息计算多播路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8 ospfspfcalc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.8 OSPFSCALC
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following functions are used in this state to calculate the shortest path tree and using this information the routing table. Transition to ospfspfcalc state on ospfcalc condition. This is set to one after processing all functions in the state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在此状态下，以下函数用于计算最短路径树，并使用此信息创建路由表。在ospfcalc条件下过渡到OSPFSFCALC状态。在处理状态中的所有函数后，将此设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. OspfCandidateAddPro: This function initializes the candidate list by examining the link state advertisement of the Router. For each link in this advertisement, if the other end of the link is a router or transit network and if it is not already in the shortest-path tree then calculate the distance between these vertices. If the other end of this link is not already on the candidate list or if the distance calculated is less than the value that appears for this other end add the other end of the link to candidate list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. OspfCandidateAddPro：此函数通过检查路由器的链路状态公告来初始化候选列表。对于此广告中的每个链接，如果链接的另一端是路由器或传输网络，并且它不在最短路径树中，则计算这些顶点之间的距离。如果此链接的另一端不在候选列表中，或者如果计算的距离小于此另一端显示的值，请将链接的另一端添加到候选列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. OspfSPTreeBuild: This function pulls each vertex from the candidate list that is closest to the root and adds it to the shortest path tree. In doing so it deletes the vertex from the candidate list. This function continues to do this until the candidate list is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. OspfSPTreeBuild：此函数从最接近根的候选列表中提取每个顶点，并将其添加到最短路径树中。执行此操作时，将从候选列表中删除顶点。此函数将继续执行此操作，直到候选列表为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. OspfStubLinkPro: In this procedure the stub networks are added to shortest path tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. OspfStubLinkPro：在此过程中，存根网络被添加到最短路径树中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. OspfSummaryLinkPro: If the router is an Area Border Router the summary links that it has received is examined. The route to the Area border router advertising this summary LSA is examined in the routing table. If one is found a routing table update is done by adding the route to the network specified in the summary LSA and the cost to this route is sum of the cost to area border router advertising this and the cost to reach this network from that area border router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. OspfSummaryLinkPro：如果路由器是区域边界路由器，则检查它接收到的摘要链接。发送此摘要LSA的区域边界路由器的路由在路由表中进行检查。如果找到一个路由表，则通过将路由添加到摘要LSA中指定的网络来更新路由表，该路由的成本是区域边界路由器的成本和从该区域边界路由器到达该网络的成本之和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. RoutingTableCalc: This function updates the routing table by examining the shortest path tree data structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. RoutingTableCalc：此函数通过检查最短路径树数据结构来更新路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9 upstr_node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.9 upstr_节点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state does not do anything in the present model. It transitions to DABRA state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态在当前模型中不起任何作用。它过渡到达布拉州。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.10 DABRA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.10 达布拉
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the router is an Area Border Router and the area is the source area then a DABRA message is constructed and send to all the downstream areas. Default transition to idle state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果路由器是区域边界路由器，并且该区域是源区域，则构建DABRA消息并发送到所有下游区域。默认转换为空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. DVMRP Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. DVMRP模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DVMRP model is implemented based on reference [6], DVMRP version 3. There are nine states. The DVMRP process only exists on Routers. Figure 11 shows the states of the DVMRP process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DVMRP模型是在参考文献[6]DVMRP版本3的基础上实现的。有九个州。DVMRP进程仅存在于路由器上。图11显示了DVMRP过程的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 Init
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1 初始化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialize all variables, routing table and forwarding table and load the simulation parameters. It will transit to the Idle state after completing all the initializations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始化所有变量、路由表和转发表，并加载模拟参数。完成所有初始化后，它将转换为空闲状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 Idle
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2 闲置的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The simulation waits for the next scheduled event or remotely invoked event in the Idle State and transit to the state accordingly. In the DVMRP model, Idle State has transitions to Probe_Send, Report_Send, Prune_Send, Graft_Send, Arr_Pkt, Route_Calc and Timer states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
模拟在空闲状态下等待下一个计划事件或远程调用的事件，并相应地转换到该状态。在DVMRP模型中，空闲状态转换为探测发送、报告发送、修剪发送、嫁接发送、Arr发送、路由计算和计时器状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
[Figure 11. DVMRP process on routers]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
[图11.路由器上的DVMRP过程]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 Probe_Send State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3 探测发送状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DVMRP router sends Probe messages periodically to inform other DVMRP routers that it is operational. A DVMRP router lists all its known neighbors&#39; addresses in the Probe message and sends it to All-DVMRP-Routers address. The routers will not process any message that comes from an unknown neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DVMRP路由器定期发送探测消息，通知其他DVMRP路由器它正在运行。DVMRP路由器在探测消息中列出其所有已知邻居的地址，并将其发送到所有DVMRP路由器地址。路由器不会处理来自未知邻居的任何消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4 Report_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4 报告发送
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid sending Report at the same time for all DVMRP routers, the interval between two Report messages is uniformly distributed with average 60 seconds. The router lists source router&#39;s address, upstream router&#39;s address and metric of all sources into the Report message and sends it to All-DVMRP-Routers address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为避免所有DVMRP路由器同时发送报告，两条报告消息之间的间隔平均为60秒。路由器在报告消息中列出所有源的源路由器地址、上游路由器地址和度量，并将其发送到所有DVMRP路由器地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5 Prune_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.5 剪枝
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition to this state is triggered by the local IGMP process. When a host on the subnetwork drops from a group, the IGMP process asks DVMRP to see if the branch should be pruned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到该状态的转换由本地IGMP进程触发。当子网络上的主机从组中删除时，IGMP进程要求DVMRP查看是否应该删除分支。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The router obtains the group number from IGMP and checks the IP Multicast membership table to find out if there is any group member that is still in the group. If the router determines that the last host has resigned, it goes through the entire forwarding table to locate all sources for that group. The router sends Prune message,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器从IGMP获得组号，并检查IP多播成员表，以确定是否有任何组成员仍在组中。如果路由器确定最后一台主机已退出，它将遍历整个转发表以查找该组的所有源。路由器发送剪枝消息，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
containing source address, group address and prune lifetime, separately for each (source, group) pair and records the row as pruned in the forwarding table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分别包含每个（源、组）对的源地址、组地址和修剪生存期，并在转发表中记录修剪后的行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6 Graft_Send
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.6 嫁接
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition to this state is triggered by the local IGMP process. Once a multicast delivery has been pruned, Graft messages are necessary when a host in the local subnetwork joins into the group. A Graft message sent to the upstream router should be acknowledged hop by hop to the root of the tree guaranteeing end-to-end delivery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到该状态的转换由本地IGMP进程触发。一旦一个多播传递被删减，当本地子网中的主机加入到组中时，就需要嫁接消息。发送到上游路由器的嫁接消息应逐跳确认到树的根，以保证端到端传递。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The router obtains the group number from IGMP and go through the forwarding table to locate all traffic sources for that group. A Graft message will be sent to the upstream router with the source address and group address for each (source, group) pair. The router also setups a timer for each Graft message waiting for an acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器从IGMP获得组号，并通过转发表查找该组的所有流量源。将向上游路由器发送一条嫁接消息，其中包含每个（源、组）对的源地址和组地址。路由器还为每个等待确认的嫁接消息设置计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7 Arr_Pkt
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.7 阿鲁普克特酒店
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All DVMRP control messages will be sent up to DVMRP layer by IP. The function performed by the DVMRP layer depends upon the type of the message received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有DVMRP控制消息将通过IP发送到DVMRP层。DVMRP层执行的功能取决于接收的消息类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. Probe message: The router checks the neighbors&#39; list in Probe message, update its their status to indicate the availability of its neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. 探测消息：路由器检查探测消息中的邻居列表，更新其状态以指示其邻居的可用性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. Report message: Based on exchanging report messages, the routers can build the Multicast delivery tree rooted at each source. A function called ReportPkPro will be called to handle all possible situations when receiving a report message. If the message is a poison reverse report and not coming from one of the dependent downstreams, the incoming interface should be added to the router&#39;s downstream list. If the message is not a poison reverse report but it came from one of the downstreams, this interface should be deleted from the downstreams list. And then, the router compared the metric got from the message with the metric of the current upstream, if the new metric is less than the older one, the router&#39;s upstream interface should be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. 报告消息：在交换报告消息的基础上，路由器可以在每个源上建立多播传递树。在接收报告消息时，将调用名为ReportPkPro的函数来处理所有可能的情况。如果消息是有毒反向报告，并且不是来自某个相关的下游，则应将传入接口添加到路由器的下游列表中。如果消息不是有毒反向报告，但它来自一个下游，则应从下游列表中删除此接口。然后，路由器将从消息中获得的度量与当前上游的度量进行比较，如果新度量小于旧度量，则应更新路由器的上游接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Prune message: The router extracts the source address, group address and prune lifetime, marks the incoming interface as pruned in the dependent downstream list of the (source, group) pair. If all downstream interfaces have been pruned, the router will send a prune message to its upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. 修剪消息：路由器提取源地址、组地址和修剪生存期，在（源、组）对的从属下游列表中将传入接口标记为修剪。如果所有下游接口都已修剪，路由器将向其上游发送修剪消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. Graft message: The router extracts the source and group address, active the incoming interface in the dependent downstream list of the (source, group) pair. If the (source, group) pair has been pruned, the router will reconnect the branch by sending a graft message to its upstream interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d. 嫁接消息：路由器提取源地址和组地址，在（源、组）对的从属下游列表中激活传入接口。如果（源、组）对已被修剪，路由器将通过向其上游接口发送嫁接消息来重新连接分支。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. Graft Acknowledge message: The router extracts the source and group address, clear the graft message timer of the (source, group) pair in the forwarding table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e. 嫁接确认消息：路由器提取源和组地址，清除转发表中（源、组）对的嫁接消息计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8 Route_Calc
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.8 路线计算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition to this state is triggered by the local IP process. Once the IP receives a packet, it will fire a remote interrupt to the DVMRP and ask the DVMRP to prepare the outgoing interfaces for the packet. The DVMRP process obtains the packet&#39;s source address and group address from the IP and checks the (source, group) pairs in the forwarding table to decide the branches that have the group members on the Multicast delivery tree. The Group Membership Table on IP will be updated based on this knowledge.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到该状态的转换由本地IP进程触发。一旦IP收到数据包，它将向DVMRP发出远程中断，并要求DVMRP为数据包准备输出接口。DVMRP进程从IP获取数据包的源地址和组地址，并检查转发表中的（源、组）对，以确定在多播传递树上具有组成员的分支。IP上的组成员资格表将根据此知识进行更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.9 Timer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.9 计时器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state is activated once every second. It checks the forwarding table, if the Graft message acknowledgment timer is expired, The router will retransmit the Graft message to the upstream. If the prune state lifetime timer is expired, the router will graft this interface so that the downstream router can receive the packets to the group again. The router also checks if the (source, group) pair is pruned by the upstream router, if so, it will send a graft message to the upstream interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态每秒激活一次。它检查转发表，如果嫁接消息确认计时器过期，路由器将把嫁接消息重新传输到上游。如果修剪状态生存时间计时器过期，路由器将移植此接口，以便下游路由器可以再次接收到组中的数据包。路由器还检查上游路由器是否修剪了（源、组）对，如果是，它将向上游接口发送嫁接消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Simulation performance
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 仿真性能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Our simulations of three network models with MOSPF routing have showed good Scalability of the protocol. The running platform we used is a SGI Octane Station with 512 MB main memory and MIPS R10000 CPU, Rev 2.7. Here we list the real running time of each model along with its major elements and the packet inter-arrival times for the streams generated in the hosts.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们对三种采用MOSPF路由的网络模型进行了仿真，结果表明该协议具有良好的可扩展性。我们使用的运行平台是SGI Octane工作站，具有512 MB主内存和MIPS R10000 CPU，版本2.7。这里，我们列出了每个模型的实际运行时间及其主要元素，以及主机中生成的流的数据包到达时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Simulated Debug Model Intermediate Model Large Model time 11 Routers 42 routers 86 routers 12 Hosts 48 hosts 96 hosts
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
模拟调试模型中间模型大模型时间11路由器42路由器86路由器12主机48主机96主机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
 Reserve Data Reserve Data Reserve Data 0.01s 0.02s 0.02s Best-effort Data Best-effort Data Best-effort Data 0.01s 0.025s 0.025s
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
保留数据保留数据保留数据0.01s 0.02s 0.02s尽力数据尽力数据尽力数据0.01s 0.025s 0.025s
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
100 s 3 hours 14 hours 30 hours 200 s 7 hours 30 hours - - -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
100秒3小时14小时30小时200秒7小时30小时---
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Future work
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 今后的工作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We hope to receive assistance from the IPmc/RSVP development community within the IETF in validating and refining this model. We believe it will be a useful tool for predicting the behavior of RSVP-capable systems.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们希望得到IETF内IPmc/RSVP开发社区的帮助，以验证和完善该模型。我们相信这将是一个有用的工具，用于预测具有RSVP能力的系统的行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This RFC raises no security considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此RFC不引起任何安全考虑。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Deering, S., &#34;Host Requirements for IP Multicasting&#34;, STD 5, RFC 1112, August 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Deering，S.，“IP多播的主机要求”，STD 5，RFC 1112，1989年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Braden, R., Zhang, L., Berson, S., Herzog, S. and S. Jamin, &#34;Resource Reservation Protocol (RSVP) -- Version 1 Functional Specification&#34;, RFC 2205, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Braden，R.，Zhang，L.，Berson，S.，Herzog，S.和S.Jamin，“资源预留协议（RSVP）——第1版功能规范”，RFC 22052997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Wroclawski, J., &#34;The Use of RSVP with IETF Integrated Services&#34;, RFC 2210, September 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Wroclawski，J.，“RSVP与IETF综合服务的使用”，RFC 2210，1997年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] MIL3 Inc., &#34;OPNET Modeler Tutorial Version 3&#34;, Washington, DC, 1997
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] MIL3公司，“OPNET建模师教程第3版”，华盛顿特区，1997年
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Moy, J., &#34;Multicast Extensions to OSPF&#34;, RFC 1584, March 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Moy，J.，“OSPF的多播扩展”，RFC1584，1994年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Pusateri, T., &#34;Distance Vector Multicast Routing Protocol&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] “距离向量多播路由协议”，正在进行中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
J. Mark Pullen C3I Center/Computer Science Mail Stop 4A5 George Mason University Fairfax, VA 22032
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
J.马克·普伦C3I中心/计算机科学邮件站4A5乔治梅森大学费尔法克斯，弗吉尼亚州22032
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: mpullen@gmu.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: mpullen@gmu.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ravi Malghan 3141 Fairview Park Drive, Suite 700 Falls Church VA 22042
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ravi Malghan 3141美景公园大道700室Falls Church VA 22042
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: rmalghan@bacon.gmu.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: rmalghan@bacon.gmu.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lava K. Lavu Bay Networks 600 Technology Park Dr. Billerica, MA 01821
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lava K.Lavu Bay Networks 600技术园Billerica博士，马萨诸塞州01821
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: llavu@bacon.gmu.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: llavu@bacon.gmu.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Gang Duan Oracle Co. Redwood Shores, CA 94065
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
冈端甲骨文有限公司，加利福尼亚州红木海岸，邮编94065
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: gduan@us.oracle.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: gduan@us.oracle.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jiemei Ma Newbridge Networks Inc. 593 Herndon Parkway Herndon, VA 20170
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
杰美马新桥网络有限公司，弗吉尼亚州赫恩登市赫恩登公园路593号，邮编：20170
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jma@newbridge.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jma@newbridge.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hoon Nah C3I Center Mail Stop 4B5 George Mason University Fairfax, VA 22030
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hoon Nah C3I中心邮件站4B5乔治梅森大学费尔法克斯，弗吉尼亚州22030
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: hnah@bacon.gmu.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: hnah@bacon.gmu.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1999年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
