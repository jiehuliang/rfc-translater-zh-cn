<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 5236: Improved Packet Reordering Metrics中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC5236 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">5236</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc5236.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">原文</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 5236: Improved Packet Reordering Metrics 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc5236" target="_blank">
              https://datatracker.ietf.org/doc/html/rfc5236
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 5236</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                      A. Jayasumana
Request for Comments: 5236                     Colorado State University
Category: Informational                                       N. Piratla
                                                   Deutsche Telekom Labs
                                                                T. Banka
                                               Colorado State University
                                                                 A. Bare
                                                              R. Whitner
                                              Agilent Technologies, Inc.
                                                               June 2008
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                      A. Jayasumana
Request for Comments: 5236                     Colorado State University
Category: Informational                                       N. Piratla
                                                   Deutsche Telekom Labs
                                                                T. Banka
                                               Colorado State University
                                                                 A. Bare
                                                              R. Whitner
                                              Agilent Technologies, Inc.
                                                               June 2008
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
Improved Packet Reordering Metrics
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-19">
改进的包重排序度量
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG Note
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG注释
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The content of this RFC was at one time considered by the IETF, and therefore it may resemble a current IETF work in progress or a published IETF work. The IETF standard for reordering metrics is RFC 4737. The metrics in this document were not adopted for inclusion in RFC 4737. This RFC is not a candidate for any level of Internet Standard. The IETF disclaims any knowledge of the fitness of this RFC for any purpose and in particular notes that the decision to publish is not based on IETF review for such things as security, congestion control, or inappropriate interaction with deployed protocols. The RFC Editor has chosen to publish this document at its discretion. Readers of this RFC should exercise caution in evaluating its value for implementation and deployment. See RFC 3932 for more information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF曾考虑过本RFC的内容，因此它可能类似于当前正在进行的IETF工作或已发布的IETF工作。IETF关于重新排序度量的标准是RFC 4737。本文件中的指标未纳入RFC 4737。本RFC不适用于任何级别的互联网标准。IETF不承认本RFC适用于任何目的的任何知识，特别注意到，发布决定并非基于IETF对安全、拥塞控制或与已部署协议的不当交互等事项的审查。RFC编辑已自行决定发布本文件。本RFC的读者应谨慎评估其实施和部署价值。有关更多信息，请参阅RFC 3932。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document presents two improved metrics for packet reordering, namely, Reorder Density (RD) and Reorder Buffer-occupancy Density (RBD). A threshold is used to clearly define when a packet is considered lost, to bound computational complexity at O(N), and to keep the memory requirement for evaluation independent of N, where N is the length of the packet sequence. RD is a comprehensive metric that captures the characteristics of reordering, while RBD evaluates the sequences from the point of view of recovery from reordering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文介绍了两种改进的数据包重排序指标，即重排序密度（RD）和重排序缓冲区占用密度（RBD）。阈值用于明确定义数据包何时被视为丢失，将计算复杂度限制在O（N）处，并保持评估的内存需求独立于N，其中N是数据包序列的长度。RD是一个综合指标，它捕获了重新排序的特征，而RBD从从重新排序恢复的角度评估序列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These metrics are simple to compute yet comprehensive in their characterization of packet reordering. The measures are robust and orthogonal to packet loss and duplication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些指标计算简单，但对数据包重新排序的描述全面。这些度量是健壮的，并且与数据包丢失和重复正交。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction and Motivation .....................................3
   2. Attributes of Packet Reordering Metrics .........................4
   3. Reorder Density and Reorder Buffer-Occupancy Density ............7
      3.1. Receive Index (RI) .........................................8
      3.2. Out-of-Order Packet ........................................9
      3.3. Displacement (D) ...........................................9
      3.4. Displacement Threshold (DT) ................................9
      3.5. Displacement Frequency (FD) ...............................10
      3.6. Reorder Density (RD) ......................................10
      3.7. Expected Packet (E) .......................................10
      3.8. Buffer Occupancy (B) ......................................10
      3.9. Buffer-Occupancy Threshold (BT) ...........................11
      3.10. Buffer-Occupancy Frequency (FB) ..........................11
      3.11. Reorder Buffer-Occupancy Density (RBD) ...................11
   4. Representation of Packet Reordering and Reorder Density ........11
   5. Selection of DT ................................................12
   6. Detection of Lost and Duplicate Packets ........................13
   7. Algorithms to Evaluate RD and RBD ..............................14
      7.1. Algorithm for RD ..........................................14
      7.2. Algorithm for RBD .........................................16
   8. Examples .......................................................17
   9. Characteristics Derivable from RD and RBD ......................21
   10. Comparison with Other Metrics .................................22
   11. Security Considerations .......................................22
   12. References ....................................................22
      12.1. Normative References .....................................22
      12.2. Informative References ...................................22
   13. Contributors ..................................................24
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction and Motivation .....................................3
   2. Attributes of Packet Reordering Metrics .........................4
   3. Reorder Density and Reorder Buffer-Occupancy Density ............7
      3.1. Receive Index (RI) .........................................8
      3.2. Out-of-Order Packet ........................................9
      3.3. Displacement (D) ...........................................9
      3.4. Displacement Threshold (DT) ................................9
      3.5. Displacement Frequency (FD) ...............................10
      3.6. Reorder Density (RD) ......................................10
      3.7. Expected Packet (E) .......................................10
      3.8. Buffer Occupancy (B) ......................................10
      3.9. Buffer-Occupancy Threshold (BT) ...........................11
      3.10. Buffer-Occupancy Frequency (FB) ..........................11
      3.11. Reorder Buffer-Occupancy Density (RBD) ...................11
   4. Representation of Packet Reordering and Reorder Density ........11
   5. Selection of DT ................................................12
   6. Detection of Lost and Duplicate Packets ........................13
   7. Algorithms to Evaluate RD and RBD ..............................14
      7.1. Algorithm for RD ..........................................14
      7.2. Algorithm for RBD .........................................16
   8. Examples .......................................................17
   9. Characteristics Derivable from RD and RBD ......................21
   10. Comparison with Other Metrics .................................22
   11. Security Considerations .......................................22
   12. References ....................................................22
      12.1. Normative References .....................................22
      12.2. Informative References ...................................22
   13. Contributors ..................................................24
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction and Motivation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍和动机
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packet reordering is a phenomenon that occurs in Internet Protocol (IP) networks. Major causes of packet reordering include, but are not limited to, packet striping at layers 2 and 3 [Ben99] [Jai03], priority scheduling (e.g., Diffserv), and route fluttering [Pax97] [Boh03]. Reordering leads to degradation of the performance of many applications [Ben99] [Bla02] [Lao02]. Increased link speeds [Bar04], increased parallelism within routers and switches, Quality-of-Service (QoS) support, and load balancing among links all point to increased packet reordering in future networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包重排序是发生在Internet协议（IP）网络中的一种现象。分组重新排序的主要原因包括但不限于第2层和第3层的分组分条[Ben99][Jai03]、优先级调度（例如，区分服务）和路由抖动[Pax97][Boh03]。重新排序会导致许多应用程序的性能下降[Ben99][Bla02][Lao02]。链路速度的提高[Bar04]，路由器和交换机内的并行性的提高，服务质量（QoS）支持，以及链路之间的负载平衡，所有这些都指向未来网络中数据包重新排序的增加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Effective metrics for reordering are required to measure and quantify reordering. A good metric or a set of metrics capturing the nature of reordering can be expected to provide insight into the reordering phenomenon in networks. It may be possible to use such metrics to predict the effects of reordering on applications that are sensitive to packet reordering, and perhaps even to compensate for reordering. A metric for reordered packets may also help evaluate network protocols and implementations with respect to their impact on packet reordering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
需要有效的重新排序指标来衡量和量化重新排序。一个好的度量或一组度量捕获了重新排序的性质，可以期望提供对网络中重新排序现象的洞察。可以使用这些度量来预测重排序对数据包重排序敏感的应用程序的影响，甚至可以补偿重排序。重新排序的数据包的度量还可以帮助评估网络协议和实现对数据包重新排序的影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The percentage of out-of-order packets is often used as a metric for characterizing reordering. However, this metric is vague and lacking in detail. Further, there is no uniform definition for the degree of reordering of an arrived packet [Ban02] [Pi05a]. For example, consider the two packet sequences (1, 3, 4, 2, 5) and (1, 4, 3, 2, 5). It is possible to interpret the reordering of packets in these sequences differently. For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无序数据包的百分比通常用作表征重新排序的指标。然而，这一指标含糊不清，缺乏细节。此外，对于到达的分组[Ban02][Pi05a]的重新排序程度没有统一的定义。例如，考虑两个分组序列（1, 3, 4，2, 5）和（1, 4, 3，2, 5）。可以以不同的方式解释这些序列中数据包的重新排序。例如
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(i) Packets 2, 3, and 4 are out of order in both cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(i) 在这两种情况下，数据包2、3和4的顺序都不正确。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(ii) Only packet 2 is out of order in the first sequence, while packets 2 and 3 are out of order in the second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（ii）只有数据包2在第一个序列中顺序错误，而数据包2和3在第二个序列中顺序错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(iii) Packets 3 and 4 are out of order in both the sequences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（iii）包3和包4在两个序列中都是无序的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(iv) Packets 2, 3, and 4 are out of order in the first sequence, while packets 4 and 2 are out of order in the second sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（iv）包2、3和4在第一个序列中无序，而包4和2在第二个序列中无序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In essence, the percentage of out-of-order packets as a metric of reordering is subject to interpretation and cannot capture the reordering unambiguously and hence, accurately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本质上，无序数据包的百分比作为重新排序的一个度量是可以解释的，并且不能明确、准确地捕获重新排序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other metrics attempt to overcome this ambiguity by defining only the late packets or only the early packets as being reordered. However, measuring reordering based only on late or only on early packets is not always effective. Consider, for example, the sequence (1, 20, 2,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其他指标试图通过仅将延迟数据包或仅将早期数据包定义为重新排序来克服这种模糊性。然而，仅基于延迟或仅基于早期数据包的重新排序度量并不总是有效的。例如，考虑序列（1, 20, 2），
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3, ..., 19, 21, 22, ...); the only anomaly is that packet 20 is delivered immediately after packet 1. A metric based only on lateness will indicate a high degree of reordering, even though in this example it is a single packet arriving ahead of others. Similarly, a metric based only on earliness does not accurately capture reordering caused by a late arriving packet. A complete reorder metric must account for both earliness and lateness, and it must be able to differentiate between the two. The inability to capture both the earliness and the lateness precludes a metric from being useful for estimating end-to-end reordering based on reordering in constituent subnets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3, ..., 19, 21, 22, ...); 唯一的异常是，数据包20在数据包1之后立即交付。仅基于延迟的度量将指示高度的重新排序，即使在本例中，它是提前到达的单个数据包。类似地，仅基于提前度的度量不能准确捕获延迟到达的数据包引起的重新排序。一个完整的再订购指标必须同时考虑提前和延迟，并且必须能够区分两者。由于无法同时捕获早到和晚到，因此无法使用度量来基于组成子网中的重新排序来估计端到端的重新排序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sensitivity to packet reordering can vary significantly from one application to the other. Consider again the packet sequence (1, 3, 4, 2, 5). If buffers are available to store packets 3 and 4 while waiting for packet 2, an application can recover from reordering. However, with certain real-time applications, the out-of-order arrival of packet 2 may render it useless. While one can argue that a good packet reordering measurement scheme should capture application-specific effects, a counter argument can also be made that packet reordering should be measured strictly with respect to the order of delivery, independent of the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不同的应用程序对数据包重新排序的敏感性可能会有很大差异。再次考虑数据包序列（1, 3, 4，2, 5）。如果在等待数据包2时缓冲区可用于存储数据包3和4，则应用程序可以从重新排序中恢复。然而，对于某些实时应用程序，数据包2的无序到达可能会使其无用。虽然有人认为一个好的数据包重新排序测量方案应该捕获特定于应用程序的效果，但也有人反驳说，数据包重新排序应该严格按照交付顺序进行测量，与应用程序无关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many different packet reordering metrics have been suggested. For example, the standards-track document RFC 4737 [RFC4737] defines 11 metrics for packet reordering, including lateness-based percentage metrics, reordering extent metrics, and N-reordering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已经提出了许多不同的分组重新排序度量。例如，标准跟踪文档RFC 4737[RFC4737]定义了11个数据包重排序度量，包括基于延迟的百分比度量、重排序范围度量和N重排序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2 of this document discusses the desirable attributes of any packet reordering metric. Section 3 introduces two additional packet reorder metrics: Reorder Density (RD) and Reorder Buffer-occupancy Density (RBD), which we claim are superior to the others [Pi07]. In particular, RD possesses all the desirable attributes, while other metrics fall significantly short in several of these attributes. RBD is unique in measuring reordering in terms of the system resources needed for recovery from packet reordering. Both RD and RBD have a computation complexity O(N), where N is the length of the packet sequence, and they can therefore be used for real-time online monitoring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档第2节讨论了任何数据包重新排序度量的期望属性。第3节介绍了两个额外的数据包重排序指标：重排序密度（RD）和重排序缓冲区占用密度（RBD），我们声称这两个指标优于其他指标[Pi07]。特别是，RD拥有所有需要的属性，而其他指标在其中几个属性上明显不足。RBD在测量从数据包重排序恢复所需的系统资源方面是独一无二的。RD和RBD都具有计算复杂度O（N），其中N是数据包序列的长度，因此它们可以用于实时在线监控。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Attributes of Packet Reordering Metrics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 包重排序度量的属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first and foremost requirement of a packet reordering metric is its ability to capture the amount and extent of reordering in a sequence of packets. The fact that a measure varies with reordering of packets in a stream does not make it a good metric. In [Ben99], the authors have identified desirable features of a reordering metric. This list encloses the foremost requirements stated above:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据包重排序度量的首要要求是能够捕获数据包序列中的重排序量和范围。度量值随流中数据包的重新排序而变化的事实并不能使其成为一个好的度量值。在[Ben99]中，作者确定了重新排序度量的理想特征。本清单包含上述最重要的要求：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
simplicity, low sensitivity to packet loss, ability to combine reorder measures from two networks, minimal value for in-order data, and independence of data size. These features are explained below in detail, along with additional desired features. Note, the ability to combine reorder measures from two networks is added to broaden applicability, and data size independence is discussed under evaluation complexity. However, data size independence could also refer to the final measure, as in percentage reordering or even a normalized representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
简单性、对数据包丢失的敏感性低、能够结合来自两个网络的重新排序措施、有序数据的最小值以及数据大小的独立性。下面将详细说明这些功能以及其他所需功能。注意，添加了将来自两个网络的重新排序度量组合起来的能力，以扩大适用性，并在评估复杂性下讨论了数据大小独立性。然而，数据大小独立性也可以指最终的度量，如百分比重新排序，甚至是规范化表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) Simplicity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) 简单
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An ideal metric is one that is simple to understand and evaluate, and yet informative, i.e., able to provide a complete picture of reordering. Percentage of packets reordered is the simplest singleton metric; but the ambiguity in its definition, as discussed earlier, and its failure to carry the extent of reordering make it less informative. On the other hand, keeping track of the displacements of each and every packet without compressing the data will contain all the information about reordering, but it is not simple to evaluate or use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
一个理想的指标是一个易于理解和评估，但信息丰富的指标，即能够提供重新排序的完整图片。重新排序的数据包百分比是最简单的单例度量；但正如前面所讨论的那样，它的定义模棱两可，而且它没有达到重新排序的程度，这使得它的信息量更少。另一方面，在不压缩数据的情况下跟踪每个数据包的位移将包含关于重新排序的所有信息，但评估或使用并不简单。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A simpler metric may be preferred in some cases even though it does not capture reordering completely, while other cases may demand a more complex, yet complete metric.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在某些情况下，更简单的度量可能是首选的，即使它不能完全捕获重新排序，而在其他情况下，可能需要更复杂但完整的度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In striving to strike a balance, the lateness-based metrics consider only the late packets as reordered, and earliness-based metrics only the early packets as reordered. However, a metric based only on earliness or only on lateness captures only a part of the information associated with reordering. In contrast, a metric capturing both early and late arrivals provides a complete picture of reordering in a sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在努力达到平衡时，基于延迟的度量只考虑作为重新排序的晚期分组，并且基于早熟的度量仅将早期分组作为重新排序。然而，仅基于提前或延迟的度量仅捕获与重新排序相关的部分信息。相反，捕获早期和晚期到达的度量提供了序列中重新排序的完整图像。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) Low Sensitivity to Packet Loss and Duplication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) 对数据包丢失和重复的敏感性低
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A reorder metric should treat only an out-of-order packet as reordered, i.e., if a packet is lost during transit, then this should not result in its following packets, which arrive in order, being classified as out of order. Consider the sequence (1, 3, 4, 5, 6). If packet 2 has been lost, the sequence should not be considered to contain any out-of-order packets. Similarly, if multiple copies of a packet (duplicates) are delivered, this must
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
重新排序度量应仅将无序数据包视为重新排序的数据包，即，如果数据包在传输过程中丢失，则这不应导致其随后按顺序到达的数据包被归类为无序数据包。考虑序列（1, 3, 4，5, 6）。如果数据包2已丢失，则该序列不应被视为包含任何无序数据包。类似地，如果一个数据包有多个副本（副本），则必须
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
not result in a packet being classified as out of order, as long as one copy arrives in the proper position. For example, sequence (1, 2, 3, 2, 4, 5) has no reordering. The lost and duplicate packet counts may be tracked using metrics specifically intended to measure those, e.g., percentage of lost packets, and percentage of duplicate packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
只要一个副本到达正确的位置，就不会导致数据包被归类为无序。例如，序列（1、2、3、2、4、5）没有重新排序。丢失和重复分组计数可以使用专门用于测量这些计数的度量来跟踪，例如，丢失分组的百分比和重复分组的百分比。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c) Low Evaluation Complexity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c) 低评估复杂度
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Memory and time complexities associated with evaluating a metric play a vital role in implementation and real-time measurements. Spatial/memory complexity corresponds to the amount of buffers required for the overall measurement process, whereas time/computation complexity refers to the number of computation steps involved in computing the amount of reordering in a sequence. On-the-fly evaluation of the metric for large streams of packets requires the computational complexity to be O(N), where N denotes the number of received packets, used for the reordering measure. This allows the metric to be updated in constant-time as each packet arrives. In the absence of a threshold defining losses or the number of sequence numbers to buffer for detection of duplicates, the worst-case complexity of loss and duplication detection will increase with N. The rate of increase will depend, among other things, on the value of N and the implementation of the duplicate detection scheme.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
与评估度量相关的内存和时间复杂性在实现和实时度量中起着至关重要的作用。空间/内存复杂度对应于整个测量过程所需的缓冲区数量，而时间/计算复杂度指的是计算序列中重新排序数量所涉及的计算步骤数量。动态评估大数据包流的度量要求计算复杂度为O（N），其中N表示用于重新排序度量的接收数据包的数量。这允许在每个数据包到达时以恒定时间更新度量。在没有定义丢失的阈值或用于检测重复的缓冲序列号数量的情况下，丢失和重复检测的最坏情况复杂性将随着N的增加而增加。除其他外，增加率将取决于N的值和重复检测方案的实施。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d) Robustness
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
d) 健壮性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Reorder measurements should be robust against different network phenomena and peculiarities in measurement or sequences such as a very late arrival of a duplicate packet, or even a rogue packet due to an error or sequence number wraparound. The impact due to an event associated with a single or a small number of packets should have a sense of proportionality on the reorder measure. Consider, for example, the arrival sequence: (1, 5430, 2, 3, 4, 5, ...) where packet 5430 appears to be very early; it may be due to either sequence rollover in test streams or some unknown reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
重排序测量应能够抵抗测量或序列中的不同网络现象和特性，例如，由于错误或序列号环绕而导致的重复数据包或甚至恶意数据包的延迟到达。与单个或少量数据包相关的事件产生的影响应与重新排序度量具有相称性。考虑，例如，到达序列：（1, 5430, 2，3, 4, 5，…），其中分组5430看起来非常早；这可能是由于测试流中的序列翻转或某些未知原因造成的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e) Broad Applicability
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
e) 广泛适用性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A framework for IP performance metrics [RFC2330] states: &#34;The metrics must aid users and providers in understanding the performance they experience or provide&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IP性能度量框架[RFC2330]指出：“这些度量必须帮助用户和提供商了解他们体验或提供的性能”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Rather than being a mere value or a set of values that changes with the reordering of packets in a stream, a reorder metric should be useful for a variety of purposes. An application or a transport protocol implementation, for example, may be able to use
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
与仅仅是一个值或一组随着流中数据包的重新排序而变化的值不同，重新排序度量对于各种目的应该是有用的。例如，应用程序或传输协议实现可以使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
the reordering information to allocate resources to recover from reordering. A metric may be useful for TCP flow control, buffer resource allocation for recovery from reordering and/or network diagnosis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
用于分配资源以从重新排序中恢复的重新排序信息。度量对于TCP流控制、从重新排序恢复的缓冲区资源分配和/或网络诊断可能有用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ability to combine the reorder metrics of constituent subnets to measure the end-to-end reordering would be an extremely useful property. In the absence of this property, no amount of individual network measurements, short of measuring the reordering for the pair of endpoints of interest, would be useful in predicting the end-to-end reordering.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
结合组成子网的重新排序度量来测量端到端重新排序的能力将是一个非常有用的特性。在没有此属性的情况下，除了测量感兴趣的端点对的重新排序之外，没有任何数量的单独网络测量将有助于预测端到端的重新排序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ability to provide different types of information based on monitoring or diagnostic needs also broadens the applicability of a metric. Examples of applicable information for reordering may include parameters such as the percentage of reordered packets that resulted in fast retransmissions in TCP, or the percentage of utilization of the reorder recovery buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
根据监测或诊断需要提供不同类型信息的能力也扩大了指标的适用范围。用于重新排序的适用信息的示例可包括参数，例如导致TCP中快速重传的重新排序的分组的百分比，或重新排序恢复缓冲区的利用率百分比。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Reorder Density and Reorder Buffer-Occupancy Density
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 重排序密度和重排序缓冲区占用密度
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this memo, we define two discrete density functions, Reorder Density (RD) and Reorder Buffer-occupancy Density (RBD), that capture the nature of reordering in a packet stream. These two metrics can be used individually or collectively to characterize the reordering in a packet stream. Also presented are algorithms for real-time evaluation of these metrics for an incoming packet stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本备忘录中，我们定义了两个离散的密度函数，重排序密度（RD）和重排序缓冲区占用密度（RBD），它们捕获了数据包流中重排序的性质。这两个度量可以单独或共同用于描述分组流中的重新排序。还提出了用于实时评估传入数据包流的这些度量的算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD is defined as the distribution of displacements of packets from their original positions, normalized with respect to the number of packets. An early packet corresponds to a negative displacement and a late packet to a positive displacement. A threshold on displacement is used to keep the computation within bounds. The choice of threshold value depends on the measurement uses and constraints, such as whether duplicate packets are accounted for when evaluating these displacements (discussed in Section 5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD定义为数据包从其原始位置的位移分布，根据数据包的数量进行归一化。早期数据包对应于负位移，晚期数据包对应于正位移。位移阈值用于将计算保持在限定范围内。阈值的选择取决于测量用途和限制，例如在评估这些位移时是否考虑重复数据包（在第5节中讨论）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ability of RD to capture the nature and properties of reordering in a comprehensive manner has been demonstrated in [Pi05a], [Pi05b], [Pi05c], and [Pi07]. The RD observed at the output port of a subnet when the input is an in-order packet stream can be viewed as a &#34;reorder response&#34; of a network, a concept somewhat similar to the &#34;system response&#34; or &#34;impulse response&#34; used in traditional system theory. For a subnet under stationary conditions, RD is the probability density of the packet displacement. RD measured on individual subnets can be combined, using the convolution operation, to predict the end-to-end reorder characteristics of the network formed by the cascade of subnets under a fairly broad set of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi05a]、[Pi05b]、[Pi05c]和[Pi07]中已经证明了研发能够以全面的方式捕获重新排序的性质和属性。当输入为有序数据包流时，在子网的输出端口观察到的RD可被视为网络的“重新排序响应”，这一概念与传统系统理论中使用的“系统响应”或“脉冲响应”有点类似。对于静态条件下的子网，RD是数据包移位的概率密度。使用卷积运算，可以组合在单个子网上测量的RD，以预测在相当广泛的数据集下由子网级联形成的网络的端到端重新排序特性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
conditions [Pi05b]. RD also shows significant promise as a tool for analytical modeling of reordering, as demonstrated with a load-balancing scenario in [Pi06]. Use of a threshold to define the condition under which a packet is considered lost makes the metric robust, efficient, and adaptable for different network and stream characteristics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
条件[Pi05b]。RD还显示出作为重新排序分析建模工具的巨大潜力，如[Pi06]中的负载平衡场景所示。使用阈值来定义数据包被认为丢失的条件，使得该度量健壮、高效，并且适用于不同的网络和流特征。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RBD is the normalized histogram of the occupancy of a hypothetical buffer that would allow the recovery from out-of-order delivery of packets. If an arriving packet is early, it is added to a hypothetical buffer until it can be released in order [Ban02]. The occupancy of this buffer, after each arrival, is used as the measure of reordering. A threshold, used to declare a packet as lost, keeps the complexity of computation within bounds. The threshold may be selected based on application requirements in situations where the late arrival of a packet makes it useless, e.g., a real-time application. In [Ban02], this metric was called RD and buffer occupancy was known as displacement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RBD是假设缓冲区占用情况的标准化柱状图，该缓冲区允许从无序的数据包交付中恢复。如果一个到达的数据包提前到达，它将被添加到一个假设的缓冲区中，直到它可以按顺序释放[Ban02]。每次到达后，此缓冲区的占用率用作重新排序的度量。用于声明数据包丢失的阈值使计算的复杂性保持在一定范围内。在分组的延迟到达使得其无用的情况下，例如，实时应用，可以基于应用需求来选择阈值。在[Ban02]中，该指标称为RD，缓冲区占用率称为位移。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD and RBD are simple, yet useful, metrics for measurement and evaluation of reordering. These metrics are robust against many peculiarities, such as those discussed previously, and have a computational complexity of O(N), where N is the received sequence size. RD is orthogonal to loss and duplication, whereas RBD is orthogonal to duplication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD和RBD是衡量和评估重新排序的简单但有用的指标。这些度量对于许多特性（如前面讨论的特性）是鲁棒的，并且具有O（N）的计算复杂性，其中N是接收序列的大小。RD与丢失和复制正交，而RBD与复制正交。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A detailed comparison of these and other proposed metrics for reordering is presented in [Pi07].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi07]中详细比较了这些指标和其他建议的重新排序指标。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following terms are used to formally define RD, RBD, and the measurement algorithms. The wraparound of sequence numbers is not addressed in this document explicitly, but with the use of modulo-N arithmetic, all claims made here remain valid in the presence of wraparound.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下术语用于正式定义RD、RBD和测量算法。本文件未明确说明序列号的环绕，但通过使用模-N算法，此处提出的所有权利要求在环绕存在的情况下仍然有效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Receive Index (RI)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 接收索引（RI）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a sequence of packets (1, 2, ..., N) transmitted over a network. A receive index RI (1, 2, ...), is a value assigned to a packet as it arrives at its destination, according to the order of arrival. A receive index is not assigned to duplicate packets, and the receive index value skips the value corresponding to a lost packet. (The detection of loss and duplication for this purpose is described in Section 6.) In the absence of reordering, the sequence number of the packet and the receive index are the same for each packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑通过网络传输的分组序列（1, 2，…，N）。接收索引RI（1，2，…）是根据到达顺序在分组到达其目的地时分配给分组的值。接收索引未分配给重复的数据包，并且接收索引值跳过与丢失的数据包对应的值。（第6节描述了为此目的的丢失和重复检测。）在没有重新排序的情况下，每个数据包的数据包序列号和接收索引相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RI is used to compute earliness and lateness of an arriving packet. Below are two examples of received sequences with receive index values for a sequence of 5 packets (1, 2, 3, 4, 5) arriving out of order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RI用于计算到达数据包的早到和晚到。下面是接收序列的两个示例，其中接收索引值用于无序到达的5个数据包（1、2、3、4、5）的序列：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example 1: Arrived sequence: 2 1 4 5 3 receive index: 1 2 3 4 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
示例1：到达序列：211453接收索引：123445
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example 2: Arrived sequence: 1 4 3 5 3 receive index: 1 3 4 5 -
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
示例2：到达序列：1 4 3 5 3接收索引：1 3 4 5-
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Example 1, there is no loss or duplication. In Example 2, the packet with sequence number 2 is lost. Thus, 2 is not assigned as an RI. Packet 3 is duplicated; thus, the second copy is not assigned an RI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在示例1中，没有丢失或重复。在示例2中，序列号为2的数据包丢失。因此，2没有被指定为RI。包3是重复的；因此，第二副本没有分配RI。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Out-of-Order Packet
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 故障包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the sequence number of a packet is not equal to the RI assigned to it, it is considered to be an out-of-order packet. Duplicates for which an RI is not defined are ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当数据包的序列号不等于分配给它的RI时，它被认为是无序数据包。未定义RI的重复项将被忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Displacement (D)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 位移（D）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Displacement (D) of a packet is defined as the difference between RI and the sequence number of the packet, i.e., the displacement of packet i is RI[i] - i. Thus, a negative displacement indicates the earliness of a packet and a positive displacement the lateness. In example 3 below, an arrived sequence with displacements of each packet is illustrated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分组的位移（D）被定义为RI和分组的序列号之间的差，即，分组i的位移是RI[i]-i。因此，负位移表示数据包的提前，正位移表示延迟。在下面的示例3中，示出了具有每个分组的位移的到达序列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Example 3:
   Arrived sequence:    1   4   3   5   3   8   7   6
   receive index:       1   3   4   5   -   6   7   8
   Displacement:        0  -1   1   0   -  -2   0   2
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Example 3:
   Arrived sequence:    1   4   3   5   3   8   7   6
   receive index:       1   3   4   5   -   6   7   8
   Displacement:        0  -1   1   0   -  -2   0   2
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Displacement Threshold (DT)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 位移阈值（DT）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The displacement threshold is a threshold on the displacement of packets that allows the metric to classify a packet as lost or duplicate. Determining when to classify a packet as lost is difficult because there is no point in time at which a packet can definitely be classified as lost; the packet may still arrive after some arbitrarily long delay. However, from a practical point of view, a packet may be classified as lost if it has not arrived within a certain administratively defined displacement threshold, DT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
位移阈值是数据包位移的阈值，允许度量将数据包分类为丢失或重复。确定何时将数据包分类为丢失是困难的，因为没有一个时间点可以肯定地将数据包分类为丢失；在经过任意长的延迟后，数据包仍可能到达。然而，从实际的角度来看，如果数据包没有到达某个管理定义的位移阈值DT内，则可以将其分类为丢失。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, to identify a duplicate packet, it is theoretically necessary to keep track of all the arrived (or missing) packets. Again, however, from a practical point of view, missing packets within a certain window of sequence numbers suffice. Thus, DT is used as a practical means for declaring a packet as lost or duplicated. DT makes the metric more robust, keeps the computational complexity for long sequences within O(N), and keeps storage requirements independent of N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类似地，为了识别重复的数据包，理论上有必要跟踪所有到达（或丢失）的数据包。然而，从实际的角度来看，在序列号的某个窗口内丢失数据包就足够了。因此，DT被用作声明数据包丢失或重复的实用方法。DT使度量更加健壮，使长序列的计算复杂度保持在O（N）以内，并使存储需求与N无关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the DT selected is too small, reordered packets might be classified as lost. A large DT will increase both the size of memory required to keep track of sequence numbers and the length of computation time required to evaluate the metric. Indeed, it is possible to use two different thresholds for the two cases. The selection of DT is further discussed in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果选择的DT太小，重新排序的数据包可能被归类为丢失。较大的DT将增加跟踪序列号所需的内存大小和评估度量所需的计算时间长度。事实上，对于这两种情况，可以使用两种不同的阈值。第5节将进一步讨论DT的选择。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Displacement Frequency (FD)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 位移频率（FD）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Displacement Frequency FD[k] is the number of arrived packets having a displacement of k, where k takes values from -DT to DT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
位移频率FD[k]是位移为k的到达数据包的数量，其中k取-DT到DT的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Reorder Density (RD)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 再订购密度（RD）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD is defined as the distribution of the Displacement Frequencies FD[k], normalized with respect to N&#39;, where N&#39; is the length of the received sequence, ignoring lost and duplicate packets. N&#39; is equal to the sum(FD[k]) for k in [-DT, DT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD被定义为位移频率FD[k]的分布，相对于N&#39;标准化，其中N&#39;是接收序列的长度，忽略丢失和重复的数据包。N&#39;等于[-DT，DT]中k的和（FD[k]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. Expected Packet (E)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. 预期数据包（E）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A packet with sequence number E is expected if E is the largest number such that all the packets with sequence numbers less than E have already arrived or have been determined to be lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果E是最大的数字，使得序列号小于E的所有数据包已经到达或已经确定丢失，则期望序列号为E的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. Buffer Occupancy (B)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8. 缓冲区占用率（B）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An arrived packet with a sequence number greater than that of an expected packet is considered to be stored in a hypothetical buffer sufficiently long to permit recovery from reordering. At any packet arrival instant, the buffer occupancy is equal to the number of out-of-order packets in the buffer, including the newly arrived packet. One buffer location is assumed for each packet, although it is possible to extend the concept to the case where the number of bytes is used for buffer occupancy. For example, consider the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
序列号大于预期数据包序列号的到达数据包被视为存储在假设缓冲区中，缓冲区足够长，以允许从重新排序中恢复。在任何数据包到达瞬间，缓冲区占用率等于缓冲区中无序数据包的数量，包括新到达的数据包。假设每个数据包有一个缓冲区位置，尽管可以将该概念扩展到字节数用于缓冲区占用的情况。例如，考虑
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence of packets (1, 2, 4, 5, 3) with expected order (1, 2, 3, 4, 5). When packet 4 arrives, the buffer occupancy is 1 because packet 4 arrived early. Similarly, the buffer occupancy becomes 2 when packet 5 arrives. When packet 3 arrives, recovery from reordering occurs and the buffer occupancy reduces to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具有预期顺序（1、2、3、4、5、5）的数据包序列（1、2、4、3）。当数据包4到达时，缓冲区占用率为1，因为数据包4提前到达。类似地，当分组5到达时，缓冲器占用变为2。当数据包3到达时，从重新排序中恢复，缓冲区占用率降至零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. Buffer-Occupancy Threshold (BT)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9. 缓冲区占用阈值（BT）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Buffer-occupancy threshold is a threshold on the maximum size of the hypothetical buffer that is used for recovery from reordering. As with the case of DT for RD, BT is used for loss and duplication classification for Reorder Buffer-occupancy Density (RBD) computation (see Section 3.11). BT provides robustness and limits the computational complexity of RBD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
缓冲区占用阈值是用于从重新排序中恢复的假设缓冲区的最大大小的阈值。与RD的DT一样，BT用于重新订购缓冲区占用密度（RBD）计算的丢失和重复分类（见第3.11节）。BT提供了健壮性并限制了RBD的计算复杂性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10. Buffer-Occupancy Frequency (FB)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10. 缓冲区占用频率（FB）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the arrival of each packet, the buffer occupancy may take any value, k, ranging from 0 to BT. The buffer occupancy frequency FB[k] is the number of arrival instances after which the occupancy takes the value of k.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在每个数据包到达时，缓冲区占用率可以取0到BT之间的任何值k。缓冲区占用频率FB[k]是到达实例的数量，在此之后，占用率取k值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.11. Reorder Buffer-Occupancy Density (RBD)
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.11. 重新排序缓冲区占用密度（RBD）
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reorder buffer-occupancy density is the buffer occupancy frequencies normalized by the total number of non-duplicate packets, i.e., RBD[k] = FB[k]/N&#39; where N&#39; is the length of the received sequence, ignoring excessively delayed (deemed lost) and duplicate packets. N&#39; is also the sum(FB[k]) for all k such that k belongs to [0, BT].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reorder buffer Occession density是由非重复数据包总数标准化的缓冲区占用频率，即RBD[k]=FB[k]/N&#39;，其中N&#39;是接收序列的长度，忽略过度延迟（视为丢失）和重复数据包。N&#39;也是所有k的和（FB[k]），使得k属于[0，BT]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Representation of Packet Reordering and Reorder Density
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 数据包重排序和重排序密度的表示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a sequence of packets (1, 2, ..., N). Let the RI assigned to packet m be &#34;the sequence number m plus an offset dm&#34;, i.e.,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑一个数据包序列（1, 2，…，n）。让分配给分组m的RI为“序列号m加上偏移量dm”，即。，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            RI = m + dm; D  = dm
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            RI = m + dm; D  = dm
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reorder event of packet m is represented by r(m, dm). When dm is not equal to zero, a reorder event is said to have occurred. A packet is late if dm &gt; 0 and early if dm &lt; 0. Thus, packet reordering of a sequence of packets is completely represented by the union of reorder events, R, referred to as the reorder set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包m的重排序事件由r（m，dm）表示。当dm不等于零时，称发生了重新排序事件。如果dm&gt;0，则数据包延迟；如果dm&lt;0，则数据包提前。因此，分组序列的分组重新排序完全由被称为重新排序集的重新排序事件R的并集表示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            R = {r(m,dm)| dm not equal to 0 for all m}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            R = {r(m,dm)| dm not equal to 0 for all m}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is no reordering in a packet sequence, then R is the null set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果数据包序列中没有重新排序，那么R是空集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Examples 4 and 5 illustrate the reorder set:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
示例4和5说明了重新排序集：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example 4. No losses or duplicates
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例4。没有损失或重复
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Arrived Sequence     1       2       3       5       4       6
   receive index (RI)   1       2       3       4       5       6
   Displacement (D)     0       0       0      -1       1       0
   R = {(4,1), (5,-1)}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Arrived Sequence     1       2       3       5       4       6
   receive index (RI)   1       2       3       4       5       6
   Displacement (D)     0       0       0      -1       1       0
   R = {(4,1), (5,-1)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example 5. Packet 4 is lost and 2 is duplicated
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例5。数据包4丢失，数据包2重复
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Arrived Sequence     1       2       5       3       6       2
   receive index (RI)   1       2       3       5       6       -
   Displacement (D)     0       0       -2      2       0       -
   R = {(3, 2), (5, -2)}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Arrived Sequence     1       2       5       3       6       2
   receive index (RI)   1       2       3       5       6       -
   Displacement (D)     0       0       -2      2       0       -
   R = {(3, 2), (5, -2)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD is defined as the discrete density of the frequency of packets with respect to their displacements, i.e., the lateness and earliness from the original position. Let S[k] denote the set of reorder events in R with displacement equal to k. That is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD定义为数据包频率相对于其位移的离散密度，即原始位置的延迟和提前。设S[k]表示R中位移等于k的重排序事件集。即:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            S[k]= {r(m, dm)| dm = k}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            S[k]= {r(m, dm)| dm = k}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let |S[k]| be the cardinality of set S[k]. Thus, RD[k] is defined as |S[k]| normalized with respect to the total number of received packets (N&#39;). Note that N&#39; does not include duplicate or lost packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
设| S[k]|为集S[k]的基数。因此，RD[k]被定义为相对于接收的分组的总数（N&#39;）归一化的| S[k]。注意，N&#39;不包括重复或丢失的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            RD[k]  = |S[k]| / N&#39; for k not equal to zero
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            RD[k]  = |S[k]| / N&#39; for k not equal to zero
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD[0] corresponds to the packets for which RI is the same as the sequence number:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD[0]对应于RI与序列号相同的数据包：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            RD[0] = 1 - sum(|S[k]| / N&#39;)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            RD[0] = 1 - sum(|S[k]| / N&#39;)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As defined previously, FD[k] is the measure that keeps track of |S[k]|.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如前所述，FD[k]是跟踪| S[k]|的度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Selection of DT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. DT的选择
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although assigning a threshold for determining lost and duplicate packets might appear to introduce error into the reorder metrics, in practice this need not be the case. Applications, protocols, and the network itself operate within finite resource constraints that introduce practical limits beyond which the choice of certain values becomes irrelevant. If the operational nature of an application is such that a DT can be defined, then using DT in the computation of reorder metrics will not invalidate nor limit the effectiveness of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管为确定丢失和重复数据包分配阈值可能会在重新排序度量中引入错误，但实际上情况并非如此。应用程序、协议和网络本身在有限的资源约束下运行，这些约束引入了实际限制，超过这些限制，某些值的选择变得无关紧要。如果应用程序的操作性质是可以定义DT，那么在计算再订购度量时使用DT不会使应用程序无效，也不会限制其有效性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the metrics, i.e., increasing DT does not provide any benefit. In the case of TCP, the maximum transmit and receive window sizes impose a natural limit on the useful value of DT. Sequence number wraparound may provide a useful upper bound for DT in some instances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些指标，即增加DT不会带来任何好处。在TCP的情况下，最大发送和接收窗口大小对DT的有用值施加了自然限制。在某些情况下，序列号环绕可以为DT提供一个有用的上界。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there are no operational constraints imposed by factors as described above, or if one is purely interested in a more complete picture of reordering, then DT can be made as large as required. If DT is equal to the length of the packet sequence (worst case scenario), a complete picture of reordering is seen. Any metric that does not rely on a threshold to declare a packet as lost implicitly makes one of two assumptions: a) A missing packet is not considered lost until the end of the sequence, or b) the packet is considered lost until it arrives. The former corresponds to the case where DT is set to the length of the sequence. The latter leads to many problems related to complexity and robustness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果没有上述因素施加的操作约束，或者如果一个人纯粹对更完整的重新排序图感兴趣，则可以根据需要使DT尽可能大。如果DT等于数据包序列的长度（最坏情况），则可以看到重新排序的完整图片。任何不依赖阈值将数据包隐式声明为丢失的度量都会做出以下两种假设之一：a）丢失的数据包在序列结束之前不会被视为丢失，或b）数据包在到达之前被视为丢失。前者对应于DT设置为序列长度的情况。后者会导致许多与复杂性和健壮性相关的问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Detection of Lost and Duplicate Packets
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 检测丢失和重复数据包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In RD, a packet is considered lost if it is late beyond DT. Non-duplicate arriving packets do not have a copy in the buffer and do not have a sequence number less (earlier) than E. In RBD, a packet is considered lost if the buffer is filled to its threshold BT. A packet is considered a duplicate when the sequence number is less than the expected packet, or if the sequence number is already in the buffer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在RD中，如果延迟超过DT，则认为数据包丢失。非重复到达的数据包在缓冲区中没有副本，序列号也不小于（早于）E。在RBD中，如果缓冲区填充到其阈值BT，则数据包被视为丢失。如果序列号小于预期数据包，或者序列号已在缓冲区中，则数据包被视为重复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since RI skips the sequence number of a lost packet, the question arises as to how to assign an RI to subsequent packets that arrive before it is known that the packet is lost. This problem arises only when reorder metrics are calculated in real-time for an incoming sequence, and not with offline computations. This concern can be handled in one of two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于RI跳过丢失数据包的序列号，因此出现了如何将RI分配给在已知数据包丢失之前到达的后续数据包的问题。此问题仅在对传入序列实时计算重新排序度量时出现，而不是在离线计算时出现。可通过以下两种方式之一处理此问题：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) Go-back Method: RD is computed as packets arrive. When a packet is deemed lost, RI values are corrected and displacements are recomputed. The Go-back Method is only invoked when a packet is lost and recomputing RD involves at most DT packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) 返回方法：在数据包到达时计算RD。当一个数据包被认为丢失时，RI值被修正，位移被重新计算。只有当数据包丢失并且重新计算RD最多涉及DT数据包时，才会调用返回方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) Stay-back Method: RD evaluation lags the arriving packets so that the correct RI and E values can be assigned to each packet as it arrives. Here, RI is assigned to a packet only once, and the value assigned is guaranteed to be correct. In the worst case, the computation lags the arriving packet by DT. The lag associated with the Stay-back Method is incurred only when a packet is missing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) 后备方法：RD评估滞后于到达的数据包，以便在每个数据包到达时为其分配正确的RI和E值。这里，RI仅被分配给一个分组一次，并且分配的值保证是正确的。在最坏的情况下，计算滞后于到达的数据包DT。只有当数据包丢失时，才会产生与back方法相关的延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another issue related to a metric and its implementation is the robustness against peculiarities that may occur in a sequence as discussed in Section 2. Consider, for example, the arrival sequence (1, 5430, 2, 3, 4, 5, ...). With RD, a sense of proportionality is easily maintained using the concept of threshold (DT), which limits the effects a rogue packet can have on the measurement results. In this example, when the displacement is greater than DT, rogue packet 5430 is discarded. In this way the impact due to the rogue packet is limited, at most, to DT packets, thus imposing a limit on the amount of error it can cause in the results. Note also that a threshold different from DT can be used for the same purpose. For example, a pre-specified threshold that limits the time a packet remains in the buffer can make RBD robust against rogue packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与度量及其实现相关的另一个问题是对第2节中讨论的序列中可能出现的特性的鲁棒性。考虑，例如，到达序列（1, 5430, 2，3, 4, 5，…）。对于RD，使用阈值（DT）的概念很容易保持比例感，这限制了恶意数据包对测量结果的影响。在该示例中，当位移大于DT时，丢弃恶意分组5430。通过这种方式，流氓数据包造成的影响最多只限于DT数据包，从而限制了它在结果中可能导致的错误量。还应注意，不同于DT的阈值可用于相同目的。例如，预先指定的限制数据包在缓冲区中的时间的阈值可以使RBD对恶意数据包具有鲁棒性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Algorithms to Evaluate RD and RBD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 评价RD和RBD的算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithms to compute RD and RBD are given below. These algorithms are applicable for online computation of an incoming packet stream and provide an up-to-date metric for the packet stream read so far. For simplicity, the sequence numbers are considered to start from 1 and continue in increments of 1. Only the Stay-back Method of loss detection is presented here; hence, the RD values lag by a maximum of DT. The algorithm for the Go-back Method is given in [Bar04]. Perl scripts for these algorithms are posted in [Per04].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面给出了计算RD和RBD的算法。这些算法适用于传入分组流的在线计算，并为迄今为止读取的分组流提供最新度量。为简单起见，序列号被视为从1开始，并以1的增量继续。这里只介绍了损耗检测的后置方法；因此，RD值滞后最大DT。回溯法的算法在[Bar04]中给出。这些算法的Perl脚本发布在[Per04]中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Algorithm for RD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. RD算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Variables used:
   -------------------------------------------------------------------
    RI: receive index.
    S: Arrival under consideration for lateness/earliness computation.
    D: Lateness or earliness of the packet being processed: dm for m.
    FD[-DT..DT]: Frequency of lateness and earliness.
    window[1..DT+1]: List of incoming sequence numbers; FIFO buffer.
    buffer[1..DT]: Array to hold sequence numbers of early arrivals.
    window[] and buffer[] are empty at the beginning.
   ===================================================================
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Variables used:
   -------------------------------------------------------------------
    RI: receive index.
    S: Arrival under consideration for lateness/earliness computation.
    D: Lateness or earliness of the packet being processed: dm for m.
    FD[-DT..DT]: Frequency of lateness and earliness.
    window[1..DT+1]: List of incoming sequence numbers; FIFO buffer.
    buffer[1..DT]: Array to hold sequence numbers of early arrivals.
    window[] and buffer[] are empty at the beginning.
   ===================================================================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 1. Initialize:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第一步。初始化：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Store first unique DT+1 sequence numbers in arriving order into
      window; RI = 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Store first unique DT+1 sequence numbers in arriving order into
      window; RI = 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 2. Repeat (until window is empty):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二步。重复（直到窗口为空）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If (window or buffer contains sequence number RI) { Move sequence number out of window to S # window is FIFO
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果（窗口或缓冲区包含序列号RI）{将序列号从窗口移到S#窗口为FIFO
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         D = RI - S; # compute displacement
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         D = RI - S; # compute displacement
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         If (absolute(D) &lt;= DT) # Apply threshold
         {
            FD[D]++; # Update frequency
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         If (absolute(D) &lt;= DT) # Apply threshold
         {
            FD[D]++; # Update frequency
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
If (buffer contains sequence number RI) Delete RI from buffer;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
如果（缓冲区包含序列号RI），则从缓冲区中删除RI；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            If (D &lt; 0) # Early Arrival
               add S to empty slot in buffer;
            RI++; # Update RI value
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            If (D &lt; 0) # Early Arrival
               add S to empty slot in buffer;
            RI++; # Update RI value
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Else # Displacement beyond threshold.
         {
            Discard S;
            # Note, an early arrival in window is moved to buffer if
            # its displacement is less or equal to DT.  Therefore, the
            # contents in buffer will have only possible RIs.  Thus,
            # clearing an RI as it is consumed prevents memory leaks
            # in buffer
         }
         # Get next incoming non-duplicate sequence number, if any.
         newS = get_next_arrival(); # subroutine called*
         if (newS != null)
         {
              add newS to window;
         }
         if (window is empty) go to step 3;
      }
      Else # RI not found.  Get next RI value.
      {
         # Next RI is the minimum among window and buffer contents.
         m = minimum (minimum (window), minimum (buffer));
         If (RI &lt; m)
            RI = m;
         Else
            RI++;
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Else # Displacement beyond threshold.
         {
            Discard S;
            # Note, an early arrival in window is moved to buffer if
            # its displacement is less or equal to DT.  Therefore, the
            # contents in buffer will have only possible RIs.  Thus,
            # clearing an RI as it is consumed prevents memory leaks
            # in buffer
         }
         # Get next incoming non-duplicate sequence number, if any.
         newS = get_next_arrival(); # subroutine called*
         if (newS != null)
         {
              add newS to window;
         }
         if (window is empty) go to step 3;
      }
      Else # RI not found.  Get next RI value.
      {
         # Next RI is the minimum among window and buffer contents.
         m = minimum (minimum (window), minimum (buffer));
         If (RI &lt; m)
            RI = m;
         Else
            RI++;
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Step 3. Normalize FD to get RD;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三步。将FD归一化得到RD；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   # Get a new sequence number from packet stream, if any
   subroutine get_next_arrival()
   {
        do   # get non-duplicate next arrival
        {
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   # Get a new sequence number from packet stream, if any
   subroutine get_next_arrival()
   {
        do   # get non-duplicate next arrival
        {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              newS = new sequence from arriving stream;
              if (newS == null) # End of packet stream
                 return null;
        } while (newS &lt; RI or newS in buffer or newS in window);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              newS = new sequence from arriving stream;
              if (newS == null) # End of packet stream
                 return null;
        } while (newS &lt; RI or newS in buffer or newS in window);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        return newS;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        return newS;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Algorithm for RBD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. RBD算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Variables used:
   ---------------------------------------------------------------------
   # E : Next expected sequence number.
   # S : Sequence number of the packet just arrived.
   # B : Current buffer occupancy.
   # BT: Buffer Occupancy threshold.
   # FB[i]: Frequency of buffer occupancy i  (0 &lt;= i &lt;= BT).
   # in_buffer(N) : True if the packet with sequence number N is
     already stored in the buffer.
   =====================================================================
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Variables used:
   ---------------------------------------------------------------------
   # E : Next expected sequence number.
   # S : Sequence number of the packet just arrived.
   # B : Current buffer occupancy.
   # BT: Buffer Occupancy threshold.
   # FB[i]: Frequency of buffer occupancy i  (0 &lt;= i &lt;= BT).
   # in_buffer(N) : True if the packet with sequence number N is
     already stored in the buffer.
   =====================================================================
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Initialize E = 1, B = 0 and FB[i] = 0 for all values of i.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 为i的所有值初始化E=1、B=0和FB[i]=0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Do the following for each arrived packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 对每个到达的数据包执行以下操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          If (in_buffer(S) || S &lt; E) /*Do nothing*/;
          /* Case a: S is a duplicate or excessively delayed packet.
          Discard the packet.*/
          Else
          {
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          If (in_buffer(S) || S &lt; E) /*Do nothing*/;
          /* Case a: S is a duplicate or excessively delayed packet.
          Discard the packet.*/
          Else
          {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             If (S == E)
             /* Case b: Expected packet has arrived.*/
             {
                E = E + 1;
                While (in_buffer(E))
                {
                   B = B - 1; /* Free buffer occupied by E.*/
                   E = E + 1; /* Expect next packet.*/
                }
                FB[B] = FB[B] + 1; /*Update frequency for buffer
                occupancy B.*/
             } /* End of If (S == E)*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             If (S == E)
             /* Case b: Expected packet has arrived.*/
             {
                E = E + 1;
                While (in_buffer(E))
                {
                   B = B - 1; /* Free buffer occupied by E.*/
                   E = E + 1; /* Expect next packet.*/
                }
                FB[B] = FB[B] + 1; /*Update frequency for buffer
                occupancy B.*/
             } /* End of If (S == E)*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             ElseIf (S &gt; E)
             /* Case c: Arrived packet has a sequence number higher
                than expected.*/
             {
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             ElseIf (S &gt; E)
             /* Case c: Arrived packet has a sequence number higher
                than expected.*/
             {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                If (B &lt; BT)
                /* Store the arrived packet in a buffer.*/
                   B = B + 1;
                Else
                /* Expected packet is delayed beyond the BT.
                Treat it as lost.*/
                {
                   Repeat
                   {
                      E = E + 1;
                   }
                   Until (in_buffer(E) || E == S);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                If (B &lt; BT)
                /* Store the arrived packet in a buffer.*/
                   B = B + 1;
                Else
                /* Expected packet is delayed beyond the BT.
                Treat it as lost.*/
                {
                   Repeat
                   {
                      E = E + 1;
                   }
                   Until (in_buffer(E) || E == S);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                   While (in_buffer(E) || E == S)
                   {
                      if (E != S) B = B - 1;
                      E = E + 1;
                   }
                 }
                 FB[B] = FB[B] + 1; /*Update frequency for buffer
                 occupancy B.*/
             } /* End of ElseIf (S &gt; E)*/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                   While (in_buffer(E) || E == S)
                   {
                      if (E != S) B = B - 1;
                      E = E + 1;
                   }
                 }
                 FB[B] = FB[B] + 1; /*Update frequency for buffer
                 occupancy B.*/
             } /* End of ElseIf (S &gt; E)*/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Normalize FB[i] to obtain RBD[i], for all values of i using
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 对FB[i]进行规范化，以获得i的所有值的RBD[i]，使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                            FB[i]
      RBD[i] = ----------------------------------
                  Sum(FB[j] for 0 &lt;= j &lt;= BT)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                            FB[i]
      RBD[i] = ----------------------------------
                  Sum(FB[j] for 0 &lt;= j &lt;= BT)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 例子
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. Scenario with no packet loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a. 无数据包丢失的场景
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the sequence of packets (1, 4, 2, 5, 3, 6, 7, 8) with DT = BT = 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑具有DT＝BT＝4的分组（1, 4, 2、5, 3, 6、7, 8）的序列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tables 1 and 2 show the computational steps when the RD algorithm is applied to the above sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表1和表2显示了将RD算法应用于上述序列时的计算步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 1: Late/Early-packet Frequency computation steps
   ------------------------------------------------------
   S         1     4     2     5     3     6   7    8
   RI        1     2     3     4     5     6   7    8
   D         0    -2     1    -1     2     0   0    0
   FD[D]     1     1     1     1     1     2   3    4
   ------------------------------------------------------
   (S, RI,D and FD[D] as described in Section 7.1)
   ------------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 1: Late/Early-packet Frequency computation steps
   ------------------------------------------------------
   S         1     4     2     5     3     6   7    8
   RI        1     2     3     4     5     6   7    8
   D         0    -2     1    -1     2     0   0    0
   FD[D]     1     1     1     1     1     2   3    4
   ------------------------------------------------------
   (S, RI,D and FD[D] as described in Section 7.1)
   ------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last row (FD[D]) represents the current frequency of occurrence of the displacement D, e.g., column 3 indicates FD[1] = 1 while column 4 indicates FD[-1] = 1. The final set of values for RD are shown in Table 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后一行（FD[D]）表示位移D的当前出现频率，例如，第3列指示FD[1]=1，而第4列指示FD[-1]=1。RD的最终值集如表2所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   -------------------------------------------------
   Table 2: Reorder Density (RD)
   -------------------------------------------------
     D       -2       -1      0     1       2
   FD[D]      1        1      4     1       1
   RD[D]     0.125   0.125   0.5   0.125   0.125
   -------------------------------------------------
   (D,FD[D] and RD[D] as described in Section 7.1)
   -------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   -------------------------------------------------
   Table 2: Reorder Density (RD)
   -------------------------------------------------
     D       -2       -1      0     1       2
   FD[D]      1        1      4     1       1
   RD[D]     0.125   0.125   0.5   0.125   0.125
   -------------------------------------------------
   (D,FD[D] and RD[D] as described in Section 7.1)
   -------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tables 3 and 4 illustrate the computational steps for RBD for the same example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表3和表4说明了同一示例中RBD的计算步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------------
   Table 3: Buffer occupancy frequencies (FB) computation steps
   ------------------------------------------------------------
   S         1     4     2     5     3     6     7     8
   E         1     2     2     3     3     6     7     8
   B         0     1     1     2     0     0     0     0
   FB[B]     1     1     2     1     2     3     4     5
   ------------------------------------------------------------
   (E,S,B and FB[B] as described in Section 7.2)
   ------------------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------------
   Table 3: Buffer occupancy frequencies (FB) computation steps
   ------------------------------------------------------------
   S         1     4     2     5     3     6     7     8
   E         1     2     2     3     3     6     7     8
   B         0     1     1     2     0     0     0     0
   FB[B]     1     1     2     1     2     3     4     5
   ------------------------------------------------------------
   (E,S,B and FB[B] as described in Section 7.2)
   ------------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------------
   Table 4: Reorder Buffer-occupancy Density
   ------------------------------------------------------------
   B           0        1     2
   FB[B]       5        2     1
   RBD[B]     0.625   0.25  0.125
   ------------------------------------------------------------
   (B,FB[B] and RBD[B] as discussed in Section 7.2)
   ------------------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------------
   Table 4: Reorder Buffer-occupancy Density
   ------------------------------------------------------------
   B           0        1     2
   FB[B]       5        2     1
   RBD[B]     0.625   0.25  0.125
   ------------------------------------------------------------
   (B,FB[B] and RBD[B] as discussed in Section 7.2)
   ------------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Graphical representations of the densities are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密度的图形表示如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                ^                            ^
                |                            |
                |                            _
    ^       0.5 _                   ^ 0.625 | |
    |          | |                  |       | |
               | |                          | |
   RD[D]       | |                RBD[B]    | | - o.25
          _  _ | | _  _ 0.125               | || | - 0.125
         | || || || || |                    | || || |
        --+--+--+--+--+--+--&gt;             ---+--+--+--
         -2 -1  0  1  2                      0  1  2
                D  --&gt;                        B --&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                ^                            ^
                |                            |
                |                            _
    ^       0.5 _                   ^ 0.625 | |
    |          | |                  |       | |
               | |                          | |
   RD[D]       | |                RBD[B]    | | - o.25
          _  _ | | _  _ 0.125               | || | - 0.125
         | || || || || |                    | || || |
        --+--+--+--+--+--+--&gt;             ---+--+--+--
         -2 -1  0  1  2                      0  1  2
                D  --&gt;                        B --&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. Scenario with packet loss
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b. 丢包场景
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a sequence of 6 packets (1, 2, 4, 5, 6, 7) with DT = BT = 3. Table 5 shows the computational steps when the RD algorithm is applied to the above sequence to obtain FD[D].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑具有DT＝BT＝3的6个分组（1, 2, 4，5, 6, 7）的序列。表5显示了将RD算法应用于上述序列以获得FD[D]时的计算步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 5: Late/Early-packet Frequency computation steps
   ------------------------------------------------------
   S         1     2     4     5     6     7
   RI        1     2     4     5     6     7
   D         0     0     0     0     0     0
   FD[D]     1     2     3     4     5     6
   ------------------------------------------------------
   (S,RI,D and FD[D] as described in Section 7.1)
   ------------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 5: Late/Early-packet Frequency computation steps
   ------------------------------------------------------
   S         1     2     4     5     6     7
   RI        1     2     4     5     6     7
   D         0     0     0     0     0     0
   FD[D]     1     2     3     4     5     6
   ------------------------------------------------------
   (S,RI,D and FD[D] as described in Section 7.1)
   ------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 6 illustrates the FB[B] for the above arrival sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表6说明了上述到达序列的FB[B]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   -------------------------------------------------
   Table 6: Buffer occupancy computation steps
   -------------------------------------------------
   S        1     2     4     5     6     7
   E        1     2     3     3     3     7
   B        0     0     1     2     3     0
   FB[B]    1     2     1     1     1     3
   -------------------------------------------------
   (E,S,B and FB[B] as described in Section 7.2)
   -------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   -------------------------------------------------
   Table 6: Buffer occupancy computation steps
   -------------------------------------------------
   S        1     2     4     5     6     7
   E        1     2     3     3     3     7
   B        0     0     1     2     3     0
   FB[B]    1     2     1     1     1     3
   -------------------------------------------------
   (E,S,B and FB[B] as described in Section 7.2)
   -------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Graphical representations of RD and RBD for the above sequence are as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述序列的RD和RBD的图形表示如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                ^                        ^
                |                        |
          1.0   _                        |
      ^        | |                ^      |
      |        | |                | 0.5  _
               | |                      | |
    RD[D]      | |               RBD[B] | | _  _  _ 0.167
               | |                      | || || || |
           --+--+--+--&gt;                --+--+--+--+--&gt;
            -1  0  1                     0  1  2  3
                D  --&gt;                      B --&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                ^                        ^
                |                        |
          1.0   _                        |
      ^        | |                ^      |
      |        | |                | 0.5  _
               | |                      | |
    RD[D]      | |               RBD[B] | | _  _  _ 0.167
               | |                      | || || || |
           --+--+--+--&gt;                --+--+--+--+--&gt;
            -1  0  1                     0  1  2  3
                D  --&gt;                      B --&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. Scenario with duplicate packets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
c. 具有重复数据包的场景
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider a sequence of 6 packets (1, 3, 2, 3, 4, 5) with DT = 2. Table 7 shows the computational steps when the RD algorithm is applied to the above sequence to obtain FD[D].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑具有DT＝2的6个分组（1, 3, 2，3, 4, 5）的序列。表7显示了将RD算法应用于上述序列以获得FD[D]时的计算步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 7: Late/Early-packet Frequency computation steps
   ------------------------------------------------------
   S         1     3     2     3     4     5
   RI        1     2     3     -     4     5
   D         0    -1     1     -     0     0
   FD[D]     1     1     1     -     2     3
   ------------------------------------------------------
   (S, RI,D and FD[D] as described in Section 7.1)
   ------------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 7: Late/Early-packet Frequency computation steps
   ------------------------------------------------------
   S         1     3     2     3     4     5
   RI        1     2     3     -     4     5
   D         0    -1     1     -     0     0
   FD[D]     1     1     1     -     2     3
   ------------------------------------------------------
   (S, RI,D and FD[D] as described in Section 7.1)
   ------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Table 8 illustrates the FB[B] for the above arrival sequence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表8说明了上述到达序列的FB[B]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 8: Buffer Occupancy Frequency computation steps
   ------------------------------------------------------
   S     1     3     2     3     4     5
   E     1     2     2     -     4     5
   B     0     1     0     -     0     0
   FB[B] 1     1     2     -     3     4
   ------------------------------------------------------
   (E,S,B and FB[B] as described in Section 7.2)
   ------------------------------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ------------------------------------------------------
   Table 8: Buffer Occupancy Frequency computation steps
   ------------------------------------------------------
   S     1     3     2     3     4     5
   E     1     2     2     -     4     5
   B     0     1     0     -     0     0
   FB[B] 1     1     2     -     3     4
   ------------------------------------------------------
   (E,S,B and FB[B] as described in Section 7.2)
   ------------------------------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Graphical representations of RD and RBD for the above sequence are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述序列的RD和RBD的图形表示如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 ^                            ^
                 |                            |
     ^           |                   ^   0.8  _
     |       0.6 _                   |       | |
                | |                          | |
    RD[D]       | |                RBD[B]    | |
          0.2 _ | | _ 0.2                    | | _ 0.2
             | || || |                       | || |
         --+--+--+--+--+--+--&gt;             ---+--+--+--
          -2 -1  0  1  2                      0  1  2
                 D  --&gt;                        B --&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 ^                            ^
                 |                            |
     ^           |                   ^   0.8  _
     |       0.6 _                   |       | |
                | |                          | |
    RD[D]       | |                RBD[B]    | |
          0.2 _ | | _ 0.2                    | | _ 0.2
             | || || |                       | || |
         --+--+--+--+--+--+--&gt;             ---+--+--+--
          -2 -1  0  1  2                      0  1  2
                 D  --&gt;                        B --&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Characteristics Derivable from RD and RBD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 可从RD和RBD导出的特性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional information may be extracted from RD and RBD depending on the specific applications. For example, in the case of resource allocation at a node to recover from reordering, the mean and variance of buffer occupancy can be derived from RBD. For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据具体应用，可从RD和RBD中提取附加信息。例如，在节点上进行资源分配以从重新排序中恢复的情况下，可以从RBD中导出缓冲区占用的平均值和方差。例如：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Mean occupancy of recovery buffer =  sum(i*RBD[i] for 0 &lt;= i &lt;= BT)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Mean occupancy of recovery buffer =  sum(i*RBD[i] for 0 &lt;= i &lt;= BT)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic definition of RBD may be modified to count the buffer occupancy in bytes as opposed to packets when the actual buffer space is more important. Another alternative is to use time to update the buffer occupancy compared to updating it at every arrival instant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当实际缓冲区空间更重要时，可以修改RBD的基本定义，以字节为单位计算缓冲区占用率，而不是数据包占用率。另一种选择是使用时间更新缓冲区占用率，而不是在每个到达瞬间更新它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameters that can be extracted from RD include the percentage of late (or early) packets, mean displacement of packets, and mean displacement of late (or early) packets [Ye06]. For example, the fraction of packets that arrive after three or more of their successors according to the order of transmission is given by Sum
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可从RD提取的参数包括延迟（或早期）数据包的百分比、数据包的平均位移和延迟（或早期）数据包的平均位移[Ye06]。例如，根据传输顺序，在三个或三个以上的后继数据包之后到达的数据包分数由总和给出
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RD[i] for 3&lt;=i&lt;=DT]. RD also allows for extraction of parameters such as entropy of the reordered sequence, a measure of disorder in the sequence [Ye06]. Due to the probability mass function nature of RD, it is also a convenient measure for theoretical modeling and analysis of reordering, e.g., see [Pi06].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RD[i]用于3&lt;=i&lt;=DT]。RD还允许提取参数，如重新排序序列的熵，这是序列无序度的度量[Ye06]。由于RD的概率质量函数性质，它也是对重新排序进行理论建模和分析的方便方法，例如，参见[Pi06]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Comparison with Other Metrics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 与其他指标的比较
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD and RBD are compared to other metrics of [RFC4737] in [Pi07].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RD和RBD与[Pi07]中[RFC4737]的其他指标进行了比较。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security considerations listed in [RFC4737], [RFC3763], and [RFC4656] are extensive and directly applicable to the usage of these metrics; thus, they should be consulted for additional details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4737]、[RFC3763]和[RFC4656]中列出的安全注意事项广泛且直接适用于这些指标的使用；因此，应向他们咨询更多细节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2330] Paxson, V., Almes, G., Mahdavi, J., and M. Mathis, &#34;Framework for IP Performance Metrics&#34;, RFC 2330, May 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2330]Paxson，V.，Almes，G.，Mahdavi，J.，和M.Mathis，“IP性能度量框架”，RFC 2330，1998年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi07] N. M. Piratla and A. P. Jayasumana, &#34;Metrics for Packet Reordering - A Comparative Analysis,&#34; International Journal of Communication Systems (IJCS), Vol. 21/1, 2008, pp: 99-113.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi07]N.M.Piratla和A.P.Jayasumana，“数据包重新排序的指标——比较分析”，《国际通信系统杂志》（IJCS），第21/12008卷，第99-113页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ben99] J. C. R. Bennett, C. Partridge and N. Shectman, &#34;Packet Reordering is Not Pathological Network Behavior,&#34; IEEE/ACM Trans. on Networking , Dec. 1999, pp.789-798.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ben99]J.C.R.Bennett，C.Partridge和N.Shectman，“数据包重新排序不是病态的网络行为”，IEEE/ACM Trans。关于网络，1999年12月，第789-798页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jai03] S. Jaiswal, G. Iannaccone, C. Diot, J. Kurose and D. Towsley, &#34;Measurement and Classification of Out-of-sequence Packets in Tier-1 IP Backbone,&#34; Proc. IEEE INFOCOM, Mar. 2003, pp. 1199-1209.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Jai03]S.Jaiswal，G.Iannacone，C.Diot，J.Kurose和D.Towsley，“第1层IP主干中无序数据包的测量和分类”，Proc。IEEE INFOCOM，2003年3月，第1199-1209页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pax97] V.Paxson, &#34;Measurements and Analysis of End-to-End Internet Dynamics,&#34; Ph.D. Dissertation, U.C. Berkeley, 1997, ftp://ftp.ee.lbl.gov/papers/vp-thesis/dis.ps.gz.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pax97]V.Paxson，“端到端互联网动态的测量和分析”，博士。博士论文，加州大学伯克利分校，1997年，ftp://ftp.ee.lbl.gov/papers/vp-thesis/dis.ps.gz.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Boh03] S. Bohacek, J. Hespanha, J. Lee, C. Lim and K.Obraczka, &#34;TCP-PR: TCP for Persistent Packet Reordering,&#34; Proc. of the IEEE 23rdICDCS, May 2003, pp.222-231.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Boh03]S.Bohacek，J.Hespanha，J.Lee，C.Lim和K.Obraczka，“TCP-PR:TCP用于持久数据包重新排序”，Proc。IEEE 23RDICDS，2003年5月，第222-231页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bla02] E. Blanton and M. Allman, &#34;On Making TCP More Robust to Packet Reordering,&#34; ACM Computer Comm. Review, 32(1), Jan. 2002, pp.20-30.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bla02]E.Blanton和M.Allman，“关于使TCP对数据包重新排序更具鲁棒性”，ACM计算机通信评论，32（1），2002年1月，第20-30页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Lao02] M. Laor and L. Gendel, &#34;The Effect of Packet Reordering in a Backbone Link on Application Throughput,&#34; IEEE Network, Sep./Oct. 2002, pp.28-36.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Lao02]M.Laor和L.Gendel，“主干链路中数据包重新排序对应用吞吐量的影响”，IEEE网络，2002年9月/10月，第28-36页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bar04] A. A. Bare, &#34;Measurement and Analysis of Packet Reordering Using Reorder Density,&#34; Masters Thesis, Department of Computer Science, Colorado State University, Fort Collins, Colorado, Fall 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Bar04]A.A.Bare，“使用重排序密度测量和分析数据包重排序”，科罗拉多州立大学计算机科学系硕士论文，科罗拉多州柯林斯堡，2004年秋季。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ban02] T. Banka, A. A. Bare, A. P. Jayasumana, &#34;Metrics for Degree of Reordering in Packet Sequences&#34;, Proc. 27th IEEE Conference on Local Computer Networks, Tampa, FL, Nov. 2002, pp. 332-342.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ban02]T.Banka，A.A.Bare，A.P.Jayasumana，“数据包序列中重新排序程度的度量”，Proc。第27届IEEE本地计算机网络会议，佛罗里达州坦帕，2002年11月，第332-342页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi05a] N. M. Piratla, &#34;A Theoretical Foundation, Metrics and Modeling of Packet Reordering and Methodology of Delay Modeling using Inter-packet Gaps,&#34; Ph.D. Dissertation, Department of Electrical and Computer Engineering, Colorado State University, Fort Collins, CO, Fall 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi05a] N. M. Piratla：“包重新排序的度量基础和建模和使用分组间间隙的延迟建模方法”，Ph.D.科罗拉多州立大学电气与计算机工程系毕业论文，科罗拉多州柯林斯堡，2005年秋季。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi05b] N. M. Piratla, A. P. Jayasumana and A. A. Bare, &#34;RD: A Formal, Comprehensive Metric for Packet Reordering,&#34; Proc. 5th International IFIP-TC6 Networking Conference (Networking 2005), Waterloo, Canada, May 2-6, 2005, LNCS 3462, pp: 78-89.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi05b]N.M.Piratla、A.P.Jayasumana和A.A.Bare，“RD：数据包重新排序的正式、全面度量”，Proc。第五届国际IFIP-TC6网络会议（2005年网络会议），加拿大滑铁卢，2005年5月2日至6日，LNCS 3462，pp:78-89。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi06] N. M. Piratla and A. P. Jayasumana, &#34;Reordering of Packets due to Multipath Forwarding - An Analysis,&#34; Proc. IEE Intl. Conf. Communications ICC 2006, Istanbul, Turkey, Jun. 2006, pp:829-834.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi06]N.M.Piratla和A.P.Jayasumana，“由于多路径转发导致的数据包重新排序-分析”，Proc。IEE国际通讯国际商会2006，土耳其伊斯坦布尔，2006年6月，第829-834页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Per04] Perl Scripts for RLED and RBD, http://www.cnrl.colostate.edu/packet_reorder.html, Last modified on Jul. 18, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Per04]用于RLED和RBD的Perl脚本，http://www.cnrl.colostate.edu/packet_reorder.html，上次修改日期为2004年7月18日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ye06] B. Ye, A. P. Jayasumana and N. Piratla, &#34;On Monitoring of End-to-End Packet Reordering over the Internet,&#34; Proc. Int. Conf. on Networking and Services (ICNS&#39;06), Santa Clara, CA, July 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Ye06]B.Ye，A.P.Jayasumana和N.Piratla，“关于监控互联网上端到端数据包的重新排序”，Proc。网络和服务国际会议（ICNS&#39;06），加利福尼亚州圣克拉拉，2006年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4737] Morton, A., Ciavattone, L., Ramachandran, G., Shalunov, S., and J. Perser, &#34;Packet Reordering Metrics&#34;, RFC 4737, November 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4737]Morton，A.，Ciavattone，L.，Ramachandran，G.，Shalunov，S.，和J.Perser，“数据包重新排序度量”，RFC 4737，2006年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3763] Shalunov, S. and B. Teitelbaum, &#34;One-way Active Measurement Protocol (OWAMP) Requirements&#34;, RFC 3763, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3763]Shalunov，S.和B.Teitelbaum，“单向主动测量协议（OWAMP）要求”，RFC 3763，2004年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4656] Shalunov, S., Teitelbaum, B., Karp, A., Boote, J., and M. Zekauskas, &#34;A One-way Active Measurement Protocol (OWAMP)&#34;, RFC 4656, September 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4656]Shalunov，S.，Teitelbaum，B.，Karp，A.，Boote，J.，和M.Zekauskas，“单向主动测量协议（OWAMP）”，RFC 46562006年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi05c] N. M. Piratla, A. P. Jayasumana and T. Banka, &#34;On Reorder Density and its Application to Characterization of Packet Reordering,&#34; Proc. 30th IEEE Local Computer Networks Conference (LCN 2005), Sydney, Australia, Nov. 2005, pp:156-165.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Pi05c]N.M.Piratla，A.P.Jayasumana和T.Banka，“关于重排序密度及其在数据包重排序表征中的应用”，Proc。第30届IEEE本地计算机网络会议（LCN 2005），澳大利亚悉尼，2005年11月，pp:156-165。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Contributors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 贡献者
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jerry McCollom Hewlett Packard, 3404 East Harmony Road Fort Collins, CO 80528, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
杰里·麦科洛姆·惠普，美国科罗拉多州柯林斯堡和谐东路3404号，邮编80528
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jerry_mccollom@hp.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jerry_mccollom@hp.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anura P. Jayasumana Computer Networking Research Laboratory Department of Electrical and Computer Engineering 1373 Colorado State University, Fort Collins, CO 80523, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anura P.Jayasumana计算机网络研究实验室美国科罗拉多州立大学电气和计算机工程系1373号，科林斯堡，邮编：80523
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: Anura.Jayasumana@colostate.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: Anura.Jayasumana@colostate.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nischal M. Piratla Deutsche Telekom Laboratories Ernst-Reuter-Platz 7 D-10587 Berlin, Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nischal M.Piratla Deutsche Telekom Laboratories Ernst Reuter Platz 7 D-10587德国柏林
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: Nischal.Piratla@telekom.de
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: Nischal.Piratla@telekom.de
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tarun Banka Computer Networking Research Laboratory Department of Electrical and Computer Engineering 1373 Colorado State University Fort Collins, CO 80523, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
塔伦·班卡计算机网络研究实验室美国科罗拉多州立大学电气和计算机工程系1373科林斯堡，邮编：80523
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: Tarun.Banka@colostate.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: Tarun.Banka@colostate.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abhijit A. Bare Agilent Technologies, Inc. 900 South Taft Ave. Loveland, CO 80537, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Abhijit A.Bare Agilent Technologies，Inc.美国科罗拉多州洛夫兰南塔夫特大道900号，邮编80537
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: abhijit_bare@agilent.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: abhijit_bare@agilent.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rick Whitner Agilent Technologies, Inc. 900 South Taft Ave. Loveland, CO 80537, USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rick Whitner安捷伦科技有限公司，美国科罗拉多州洛夫兰南塔夫特大道900号，邮编80537
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: rick_whitner@agilent.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: rick_whitner@agilent.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2008).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）IETF信托基金（2008年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78 and at http://www.rfc-editor.org/copyright.html, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和http://www.rfc-editor.org/copyright.html，除本协议另有规定外，提交人保留其所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其包含的信息以“原样”为基础提供，贡献者、他/她所代表或赞助的组织（如有）、互联网协会、IETF信托基金和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org.
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
