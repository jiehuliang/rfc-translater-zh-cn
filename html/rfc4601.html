<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 4601: Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC4601 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4601</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc4601.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">原文</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 4601: Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised) 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc4601" target="_blank">
              https://datatracker.ietf.org/doc/html/rfc4601
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 4601</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          B. Fenner
Request for Comments: 4601                          AT&amp;T Labs - Research
Obsoletes: 2362                                               M. Handley
Category: Standards Track                                            UCL
                                                             H. Holbrook
                                                                 Arastra
                                                             I. Kouvelas
                                                                   Cisco
                                                             August 2006
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          B. Fenner
Request for Comments: 4601                          AT&amp;T Labs - Research
Obsoletes: 2362                                               M. Handley
Category: Standards Track                                            UCL
                                                             H. Holbrook
                                                                 Arastra
                                                             I. Kouvelas
                                                                   Cisco
                                                             August 2006
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
协议无关多播-稀疏模式（PIM-SM）：协议规范（修订版）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2006年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies Protocol Independent Multicast - Sparse Mode (PIM-SM). PIM-SM is a multicast routing protocol that can use the underlying unicast routing information base or a separate multicast-capable routing information base. It builds unidirectional shared trees rooted at a Rendezvous Point (RP) per group, and optionally creates shortest-path trees per source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档规定了协议独立多播稀疏模式（PIM-SM）。PIM-SM是一种多播路由协议，可以使用底层单播路由信息库或单独的支持多播的路由信息库。它为每个组构建以集合点（RP）为根的单向共享树，并可选择为每个源创建最短路径树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes RFC 2362, an Experimental version of PIM-SM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件淘汰了RFC 2362，一种PIM-SM的实验版本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................5
   2. Terminology .....................................................5
      2.1. Definitions ................................................5
      2.2. Pseudocode Notation ........................................7
   3. PIM-SM Protocol Overview ........................................7
      3.1. Phase One: RP Tree .........................................8
      3.2. Phase Two: Register-Stop ...................................8
      3.3. Phase Three: Shortest-Path Tree ............................9
      3.4. Source-Specific Joins .....................................10
      3.5. Source-Specific Prunes ....................................11
      3.6. Multi-Access Transit LANs .................................11
      3.7. RP Discovery ..............................................12
   4. Protocol Specification .........................................12
      4.1. PIM Protocol State ........................................13
           4.1.1. General Purpose State ..............................14
           4.1.2. (*,*,RP) State .....................................15
           4.1.3. (*,G) State ........................................16
           4.1.4. (S,G) State ........................................17
           4.1.5. (S,G,rpt) State ....................................20
           4.1.6. State Summarization Macros .........................21
      4.2. Data Packet Forwarding Rules ..............................26
           4.2.1. Last-Hop Switchover to the SPT .....................28
           4.2.2. Setting and Clearing the (S,G) SPTbit ..............29
      4.3. Designated Routers (DR) and Hello Messages ................30
           4.3.1. Sending Hello Messages .............................30
           4.3.2. DR Election ........................................32
           4.3.3. Reducing Prune Propagation Delay on LANs ...........34
           4.3.4. Maintaining Secondary Address Lists ................37
      4.4. PIM Register Messages .....................................38
           4.4.1. Sending Register Messages from the DR ..............38
           4.4.2. Receiving Register Messages at the RP ..............43
      4.5. PIM Join/Prune Messages ...................................45
           4.5.1. Receiving (*,*,RP) Join/Prune Messages .............45
           4.5.2. Receiving (*,G) Join/Prune Messages ................49
           4.5.3. Receiving (S,G) Join/Prune Messages ................53
           4.5.4. Receiving (S,G,rpt) Join/Prune Messages ............56
           4.5.5. Sending (*,*,RP) Join/Prune Messages ...............62
           4.5.6. Sending (*,G) Join/Prune Messages ..................66
           4.5.7. Sending (S,G) Join/Prune Messages ..................71
           4.5.8. (S,G,rpt) Periodic Messages ........................76
           4.5.9. State Machine for (S,G,rpt) Triggered Messages .....77
           4.5.10. Background: (*,*,RP) and (S,G,rpt) Interaction ....82
      4.6. PIM Assert Messages .......................................83
           4.6.1. (S,G) Assert Message State Machine .................83
           4.6.2. (*,G) Assert Message State Machine .................91
           4.6.3. Assert Metrics .....................................98
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................5
   2. Terminology .....................................................5
      2.1. Definitions ................................................5
      2.2. Pseudocode Notation ........................................7
   3. PIM-SM Protocol Overview ........................................7
      3.1. Phase One: RP Tree .........................................8
      3.2. Phase Two: Register-Stop ...................................8
      3.3. Phase Three: Shortest-Path Tree ............................9
      3.4. Source-Specific Joins .....................................10
      3.5. Source-Specific Prunes ....................................11
      3.6. Multi-Access Transit LANs .................................11
      3.7. RP Discovery ..............................................12
   4. Protocol Specification .........................................12
      4.1. PIM Protocol State ........................................13
           4.1.1. General Purpose State ..............................14
           4.1.2. (*,*,RP) State .....................................15
           4.1.3. (*,G) State ........................................16
           4.1.4. (S,G) State ........................................17
           4.1.5. (S,G,rpt) State ....................................20
           4.1.6. State Summarization Macros .........................21
      4.2. Data Packet Forwarding Rules ..............................26
           4.2.1. Last-Hop Switchover to the SPT .....................28
           4.2.2. Setting and Clearing the (S,G) SPTbit ..............29
      4.3. Designated Routers (DR) and Hello Messages ................30
           4.3.1. Sending Hello Messages .............................30
           4.3.2. DR Election ........................................32
           4.3.3. Reducing Prune Propagation Delay on LANs ...........34
           4.3.4. Maintaining Secondary Address Lists ................37
      4.4. PIM Register Messages .....................................38
           4.4.1. Sending Register Messages from the DR ..............38
           4.4.2. Receiving Register Messages at the RP ..............43
      4.5. PIM Join/Prune Messages ...................................45
           4.5.1. Receiving (*,*,RP) Join/Prune Messages .............45
           4.5.2. Receiving (*,G) Join/Prune Messages ................49
           4.5.3. Receiving (S,G) Join/Prune Messages ................53
           4.5.4. Receiving (S,G,rpt) Join/Prune Messages ............56
           4.5.5. Sending (*,*,RP) Join/Prune Messages ...............62
           4.5.6. Sending (*,G) Join/Prune Messages ..................66
           4.5.7. Sending (S,G) Join/Prune Messages ..................71
           4.5.8. (S,G,rpt) Periodic Messages ........................76
           4.5.9. State Machine for (S,G,rpt) Triggered Messages .....77
           4.5.10. Background: (*,*,RP) and (S,G,rpt) Interaction ....82
      4.6. PIM Assert Messages .......................................83
           4.6.1. (S,G) Assert Message State Machine .................83
           4.6.2. (*,G) Assert Message State Machine .................91
           4.6.3. Assert Metrics .....................................98
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
           4.6.4. AssertCancel Messages ..............................99
           4.6.5. Assert State Macros ...............................100
      4.7. PIM Bootstrap and RP Discovery ...........................103
           4.7.1. Group-to-RP Mapping ...............................104
           4.7.2. Hash Function .....................................105
      4.8. Source-Specific Multicast ................................106
           4.8.1. Protocol Modifications for SSM Destination
                  Addresses .........................................106
           4.8.2. PIM-SSM-Only Routers ..............................107
      4.9. PIM Packet Formats .......................................108
           4.9.1. Encoded Source and Group Address Formats ..........110
           4.9.2. Hello Message Format ..............................113
           4.9.3. Register Message Format ...........................116
           4.9.4. Register-Stop Message Format ......................119
           4.9.5. Join/Prune Message Format .........................119
                  4.9.5.1. Group Set Source List Rules ..............122
                  4.9.5.2. Group Set Fragmentation ..................126
           4.9.6. Assert Message Format .............................126
      4.10. PIM Timers ..............................................128
      4.11. Timer Values ............................................129
   5. IANA Considerations ...........................................135
      5.1. PIM Address Family .......................................135
      5.2. PIM Hello Options ........................................136
   6. Security Considerations .......................................136
      6.1. Attacks Based on Forged Messages .........................136
           6.1.1. Forged Link-Local Messages ........................136
           6.1.2. Forged Unicast Messages ...........................137
      6.2. Non-Cryptographic Authentication Mechanisms ..............137
      6.3. Authentication Using IPsec ...............................138
           6.3.1. Protecting Link-Local Multicast Messages ..........138
           6.3.2. Protecting Unicast Messages .......................139
                  6.3.2.1. Register Messages ........................139
                  6.3.2.2. Register-Stop Messages ...................139
      6.4. Denial-of-Service Attacks ................................140
   7. Acknowledgements ..............................................140
   8. Normative References ..........................................141
   9. Informative References ........................................141
   Appendix A. PIM Multicast Border Router Behavior .................143
      A.1. Sources External to the PIM-SM Domain ....................143
      A.2.  Sources Internal to the PIM-SM Domain ...................144
   Appendix B. Index ................................................146
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
           4.6.4. AssertCancel Messages ..............................99
           4.6.5. Assert State Macros ...............................100
      4.7. PIM Bootstrap and RP Discovery ...........................103
           4.7.1. Group-to-RP Mapping ...............................104
           4.7.2. Hash Function .....................................105
      4.8. Source-Specific Multicast ................................106
           4.8.1. Protocol Modifications for SSM Destination
                  Addresses .........................................106
           4.8.2. PIM-SSM-Only Routers ..............................107
      4.9. PIM Packet Formats .......................................108
           4.9.1. Encoded Source and Group Address Formats ..........110
           4.9.2. Hello Message Format ..............................113
           4.9.3. Register Message Format ...........................116
           4.9.4. Register-Stop Message Format ......................119
           4.9.5. Join/Prune Message Format .........................119
                  4.9.5.1. Group Set Source List Rules ..............122
                  4.9.5.2. Group Set Fragmentation ..................126
           4.9.6. Assert Message Format .............................126
      4.10. PIM Timers ..............................................128
      4.11. Timer Values ............................................129
   5. IANA Considerations ...........................................135
      5.1. PIM Address Family .......................................135
      5.2. PIM Hello Options ........................................136
   6. Security Considerations .......................................136
      6.1. Attacks Based on Forged Messages .........................136
           6.1.1. Forged Link-Local Messages ........................136
           6.1.2. Forged Unicast Messages ...........................137
      6.2. Non-Cryptographic Authentication Mechanisms ..............137
      6.3. Authentication Using IPsec ...............................138
           6.3.1. Protecting Link-Local Multicast Messages ..........138
           6.3.2. Protecting Unicast Messages .......................139
                  6.3.2.1. Register Messages ........................139
                  6.3.2.2. Register-Stop Messages ...................139
      6.4. Denial-of-Service Attacks ................................140
   7. Acknowledgements ..............................................140
   8. Normative References ..........................................141
   9. Informative References ........................................141
   Appendix A. PIM Multicast Border Router Behavior .................143
      A.1. Sources External to the PIM-SM Domain ....................143
      A.2.  Sources Internal to the PIM-SM Domain ...................144
   Appendix B. Index ................................................146
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
List of Figures
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
数字一览表
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   Figure 1. Per-(S,G) register state machine at a DR ................38
   Figure 2. Downstream per-interface (*,*,RP) state machine .........46
   Figure 3. Downstream per-interface (*,G) state machine ............50
   Figure 4. Downstream per-interface (S,G) state machine ............53
   Figure 5. Downstream per-interface (S,G,rpt) state machine ........57
   Figure 6. Upstream (*,*,RP) state machine .........................62
   Figure 7. Upstream (*,G) state machine ............................67
   Figure 8. Upstream (S,G) state machine ............................71
   Figure 9. Upstream (S,G,rpt) state machine for triggered
             messages ................................................77
   Figure 10. Per-interface (S,G) Assert State machine ...............84
   Figure 11. Per-interface (*,G) Assert State machine ...............92
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   Figure 1. Per-(S,G) register state machine at a DR ................38
   Figure 2. Downstream per-interface (*,*,RP) state machine .........46
   Figure 3. Downstream per-interface (*,G) state machine ............50
   Figure 4. Downstream per-interface (S,G) state machine ............53
   Figure 5. Downstream per-interface (S,G,rpt) state machine ........57
   Figure 6. Upstream (*,*,RP) state machine .........................62
   Figure 7. Upstream (*,G) state machine ............................67
   Figure 8. Upstream (S,G) state machine ............................71
   Figure 9. Upstream (S,G,rpt) state machine for triggered
             messages ................................................77
   Figure 10. Per-interface (S,G) Assert State machine ...............84
   Figure 11. Per-interface (*,G) Assert State machine ...............92
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies a protocol for efficiently routing multicast groups that may span wide-area (and inter-domain) internets. This protocol is called Protocol Independent Multicast - Sparse Mode (PIM-SM) because, although it may use the underlying unicast routing to provide reverse-path information for multicast tree building, it is not dependent on any particular unicast routing protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档指定了一种协议，用于有效地路由可能跨越广域（和域间）互联网的多播组。该协议被称为协议独立多播稀疏模式（PIM-SM），因为尽管它可以使用底层单播路由为多播树的构建提供反向路径信息，但它不依赖于任何特定的单播路由协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM version 2 was originally specified in RFC 2117 and was revised in RFC 2362, both Experimental RFCs. This document is intended to obsolete RFC 2362, to correct a number of deficiencies that have been identified with the way PIM-SM was previously specified, and to bring PIM-SM onto the IETF Standards Track. As far as possible, this document specifies the same protocol as RFC 2362 and only diverges from the behavior intended by RFC 2362 when the previously specified behavior was clearly incorrect. Routers implemented according to the specification in this document will be able to interoperate successfully with routers implemented according to RFC 2362.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM版本2最初在RFC 2117中规定，并在RFC 2362中进行了修订，这两个RFC均为实验性RFC。本文件旨在淘汰RFC 2362，纠正先前规定的PIM-SM方法中发现的许多缺陷，并将PIM-SM纳入IETF标准轨道。本文件尽可能指定与RFC 2362相同的协议，并且仅当先前指定的行为明显不正确时，才偏离RFC 2362预期的行为。根据本文件规范实施的路由器将能够与根据RFC 2362实施的路由器成功互操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 术语
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this document, the key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; are to be interpreted as described in RFC 2119 [1] and indicate requirement levels for compliant PIM-SM implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本文件中，关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照RFC 2119[1]中所述进行解释，并表示符合PIM-SM实施的要求级别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following terms have special significance for PIM-SM:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下术语对PIM-SM具有特殊意义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rendezvous Point (RP): An RP is a router that has been configured to be used as the root of the non-source-specific distribution tree for a multicast group. Join messages from receivers for a group are sent towards the RP, and data from senders is sent to the RP so that receivers can discover who the senders are and start to receive traffic destined for the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合点（RP）：RP是一种路由器，已配置为用作多播组的非源特定分发树的根。来自组的接收者的加入消息被发送到RP，来自发送者的数据被发送到RP，以便接收者可以发现发送者是谁，并开始接收发送给组的通信量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Designated Router (DR): A shared-media LAN like Ethernet may have multiple PIM-SM routers connected to it. A single one of these routers, the DR, will act on behalf of directly connected hosts with respect to the PIM-SM protocol. A single DR is elected per interface (LAN or otherwise) using a simple election process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定路由器（DR）：像以太网这样的共享媒体LAN可能连接有多个PIM-SM路由器。就PIM-SM协议而言，这些路由器中的一个，即DR，将代表直接连接的主机。使用简单的选择过程，每个接口（LAN或其他）选择一个DR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MRIB Multicast Routing Information Base. This is the multicast topology table, which is typically derived from the unicast routing table, or routing protocols such as Multiprotocol BGP (MBGP) that carry multicast-specific topology information. In PIM-SM, the MRIB is used to decide where to send Join/Prune messages. A secondary function of the MRIB is to provide routing metrics for destination addresses; these metrics are used when sending and processing Assert messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MRIB多播路由信息库。这是多播拓扑表，通常从单播路由表或多协议BGP（MBGP）等承载多播特定拓扑信息的路由协议派生而来。在PIM-SM中，MRIB用于决定在何处发送加入/删除消息。MRIB的第二个功能是为目的地地址提供路由度量；这些指标在发送和处理断言消息时使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF Neighbor RPF stands for &#34;Reverse Path Forwarding&#34;. The RPF Neighbor of a router with respect to an address is the neighbor that the MRIB indicates should be used to forward packets to that address. In the case of a PIM-SM multicast group, the RPF neighbor is the router that a Join message for that group would be directed to, in the absence of modifying Assert state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF邻居RPF代表“反向路径转发”。路由器相对于地址的RPF邻居是MRIB指示应用于将数据包转发到该地址的邻居。在PIM-SM多播组的情况下，RPF邻居是在没有修改断言状态的情况下，该组的加入消息将定向到的路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIB Tree Information Base. This is the collection of state at a PIM router that has been created by receiving PIM Join/Prune messages, PIM Assert messages, and Internet Group Management Protocol (IGMP) or Multicast Listener Discovery (MLD) information from local hosts. It essentially stores the state of all multicast distribution trees at that router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TIB树信息库。这是通过从本地主机接收PIM加入/删减消息、PIM断言消息和Internet组管理协议（IGMP）或多播侦听器发现（MLD）信息而创建的PIM路由器上的状态集合。它本质上存储该路由器上所有多播分发树的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MFIB Multicast Forwarding Information Base. The TIB holds all the state that is necessary to forward multicast packets at a router. However, although this specification defines forwarding in terms of the TIB, to actually forward packets using the TIB is very inefficient. Instead, a real router implementation will normally build an efficient MFIB from the TIB state to perform forwarding. How this is done is implementation-specific and is not discussed in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MFIB多播转发信息库。TIB保存在路由器上转发多播数据包所需的所有状态。然而，尽管该规范根据TIB定义了转发，但使用TIB实际转发数据包是非常低效的。相反，真正的路由器实现通常会从TIB状态构建一个高效的MFIB来执行转发。如何做到这一点是具体实现的，本文档中没有讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upstream Towards the root of the tree. The root of tree may be either the source or the RP, depending on the context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向树根上游。树的根可以是源，也可以是RP，具体取决于上下文。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Downstream Away from the root of the tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
远离树根的下游。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GenID Generation Identifier, used to detect reboots.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GenID生成标识符，用于检测重新启动。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PMBR PIM Multicast Border Router, joining a PIM domain with another multicast domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PMBR PIM多播边界路由器，将一个PIM域与另一个多播域连接起来。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Pseudocode Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 伪码表示法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We use set notation in several places in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本规范中，我们在几个地方使用集合表示法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A (+) B is the union of two sets, A and B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A（+）B是两个集合A和B的并集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A (-) B is the elements of set A that are not in set B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A（-）B是集合A中不在集合B中的元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULL is the empty set or list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULL是空的集合或列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, we use C-like syntax:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，我们使用类似C的语法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
= denotes assignment of a variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
=表示变量的赋值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
== denotes a comparison for equality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
==表示相等的比较。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
!= denotes a comparison for inequality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
!= 表示不等式的比较。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Braces { and } are used for grouping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大括号{和}用于分组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. PIM-SM Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. PIM-SM协议概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an overview of PIM-SM behavior. It is intended as an introduction to how PIM-SM works, and it is NOT definitive. For the definitive specification, see Section 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节概述PIM-SM行为。本手册旨在介绍PIM-SM的工作原理，但并不确定。有关最终规范，请参见第4节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM relies on an underlying topology-gathering protocol to populate a routing table with routes. This routing table is called the Multicast Routing Information Base (MRIB). The routes in this table may be taken directly from the unicast routing table, or they may be different and provided by a separate routing protocol such as MBGP [10]. Regardless of how it is created, the primary role of the MRIB in the PIM protocol is to provide the next-hop router along a multicast-capable path to each destination subnet. The MRIB is used to determine the next-hop neighbor to which any PIM Join/Prune message is sent. Data flows along the reverse path of the Join messages. Thus, in contrast to the unicast RIB, which specifies the next hop that a data packet would take to get to some subnet, the MRIB gives reverse-path information and indicates the path that a multicast data packet would take from its origin subnet to the router that has the MRIB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM依赖于底层拓扑收集协议来用路由填充路由表。此路由表称为多播路由信息库（MRIB）。该表中的路由可以直接取自单播路由表，也可以不同，由单独的路由协议（如MBGP）[10]提供。不管它是如何创建的，在PIM协议中，MRIB的主要作用是沿着能够多播的路径向每个目标子网提供下一跳路由器。MRIB用于确定向其发送任何PIM加入/删减消息的下一跳邻居。数据沿着连接消息的反向路径流动。因此，与单播RIB不同，单播RIB指定数据包到达某个子网的下一跳，MRIB提供反向路径信息，并指示多播数据包从其原始子网到具有MRIB的路由器的路径。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like all multicast routing protocols that implement the service model from RFC 1112 [3], PIM-SM must be able to route data packets from sources to receivers without either the sources or receivers knowing a priori of the existence of the others. This is essentially done in three phases, although as senders and receivers may come and go at any time, all three phases may occur simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与实现RFC 1112[3]服务模型的所有多播路由协议一样，PIM-SM必须能够将数据包从源路由到接收器，而无需源或接收器事先知道其他源或接收器的存在。这基本上是分三个阶段完成的，尽管发送方和接收方可能随时来去，所有三个阶段可能同时发生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Phase One: RP Tree
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 第一阶段：RP树
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In phase one, a multicast receiver expresses its interest in receiving traffic destined for a multicast group. Typically, it does this using IGMP [2] or MLD [4], but other mechanisms might also serve this purpose. One of the receiver&#39;s local routers is elected as the Designated Router (DR) for that subnet. On receiving the receiver&#39;s expression of interest, the DR then sends a PIM Join message towards the RP for that multicast group. This Join message is known as a (*,G) Join because it joins group G for all sources to that group. The (*,G) Join travels hop-by-hop towards the RP for the group, and in each router it passes through, multicast tree state for group G is instantiated. Eventually, the (*,G) Join either reaches the RP or reaches a router that already has (*,G) Join state for that group. When many receivers join the group, their Join messages converge on the RP and form a distribution tree for group G that is rooted at the RP. This is known as the RP Tree (RPT), and is also known as the shared tree because it is shared by all sources sending to that group. Join messages are resent periodically so long as the receiver remains in the group. When all receivers on a leaf-network leave the group, the DR will send a PIM (*,G) Prune message towards the RP for that multicast group. However, if the Prune message is not sent for any reason, the state will eventually time out.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第一阶段，多播接收器表示其对接收目的地为多播组的流量感兴趣。通常，它使用IGMP[2]或MLD[4]来实现这一点，但其他机制也可以用于此目的。接收方的一个本地路由器被选为该子网的指定路由器（DR）。在接收到接收者的兴趣表达时，DR然后向该多播组的RP发送PIM加入消息。此联接消息称为（*，G）联接，因为它将所有源的组G联接到该组。（*，G）连接逐跳向组的RP移动，并且在它经过的每个路由器中，组G的多播树状态被实例化。最后，（，G）连接要么到达RP，要么到达已经具有该组的（*，G）连接状态的路由器。当许多接收者加入该组时，他们的加入消息会聚在RP上，并形成一个根在RP的G组分发树。这被称为RP树（RPT），也被称为共享树，因为发送到该组的所有源都共享它。只要接收方仍在组中，加入消息就会定期重新发送。当叶子网络上的所有接收器离开该组时，DR将向该多播组的RP发送一条PIM（*，G）删减消息。但是，如果出于任何原因未发送修剪消息，状态最终将超时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A multicast data sender just starts sending data destined for a multicast group. The sender&#39;s local router (DR) takes those data packets, unicast-encapsulates them, and sends them directly to the RP. The RP receives these encapsulated data packets, decapsulates them, and forwards them onto the shared tree. The packets then follow the (*,G) multicast tree state in the routers on the RP Tree, being replicated wherever the RP Tree branches, and eventually reaching all the receivers for that multicast group. The process of encapsulating data packets to the RP is called registering, and the encapsulation packets are known as PIM Register packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播数据发送方刚刚开始向多播组发送目的地数据。发送方的本地路由器（DR）接收这些数据包，单播封装它们，并将它们直接发送到RP。RP接收这些封装的数据包，对其进行去封装，然后将其转发到共享树上。然后，包在RP树上的路由器中遵循（*，G）多播树状态，在RP树分支的任何位置复制，并最终到达该多播组的所有接收器。将数据包封装到RP的过程称为注册，封装包称为PIM注册包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the end of phase one, multicast traffic is flowing encapsulated to the RP, and then natively over the RP tree to the multicast receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第一阶段结束时，多播流量被封装到RP，然后通过RP树本机流向多播接收器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Phase Two: Register-Stop
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 第二阶段：寄存器停止
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Register-encapsulation of data packets is inefficient for two reasons:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据包的寄存器封装效率低下，原因有两个：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Encapsulation and decapsulation may be relatively expensive operations for a router to perform, depending on whether or not the router has appropriate hardware for these tasks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 封装和去封装对于路由器来说可能是相对昂贵的操作，这取决于路由器是否具有用于这些任务的适当硬件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Traveling all the way to the RP, and then back down the shared tree may result in the packets traveling a relatively long distance to reach receivers that are close to the sender. For some applications, this increased latency or bandwidth consumption is undesirable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一直移动到RP，然后返回共享树可能会导致数据包移动相对较长的距离，以到达靠近发送方的接收器。对于某些应用程序，这种增加的延迟或带宽消耗是不可取的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although Register-encapsulation may continue indefinitely, for these reasons, the RP will normally choose to switch to native forwarding. To do this, when the RP receives a register-encapsulated data packet from source S on group G, it will normally initiate an (S,G) source-specific Join towards S. This Join message travels hop-by-hop towards S, instantiating (S,G) multicast tree state in the routers along the path. (S,G) multicast tree state is used only to forward packets for group G if those packets come from source S. Eventually the Join message reaches S&#39;s subnet or a router that already has (S,G) multicast tree state, and then packets from S start to flow following the (S,G) tree state towards the RP. These data packets may also reach routers with (*,G) state along the path towards the RP; if they do, they can shortcut onto the RP tree at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管寄存器封装可能会无限期地继续，但出于这些原因，RP通常会选择切换到本机转发。为此，当RP从G组上的源S接收到寄存器封装的数据包时，它通常会向S发起（S，G）源特定的连接。该连接消息逐跳向S移动，在路由器中沿路径实例化（S，G）多播树状态。（S，G）多播树状态仅用于转发来自源S的G组数据包。最终，连接消息到达S的子网或已具有（S，G）多播树状态的路由器，然后来自S的数据包开始沿着（S，G）树状态流向RP。这些数据包也可能到达带有（*，G）的路由器沿着通向RP的路径进行状态描述；如果他们这样做了，他们可以在这一点上的RP树的快捷方式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While the RP is in the process of joining the source-specific tree for S, the data packets will continue being encapsulated to the RP. When packets from S also start to arrive natively at the RP, the RP will be receiving two copies of each of these packets. At this point, the RP starts to discard the encapsulated copy of these packets, and it sends a Register-Stop message back to S&#39;s DR to prevent the DR from unnecessarily encapsulating the packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当RP正在加入S的源特定树时，数据包将继续被封装到RP。当来自S的包也开始以本机方式到达RP时，RP将接收这些包中每个包的两个副本。此时，RP开始丢弃这些数据包的封装副本，并将寄存器停止消息发送回S的DR，以防止DR不必要地封装数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the end of phase 2, traffic will be flowing natively from S along a source-specific tree to the RP, and from there along the shared tree to the receivers. Where the two trees intersect, traffic may transfer from the source-specific tree to the RP tree and thus avoid taking a long detour via the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第2阶段结束时，流量将以本机方式从S沿源特定树流向RP，然后从RP沿共享树流向接收器。在两棵树相交的地方，交通可能从源特定的树转移到RP树，从而避免通过RP走很长的弯路。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that a sender may start sending before or after a receiver joins the group, and thus phase two may happen before the shared tree to the receiver is built.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，发送方可能在接收方加入组之前或之后开始发送，因此第二阶段可能发生在构建接收方共享树之前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Phase Three: Shortest-Path Tree
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 第三阶段：最短路径树
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although having the RP join back towards the source removes the encapsulation overhead, it does not completely optimize the forwarding paths. For many receivers, the route via the RP may involve a significant detour when compared with the shortest path from the source to the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管让RP连接回到源端消除了封装开销，但它并没有完全优化转发路径。对于许多接收器而言，与从源到接收器的最短路径相比，通过RP的路径可能涉及显著的迂回。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To obtain lower latencies or more efficient bandwidth utilization, a router on the receiver&#39;s LAN, typically the DR, may optionally initiate a transfer from the shared tree to a source-specific shortest-path tree (SPT). To do this, it issues an (S,G) Join towards S. This instantiates state in the routers along the path to S. Eventually, this join either reaches S&#39;s subnet or reaches a router that already has (S,G) state. When this happens, data packets from S start to flow following the (S,G) state until they reach the receiver.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了获得更低的延迟或更有效的带宽利用率，接收器LAN上的路由器（通常是DR）可以选择性地发起从共享树到源特定最短路径树（SPT）的传输。为此，它向S发出一个（S，G）连接。该连接将沿着到S的路径实例化路由器中的状态。最终，该连接要么到达S的子网，要么到达已经具有（S，G）状态的路由器。当这种情况发生时，来自S的数据包开始按照（S，G）状态流动，直到它们到达接收器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, the receiver (or a router upstream of the receiver) will be receiving two copies of the data: one from the SPT and one from the RPT. When the first traffic starts to arrive from the SPT, the DR or upstream router starts to drop the packets for G from S that arrive via the RP tree. In addition, it sends an (S,G) Prune message towards the RP. This is known as an (S,G,rpt) Prune. The Prune message travels hop-by-hop, instantiating state along the path towards the RP indicating that traffic from S for G should NOT be forwarded in this direction. The prune is propagated until it reaches the RP or a router that still needs the traffic from S for other receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此时，接收器（或接收器上游的路由器）将接收两份数据：一份来自SPT，另一份来自RPT。当第一个流量开始从SPT到达时，DR或上游路由器开始从S丢弃通过RP树到达的G数据包。此外，它向RP发送（S，G）修剪消息。这称为（S，G，rpt）修剪。Prune消息一跳一跳地移动，沿着通向RP的路径实例化状态，指示来自S for G的流量不应沿此方向转发。修剪会一直传播，直到它到达RP或路由器，该路由器仍然需要来自其他接收器的S的流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By now, the receiver will be receiving traffic from S along the shortest-path tree between the receiver and S. In addition, the RP is receiving the traffic from S, but this traffic is no longer reaching the receiver along the RP tree. As far as the receiver is concerned, this is the final distribution tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在，接收器将沿着接收器和S之间的最短路径树接收来自S的流量。此外，RP正在接收来自S的流量，但该流量不再沿着RP树到达接收器。就接收器而言，这是最终的分发树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Source-Specific Joins
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 源特定联接
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMPv3 permits a receiver to join a group and specify that it only wants to receive traffic for a group if that traffic comes from a particular source. If a receiver does this, and no other receiver on the LAN requires all the traffic for the group, then the DR may omit performing a (*,G) join to set up the shared tree, and instead issue a source-specific (S,G) join only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMPv3允许接收方加入一个组，并指定它只希望接收来自特定源的组通信量。如果某个接收器执行此操作，并且LAN上没有其他接收器需要该组的所有通信量，则DR可能会忽略执行（*，G）连接以建立共享树，而只发出源特定（S，G）连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The range of multicast addresses from 232.0.0.0 to 232.255.255.255 is currently set aside for source-specific multicast in IPv4. For groups in this range, receivers should only issue source-specific IGMPv3 joins. If a PIM router receives a non-source-specific join for a group in this range, it should ignore it, as described in Section 4.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当前为IPv4中的源特定多播预留了232.0.0.0到232.255.255.255之间的多播地址范围。对于此范围内的组，接收器应仅发出源特定的IGMPv3联接。如第4.8节所述，如果PIM路由器接收到此范围内的组的非源特定连接，则应忽略该连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Source-Specific Prunes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 源特定剪枝
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMPv3 also permits a receiver to join a group and to specify that it only wants to receive traffic for a group if that traffic does not come from a specific source or sources. In this case, the DR will perform a (*,G) join as normal, but may combine this with an (S,G,rpt) prune for each of the sources the receiver does not wish to receive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IGMPv3还允许接收方加入一个组，并指定它只希望接收来自一个或多个特定源的组的流量。在这种情况下，DR将正常执行（*，G）连接，但可以将其与接收器不希望接收的每个源的（S，G，rpt）修剪相结合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Multi-Access Transit LANs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 多址传输局域网
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The overview so far has concerned itself with point-to-point transit links. However, using multi-access LANs such as Ethernet for transit is not uncommon. This can cause complications for three reasons:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到目前为止，概述涉及到点到点的公交线路。然而，使用多址局域网（如以太网）进行传输并不少见。这可能导致并发症，原因有三：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Two or more routers on the LAN may issue (*,G) Joins to different upstream routers on the LAN because they have inconsistent MRIB entries regarding how to reach the RP. Both paths on the RP tree will be set up, causing two copies of all the shared tree traffic to appear on the LAN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LAN上的两个或多个路由器可能会向LAN上的不同上游路由器发出（*，G）连接，因为它们在如何到达RP方面具有不一致的MRIB条目。RP树上的两条路径都将被设置，导致LAN上出现所有共享树流量的两个副本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Two or more routers on the LAN may issue (S,G) Joins to different upstream routers on the LAN because they have inconsistent MRIB entries regarding how to reach source S. Both paths on the source-specific tree will be set up, causing two copies of all the traffic from S to appear on the LAN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LAN上的两个或多个路由器可能会向LAN上的不同上游路由器发出（S，G）连接，因为它们在如何到达源S方面具有不一致的MRIB条目。将设置源特定树上的两条路径，从而导致LAN上出现来自S的所有流量的两个副本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router on the LAN may issue a (*,G) Join to one upstream router on the LAN, and another router on the LAN may issue an (S,G) Join to a different upstream router on the same LAN. Traffic from S may reach the LAN over both the RPT and the SPT. If the receiver behind the downstream (*,G) router doesn&#39;t issue an (S,G,rpt) prune, then this condition would persist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LAN上的路由器可以向LAN上的一个上游路由器发出（*，G）连接，LAN上的另一个路由器可以向同一LAN上的不同上游路由器发出（S，G）连接。来自S的流量可通过RPT和SPT到达LAN。如果下游（*，G）路由器后面的接收器没有发出（S，G，rpt）修剪，那么这种情况将持续存在。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of these problems are caused by there being more than one upstream router with join state for the group or source-group pair. PIM does not prevent such duplicate joins from occurring; instead, when duplicate data packets appear on the LAN from different routers, these routers notice this and then elect a single forwarder. This election is performed using PIM Assert messages, which resolve the problem in favor of the upstream router that has (S,G) state; or, if neither or both router has (S,G) state, then the problem is resolved in favor of the router with the best metric to the RP for RP trees, or the best metric to the source to source-specific trees.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有这些问题都是由于组或源组对存在多个具有连接状态的上游路由器造成的。PIM不会阻止此类重复连接的发生；相反，当LAN上出现来自不同路由器的重复数据包时，这些路由器会注意到这一点，然后选择单个转发器。该选择使用PIM断言消息执行，该消息有利于具有（S，G）状态的上游路由器解决问题；或者，如果两个或两个路由器都没有（S，G）状态，则问题的解决有利于路由器使用RP树的最佳度量，或源到源特定树的最佳度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These Assert messages are also received by the downstream routers on the LAN, and these cause subsequent Join messages to be sent to the upstream router that won the Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAN上的下游路由器也会接收这些断言消息，这些消息会导致后续加入消息发送到赢得断言的上游路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. RP Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7. RP发现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM routers need to know the address of the RP for each group for which they have (*,G) state. This address is obtained automatically (e.g., embedded-RP), through a bootstrap mechanism, or through static configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM路由器需要知道其具有（*，G）状态的每个组的RP地址。该地址通过引导机制或静态配置自动获得（例如嵌入式RP）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One dynamic way to do this is to use the Bootstrap Router (BSR) mechanism [11]. One router in each PIM domain is elected the Bootstrap Router through a simple election process. All the routers in the domain that are configured to be candidates to be RPs periodically unicast their candidacy to the BSR. From the candidates, the BSR picks an RP-set, and periodically announces this set in a Bootstrap message. Bootstrap messages are flooded hop-by-hop throughout the domain until all routers in the domain know the RP-Set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一种动态方法是使用引导路由器（BSR）机制[11]。每个PIM域中的一个路由器通过简单的选择过程被选为引导路由器。域中所有被配置为候选RPs的路由器定期将其候选性单播到BSR。BSR从候选者中选择一个RP集，并在引导消息中定期宣布该集。引导消息在整个域中逐跳地被淹没，直到域中的所有路由器都知道RP集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To map a group to an RP, a router hashes the group address into the RP-set using an order-preserving hash function (one that minimizes changes if the RP-Set changes). The resulting RP is the one that it uses as the RP for that group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了将一个组映射到一个RP，路由器使用一个保序散列函数（如果RP集发生变化，该函数可以最小化变化）将组地址散列到RP集中。生成的RP是它用作该组RP的RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Protocol Specification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 协议规范
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specification of PIM-SM is broken into several parts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM的规范分为几个部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4.1 details the protocol state stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.1节详细说明了存储的协议状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4.2 specifies the data packet forwarding rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.2节规定了数据包转发规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4.3 specifies Designated Router (DR) election and the rules for sending and processing Hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.3节规定了指定路由器（DR）选择以及发送和处理Hello消息的规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4.4 specifies the PIM Register generation and processing rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.4节规定了PIM寄存器的生成和处理规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4.5 specifies the PIM Join/Prune generation and processing rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.5节规定了PIM联接/修剪生成和处理规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4.6 specifies the PIM Assert generation and processing rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.6节规定了PIM断言生成和处理规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4.7 specifies the RP discovery mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.7节规定了RP发现机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The subset of PIM required to support Source-Specific Multicast, PIM-SSM, is described in Section 4.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.8节描述了支持源特定多播所需的PIM子集PIM-SSM。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM packet formats are specified in Section 4.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4.9节规定了PIM数据包格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A summary of PIM-SM timers and their default values is given in Section 4.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PIM-SM定时器及其默认值的摘要见第4.10节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Appendix A specifies the PIM Multicast Border Router behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 附录A规定了PIM多播边界路由器的行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. PIM Protocol State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. PIM协议状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section specifies all the protocol state that a PIM implementation should maintain in order to function correctly. We term this state the Tree Information Base (TIB), as it holds the state of all the multicast distribution trees at this router. In this specification, we define PIM mechanisms in terms of the TIB. However, only a very simple implementation would actually implement packet forwarding operations in terms of this state. Most implementations will use this state to build a multicast forwarding table, which would then be updated when the relevant state in the TIB changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节规定了PIM实现为正常运行应保持的所有协议状态。我们将此状态称为树信息库（TIB），因为它保存此路由器上所有多播分发树的状态。在本规范中，我们根据TIB定义PIM机制。然而，只有一个非常简单的实现才能真正实现这种状态下的包转发操作。大多数实现将使用此状态来构建多播转发表，当TIB中的相关状态发生更改时，将更新该表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although we specify precisely the state to be kept, this does not mean that an implementation of PIM-SM needs to hold the state in this form. This is actually an abstract state definition, which is needed in order to specify the router&#39;s behavior. A PIM-SM implementation is free to hold whatever internal state it requires and will still be conformant with this specification so long as it results in the same externally visible protocol behavior as an abstract router that holds the following state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管我们精确地指定了要保持的状态，但这并不意味着PIM-SM的实现需要以这种形式保持状态。这实际上是一个抽象的状态定义，需要它来指定路由器的行为。PIM-SM实现可自由保持其所需的任何内部状态，并且只要其产生与保持以下状态的抽象路由器相同的外部可见协议行为，则仍将符合本规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We divide TIB state into four sections:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们将TIB状态分为四个部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*,*,RP) state State that maintains per-RP trees, for all groups served by a given RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，*，RP）为给定RP服务的所有组维护每RP树的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*,G) state State that maintains the RP tree for G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，G）维护G的RP树的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G) state State that maintains a source-specific tree for source S and group G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）为源S和组G维护源特定树的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G,rpt) state State that maintains source-specific information about source S on the RP tree for G. For example, if a source is being received on the source-specific tree, it will normally have been pruned off the RP tree. This prune state is (S,G,rpt) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G，rpt）在RP树上为G维护有关源S的源特定信息的状态。例如，如果在源特定树上接收到源，则该源通常已从RP树上删除。此修剪状态为（S、G、rpt）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state that should be kept is described below. Of course, implementations will only maintain state when it is relevant to forwarding operations; for example, the &#34;NoInfo&#34; state might be assumed from the lack of other state information rather than being held explicitly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应保持的状态如下所述。当然，实现只会在与转发操作相关时维护状态；例如，“NoInfo”状态可能是由于缺少其他状态信息而假设的，而不是被明确持有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. General Purpose State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 通用状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A router holds the following non-group-specific state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器具有以下非组特定状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
o Effective Override Interval
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
o 有效超驰间隔
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
o Effective Propagation Delay
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
o 有效传播延迟
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
o Suppression state: One of {&#34;Enable&#34;, &#34;Disable&#34;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
o 抑制状态：{“启用”、“禁用”}之一
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Neighbor State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
邻国：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
For each neighbor:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
对于每个邻居：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
o Information from neighbor&#39;s Hello
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
o 邻居的问候
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
o Neighbor&#39;s GenID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
o 邻居的精灵。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
o Neighbor Liveness Timer (NLT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-15">
o 邻居活跃度计时器（NLT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Designated Router (DR) State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
指定路由器（DR）状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
o Designated Router&#39;s IP Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
o 指定路由器的IP地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
o DR&#39;s DR Priority
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
o 博士优先权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Effective Override Interval, the Effective Propagation Delay and the Interface suppression state are described in Section 4.3.3. Designated Router state is described in Section 4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.3.3节描述了有效覆盖间隔、有效传播延迟和接口抑制状态。第4.3节描述了指定的路由器状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. (*,*,RP) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. （*，*，RP）状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For every RP, a router keeps the following state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个RP，路由器保持以下状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*,*,RP) state: For each interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，*，RP）状态：对于每个接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM (*,*,RP) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM（*，*，RP）连接/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NoInfo&#34; (NI), &#34;Join&#34; (J), &#34;Prune-Pending&#34; (PP)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 国家：其中一个{“NoInfo”（NI），“Join”（J），“Prune Pending”（PP）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Prune-Pending Timer (PPT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 删除挂起计时器（PPT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Join/Prune Expiry Timer (ET)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 加入/删除到期计时器（ET）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Not interface specific:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
不特定于接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Upstream (*,*,RP) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
上游（*，*，RP）连接/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NotJoined(*,*,RP)&#34;, &#34;Joined(*,*,RP)&#34;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 状态：{“未加入（*，*，RP）”，“已加入（*，*，RP）”中的一个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o Upstream Join/Prune Timer (JT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o 上游连接/删除计时器（JT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o Last RPF Neighbor towards RP that was used
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o 使用的RP的最后一个RPF邻居
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM (*,*,RP) Join/Prune state is the result of receiving PIM (*,*,RP) Join/Prune messages on this interface and is specified in Section 4.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM（*，*，RP）加入/删减状态是在该接口上接收PIM（*，*，RP）加入/删减消息的结果，并在第4.5.1节中规定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (*,*,RP) Join/Prune State reflects the state of the upstream (*,*,RP) state machine described in Section 4.5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（*，*，RP）连接/修剪状态反映了第4.5.5节中描述的上游（*，*，RP）状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (*,*,RP) Join/Prune Timer is used to send out periodic Join(*,*,RP) messages, and to override Prune(*,*,RP) messages from peers on an upstream LAN interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（*，*，RP）加入/删减计时器用于发送定期加入（*，*，RP）消息，并覆盖上游LAN接口上对等方的删减（*，*，RP）消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last RPF neighbor towards the RP is stored because if the MRIB changes, then the RPF neighbor towards the RP may change. If it does so, then we need to trigger a new Join(*,*,RP) to the new upstream neighbor and a Prune(*,*,RP) to the old upstream neighbor. Similarly, if a router detects through a changed GenID in a Hello message that the upstream neighbor towards the RP has rebooted, then it should re-instantiate state by sending a Join(*,*,RP). These mechanisms are specified in Section 4.5.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储朝向RP的最后一个RPF邻居，因为如果MRIB更改，则朝向RP的RPF邻居可能会更改。如果它这样做了，那么我们需要触发一个新的连接（*，*，RP）到新的上游邻居，以及一个修剪（*，*，RP）到旧的上游邻居。类似地，如果路由器通过Hello消息中更改的GenID检测到RP的上游邻居已重新启动，那么它应该通过发送连接（*，*，RP）来重新实例化状态。第4.5.5节规定了这些机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. (*,G) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. （*，G）状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For every group G, a router keeps the following state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个G组，路由器保持以下状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*,G) state: For each interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，G）状态：对于每个接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             Local Membership:
                  State: One of {&#34;NoInfo&#34;, &#34;Include&#34;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             Local Membership:
                  State: One of {&#34;NoInfo&#34;, &#34;Include&#34;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM (*,G) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM（*，G）连接/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NoInfo&#34; (NI), &#34;Join&#34; (J), &#34;Prune-Pending&#34; (PP)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 国家：其中一个{“NoInfo”（NI），“Join”（J），“Prune Pending”（PP）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Prune-Pending Timer (PPT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 删除挂起计时器（PPT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Join/Prune Expiry Timer (ET)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 加入/删除到期计时器（ET）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
(*,G) Assert Winner State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
（*，G）断言胜利者状态
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NoInfo&#34; (NI), &#34;I lost Assert&#34; (L), &#34;I won Assert&#34; (W)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 国家：其中一个{“NoInfo”（NI），“我失去了主张”（L），“我赢得主张”（W）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Assert Timer (AT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 断言计时器（AT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Assert winner&#39;s IP Address (AssertWinner)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 断言赢家的IP地址（AssertWinner）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Assert winner&#39;s Assert Metric (AssertWinnerMetric)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 断言赢家的断言度量（AssertWinnerMetric）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Not interface specific:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
不特定于接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Upstream (*,G) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
上游（*，G）连接/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NotJoined(*,G)&#34;, &#34;Joined(*,G)&#34;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 国家：{“未加入（*，G）”，“已加入（*，G）”中的一个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o Upstream Join/Prune Timer (JT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o 上游连接/删除计时器（JT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o Last RP Used
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o 最后使用的RP
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o Last RPF Neighbor towards RP that was used
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o 使用的RP的最后一个RPF邻居
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Local membership is the result of the local membership mechanism (such as IGMP or MLD) running on that interface. It need not be kept if this router is not the DR on that interface unless this router won a (*,G) assert on this interface for this group, although implementations may optionally keep this state in case they become the DR or assert winner. We recommend storing this information if
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本地成员身份是在该接口上运行的本地成员身份机制（如IGMP或MLD）的结果。如果此路由器不是该接口上的DR，则不需要保留该状态，除非此路由器为此组在该接口上赢得了（*，G）断言，尽管实现可能会选择保留该状态，以防它们成为DR或断言的获胜者。如果需要，建议存储此信息
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
possible, as it reduces latency converging to stable operating conditions after a failure causing a change of DR. This information is used by the pim_include(*,G) macro described in Section 4.1.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能，因为它减少了导致DR变化的故障后收敛到稳定工作条件的延迟。该信息由第4.1.6节中描述的pim_include（*，G）宏使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM (*,G) Join/Prune state is the result of receiving PIM (*,G) Join/Prune messages on this interface and is specified in Section 4.5.2. The state is used by the macros that calculate the outgoing interface list in Section 4.1.6, and in the JoinDesired(*,G) macro (defined in Section 4.5.6) that is used in deciding whether a Join(*,G) should be sent upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM（*，G）连接/删除状态是在该接口上接收PIM（*，G）连接/删除消息的结果，并在第4.5.2节中规定。该状态由第4.1.6节中计算传出接口列表的宏和用于决定是否应向上游发送连接（*，G）的JoinDesired（*，G）宏（第4.5.6节中定义）使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*,G) Assert Winner state is the result of sending or receiving (*,G) Assert messages on this interface. It is specified in Section 4.6.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，G）Assert Winner state是在此接口上发送或接收（*，G）Assert消息的结果。第4.6.2节对其进行了规定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (*,G) Join/Prune State reflects the state of the upstream (*,G) state machine described in Section 4.5.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（*，G）连接/删除状态反映了第4.5.6节中描述的上游（*，G）状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (*,G) Join/Prune Timer is used to send out periodic Join(*,G) messages, and to override Prune(*,G) messages from peers on an upstream LAN interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（*，G）加入/删减计时器用于发送定期加入（*，G）消息，并覆盖上游LAN接口上对等方的删减（*，G）消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last RP used must be stored because if the RP-Set changes (Section 4.7), then state must be torn down and rebuilt for groups whose RP changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须存储最后使用的RP，因为如果RP集发生变化（第4.7节），则必须为RP发生变化的组拆除并重建状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last RPF neighbor towards the RP is stored because if the MRIB changes, then the RPF neighbor towards the RP may change. If it does so, then we need to trigger a new Join(*,G) to the new upstream neighbor and a Prune(*,G) to the old upstream neighbor. Similarly, if a router detects through a changed GenID in a Hello message that the upstream neighbor towards the RP has rebooted, then it should re-instantiate state by sending a Join(*,G). These mechanisms are specified in Section 4.5.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储朝向RP的最后一个RPF邻居，因为如果MRIB更改，则朝向RP的RPF邻居可能会更改。如果它这样做了，那么我们需要触发一个新的连接（*，G）到新的上游邻居，并触发一个修剪（*，G）到旧的上游邻居。类似地，如果路由器通过Hello消息中更改的GenID检测到RP的上游邻居已重新启动，那么它应该通过发送连接（*，G）来重新实例化状态。第4.5.6节规定了这些机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4. (S,G) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.4. （S，G）国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For every source/group pair (S,G), a router keeps the following state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个源/组对（S、G），路由器保持以下状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G) state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）说明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
For each interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
对于每个接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             Local Membership:
                  State: One of {&#34;NoInfo&#34;, &#34;Include&#34;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             Local Membership:
                  State: One of {&#34;NoInfo&#34;, &#34;Include&#34;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM (S,G) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM（S，G）连接/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NoInfo&#34; (NI), &#34;Join&#34; (J), &#34;Prune-Pending&#34; (PP)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 国家：其中一个{“NoInfo”（NI），“Join”（J），“Prune Pending”（PP）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Prune-Pending Timer (PPT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 删除挂起计时器（PPT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Join/Prune Expiry Timer (ET)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 加入/删除到期计时器（ET）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
(S,G) Assert Winner State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
（S，G）主张胜利者国家
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NoInfo&#34; (NI), &#34;I lost Assert&#34; (L), &#34;I won Assert&#34; (W)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 国家：其中一个{“NoInfo”（NI），“我失去了主张”（L），“我赢得主张”（W）}
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Assert Timer (AT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 断言计时器（AT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Assert winner&#39;s IP Address (AssertWinner)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 断言赢家的IP地址（AssertWinner）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Assert winner&#39;s Assert Metric (AssertWinnerMetric)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 断言赢家的断言度量（AssertWinnerMetric）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Not interface specific:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
不特定于接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Upstream (S,G) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
上游（S，G）连接/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NotJoined(S,G)&#34;, &#34;Joined(S,G)&#34;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 状态：{“未加入（S，G）”，“已加入（S，G）”}之一
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o Upstream (S,G) Join/Prune Timer (JT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o 上游（S，G）加入/删除计时器（JT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o Last RPF Neighbor towards S that was used
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o 使用的最后一个RPF邻居
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o SPTbit (indicates (S,G) state is active)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o SPTbit（表示（S，G）状态为活动状态）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o (S,G) Keepalive Timer (KAT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
o （S，G）保持计时器（KAT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Additional (S,G) state at the DR:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
DR的附加（S，G）状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Register state: One of {&#34;Join&#34; (J), &#34;Prune&#34; (P), &#34;Join-Pending&#34; (JP), &#34;NoInfo&#34; (NI)}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 注册状态{“Join”（J）、“Prune”（P）、“Join Pending”（JP）、“NoInfo”（NI）之一
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Register-Stop timer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 寄存器停止计时器
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Additional (S,G) state at the RP:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
RP处的附加（S，G）状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o PMBR: the first PMBR to send a Register for this source with the Border bit set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o PMBR：第一个发送此源的寄存器并设置边界位的PMBR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Local membership is the result of the local source-specific membership mechanism (such as IGMP version 3) running on that interface and specifying that this particular source should be included. As stored here, this state is the resulting state after any IGMPv3 inconsistencies have been resolved. It need not be kept if this router is not the DR on that interface unless this router won a (S,G) assert on this interface for this group. However, we recommend storing this information if possible, as it reduces latency converging to stable operating conditions after a failure causing a change of DR. This information is used by the pim_include(S,G) macro described in Section 4.1.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本地成员身份是在该接口上运行的特定于本地源的成员身份机制（如IGMP版本3）的结果，该机制指定应包括该特定源。如此处所存储的，此状态是解决任何IGMPv3不一致后的结果状态。如果此路由器不是该接口上的DR，则不需要保留该属性，除非此路由器为此组在该接口上赢得（S，G）断言。但是，我们建议尽可能存储此信息，因为它可以减少导致DR变化的故障后收敛到稳定工作条件的延迟。第4.1.6节中描述的pim_include（S，G）宏使用此信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM (S,G) Join/Prune state is the result of receiving PIM (S,G) Join/Prune messages on this interface and is specified in Section 4.5.2. The state is used by the macros that calculate the outgoing interface list in Section 4.1.6, and in the JoinDesired(S,G) macro (defined in Section 4.5.7) that is used in deciding whether a Join(S,G) should be sent upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM（S，G）加入/删减状态是在该接口上接收PIM（S，G）加入/删减消息的结果，并在第4.5.2节中规定。该状态由第4.1.6节中计算传出接口列表的宏和用于决定是否应向上游发送连接的JoinDesired（S，G）宏（第4.5.7节中定义）使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G) Assert Winner state is the result of sending or receiving (S,G) Assert messages on this interface. It is specified in Section 4.6.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）Assert Winner state是在此接口上发送或接收（S，G）Assert消息的结果。第4.6.1节对此进行了规定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (S,G) Join/Prune State reflects the state of the upstream (S,G) state machine described in Section 4.5.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（S，G）连接/修剪状态反映了第4.5.7节中描述的上游（S，G）状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (S,G) Join/Prune Timer is used to send out periodic Join(S,G) messages, and to override Prune(S,G) messages from peers on an upstream LAN interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（S，G）加入/删减计时器用于发送定期加入（S，G）消息，并覆盖来自上游LAN接口上对等方的删减（S，G）消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last RPF neighbor towards S is stored because if the MRIB changes, then the RPF neighbor towards S may change. If it does so, then we need to trigger a new Join(S,G) to the new upstream neighbor and a Prune(S,G) to the old upstream neighbor. Similarly, if the router detects through a changed GenID in a Hello message that the upstream neighbor towards S has rebooted, then it should re-instantiate state by sending a Join(S,G). These mechanisms are specified in Section 4.5.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储最后一个朝向S的RPF邻居，因为如果MRIB更改，则朝向S的RPF邻居可能会更改。如果它这样做了，那么我们需要触发一个新的连接（S，G）到新的上游邻居，以及一个修剪（S，G）到旧的上游邻居。类似地，如果路由器通过Hello消息中更改的GenID检测到向S的上游邻居已重新启动，那么它应该通过发送连接（S，G）来重新实例化状态。第4.5.7节规定了这些机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SPTbit is used to indicate whether forwarding is taking place on the (S,G) Shortest Path Tree (SPT) or on the (*,G) tree. A router can have (S,G) state and still be forwarding on (*,G) state during the interval when the source-specific tree is being constructed. When SPTbit is FALSE, only (*,G) forwarding state is used to forward packets from S to G. When SPTbit is TRUE, both (*,G) and (S,G) forwarding state are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SPTbit用于指示转发是在（S，G）最短路径树（SPT）上进行还是在（*，G）树上进行。路由器可以具有（S，G）状态，并且在构建源特定树的间隔期间仍然处于（*，G）状态。当SPTbit为FALSE时，仅使用（*，G）转发状态将数据包从S转发到G。当SPTbit为TRUE时，同时使用（*，G）和（S，G）转发状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (S,G) Keepalive Timer is updated by data being forwarded using this (S,G) forwarding state. It is used to keep (S,G) state alive in the absence of explicit (S,G) Joins. Amongst other things, this is necessary for the so-called &#34;turnaround rules&#34; -- when the RP uses (S,G) joins to stop encapsulation, and then (S,G) prunes to prevent traffic from unnecessarily reaching the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）Keepalive计时器通过使用此（S，G）转发状态转发的数据进行更新。它用于在没有显式（S，G）连接的情况下保持（S，G）状态为活动状态。除其他事项外，这对于所谓的“周转规则”是必要的——RP使用（S，G）连接停止封装，然后（S，G）修剪以防止流量不必要地到达RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a DR, the (S,G) Register State is used to keep track of whether to encapsulate data to the RP on the Register Tunnel; the (S,G) Register-Stop timer tracks how long before encapsulation begins again for a given (S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在DR上，（S，G）寄存器状态用于跟踪是否将数据封装到寄存器通道上的RP；（S，G）寄存器停止计时器跟踪给定（S，G）的封装重新开始之前的时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On an RP, the PMBR value must be cleared when the Keepalive Timer expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在RP上，当Keepalive计时器过期时，必须清除PMBR值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.5. (S,G,rpt) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.5. （S、G、rpt）状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For every source/group pair (S,G) for which a router also has (*,G) state, it also keeps the following state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于路由器也具有（*，G）状态的每个源/组对（S，G），它还保持以下状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G,rpt) state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S、G、rpt）声明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
For each interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
对于每个接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             Local Membership:
                  State: One of {&#34;NoInfo&#34;, &#34;Exclude&#34;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             Local Membership:
                  State: One of {&#34;NoInfo&#34;, &#34;Exclude&#34;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM (S,G,rpt) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
PIM（S、G、rpt）加入/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;NoInfo&#34;, &#34;Pruned&#34;, &#34;Prune-Pending&#34;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 状态{“NoInfo”、“Pruned”、“Prune Pending”中的一个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Prune-Pending Timer (PPT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 删除挂起计时器（PPT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Join/Prune Expiry Timer (ET)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 加入/删除到期计时器（ET）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Not interface specific:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
不特定于接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Upstream (S,G,rpt) Join/Prune State:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
上游（S、G、rpt）加入/删除状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o State: One of {&#34;RPTNotJoined(G)&#34;, &#34;NotPruned(S,G,rpt)&#34;, &#34;Pruned(S,G,rpt)&#34;}
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 状态：{“RPTNotJoined（G）”，“NotPruned（S，G，rpt）”，“Pruned（S，G，rpt）”中的一个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o Override Timer (OT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
o 超控定时器（OT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Local membership is the result of the local source-specific membership mechanism (such as IGMPv3) running on that interface and specifying that although there is (*,G) Include state, this
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本地成员身份是在该接口上运行的本地源特定成员身份机制（如IGMPv3）的结果，该机制指定尽管存在（*，G）Include state，但
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
particular source should be excluded. As stored here, this state is the resulting state after any IGMPv3 inconsistencies between LAN members have been resolved. It need not be kept if this router is not the DR on that interface unless this router won a (*,G) assert on this interface for this group. However, we recommend storing this information if possible, as it reduces latency converging to stable operating conditions after a failure causing a change of DR. This information is used by the pim_exclude(S,G) macro described in Section 4.1.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应排除特定来源。如此处所存储的，此状态是解决LAN成员之间任何IGMPv3不一致后的结果状态。如果此路由器不是该接口上的DR，则不需要保留该属性，除非此路由器为此组在该接口上赢得（*，G）断言。但是，我们建议尽可能存储此信息，因为它可以减少导致DR变化的故障后收敛到稳定工作条件的延迟。第4.1.6节中描述的pim_exclude（S，G）宏使用此信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM (S,G,rpt) Join/Prune state is the result of receiving PIM (S,G,rpt) Join/Prune messages on this interface and is specified in Section 4.5.4. The state is used by the macros that calculate the outgoing interface list in Section 4.1.6, and in the rules for adding Prune(S,G,rpt) messages to Join(*,G) messages specified in Section 4.5.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM（S，G，rpt）加入/删减状态是在该接口上接收PIM（S，G，rpt）加入/删减消息的结果，并在第4.5.4节中规定。该状态由宏使用，宏计算第4.1.6节中的传出接口列表，并在第4.5.8节中指定的添加Prune（S，G，rpt）消息以加入（*，G）消息的规则中使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (S,G,rpt) Join/Prune state is used along with the Override Timer to send the correct override messages in response to Join/Prune messages sent by upstream peers on a LAN. This state and behavior are specified in Section 4.5.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（S、G、rpt）加入/删减状态与覆盖计时器一起使用，以发送正确的覆盖消息，以响应LAN上上游对等方发送的加入/删减消息。第4.5.9节规定了该状态和行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.6. State Summarization Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.6. 状态摘要宏
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using this state, we define the following &#34;macro&#34; definitions, which we will use in the descriptions of the state machines and pseudocode in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用此状态，我们定义以下“宏”定义，我们将在以下部分的状态机和伪代码描述中使用这些定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most important macros are those that define the outgoing interface list (or &#34;olist&#34;) for the relevant state. An olist can be &#34;immediate&#34; if it is built directly from the state of the relevant type. For example, the immediate_olist(S,G) is the olist that would be built if the router only had (S,G) state and no (*,G) or (S,G,rpt) state. In contrast, the &#34;inherited&#34; olist inherits state from other types. For example, the inherited_olist(S,G) is the olist that is relevant for forwarding a packet from S to G using both source-specific and group-specific state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最重要的宏是那些为相关状态定义传出接口列表（或“olist”）的宏。如果直接从相关类型的状态构建，则olist可以是“即时”的。例如，即时列表（S，G）是在路由器只有（S，G）状态而没有（*，G）或（S，G，rpt）状态时将构建的列表。相反，“继承的”寡头从其他类型继承状态。例如，继承的olist（S，G）是与使用源特定和组特定状态将数据包从S转发到G相关的olist。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no immediate_olist(S,G,rpt) as (S,G,rpt) state is negative state; it removes interfaces in the (*,G) olist from the olist that is actually used to forward traffic. The inherited_olist(S,G,rpt) is therefore the olist that would be used for a packet from S to G forwarding on the RP tree. It is a strict subset of (immediate_olist(*,*,RP) (+) immediate_olist(*,G)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于（S，G，rpt）状态为负状态，因此不存在直接形式（S，G，rpt）；它从实际用于转发流量的olist中删除（*，G）olist中的接口。因此，继承的olist（S、G、rpt）是RP树上用于从S到G转发数据包的olist。它是（immediate_olist（*，*，RP）（+）immediate_olist（*，G））的严格子集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generally speaking, the inherited olists are used for forwarding, and the immediate_olists are used to make decisions about state maintenance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般来说，继承的olist用于转发，直接的olist用于做出有关状态维护的决策。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(*,*,RP) =
       joins(*,*,RP)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(*,*,RP) =
       joins(*,*,RP)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(*,G) =
       joins(*,G) (+) pim_include(*,G) (-) lost_assert(*,G)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(*,G) =
       joins(*,G) (+) pim_include(*,G) (-) lost_assert(*,G)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(S,G) =
       joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(S,G) =
       joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   inherited_olist(S,G,rpt) =
           ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )
       (+) ( pim_include(*,G) (-) pim_exclude(S,G))
       (-) ( lost_assert(*,G) (+) lost_assert(S,G,rpt) )
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   inherited_olist(S,G,rpt) =
           ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )
       (+) ( pim_include(*,G) (-) pim_exclude(S,G))
       (-) ( lost_assert(*,G) (+) lost_assert(S,G,rpt) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   inherited_olist(S,G) =
       inherited_olist(S,G,rpt) (+)
       joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   inherited_olist(S,G) =
       inherited_olist(S,G,rpt) (+)
       joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macros pim_include(*,G) and pim_include(S,G) indicate the interfaces to which traffic might be forwarded because of hosts that are local members on that interface. Note that normally only the DR cares about local membership, but when an assert happens, the assert winner takes over responsibility for forwarding traffic to local members that have requested traffic on a group or source/group pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏pim_include（*，G）和pim_include（S，G）指示由于主机是该接口上的本地成员而可能将流量转发到的接口。请注意，通常只有DR关心本地成员资格，但当发生断言时，断言获胜者将负责将流量转发给已请求组或源/组对流量的本地成员。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_include(*,G) =
      { all interfaces I such that:
        ( ( I_am_DR( I ) AND lost_assert(*,G,I) == FALSE )
          OR AssertWinner(*,G,I) == me )
        AND  local_receiver_include(*,G,I) }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_include(*,G) =
      { all interfaces I such that:
        ( ( I_am_DR( I ) AND lost_assert(*,G,I) == FALSE )
          OR AssertWinner(*,G,I) == me )
        AND  local_receiver_include(*,G,I) }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_include(S,G) =
       { all interfaces I such that:
         ( (I_am_DR( I ) AND lost_assert(S,G,I) == FALSE )
           OR AssertWinner(S,G,I) == me )
          AND  local_receiver_include(S,G,I) }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_include(S,G) =
       { all interfaces I such that:
         ( (I_am_DR( I ) AND lost_assert(S,G,I) == FALSE )
           OR AssertWinner(S,G,I) == me )
          AND  local_receiver_include(S,G,I) }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_exclude(S,G) =
       { all interfaces I such that:
         ( (I_am_DR( I ) AND lost_assert(*,G,I) == FALSE )
           OR AssertWinner(*,G,I) == me )
          AND  local_receiver_exclude(S,G,I) }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_exclude(S,G) =
       { all interfaces I such that:
         ( (I_am_DR( I ) AND lost_assert(*,G,I) == FALSE )
           OR AssertWinner(*,G,I) == me )
          AND  local_receiver_exclude(S,G,I) }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The clause &#34;local_receiver_include(S,G,I)&#34; is true if the IGMP/MLD module or other local membership mechanism has determined that local members on interface I desire to receive traffic sent specifically by S to G. &#34;local_receiver_include(*,G,I)&#34; is true if the IGMP/MLD module or other local membership mechanism has determined that local
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果IGMP/MLD模块或其他本地成员机制已确定接口I上的本地成员希望接收S向G专门发送的通信量，则“本地接收器包括（S，G，I）”条款为真。如果IGMP/MLD模块或其他本地成员机制已确定本地
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
members on interface I desire to receive all traffic sent to G (possibly excluding traffic from a specific set of sources). &#34;local_receiver_exclude(S,G,I) is true if &#34;local_receiver_include(*,G,I)&#34; is true but none of the local members desire to receive traffic from S.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接口I上的成员希望接收发送到G的所有流量（可能不包括来自特定源集的流量）。如果“local_receiver_include（*，G，I）”为真，则“local_receiver_exclude（S，G，I）”为真，但没有任何本地成员希望接收来自S的流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set &#34;joins(*,*,RP)&#34; is the set of all interfaces on which the router has received (*,*,RP) Joins:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合“joins（*，*，RP）”是路由器接收（*，*，RP）联接的所有接口的集合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   joins(*,*,RP) =
       { all interfaces I such that
         DownstreamJPState(*,*,RP,I) is either Join or
             Prune-Pending }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   joins(*,*,RP) =
       { all interfaces I such that
         DownstreamJPState(*,*,RP,I) is either Join or
             Prune-Pending }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DownstreamJPState(*,*,RP,I) is the state of the finite state machine in Section 4.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下游状态（*，*，RP，I）是第4.5.1节中有限状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set &#34;joins(*,G)&#34; is the set of all interfaces on which the router has received (*,G) Joins:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合“连接（*，G）”是路由器接收（*，G）连接的所有接口的集合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   joins(*,G) =
       { all interfaces I such that
         DownstreamJPState(*,G,I) is either Join or Prune-Pending }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   joins(*,G) =
       { all interfaces I such that
         DownstreamJPState(*,G,I) is either Join or Prune-Pending }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DownstreamJPState(*,G,I) is the state of the finite state machine in Section 4.5.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下游状态（*，G，I）是第4.5.2节中有限状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set &#34;joins(S,G)&#34; is the set of all interfaces on which the router has received (S,G) Joins:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合“连接（S，G）”是路由器接收（S，G）连接的所有接口的集合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   joins(S,G) =
       { all interfaces I such that
         DownstreamJPState(S,G,I) is either Join or Prune-Pending }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   joins(S,G) =
       { all interfaces I such that
         DownstreamJPState(S,G,I) is either Join or Prune-Pending }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DownstreamJPState(S,G,I) is the state of the finite state machine in Section 4.5.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下游状态（S，G，I）是第4.5.3节中有限状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set &#34;prunes(S,G,rpt)&#34; is the set of all interfaces on which the router has received (*,G) joins and (S,G,rpt) prunes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合“prune（S，G，rpt）”是路由器接收（*，G）连接和（S，G，rpt）修剪的所有接口的集合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   prunes(S,G,rpt) =
       { all interfaces I such that
         DownstreamJPState(S,G,rpt,I) is Prune or PruneTmp }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   prunes(S,G,rpt) =
       { all interfaces I such that
         DownstreamJPState(S,G,rpt,I) is Prune or PruneTmp }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DownstreamJPState(S,G,rpt,I) is the state of the finite state machine in Section 4.5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下游状态（S、G、rpt、I）是第4.5.4节中有限状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set &#34;lost_assert(*,G)&#34; is the set of all interfaces on which the router has received (*,G) joins but has lost a (*,G) assert. The macro lost_assert(*,G,I) is defined in Section 4.6.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合“lost_assert（*，G）”是路由器已接收（*，G）连接但已丢失（*，G）assert的所有接口的集合。第4.6.5节定义了宏lost_assert（*，G，I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(*,G) =
       { all interfaces I such that
         lost_assert(*,G,I) == TRUE }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(*,G) =
       { all interfaces I such that
         lost_assert(*,G,I) == TRUE }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set &#34;lost_assert(S,G,rpt)&#34; is the set of all interfaces on which the router has received (*,G) joins but has lost an (S,G) assert. The macro lost_assert(S,G,rpt,I) is defined in Section 4.6.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合“lost_assert（S，G，rpt）”是路由器已接收（*，G）连接但已丢失（S，G）assert的所有接口的集合。第4.6.5节定义了宏lost_断言（S、G、rpt、I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(S,G,rpt) =
       { all interfaces I such that
         lost_assert(S,G,rpt,I) == TRUE }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(S,G,rpt) =
       { all interfaces I such that
         lost_assert(S,G,rpt,I) == TRUE }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set &#34;lost_assert(S,G)&#34; is the set of all interfaces on which the router has received (S,G) joins but has lost an (S,G) assert. The macro lost_assert(S,G,I) is defined in Section 4.6.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
集合“lost_assert（S，G）”是路由器已接收（S，G）连接但已丢失（S，G）assert的所有接口的集合。第4.6.5节定义了宏lost_断言（S、G、I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(S,G) =
       { all interfaces I such that
         lost_assert(S,G,I) == TRUE }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(S,G) =
       { all interfaces I such that
         lost_assert(S,G,I) == TRUE }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following pseudocode macro definitions are also used in many places in the specification. Basically, RPF&#39; is the RPF neighbor towards an RP or source unless a PIM-Assert has overridden the normal choice of neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
规范中的许多地方也使用了以下伪代码宏定义。基本上，RPF&#39;是指向RP或源的RPF邻居，除非PIM断言覆盖了正常的邻居选择。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     neighbor RPF&#39;(*,G) {
         if ( I_Am_Assert_Loser(*, G, RPF_interface(RP(G))) ) {
              return AssertWinner(*, G, RPF_interface(RP(G)) )
         } else {
              return NBR( RPF_interface(RP(G)), MRIB.next_hop( RP(G) ) )
         }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     neighbor RPF&#39;(*,G) {
         if ( I_Am_Assert_Loser(*, G, RPF_interface(RP(G))) ) {
              return AssertWinner(*, G, RPF_interface(RP(G)) )
         } else {
              return NBR( RPF_interface(RP(G)), MRIB.next_hop( RP(G) ) )
         }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     neighbor RPF&#39;(S,G,rpt) {
         if( I_Am_Assert_Loser(S, G, RPF_interface(RP(G)) ) ) {
              return AssertWinner(S, G, RPF_interface(RP(G)) )
         } else {
              return RPF&#39;(*,G)
         }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     neighbor RPF&#39;(S,G,rpt) {
         if( I_Am_Assert_Loser(S, G, RPF_interface(RP(G)) ) ) {
              return AssertWinner(S, G, RPF_interface(RP(G)) )
         } else {
              return RPF&#39;(*,G)
         }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     neighbor RPF&#39;(S,G) {
         if ( I_Am_Assert_Loser(S, G, RPF_interface(S) )) {
              return AssertWinner(S, G, RPF_interface(S) )
         } else {
              return NBR( RPF_interface(S), MRIB.next_hop( S ) )
         }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     neighbor RPF&#39;(S,G) {
         if ( I_Am_Assert_Loser(S, G, RPF_interface(S) )) {
              return AssertWinner(S, G, RPF_interface(S) )
         } else {
              return NBR( RPF_interface(S), MRIB.next_hop( S ) )
         }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF&#39;(*,G) and RPF&#39;(S,G) indicate the neighbor from which data packets should be coming and to which joins should be sent on the RP tree and SPT, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF&#39;（*，G）和RPF&#39;（S，G）分别表示RP树和SPT上数据包应该来自的邻居和应该发送连接的邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF&#39;(S,G,rpt) is basically RPF&#39;(*,G) modified by the result of an Assert(S,G) on RPF_interface(RP(G)). In such a case, packets from S will be originating from a different router than RPF&#39;(*,G). If we only have active (*,G) Join state, we need to accept packets from RPF&#39;(S,G,rpt) and add a Prune(S,G,rpt) to the periodic Join(*,G) messages that we send to RPF&#39;(*,G) (see Section 4.5.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF&#39;（S，G，rpt）基本上是由RPF_接口（RP（G））上的断言（S，G）的结果修改的RPF&#39;（*，G）。在这种情况下，来自S的数据包将来自不同于RPF&#39;（*，G）的路由器。如果我们只有活动（*，G）连接状态，我们需要接受来自RPF&#39;（S，G，rpt）的数据包，并向发送到RPF&#39;（*，G）的定期连接（*，G）消息添加一个删减（S，G，rpt）（见第4.5.8节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function MRIB.next_hop( S ) returns an address of the next-hop PIM neighbor toward the host S, as indicated by the current MRIB. If S is directly adjacent, then MRIB.next_hop( S ) returns NULL. At the RP for G, MRIB.next_hop( RP(G)) returns NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
函数MRIB.next_hop（S）返回指向主机的下一跳PIM邻居的地址，如当前MRIB所示。如果S直接相邻，则MRIB.next_hop（S）返回NULL。在G的RP处，MRIB.next_hop（RP（G））返回NULL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function NBR( I, A ) uses information gathered through PIM Hello messages to map the IP address A of a directly connected PIM neighbor router on interface I to the primary IP address of the same router (Section 4.3.4). The primary IP address of a neighbor is the address that it uses as the source of its PIM Hello messages. Note that a neighbor&#39;s IP address may be non-unique within the PIM neighbor database due to scope issues. The address must, however, be unique amongst the addresses of all the PIM neighbors on a specific interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
功能NBR（I，A）使用通过PIM Hello消息收集的信息，将接口I上直接连接的PIM邻居路由器的IP地址A映射到同一路由器的主IP地址（第4.3.4节）。邻居的主IP地址是它用作其PIM Hello消息源的地址。请注意，由于作用域问题，邻居的IP地址在PIM邻居数据库中可能是非唯一的。但是，该地址在特定接口上所有PIM邻居的地址中必须是唯一的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I_Am_Assert_Loser(S, G, I) is true if the Assert state machine (in Section 4.6.1) for (S,G) on Interface I is in &#34;I am Assert Loser&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果接口I上（S，G）的断言状态机（在第4.6.1节中）处于“我是断言失败者”状态，则I_Am_断言失败者（S，G，I）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I_Am_Assert_Loser(*, G, I) is true if the Assert state machine (in Section 4.6.2) for (*,G) on Interface I is in &#34;I am Assert Loser&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果接口I上（*，G）的断言状态机（在第4.6.2节中）处于“I Am Assert Loser”状态，则I_Am_Assert_Loser（*，G，I）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Data Packet Forwarding Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 数据包转发规则
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM-SM packet forwarding rules are defined below in pseudocode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM数据包转发规则在下面的伪代码中定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
iif is the incoming interface of the packet. S is the source address of the packet. G is the destination address of the packet (group address). RP is the address of the Rendezvous Point for this group. RPF_interface(S) is the interface the MRIB indicates would be used to route packets to S. RPF_interface(RP) is the interface the MRIB indicates would be used to route packets to RP, except at the RP when it is the decapsulation interface (the &#34;virtual&#34; interface on which register packets are received).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
iif是数据包的传入接口。S是数据包的源地址。G是数据包的目标地址（组地址）。RP是此组的集合点地址。RPF_接口是MRIB指示的用于将数据包路由到S的接口。RPF_接口（RP）是MRIB指示的用于将数据包路由到RP的接口，但在RP处是去封装接口（接收注册数据包的“虚拟”接口）时除外。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, we restart (or start) the Keepalive Timer if the source is on a directly connected subnet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
首先，如果源位于直接连接的子网上，则重新启动（或启动）Keepalive计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Second, we check to see if the SPTbit should be set because we&#39;ve now switched from the RP tree to the SPT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其次，我们检查是否应该设置SPTbit，因为我们现在已经从RP树切换到了SPT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Next, we check to see whether the packet should be accepted based on TIB state and the interface that the packet arrived on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接下来，我们检查是否应该根据TIB状态和数据包到达的接口接受数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the packet should be forwarded using (S,G) state, we then build an outgoing interface list for the packet. If this list is not empty, then we restart the (S,G) state Keepalive Timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果数据包应该使用（S，G）状态转发，那么我们就为数据包建立一个传出接口列表。如果此列表不为空，则重新启动（S，G）状态Keepalive计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the packet should be forwarded using (*,*,RP) or (*,G) state, then we just build an outgoing interface list for the packet. We also check if we should initiate a switch to start receiving this source on a shortest path tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果应该使用（*，*，RP）或（*，G）状态转发数据包，那么我们只需为数据包构建一个传出接口列表。我们还检查是否应该启动一个交换机，以在最短路径树上开始接收该源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally we remove the incoming interface from the outgoing interface list we&#39;ve created, and if the resulting outgoing interface list is not empty, we forward the packet out of those interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，我们从我们创建的传出接口列表中删除传入接口，如果生成的传出接口列表不是空的，我们将数据包转发出这些接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   On receipt of data from S to G on interface iif:
    if( DirectlyConnected(S) == TRUE AND iif == RPF_interface(S) ) {
         set KeepaliveTimer(S,G) to Keepalive_Period
         # Note: a register state transition or UpstreamJPState(S,G)
         # transition may happen as a result of restarting
         # KeepaliveTimer, and must be dealt with here.
    }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   On receipt of data from S to G on interface iif:
    if( DirectlyConnected(S) == TRUE AND iif == RPF_interface(S) ) {
         set KeepaliveTimer(S,G) to Keepalive_Period
         # Note: a register state transition or UpstreamJPState(S,G)
         # transition may happen as a result of restarting
         # KeepaliveTimer, and must be dealt with here.
    }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined AND
      inherited_olist(S,G) != NULL ) {
          set KeepaliveTimer(S,G) to Keepalive_Period
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined AND
      inherited_olist(S,G) != NULL ) {
          set KeepaliveTimer(S,G) to Keepalive_Period
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Update_SPTbit(S,G,iif) oiflist = NULL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新_SPTbit（S，G，iif）oiflist=NULL
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if( iif == RPF_interface(S) AND SPTbit(S,G) == TRUE ) {
      oiflist = inherited_olist(S,G)
   } else if( iif == RPF_interface(RP(G)) AND SPTbit(S,G) == FALSE) {
     oiflist = inherited_olist(S,G,rpt)
     CheckSwitchToSpt(S,G)
   } else {
      # Note: RPF check failed
      # A transition in an Assert FSM may cause an Assert(S,G)
      # or Assert(*,G) message to be sent out interface iif.
      # See section 4.6 for details.
      if ( SPTbit(S,G) == TRUE AND iif is in inherited_olist(S,G) ) {
         send Assert(S,G) on iif
      } else if ( SPTbit(S,G) == FALSE AND
                  iif is in inherited_olist(S,G,rpt) {
         send Assert(*,G) on iif
      }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if( iif == RPF_interface(S) AND SPTbit(S,G) == TRUE ) {
      oiflist = inherited_olist(S,G)
   } else if( iif == RPF_interface(RP(G)) AND SPTbit(S,G) == FALSE) {
     oiflist = inherited_olist(S,G,rpt)
     CheckSwitchToSpt(S,G)
   } else {
      # Note: RPF check failed
      # A transition in an Assert FSM may cause an Assert(S,G)
      # or Assert(*,G) message to be sent out interface iif.
      # See section 4.6 for details.
      if ( SPTbit(S,G) == TRUE AND iif is in inherited_olist(S,G) ) {
         send Assert(S,G) on iif
      } else if ( SPTbit(S,G) == FALSE AND
                  iif is in inherited_olist(S,G,rpt) {
         send Assert(*,G) on iif
      }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oiflist = oiflist (-) iif forward packet on all interfaces in oiflist
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
oiflist=oiflist（-）oiflist中所有接口上的iif转发数据包
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This pseudocode employs several &#34;macro&#34; definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此伪代码使用了几个“宏”定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DirectlyConnected(S) is TRUE if the source S is on any subnet that is directly connected to this router (or for packets originating on this router).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果源位于直接连接到此路由器（或源自此路由器的数据包）的任何子网上，则DirectlyConnected为TRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inherited_olist(S,G) and inherited_olist(S,G,rpt) are defined in Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.1节中定义了继承的资产负债表（S，G）和继承的资产负债表（S，G，rpt）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Basically, inherited_olist(S,G) is the outgoing interface list for packets forwarded on (S,G) state, taking into account (*,*,RP) state, (*,G) state, asserts, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本上，继承的_olist（S，G）是在（S，G）状态下转发的数据包的传出接口列表，考虑（*，*，RP）状态、（*，G）状态、断言等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inherited_olist(S,G,rpt) is the outgoing interface list for packets forwarded on (*,*,RP) or (*,G) state, taking into account (S,G,rpt) prune state, asserts, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inherited_olist（S，G，rpt）是在（*，*，RP）或（*，G）状态下转发的数据包的传出接口列表，考虑到（S，G，rpt）修剪状态、断言等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Update_SPTbit(S,G,iif) is defined in Section 4.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.2.2节定义了更新标准（S、G、iif）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CheckSwitchToSpt(S,G) is defined in Section 4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.2.1节定义了CheckSwitchToSpt（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamJPState(S,G) is the state of the finite state machine in Section 4.5.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamJPState（S，G）是第4.5.7节中有限状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keepalive_Period is defined in Section 4.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.10节定义了保持期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data-triggered PIM-Assert messages sent from the above forwarding code should be rate-limited in a implementation-dependent manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从上述转发代码发送的数据触发PIM Assert消息应以依赖于实现的方式进行速率限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Last-Hop Switchover to the SPT
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. 最后一跳切换到SPT
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Sparse-Mode PIM, last-hop routers join the shared tree towards the RP. Once traffic from sources to joined groups arrives at a last-hop router, it has the option of switching to receive the traffic on a shortest path tree (SPT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在稀疏模式PIM中，最后一跳路由器向RP加入共享树。一旦从源到加入组的流量到达最后一跳路由器，它可以选择切换以在最短路径树（SPT）上接收流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The decision for a router to switch to the SPT is controlled as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器切换到SPT的决定受以下控制：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void
     CheckSwitchToSpt(S,G) {
       if ( ( pim_include(*,G) (-) pim_exclude(S,G)
              (+) pim_include(S,G) != NULL )
            AND SwitchToSptDesired(S,G) ) {
              # Note: Restarting the KAT will result in the SPT switch
              set KeepaliveTimer(S,G) to Keepalive_Period
       }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void
     CheckSwitchToSpt(S,G) {
       if ( ( pim_include(*,G) (-) pim_exclude(S,G)
              (+) pim_include(S,G) != NULL )
            AND SwitchToSptDesired(S,G) ) {
              # Note: Restarting the KAT will result in the SPT switch
              set KeepaliveTimer(S,G) to Keepalive_Period
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SwitchToSptDesired(S,G) is a policy function that is implementation defined. An &#34;infinite threshold&#34; policy can be implemented by making SwitchToSptDesired(S,G) return false all the time. A &#34;switch on first packet&#34; policy can be implemented by making SwitchToSptDesired(S,G) return true once a single packet has been received for the source and group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SwitchToSptDesired（S，G）是实现定义的策略功能。通过使SwitchToSptDesired（S，G）始终返回false，可以实现“无限阈值”策略。一旦接收到源和组的单个数据包，就可以通过使SwitchToSptDesired（S，G）返回true来实现“打开第一个数据包”策略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Setting and Clearing the (S,G) SPTbit
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 设置和清除（S，G）SPTbit
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (S,G) SPTbit is used to distinguish whether to forward on (*,*,RP)/(*,G) or on (S,G) state. When switching from the RP tree to the source tree, there is a transition period when data is arriving due to upstream (*,*,RP)/(*,G) state while upstream (S,G) state is being established, during which time a router should continue to forward only on (*,*,RP)/(*,G) state. This prevents temporary black-holes that would be caused by sending a Prune(S,G,rpt) before the upstream (S,G) state has finished being established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）SPTbit用于区分是在（*，*，RP）/（*，G）状态下转发还是在（S，G）状态下转发。当从RP树切换到源树时，由于上游（*，*，RP）/（*，G）状态，在建立上游（S，G）状态的同时，存在一个数据到达的过渡期，在此期间，路由器应仅在（*，*，RP）/（*，G）状态下继续转发。这可以防止在上游（S，G）状态建立完成之前发送剪枝（S，G，rpt）导致的临时黑洞。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, when a packet arrives, the (S,G) SPTbit is updated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，当分组到达时，（S，G）SPTbit更新如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void
     Update_SPTbit(S,G,iif) {
       if ( iif == RPF_interface(S)
             AND JoinDesired(S,G) == TRUE
             AND ( DirectlyConnected(S) == TRUE
                   OR RPF_interface(S) != RPF_interface(RP(G))
                   OR inherited_olist(S,G,rpt) == NULL
                   OR ( ( RPF&#39;(S,G) == RPF&#39;(*,G) ) AND
                        ( RPF&#39;(S,G) != NULL ) )
                   OR ( I_Am_Assert_Loser(S,G,iif) ) {
          Set SPTbit(S,G) to TRUE
       }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void
     Update_SPTbit(S,G,iif) {
       if ( iif == RPF_interface(S)
             AND JoinDesired(S,G) == TRUE
             AND ( DirectlyConnected(S) == TRUE
                   OR RPF_interface(S) != RPF_interface(RP(G))
                   OR inherited_olist(S,G,rpt) == NULL
                   OR ( ( RPF&#39;(S,G) == RPF&#39;(*,G) ) AND
                        ( RPF&#39;(S,G) != NULL ) )
                   OR ( I_Am_Assert_Loser(S,G,iif) ) {
          Set SPTbit(S,G) to TRUE
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, a router can set SPTbit(S,G) to TRUE in other cases, such as when it receives an Assert(S,G) on RPF_interface(S) (see Section 4.6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，路由器可以在其他情况下将SPTbit（S，G）设置为TRUE，例如在RPF_接口上接收断言（S，G）（参见第4.6.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinDesired(S,G) is defined in Section 4.5.7 and indicates whether we have the appropriate (S,G) Join state to wish to send a Join(S,G) upstream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinDesired（S，G）在第4.5.7节中有定义，并表明我们是否有适当的（S，G）连接状态以希望向上游发送连接（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Basically, Update_SPTbit will set the SPTbit if we have the appropriate (S,G) join state, and if the packet arrived on the correct upstream interface for S, and if one or more of the following conditions applies:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本上，如果我们有适当的（S，G）连接状态，如果数据包到达正确的上游接口，并且如果以下一个或多个条件适用，则Update_SPTbit将设置SPTbit：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The source is directly connected, in which case the switch to the SPT is a no-op.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 电源直接连接，在这种情况下，SPT的开关为no-op。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The RPF interface to S is different from the RPF interface to the RP. The packet arrived on RPF_interface(S), and so the SPT must have been completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 到S的RPF接口与到RP的RPF接口不同。数据包到达RPF_接口，因此SPT必须已完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Noone wants the packet on the RP tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 没有人想要RP树上的包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. RPF&#39;(S,G) == RPF&#39;(*,G). In this case, the router will never be able to tell if the SPT has been completed, so it should just switch immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. RPF&#39;（S，G）=RPF&#39;（*，G）。在这种情况下，路由器永远无法判断SPT是否已完成，因此它应该立即切换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the case where the RPF interface is the same for the RP and for S, but RPF&#39;(S,G) and RPF&#39;(*,G) differ, we wait for an Assert(S,G), which indicates that the upstream router with (S,G) state believes the SPT has been completed. However, item (3) above is needed because there may not be any (*,G) state to trigger an Assert(S,G) to happen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果RP和S的RPF接口相同，但RPF&#39;（S，G）和RPF&#39;（*，G）不同，则我们等待断言（S，G），这表明具有（S，G）状态的上游路由器认为SPT已完成。但是，需要上面的第（3）项，因为可能没有任何（*，G）状态来触发断言（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SPTbit is cleared in the (S,G) upstream state machine (see Section 4.5.7) when JoinDesired(S,G) becomes FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当（S，G）变为假时，在（S，G）上游状态机（见第4.5.7节）中清除SPTbit。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Designated Routers (DR) and Hello Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 指定路由器（DR）和Hello消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A shared-media LAN like Ethernet may have multiple PIM-SM routers connected to it. A single one of these routers, the DR, will act on behalf of directly connected hosts with respect to the PIM-SM protocol. Because the distinction between LANs and point-to-point interfaces can sometimes be blurred, and because routers may also have multicast host functionality, the PIM-SM specification makes no distinction between the two. Thus, DR election will happen on all interfaces, LAN or otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
像以太网这样的共享媒体LAN可能连接有多个PIM-SM路由器。就PIM-SM协议而言，这些路由器中的一个，即DR，将代表直接连接的主机。由于局域网和点到点接口之间的区别有时会模糊不清，而且路由器也可能具有多播主机功能，因此PIM-SM规范对两者没有区别。因此，DR选择将在所有接口（LAN或其他接口）上进行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR election is performed using Hello messages. Hello messages are also the way that option negotiation takes place in PIM, so that additional functionality can be enabled, or parameters tuned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用Hello消息执行DR选择。Hello消息也是在PIM中进行选项协商的方式，因此可以启用附加功能或调整参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Sending Hello Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. 发送问候信息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Hello messages are sent periodically on each PIM-enabled interface. They allow a router to learn about the neighboring PIM routers on each interface. Hello messages are also the mechanism used to elect a Designated Router (DR), and to negotiate additional capabilities. A router must record the Hello information received from each PIM neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Hello消息在每个启用PIM的接口上定期发送。它们允许路由器了解每个接口上相邻的PIM路由器。Hello消息也是用于选择指定路由器（DR）和协商附加功能的机制。路由器必须记录从每个PIM邻居收到的Hello信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello messages MUST be sent on all active interfaces, including physical point-to-point links, and are multicast to the &#39;ALL-PIM-ROUTERS&#39; group address (&#39;224.0.0.13&#39; for IPv4 and &#39;ff02::d&#39; for IPv6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello消息必须在所有活动接口（包括物理点到点链路）上发送，并多播到“all-PIM-ROUTERS”组地址（“IPv4为224.0.0.13”，IPv6为“ff02:：d”）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
We note that some implementations do not send Hello messages on point-to-point interfaces. This is non-compliant behavior. A compliant PIM router MUST send Hello messages, even on point-to-point interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我们注意到，一些实现不在点到点接口上发送Hello消息。这是不合规的行为。兼容的PIM路由器必须发送Hello消息，即使在点到点接口上也是如此。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A per-interface Hello Timer (HT(I)) is used to trigger sending Hello messages on each active interface. When PIM is enabled on an interface or a router first starts, the Hello Timer of that interface is set to a random value between 0 and Triggered_Hello_Delay. This prevents synchronization of Hello messages if multiple routers are powered on simultaneously. After the initial randomized interval, Hello messages must be sent every Hello_Period seconds. The Hello Timer should not be reset except when it expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个接口Hello定时器（HT（I））用于触发在每个活动接口上发送Hello消息。当接口上启用PIM或路由器首次启动时，该接口的Hello定时器设置为0和触发的Hello\u延迟之间的随机值。如果多个路由器同时通电，这将阻止Hello消息的同步。在初始随机间隔之后，必须每隔几秒钟发送一次Hello_消息。除非Hello计时器过期，否则不应重置它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that neighbors will not accept Join/Prune or Assert messages from a router unless they have first heard a Hello message from that router. Thus, if a router needs to send a Join/Prune or Assert message on an interface on which it has not yet sent a Hello message with the currently configured IP address, then it MUST immediately send the relevant Hello message without waiting for the Hello Timer to expire, followed by the Join/Prune or Assert message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，邻居不会接受来自路由器的加入/删除或断言消息，除非他们第一次听到来自该路由器的Hello消息。因此，如果路由器需要在其尚未发送具有当前配置的IP地址的Hello消息的接口上发送加入/删除或断言消息，那么它必须立即发送相关Hello消息，而无需等待Hello计时器过期，然后发送加入/删除或断言消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DR_Priority Option allows a network administrator to give preference to a particular router in the DR election process by giving it a numerically larger DR Priority. The DR_Priority Option SHOULD be included in every Hello message, even if no DR Priority is explicitly configured on that interface. This is necessary because priority-based DR election is only enabled when all neighbors on an interface advertise that they are capable of using the DR_Priority Option. The default priority is 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR_Priority选项允许网络管理员在DR选举过程中通过赋予特定路由器更大的DR优先级来优先选择该路由器。每个Hello消息中都应该包含DR_Priority选项，即使该接口上没有显式配置DR Priority。这是必要的，因为只有当接口上的所有邻居宣布他们能够使用DR_priority选项时，才会启用基于优先级的DR election。默认优先级为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Generation_Identifier (GenID) Option SHOULD be included in all Hello messages. The GenID option contains a randomly generated 32-bit value that is regenerated each time PIM forwarding is started or restarted on the interface, including when the router itself restarts. When a Hello message with a new GenID is received from a neighbor, any old Hello information about that neighbor SHOULD be discarded and superseded by the information from the new Hello message. This may cause a new DR to be chosen on that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有Hello消息中都应包含Generation_Identifier（GenID）选项。GenID选项包含一个随机生成的32位值，该值在接口上每次启动或重新启动PIM转发时重新生成，包括路由器本身重新启动时。当从邻居接收到带有新GenID的Hello消息时，任何关于该邻居的旧Hello信息都应该被丢弃，并被来自新Hello消息的信息取代。这可能会导致在该接口上选择新的DR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAN Prune Delay Option SHOULD be included in all Hello messages sent on multi-access LANs. This option advertises a router&#39;s capability to use values other than the defaults for the Propagation_Delay and Override_Interval, which affect the setting of the Prune-Pending, Upstream Join, and Override Timers (defined in Section 4.10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在多访问LAN上发送的所有Hello消息中都应包含LAN修剪延迟选项。此选项宣传路由器使用传播延迟和覆盖间隔默认值以外的值的能力，这会影响修剪挂起、上游连接和覆盖计时器的设置（在第4.10节中定义）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Address List Option advertises all the secondary addresses associated with the source interface of the router originating the message. The option MUST be included in all Hello messages if there are secondary addresses associated with the source interface and MAY be omitted if no secondary addresses exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
地址列表选项播发与发起消息的路由器的源接口相关联的所有辅助地址。如果存在与源接口关联的辅助地址，则该选项必须包含在所有Hello消息中，如果不存在辅助地址，则可以省略该选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To allow new or rebooting routers to learn of PIM neighbors quickly, when a Hello message is received from a new neighbor, or a Hello message with a new GenID is received from an existing neighbor, a new Hello message should be sent on this interface after a randomized delay between 0 and Triggered_Hello_Delay. This triggered message need not change the timing of the scheduled periodic message. If a router needs to send a Join/Prune to the new neighbor or send an Assert message in response to an Assert message from the new neighbor before this randomized delay has expired, then it MUST immediately send the relevant Hello message without waiting for the Hello Timer to expire, followed by the Join/Prune or Assert message. If it does not do this, then the new neighbor will discard the Join/Prune or Assert message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了使新的或重新启动的路由器能够快速了解PIM邻居，当从新邻居收到Hello消息，或从现有邻居收到带有新GenID的Hello消息时，应在0和触发Hello\u延迟之间的随机延迟后在此接口上发送新的Hello消息。此触发消息无需更改计划的定期消息的定时。如果路由器需要在随机延迟过期之前向新邻居发送加入/删除或发送断言消息以响应来自新邻居的断言消息，那么它必须立即发送相关的Hello消息，而不等待Hello计时器过期，然后发送加入/删除或断言消息。如果不这样做，那么新邻居将丢弃Join/Prune或Assert消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before an interface goes down or changes primary IP address, a Hello message with a zero HoldTime should be sent immediately (with the old IP address if the IP address changed). This will cause PIM neighbors to remove this neighbor (or its old IP address) immediately. After an interface has changed its IP address, it MUST send a Hello message with its new IP address. If an interface changes one of its secondary IP addresses, a Hello message with an updated Address_List option and a non-zero HoldTime should be sent immediately. This will cause PIM neighbors to update this neighbor&#39;s list of secondary addresses immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在接口关闭或更改主IP地址之前，应立即发送保持时间为零的Hello消息（如果IP地址更改，则使用旧IP地址）。这将导致PIM邻居立即删除此邻居（或其旧IP地址）。接口更改其IP地址后，它必须发送一条带有新IP地址的Hello消息。如果接口更改了其一个辅助IP地址，则应立即发送带有更新地址列表选项和非零保持时间的Hello消息。这将导致PIM邻居立即更新此邻居的辅助地址列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. DR Election
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. 选举博士
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a PIM Hello message is received on interface I, the following information about the sending neighbor is recorded:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当在接口I上接收到PIM Hello消息时，记录关于发送邻居的以下信息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.interface The interface on which the Hello message arrived.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
interface Hello消息到达的接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.primary_ip_address The IP address that the PIM neighbor used as the source address of the Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.primary_ip_address PIM邻居用作Hello消息源地址的ip地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.genid The Generation ID of the PIM neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.genid PIM邻居的代ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.dr_priority The DR Priority field of the PIM neighbor, if it is present in the Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.dr_priority PIM邻居的dr priority字段，如果它出现在Hello消息中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.dr_priority_present A flag indicating if the DR Priority field was present in the Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.dr_priority_显示一个标志，指示Hello消息中是否存在dr priority字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.timeout A timer value to time out the neighbor state when it becomes stale, also known as the Neighbor Liveness Timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.timeout一个计时器值，用于在邻居状态过时时对其进行超时，也称为邻居活动计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The Neighbor Liveness Timer (NLT(N,I)) is reset to Hello_Holdtime (from the Hello Holdtime option) whenever a Hello message is received containing a Holdtime option, or to Default_Hello_Holdtime if the Hello message does not contain the Holdtime option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
每当接收到包含Holdtime选项的Hello消息时，邻居活跃度计时器（NLT（N，I））将重置为Hello_Holdtime（来自Hello Holdtime选项），或者如果Hello消息不包含Holdtime选项，将重置为默认的Hello_Holdtime。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Neighbor state is deleted when the neighbor timeout expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
邻居超时过期时，将删除邻居状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function for computing the DR on interface I is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在接口I上计算DR的功能是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     host
     DR(I) {
         dr = me
         for each neighbor on interface I {
             if ( dr_is_better( neighbor, dr, I ) == TRUE ) {
                 dr = neighbor
             }
         }
         return dr
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     host
     DR(I) {
         dr = me
         for each neighbor on interface I {
             if ( dr_is_better( neighbor, dr, I ) == TRUE ) {
                 dr = neighbor
             }
         }
         return dr
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function used for comparing DR &#34;metrics&#34; on interface I is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于比较接口I上的DR“度量”的函数为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     dr_is_better(a,b,I) {
         if( there is a neighbor n on I for which n.dr_priority_present
                 is false ) {
             return a.primary_ip_address &gt; b.primary_ip_address
         } else {
             return ( a.dr_priority &gt; b.dr_priority ) OR
                    ( a.dr_priority == b.dr_priority AND
                      a.primary_ip_address &gt; b.primary_ip_address )
         }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     dr_is_better(a,b,I) {
         if( there is a neighbor n on I for which n.dr_priority_present
                 is false ) {
             return a.primary_ip_address &gt; b.primary_ip_address
         } else {
             return ( a.dr_priority &gt; b.dr_priority ) OR
                    ( a.dr_priority == b.dr_priority AND
                      a.primary_ip_address &gt; b.primary_ip_address )
         }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The trivial function I_am_DR(I) is defined to aid readability:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
简单函数I_am_DR（I）的定义有助于可读性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     I_am_DR(I) {
        return DR(I) == me
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     I_am_DR(I) {
        return DR(I) == me
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The DR Priority is a 32-bit unsigned number, and the numerically larger priority is always preferred. A router&#39;s idea of the current DR on an interface can change when a PIM Hello message is received, when a neighbor times out, or when a router&#39;s own DR Priority changes. If the router becomes the DR or ceases to be the DR, this will normally cause the DR Register state machine to change state. Subsequent actions are determined by that state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DR优先级是一个32位无符号数，并且总是首选数值较大的优先级。当收到PIM Hello消息、邻居超时或路由器自身的DR优先级发生变化时，路由器对接口上当前DR的想法可能会改变。如果路由器成为DR或不再是DR，这通常会导致DR寄存器状态机更改状态。后续操作由该状态机确定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
We note that some PIM implementations do not send Hello messages on point-to-point interfaces and thus cannot perform DR election on such interfaces. This is non-compliant behavior. DR election MUST be performed on ALL active PIM-SM interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我们注意到，一些PIM实现不在点到点接口上发送Hello消息，因此无法在此类接口上执行DR选择。这是不合规的行为。必须在所有激活的PIM-SM接口上执行DR选择。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3. Reducing Prune Propagation Delay on LANs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3. 减少局域网上的剪枝传播延迟
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the information recorded for the DR Election, the following per neighbor information is obtained from the LAN Prune Delay Hello option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了为DR选举记录的信息外，还可以从LAN Prune Delay Hello选项获得以下每个邻居的信息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.lan_prune_delay_present A flag indicating if the LAN Prune Delay option was present in the Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.lan\u prune\u delay\u显示一个标志，指示Hello消息中是否存在lan prune delay选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.tracking_support A flag storing the value of the T bit in the LAN Prune Delay option if it is present in the Hello message. This indicates the neighbor&#39;s capability to disable Join message suppression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.tracking\如果Hello消息中存在T位，则支持在LAN Prune Delay选项中存储T位值的标志。这表示邻居禁用加入消息抑制的能力。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.propagation_delay The Propagation Delay field of the LAN Prune Delay option (if present) in the Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.propagation\u delay Hello消息中LAN修剪延迟选项（如果存在）的传播延迟字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.override_interval The Override_Interval field of the LAN Prune Delay option (if present) in the Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
override_interval Hello消息中LAN修剪延迟选项（如果存在）的override_interval字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The additional state described above is deleted along with the DR neighbor state when the neighbor timeout expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当邻居超时过期时，上述附加状态将与DR邻居状态一起删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Just like the DR_Priority option, the information provided in the LAN Prune Delay option is not used unless all neighbors on a link advertise the option. The function below computes this state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与DR_Priority选项一样，LAN Prune Delay选项中提供的信息不会被使用，除非链路上的所有邻居都宣传该选项。下面的函数计算此状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     lan_delay_enabled(I) {
         for each neighbor on interface I {
             if ( neighbor.lan_prune_delay_present == false ) {
                 return false
             }
         }
         return true
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     lan_delay_enabled(I) {
         for each neighbor on interface I {
             if ( neighbor.lan_prune_delay_present == false ) {
                 return false
             }
         }
         return true
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Propagation Delay inserted by a router in the LAN Prune Delay option expresses the expected message propagation delay on the link and should be configurable by the system administrator. It is used by upstream routers to figure out how long they should wait for a Join override message before pruning an interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器在LAN Prune Delay选项中插入的传播延迟表示链路上预期的消息传播延迟，应由系统管理员进行配置。上游路由器使用它来计算在修剪接口之前他们应该等待连接覆盖消息多长时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM implementers should enforce a lower bound on the permitted values for this delay to allow for scheduling and processing delays within their router. Such delays may cause received messages to be processed later as well as triggered messages to be sent later than intended. Setting this Propagation Delay to too low a value may result in temporary forwarding outages because a downstream router will not be able to override a neighbor&#39;s Prune message before the upstream neighbor stops forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM实现者应该对该延迟的允许值实施一个下限，以允许其路由器内的调度和处理延迟。这种延迟可能会导致接收到的消息被延迟处理，以及触发的消息被延迟发送。将此传播延迟设置为过低的值可能会导致临时转发中断，因为在上游邻居停止转发之前，下游路由器将无法覆盖邻居的修剪消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When all routers on a link are in a position to negotiate a Propagation Delay different from the default, the largest value from those advertised by each neighbor is chosen. The function for computing the Effective_Propagation_Delay of interface I is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当链路上的所有路由器都能够协商不同于默认值的传播延迟时，将选择每个邻居公布的最大值。计算接口I的有效传播延迟的函数为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     time_interval
     Effective_Propagation_Delay(I) {
         if ( lan_delay_enabled(I) == false ) {
             return Propagation_delay_default
         }
         delay = Propagation_Delay(I)
         for each neighbor on interface I {
             if ( neighbor.propagation_delay &gt; delay ) {
                 delay = neighbor.propagation_delay
             }
         }
         return delay
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     time_interval
     Effective_Propagation_Delay(I) {
         if ( lan_delay_enabled(I) == false ) {
             return Propagation_delay_default
         }
         delay = Propagation_Delay(I)
         for each neighbor on interface I {
             if ( neighbor.propagation_delay &gt; delay ) {
                 delay = neighbor.propagation_delay
             }
         }
         return delay
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid synchronization of override messages when multiple downstream routers share a multi-access link, sending of such messages is delayed by a small random amount of time. The period of randomization should represent the size of the PIM router population
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当多个下游路由器共享多址链路时，为了避免覆盖消息的同步，此类消息的发送会延迟少量随机时间。随机化周期应代表PIM路由器总体的大小
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
on the link. Each router expresses its view of the amount of randomization necessary in the Override Interval field of the LAN Prune Delay option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在链接上。每个路由器在LAN修剪延迟选项的覆盖间隔字段中表示其对所需随机化量的看法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When all routers on a link are in a position to negotiate an Override Interval different from the default, the largest value from those advertised by each neighbor is chosen. The function for computing the Effective Override Interval of interface I is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当链路上的所有路由器都能够协商不同于默认值的覆盖间隔时，将选择每个邻居公布的覆盖间隔中的最大值。计算接口I的有效覆盖间隔的函数为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     time_interval
     Effective_Override_Interval(I) {
         if ( lan_delay_enabled(I) == false ) {
             return t_override_default
         }
         delay = Override_Interval(I)
         for each neighbor on interface I {
             if ( neighbor.override_interval &gt; delay ) {
                 delay = neighbor.override_interval
             }
         }
         return delay
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     time_interval
     Effective_Override_Interval(I) {
         if ( lan_delay_enabled(I) == false ) {
             return t_override_default
         }
         delay = Override_Interval(I)
         for each neighbor on interface I {
             if ( neighbor.override_interval &gt; delay ) {
                 delay = neighbor.override_interval
             }
         }
         return delay
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the mechanisms are not specified in this document, it is possible for upstream routers to explicitly track the join membership of individual downstream routers if Join suppression is disabled. A router can advertise its willingness to disable Join suppression by using the T bit in the LAN Prune Delay Hello option. Unless all PIM routers on a link negotiate this capability, explicit tracking and the disabling of the Join suppression mechanism are not possible. The function for computing the state of Suppression on interface I is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管本文档中未指定这些机制，但如果连接抑制被禁用，则上游路由器可以显式跟踪各个下游路由器的连接成员资格。路由器可以通过使用LAN Prune Delay Hello选项中的T位来宣传其禁用连接抑制的意愿。除非链路上的所有PIM路由器协商此功能，否则不可能显式跟踪和禁用连接抑制机制。用于计算接口I上抑制状态的函数为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     Suppression_Enabled(I) {
         if ( lan_delay_enabled(I) == false ) {
             return true
         }
         for each neighbor on interface I {
             if ( neighbor.tracking_support == false ) {
                 return true
             }
         }
         return false
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool
     Suppression_Enabled(I) {
         if ( lan_delay_enabled(I) == false ) {
             return true
         }
         for each neighbor on interface I {
             if ( neighbor.tracking_support == false ) {
                 return true
             }
         }
         return false
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the setting of Suppression_Enabled(I) affects the value of t_suppressed (see Section 4.10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，抑制_启用（I）的设置会影响抑制的t_值（见第4.10节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.4. Maintaining Secondary Address Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.4. 维护辅助地址列表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Communication of a router&#39;s interface secondary addresses to its PIM neighbors is necessary to provide the neighbors with a mechanism for mapping next_hop information obtained through their MRIB to a primary address that can be used as a destination for Join/Prune messages. The mapping is performed through the NBR macro. The primary address of a PIM neighbor is obtained from the source IP address used in its PIM Hello messages. Secondary addresses are carried within the Hello message in an Address List Hello option. The primary address of the source interface of the router MUST NOT be listed within the Address List Hello option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器接口次要地址与其PIM邻居的通信是必要的，以便为邻居提供一种机制，将通过其MRIB获得的下一跳信息映射到主地址，该主地址可用作连接/删除消息的目的地。映射通过NBR宏执行。PIM邻居的主地址来自其PIM Hello消息中使用的源IP地址。辅助地址包含在地址列表Hello选项的Hello消息中。路由器源接口的主地址不得在地址列表Hello选项中列出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the information recorded for the DR Election, the following per neighbor information is obtained from the Address List Hello option:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了为DR选举记录的信息外，还可以从地址列表Hello选项中获得以下每个邻居的信息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.secondary_address_list The list of secondary addresses used by the PIM neighbor on the interface through which the Hello message was transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
neighbor.secondary_address_列出PIM邻居在发送Hello消息的接口上使用的次要地址列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When processing a received PIM Hello message containing an Address List Hello option, the list of secondary addresses in the message completely replaces any previously associated secondary addresses for that neighbor. If a received PIM Hello message does not contain an Address List Hello option, then all secondary addresses associated with the neighbor must be deleted. If a received PIM Hello message contains an Address List Hello option that includes the primary address of the sending router in the list of secondary addresses (although this is not expected), then the addresses listed in the message, excluding the primary address, are used to update the associated secondary addresses for that neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处理接收到的包含地址列表Hello选项的PIM Hello消息时，消息中的辅助地址列表将完全替换该邻居以前关联的任何辅助地址。如果收到的PIM Hello消息不包含地址列表Hello选项，则必须删除与邻居关联的所有辅助地址。如果收到的PIM Hello消息包含地址列表Hello选项，该选项将发送路由器的主地址包括在辅助地址列表中（尽管这不是预期的），则消息中列出的地址（不包括主地址）将用于更新该邻居的关联辅助地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the advertised secondary addresses in received Hello messages must be checked against those previously advertised by all other PIM neighbors on that interface. If there is a conflict and the same secondary address was previously advertised by another neighbor, then only the most recently received mapping MUST be maintained, and an error message SHOULD be logged to the administrator in a rate-limited manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收到的Hello消息中的所有播发的辅助地址必须与该接口上所有其他PIM邻居先前播发的辅助地址进行检查。如果存在冲突，并且相同的辅助地址以前由另一个邻居播发，则必须仅维护最近接收的映射，并且应以速率受限的方式向管理员记录错误消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within one Address List Hello option, all the addresses MUST be of the same address family. It is not permitted to mix IPv4 and IPv6 addresses within the same message. In addition, the address family of the fields in the message SHOULD be the same as the IP source and destination addresses of the packet header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在一个地址列表Hello选项中，所有地址必须属于同一地址族。不允许在同一消息中混合使用IPv4和IPv6地址。此外，消息中字段的地址系列应与数据包头的IP源地址和目标地址相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. PIM Register Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. PIM寄存器消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Designated Router (DR) on a LAN or point-to-point link encapsulates multicast packets from local sources to the RP for the relevant group unless it recently received a Register-Stop message for that (S,G) or (*,G) from the RP. When the DR receives a Register-Stop message from the RP, it starts a Register-Stop Timer to maintain this state. Just before the Register-Stop Timer expires, the DR sends a Null-Register Message to the RP to allow the RP to refresh the Register-Stop information at the DR. If the Register-Stop Timer actually expires, the DR will resume encapsulating packets from the source to the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAN或点对点链路上的指定路由器（DR）将本地源的多播数据包封装到相关组的RP，除非其最近从RP接收到该（S，G）或（*，G）的寄存器停止消息。当DR从RP接收到寄存器停止消息时，它启动寄存器停止计时器以保持此状态。就在寄存器停止计时器到期之前，DR向RP发送空寄存器消息，以允许RP在DR刷新寄存器停止信息。如果寄存器停止计时器实际到期，DR将恢复将数据包从源封装到RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. Sending Register Messages from the DR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. 从DR发送注册信息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every PIM-SM router has the capability to be a DR. The state machine below is used to implement Register functionality. For the purposes of specification, we represent the mechanism to encapsulate packets to the RP as a Register-Tunnel interface, which is added to or removed from the (S,G) olist. The tunnel interface then takes part in the normal packet forwarding rules as specified in Section 4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个PIM-SM路由器都有成为DR的能力。下面的状态机用于实现寄存器功能。出于规范的目的，我们将包封装到RP的机制表示为寄存器隧道接口，该接口添加到（S，G）olist中或从中删除。然后，隧道接口参与第4.2节规定的正常数据包转发规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If register state is maintained, it is maintained only for directly connected sources and is per-(S,G). There are four states in the DR&#39;s per-(S,G) Register state machine:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果保持寄存器状态，则仅对直接连接的源保持寄存器状态，并且为每-（S，G）。DR的每-（s，G）寄存器状态机中有四种状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Join (J) The register tunnel is &#34;joined&#34; (the join is actually implicit, but the DR acts as if the RP has joined the DR on the tunnel interface).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Join（J）寄存器通道是“连接的”（连接实际上是隐式的，但DR的行为就好像RP在通道接口上连接了DR一样）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prune (P) The register tunnel is &#34;pruned&#34; (this occurs when a Register-Stop is received).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
删减（P）寄存器通道被“删减”（在收到寄存器停止时发生）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Join-Pending (JP) The register tunnel is pruned but the DR is contemplating adding it back.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
joinpending（JP）注册隧道被删减，但DR正在考虑将其重新添加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NoInfo (NI) No information. This is the initial state, and the state when the router is not the DR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NoInfo（NI）没有信息。这是初始状态，也是路由器不是DR时的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, a Register-Stop Timer (RST) is kept if the state machine is not in the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，如果状态机未处于NoInfo状态，则保留寄存器停止计时器（RST）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 1: Per-(S,G) register state machine at a DR in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图1：以表格形式在DR上的Per-（S，G）寄存器状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------++----------------------------------------------------------+
|          ||                          Event                           |
|          ++----------+-----------+-----------+-----------+-----------+
|Prev State||Register- | Could     | Could     | Register- | RP changed|
|          ||Stop Timer| Register  | Register  | Stop      |           |
|          ||expires   | -&gt;True    | -&gt;False   | received  |           |
+----------++----------+-----------+-----------+-----------+-----------+
|NoInfo    ||-         | -&gt; J state| -         | -         | -         |
|(NI)      ||          | add reg   |           |           |           |
|          ||          | tunnel    |           |           |           |
+----------++----------+-----------+-----------+-----------+-----------+
|          ||-         | -         | -&gt; NI     | -&gt; P state| -&gt; J state|
|          ||          |           | state     |           |           |
|          ||          |           | remove reg| remove reg| update reg|
|Join (J)  ||          |           | tunnel    | tunnel;   | tunnel    |
|          ||          |           |           | set       |           |
|          ||          |           |           | Register- |           |
|          ||          |           |           | Stop      |           |
|          ||          |           |           | Timer(*)  |           |
+----------++----------+-----------+-----------+-----------+-----------+
|          ||-&gt; J state| -         | -&gt; NI     | -&gt; P state| -&gt; J state|
|          ||          |           | state     |           |           |
|Join-     ||add reg   |           |           | set       | add reg   |
|Pending   ||tunnel    |           |           | Register- | tunnel;   |
|(JP)      ||          |           |           | Stop      | cancel    |
|          ||          |           |           | Timer(*)  | Register- |
|          ||          |           |           |           | Stop Timer|
+----------++----------+-----------+-----------+-----------+-----------+
|          ||-&gt; JP     | -         | -&gt; NI     | -         | -&gt; J state|
|          ||state     |           | state     |           |           |
|          ||set       |           |           |           | add reg   |
|Prune (P) ||Register- |           |           |           | tunnel;   |
|          ||Stop      |           |           |           | cancel    |
|          ||Timer(**);|           |           |           | Register- |
|          ||send Null-|           |           |           | Stop Timer|
|          ||Register  |           |           |           |           |
+----------++----------+-----------+-----------+-----------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------++----------------------------------------------------------+
|          ||                          Event                           |
|          ++----------+-----------+-----------+-----------+-----------+
|Prev State||Register- | Could     | Could     | Register- | RP changed|
|          ||Stop Timer| Register  | Register  | Stop      |           |
|          ||expires   | -&gt;True    | -&gt;False   | received  |           |
+----------++----------+-----------+-----------+-----------+-----------+
|NoInfo    ||-         | -&gt; J state| -         | -         | -         |
|(NI)      ||          | add reg   |           |           |           |
|          ||          | tunnel    |           |           |           |
+----------++----------+-----------+-----------+-----------+-----------+
|          ||-         | -         | -&gt; NI     | -&gt; P state| -&gt; J state|
|          ||          |           | state     |           |           |
|          ||          |           | remove reg| remove reg| update reg|
|Join (J)  ||          |           | tunnel    | tunnel;   | tunnel    |
|          ||          |           |           | set       |           |
|          ||          |           |           | Register- |           |
|          ||          |           |           | Stop      |           |
|          ||          |           |           | Timer(*)  |           |
+----------++----------+-----------+-----------+-----------+-----------+
|          ||-&gt; J state| -         | -&gt; NI     | -&gt; P state| -&gt; J state|
|          ||          |           | state     |           |           |
|Join-     ||add reg   |           |           | set       | add reg   |
|Pending   ||tunnel    |           |           | Register- | tunnel;   |
|(JP)      ||          |           |           | Stop      | cancel    |
|          ||          |           |           | Timer(*)  | Register- |
|          ||          |           |           |           | Stop Timer|
+----------++----------+-----------+-----------+-----------+-----------+
|          ||-&gt; JP     | -         | -&gt; NI     | -         | -&gt; J state|
|          ||state     |           | state     |           |           |
|          ||set       |           |           |           | add reg   |
|Prune (P) ||Register- |           |           |           | tunnel;   |
|          ||Stop      |           |           |           | cancel    |
|          ||Timer(**);|           |           |           | Register- |
|          ||send Null-|           |           |           | Stop Timer|
|          ||Register  |           |           |           |           |
+----------++----------+-----------+-----------+-----------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
笔记：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*) The Register-Stop Timer is set to a random value chosen uniformly from the interval ( 0.5 * Register_Suppression_Time, 1.5 * Register_Suppression_Time) minus Register_Probe_Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*）寄存器停止计时器设置为从间隔（0.5*寄存器抑制时间，1.5*寄存器抑制时间）减去寄存器探测时间中均匀选择的随机值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Subtracting off Register_Probe_Time is a bit unnecessary because it is really small compared to Register_Suppression_Time, but this was in the old spec and is kept for compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
减去寄存器外的探测时间有点不必要，因为它与寄存器抑制时间相比确实很小，但这是在旧规范中，为了兼容性而保留。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(**) The Register-Stop Timer is set to Register_Probe_Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（**）寄存器停止计时器设置为寄存器探测时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following three actions are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义了以下三个操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Add Register Tunnel
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
添加寄存器通道
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A Register-Tunnel virtual interface, VI, is created (if it doesn&#39;t already exist) with its encapsulation target being RP(G). DownstreamJPState(S,G,VI) is set to Join state, causing the tunnel interface to be added to immediate_olist(S,G) and inherited_olist(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
创建了一个寄存器通道虚拟接口VI（如果它还不存在），其封装目标为RP（G）。下游状态（S，G，VI）设置为连接状态，导致隧道接口添加到直接列表（S，G）和继承列表（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Remove Register Tunnel
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
移除寄存器通道
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
VI is the Register-Tunnel virtual interface with encapsulation target of RP(G). DownstreamJPState(S,G,VI) is set to NoInfo state, causing the tunnel interface to be removed from immediate_olist(S,G) and inherited_olist(S,G). If DownstreamJPState(S,G,VI) is NoInfo for all (S,G), then VI can be deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
VI是寄存器隧道虚拟接口，封装目标为RP（G）。下游PSTATE（S，G，VI）设置为NoInfo状态，导致隧道接口从直接实体（S，G）和继承实体（S，G）中移除。如果所有（S，G）的下游Pstate（S，G，VI）均为NoInfo，则可以删除VI。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Update Register Tunnel
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新寄存器通道
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This action occurs when RP(G) changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
当RP（G）发生变化时，会发生此动作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
VI_old is the Register-Tunnel virtual interface with encapsulation target old_RP(G). A Register-Tunnel virtual interface, VI_new, is created (if it doesn&#39;t already exist) with its encapsulation target being new_RP(G). DownstreamJPState(S,G,VI_old) is set to NoInfo state and DownstreamJPState(S,G,VI_new) is set to Join state. If DownstreamJPState(S,G,VI_old) is NoInfo for all (S,G), then VI_old can be deleted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
VI_old是具有封装目标old_RP（G）的寄存器隧道虚拟接口。创建了一个寄存器通道虚拟接口VI_new（如果它还不存在），其封装目标为new_RP（G）。下游PSTATE（S、G、VI_旧）设置为NoInfo状态，而下游PSTATE（S、G、VI_新）设置为Join状态。如果所有（S，G）的下游状态（S，G，VI_old）均为NoInfo，则可以删除VI_old。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that we cannot simply change the encapsulation target of VI_old because not all groups using that encapsulation tunnel will have moved to the same new RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
请注意，我们不能简单地更改VI_old的封装目标，因为并非所有使用该封装隧道的组都将移动到相同的新RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CouldRegister(S,G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可注册（S，G）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The macro &#34;CouldRegister&#34; in the state machine is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
状态机中的宏“CouldRegister”定义为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      bool CouldRegister(S,G) {
         return ( I_am_DR( RPF_interface(S) ) AND
                  KeepaliveTimer(S,G) is running AND
                  DirectlyConnected(S) == TRUE )
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      bool CouldRegister(S,G) {
         return ( I_am_DR( RPF_interface(S) ) AND
                  KeepaliveTimer(S,G) is running AND
                  DirectlyConnected(S) == TRUE )
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that on reception of a packet at the DR from a directly connected source, KeepaliveTimer(S,G) needs to be set by the packet forwarding rules before computing CouldRegister(S,G) in the register state machine, or the first packet from a source won&#39;t be registered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
请注意，在DR接收到来自直接连接源的数据包时，在寄存器状态机中计算CouldRegister（S，G）之前，需要通过数据包转发规则设置KeepaliveTimer（S，G），否则将不会注册来自源的第一个数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encapsulating Data Packets in the Register Tunnel
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在寄存器通道中封装数据包
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Conceptually, the Register Tunnel is an interface with a smaller MTU than the underlying IP interface towards the RP. IP fragmentation on packets forwarded on the Register Tunnel is performed based upon this smaller MTU. The encapsulating DR may perform Path MTU Discovery to the RP to determine the effective MTU of the tunnel. Fragmentation for the smaller MTU should take both the outer IP header and the PIM register header overhead into account. If a multicast packet is fragmented on the way into the Register Tunnel, each fragment is encapsulated individually so it contains IP, PIM, and inner IP headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
从概念上讲，寄存器隧道是一个接口，其MTU小于朝向RP的底层IP接口。在寄存器隧道上转发的数据包上的IP碎片是基于这个较小的MTU执行的。封装DR可以执行到RP的路径MTU发现，以确定隧道的有效MTU。较小MTU的分段应同时考虑外部IP报头和PIM寄存器报头开销。如果一个多播数据包在进入注册通道的过程中被分段，那么每个分段都被单独封装，因此它包含IP、PIM和内部IP头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In IPv6, the DR MUST perform Path MTU discovery, and an ICMP Packet Too Big message MUST be sent by the encapsulating DR if it receives a packet that will not fit in the effective MTU of the tunnel. If the MTU between the DR and the RP results in the effective tunnel MTU being smaller than 1280 (the IPv6 minimum MTU), the DR MUST send Fragmentation Required messages with an MTU value of 1280 and MUST fragment its PIM register messages as required, using an IPv6 fragmentation header between the outer IPv6 header and the PIM Register header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在IPv6中，DR必须执行路径MTU发现，如果封装DR接收到不适合隧道有效MTU的数据包，则必须发送ICMP数据包过大消息。如果DR和RP之间的MTU导致有效隧道MTU小于1280（IPv6最小MTU），DR必须发送MTU值为1280的碎片要求消息，并且必须根据需要使用外部IPv6标头和PIM寄存器标头之间的IPv6碎片标头对其PIM寄存器消息进行碎片化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The TTL of a forwarded data packet is decremented before it is encapsulated in the Register Tunnel. The encapsulating packet uses the normal TTL that the router would use for any locally-generated IP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
转发数据包的TTL在被封装到寄存器隧道中之前被递减。封装包使用路由器将用于任何本地生成的IP包的正常TTL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The IP ECN bits should be copied from the original packet to the IP header of the encapsulating packet. They SHOULD NOT be set independently by the encapsulating router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
IP ECN位应从原始数据包复制到封装数据包的IP报头。它们不应由封装路由器独立设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The Diffserv Code Point (DSCP) should be copied from the original packet to the IP header of the encapsulating packet. It MAY be set independently by the encapsulating router, based upon static configuration or traffic classification. See [12] for more discussion on setting the DSCP on tunnels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
区分服务代码点（DSCP）应从原始数据包复制到封装数据包的IP报头。它可以由封装路由器根据静态配置或流量分类独立设置。有关在隧道上设置DSCP的更多讨论，请参见[12]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Handling Register-Stop(*,G) Messages at the DR
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在DR处处理寄存器停止（*，G）消息
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An old RP might send a Register-Stop message with the source address set to all zeros. This was the normal course of action in RFC 2362 when the Register message matched against (*,G) state at the RP, and it was defined as meaning &#34;stop encapsulating all sources for this group&#34;. However, the behavior of such a Register-Stop(*,G) is ambiguous or incorrect in some circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旧RP可能发送源地址设置为全零的寄存器停止消息。这是RFC 2362中的正常操作过程，当寄存器消息与RP处的（*，G）状态匹配时，它被定义为“停止封装该组的所有源”。然而，这种寄存器停止（*，G）的行为在某些情况下是不明确或不正确的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
We specify that an RP should not send Register-Stop(*,G) messages, but for compatibility, a DR should be able to accept one if it is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
我们指定RP不应该发送寄存器停止（*，G）消息，但为了兼容性，DR应该能够在收到消息时接受它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A Register-Stop(*,G) should be treated as a Register-Stop(S,G) for all (S,G) Register state machines that are not in the NoInfo state. A router should not apply a Register-Stop(*,G) to sources that become active after the Register-Stop(*,G) was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
对于所有不处于NoInfo状态的（S，G）寄存器状态机，寄存器停止（*，G）应视为寄存器停止（S，G）。路由器不应将寄存器停止（*，G）应用于接收到寄存器停止（*，G）后变为活动的源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. Receiving Register Messages at the RP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. 在RP接收注册信息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an RP receives a Register message, the course of action is decided according to the following pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当RP收到注册信息时，根据以下伪代码决定操作过程：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   packet_arrives_on_rp_tunnel( pkt ) {
       if( outer.dst is not one of my addresses ) {
           drop the packet silently.
           # Note: this may be a spoofing attempt
       }
       if( I_am_RP(G) AND outer.dst == RP(G) ) {
             sentRegisterStop = FALSE;
             if ( register.borderbit == TRUE ) {
                  if ( PMBR(S,G) == unknown ) {
                       PMBR(S,G) = outer.src
                  } else if ( outer.src != PMBR(S,G) ) {
                       send Register-Stop(S,G) to outer.src
                       drop the packet silently.
                  }
             }
             if ( SPTbit(S,G) OR
              ( SwitchToSptDesired(S,G) AND
                ( inherited_olist(S,G) == NULL ))) {
               send Register-Stop(S,G) to outer.src
               sentRegisterStop = TRUE;
             }
             if ( SPTbit(S,G) OR SwitchToSptDesired(S,G) ) {
                  if ( sentRegisterStop == TRUE ) {
                       set KeepaliveTimer(S,G) to RP_Keepalive_Period;
                  } else {
                       set KeepaliveTimer(S,G) to Keepalive_Period;
                  }
             }
             if( !SPTbit(S,G) AND ! pkt.NullRegisterBit ) {
                  decapsulate and forward the inner packet to
                  inherited_olist(S,G,rpt) # Note (+)
             }
       } else {
           send Register-Stop(S,G) to outer.src
           # Note (*)
       }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   packet_arrives_on_rp_tunnel( pkt ) {
       if( outer.dst is not one of my addresses ) {
           drop the packet silently.
           # Note: this may be a spoofing attempt
       }
       if( I_am_RP(G) AND outer.dst == RP(G) ) {
             sentRegisterStop = FALSE;
             if ( register.borderbit == TRUE ) {
                  if ( PMBR(S,G) == unknown ) {
                       PMBR(S,G) = outer.src
                  } else if ( outer.src != PMBR(S,G) ) {
                       send Register-Stop(S,G) to outer.src
                       drop the packet silently.
                  }
             }
             if ( SPTbit(S,G) OR
              ( SwitchToSptDesired(S,G) AND
                ( inherited_olist(S,G) == NULL ))) {
               send Register-Stop(S,G) to outer.src
               sentRegisterStop = TRUE;
             }
             if ( SPTbit(S,G) OR SwitchToSptDesired(S,G) ) {
                  if ( sentRegisterStop == TRUE ) {
                       set KeepaliveTimer(S,G) to RP_Keepalive_Period;
                  } else {
                       set KeepaliveTimer(S,G) to Keepalive_Period;
                  }
             }
             if( !SPTbit(S,G) AND ! pkt.NullRegisterBit ) {
                  decapsulate and forward the inner packet to
                  inherited_olist(S,G,rpt) # Note (+)
             }
       } else {
           send Register-Stop(S,G) to outer.src
           # Note (*)
       }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
outer.dst is the IP destination address of the encapsulating header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
outer.dst是封装头的IP目标地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
outer.src is the IP source address of the encapsulating header, i.e., the DR&#39;s address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
outer.src是封装头的IP源地址，即DR的地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I_am_RP(G) is true if the group-to-RP mapping indicates that this router is the RP for the group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果组到RP的映射表明此路由器是该组的RP，则I_am_RP（G）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note (*): This may block traffic from S for Register_Suppression_Time if the DR learned about a new group-to-RP mapping before the RP did. However, this doesn&#39;t matter unless we figure out some way for the RP also to accept (*,G) joins when it doesn&#39;t yet realize that it is about to become the RP for G. This will all get sorted out once the RP learns the new group-to-rp mapping. We decided to do nothing about this and just accept the fact that PIM may suffer interrupted (*,G) connectivity following an RP change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注（*）：如果DR在RP之前了解到一个新的组到RP映射，这可能会在寄存器\u抑制\u时间内阻止来自S的通信。然而，这并不重要，除非我们找到一些方法让RP在还没有意识到它即将成为G的RP时也接受（*，G）连接。一旦RP学习到新的组到RP映射，这一切都会得到解决。我们决定对此不采取任何措施，只接受这样一个事实，即RP变更后PIM可能会中断（*，G）连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note (+): Implementations are advised not to make this a special case, but to arrange that this path rejoin the normal packet forwarding path. All of the appropriate actions from the &#34;On receipt of data from S to G on interface iif&#34; pseudocode in Section 4.2 should be performed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意（+）：建议实现不要将此作为特殊情况，而是安排此路径重新加入正常的数据包转发路径。应执行第4.2节中“在接口iif上从S到G接收数据”伪代码中的所有适当操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
KeepaliveTimer(S,G) is restarted at the RP when packets arrive on the proper tunnel interface and the RP desires to switch to the SPT or the SPTbit is already set. This may cause the upstream (S,G) state machine to trigger a join if the inherited_olist(S,G) is not NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当数据包到达正确的隧道接口并且RP希望切换到SPT或SPTbit已经设置时，KeepaliveTimer（S，G）在RP处重新启动。这可能会导致上游（S，G）状态机在继承的列表（S，G）不为空时触发联接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RP should preserve (S,G) state that was created in response to a Register message for at least ( 3 * Register_Suppression_Time ); otherwise, the RP may stop joining (S,G) before the DR for S has restarted sending registers. Traffic would then be interrupted until the Register-Stop Timer expires at the DR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在至少3个时间u*S中创建了一个RP-to-response-to-response-to-response-to-response-to-response-to-response-to-in-Time-in-response-in-in-in-in-in-in-in-in-in-in-in-；否则，RP可能在DR for S重新启动发送寄存器之前停止加入（S，G）。然后，流量将被中断，直到DR的寄存器停止计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, at the RP, KeepaliveTimer(S,G) should be restarted to ( 3 * Register_Suppression_Time + Register_Probe_Time ).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，在RP时，KeepaliveTimer（S，G）应该重新启动到（3*寄存器\抑制\时间+寄存器\探测\时间）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When forwarding a packet from the Register Tunnel, the TTL of the original data packet is decremented after it is decapsulated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当从寄存器隧道转发数据包时，原始数据包的TTL在解除封装后减小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IP ECN bits should be copied from the IP header of the Register packet to the decapsulated packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP ECN位应从寄存器数据包的IP报头复制到解除封装的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Diffserv Code Point (DSCP) should be copied from the IP header of the Register packet to the decapsulated packet. The RP MAY retain the DSCP of the inner packet or re-classify the packet and apply a different DSCP. Scenarios where each of these might be useful are discussed in [12].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
区分服务代码点（DSCP）应从寄存器数据包的IP报头复制到解除封装的数据包。RP可以保留内部分组的DSCP，或者重新分类分组并应用不同的DSCP。[12]中讨论了其中每种可能有用的场景。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. PIM Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. PIM加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM Join/Prune message consists of a list of groups and a list of Joined and Pruned sources for each group. When processing a received Join/Prune message, each Joined or Pruned source for a Group is effectively considered individually, and applies to one or more of the following state machines. When considering a Join/Prune message whose Upstream Neighbor Address field addresses this router, (*,G) Joins and Prunes can affect both the (*,G) and (S,G,rpt) downstream state machines, while (*,*,RP), (S,G), and (S,G,rpt) Joins and Prunes can only affect their respective downstream state machines. When considering a Join/Prune message whose Upstream Neighbor Address field addresses another router, most Join or Prune messages could affect each upstream state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM加入/删减消息由组列表以及每个组的已加入和删减源列表组成。在处理收到的加入/删减消息时，组的每个加入或删减的源都被有效地单独考虑，并应用于以下一个或多个状态机。当考虑其上游邻居地址字段寻址此路由器的加入/删减消息时，（*，G）加入和删减可影响（*，G）和（S，G，rpt）下游状态机，而（*，*，RP），（S，G）和（S，G，rpt）加入和删减只能影响其各自的下游状态机。当考虑其上游邻居地址字段寻址另一路由器的加入/删减消息时，大多数加入或删减消息可能会影响每个上游状态机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, a PIM Join/Prune message should only be accepted for processing if it comes from a known PIM neighbor. A PIM router hears about PIM neighbors through PIM Hello messages. If a router receives a Join/Prune message from a particular IP source address and it has not seen a PIM Hello message from that source address, then the Join/Prune message SHOULD be discarded without further processing. In addition, if the Hello message from a neighbor was authenticated using IPsec AH (see Section 6.3), then all Join/Prune messages from that neighbor MUST also be authenticated using IPsec AH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常，只有来自已知PIM邻居的PIM加入/删减消息才应被接受处理。PIM路由器通过PIM Hello消息听到PIM邻居的消息。如果路由器接收到来自特定IP源地址的加入/删减消息，但没有看到来自该源地址的PIM Hello消息，则应丢弃该加入/删减消息，无需进一步处理。此外，如果使用IPsec AH对来自邻居的Hello消息进行了身份验证（请参见第6.3节），则来自该邻居的所有加入/删除消息也必须使用IPsec AH进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that some older PIM implementations incorrectly fail to send Hello messages on point-to-point interfaces, so we also RECOMMEND that a configuration option be provided to allow interoperation with such older routers, but that this configuration option SHOULD NOT be enabled by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们注意到，一些较旧的PIM实现错误地无法在点到点接口上发送Hello消息，因此我们还建议提供一个配置选项，以允许与此类较旧的路由器进行互操作，但默认情况下不应启用此配置选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. Receiving (*,*,RP) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. 接收（*，*，RP）加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The per-interface state machine for receiving (*,*,RP) Join/Prune Messages is given below. There are three states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面给出了用于接收（*，*，RP）连接/删除消息的每个接口状态机。有三个州：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo (NI) The interface has no (*,*,RP) Join state and no timers running.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo（NI）接口没有（*，*，RP）连接状态，也没有运行计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join (J) The interface has (*,*,RP) Join state, which will cause the router to forward packets destined for any group handled by RP from this interface except if there is also (S,G,rpt) prune information (see Section 4.5.4) or the router lost an assert on this interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join（J）接口具有（*，*，RP）连接状态，这将导致路由器从该接口转发发送给RP处理的任何组的数据包，除非还有（S，G，rpt）删减信息（参见第4.5.4节）或路由器在该接口上丢失断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending (PP) The router has received a Prune(*,*,RP) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the Join state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪挂起（PP）路由器已从下游邻居收到此接口上的修剪（*，*，RP），并等待查看修剪是否将被另一个下游路由器覆盖。出于转发目的，Prune挂起状态的功能与Join状态完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the state machine uses two timers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，状态机使用两个计时器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ExpiryTimer (ET) This timer is restarted when a valid Join(*,*,RP) is received. Expiry of the ExpiryTimer causes the interface state to revert to NoInfo for this RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
ExpiryTimer（ET）当接收到有效的联接（*，*，RP）时，此计时器将重新启动。ExpiryTimer的过期将导致此RP的接口状态恢复为NoInfo。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer (PPT) This timer is set when a valid Prune(*,*,RP) is received. Expiry of the Prune-Pending Timer causes the interface state to revert to NoInfo for this RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪挂起计时器（PPT）此计时器在收到有效的修剪（*，*，RP）时设置。修剪挂起计时器的到期将导致此RP的接口状态恢复为NoInfo。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Figure 2: Downstream per-interface (*,*,RP) state machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
图2：表格形式的每个接口（*，*，RP）下游状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                          Event                         |
|            ++-------------+-------------+--------------+-------------+
|Prev State  ||Receive      | Receive     | Prune-       | Expiry Timer|
|            ||Join(*,*,RP) | Prune       | Pending      | Expires     |
|            ||             | (*,*,RP)    | Timer        |             |
|            ||             |             | Expires      |             |
+------------++-------------+-------------+--------------+-------------+
|            ||-&gt; J state   | -&gt; NI state | -            | -           |
|NoInfo (NI) ||start Expiry |             |              |             |
|            ||Timer        |             |              |             |
+------------++-------------+-------------+--------------+-------------+
|            ||-&gt; J state   | -&gt; PP state | -            | -&gt; NI state |
|Join (J)    ||restart      | start Prune-|              |             |
|            ||Expiry Timer | Pending     |              |             |
|            ||             | Timer       |              |             |
+------------++-------------+-------------+--------------+-------------+
|Prune-      ||-&gt; J state   | -&gt; PP state | -&gt; NI state  | -&gt; NI state |
|Pending (PP)||restart      |             | Send Prune-  |             |
|            ||Expiry Timer |             | Echo(*,*,RP) |             |
+------------++-------------+-------------+--------------+-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                          Event                         |
|            ++-------------+-------------+--------------+-------------+
|Prev State  ||Receive      | Receive     | Prune-       | Expiry Timer|
|            ||Join(*,*,RP) | Prune       | Pending      | Expires     |
|            ||             | (*,*,RP)    | Timer        |             |
|            ||             |             | Expires      |             |
+------------++-------------+-------------+--------------+-------------+
|            ||-&gt; J state   | -&gt; NI state | -            | -           |
|NoInfo (NI) ||start Expiry |             |              |             |
|            ||Timer        |             |              |             |
+------------++-------------+-------------+--------------+-------------+
|            ||-&gt; J state   | -&gt; PP state | -            | -&gt; NI state |
|Join (J)    ||restart      | start Prune-|              |             |
|            ||Expiry Timer | Pending     |              |             |
|            ||             | Timer       |              |             |
+------------++-------------+-------------+--------------+-------------+
|Prune-      ||-&gt; J state   | -&gt; PP state | -&gt; NI state  | -&gt; NI state |
|Pending (PP)||restart      |             | Send Prune-  |             |
|            ||Expiry Timer |             | Echo(*,*,RP) |             |
+------------++-------------+-------------+--------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition events &#34;Receive Join(*,*,RP)&#34; and &#34;Receive Prune(*,*,RP)&#34; imply receiving a Join or Prune targeted to this router&#39;s primary IP address on the received interface. If the upstream neighbor address field is not correct, these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转换事件“Receive Join（*，*，RP）”和“Receive Prune（*，*，RP）”意味着在接收到的接口上接收针对该路由器主IP地址的连接或修剪。如果上游邻居地址字段不正确，则此状态机中的这些状态转换不得发生，尽管看到这样的数据包可能会导致其他状态机中的状态转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On unnumbered interfaces on point-to-point links, the router&#39;s address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to-point links we also recommend that for backwards compatibility PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在点到点链路上的未编号接口上，路由器的地址应与它为通过该接口发送的Hello消息选择的源地址相同。然而，在点到点链路上，我们还建议，为了向后兼容，也接受上游邻居地址字段为全零的PIM Join/Prune消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NoInfo State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从NoInfo状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in NoInfo state, the following event may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于NoInfo状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,*,RP) A Join(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，*，RP）在接口I上接收连接（*，*，RP），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,*,RP) downstream state machine on interface I transitions to the Join state. The Expiry Timer (ET) is started and set to the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，*，RP）下游状态机转换为连接状态。到期计时器（ET）启动，并从触发加入/删除消息设置为保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Note that it is possible to receive a Join(*,*,RP) message for an RP for which we do not have information telling us that it is an RP. In the case of (*,*,RP) state, so long as we have a route to the RP, this will not cause a problem, and the transition should still take place.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
请注意，可能会收到RP的联接（*，*，RP）消息，但我们没有信息告诉我们该RP是RP。在（*，*，RP）状态的情况下，只要我们有到RP的路由，这将不会导致问题，并且仍应进行转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Join State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Join state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处于连接状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,*,RP) A Join(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，*，RP）在接口I上接收连接（*，*，RP），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,*,RP) downstream state machine on interface I remains in Join state, and the Expiry Timer (ET) is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，*，RP）下游状态机保持连接状态，到期计时器（ET）重新启动，设置为其当前值和触发连接/删除消息的保持时间的最大值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(*,*,RP) A Prune(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（*，*，RP）在接口I上接收修剪（*，*，RP），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,*,RP) downstream state machine on interface I transitions to the Prune-Pending state. The Prune-Pending Timer is started. It is set to the J/P_Override_Interval(I) if the router has more than one neighbor on that interface; otherwise, it is set to zero, causing it to expire immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，*，RP）下游状态机转换为Prune挂起状态。修剪挂起计时器已启动。如果路由器在该接口上有多个邻居，则设置为J/P_覆盖_间隔（I）；否则，它将设置为零，导致它立即过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires The Expiry Timer for the (*,*,RP) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器过期接口I上（*，*，RP）下游状态机的到期计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,*,RP) downstream state machine on interface I transitions to the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，*，RP）下游状态机转换为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Prune-Pending State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从修剪挂起状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Prune-Pending state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处于修剪挂起状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,*,RP) A Join(*,*,RP) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，*，RP）在接口I上接收连接（*，*，RP），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,*,RP) downstream state machine on interface I transitions to the Join state. The Prune-Pending Timer is canceled (without triggering an expiry event). The Expiry Timer is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，*，RP）下游状态机转换为连接状态。删除挂起计时器被取消（不会触发到期事件）。过期计时器将重新启动，并设置为其当前值的最大值和触发加入/删除消息的保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires The Expiry Timer for the (*,*,RP) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器过期接口I上（*，*，RP）下游状态机的到期计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,*,RP) downstream state machine on interface I transitions to the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，*，RP）下游状态机转换为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer Expires The Prune-Pending Timer for the (*,*,RP) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Pending Timer Expires接口I上的（*，*，RP）下游状态机的Prune Pending Timer过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,*,RP) downstream state machine on interface I transitions to the NoInfo state. A PruneEcho(*,*,RP) is sent onto the subnet connected to interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，*，RP）下游状态机转换为NoInfo状态。Prueecho（*，*，RP）被发送到连接到接口I的子网。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The action &#34;Send PruneEcho(*,*,RP)&#34; is triggered when the router stops forwarding on an interface as a result of a prune. A PruneEcho(*,*,RP) is simply a Prune(*,*,RP) message sent by the upstream router on a LAN with its own address in the Upstream Neighbor Address field. Its purpose is to add additional reliability so that if a Prune that should have been overridden by another router is lost locally on the LAN, then the PruneEcho may be received and cause the override to happen. A PruneEcho(*,*,RP) need not be sent on an interface that contains only a single PIM neighbor during the time this state machine was in Prune-Pending state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
当路由器由于修剪而停止在接口上的转发时，将触发“发送prueecho（*，*，RP）”操作。PruneEcho（*，*，RP）只是由LAN上的上游路由器发送的一条Prune（*，*，RP）消息，其自身地址位于上游邻居地址字段中。它的目的是增加额外的可靠性，以便如果本应由另一路由器覆盖的修剪在LAN上本地丢失，则可能会接收到该修剪并导致发生覆盖。在状态机处于Prune Pending状态期间，不需要在仅包含单个PIM邻居的接口上发送PruneEcho（*，*，RP）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. Receiving (*,G) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. 接收（*，G）加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a router receives a Join(*,G), it must first check to see whether the RP in the message matches RP(G) (the router&#39;s idea of who the RP is). If the RP in the message does not match RP(G), the Join(*,G) should be silently dropped. (Note that other source list entries, such as (S,G,rpt) or (S,G), in the same Group-Specific Set should still be processed.) If a router has no RP information (e.g., has not recently received a BSR message), then it may choose to accept Join(*,G) and treat the RP in the message as RP(G). Received Prune(*,G) messages are processed even if the RP in the message does not match RP(G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器收到连接（*，G）时，它必须首先检查消息中的RP是否匹配RP（G）（路由器对RP是谁的想法）。如果消息中的RP与RP（G）不匹配，则应该无声地删除联接（*，G）。（注意，同一组特定集合中的其他源列表条目，例如（S，G，rpt）或（S，G），仍应进行处理。）如果路由器没有RP信息（例如，最近没有收到BSR消息），则它可以选择接受联接（*，G），并将消息中的RP视为RP（G）。即使消息中的RP与RP（G）不匹配，也会处理收到的Prune（*，G）消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The per-interface state machine for receiving (*,G) Join/Prune Messages is given below. There are three states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面给出了用于接收（*，G）连接/删除消息的每个接口状态机。有三个州：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo (NI) The interface has no (*,G) Join state and no timers running.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo（NI）接口没有（*，G）连接状态，也没有运行计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join (J) The interface has (*,G) Join state, which will cause the router to forward packets destined for G from this interface except if there is also (S,G,rpt) prune information (see Section 4.5.4) or the router lost an assert on this interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join（J）接口具有（*，G）Join状态，这将导致路由器从该接口转发以G为目的地的数据包，除非还有（S，G，rpt）删减信息（参见第4.5.4节）或路由器在该接口上丢失断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending (PP) The router has received a Prune(*,G) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the Join state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Pending（PP）路由器已从下游邻居收到此接口上的Prune（*，G），并等待查看该Prune是否将被另一个下游路由器覆盖。出于转发目的，Prune挂起状态的功能与Join状态完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the state machine uses two timers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，状态机使用两个计时器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer (ET) This timer is restarted when a valid Join(*,G) is received. Expiry of the Expiry Timer causes the interface state to revert to NoInfo for this group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器（ET）当接收到有效的联接（*，G）时，此计时器将重新启动。到期计时器的到期将导致此组的接口状态恢复为NoInfo。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer (PPT) This timer is set when a valid Prune(*,G) is received. Expiry of the Prune-Pending Timer causes the interface state to revert to NoInfo for this group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪挂起计时器（PPT）此计时器在收到有效的修剪（*，G）时设置。修剪挂起计时器的到期将导致此组的接口状态恢复为NoInfo。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Figure 3: Downstream per-interface (*,G) state machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
图3：下游每个接口（*，G）表格形式的状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                         Event                          |
|            ++-------------+--------------+-------------+-------------+
|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|
|            ||Join(*,G)    | Prune(*,G)   | Pending     | Expires     |
|            ||             |              | Timer       |             |
|            ||             |              | Expires     |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; NI state  | -           | -           |
|NoInfo (NI) ||start Expiry |              |             |             |
|            ||Timer        |              |             |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; PP state  | -           | -&gt; NI state |
|Join (J)    ||restart      | start Prune- |             |             |
|            ||Expiry Timer | Pending      |             |             |
|            ||             | Timer        |             |             |
+------------++-------------+--------------+-------------+-------------+
|Prune-      ||-&gt; J state   | -&gt; PP state  | -&gt; NI state | -&gt; NI state |
|Pending (PP)||restart      |              | Send Prune- |             |
|            ||Expiry Timer |              | Echo(*,G)   |             |
+------------++-------------+--------------+-------------+-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                         Event                          |
|            ++-------------+--------------+-------------+-------------+
|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|
|            ||Join(*,G)    | Prune(*,G)   | Pending     | Expires     |
|            ||             |              | Timer       |             |
|            ||             |              | Expires     |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; NI state  | -           | -           |
|NoInfo (NI) ||start Expiry |              |             |             |
|            ||Timer        |              |             |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; PP state  | -           | -&gt; NI state |
|Join (J)    ||restart      | start Prune- |             |             |
|            ||Expiry Timer | Pending      |             |             |
|            ||             | Timer        |             |             |
+------------++-------------+--------------+-------------+-------------+
|Prune-      ||-&gt; J state   | -&gt; PP state  | -&gt; NI state | -&gt; NI state |
|Pending (PP)||restart      |              | Send Prune- |             |
|            ||Expiry Timer |              | Echo(*,G)   |             |
+------------++-------------+--------------+-------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition events &#34;Receive Join(*,G)&#34; and &#34;Receive Prune(*,G)&#34; imply receiving a Join or Prune targeted to this router&#39;s primary IP address on the received interface. If the upstream neighbor address field is not correct, these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转换事件“Receive Join（*，G）”和“Receive Prune（*，G）”意味着在接收到的接口上接收针对该路由器的主IP地址的连接或删除。如果上游邻居地址字段不正确，则此状态机中的这些状态转换不得发生，尽管看到这样的数据包可能会导致其他状态机中的状态转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On unnumbered interfaces on point-to-point links, the router&#39;s address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to-
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在点到点链路上的未编号接口上，路由器的地址应与它为通过该接口发送的Hello消息选择的源地址相同。然而，在这一点上-
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
point links we also recommend that for backwards compatibility PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
点链接为了向后兼容，我们还建议接受上游邻居地址字段为全零的PIM加入/删减消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NoInfo State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从NoInfo状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in NoInfo state, the following event may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于NoInfo状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，G）在接口I上接收连接（*，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,G) downstream state machine on interface I transitions to the Join state. The Expiry Timer (ET) is started and set to the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，G）下游状态机转换为连接状态。到期计时器（ET）启动，并从触发加入/删除消息设置为保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Join State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Join state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处于连接状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，G）在接口I上接收连接（*，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,G) downstream state machine on interface I remains in Join state, and the Expiry Timer (ET) is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，G）下游状态机保持连接状态，过期计时器（ET）重新启动，设置为其当前值和触发连接/删除消息的保持时间的最大值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(*,G) A Prune(*,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（*，G）在接口I上接收修剪（*，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,G) downstream state machine on interface I transitions to the Prune-Pending state. The Prune-Pending Timer is started. It is set to the J/P_Override_Interval(I) if the router has more than one neighbor on that interface; otherwise, it is set to zero, causing it to expire immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，G）下游状态机转换为Prune挂起状态。修剪挂起计时器已启动。如果路由器在该接口上有多个邻居，则设置为J/P_覆盖_间隔（I）；否则，它将设置为零，导致它立即过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires The Expiry Timer for the (*,G) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器过期接口I上（*，G）下游状态机的到期计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,G) downstream state machine on interface I transitions to the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，G）下游状态机转换为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Prune-Pending State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从修剪挂起状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Prune-Pending state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处于修剪挂起状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，G）在接口I上接收连接（*，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,G) downstream state machine on interface I transitions to the Join state. The Prune-Pending Timer is canceled (without triggering an expiry event). The Expiry Timer is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，G）下游状态机转换为连接状态。删除挂起计时器被取消（不会触发到期事件）。过期计时器将重新启动，并设置为其当前值的最大值和触发加入/删除消息的保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires The Expiry Timer for the (*,G) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器过期接口I上（*，G）下游状态机的到期计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,G) downstream state machine on interface I transitions to the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，G）下游状态机转换为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer Expires The Prune-Pending Timer for the (*,G) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Pending Timer Expires接口I上（*，G）下游状态机的Prune Pending Timer过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (*,G) downstream state machine on interface I transitions to the NoInfo state. A PruneEcho(*,G) is sent onto the subnet connected to interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（*，G）下游状态机转换为NoInfo状态。Prueecho（*，G）被发送到连接到接口I的子网。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The action &#34;Send PruneEcho(*,G)&#34; is triggered when the router stops forwarding on an interface as a result of a prune. A PruneEcho(*,G) is simply a Prune(*,G) message sent by the upstream router on a LAN with its own address in the Upstream Neighbor Address field. Its purpose is to add additional reliability so that if a Prune that should have been overridden by another router is lost locally on the LAN, then the PruneEcho may be received and cause the override to happen. A PruneEcho(*,G) need not be sent on an interface that contains only a single PIM neighbor during the time this state machine was in Prune-Pending state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
当路由器由于修剪而停止在接口上的转发时，将触发操作“发送prueecho（*，G）”。PruneEcho（*，G）只是由LAN上的上游路由器发送的Prune（*，G）消息，其自身地址位于上游邻居地址字段中。它的目的是增加额外的可靠性，以便如果本应由另一路由器覆盖的修剪在LAN上本地丢失，则可能会接收到该修剪并导致发生覆盖。在状态机处于Prune挂起状态期间，不需要在仅包含单个PIM邻居的接口上发送prueecho（*，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.3. Receiving (S,G) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.3. 接收（S，G）加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The per-interface state machine for receiving (S,G) Join/Prune messages is given below and is almost identical to that for (*,G) messages. There are three states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面给出了用于接收（S，G）连接/删除消息的每个接口状态机，它与（*，G）消息的状态机几乎相同。有三个州：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo (NI) The interface has no (S,G) Join state and no (S,G) timers running.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo（NI）接口没有（S，G）连接状态，也没有（S，G）计时器在运行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join (J) The interface has (S,G) Join state, which will cause the router to forward packets from S destined for G from this interface if the (S,G) state is active (the SPTbit is set) except if the router lost an assert on this interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join（J）接口具有（S，G）Join状态，如果（S，G）状态处于活动状态（设置了SPTbit），则该状态将导致路由器从该接口转发来自S、目的地为G的数据包，除非路由器在该接口上丢失了断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending (PP) The router has received a Prune(S,G) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the Join state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Pending（PP）路由器已从下游邻居收到此接口上的Prune（S，G），并等待查看该Prune是否将被另一个下游路由器覆盖。出于转发目的，Prune挂起状态的功能与Join状态完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there are two timers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有两个计时器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer (ET) This timer is set when a valid Join(S,G) is received. Expiry of the Expiry Timer causes this state machine to revert to NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器（ET）当接收到有效的连接（S，G）时设置此计时器。到期计时器的到期导致此状态机恢复为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer (PPT) This timer is set when a valid Prune(S,G) is received. Expiry of the Prune-Pending Timer causes this state machine to revert to NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪挂起计时器（PPT）此计时器在收到有效修剪（S，G）时设置。修剪挂起计时器的到期将导致此状态机恢复为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Figure 4: Downstream per-interface (S,G) state machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
图4：表格形式的每个接口（S，G）状态机的下游
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                         Event                          |
|            ++-------------+--------------+-------------+-------------+
|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|
|            ||Join(S,G)    | Prune(S,G)   | Pending     | Expires     |
|            ||             |              | Timer       |             |
|            ||             |              | Expires     |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; NI state  | -           | -           |
|NoInfo (NI) ||start Expiry |              |             |             |
|            ||Timer        |              |             |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; PP state  | -           | -&gt; NI state |
|Join (J)    ||restart      | start Prune- |             |             |
|            ||Expiry Timer | Pending      |             |             |
|            ||             | Timer        |             |             |
+------------++-------------+--------------+-------------+-------------+
|Prune-      ||-&gt; J state   | -&gt; PP state  | -&gt; NI state | -&gt; NI state |
|Pending (PP)||restart      |              | Send Prune- |             |
|            ||Expiry Timer |              | Echo(S,G)   |             |
+------------++-------------+--------------+-------------+-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                         Event                          |
|            ++-------------+--------------+-------------+-------------+
|Prev State  ||Receive      | Receive      | Prune-      | Expiry Timer|
|            ||Join(S,G)    | Prune(S,G)   | Pending     | Expires     |
|            ||             |              | Timer       |             |
|            ||             |              | Expires     |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; NI state  | -           | -           |
|NoInfo (NI) ||start Expiry |              |             |             |
|            ||Timer        |              |             |             |
+------------++-------------+--------------+-------------+-------------+
|            ||-&gt; J state   | -&gt; PP state  | -           | -&gt; NI state |
|Join (J)    ||restart      | start Prune- |             |             |
|            ||Expiry Timer | Pending      |             |             |
|            ||             | Timer        |             |             |
+------------++-------------+--------------+-------------+-------------+
|Prune-      ||-&gt; J state   | -&gt; PP state  | -&gt; NI state | -&gt; NI state |
|Pending (PP)||restart      |              | Send Prune- |             |
|            ||Expiry Timer |              | Echo(S,G)   |             |
+------------++-------------+--------------+-------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition events &#34;Receive Join(S,G)&#34; and &#34;Receive Prune(S,G)&#34; imply receiving a Join or Prune targeted to this router&#39;s primary IP address on the received interface. If the upstream neighbor address field is not correct, these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转换事件“接收连接（S，G）”和“接收剪枝（S，G）”意味着在接收到的接口上接收针对该路由器的主IP地址的连接或剪枝。如果上游邻居地址字段不正确，则此状态机中的这些状态转换不得发生，尽管看到这样的数据包可能会导致其他状态机中的状态转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On unnumbered interfaces on point-to-point links, the router&#39;s address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to-point links we also recommend that for backwards compatibility PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在点到点链路上的未编号接口上，路由器的地址应与它为通过该接口发送的Hello消息选择的源地址相同。然而，在点到点链路上，我们还建议，为了向后兼容，也接受上游邻居地址字段为全零的PIM Join/Prune消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NoInfo State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从NoInfo状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in NoInfo state, the following event may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于NoInfo状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G) A Join(S,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（S，G）在接口I上接收连接（S，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G) downstream state machine on interface I transitions to the Join state. The Expiry Timer (ET) is started and set to the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G）下游状态机转换为连接状态。到期计时器（ET）启动，并从触发加入/删除消息设置为保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Join State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Join state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处于连接状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G) A Join(S,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（S，G）在接口I上接收连接（S，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G) downstream state machine on interface I remains in Join state, and the Expiry Timer (ET) is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G）下游状态机保持连接状态，过期计时器（ET）重新启动，设置为其当前值和触发连接/删除消息的保持时间的最大值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G) A Prune(S,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G）在接口I上接收修剪（S，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G) downstream state machine on interface I transitions to the Prune-Pending state. The Prune-Pending Timer is started. It is set to the J/P_Override_Interval(I) if the router has more than one neighbor on that interface; otherwise, it is set to zero, causing it to expire immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G）下游状态机转换为Prune挂起状态。修剪挂起计时器已启动。如果路由器在该接口上有多个邻居，则设置为J/P_覆盖_间隔（I）；否则，它将设置为零，导致它立即过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires The Expiry Timer for the (S,G) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器过期接口I上（S，G）下游状态机的到期计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G) downstream state machine on interface I transitions to the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G）下游状态机转换为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Prune-Pending State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从修剪挂起状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Prune-Pending state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处于修剪挂起状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G) A Join(S,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（S，G）在接口I上接收连接（S，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G) downstream state machine on interface I transitions to the Join state. The Prune-Pending Timer is canceled (without triggering an expiry event). The Expiry Timer is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G）下游状态机转换为连接状态。删除挂起计时器被取消（不会触发到期事件）。过期计时器将重新启动，并设置为其当前值的最大值和触发加入/删除消息的保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires The Expiry Timer for the (S,G) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器过期接口I上（S，G）下游状态机的到期计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G) downstream state machine on interface I transitions to the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G）下游状态机转换为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer Expires The Prune-Pending Timer for the (S,G) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪挂起计时器过期接口I上（S，G）下游状态机的修剪挂起计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G) downstream state machine on interface I transitions to the NoInfo state. A PruneEcho(S,G) is sent onto the subnet connected to interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G）下游状态机转换为NoInfo状态。一个prueecho（S，G）被发送到连接到接口I的子网。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The action &#34;Send PruneEcho(S,G)&#34; is triggered when the router stops forwarding on an interface as a result of a prune. A PruneEcho(S,G) is simply a Prune(S,G) message sent by the upstream router on a LAN with its own address in the Upstream Neighbor Address field. Its purpose is to add additional reliability so that if a Prune that should have been overridden by another router is lost locally on the LAN, then the PruneEcho may be received and cause the override to happen. A PruneEcho(S,G) need not be sent on an interface that contains only a single PIM neighbor during the time this state machine was in Prune-Pending state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
当路由器由于剪枝而停止在接口上的转发时，将触发“发送剪枝（S，G）”操作。PruneEcho（S，G）只是由局域网上的上游路由器发送的一条Prune（S，G）消息，其自身地址位于上游邻居地址字段中。它的目的是增加额外的可靠性，以便如果本应由另一路由器覆盖的修剪在LAN上本地丢失，则可能会接收到该修剪并导致发生覆盖。在状态机处于Prune挂起状态期间，不需要在仅包含单个PIM邻居的接口上发送prueecho（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.4. Receiving (S,G,rpt) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.4. 接收（S、G、rpt）加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The per-interface state machine for receiving (S,G,rpt) Join/Prune messages is given below. There are five states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面给出了用于接收（S、G、rpt）加入/删除消息的每个接口状态机。有五个州：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo (NI) The interface has no (S,G,rpt) Prune state and no (S,G,rpt) timers running.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo（NI）接口没有（S，G，rpt）修剪状态，也没有（S，G，rpt）计时器在运行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune (P) The interface has (S,G,rpt) Prune state, which will cause the router not to forward packets from S destined for G from this interface even though the interface has active (*,G) Join state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune（P）接口具有（S，G，rpt）Prune状态，这将导致路由器不从该接口转发来自以G为目的地的S的数据包，即使该接口具有活动（*，G）连接状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending (PP) The router has received a Prune(S,G,rpt) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the Prune-Pending state functions exactly like the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Pending（PP）路由器已从下游邻居收到此接口上的Prune（S、G、rpt），并等待查看该Prune是否将被另一个下游路由器覆盖。出于转发目的，Prune挂起状态的功能与NoInfo状态完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PruneTmp (P&#39;) This state is a transient state that for forwarding purposes behaves exactly like the Prune state. A (*,G) Join has been received (which may cancel the (S,G,rpt) Prune). As we parse the Join/Prune message from top to bottom, we first enter this state if the message contains a (*,G) Join. Later in the message, we will normally encounter an (S,G,rpt) prune to reinstate the Prune state. However, if we reach the end of the message without encountering such a (S,G,rpt) prune, then we will revert to NoInfo state in this state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PruneTmp（P&#39;）此状态是一种瞬态状态，出于转发目的，其行为与Prune状态完全相同。已收到（*，G）联接（这可能会取消（S，G，rpt）修剪）。当我们从上到下解析Join/Prune消息时，如果消息包含（*，G）连接，我们首先进入这种状态。在消息的后面，我们通常会遇到一个（S，G，rpt）修剪来恢复修剪状态。但是，如果我们到达消息的结尾时没有遇到这样的（S，G，rpt）删减，那么我们将在这个状态机中恢复到NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
As no time is spent in this state, no timers can expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
由于在此状态下不会花费任何时间，因此计时器不会过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending-Tmp (PP&#39;) This state is a transient state that is identical to P&#39; except that it is associated with the PP state rather than the P state. For forwarding purposes, PP&#39; behaves exactly like PP state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪挂起Tmp（PP&#39;）此状态是与P&#39;相同的瞬态，只是它与PP状态而不是P状态关联。出于转发目的，PP&#39;的行为与PP状态完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there are two timers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有两个计时器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer (ET) This timer is set when a valid Prune(S,G,rpt) is received. Expiry of the Expiry Timer causes this state machine to revert to NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
到期计时器（ET）此计时器在收到有效的修剪（S、G、rpt）时设置。到期计时器的到期导致此状态机恢复为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer (PPT) This timer is set when a valid Prune(S,G,rpt) is received. Expiry of the Prune-Pending Timer causes this state machine to move on to Prune state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪挂起计时器（PPT）此计时器在收到有效修剪（S、G、rpt）时设置。修剪挂起计时器的到期将导致此状态机转到修剪状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Figure 5: Downstream per-interface (S,G,rpt) state machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
图5：表格形式的每个接口（S、G、rpt）下游状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------++----------------------------------------------------------+
|          ||                          Event                           |
|          ++---------+----------+----------+--------+--------+--------+
|Prev      ||Receive  | Receive  | Receive  | End of | Prune- | Expiry |
|State     ||Join(*,G)| Join     | Prune    | Message| Pending| Timer  |
|          ||         | (S,G,rpt)| (S,G,rpt)|        | Timer  | Expires|
|          ||         |          |          |        | Expires|        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-        | -        | -&gt; PP    | -      | -      | -      |
|          ||         |          | state    |        |        |        |
|          ||         |          | start    |        |        |        |
|NoInfo    ||         |          | Prune-   |        |        |        |
|(NI)      ||         |          | Pending  |        |        |        |
|          ||         |          | Timer;   |        |        |        |
|          ||         |          | start    |        |        |        |
|          ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-&gt; P&#39;    | -&gt; NI    | -&gt; P     | -      | -      | -&gt; NI  |
|          ||state    | state    | state    |        |        | state  |
|Prune (P) ||         |          | restart  |        |        |        |
|          ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|Prune-    ||-&gt; PP&#39;   | -&gt; NI    | -        | -      | -&gt; P   | -      |
|Pending   ||state    | state    |          |        | state  |        |
|(PP)      ||         |          |          |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-        | -        | -&gt; P     | -&gt; NI  | -      | -      |
|PruneTmp  ||         |          | state    | state  |        |        |
|(P&#39;)      ||         |          | restart  |        |        |        |
|          ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-        | -        | -&gt; PP    | -&gt; NI  | -      | -      |
|Prune-    ||         |          | state    | state  |        |        |
|Pending-  ||         |          | restart  |        |        |        |
|Tmp (PP&#39;) ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------++----------------------------------------------------------+
|          ||                          Event                           |
|          ++---------+----------+----------+--------+--------+--------+
|Prev      ||Receive  | Receive  | Receive  | End of | Prune- | Expiry |
|State     ||Join(*,G)| Join     | Prune    | Message| Pending| Timer  |
|          ||         | (S,G,rpt)| (S,G,rpt)|        | Timer  | Expires|
|          ||         |          |          |        | Expires|        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-        | -        | -&gt; PP    | -      | -      | -      |
|          ||         |          | state    |        |        |        |
|          ||         |          | start    |        |        |        |
|NoInfo    ||         |          | Prune-   |        |        |        |
|(NI)      ||         |          | Pending  |        |        |        |
|          ||         |          | Timer;   |        |        |        |
|          ||         |          | start    |        |        |        |
|          ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-&gt; P&#39;    | -&gt; NI    | -&gt; P     | -      | -      | -&gt; NI  |
|          ||state    | state    | state    |        |        | state  |
|Prune (P) ||         |          | restart  |        |        |        |
|          ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|Prune-    ||-&gt; PP&#39;   | -&gt; NI    | -        | -      | -&gt; P   | -      |
|Pending   ||state    | state    |          |        | state  |        |
|(PP)      ||         |          |          |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-        | -        | -&gt; P     | -&gt; NI  | -      | -      |
|PruneTmp  ||         |          | state    | state  |        |        |
|(P&#39;)      ||         |          | restart  |        |        |        |
|          ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
|          ||-        | -        | -&gt; PP    | -&gt; NI  | -      | -      |
|Prune-    ||         |          | state    | state  |        |        |
|Pending-  ||         |          | restart  |        |        |        |
|Tmp (PP&#39;) ||         |          | Expiry   |        |        |        |
|          ||         |          | Timer    |        |        |        |
+----------++---------+----------+----------+--------+--------+--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition events &#34;Receive Join(S,G,rpt)&#34;, &#34;Receive Prune(S,G,rpt)&#34;, and &#34;Receive Join(*,G)&#34; imply receiving a Join or Prune targeted to this router&#39;s primary IP address on the received interface. If the upstream neighbor address field is not correct,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转换事件“接收连接（S，G，rpt）”、“接收剪枝（S，G，rpt）”和“接收连接（*，G）”意味着在接收到的接口上接收针对该路由器的主IP地址的连接或剪枝。如果上游邻居地址字段不正确，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
these state transitions in this state machine must not occur, although seeing such a packet may cause state transitions in other state machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态机中的这些状态转换不能发生，尽管看到这样的数据包可能会导致其他状态机中的状态转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On unnumbered interfaces on point-to-point links, the router&#39;s address should be the same as the source address it chose for the Hello message it sent over that interface. However, on point-to-point links we also recommend that PIM Join/Prune messages with an upstream neighbor address field of all zeros are also accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在点到点链路上的未编号接口上，路由器的地址应与它为通过该接口发送的Hello消息选择的源地址相同。但是，在点到点链路上，我们还建议也接受上游邻居地址字段为全零的PIM加入/删减消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NoInfo State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从NoInfo状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in NoInfo (NI) state, the following event may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于NoInfo（NI）状态时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G,rpt) A Prune(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G，rpt）在接口I上接收修剪（S，G，rpt），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to the Prune-Pending state. The Expiry Timer (ET) is started and set to the HoldTime from the triggering Join/Prune message. The Prune-Pending Timer is started. It is set to the J/P_Override_Interval(I) if the router has more than one neighbor on that interface; otherwise, it is set to zero, causing it to expire immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换为Prune挂起状态。到期计时器（ET）启动，并从触发加入/删除消息设置为保持时间。修剪挂起计时器已启动。如果路由器在该接口上有多个邻居，则设置为J/P_覆盖_间隔（I）；否则，它将设置为零，导致它立即过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Prune-Pending State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从修剪挂起状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Prune-Pending (PP) state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处于修剪挂起（PP）状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，G）在接口I上接收连接（*，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to Prune-Pending-Tmp state whilst the remainder of the compound Join/Prune message containing the Join(*,G) is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G，rpt）下游状态机转换为Prune挂起Tmp状态，同时处理包含Join（*，G）的复合Join/Prune消息的其余部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G,rpt) A Join(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（S，G，rpt）在接口I上接收连接（S，G，rpt），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to NoInfo state. ET and PPT are canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换为NoInfo状态。ET和PPT被取消。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune-Pending Timer Expires The Prune-Pending Timer for the (S,G,rpt) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Pending Timer Expires接口I上（S，G，rpt）下游状态机的Prune Pending Timer过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to the Prune state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换到Prune状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Prune State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从修剪状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Prune (P) state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于修剪（P）状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,G) A Join(*,G) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（*，G）在接口I上接收连接（*，G），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to PruneTmp state whilst the remainder of the compound Join/Prune message containing the Join(*,G) is processed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G，rpt）下游状态机转换为PruneTmp状态，同时处理包含Join（*，G）的复合Join/Prune消息的其余部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G,rpt) A Join(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（S，G，rpt）在接口I上接收连接（S，G，rpt），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to NoInfo state. ET and PPT are canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换为NoInfo状态。ET和PPT被取消。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G,rpt) A Prune(S,G,rpt) is received on interface I with its Upstream Neighbor Address set to the router&#39;s primary IP address on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G，rpt）在接口I上接收修剪（S，G，rpt），其上游邻居地址设置为路由器在接口I上的主IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I remains in Prune state. The Expiry Timer (ET) is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S，G，rpt）下游状态机保持在Prune状态。过期计时器（ET）重新启动，设置为其当前值的最大值和触发加入/删除消息的保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires The Expiry Timer for the (S,G,rpt) downstream state machine on interface I expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Expiry Timer Expires接口I上（S、G、rpt）下游状态机的过期计时器过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Prune-Pending-Tmp State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从修剪挂起Tmp状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in Prune-Pending-Tmp (PP&#39;) state and processing a compound Join/Prune message, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于修剪挂起Tmp（PP&#39;）状态并处理复合联接/修剪消息时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G,rpt) The compound Join/Prune message contains a Prune(S,G,rpt).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G，rpt）复合加入/修剪消息包含修剪（S，G，rpt）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions back to the Prune-Pending state. The Expiry Timer (ET) is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换回Prune挂起状态。过期计时器（ET）重新启动，设置为其当前值的最大值和触发加入/删除消息的保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
End of Message The end of the compound Join/Prune message is reached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
消息结束到达复合联接/修剪消息的结尾。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to the NoInfo state. ET and PPT are canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换为NoInfo状态。ET和PPT被取消。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from PruneTmp State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从PruneTmp状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in PruneTmp (P&#39;) state and processing a compound Join/Prune message, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于PruneTmp（P&#39;）状态并处理复合联接/修剪消息时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G,rpt) The compound Join/Prune message contains a Prune(S,G,rpt).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G，rpt）复合加入/修剪消息包含修剪（S，G，rpt）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions back to the Prune state. The Expiry Timer (ET) is restarted, set to maximum of its current value and the HoldTime from the triggering Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换回Prune状态。过期计时器（ET）重新启动，设置为其当前值的最大值和触发加入/删除消息的保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
End of Message The end of the compound Join/Prune message is reached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
消息结束到达复合联接/修剪消息的结尾。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The (S,G,rpt) downstream state machine on interface I transitions to the NoInfo state. ET is canceled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
接口I上的（S、G、rpt）下游状态机转换为NoInfo状态。ET取消了。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Notes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
笔记：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receiving a Prune(*,G) does not affect the (S,G,rpt) downstream state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收修剪（*，G）不会影响（S，G，rpt）下游状态机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receiving a Join(*,*,RP) does not affect the (S,G,rpt) downstream state machine. If a router has originated Join(*,*,RP) and pruned a source off it using Prune(S,G,rpt), then to receive that source again it should explicitly re-join using Join(S,G,rpt) or Join(*,G). In some LAN topologies it is possible for a router sending a new Join(*,*,RP) to have to wait as much as a Join/Prune Interval before noticing that it needs to override a neighbor&#39;s preexisting Prune(S,G,rpt). This is considered acceptable, as (*,*,RP) state is intended to be used only in long-lived and persistent scenarios.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
连接机器（*，rpt，G）不影响下游接收机器（*，rpt，G）。如果路由器发起了连接（*，*，RP），并使用Prune（S，G，rpt）从中删除了一个源，那么为了再次接收该源，它应该使用连接（S，G，rpt）或连接（*，G）显式地重新连接。在某些LAN拓扑中，发送新连接（*，*，RP）的路由器可能需要等待一个连接/删除间隔，然后才注意到它需要覆盖邻居先前存在的删除（s，G，rpt）。这被认为是可以接受的，因为（*，*，RP）状态仅用于长期和持久的场景。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.5. Sending (*,*,RP) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.5. 发送（*，*，RP）加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The per-interface state machines for (*,*,RP) hold join state from downstream PIM routers. This state then determines whether a router needs to propagate a Join(*,*,RP) upstream towards the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，*，RP）的每个接口状态机保持来自下游PIM路由器的连接状态。然后，该状态确定路由器是否需要向RP向上游传播连接（*，*，RP）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a router wishes to propagate a Join(*,*,RP) upstream, it must also watch for messages on its upstream interface from other routers on that subnet, and these may modify its behavior. If it sees a Join(*,*,RP) to the correct upstream neighbor, it should suppress its own Join(*,*,RP). If it sees a Prune(*,*,RP) to the correct upstream neighbor, it should be prepared to override that prune by sending a Join(*,*,RP) almost immediately. Finally, if it sees the Generation ID (see Section 4.3) of the correct upstream neighbor change, it knows that the upstream neighbor has lost state, and it should be prepared to refresh the state by sending a Join(*,*,RP) almost immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果路由器希望向上游传播连接（*，*，RP），它还必须在其上游接口上监视来自该子网上其他路由器的消息，这些消息可能会修改其行为。如果它看到一个连接（*，*，RP）到正确的上游邻居，它应该抑制自己的连接（*，*，RP）。如果它看到一个修剪（*，*，RP）到正确的上游邻居，它应该准备通过几乎立即发送连接（*，*，RP）来覆盖该修剪。如果一个邻居的ID几乎丢失，那么它应该立即刷新上游的状态（*，），参见第4节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, if the MRIB changes to indicate that the next hop towards the RP has changed, the router should prune off from the old next hop and join towards the new next hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，如果MRIB发生变化，表明朝向RP的下一个跃点发生了变化，路由器应该从旧的下一个跃点剪掉，并加入到新的下一个跃点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (*,*,RP) state machine contains only two states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（*，*，RP）状态机仅包含两种状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not Joined The downstream state machines and local membership information do not indicate that the router needs to join the (*,*,RP) tree for this RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未加入下游状态机和本地成员身份信息并不表示路由器需要加入此RP的（*，*，RP）树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joined The downstream state machines and local membership information indicate that the router should join the (*,*,RP) tree for this RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已加入下游状态机和本地成员身份信息表明路由器应加入此RP的（*，*，RP）树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, one timer JT(*,*,RP) is kept that is used to trigger the sending of a Join(*,*,RP) to the upstream next hop towards the RP, NBR(RPF_interface(RP), MRIB.next_hop(RP)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，保留一个计时器JT（*，*，RP），用于触发向RP，NBR（RPF_接口（RP），MRIB.next_hop（RP））的上游下一跳发送连接（*，*，RP）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Figure 6: Upstream (*,*,RP) state machine in tabular form
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Figure 6: Upstream (*,*,RP) state machine in tabular form
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------++-------------------------------------------------+
|                   ||                      Event                      |
|  Prev State       ++-------------------------+-----------------------+
|                   ||   JoinDesired           |    JoinDesired        |
|                   ||   (*,*,RP) -&gt;True       |    (*,*,RP) -&gt;False   |
+-------------------++-------------------------+-----------------------+
|                   ||   -&gt; J state            |    -                  |
|  NotJoined (NJ)   ||   Send Join(*,*,RP);    |                       |
|                   ||   Set Join Timer to     |                       |
|                   ||   t_periodic            |                       |
+-------------------++-------------------------+-----------------------+
|  Joined (J)       ||   -                     |    -&gt; NJ state        |
|                   ||                         |    Send Prune         |
|                   ||                         |    (*,*,RP); Cancel   |
|                   ||                         |    Join Timer         |
+-------------------++-------------------------+-----------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------++-------------------------------------------------+
|                   ||                      Event                      |
|  Prev State       ++-------------------------+-----------------------+
|                   ||   JoinDesired           |    JoinDesired        |
|                   ||   (*,*,RP) -&gt;True       |    (*,*,RP) -&gt;False   |
+-------------------++-------------------------+-----------------------+
|                   ||   -&gt; J state            |    -                  |
|  NotJoined (NJ)   ||   Send Join(*,*,RP);    |                       |
|                   ||   Set Join Timer to     |                       |
|                   ||   t_periodic            |                       |
+-------------------++-------------------------+-----------------------+
|  Joined (J)       ||   -                     |    -&gt; NJ state        |
|                   ||                         |    Send Prune         |
|                   ||                         |    (*,*,RP); Cancel   |
|                   ||                         |    Join Timer         |
+-------------------++-------------------------+-----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, we have the following transitions, which occur within the Joined state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，我们还有以下转换，它们发生在连接状态中：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+-------------------+--------------------+-----------------------------+
| Timer Expires     |  See               |   See                       |
|                   |  Join(*,*,RP)      |   Prune(*,*,RP)             |
|                   |  to MRIB.          |   to MRIB.                  |
|                   |  next_hop(RP)      |   next_hop(RP)              |
+-------------------+--------------------+-----------------------------+
| Send              |  Increase Join     |   Decrease Join             |
| Join(*,*,RP);     |  Timer to          |   Timer to                  |
| Set Join Timer    |  t_joinsuppress    |   t_override                |
| to t_periodic     |                    |                             |
+-------------------+--------------------+-----------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+-------------------+--------------------+-----------------------------+
| Timer Expires     |  See               |   See                       |
|                   |  Join(*,*,RP)      |   Prune(*,*,RP)             |
|                   |  to MRIB.          |   to MRIB.                  |
|                   |  next_hop(RP)      |   next_hop(RP)              |
+-------------------+--------------------+-----------------------------+
| Send              |  Increase Join     |   Decrease Join             |
| Join(*,*,RP);     |  Timer to          |   Timer to                  |
| Set Join Timer    |  t_joinsuppress    |   t_override                |
| to t_periodic     |                    |                             |
+-------------------+--------------------+-----------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+-----------------------------------+----------------------------------+
|    NBR(RPF_interface(RP),         |       MRIB.next_hop(RP) GenID    |
|    MRIB.next_hop(RP))             |       changes                    |
|    changes                        |                                  |
+-----------------------------------+----------------------------------+
|    Send Join(*,*,RP) to new       |       Decrease Join Timer to     |
|    next hop; Send                 |       t_override                 |
|    Prune(*,*,RP) to old           |                                  |
|    next hop; set Join Timer       |                                  |
|    to t_periodic                  |                                  |
+-----------------------------------+----------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+-----------------------------------+----------------------------------+
|    NBR(RPF_interface(RP),         |       MRIB.next_hop(RP) GenID    |
|    MRIB.next_hop(RP))             |       changes                    |
|    changes                        |                                  |
+-----------------------------------+----------------------------------+
|    Send Join(*,*,RP) to new       |       Decrease Join Timer to     |
|    next hop; Send                 |       t_override                 |
|    Prune(*,*,RP) to old           |                                  |
|    next hop; set Join Timer       |                                  |
|    to t_periodic                  |                                  |
+-----------------------------------+----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state machine uses the following macro:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态机使用以下宏：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool JoinDesired(*,*,RP) {
        if immediate_olist(*,*,RP) != NULL
            return TRUE
        else
            return FALSE
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool JoinDesired(*,*,RP) {
        if immediate_olist(*,*,RP) != NULL
            return TRUE
        else
            return FALSE
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinDesired(*,*,RP) is true when the router has received (*,*,RP) Joins from any downstream interface. Note that although JoinDesired is true, the router&#39;s sending of a Join(*,*,RP) message may be suppressed by another router sending a Join(*,*,RP) onto the upstream interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器从任何下游接口接收（*，*，RP）连接时，JoinDesired（*，*，RP）为真。注意，尽管JoinDesired为true，但路由器发送连接（*，*，RP）消息可能会被另一个向上游接口发送连接（*，*，RP）的路由器抑制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NotJoined State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从未连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the upstream (*,*,RP) state machine is in NotJoined state, the following event may trigger a state transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（*，*，RP）状态机处于未联接状态时，以下事件可能触发状态转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired(*,*,RP) becomes True The downstream state for (*,*,RP) has changed so that at least one interface is in immediate_olist(*,*,RP), making JoinDesired(*,*,RP) become True.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired（*，*，RP）变为真（*，*，RP）的下游状态已更改，因此至少有一个接口处于即时列表（*，*，RP），使JoinDesired（*，*，RP）变为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,*,RP) state machine transitions to Joined state. Send Join(*,*,RP) to the appropriate upstream neighbor, which is NBR(RPF_interface(RP), MRIB.next_hop(RP)). Set the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，*，RP）状态机转换为联接状态。将Join（*，*，RP）发送到相应的上游邻居，即NBR（RPF_接口（RP），MRIB.next_hop（RP））。将加入计时器（JT）设置为在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Joined State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the upstream (*,*,RP) state machine is in Joined state, the following events may trigger state transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（*，*，RP）状态机处于连接状态时，以下事件可能触发状态转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired(*,*,RP) becomes False The downstream state for (*,*,RP) has changed so no interface is in immediate_olist(*,*,RP), making JoinDesired(*,*,RP) become False.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired（*，*，RP）变为False（*，*，RP）的下游状态已更改，因此没有接口处于即时列表（*，*，RP），使JoinDesired（*，*，RP）变为False。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,*,RP) state machine transitions to NotJoined state. Send Prune(*,*,RP) to the appropriate upstream neighbor, which is NBR(RPF_interface(RP), MRIB.next_hop(RP)). Cancel the Join Timer (JT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，*，RP）状态机转换为NotJoined状态。将Prune（*，*，RP）发送到相应的上游邻居，即NBR（RPF_接口（RP），MRIB.next_hop（RP））。取消加入计时器（JT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join Timer Expires The Join Timer (JT) expires, indicating time to send a Join(*,*,RP)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
加入计时器过期加入计时器（JT）过期，表示发送加入（*，*，RP）的时间
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Send Join(*,*,RP) to the appropriate upstream neighbor, which is NBR(RPF_interface(RP), MRIB.next_hop(RP)). Restart the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
将Join（*，*，RP）发送到相应的上游邻居，即NBR（RPF_接口（RP），MRIB.next_hop（RP））。重新启动加入计时器（JT），使其在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Join(*,*,RP) to MRIB.next_hop(RP) This event is only relevant if RPF_interface(RP) is a shared medium. This router sees another router on RPF_interface(RP) send a Join(*,*,RP) to NBR(RPF_interface(RP), MRIB.next_hop(RP)). This causes this router to suppress its own Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅将（*，*，RP）连接到MRIB。下一跳（RP）仅当RPF_接口（RP）是共享介质时，此事件才相关。此路由器看到RPF_接口（RP）上的另一个路由器向NBR（RPF_接口（RP），MRIB.next_hop（RP））发送连接（*，*，RP）。这会导致此路由器抑制其自身的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,*,RP) state machine remains in Joined state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，*，RP）状态机保持连接状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Let t_joinsuppress be the minimum of t_suppressed and the HoldTime from the Join/Prune message triggering this event. If the Join Timer is set to expire in less than t_joinsuppress seconds, reset it so that it expires after t_joinsuppress seconds. If the Join Timer is set to expire in more than t_joinsuppress seconds, leave it unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
让t_joinsuppress是触发此事件的Join/Prune消息中t_suppressed和HoldTime的最小值。如果连接计时器设置为在t_joinsuppress秒内过期，请重置它，使其在t_joinsuppress秒后过期。如果连接计时器设置为在超过t_秒后过期，请保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(*,*,RP) to MRIB.next_hop(RP) This event is only relevant if RPF_interface(RP) is a shared medium. This router sees another router on RPF_interface(RP) send a Prune(*,*,RP) to NBR(RPF_interface(RP), MRIB.next_hop(RP)). As this router is in Joined state, it must override the Prune after a short random interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参见MRIB的删减（*，*，RP）。下一跳（RP）仅当RPF_接口（RP）是共享介质时，此事件才相关。此路由器看到RPF_接口（RP）上的另一个路由器向NBR（RPF_接口（RP），MRIB.next_hop（RP））发送修剪（*，*，RP）。由于此路由器处于连接状态，它必须在短的随机间隔后覆盖修剪。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,*,RP) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds. If the Join Timer is set to expire in less than t_override seconds, leave it unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，*，RP）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。如果连接计时器设置为在不到t_override秒的时间内过期，请保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NBR(RPF_interface(RP), MRIB.next_hop(RP)) changes A change in the MRIB routing base causes the next hop towards the RP to change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NBR（RPF_接口（RP）、MRIB.next_跃点（RP））更改MRIB路由基础中的更改会导致朝向RP的下一个跃点发生更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,*,RP) state machine remains in Joined state. Send Join(*,*,RP) to the new upstream neighbor, which is the new value of NBR(RPF_interface(RP), MRIB.next_hop(RP)). Send Prune(*,*,RP) to the old upstream neighbor, which is the old value of NBR(RPF_interface(RP), MRIB.next_hop(RP)). Set the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，*，RP）状态机保持连接状态。将Join（*，*，RP）发送到新的上游邻居，这是NBR（RPF_接口（RP），MRIB.next_hop（RP））的新值。将Prune（*，*，RP）发送到旧的上游邻居，这是NBR的旧值（RPF_接口（RP），MRIB.next_hop（RP））。将加入计时器（JT）设置为在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
MRIB.next_hop(RP) GenID changes The Generation ID of the router that is MRIB.next_hop(RP) changes. This normally means that this neighbor has lost state, and so the state must be refreshed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
MRIB.next_-hop（RP）GenID更改作为MRIB的路由器的生成ID。next_-hop（RP）更改。这通常意味着该邻居已丢失状态，因此必须刷新状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,*,RP) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，*，RP）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.6. Sending (*,G) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.6. 发送（*，G）加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The per-interface state machines for (*,G) hold join state from downstream PIM routers. This state then determines whether a router needs to propagate a Join(*,G) upstream towards the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，G）的每个接口状态机保持来自下游PIM路由器的连接状态。然后，该状态确定路由器是否需要向RP向上游传播连接（*，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a router wishes to propagate a Join(*,G) upstream, it must also watch for messages on its upstream interface from other routers on that subnet, and these may modify its behavior. If it sees a Join(*,G) to the correct upstream neighbor, it should suppress its own Join(*,G). If it sees a Prune(*,G) to the correct upstream neighbor, it should be prepared to override that prune by sending a Join(*,G) almost immediately. Finally, if it sees the Generation ID (see Section 4.3) of the correct upstream neighbor change, it knows that the upstream neighbor has lost state, and it should be prepared to refresh the state by sending a Join(*,G) almost immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果路由器希望向上游传播连接（*，G），它还必须在其上游接口上监视来自该子网上其他路由器的消息，这些消息可能会修改其行为。如果它看到一个连接（*，G）到正确的上游邻居，它应该抑制自己的连接（*，G）。如果它看到对正确的上游邻居进行了修剪（*，G），它应该准备通过几乎立即发送连接（*，G）来覆盖该修剪。最后，如果它看到正确的上游邻居的生成ID（参见第4.3节）发生变化，它知道上游邻居已丢失状态，并且它应该准备几乎立即发送连接（*，G）来刷新状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a (*,G) Assert occurs on the upstream interface, and this changes this router&#39;s idea of the upstream neighbor, it should be prepared to ensure that the Assert winner is aware of downstream routers by sending a Join(*,G) almost immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果一个（*，G）断言发生在上游接口上，并且这改变了该路由器对上游邻居的看法，那么它应该准备好通过几乎立即发送连接（*，G）来确保断言获胜者知道下游路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, if the MRIB changes to indicate that the next hop towards the RP has changed, and either the upstream interface changes or there is no Assert winner on the upstream interface, the router should prune off from the old next hop and join towards the new next hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，如果MRIB发生变化，表明朝向RP的下一个跃点发生了变化，并且上游接口发生了变化或者上游接口上没有断言赢家，那么路由器应该从旧的下一个跃点剪除，并向新的下一个跃点加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (*,G) state machine only contains two states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（*，G）状态机仅包含两种状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not Joined The downstream state machines indicate that the router does not need to join the RP tree for this group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未加入下游状态机表示路由器不需要加入此组的RP树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joined The downstream state machines indicate that the router should join the RP tree for this group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已加入下游状态机表示路由器应加入此组的RP树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, one timer JT(*,G) is kept that is used to trigger the sending of a Join(*,G) to the upstream next hop towards the RP, RPF&#39;(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，保留一个计时器JT（*，G），用于触发向RP，RPF&#39;（*，G）的上游下一跳发送连接（*，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Figure 7: Upstream (*,G) state machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
图7：表格形式的上游（*，G）状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------++-------------------------------------------------+
|                   ||                      Event                      |
|  Prev State       ++------------------------+------------------------+
|                   ||   JoinDesired(*,G)     |    JoinDesired(*,G)    |
|                   ||   -&gt;True               |    -&gt;False             |
+-------------------++------------------------+------------------------+
|                   ||   -&gt; J state           |    -                   |
|  NotJoined (NJ)   ||   Send Join(*,G);      |                        |
|                   ||   Set Join Timer to    |                        |
|                   ||   t_periodic           |                        |
+-------------------++------------------------+------------------------+
|  Joined (J)       ||   -                    |    -&gt; NJ state         |
|                   ||                        |    Send Prune(*,G);    |
|                   ||                        |    Cancel Join Timer   |
+-------------------++------------------------+------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------++-------------------------------------------------+
|                   ||                      Event                      |
|  Prev State       ++------------------------+------------------------+
|                   ||   JoinDesired(*,G)     |    JoinDesired(*,G)    |
|                   ||   -&gt;True               |    -&gt;False             |
+-------------------++------------------------+------------------------+
|                   ||   -&gt; J state           |    -                   |
|  NotJoined (NJ)   ||   Send Join(*,G);      |                        |
|                   ||   Set Join Timer to    |                        |
|                   ||   t_periodic           |                        |
+-------------------++------------------------+------------------------+
|  Joined (J)       ||   -                    |    -&gt; NJ state         |
|                   ||                        |    Send Prune(*,G);    |
|                   ||                        |    Cancel Join Timer   |
+-------------------++------------------------+------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, we have the following transitions, which occur within the Joined state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，我们还有以下转换，它们发生在连接状态中：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                        In Joined (J) State                           |
+----------------+-----------------+-----------------+-----------------+
|Timer Expires   | See Join(*,G)   | See Prune(*,G)  | RPF&#39;(*,G)       |
|                | to RPF&#39;(*,G)    | to RPF&#39;(*,G)    | changes due to  |
|                |                 |                 | an Assert       |
+----------------+-----------------+-----------------+-----------------+
|Send            | Increase Join   | Decrease Join   | Decrease Join   |
|Join(*,G); Set  | Timer to        | Timer to        | Timer to        |
|Join Timer to   | t_joinsuppress  | t_override      | t_override      |
|t_periodic      |                 |                 |                 |
+----------------+-----------------+-----------------+-----------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                        In Joined (J) State                           |
+----------------+-----------------+-----------------+-----------------+
|Timer Expires   | See Join(*,G)   | See Prune(*,G)  | RPF&#39;(*,G)       |
|                | to RPF&#39;(*,G)    | to RPF&#39;(*,G)    | changes due to  |
|                |                 |                 | an Assert       |
+----------------+-----------------+-----------------+-----------------+
|Send            | Increase Join   | Decrease Join   | Decrease Join   |
|Join(*,G); Set  | Timer to        | Timer to        | Timer to        |
|Join Timer to   | t_joinsuppress  | t_override      | t_override      |
|t_periodic      |                 |                 |                 |
+----------------+-----------------+-----------------+-----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+----------------------------------+-----------------------------------+
|    RPF&#39;(*,G) changes not         |       RPF&#39;(*,G) GenID changes     |
|    due to an Assert              |                                   |
+----------------------------------+-----------------------------------+
|    Send Join(*,G) to new         |       Decrease Join Timer to      |
|    next hop; Send                |       t_override                  |
|    Prune(*,G) to old next        |                                   |
|    hop; Set Join Timer to        |                                   |
|    t_periodic                    |                                   |
+----------------------------------+-----------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+----------------------------------+-----------------------------------+
|    RPF&#39;(*,G) changes not         |       RPF&#39;(*,G) GenID changes     |
|    due to an Assert              |                                   |
+----------------------------------+-----------------------------------+
|    Send Join(*,G) to new         |       Decrease Join Timer to      |
|    next hop; Send                |       t_override                  |
|    Prune(*,G) to old next        |                                   |
|    hop; Set Join Timer to        |                                   |
|    t_periodic                    |                                   |
+----------------------------------+-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state machine uses the following macro:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态机使用以下宏：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool JoinDesired(*,G) {
        if (immediate_olist(*,G) != NULL OR
            (JoinDesired(*,*,RP(G)) AND
             AssertWinner(*, G, RPF_interface(RP(G))) != NULL))
            return TRUE
        else
            return FALSE
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool JoinDesired(*,G) {
        if (immediate_olist(*,G) != NULL OR
            (JoinDesired(*,*,RP(G)) AND
             AssertWinner(*, G, RPF_interface(RP(G))) != NULL))
            return TRUE
        else
            return FALSE
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinDesired(*,G) is true when the router has forwarding state that would cause it to forward traffic for G using shared tree state. Note that although JoinDesired is true, the router&#39;s sending of a Join(*,G) message may be suppressed by another router sending a Join(*,G) onto the upstream interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器的转发状态会导致它使用共享树状态转发G的流量时，JoinDesired（*，G）为真。请注意，尽管JoinDesired为true，但路由器发送连接（*，G）消息可能会被另一个向上游接口发送连接（*，G）的路由器抑制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NotJoined State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从未连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the upstream (*,G) state machine is in NotJoined state, the following event may trigger a state transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（*，G）状态机处于NotJoined状态时，以下事件可能触发状态转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired(*,G) becomes True The macro JoinDesired(*,G) becomes True, e.g., because the downstream state for (*,G) has changed so that at least one interface is in immediate_olist(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired（*，G）变为True宏JoinDesired（*，G）变为True，例如，因为（*，G）的下游状态已更改，因此至少有一个接口处于即时列表（*，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,G) state machine transitions to Joined state. Send Join(*,G) to the appropriate upstream neighbor, which is RPF&#39;(*,G). Set the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，G）状态机转换为联接状态。将Join（*，G）发送到适当的上游邻居，即RPF&#39;（*，G）。将加入计时器（JT）设置为在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Joined State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the upstream (*,G) state machine is in Joined state, the following events may trigger state transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（*，G）状态机处于连接状态时，以下事件可能触发状态转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired(*,G) becomes False The macro JoinDesired(*,G) becomes False, e.g., because the downstream state for (*,G) has changed so no interface is in immediate_olist(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired（*，G）变为False宏JoinDesired（*，G）变为False，例如，因为（*，G）的下游状态已更改，因此没有接口处于立即列表（*，G）中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,G) state machine transitions to NotJoined state. Send Prune(*,G) to the appropriate upstream neighbor, which is RPF&#39;(*,G). Cancel the Join Timer (JT).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，G）状态机转换为NotJoined状态。将Prune（*，G）发送到适当的上游邻居，即RPF&#39;（*，G）。取消加入计时器（JT）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join Timer Expires The Join Timer (JT) expires, indicating time to send a Join(*,G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
加入计时器过期加入计时器（JT）过期，表示发送加入（*，G）的时间
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Send Join(*,G) to the appropriate upstream neighbor, which is RPF&#39;(*,G). Restart the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
将Join（*，G）发送到适当的上游邻居，即RPF&#39;（*，G）。重新启动加入计时器（JT），使其在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Join(*,G) to RPF&#39;(*,G) This event is only relevant if RPF_interface(RP(G)) is a shared medium. This router sees another router on RPF_interface(RP(G)) send a Join(*,G) to RPF&#39;(*,G). This causes this router to suppress its own Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅将（*，G）连接到RPF&#39;（*，G）此事件仅在RPF_接口（RP（G））是共享介质时相关。此路由器看到RPF_接口（RP（G））上的另一个路由器向RPF&#39;（*，G）发送连接（*，G）。这会导致此路由器抑制其自身的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,G) state machine remains in Joined state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，G）状态机保持连接状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Let t_joinsuppress be the minimum of t_suppressed and the HoldTime from the Join/Prune message triggering this event. If the Join Timer is set to expire in less than t_joinsuppress seconds, reset it so that it expires after t_joinsuppress seconds. If the Join Timer is set to expire in more than t_joinsuppress seconds, leave it unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
让t_joinsuppress是触发此事件的Join/Prune消息中t_suppressed和HoldTime的最小值。如果连接计时器设置为在t_joinsuppress秒内过期，请重置它，使其在t_joinsuppress秒后过期。如果连接计时器设置为在超过t_秒后过期，请保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(*,G) to RPF&#39;(*,G) This event is only relevant if RPF_interface(RP(G)) is a shared medium. This router sees another router on RPF_interface(RP(G)) send a Prune(*,G) to RPF&#39;(*,G). As this router is in Joined state, it must override the Prune after a short random interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参见Prune（*，G）到RPF&#39;（*，G）。只有当RPF_接口（RP（G））是共享介质时，此事件才相关。此路由器看到RPF_接口（RP（G））上的另一个路由器向RPF&#39;（*，G）发送修剪（*，G）。由于此路由器处于连接状态，它必须在短的随机间隔后覆盖修剪。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds. If the Join Timer is set to expire in less than t_override seconds, leave it unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。如果连接计时器设置为在不到t_override秒的时间内过期，请保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(*,G) changes due to an Assert The current next hop towards the RP changes due to an Assert(*,G) on the RPF_interface(RP(G)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;（*，G）由于断言而更改当前的下一跳到RP由于RPF_接口（RP（G））上的断言（*，G）而更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds. If the Join Timer is set to expire in less than t_override seconds, leave it unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。如果连接计时器设置为在不到t_override秒的时间内过期，请保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(*,G) changes not due to an Assert An event occurred that caused the next hop towards the RP for G to change. This may be caused by a change in the MRIB routing database or the group-to-RP mapping. Note that this transition does not occur if an Assert is active and the upstream interface does not change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;（*，G）的更改不是由于断言而导致的。发生了一个事件，导致G向RP的下一个跃点发生更改。这可能是由MRIB路由数据库或组到RP映射的更改引起的。请注意，如果断言处于活动状态且上游接口未更改，则不会发生此转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,G) state machine remains in Joined state. Send Join(*,G) to the new upstream neighbor, which is the new value of RPF&#39;(*,G). Send Prune(*,G) to the old upstream neighbor, which is the old value of RPF&#39;(*,G). Use the new value of RP(G) in the Prune(*,G) message or all zeros if RP(G) becomes unknown (old value of RP(G) may be used instead to improve behavior in routers implementing older versions of this spec). Set the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，G）状态机保持连接状态。将Join（*，G）发送到新的上游邻居，该邻居是RPF&#39;（*，G）的新值。将Prune（*，G）发送到旧的上游邻居，该邻居是RPF&#39;（*，G）的旧值。在Prune（*，G）消息中使用新的RP（G）值，如果RP（G）变得未知，则使用全零（可以使用旧的RP（G）值来改进路由器实现本规范旧版本的行为）。将加入计时器（JT）设置为在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(*,G) GenID changes The Generation ID of the router that is RPF&#39;(*,G) changes. This normally means that this neighbor has lost state, and so the state must be refreshed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;（*，G）GenID更改路由器的生成ID，即RPF&#39;（*，G）更改。这通常意味着该邻居已丢失状态，因此必须刷新状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (*,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（*，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.7. Sending (S,G) Join/Prune Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.7. 发送（S，G）加入/删除消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The per-interface state machines for (S,G) hold join state from downstream PIM routers. This state then determines whether a router needs to propagate a Join(S,G) upstream towards the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）的每个接口状态机保持来自下游PIM路由器的连接状态。然后，该状态确定路由器是否需要向上游向源传播连接（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a router wishes to propagate a Join(S,G) upstream, it must also watch for messages on its upstream interface from other routers on that subnet, and these may modify its behavior. If it sees a Join(S,G) to the correct upstream neighbor, it should suppress its own Join(S,G). If it sees a Prune(S,G), Prune(S,G,rpt), or Prune(*,G) to the correct upstream neighbor towards S, it should be prepared to override that prune by scheduling a Join(S,G) to be sent almost immediately. Finally, if it sees the Generation ID of its upstream neighbor change, it knows that the upstream neighbor has lost state, and it should refresh the state by scheduling a Join(S,G) to be sent almost immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果路由器希望向上游传播连接（S，G），它还必须在其上游接口上监视来自该子网上其他路由器的消息，这些消息可能会修改其行为。如果它看到一个连接（S，G）到正确的上游邻居，它应该抑制自己的连接（S，G）。如果它看到一个剪枝（S，G）、剪枝（S，G，rpt）或剪枝（*，G）指向正确的上游邻居，它应该准备好通过几乎立即发送连接（S，G）来覆盖该剪枝。最后，如果它看到其上游邻居的生成ID发生变化，它就知道上游邻居已丢失状态，它应该通过几乎立即发送连接（S，G）来刷新状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a (S,G) Assert occurs on the upstream interface, and this changes the this router&#39;s idea of the upstream neighbor, it should be prepared to ensure that the Assert winner is aware of downstream routers by scheduling a Join(S,G) to be sent almost immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果（S，G）断言发生在上游接口上，并且这改变了该路由器对上游邻居的看法，那么应该准备好通过几乎立即发送连接（S，G）来确保断言获胜者知道下游路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, if MRIB changes cause the next hop towards the source to change, and either the upstream interface changes or there is no Assert winner on the upstream interface, the router should send a prune to the old next hop and a join to the new next hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，如果MRIB更改导致到源的下一个跃点更改，并且上游接口更改或上游接口上没有断言赢家，则路由器应向旧的下一个跃点发送修剪，并向新的下一个跃点发送连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream (S,G) state machine only contains two states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游（S，G）状态机仅包含两种状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not Joined The downstream state machines and local membership information do not indicate that the router needs to join the shortest-path tree for this (S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未加入下游状态机和本地成员身份信息并不表示路由器需要加入此（S，G）的最短路径树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joined The downstream state machines and local membership information indicate that the router should join the shortest-path tree for this (S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加入下游状态机和本地成员信息表明路由器应加入此（S，G）的最短路径树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, one timer JT(S,G) is kept that is used to trigger the sending of a Join(S,G) to the upstream next hop towards S, RPF&#39;(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，保留一个计时器JT（S，G），用于触发向上游下一跳发送加入（S，G）到S，RPF’（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Figure 8: Upstream (S,G) state machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
图8：表格形式的上游（S，G）状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------+--------------------------------------------------+
|                   |                      Event                       |
|  Prev State       +-------------------------+------------------------+
|                   |   JoinDesired(S,G)      |   JoinDesired(S,G)     |
|                   |   -&gt;True                |   -&gt;False              |
+-------------------+-------------------------+------------------------+
|  NotJoined (NJ)   |   -&gt; J state            |   -                    |
|                   |   Send Join(S,G);       |                        |
|                   |   Set Join Timer to     |                        |
|                   |   t_periodic            |                        |
+-------------------+-------------------------+------------------------+
|  Joined (J)       |   -                     |   -&gt; NJ state          |
|                   |                         |   Send Prune(S,G);     |
|                   |                         |   Set SPTbit(S,G) to   |
|                   |                         |   FALSE; Cancel Join   |
|                   |                         |   Timer                |
+-------------------+-------------------------+------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------+--------------------------------------------------+
|                   |                      Event                       |
|  Prev State       +-------------------------+------------------------+
|                   |   JoinDesired(S,G)      |   JoinDesired(S,G)     |
|                   |   -&gt;True                |   -&gt;False              |
+-------------------+-------------------------+------------------------+
|  NotJoined (NJ)   |   -&gt; J state            |   -                    |
|                   |   Send Join(S,G);       |                        |
|                   |   Set Join Timer to     |                        |
|                   |   t_periodic            |                        |
+-------------------+-------------------------+------------------------+
|  Joined (J)       |   -                     |   -&gt; NJ state          |
|                   |                         |   Send Prune(S,G);     |
|                   |                         |   Set SPTbit(S,G) to   |
|                   |                         |   FALSE; Cancel Join   |
|                   |                         |   Timer                |
+-------------------+-------------------------+------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, we have the following transitions, which occur within the Joined state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，我们还有以下转换，它们发生在连接状态中：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+-----------------+-----------------+-----------------+----------------+
| Timer Expires   | See Join(S,G)   | See Prune(S,G)  | See Prune      |
|                 | to RPF&#39;(S,G)    | to RPF&#39;(S,G)    | (S,G,rpt) to   |
|                 |                 |                 | RPF&#39;(S,G)      |
+-----------------+-----------------+-----------------+----------------+
| Send            | Increase Join   | Decrease Join   | Decrease Join  |
| Join(S,G); Set  | Timer to        | Timer to        | Timer to       |
| Join Timer to   | t_joinsuppress  | t_override      | t_override     |
| t_periodic      |                 |                 |                |
+-----------------+-----------------+-----------------+----------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In Joined (J) State                          |
+-----------------+-----------------+-----------------+----------------+
| Timer Expires   | See Join(S,G)   | See Prune(S,G)  | See Prune      |
|                 | to RPF&#39;(S,G)    | to RPF&#39;(S,G)    | (S,G,rpt) to   |
|                 |                 |                 | RPF&#39;(S,G)      |
+-----------------+-----------------+-----------------+----------------+
| Send            | Increase Join   | Decrease Join   | Decrease Join  |
| Join(S,G); Set  | Timer to        | Timer to        | Timer to       |
| Join Timer to   | t_joinsuppress  | t_override      | t_override     |
| t_periodic      |                 |                 |                |
+-----------------+-----------------+-----------------+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                        In Joined (J) State                           |
+-----------------+-----------------+----------------+-----------------+
| See Prune(*,G)  | RPF&#39;(S,G)       | RPF&#39;(S,G)      | RPF&#39;(S,G)       |
| to RPF&#39;(S,G)    | changes not     | GenID changes  | changes due to  |
|                 | due to an       |                | an Assert       |
|                 | Assert          |                |                 |
+-----------------+-----------------+----------------+-----------------+
| Decrease Join   | Send Join(S,G)  | Decrease Join  | Decrease Join   |
| Timer to        | to new next     | Timer to       | Timer to        |
| t_override      | hop; Send       | t_override     | t_override      |
|                 | Prune(S,G) to   |                |                 |
|                 | old next hop;   |                |                 |
|                 | Set Join Timer  |                |                 |
|                 | to t_periodic   |                |                 |
+-----------------+-----------------+----------------+-----------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                        In Joined (J) State                           |
+-----------------+-----------------+----------------+-----------------+
| See Prune(*,G)  | RPF&#39;(S,G)       | RPF&#39;(S,G)      | RPF&#39;(S,G)       |
| to RPF&#39;(S,G)    | changes not     | GenID changes  | changes due to  |
|                 | due to an       |                | an Assert       |
|                 | Assert          |                |                 |
+-----------------+-----------------+----------------+-----------------+
| Decrease Join   | Send Join(S,G)  | Decrease Join  | Decrease Join   |
| Timer to        | to new next     | Timer to       | Timer to        |
| t_override      | hop; Send       | t_override     | t_override      |
|                 | Prune(S,G) to   |                |                 |
|                 | old next hop;   |                |                 |
|                 | Set Join Timer  |                |                 |
|                 | to t_periodic   |                |                 |
+-----------------+-----------------+----------------+-----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state machine uses the following macro:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态机使用以下宏：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool JoinDesired(S,G) {
         return( immediate_olist(S,G) != NULL
                 OR ( KeepaliveTimer(S,G) is running
                      AND inherited_olist(S,G) != NULL ) )
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool JoinDesired(S,G) {
         return( immediate_olist(S,G) != NULL
                 OR ( KeepaliveTimer(S,G) is running
                      AND inherited_olist(S,G) != NULL ) )
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JoinDesired(S,G) is true when the router has forwarding state that would cause it to forward traffic for G using source tree state. The source tree state can be as a result of either active source-specific join state, or the (S,G) Keepalive Timer and active non-source-specific state. Note that although JoinDesired is true, the router&#39;s sending of a Join(S,G) message may be suppressed by another router sending a Join(S,G) onto the upstream interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器的转发状态会导致它使用源树状态为G转发流量时，JoinDesired（S，G）为true。源树状态可以是活动的源特定连接状态，也可以是（S，G）Keepalive计时器和活动的非源特定状态的结果。注意，尽管JoinDesired为true，但路由器发送的连接（s，G）消息可能会被另一个向上游接口发送连接（s，G）的路由器抑制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NotJoined State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从未连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the upstream (S,G) state machine is in NotJoined state, the following event may trigger a state transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（S，G）状态机处于NotJoined状态时，以下事件可能触发状态转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired(S,G) becomes True The macro JoinDesired(S,G) becomes True, e.g., because the downstream state for (S,G) has changed so that at least one interface is in inherited_olist(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired（S，G）变为True宏JoinDesired（S，G）变为True，例如，因为（S，G）的下游状态已更改，因此至少有一个接口处于继承列表（S，G）中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine transitions to Joined state. Send Join(S,G) to the appropriate upstream neighbor, which is RPF&#39;(S,G). Set the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机转换为连接状态。将Join（S，G）发送到适当的上游邻居，即RPF&#39;（S，G）。将加入计时器（JT）设置为在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from Joined State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从连接状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the upstream (S,G) state machine is in Joined state, the following events may trigger state transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（S，G）状态机处于连接状态时，以下事件可能触发状态转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired(S,G) becomes False The macro JoinDesired(S,G) becomes False, e.g., because the downstream state for (S,G) has changed so no interface is in inherited_olist(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
JoinDesired（S，G）变为False宏JoinDesired（S，G）变为False，例如，因为（S，G）的下游状态已更改，因此没有接口位于继承的列表（S，G）中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine transitions to NotJoined state. Send Prune(S,G) to the appropriate upstream neighbor, which is RPF&#39;(S,G). Cancel the Join Timer (JT), and set SPTbit(S,G) to FALSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机转换为NotJoined状态。将Prune（S，G）发送到适当的上游邻居，即RPF&#39;（S，G）。取消连接计时器（JT），并将SPTbit（S，G）设置为FALSE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Join Timer Expires The Join Timer (JT) expires, indicating time to send a Join(S,G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
加入计时器过期加入计时器（JT）过期，表示发送加入的时间（S，G）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Send Join(S,G) to the appropriate upstream neighbor, which is RPF&#39;(S,G). Restart the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
将Join（S，G）发送到适当的上游邻居，即RPF&#39;（S，G）。重新启动加入计时器（JT），使其在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Join(S,G) to RPF&#39;(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Join(S,G) to RPF&#39;(S,G). This causes this router to suppress its own Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅将（S，G）连接到RPF&#39;（S，G）此事件仅在RPF_接口是共享介质时相关。此路由器看到RPF_接口上的另一个路由器向RPF&#39;（S，G）发送连接（S，G）。这会导致此路由器抑制其自身的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine remains in Joined state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机保持连接状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Let t_joinsuppress be the minimum of t_suppressed and the HoldTime from the Join/Prune message triggering this event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
让t_joinsuppress是触发此事件的Join/Prune消息中t_suppressed和HoldTime的最小值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
If the Join Timer is set to expire in less than t_joinsuppress seconds, reset it so that it expires after t_joinsuppress seconds. If the Join Timer is set to expire in more than t_joinsuppress seconds, leave it unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
如果连接计时器设置为在t_joinsuppress秒内过期，请重置它，使其在t_joinsuppress秒后过期。如果连接计时器设置为在超过t_秒后过期，请保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(S,G) to RPF&#39;(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(S,G) to RPF&#39;(S,G). As this router is in Joined state, it must override the Prune after a short random interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参见将（S，G）修剪为RPF’（S，G）。只有当RPF_接口是共享介质时，此事件才相关。此路由器看到RPF_接口上的另一个路由器向RPF&#39;（S，G）发送修剪（S，G）。由于此路由器处于连接状态，它必须在短的随机间隔后覆盖修剪。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(S,G,rpt) to RPF&#39;(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(S,G,rpt) to RPF&#39;(S,G). If the upstream router is an RFC-2362-compliant PIM router, then the Prune(S,G,rpt) will cause it to stop forwarding. For backwards compatibility, this router should override the prune so that forwarding continues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅将（S、G、rpt）修剪为RPF’（S、G）。只有当RPF_接口是共享介质时，此事件才相关。此路由器看到RPF_接口上的另一个路由器向RPF&#39;（S，G）发送修剪（S，G，rpt）。如果上游路由器是RFC-2362兼容的PIM路由器，则删减（S、G、rpt）将导致其停止转发。为了向后兼容，此路由器应覆盖修剪，以便继续转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(*,G) to RPF&#39;(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(*,G) to RPF&#39;(S,G). If the upstream router is an RFC-2362-compliant PIM router, then the Prune(*,G) will cause it to stop forwarding. For backwards compatibility, this router should override the prune so that forwarding continues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参见将（*，G）修剪为RPF&#39;（S，G）。只有当RPF_接口是共享介质时，此事件才相关。此路由器看到RPF_接口上的另一个路由器向RPF&#39;（S，G）发送修剪（*，G）。如果PIM-236路由器是兼容的，那么它将停止转发。为了向后兼容，此路由器应覆盖修剪，以便继续转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S,G) changes due to an Assert The current next hop towards S changes due to an Assert(S,G) on the RPF_interface(S).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;（S，G）因断言而更改当前的下一个跃点由于RPF_接口上的断言（S，G）而更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds. If the Join Timer is set to expire in less than t_override seconds, leave it unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。如果连接计时器设置为在不到t_override秒的时间内过期，请保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S,G) changes not due to an Assert An event occurred that caused the next hop towards S to change. Note that this transition does not occur if an Assert is active and the upstream interface does not change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;（S，G）的更改不是由于断言发生的事件导致下一个向S的跃点发生更改。请注意，如果断言处于活动状态且上游接口未更改，则不会发生此转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine remains in Joined state. Send Join(S,G) to the new upstream neighbor, which is the new value of RPF&#39;(S,G). Send Prune(S,G) to the old upstream neighbor, which is the old value of RPF&#39;(S,G). Set the Join Timer (JT) to expire after t_periodic seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机保持连接状态。将Join（S，G）发送到新的上游邻居，这是RPF&#39;（S，G）的新值。将Prune（S，G）发送到旧的上游邻居，这是RPF&#39;（S，G）的旧值。将加入计时器（JT）设置为在t_周期秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S,G) GenID changes The Generation ID of the router that is RPF&#39;(S,G) changes. This normally means that this neighbor has lost state, and so the state must be refreshed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;（S，G）GenID更改路由器的生成ID，即RPF&#39;（S，G）更改。这通常意味着该邻居已丢失状态，因此必须刷新状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
The upstream (S,G) state machine remains in Joined state. If the Join Timer is set to expire in more than t_override seconds, reset it so that it expires after t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
上游（S，G）状态机保持连接状态。如果连接计时器设置为在超过t_override秒后过期，请重置它，使其在t_override秒后过期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.8. (S,G,rpt) Periodic Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.8. （S、G、rpt）定期消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G,rpt) Joins and Prunes are (S,G) Joins or Prunes sent on the RP tree with the RPT bit set, either to modify the results of (*,G) Joins, or to override the behavior of other upstream LAN peers. The next section describes the rules for sending triggered messages. This section describes the rules for including a Prune(S,G,rpt) message with a Join(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G，rpt）连接和修剪是在RP树上发送的带有rpt位集的（S，G）连接或修剪，用于修改（*，G）连接的结果，或覆盖其他上游LAN对等方的行为。下一节介绍发送触发消息的规则。本节描述了包含带有连接（*，G）的Prune（S，G，rpt）消息的规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a router is going to send a Join(*,G), it should use the following pseudocode, for each (S,G) for which it has state, to decide whether to include a Prune(S,G,rpt) in the compound Join/Prune message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器要发送连接（*，G）时，它应该为其具有状态的每个（S，G）使用以下伪代码来决定是否在复合连接/删除消息中包括删除（S，G，rpt）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if( SPTbit(S,G) == TRUE ) {
         # Note: If receiving (S,G) on the SPT, we only prune off the
         # shared tree if the RPF neighbors differ.
          if( RPF&#39;(*,G) != RPF&#39;(S,G) ) {
              add Prune(S,G,rpt) to compound message
          }
     } else if ( inherited_olist(S,G,rpt) == NULL ) {
       # Note: all (*,G) olist interfaces received RPT prunes for (S,G).
       add Prune(S,G,rpt) to compound message
     } else if ( RPF&#39;(*,G) != RPF&#39;(S,G,rpt) {
       # Note: we joined the shared tree, but there was an (S,G) assert
       # and the source tree RPF neighbor is different.
       add Prune(S,G,rpt) to compound message
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if( SPTbit(S,G) == TRUE ) {
         # Note: If receiving (S,G) on the SPT, we only prune off the
         # shared tree if the RPF neighbors differ.
          if( RPF&#39;(*,G) != RPF&#39;(S,G) ) {
              add Prune(S,G,rpt) to compound message
          }
     } else if ( inherited_olist(S,G,rpt) == NULL ) {
       # Note: all (*,G) olist interfaces received RPT prunes for (S,G).
       add Prune(S,G,rpt) to compound message
     } else if ( RPF&#39;(*,G) != RPF&#39;(S,G,rpt) {
       # Note: we joined the shared tree, but there was an (S,G) assert
       # and the source tree RPF neighbor is different.
       add Prune(S,G,rpt) to compound message
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that Join(S,G,rpt) is normally sent not as a periodic message, but only as a triggered message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，Join（S、G、rpt）通常不作为定期消息发送，而仅作为触发消息发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.9. State Machine for (S,G,rpt) Triggered Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.9. （S、G、rpt）触发消息的状态机
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state machine for (S,G,rpt) triggered messages is required per-(S,G) when there is (*,G) or (*,*,RP) join state at a router, and the router or any of its upstream LAN peers wishes to prune S off the RP tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器处存在（*，G）或（*，*，RP）连接状态，并且路由器或其任何上游LAN对等方希望从RP树中剪除S时，根据-（S，G）需要（S，G，rpt）触发消息的状态机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are three states in the state machine. One of the states is when there is neither (*,G) nor (*,*,RP(G)) join state at this router. If there is (*,G) or (*,*,RP(G)) join state at the router, then the state machine must be at one of the other two states. The three states are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态机中有三种状态。其中一种状态是当此路由器上既没有（*，G）也没有（*，*，RP（G））连接状态时。如果路由器上存在（*，G）或（*，*，RP（G））连接状态，则状态机必须处于其他两种状态之一。这三个州是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pruned(S,G,rpt)
      (*,G) or (*,*,RP(G)) Joined, but (S,G,rpt) pruned
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Pruned(S,G,rpt)
      (*,G) or (*,*,RP(G)) Joined, but (S,G,rpt) pruned
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   NotPruned(S,G,rpt)
      (*,G) or (*,*,RP(G)) Joined, and (S,G,rpt) not pruned
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   NotPruned(S,G,rpt)
      (*,G) or (*,*,RP(G)) Joined, and (S,G,rpt) not pruned
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPTNotJoined(G) neither (*,G) nor (*,*,RP(G)) has been joined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPTNotJoined（G）未连接（*，G）或（*，*，RP（G））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there is an (S,G,rpt) Override Timer, OT(S,G,rpt), which is used to delay triggered Join(S,G,rpt) messages to prevent implosions of triggered messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有一个（S，G，rpt）覆盖计时器OT（S，G，rpt），用于延迟触发的连接（S，G，rpt）消息，以防止触发的消息内爆。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 9: Upstream (S,G,rpt) state machine for triggered messages in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图9：表格形式触发消息的上游（S、G、rpt）状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                           Event                        |
|            ++--------------+--------------+-------------+------------+
|Prev State  || PruneDesired | PruneDesired | RPTJoin     | inherited_ |
|            || (S,G,rpt)    | (S,G,rpt)    | Desired(G)  | olist      |
|            || -&gt;True       | -&gt;False      | -&gt;False     | (S,G,rpt)  |
|            ||              |              |             | -&gt;non-NULL |
+------------++--------------+--------------+-------------+------------+
|RPTNotJoined|| -&gt; P state   | -            | -           | -&gt; NP state|
|(G) (NJ)    ||              |              |             |            |
+------------++--------------+--------------+-------------+------------+
|Pruned      || -            | -&gt; NP state  | -&gt; NJ state | -          |
|(S,G,rpt)   ||              | Send Join    |             |            |
|(P)         ||              | (S,G,rpt)    |             |            |
+------------++--------------+--------------+-------------+------------+
|NotPruned   || -&gt; P state   | -            | -&gt; NJ state | -          |
|(S,G,rpt)   || Send Prune   |              | Cancel OT   |            |
|(NP)        || (S,G,rpt);   |              |             |            |
|            || Cancel OT    |              |             |            |
+------------++--------------+--------------+-------------+------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+------------++--------------------------------------------------------+
|            ||                           Event                        |
|            ++--------------+--------------+-------------+------------+
|Prev State  || PruneDesired | PruneDesired | RPTJoin     | inherited_ |
|            || (S,G,rpt)    | (S,G,rpt)    | Desired(G)  | olist      |
|            || -&gt;True       | -&gt;False      | -&gt;False     | (S,G,rpt)  |
|            ||              |              |             | -&gt;non-NULL |
+------------++--------------+--------------+-------------+------------+
|RPTNotJoined|| -&gt; P state   | -            | -           | -&gt; NP state|
|(G) (NJ)    ||              |              |             |            |
+------------++--------------+--------------+-------------+------------+
|Pruned      || -            | -&gt; NP state  | -&gt; NJ state | -          |
|(S,G,rpt)   ||              | Send Join    |             |            |
|(P)         ||              | (S,G,rpt)    |             |            |
+------------++--------------+--------------+-------------+------------+
|NotPruned   || -&gt; P state   | -            | -&gt; NJ state | -          |
|(S,G,rpt)   || Send Prune   |              | Cancel OT   |            |
|(NP)        || (S,G,rpt);   |              |             |            |
|            || Cancel OT    |              |             |            |
+------------++--------------+--------------+-------------+------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, we have the following transitions within the NotPruned(S,G,rpt) state, which are all used for prune override behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，我们在NotPruned（S、G、rpt）状态中有以下转换，它们都用于修剪覆盖行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                    In NotPruned(S,G,rpt) State                       |
+----------+--------------+--------------+--------------+--------------+
|Override  | See Prune    | See Join     | See Prune    | RPF&#39;         |
|Timer     | (S,G,rpt) to | (S,G,rpt) to | (S,G) to     | (S,G,rpt) -&gt; |
|expires   | RPF&#39;         | RPF&#39;         | RPF&#39;         | RPF&#39; (*,G)   |
|          | (S,G,rpt)    | (S,G,rpt)    | (S,G,rpt)    |              |
+----------+--------------+--------------+--------------+--------------+
|Send Join | OT = min(OT, | Cancel OT    | OT = min(OT, | OT = min(OT, |
|(S,G,rpt);| t_override)  |              | t_override)  | t_override)  |
|Leave OT  |              |              |              |              |
|unset     |              |              |              |              |
+----------+--------------+--------------+--------------+--------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                    In NotPruned(S,G,rpt) State                       |
+----------+--------------+--------------+--------------+--------------+
|Override  | See Prune    | See Join     | See Prune    | RPF&#39;         |
|Timer     | (S,G,rpt) to | (S,G,rpt) to | (S,G) to     | (S,G,rpt) -&gt; |
|expires   | RPF&#39;         | RPF&#39;         | RPF&#39;         | RPF&#39; (*,G)   |
|          | (S,G,rpt)    | (S,G,rpt)    | (S,G,rpt)    |              |
+----------+--------------+--------------+--------------+--------------+
|Send Join | OT = min(OT, | Cancel OT    | OT = min(OT, | OT = min(OT, |
|(S,G,rpt);| t_override)  |              | t_override)  | t_override)  |
|Leave OT  |              |              |              |              |
|unset     |              |              |              |              |
+----------+--------------+--------------+--------------+--------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the min function in the above state machine considers a non-running timer to have an infinite value (e.g., min(not-running, t_override) = t_override).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，上述状态机中的min函数认为非运行计时器具有无穷大的值（例如，min（未运行，t_覆盖）=t_覆盖）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This state machine uses the following macros:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此状态机使用以下宏：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool RPTJoinDesired(G) {
       return (JoinDesired(*,G) OR JoinDesired(*,*,RP(G)))
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool RPTJoinDesired(G) {
       return (JoinDesired(*,G) OR JoinDesired(*,*,RP(G)))
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPTJoinDesired(G) is true when the router has forwarding state that would cause it to forward traffic for G using either (*,G) or (*,*,RP) shared tree state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当路由器的转发状态会导致它使用（*，G）或（*，*，RP）共享树状态为G转发流量时，RPTJoinDesired（G）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool PruneDesired(S,G,rpt) {
          return ( RPTJoinDesired(G) AND
                   ( inherited_olist(S,G,rpt) == NULL
                     OR (SPTbit(S,G)==TRUE
                         AND (RPF&#39;(*,G) != RPF&#39;(S,G)) )))
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool PruneDesired(S,G,rpt) {
          return ( RPTJoinDesired(G) AND
                   ( inherited_olist(S,G,rpt) == NULL
                     OR (SPTbit(S,G)==TRUE
                         AND (RPF&#39;(*,G) != RPF&#39;(S,G)) )))
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PruneDesired(S,G,rpt) can only be true if RPTJoinDesired(G) is true. If RPTJoinDesired(G) is true, then PruneDesired(S,G,rpt) is true either if there are no outgoing interfaces that S would be forwarded on, or if the router has active (S,G) forwarding state but RPF&#39;(*,G) != RPF&#39;(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仅当RPTJoinDesired（G）为true时，PruneDesired（S、G、rpt）才可以为true。如果RPTJoinDesired（G）为true，则如果没有将转发S的传出接口，或者如果路由器具有活动（S，G）转发状态但RPF&#39;（*，G）！=RPF’（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state machine contains the following transition events:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态机包含以下转换事件：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Join(S,G,rpt) to RPF&#39;(S,G,rpt) This event is only relevant in the &#34;Not Pruned&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请参阅将（S，G，rpt）加入RPF’（S，G，rpt）。此事件仅在“未修剪”状态下相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The router sees a Join(S,G,rpt) from someone else to RPF&#39;(S,G,rpt), which is the correct upstream neighbor. If we&#39;re in &#34;NotPruned&#34; state and the (S,G,rpt) Override Timer is running, then this is because we have been triggered to send our own Join(S,G,rpt) to RPF&#39;(S,G,rpt). Someone else beat us to it, so there&#39;s no need to send our own Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器看到从其他人到RPF（S，G，rpt）的连接（S，G，rpt），RPF是正确的上游邻居。如果我们处于“NotPruned”状态，并且（S，G，rpt）覆盖计时器正在运行，那么这是因为我们被触发将自己的加入（S，G，rpt）发送到RPF&#39;（S，G，rpt）。有人比我们抢先一步，所以没有必要让我们自己加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The action is to cancel the Override Timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
操作是取消覆盖计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Prune(S,G,rpt) to RPF&#39;(S,G,rpt) This event is only relevant in the &#34;NotPruned&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请参阅从修剪（S，G，rpt）到RPF’（S，G，rpt）此事件仅在“未修剪”状态下相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The router sees a Prune(S,G,rpt) from someone else to RPF&#39;(S,G,rpt), which is the correct upstream neighbor. If we&#39;re in the &#34;NotPruned&#34; state, then we want to continue to receive traffic from S destined for G, and that traffic is being supplied by RPF&#39;(S,G,rpt). Thus, we need to override the Prune.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器看到从其他人到RPF（S，G，rpt）的剪枝（S，G，rpt），RPF是正确的上游邻居。如果我们处于“NotPruned”状态，那么我们希望继续接收来自发送到G的S的流量，并且该流量由RPF（S，G，rpt）提供。因此，我们需要覆盖修剪。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The action is to set the (S,G,rpt) Override Timer to the randomized prune-override interval, t_override. However, if the Override Timer is already running, we only set the timer if doing so would set it to a lower value. At the end of this interval, if noone else has sent a Join, then we will do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
操作是将（S、G、rpt）覆盖计时器设置为随机修剪覆盖间隔t_覆盖。但是，如果覆盖计时器已经在运行，我们只会在这样做会将其设置为较低值时设置计时器。在此间隔结束时，如果没有其他人发送了加入，那么我们将这样做。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See Prune(S,G) to RPF&#39;(S,G,rpt) This event is only relevant in the &#34;NotPruned&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请参阅将（S，G）修剪为RPF’（S，G，rpt）。此事件仅在“未修剪”状态下相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
This transition and action are the same as the above transition and action, except that the Prune does not have the RPT bit set. This transition is necessary to be compatible with routers implemented from RFC2362 that don&#39;t maintain separate (S,G) and (S,G,rpt) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
此转换和操作与上述转换和操作相同，只是修剪没有设置RPT位。此转换对于与从RFC2362实现的路由器兼容是必要的，这些路由器不保持单独的（S，G）和（S，G，rpt）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (S,G,rpt) prune Override Timer expires This event is only relevant in the &#34;NotPruned&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S、G、rpt）修剪覆盖计时器过期此事件仅在“NotPruned”状态下相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When the Override Timer expires, we must send a Join(S,G,rpt) to RPF&#39;(S,G,rpt) to override the Prune message that caused the timer to be running. We only send this if RPF&#39;(S,G,rpt) equals RPF&#39;(*,G); if this were not the case, then the Join might be sent to a router that does not have (*,G) or (*,*,RP(G)) Join state, and so the behavior would not be well defined. If RPF&#39;(S,G,rpt) is not the same as RPF&#39;(*,G), then it may stop forwarding S. However, if this happens, then the router will send an AssertCancel(S,G), which would then cause RPF&#39;(S,G,rpt) to become equal to RPF&#39;(*,G) (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
当覆盖计时器过期时，我们必须向RPF&#39;（S，G，rpt）发送一个连接（S，G，rpt），以覆盖导致计时器运行的修剪消息。我们只在RPF&#39;（S，G，rpt）等于RPF&#39;（*，G）时发送此消息；如果不是这种情况，那么连接可能被发送到没有（*，G）或（*，*，RP（G））连接状态的路由器，因此行为将无法很好地定义。如果RPF&#39;（S，G，rpt）与RPF&#39;（*，G）不同，则可能会停止转发S。但是，如果发生这种情况，则路由器将发送一个AssertCancel（S，G），这将导致RPF&#39;（S，G，rpt）与RPF&#39;（*，G）相等（见下文）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF&#39;(S,G,rpt) changes to become equal to RPF&#39;(*,G) This event is only relevant in the &#34;NotPruned&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPF&#39;（S，G，rpt）更改为等于RPF&#39;（*，G）。此事件仅在“未修剪”状态下相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
RPF&#39;(S,G,rpt) can only be different from RPF&#39;(*,G) if an (S,G) Assert has happened, which means that traffic from S is arriving on the SPT, and so Prune(S,G,rpt) will have been sent to RPF&#39;(*,G). When RPF&#39;(S,G,rpt) changes to become equal to RPF&#39;(*,G), we need to trigger a Join(S,G,rpt) to RPF&#39;(*,G) to cause that router to start forwarding S again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果发生（S，G）断言，则RPF&#39;（S，G，rpt）只能与RPF&#39;（*，G）不同，这意味着来自S的流量将到达SPT，因此Prune（S，G，rpt）将被发送到RPF&#39;（*，G）。当RPF&#39;（S，G，rpt）变为等于RPF&#39;（*，G）时，我们需要触发到RPF&#39;（*，G）的连接（S，G，rpt），以使路由器再次开始转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The action is to set the (S,G,rpt) Override Timer to the randomized prune-override interval t_override. However, if the timer is already running, we only set the timer if doing so would set it to a lower value. At the end of this interval, if noone else has sent a Join, then we will do so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
操作是将（S、G、rpt）覆盖计时器设置为随机修剪覆盖间隔t_覆盖。但是，如果计时器已经在运行，我们只会在这样做会将其设置为较低值时设置计时器。在此间隔结束时，如果没有其他人发送了加入，那么我们将这样做。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PruneDesired(S,G,rpt)-&gt;TRUE See macro above. This event is relevant in the &#34;NotPruned&#34; and &#34;RPTNotJoined(G)&#34; states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PruneDesired（S、G、rpt）-&gt;TRUE请参见上面的宏。此事件与“未删减”和“未加入（G）”状态相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The router wishes to receive traffic for G, but does not wish to receive traffic from S destined for G. This causes the router to transition into the Pruned state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器希望接收G的通信量，但不希望接收来自G的S的通信量。这会导致路由器转换到修剪状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the router was previously in NotPruned state, then the action is to send a Prune(S,G,rpt) to RPF&#39;(S,G,rpt), and to cancel the Override Timer. If the router was previously in RPTNotJoined(G) state, then there is no need to trigger an action in this state machine because sending a Prune(S,G,rpt) is handled by the rules for sending the Join(*,G) or Join(*,*,RP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果路由器以前处于NotPruned状态，则操作是向RPF&#39;（S，G，rpt）发送一个修剪（S，G，rpt），并取消覆盖计时器。如果路由器以前处于RPTNotJoin（G）状态，则无需在此状态机中触发操作，因为发送剪枝（S、G、rpt）由发送连接（*，G）或连接（*，*，RP）的规则处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PruneDesired(S,G,rpt)-&gt;FALSE See macro above. This transition is only relevant in the &#34;Pruned&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PruneDesired（S、G、rpt）-&gt;错误请参见上面的宏。此转换仅在“修剪”状态下相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the router is in the Pruned(S,G,rpt) state, and PruneDesired(S,G,rpt) changes to FALSE, this could be because the router no longer has RPTJoinDesired(G) true, or it now wishes to receive traffic from S again. If it is the former, then this transition should not happen, but instead the &#34;RPTJoinDesired(G)-&gt;FALSE&#34; transition should happen. Thus, this transition should be interpreted as &#34;PruneDesired(S,G,rpt)-&gt;FALSE AND RPTJoinDesired(G)==TRUE&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果路由器处于删减（S，G，rpt）状态，并且删减所需（S，G，rpt）更改为FALSE，这可能是因为路由器不再具有所需（G）true，或者它现在希望再次从S接收流量。如果是前者，则不应发生此转换，而是应发生“RPTJoinDesired（G）-&gt;FALSE”转换。因此，此转换应解释为“PruneDesired（S，G，rpt）-&gt;FALSE和RPTJoinDesired（G）=TRUE”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The action is to send a Join(S,G,rpt) to RPF&#39;(S,G,rpt).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
操作是将联接（S，G，rpt）发送到RPF’（S，G，rpt）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPTJoinDesired(G)-&gt;FALSE This event is relevant in the &#34;Pruned&#34; and &#34;NotPruned&#34; states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPTJoinDesired（G）-&gt;FALSE此事件与“已修剪”和“未修剪”状态相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The router no longer wishes to receive any traffic destined for G on the RP Tree. This causes a transition to the RPTNotJoined(G) state, and the Override Timer is canceled if it was running. Any further actions are handled by the appropriate upstream state machine for (*,G) or (*,*,RP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器不再希望接收RP树上发送给G的任何通信量。这会导致转换到RPTNotJoined（G）状态，如果覆盖计时器正在运行，则会取消覆盖计时器。任何进一步的操作都由（*，G）或（*，*，RP）的相应上游状态机处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
inherited_olist(S,G,rpt) becomes non-NULL This transition is only relevant in the RPTNotJoined(G) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
继承的列表（S、G、rpt）变为非空此转换仅在RPTNotJoined（G）状态下相关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The router has joined the RP tree (handled by the (*,G) or (*,*,RP) upstream state machine as appropriate) and wants to receive traffic from S. This does not trigger any events in this state machine, but causes a transition to the NotPruned(S,G,rpt) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
路由器已加入RP树（由（*，G）或（*，*，RP）上游状态机处理（视情况而定），并希望从S接收流量。这不会触发此状态机中的任何事件，但会导致转换到NotPruned（S，G，rpt）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.10. Background: (*,*,RP) and (S,G,rpt) Interaction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.10. 背景：（*，*，RP）和（S，G，rpt）相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Sections 4.5.8 and 4.5.9, the mechanisms for sending periodic and triggered (S,G,rpt) messages are described. The astute reader will note that periodic Prune(S,G,rpt) messages are only sent in PIM Join/Prune messages containing a Join(*,G), whereas it is possible for a triggered Prune(S,G,rpt) message to be sent when the router has no (*,G) join state. This may seem like a contradiction, but in fact it is intentional and is a side effect of not optimizing (*,*,RP) behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第4.5.8节和第4.5.9节中，描述了发送定期和触发（S、G、rpt）消息的机制。机敏的读者会注意到，周期性修剪（S，G，rpt）消息仅在包含连接（*，G）的PIM连接/修剪消息中发送，而当路由器没有（*，G）连接状态时，可能会发送触发的修剪（S，G，rpt）消息。这似乎是一个矛盾，但事实上这是故意的，是不优化（*，*，RP）行为的副作用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We first note that reception of a Join(*,*,RP) by itself does not cancel (S,G,rpt) prune state on that interface, whereas receiving a Join(*,G) by itself does cancel (S,G,rpt) prune state on that interface. Similarly, reception of a Prune(*,G) on an interface with (*,*,RP) join state does not by itself prevent forwarding of G using the (*,*,RP) state; this is because a Prune(*,G) only serves to cancel (*,G) join state. Conceptually (*,*,RP) state functions &#34;above&#34; the normal (*,G) and (S,G) mechanisms, and so neither Join(*,*,RP) nor Prune(*,*,RP) messages affect any other state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们首先注意到，单独接收连接（*，*，RP）不会取消该接口上的（S，G，rpt）修剪状态，而单独接收连接（*，G）会取消该接口上的（S，G，rpt）修剪状态。类似地，在具有（*，*，RP）连接状态的接口上接收修剪（*，G）本身并不阻止使用（*，*，RP）状态转发G；这是因为修剪（*，G）只用于取消（*，G）连接状态。从概念上讲（*，*，RP）状态函数“高于”正常（*，G）和（S，G）机制，因此连接（*，*，RP）和删除（*，*，RP）消息都不会影响任何其他状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upshot of this is that to prevent forwarding (S,G) on (*,*,RP) state, a Prune(S,G,rpt) must be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其结果是为了防止（*，*，RP）状态下的转发（S，G），必须使用Prune（S，G，rpt）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We also note that for historical reasons there is no Assert(*,*,RP) message, so any forwarding contention is resolved using Assert(*,G) messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们还注意到，由于历史原因，没有Assert（*，*，RP）消息，因此任何转发争用都是使用Assert（*，G）消息解决的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We now need to consider the interaction between (*,*,RP) state and (*,G) state. If there is a need for an assert between two upstream routers on a LAN, we need to ensure that the correct thing happens for all combinations of (*,*,RP) and (*,G) forwarding state. As there is no Assert(*,*,RP) message, no router can tell whether the assert winner has (*,*,RP) state or (*,G) state. Thus, a downstream router has to treat the two the same and send its periodic Prune(S,G,rpt) messages to RPF&#39;(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们现在需要考虑（*，*，RP）状态和（*，g）状态之间的相互作用。如果在局域网上的两个上游路由器之间需要断言，我们需要确保（*，*，RP）和（*，G）转发状态的所有组合都正确。由于没有Assert（*，*，RP）消息，因此没有路由器可以判断Assert获胜者是处于（*，*，RP）状态还是处于（*，G）状态。因此，下游路由器必须将两者视为相同的，并向RPF&#39;（*，G）发送其周期性修剪（S，G，rpt）消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid needing to specify all the complex override rules between (*,*,RP), (*,G), and (S,G,rpt), we simply require that to prune (S,G) off the (*,*,RP) tree, a Join(*,G) must also be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了避免需要指定（*，*，RP），（*，G）和（S，G，rpt）之间的所有复杂覆盖规则，我们只需要将（S，G）从（*，*，RP）树中剪除，还必须发送连接（*，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a router is receiving on (*,*,RP) state and has not yet had (*,G) state instantiated, it may still need to send a triggered Join(S,G,rpt) to override a Prune(S,G,rpt) that it sees directed to RPF&#39;(*,G) on its upstream interface. Hence, triggered (S,G,rpt) messages may be sent when JoinDesired(*,G) is false but JoinDesired(*,*,RP) is true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果路由器正在接收（*，*，RP）状态，并且尚未实例化（*，G）状态，它可能仍然需要发送一个触发的连接（S，G，rpt），以覆盖它在其上游接口上看到的指向RPF&#39;（*，G）的修剪（S，G，rpt）。因此，当JoinDesired（*，G）为false但JoinDesired（*，*，RP）为true时，可以发送触发的（S，G，rpt）消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, we note that there is an unoptimized case when the upstream router on a LAN already has (*,G) join and (S,G,rpt) prune state caused by an existing downstream router. If at this time a new Join(*,*,RP) is sent to the upstream router from a different downstream router, this will not override the (S,G,rpt) prune state at the upstream router. The override will not occur until the next time the original downstream router resends its Prune(S,G,rpt). This case was not considered worth optimizing, as (*,*,RP) state is generally very long lived, and so any minor delays in getting traffic to a new PMBR seem unimportant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，我们注意到，当LAN上的上游路由器已经有（*，G）连接和（S，G，rpt）剪枝状态时，存在一个未优化的情况，该状态由现有的下游路由器引起。如果此时从不同的下游路由器向上游路由器发送一个新的连接（*，*，RP），这将不会覆盖上游路由器的（S，G，rpt）修剪状态。直到下一次原始下游路由器重新发送其修剪（S、G、rpt）时，覆盖才会发生。这种情况不值得优化，因为（*，*，RP）状态通常寿命很长，因此将流量传输到新PMBR的任何微小延迟似乎都不重要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. PIM Assert Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. PIM断言消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where multiple PIM routers peer over a shared LAN, it is possible for more than one upstream router to have valid forwarding state for a packet, which can lead to packet duplication (see Section 3.6). PIM does not attempt to prevent this from occurring. Instead, it detects when this has happened and elects a single forwarder amongst the upstream routers to prevent further duplication. This election is performed using PIM Assert messages. Assert messages are also received by downstream routers on the LAN, and these cause subsequent Join/Prune messages to be sent to the upstream router that won the Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果多个PIM路由器在共享LAN上对等，则可能有多个上游路由器具有数据包的有效转发状态，这可能导致数据包重复（参见第3.6节）。PIM不会试图阻止这种情况发生。相反，它检测何时发生这种情况，并在上游路由器中选择一个转发器以防止进一步的重复。此选择使用PIM Assert消息执行。LAN上的下游路由器也会接收断言消息，这些消息会导致后续的加入/删减消息发送到赢得断言的上游路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, a PIM Assert message should only be accepted for processing if it comes from a known PIM neighbor. A PIM router hears about PIM neighbors through PIM Hello messages. If a router receives an Assert message from a particular IP source address and it has not seen a PIM Hello message from that source address, then the Assert message SHOULD be discarded without further processing. In addition, if the Hello message from a neighbor was authenticated using the IPsec Authentication Header (AH) (see Section 6.3), then all Assert messages from that neighbor MUST also be authenticated using IPsec AH.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常，只有来自已知PIM邻居的PIM Assert消息才应被接受处理。PIM路由器通过PIM Hello消息听到PIM邻居的消息。如果路由器接收到来自特定IP源地址的断言消息，但它没有看到来自该源地址的PIM Hello消息，则断言消息应被丢弃，无需进一步处理。此外，如果使用IPsec身份验证头（AH）对来自邻居的Hello消息进行了身份验证（请参见第6.3节），则来自该邻居的所有断言消息也必须使用IPsec AH进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that some older PIM implementations incorrectly fail to send Hello messages on point-to-point interfaces, so we also RECOMMEND that a configuration option be provided to allow interoperation with such older routers, but that this configuration option SHOULD NOT be enabled by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们注意到，一些较旧的PIM实现错误地无法在点到点接口上发送Hello消息，因此我们还建议提供一个配置选项，以允许与此类较旧的路由器进行互操作，但默认情况下不应启用此配置选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. (S,G) Assert Message State Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. （S，G）断言消息状态机
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (S,G) Assert state machine for interface I is shown in Figure 10. There are three states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接口I的（S，G）断言状态机如图10所示。有三个州：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NoInfo (NI) This router has no (S,G) assert state on interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NoInfo（NI）此路由器在接口I上没有（S，G）断言状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I am Assert Winner (W) This router has won an (S,G) assert on interface I. It is now responsible for forwarding traffic from S destined for G out of interface I. Irrespective of whether it is the DR for I, while a router is the assert winner, it is also responsible for forwarding traffic onto I on behalf of local hosts on I that have made membership requests that specifically refer to S (and G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我是断言赢家（W）此路由器在接口I上赢得了一个（S，G）断言。它现在负责将S发送到G的流量从接口I转发出去。无论它是否是I的DR，而路由器是断言赢家，它还负责代表I上的本地主机将流量转发到I上，这些主机发出了专门涉及S（和G）的成员资格请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I am Assert Loser (L) This router has lost an (S,G) assert on interface I. It must not forward packets from S destined for G onto interface I. If it is the DR on I, it is no longer responsible for forwarding traffic onto I to satisfy local hosts with membership requests that specifically refer to S and G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我是Assert Loser（L）此路由器在接口I上丢失了一个（S，G）Assert。它不能将数据包从S转发到接口I上。如果它是I上的DR，它将不再负责将流量转发到I上，以满足本地主机对S和G的成员资格请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there is also an Assert Timer (AT) that is used to time out asserts on the assert losers and to resend asserts on the assert winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有一个断言计时器（AT），用于超时断言失败者的断言，并重新发送断言成功者的断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
Figure 10: Per-interface (S,G) Assert State machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
图10：每个接口（S，G）以表格形式断言状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In NoInfo (NI) State                         |
+---------------+-------------------+------------------+---------------+
| Receive       |  Receive Assert   |  Data arrives    |  Receive      |
| Inferior      |  with RPTbit      |  from S to G on  |  Acceptable   |
| Assert with   |  set and          |  I and           |  Assert with  |
| RPTbit clear  |  CouldAssert      |  CouldAssert     |  RPTbit clear |
| and           |  (S,G,I)          |  (S,G,I)         |  and AssTrDes |
| CouldAssert   |                   |                  |  (S,G,I)      |
| (S,G,I)       |                   |                  |               |
+---------------+-------------------+------------------+---------------+
| -&gt; W state    |  -&gt; W state       |  -&gt; W state      |  -&gt; L state   |
| [Actions A1]  |  [Actions A1]     |  [Actions A1]    |  [Actions A6] |
+---------------+-------------------+------------------+---------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In NoInfo (NI) State                         |
+---------------+-------------------+------------------+---------------+
| Receive       |  Receive Assert   |  Data arrives    |  Receive      |
| Inferior      |  with RPTbit      |  from S to G on  |  Acceptable   |
| Assert with   |  set and          |  I and           |  Assert with  |
| RPTbit clear  |  CouldAssert      |  CouldAssert     |  RPTbit clear |
| and           |  (S,G,I)          |  (S,G,I)         |  and AssTrDes |
| CouldAssert   |                   |                  |  (S,G,I)      |
| (S,G,I)       |                   |                  |               |
+---------------+-------------------+------------------+---------------+
| -&gt; W state    |  -&gt; W state       |  -&gt; W state      |  -&gt; L state   |
| [Actions A1]  |  [Actions A1]     |  [Actions A1]    |  [Actions A6] |
+---------------+-------------------+------------------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                   In I Am Assert Winner (W) State                    |
+----------------+------------------+-----------------+----------------+
| Assert Timer   |   Receive        |  Receive        |  CouldAssert   |
| Expires        |   Inferior       |  Preferred      |  (S,G,I) -&gt;    |
|                |   Assert         |  Assert         |  FALSE         |
+----------------+------------------+-----------------+----------------+
| -&gt; W state     |   -&gt; W state     |  -&gt; L state     |  -&gt; NI state   |
| [Actions A3]   |   [Actions A3]   |  [Actions A2]   |  [Actions A4]  |
+----------------+------------------+-----------------+----------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                   In I Am Assert Winner (W) State                    |
+----------------+------------------+-----------------+----------------+
| Assert Timer   |   Receive        |  Receive        |  CouldAssert   |
| Expires        |   Inferior       |  Preferred      |  (S,G,I) -&gt;    |
|                |   Assert         |  Assert         |  FALSE         |
+----------------+------------------+-----------------+----------------+
| -&gt; W state     |   -&gt; W state     |  -&gt; L state     |  -&gt; NI state   |
| [Actions A3]   |   [Actions A3]   |  [Actions A2]   |  [Actions A4]  |
+----------------+------------------+-----------------+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------------------------------------------------+
|                   In I Am Assert Loser (L) State                    |
+-------------+-------------+-------------+-------------+-------------+
|Receive      |Receive      |Receive      |Assert Timer |Current      |
|Preferred    |Acceptable   |Inferior     |Expires      |Winner&#39;s     |
|Assert       |Assert with  |Assert or    |             |GenID        |
|             |RPTbit clear |Assert       |             |Changes or   |
|             |from Current |Cancel from  |             |NLT Expires  |
|             |Winner       |Current      |             |             |
|             |             |Winner       |             |             |
+-------------+-------------+-------------+-------------+-------------+
|-&gt; L state   |-&gt; L state   |-&gt; NI state  |-&gt; NI state  |-&gt; NI state  |
|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |
+-------------+-------------+-------------+-------------+-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------------------------------------------------+
|                   In I Am Assert Loser (L) State                    |
+-------------+-------------+-------------+-------------+-------------+
|Receive      |Receive      |Receive      |Assert Timer |Current      |
|Preferred    |Acceptable   |Inferior     |Expires      |Winner&#39;s     |
|Assert       |Assert with  |Assert or    |             |GenID        |
|             |RPTbit clear |Assert       |             |Changes or   |
|             |from Current |Cancel from  |             |NLT Expires  |
|             |Winner       |Current      |             |             |
|             |             |Winner       |             |             |
+-------------+-------------+-------------+-------------+-------------+
|-&gt; L state   |-&gt; L state   |-&gt; NI state  |-&gt; NI state  |-&gt; NI state  |
|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |
+-------------+-------------+-------------+-------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                    In I Am Assert Loser (L) State                    |
+----------------+-----------------+------------------+----------------+
| AssTrDes       |  my_metric -&gt;   |  RPF_interface   |  Receive       |
| (S,G,I) -&gt;     |  better than    |  (S) stops       |  Join(S,G) on  |
| FALSE          |  winner&#39;s       |  being I         |  interface I   |
|                |  metric         |                  |                |
+----------------+-----------------+------------------+----------------+
| -&gt; NI state    |  -&gt; NI state    |  -&gt; NI state     |  -&gt; NI State   |
| [Actions A5]   |  [Actions A5]   |  [Actions A5]    |  [Actions A5]  |
+----------------+-----------------+------------------+----------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                    In I Am Assert Loser (L) State                    |
+----------------+-----------------+------------------+----------------+
| AssTrDes       |  my_metric -&gt;   |  RPF_interface   |  Receive       |
| (S,G,I) -&gt;     |  better than    |  (S) stops       |  Join(S,G) on  |
| FALSE          |  winner&#39;s       |  being I         |  interface I   |
|                |  metric         |                  |                |
+----------------+-----------------+------------------+----------------+
| -&gt; NI state    |  -&gt; NI state    |  -&gt; NI state     |  -&gt; NI State   |
| [Actions A5]   |  [Actions A5]   |  [Actions A5]    |  [Actions A5]  |
+----------------+-----------------+------------------+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for reasons of compactness, &#34;AssTrDes(S,G,I)&#34; is used in the state machine table to refer to AssertTrackingDesired(S,G,I).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，出于紧凑性的原因，在状态机表中使用“AssTrDes（S，G，I）”来表示AssertTrackingDesired（S，G，I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Terminology:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
术语：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A &#34;preferred assert&#34; is one with a better metric than the current winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
“首选断言”是指比当前获胜者具有更好指标的断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An &#34;acceptable assert&#34; is one that has a better metric than my_assert_metric(S,G,I). An assert is never considered acceptable if its metric is infinite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
“可接受断言”是指具有比我的断言度量（S、G、I）更好的度量的断言。如果断言的度量是无限的，则它永远不会被认为是可接受的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An &#34;inferior assert&#34; is one with a worse metric than my_assert_metric(S,G,I). An assert is never considered inferior if my_assert_metric(S,G,I) is infinite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
“次断言”是指比我的度量（S、G、I）更差的度量。如果我的断言度量（S，G，I）是无限的，那么断言永远不会被认为是劣等的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state machine uses the following macros:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态机使用以下宏：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
CouldAssert(S,G,I) =
     SPTbit(S,G)==TRUE
     AND (RPF_interface(S) != I)
     AND (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )
                 (+) ( pim_include(*,G) (-) pim_exclude(S,G) )
                 (-) lost_assert(*,G)
                 (+) joins(S,G) (+) pim_include(S,G) ) )
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
CouldAssert(S,G,I) =
     SPTbit(S,G)==TRUE
     AND (RPF_interface(S) != I)
     AND (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )
                 (+) ( pim_include(*,G) (-) pim_exclude(S,G) )
                 (-) lost_assert(*,G)
                 (+) joins(S,G) (+) pim_include(S,G) ) )
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CouldAssert(S,G,I) is true for downstream interfaces that would be in the inherited_olist(S,G) if (S,G) assert information was not taken into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果不考虑（S，G）断言信息，则对于继承列表（S，G）中的下游接口，CouldAssert（S，G，I）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   AssertTrackingDesired(S,G,I) =
        (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )
                (+) ( pim_include(*,G) (-) pim_exclude(S,G) )
                (-) lost_assert(*,G)
                (+) joins(S,G) ) )
        OR (local_receiver_include(S,G,I) == TRUE
            AND (I_am_DR(I) OR (AssertWinner(S,G,I) == me)))
        OR ((RPF_interface(S) == I) AND (JoinDesired(S,G) == TRUE))
        OR ((RPF_interface(RP(G)) == I) AND (JoinDesired(*,G) == TRUE)
            AND (SPTbit(S,G) == FALSE))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   AssertTrackingDesired(S,G,I) =
        (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )
                (+) ( pim_include(*,G) (-) pim_exclude(S,G) )
                (-) lost_assert(*,G)
                (+) joins(S,G) ) )
        OR (local_receiver_include(S,G,I) == TRUE
            AND (I_am_DR(I) OR (AssertWinner(S,G,I) == me)))
        OR ((RPF_interface(S) == I) AND (JoinDesired(S,G) == TRUE))
        OR ((RPF_interface(RP(G)) == I) AND (JoinDesired(*,G) == TRUE)
            AND (SPTbit(S,G) == FALSE))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertTrackingDesired(S,G,I) is true on any interface in which an (S,G) assert might affect our behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertTrackingDesired（S，G，I）在（S，G）断言可能影响我们行为的任何接口上都是真的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first three lines of AssertTrackingDesired account for (*,G) join and local membership information received on I that might cause the router to be interested in asserts on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertTrackingDesired的前三行用于在I上接收的（*，G）连接和本地成员资格信息，这些信息可能会导致路由器对I上的断言感兴趣。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 4th line accounts for (S,G) join information received on I that might cause the router to be interested in asserts on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第四行说明了在I上接收到的（S，G）连接信息，这些信息可能会导致路由器对I上的断言感兴趣。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The 5th and 6th lines account for (S,G) local membership information on I. Note that we can&#39;t use the pim_include(S,G) macro since it uses lost_assert(S,G,I) and would result in the router forgetting that it lost an assert if the only reason it was interested was local membership. The AssertWinner(S,G,I) check forces an assert winner to keep on being responsible for forwarding as long as local receivers are present. Removing this check would make the assert winner give up forwarding as soon as the information that originally caused it to forward went away, and the task of forwarding for local receivers would revert back to the DR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第5行和第6行说明了I上的（S，G）本地成员信息。请注意，我们不能使用pim_include（S，G）宏，因为它使用lost_assert（S，G，I），如果路由器感兴趣的唯一原因是本地成员身份，则会导致路由器忘记丢失assert。AssertWinner（S、G、I）检查强制AssertWinner在本地接收者存在时继续负责转发。删除此检查将使断言赢家在最初导致其转发的信息消失后立即放弃转发，并且本地接收器的转发任务将恢复到DR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last three lines account for the fact that a router must keep track of assert information on upstream interfaces in order to send joins and prunes to the proper neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后三行说明了这样一个事实，路由器必须跟踪上游接口上的断言信息，以便向适当的邻居发送连接和剪枝。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NoInfo State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从NoInfo状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in NoInfo state, the following events may trigger transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于NoInfo状态时，以下事件可能会触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert with RPTbit cleared AND CouldAssert(S,G,I)==TRUE An assert is received for (S,G) with the RPT bit cleared that is inferior to our own assert metric. The RPT bit cleared indicates that the sender of the assert had (S,G) forwarding state on this interface. If the assert is inferior to our metric, then we must also have (S,G) forwarding state (i.e., CouldAssert(S,G,I)==TRUE) as (S,G) asserts beat (*,G) asserts, and so we should be the assert winner. We transition to the &#34;I am Assert Winner&#34; state and perform Actions A1 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收RPT位已清除的低级断言，并且CouldAssert（S，G，I）=TRUE接收RPT位已清除且低于我们自己的断言度量的（S，G）的断言。清除的RPT位表示断言的发送方在此接口上具有（S，G）转发状态。如果断言低于我们的度量，那么我们还必须具有（S，G）转发状态（即，CouldAssert（S，G，i）==TRUE），正如（S，G）断言beat（*，G）断言一样，因此我们应该是断言的赢家。我们转换到“我是赢家”状态并执行操作A1（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Assert with RPTbit set AND CouldAssert(S,G,I)==TRUE An assert is received for (S,G) on I with the RPT bit set (it&#39;s a (*,G) assert). CouldAssert(S,G,I) is TRUE only if we have (S,G) forwarding state on this interface, so we should be the assert winner. We transition to the &#34;I am Assert Winner&#34; state and perform Actions A1 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
使用RPT位集接收断言，并且CouldAssert（S，G，I）=TRUE使用RPT位集接收I上（S，G）的断言（它是（*，G）断言）。CouldAssert（S，G，I）只有在这个接口上有（S，G）转发状态时才是真的，所以我们应该是断言的赢家。我们转换到“我是赢家”状态并执行操作A1（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
An (S,G) data packet arrives on interface I, AND CouldAssert(S,G,I)==TRUE An (S,G) data packet arrived on an downstream interface that is in our (S,G) outgoing interface list. We optimistically assume that we will be the assert winner for this (S,G), and so we transition to the &#34;I am Assert Winner&#34; state and perform Actions A1 (below), which will initiate the assert negotiation for (S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（S，G）数据包到达接口I，并且CouldAssert（S，G，I）=真（S，G）数据包到达（S，G）输出接口列表中的下游接口。我们乐观地假设我们将是（S，G）的断言赢家，因此我们过渡到“我是断言赢家”状态并执行操作A1（如下），这将启动（S，G）的断言协商。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Acceptable Assert with RPT bit clear AND AssertTrackingDesired(S,G,I)==TRUE We&#39;re interested in (S,G) Asserts, either because I is a downstream interface for which we have (S,G) or (*,G) forwarding state, or because I is the upstream interface for S and we have (S,G) forwarding state. The received assert has a better metric than our own, so we do not win the Assert. We transition to &#34;I am Assert Loser&#34; and perform Actions A6 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收RPT位清晰的可接受断言和AssertTrackingDesired（S，G，I）=TRUE我们对（S，G）断言感兴趣，因为I是下游接口，我们有（S，G）或（*，G）转发状态，或者因为I是S的上游接口，我们有（S，G）转发状态。收到的断言比我们自己的度量更好，因此我们不会赢得断言。我们转换到“我是失败者”并执行操作A6（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from &#34;I am Assert Winner&#34; State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从“我是赢家”状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Winner&#34; state, the following events trigger transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“我是赢家”状态时，以下事件触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Assert Timer Expires The (S,G) Assert Timer expires. As we&#39;re in the Winner state, we must still have (S,G) forwarding state that is actively being kept alive. We resend the (S,G) Assert and restart the Assert Timer (Actions A3 below). Note that the assert winner&#39;s Assert Timer is engineered to expire shortly before timers on assert losers; this prevents unnecessary thrashing of the forwarder and periodic flooding of duplicate packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
断言计时器过期（S，G）断言计时器过期。当我们处于赢家状态时，我们必须仍然具有（S，G）转发状态，该状态将保持活跃。我们重新发送（S，G）断言并重新启动断言计时器（下面的操作A3）。请注意，断言赢家的断言计时器设计为在断言输家的计时器之前不久过期；这可以防止转发器不必要的抖动和重复数据包的周期性泛滥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert We receive an (S,G) assert or (*,G) assert mentioning S that has a worse metric than our own. Whoever sent the assert is in error, and so we resend an (S,G) Assert and restart the Assert Timer (Actions A3 below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我们收到的（S，G）断言或（*，G）断言的度量比我们自己的度量更差。发送断言的人出错，因此我们重新发送（S，G）断言并重新启动断言计时器（下面的操作A3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Preferred Assert We receive an (S,G) assert that has a better metric than our own. We transition to &#34;I am Assert Loser&#34; state and perform Actions A2 (below). Note that this may affect the value of JoinDesired(S,G) and PruneDesired(S,G,rpt), which could cause transitions in the upstream (S,G) or (S,G,rpt) state machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收首选断言我们接收一个（S，G）断言，它的度量比我们自己的更好。我们转换到“我是失败者”状态并执行操作A2（如下）。请注意，这可能会影响JoinDesired（S，G）和PruneDesired（S，G，rpt）的值，这可能会导致上游（S，G）或（S，G，rpt）状态机中的转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert(S,G,I) -&gt; FALSE Our (S,G) forwarding state or RPF interface changed so as to make CouldAssert(S,G,I) become false. We can no longer perform the actions of the assert winner, and so we transition to NoInfo state and perform Actions A4 (below). This includes sending a &#34;canceling assert&#34; with an infinite metric.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert（S，G，I）-&gt;FALSE我们的（S，G）转发状态或RPF接口已更改，从而使CouldAssert（S，G，I）变为FALSE。我们不能再执行assert winner的操作，因此我们转换到NoInfo状态并执行操作A4（如下）。这包括发送带有无限度量的“取消断言”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from &#34;I am Assert Loser&#34; State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从“我是失败者”状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Loser&#34; state, the following transitions can occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“我是失败者”状态时，可能会发生以下转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Preferred Assert We receive an assert that is better than that of the current assert winner. We stay in Loser state and perform Actions A2 below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收首选断言我们接收的断言优于当前断言获胜者的断言。我们处于失败者状态，执行下面的A2操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Acceptable Assert with RPTbit clear from Current Winner We receive an assert from the current assert winner that is better than our own metric for this (S,G) (although the metric may be worse than the winner&#39;s previous metric). We stay in Loser state and perform Actions A2 below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收当前获胜者的RPTbit clear可接受断言我们从当前获胜者那里接收到一个断言，该断言优于我们自己的度量（S，G）（尽管该度量可能比获胜者之前的度量更差）。我们处于失败者状态，执行下面的A2操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert or Assert Cancel from Current Winner We receive an assert from the current assert winner that is worse than our own metric for this group (typically, because the winner&#39;s metric became worse or because it is an assert cancel). We transition to NoInfo state, deleting the (S,G) assert information and allowing the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets from S have started flowing again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从当前赢家处收到较差的断言或断言取消我们从当前断言赢家处收到的断言比我们在该组中的度量更差（通常是因为赢家的度量变得更差或因为它是断言取消）。我们转换到NoInfo状态，删除（S，G）断言信息，并允许正常的PIM连接/修剪机制运行。通常，当来自S的数据包再次开始流动时，我们最终将重新断言并获胜。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Assert Timer Expires The (S,G) Assert Timer expires. We transition to NoInfo state, deleting the (S,G) assert information (Actions A5 below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
断言计时器过期（S，G）断言计时器过期。我们转换到NoInfo状态，删除（S，G）断言信息（下面的操作A5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Current Winner&#39;s GenID Changes or NLT Expires The Neighbor Liveness Timer associated with the current winner expires or we receive a Hello message from the current winner reporting a different GenID from the one it previously reported. This indicates that the current winner&#39;s interface or router has gone down (and may have come back up), and so we must assume it no longer knows it was the winner. We transition to the NoInfo state, deleting this (S,G) assert information (Actions A5 below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
当前获奖者的GenID更改或NLT过期与当前获奖者关联的邻居活跃度计时器过期，或者我们收到来自当前获奖者的Hello消息，报告与先前报告的GenID不同的GenID。这表明当前赢家的接口或路由器已关闭（可能已恢复），因此我们必须假设它不再知道自己是赢家。我们转换到NoInfo状态，删除这个（S，G）断言信息（下面的动作A5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AssertTrackingDesired(S,G,I)-&gt;FALSE AssertTrackingDesired(S,G,I) becomes FALSE. Our forwarding state has changed so that (S,G) Asserts on interface I are no longer of interest to us. We transition to the NoInfo state, deleting the (S,G) assert information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AssertTrackingDesired（S，G，I）-&gt;FALSE AssertTrackingDesired（S，G，I）变为FALSE。我们的转发状态已更改，因此接口I上的（S，G）断言不再引起我们的兴趣。我们转换到NoInfo状态，删除（S，G）断言信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
My metric becomes better than the assert winner&#39;s metric my_assert_metric(S,G,I) has changed so that now my assert metric for (S,G) is better than the metric we have stored for current assert winner. This might happen when the underlying routing metric changes, or when CouldAssert(S,G,I) becomes true; for example, when SPTbit(S,G) becomes true. We transition to NoInfo state, delete this (S,G) assert state (Actions A5 below), and allow the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets from S have started flowing again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我的度量变得比断言赢家的度量更好我的断言度量（s，G，I）已更改，因此现在（s，G）的断言度量优于我们为当前断言赢家存储的度量。当底层路由度量发生变化时，或者当CouldAssert（S、G、I）变为true时，可能会发生这种情况；例如，当SPTbit（S，G）变为true时。我们转换到NoInfo状态，删除这个（S，G）断言状态（下面的操作A5），并允许正常的PIM连接/修剪机制运行。通常，当来自S的数据包再次开始流动时，我们最终将重新断言并获胜。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_interface(S) stops being interface I Interface I used to be the RPF interface for S, and now it is not. We transition to NoInfo state, deleting this (S,G) assert state (Actions A5 below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_接口不再是接口I接口I曾经是S的RPF接口，现在不是了。我们转换到NoInfo状态，删除这个（S，G）断言状态（下面的动作A5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G) on Interface I We receive a Join(S,G) that has the Upstream Neighbor Address field set to my primary IP address on interface I. The action is to transition to NoInfo state, delete this (S,G) assert state (Actions A5 below), and allow the normal PIM Join/Prune mechanisms to operate. If whoever sent the Join was in error, then the normal assert mechanism will eventually re-apply, and we will lose the assert again. However, whoever sent the assert may know that the previous assert winner has died, and so we may end up being the new forwarder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
在接口I上接收连接（S，G）我们在接口I上接收一个连接（S，G），其上游邻居地址字段设置为我的主IP地址。操作是转换到NoInfo状态，删除此（S，G）断言状态（下面的操作A5），并允许正常的PIM连接/修剪机制运行。如果发送连接的人出错，那么正常的断言机制最终将重新应用，我们将再次丢失断言。然而，无论谁发送了assert，都可能知道先前的assert赢家已经去世，因此我们可能最终成为新的货运代理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G) Assert State machine Actions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）断言状态机操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A1: Send Assert(S,G). Set Assert Timer to (Assert_Time - Assert_Override_Interval). Store self as AssertWinner(S,G,I). Store spt_assert_metric(S,I) as AssertWinnerMetric(S,G,I).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A1：发送断言（S，G）。将Assert Timer设置为（Assert\u Time-Assert\u Override\u Interval）。将自身存储为资产赢家（S、G、I）。将spt_assert_度量（S，I）存储为AssertWinnerMetric（S，G，I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A2: Store new assert winner as AssertWinner(S,G,I) and assert winner metric as AssertWinnerMetric(S,G,I). Set Assert Timer to Assert_Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A2：将新的assert winner存储为AssertWinner（S，G，I），将assert winner度量存储为AssertWinnerMetric（S，G，I）。将Assert Timer设置为Assert_Time。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A3: Send Assert(S,G). Set Assert Timer to (Assert_Time - Assert_Override_Interval).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A3：发送断言（S，G）。将Assert Timer设置为（Assert\u Time-Assert\u Override\u Interval）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A4: Send AssertCancel(S,G). Delete assert info (AssertWinner(S,G,I) and AssertWinnerMetric(S,G,I) will then return their default values).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A4：发送资产取消（S、G）。删除断言信息（AssertWinner（S，G，I）和AssertWinnerMetric（S，G，I）将返回其默认值）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A5: Delete assert info (AssertWinner(S,G,I) and AssertWinnerMetric(S,G,I) will then return their default values).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A5：删除断言信息（AssertWinner（S，G，I）和AssertWinnerMetric（S，G，I）将返回其默认值）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A6: Store new assert winner as AssertWinner(S,G,I) and assert winner metric as AssertWinnerMetric(S,G,I). Set Assert Timer to Assert_Time. If (I is RPF_interface(S)) AND (UpstreamJPState(S,G) == true) set SPTbit(S,G) to TRUE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A6：将新的assert winner存储为AssertWinner（S，G，I），将assert winner度量存储为AssertWinnerMetric（S，G，I）。将Assert Timer设置为Assert_Time。如果（I是RPF_接口）和（上游状态（S，G）==true），则将SPTbit（S，G）设置为true。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some of these actions may cause the value of JoinDesired(S,G), PruneDesired(S,G,rpt), or RPF&#39;(S,G) to change, which could cause further transitions in other state machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，其中一些操作可能会导致JoinDesired（S，G）、PruneDesired（S，G，rpt）或RPF（S，G）的值发生更改，这可能会导致其他状态机中的进一步转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. (*,G) Assert Message State Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. （*，G）断言消息状态机
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (*,G) Assert state machine for interface I is shown in Figure 11. There are three states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接口I的（*，G）断言状态机如图11所示。有三个州：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NoInfo (NI) This router has no (*,G) assert state on interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NoInfo（NI）此路由器在接口I上没有（*，G）断言状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I am Assert Winner (W) This router has won an (*,G) assert on interface I. It is now responsible for forwarding traffic destined for G onto interface I with the exception of traffic for which it has (S,G) &#34;I am Assert Loser&#34; state. Irrespective of whether it is the DR for I, it is also responsible for handling the membership requests for G from local hosts on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我是断言赢家（W）此路由器在接口I上赢得了（*，G）断言。它现在负责将目的地为G的流量转发到接口I上，但具有（S，G）“我是断言输家”状态的流量除外。无论它是否是I的DR，它也负责处理I上本地主机对G的成员资格请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I am Assert Loser (L) This router has lost an (*,G) assert on interface I. It must not forward packets for G onto interface I with the exception of traffic from sources for which is has (S,G) &#34;I am Assert Winner&#34; state. If it is the DR, it is no longer responsible for handling the membership requests for group G from local hosts on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I am Assert Loser（L）此路由器在接口I上丢失了一个（*，G）Assert。它不能将G的数据包转发到接口I上，但来自具有（S，G）“I am Assert Winner”状态的源的流量除外。如果是DR，则不再负责处理来自I上本地主机的G组成员资格请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there is also an Assert Timer (AT) that is used to time out asserts on the assert losers and to resend asserts on the assert winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有一个断言计时器（AT），用于超时断言失败者的断言，并重新发送断言成功者的断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an Assert message is received with a source address other than zero, a PIM implementation must first match it against the possible events in the (S,G) assert state machine and process any transitions and actions, before considering whether the Assert message matches against the (*,G) assert state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收到源地址不是零的断言消息时，PIM实现必须首先将其与（S，G）断言状态机中的可能事件进行匹配，并处理任何转换和操作，然后再考虑断言消息是否与（*，G）断言状态机匹配。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that NO TRANSITION CAN OCCUR in the (*,G) state machine as a result of receiving an Assert message unless the (S,G) assert state machine for the relevant S and G is in the &#34;NoInfo&#34; state after the (S,G) state machine has processed the message. Also, NO TRANSITION CAN OCCUR in the (*,G) state machine as a result of receiving an assert message if that message triggers any change of state in the (S,G) state machine. Obviously, when the source address in the received message is set to zero, an (S,G) state machine for the S and G does not exist and can be assumed to be in the &#34;NoInfo&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重要的是要注意，如果（*，G）状态机在（S，G）状态机处理完消息后，（S，G）相关S和G的（S，G）Assert状态机处于“NoInfo”状态，则接收Assert消息时（*，G）状态机中不会发生转换。此外，如果（*，G）状态机中的断言消息触发了（S，G）状态机中的任何状态更改，则（*，G）状态机中不会因接收该消息而发生转换。显然，当接收到的消息中的源地址设置为零时，S和G的（S，G）状态机不存在，并且可以假定处于“NoInfo”状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, if both the (S,G) and (*,G) assert state machines are in the NoInfo state when an Assert message arrives, and the message causes the (S,G) state machine to transition to either &#34;W&#34; or &#34;L&#34; state, then the assert will not be processed by the (*,G) assert state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如，当断言消息到达时，如果（S，G）和（*，G）断言状态机都处于NoInfo状态，并且该消息导致（S，G）状态机转换为“W”或“L”状态，则（*，G）断言状态机将不会处理该断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another example: if the (S,G) assert state machine is in &#34;L&#34; state when an assert message is received, and the assert metric in the message is worse than my_assert_metric(S,G,I), then the (S,G) assert state machine will transition to NoInfo state. In such a case, if the (*,G) assert state machine were in NoInfo state, it might appear that it would transition to &#34;W&#34; state, but this is not the case because this message already triggered a transition in the (S,G) assert state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
另一个示例：如果（S，G）断言状态机在收到断言消息时处于“L”状态，并且消息中的断言度量比我的断言度量（S，G，I）更差，则（S，G）断言状态机将转换为NoInfo状态。在这种情况下，如果（*，G）断言状态机处于NoInfo状态，它可能会转换为“W”状态，但情况并非如此，因为此消息已触发（S，G）断言状态机中的转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
Figure 11: Per-interface (*,G) Assert State machine in tabular form
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
图11：每个接口（*，G）以表格形式断言状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In NoInfo (NI) State                         |
+-----------------------+-----------------------+----------------------+
| Receive Inferior      |  Data arrives for G   |  Receive Acceptable  |
| Assert with RPTbit    |  on I and             |  Assert with RPTbit  |
| set and               |  CouldAssert          |  set and AssTrDes    |
| CouldAssert(*,G,I)    |  (*,G,I)              |  (*,G,I)             |
+-----------------------+-----------------------+----------------------+
| -&gt; W state            |  -&gt; W state           |  -&gt; L state          |
| [Actions A1]          |  [Actions A1]         |  [Actions A2]        |
+-----------------------+-----------------------+----------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                         In NoInfo (NI) State                         |
+-----------------------+-----------------------+----------------------+
| Receive Inferior      |  Data arrives for G   |  Receive Acceptable  |
| Assert with RPTbit    |  on I and             |  Assert with RPTbit  |
| set and               |  CouldAssert          |  set and AssTrDes    |
| CouldAssert(*,G,I)    |  (*,G,I)              |  (*,G,I)             |
+-----------------------+-----------------------+----------------------+
| -&gt; W state            |  -&gt; W state           |  -&gt; L state          |
| [Actions A1]          |  [Actions A1]         |  [Actions A2]        |
+-----------------------+-----------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------------------------------------------------+
|                    In I Am Assert Winner (W) State                  |
+----------------+-----------------+-----------------+----------------+
| Assert Timer   |  Receive        |  Receive        |  CouldAssert   |
| Expires        |  Inferior       |  Preferred      |  (*,G,I) -&gt;    |
|                |  Assert         |  Assert         |  FALSE         |
+----------------+-----------------+-----------------+----------------+
| -&gt; W state     |  -&gt; W state     |  -&gt; L state     |  -&gt; NI state   |
| [Actions A3]   |  [Actions A3]   |  [Actions A2]   |  [Actions A4]  |
+----------------+-----------------+-----------------+----------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------------------------------------------------+
|                    In I Am Assert Winner (W) State                  |
+----------------+-----------------+-----------------+----------------+
| Assert Timer   |  Receive        |  Receive        |  CouldAssert   |
| Expires        |  Inferior       |  Preferred      |  (*,G,I) -&gt;    |
|                |  Assert         |  Assert         |  FALSE         |
+----------------+-----------------+-----------------+----------------+
| -&gt; W state     |  -&gt; W state     |  -&gt; L state     |  -&gt; NI state   |
| [Actions A3]   |  [Actions A3]   |  [Actions A2]   |  [Actions A4]  |
+----------------+-----------------+-----------------+----------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------------------------------------------------+
|                    In I Am Assert Loser (L) State                   |
+-------------+-------------+-------------+-------------+-------------+
|Receive      |Receive      |Receive      |Assert Timer |Current      |
|Preferred    |Acceptable   |Inferior     |Expires      |Winner&#39;s     |
|Assert with  |Assert from  |Assert or    |             |GenID        |
|RPTbit set   |Current      |Assert       |             |Changes or   |
|             |Winner with  |Cancel from  |             |NLT Expires  |
|             |RPTbit set   |Current      |             |             |
|             |             |Winner       |             |             |
+-------------+-------------+-------------+-------------+-------------+
|-&gt; L state   |-&gt; L state   |-&gt; NI state  |-&gt; NI state  |-&gt; NI state  |
|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |
+-------------+-------------+-------------+-------------+-------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------------------------------------------------+
|                    In I Am Assert Loser (L) State                   |
+-------------+-------------+-------------+-------------+-------------+
|Receive      |Receive      |Receive      |Assert Timer |Current      |
|Preferred    |Acceptable   |Inferior     |Expires      |Winner&#39;s     |
|Assert with  |Assert from  |Assert or    |             |GenID        |
|RPTbit set   |Current      |Assert       |             |Changes or   |
|             |Winner with  |Cancel from  |             |NLT Expires  |
|             |RPTbit set   |Current      |             |             |
|             |             |Winner       |             |             |
+-------------+-------------+-------------+-------------+-------------+
|-&gt; L state   |-&gt; L state   |-&gt; NI state  |-&gt; NI state  |-&gt; NI state  |
|[Actions A2] |[Actions A2] |[Actions A5] |[Actions A5] |[Actions A5] |
+-------------+-------------+-------------+-------------+-------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                    In I Am Assert Loser (L) State                    |
+----------------+----------------+-----------------+------------------+
| AssTrDes       | my_metric -&gt;   |  RPF_interface  |  Receive         |
| (*,G,I) -&gt;     | better than    |  (RP(G)) stops  |  Join(*,G) or    |
| FALSE          | Winner&#39;s       |  being I        |  Join            |
|                | metric         |                 |  (*,*,RP(G)) on  |
|                |                |                 |  Interface I     |
+----------------+----------------+-----------------+------------------+
| -&gt; NI state    | -&gt; NI state    |  -&gt; NI state    |  -&gt; NI State     |
| [Actions A5]   | [Actions A5]   |  [Actions A5]   |  [Actions A5]    |
+----------------+----------------+-----------------+------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                    In I Am Assert Loser (L) State                    |
+----------------+----------------+-----------------+------------------+
| AssTrDes       | my_metric -&gt;   |  RPF_interface  |  Receive         |
| (*,G,I) -&gt;     | better than    |  (RP(G)) stops  |  Join(*,G) or    |
| FALSE          | Winner&#39;s       |  being I        |  Join            |
|                | metric         |                 |  (*,*,RP(G)) on  |
|                |                |                 |  Interface I     |
+----------------+----------------+-----------------+------------------+
| -&gt; NI state    | -&gt; NI state    |  -&gt; NI state    |  -&gt; NI State     |
| [Actions A5]   | [Actions A5]   |  [Actions A5]   |  [Actions A5]    |
+----------------+----------------+-----------------+------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state machine uses the following macros:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态机使用以下宏：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CouldAssert(*,G,I) =
       ( I in ( joins(*,*,RP(G)) (+) joins(*,G)
                (+) pim_include(*,G)) )
       AND (RPF_interface(RP(G)) != I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CouldAssert(*,G,I) =
       ( I in ( joins(*,*,RP(G)) (+) joins(*,G)
                (+) pim_include(*,G)) )
       AND (RPF_interface(RP(G)) != I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CouldAssert(*,G,I) is true on downstream interfaces for which we have (*,*,RP(G)) or (*,G) join state, or local members that requested any traffic destined for G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CouldAssert（*，G，I）在我们有（*，*，RP（G））或（*，G）连接状态的下游接口上为真，或者在请求任何发送到G的流量的本地成员上为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   AssertTrackingDesired(*,G,I) =
       CouldAssert(*,G,I)
       OR (local_receiver_include(*,G,I)==TRUE
           AND (I_am_DR(I) OR AssertWinner(*,G,I) == me))
       OR (RPF_interface(RP(G)) == I AND RPTJoinDesired(G))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   AssertTrackingDesired(*,G,I) =
       CouldAssert(*,G,I)
       OR (local_receiver_include(*,G,I)==TRUE
           AND (I_am_DR(I) OR AssertWinner(*,G,I) == me))
       OR (RPF_interface(RP(G)) == I AND RPTJoinDesired(G))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertTrackingDesired(*,G,I) is true on any interface on which an (*,G) assert might affect our behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertTrackingDesired（*，G，I）在（*，G）断言可能影响我们行为的任何接口上都是真的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for reasons of compactness, &#34;AssTrDes(*,G,I)&#34; is used in the state machine table to refer to AssertTrackingDesired(*,G,I).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，出于紧凑性的原因，在状态机表中使用“AssTrDes（*，G，I）”来指代AssertTrackingDesired（*，G，I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Terminology:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
术语：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A &#34;preferred assert&#34; is one with a better metric than the current winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
“首选断言”是指比当前获胜者具有更好指标的断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An &#34;acceptable assert&#34; is one that has a better metric than my_assert_metric(*,G,I). An assert is never considered acceptable if its metric is infinite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
“可接受断言”是指具有比我的断言度量（*，G，I）更好的度量的断言。如果断言的度量是无限的，则它永远不会被认为是可接受的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An &#34;inferior assert&#34; is one with a worse metric than my_assert_metric(*,G,I). An assert is never considered inferior if my_assert_metric(*,G,I) is infinite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
“次断言”是指比我的度量（*，G，I）更差的度量。如果我的断言度量（*，G，I）是无限的，那么断言永远不会被认为是劣等的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from NoInfo State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从NoInfo状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in NoInfo state, the following events trigger transitions, but only if the (S,G) assert state machine is in NoInfo state before and after consideration of the received message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于NoInfo状态时，以下事件触发转换，但仅当（S，G）断言状态机在考虑接收到的消息之前和之后处于NoInfo状态时：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert with RPTbit set AND CouldAssert(*,G,I)==TRUE An Inferior (*,G) assert is received for G on Interface I. If CouldAssert(*,G,I) is TRUE, then I is our downstream interface, and we have (*,G) forwarding state on this interface, so we should be the assert winner. We transition to the &#34;I am Assert Winner&#34; state and perform Actions A1 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
设置RPTbit并接收下级断言，并且CouldAssert（*，G，I）=TRUE在接口I上为G接收下级（*，G）断言。如果CouldAssert（*，G，I）为TRUE，则我是我们的下游接口，并且我们在此接口上具有（*，G）转发状态，因此我们应该是断言的赢家。我们转换到“我是赢家”状态并执行操作A1（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A data packet destined for G arrives on interface I, AND CouldAssert(*,G,I)==TRUE A data packet destined for G arrived on a downstream interface that is in our (*,G) outgoing interface list. We therefore believe we should be the forwarder for this (*,G), and so we transition to the &#34;I am Assert Winner&#34; state and perform Actions A1 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
以G为目的地的数据包到达接口I，并且CouldAssert（*，G，I）=TRUE以G为目的地的数据包到达我们（*，G）输出接口列表中的下游接口。因此，我们认为我们应该成为该（*，G）的转发商，因此我们将过渡到“我是断言赢家”状态，并执行行动A1（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Acceptable Assert with RPT bit set AND AssertTrackingDesired(*,G,I)==TRUE We&#39;re interested in (*,G) Asserts, either because I is a downstream interface for which we have (*,G) forwarding state, or because I is the upstream interface for RP(G) and we have (*,G) forwarding state. We get a (*,G) Assert that has a better metric than our own, so we do not win the Assert. We transition to &#34;I am Assert Loser&#34; and perform Actions A2 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收带有RPT位集的可接受断言和AssertTrackingDesired（*，G，I）=TRUE我们对（*，G）断言感兴趣，这可能是因为I是具有（*，G）转发状态的下游接口，或者因为I是RP（G）的上游接口，并且具有（*，G）转发状态。我们得到一个（*，G）断言，它的度量比我们自己的更好，因此我们不会赢得断言。我们转换到“我是失败者”并执行操作A2（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from &#34;I am Assert Winner&#34; State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从“我是赢家”状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Winner&#34; state, the following events trigger transitions, but only if the (S,G) assert state machine is in NoInfo state before and after consideration of the received message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“I am Assert Winner”状态时，以下事件触发转换，但仅当（S，G）Assert状态机在考虑接收到的消息之前和之后处于NoInfo状态时：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert We receive a (*,G) assert that has a worse metric than our own. Whoever sent the assert has lost, and so we resend a (*,G) Assert and restart the Assert Timer (Actions A3 below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我们收到一个（*，G）断言，它的度量比我们自己的更差。发送断言的人已丢失，因此我们重新发送（*，G）断言并重新启动断言计时器（下面的操作A3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Preferred Assert We receive a (*,G) assert that has a better metric than our own. We transition to &#34;I am Assert Loser&#34; state and perform Actions A2 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收首选断言我们接收一个（*，G）断言，该断言的度量比我们自己的更好。我们转换到“我是失败者”状态并执行操作A2（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Winner&#34; state, the following events trigger transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“我是赢家”状态时，以下事件触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Assert Timer Expires The (*,G) Assert Timer expires. As we&#39;re in the Winner state, then we must still have (*,G) forwarding state that is actively being kept alive. To prevent unnecessary thrashing of the forwarder and periodic flooding of duplicate packets, we resend the (*,G) Assert and restart the Assert Timer (Actions A3 below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
断言计时器过期（*，G）断言计时器过期。由于我们处于赢家状态，那么我们必须仍然有（*，G）转发状态，该状态将保持活跃。为了防止转发器不必要的抖动和重复数据包的周期性泛滥，我们重新发送（*，G）断言并重新启动断言计时器（下面的操作A3）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert(*,G,I) -&gt; FALSE Our (*,G) forwarding state or RPF interface changed so as to make CouldAssert(*,G,I) become false. We can no longer perform the actions of the assert winner, and so we transition to NoInfo state and perform Actions A4 (below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert（*，G，I）-&gt;FALSE我们的（*，G）转发状态或RPF接口已更改，从而使CouldAssert（*，G，I）变为FALSE。我们不能再执行assert winner的操作，因此我们转换到NoInfo状态并执行操作A4（如下）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transitions from &#34;I am Assert Loser&#34; State
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从“我是失败者”状态的转换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Loser&#34; state, the following events trigger transitions, but only if the (S,G) assert state machine is in NoInfo state before and after consideration of the received message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“I am Assert Loser”状态时，以下事件触发转换，但仅当（S，G）Assert状态机在考虑接收到的消息之前和之后处于NoInfo状态时：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Preferred Assert with RPTbit set We receive a (*,G) assert that is better than that of the current assert winner. We stay in Loser state and perform Actions A2 below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收RPTbit集合的首选断言我们接收一个（*，G）断言，它比当前的断言优胜者的断言更好。我们处于失败者状态，执行下面的A2操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Acceptable Assert from Current Winner with RPTbit set We receive a (*,G) assert from the current assert winner that is better than our own metric for this group (although the metric may be worse than the winner&#39;s previous metric). We stay in Loser state and perform Actions A2 below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
使用RPTbit集从当前获奖者处接收可接受的断言我们从当前获奖者处接收一个（*，G）断言，该断言好于我们对该组的度量（尽管该度量可能比获奖者以前的度量更差）。我们处于失败者状态，执行下面的A2操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert or Assert Cancel from Current Winner We receive an assert from the current assert winner that is worse than our own metric for this group (typically because the winner&#39;s metric became worse or is now an assert cancel). We transition to NoInfo state, delete this (*,G) assert state (Actions A5), and allow the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets for G have started flowing again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从当前赢家处收到较差的断言或断言取消我们从当前断言赢家处收到的断言比我们在该组中的度量更差（通常是因为赢家的度量变得更差或现在是断言取消）。我们转换到NoInfo状态，删除（*，G）断言状态（操作A5），并允许正常的PIM连接/修剪机制运行。通常，当G的数据包再次开始流动时，我们最终将重新断言并获胜。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Loser&#34; state, the following events trigger transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“我是失败者”状态时，以下事件触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Assert Timer Expires The (*,G) Assert Timer expires. We transition to NoInfo state and delete this (*,G) assert info (Actions A5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
断言计时器过期（*，G）断言计时器过期。我们转换到NoInfo状态并删除此（*，G）断言信息（操作A5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Current Winner&#39;s GenID Changes or NLT Expires The Neighbor Liveness Timer associated with the current winner expires or we receive a Hello message from the current winner reporting a different GenID from the one it previously reported. This indicates that the current winner&#39;s interface or router has gone down (and may have come back up), and so we must assume it no longer knows it was the winner. We transition to the NoInfo state, deleting the (*,G) assert information (Actions A5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
当前获奖者的GenID更改或NLT过期与当前获奖者关联的邻居活跃度计时器过期，或者我们收到来自当前获奖者的Hello消息，报告与先前报告的GenID不同的GenID。这表明当前赢家的接口或路由器已关闭（可能已恢复），因此我们必须假设它不再知道自己是赢家。我们转换到NoInfo状态，删除（*，G）断言信息（操作A5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AssertTrackingDesired(*,G,I)-&gt;FALSE AssertTrackingDesired(*,G,I) becomes FALSE. Our forwarding state has changed so that (*,G) Asserts on interface I are no longer of interest to us. We transition to NoInfo state and delete this (*,G) assert info (Actions A5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AssertTrackingIded（*，G，I）-&gt;FALSE AssertTracking所需（*，G，I）变为FALSE。我们的转发状态已更改，因此接口I上的（*，G）断言不再引起我们的兴趣。我们转换到NoInfo状态并删除此（*，G）断言信息（操作A5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
My metric becomes better than the assert winner&#39;s metric My routing metric, rpt_assert_metric(G,I), has changed so that now my assert metric for (*,G) is better than the metric we have stored for current assert winner. We transition to NoInfo state, delete this (*,G) assert state (Actions A5), and allow the normal PIM Join/Prune mechanisms to operate. Usually, we will eventually re-assert and win when data packets for G have started flowing again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我的度量变得比断言赢家的度量更好我的路由度量rpt_assert_metric（G，I）已更改，因此（*，G）的断言度量现在比我们为当前断言赢家存储的度量更好。我们转换到NoInfo状态，删除（*，G）断言状态（操作A5），并允许正常的PIM连接/修剪机制运行。通常，当G的数据包再次开始流动时，我们最终将重新断言并获胜。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_interface(RP(G)) stops being interface I Interface I used to be the RPF interface for RP(G), and now it is not. We transition to NoInfo state and delete this (*,G) assert state (Actions A5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_接口（RP（G））不再是接口I接口I曾经是RP（G）的RPF接口，现在不是了。我们转换到NoInfo状态并删除这个（*，G）断言状态（操作A5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(*,G) or Join(*,*,RP(G)) on interface I We receive a Join(*,G) or a Join(*,*,RP(G)) that has the Upstream Neighbor Address field set to my primary IP address on interface I. The action is to transition to NoInfo state, delete this (*,G) assert state (Actions A5), and allow the normal PIM Join/Prune mechanisms to operate. If whoever sent the Join was in error, then the normal assert mechanism will eventually re-apply, and we will lose the assert again. However, whoever sent the assert may know that the previous assert winner has died, so we may end up being the new forwarder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
在接口I上接收连接（*，G）或连接（*，*，RP（G）），我们接收一个连接（*，G）或连接（*，*，RP（G）），其上游邻居地址字段设置为接口I上的主IP地址。操作是转换到NoInfo状态，删除此（*，G）断言状态（操作A5），并允许正常的PIM连接/修剪机制运行。如果发送连接的人出错，那么正常的断言机制最终将重新应用，我们将再次丢失断言。然而，无论谁发送了assert，都可能知道先前的assert赢家已经去世，因此我们可能最终成为新的转运商。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(*,G) Assert State machine Actions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*，G）断言状态机操作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A1: Send Assert(*,G). Set Assert Timer to (Assert_Time - Assert_Override_Interval). Store self as AssertWinner(*,G,I). Store rpt_assert_metric(G,I) as AssertWinnerMetric(*,G,I).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A1：发送断言（*，G）。将Assert Timer设置为（Assert\u Time-Assert\u Override\u Interval）。将自身存储为AssertWinner（*，G，I）。将rpt_assert_度量（G，I）存储为AssertWinnerMetric（*，G，I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A2: Store new assert winner as AssertWinner(*,G,I) and assert winner metric as AssertWinnerMetric(*,G,I). Set Assert Timer to Assert_Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A2：将新的assert winner存储为AssertWinner（*，G，I），将assert winner度量存储为AssertWinnerMetric（*，G，I）。将Assert Timer设置为Assert_Time。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A3: Send Assert(*,G) Set Assert Timer to (Assert_Time - Assert_Override_Interval).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A3：发送断言（*，G）将断言计时器设置为（断言时间-断言覆盖间隔）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A4: Send AssertCancel(*,G). Delete assert info (AssertWinner(*,G,I) and AssertWinnerMetric(*,G,I) will then return their default values).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A4：发送资产取消（*，G）。删除断言信息（AssertWinner（*，G，I）和AssertWinnerMetric（*，G，I）将返回其默认值）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A5: Delete assert info (AssertWinner(*,G,I) and AssertWinnerMetric(*,G,I) will then return their default values).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
A5：删除断言信息（AssertWinner（*，G，I）和AssertWinnerMetric（*，G，I）然后将返回其默认值）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some of these actions may cause the value of JoinDesired(*,G) or RPF&#39;(*,G)) to change, which could cause further transitions in other state machines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，其中一些操作可能会导致JoinDesired（*，G）或RPF&#39;（*，G））的值更改，这可能会导致其他状态机中的进一步转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. Assert Metrics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. 断言度量
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assert metrics are defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断言度量定义为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct assert_metric {
       rpt_bit_flag;
       metric_preference;
       route_metric;
       ip_address;
     };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct assert_metric {
       rpt_bit_flag;
       metric_preference;
       route_metric;
       ip_address;
     };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When comparing assert_metrics, the rpt_bit_flag, metric_preference, and route_metric field are compared in order, where the first lower value wins. If all fields are equal, the primary IP address of the router that sourced the Assert message is used as a tie-breaker, with the highest IP address winning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在比较assert_度量时，rpt_bit_标志、度量_首选项和route_度量字段按顺序进行比较，其中第一个较低的值获胜。如果所有字段都相等，则源于断言消息的路由器的主IP地址将用作平局断路器，最高IP地址将获胜。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An assert metric for (S,G) to include in (or compare against) an Assert message sent on interface I should be computed using the following pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应使用以下伪代码计算（S，G）的断言度量，以将其包含在接口I上发送的断言消息中（或与之进行比较）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     my_assert_metric(S,G,I) {
         if( CouldAssert(S,G,I) == TRUE ) {
             return spt_assert_metric(S,I)
         } else if( CouldAssert(*,G,I) == TRUE ) {
             return rpt_assert_metric(G,I)
         } else {
             return infinite_assert_metric()
         }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     my_assert_metric(S,G,I) {
         if( CouldAssert(S,G,I) == TRUE ) {
             return spt_assert_metric(S,I)
         } else if( CouldAssert(*,G,I) == TRUE ) {
             return rpt_assert_metric(G,I)
         } else {
             return infinite_assert_metric()
         }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
spt_assert_metric(S,I) gives the assert metric we use if we&#39;re sending an assert based on active (S,G) forwarding state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
spt_assert_metric（S，I）给出了我们在基于活动（S，G）转发状态发送断言时使用的断言度量：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     spt_assert_metric(S,I) {
        return {0,MRIB.pref(S),MRIB.metric(S),my_ip_address(I)}
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     spt_assert_metric(S,I) {
        return {0,MRIB.pref(S),MRIB.metric(S),my_ip_address(I)}
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rpt_assert_metric(G,I) gives the assert metric we use if we&#39;re sending an assert based only on (*,G) forwarding state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rpt_assert_metric（G，I）给出了仅基于（*，G）转发状态发送断言时使用的断言度量：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     rpt_assert_metric(G,I) {
         return {1,MRIB.pref(RP(G)),MRIB.metric(RP(G)),my_ip_address(I)}
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     rpt_assert_metric(G,I) {
         return {1,MRIB.pref(RP(G)),MRIB.metric(RP(G)),my_ip_address(I)}
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MRIB.pref(X) and MRIB.metric(X) are the routing preference and routing metrics associated with the route to a particular (unicast) destination X, as determined by the MRIB. my_ip_address(I) is simply the router&#39;s primary IP address that is associated with the local interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MRIB.pref（X）和MRIB.metric（X）是与到特定（单播）目的地X的路由相关联的路由首选项和路由度量，由MRIB确定。my_ip_address（I）只是与本地接口I关联的路由器的主ip地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
infinite_assert_metric() gives the assert metric we need to send an assert but don&#39;t match either (S,G) or (*,G) forwarding state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
infinite_assert_metric（）提供我们需要发送断言的断言度量，但与（S，G）或（*，G）转发状态不匹配：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     infinite_assert_metric() {
          return {1,infinity,infinity,0}
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     assert_metric
     infinite_assert_metric() {
          return {1,infinity,infinity,0}
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4. AssertCancel Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4. 资产取消消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An AssertCancel message is simply an RPT Assert message but with infinite metric. It is sent by the assert winner when it deletes the forwarding state that had caused the assert to occur. Other routers will see this metric, and it will cause any other router that has forwarding state to send its own assert, and to take over forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel消息只是RPT Assert消息，但具有无限度量。断言赢家在删除导致断言发生的转发状态时发送该消息。其他路由器将看到此度量，它将导致任何其他具有转发状态的路由器发送其自己的断言，并接管转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An AssertCancel(S,G) is an infinite metric assert with the RPT bit set that names S as the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel（S，G）是一个无限度量断言，其RPT位集将S命名为源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An AssertCancel(*,G) is an infinite metric assert with the RPT bit set and the source set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel（*，G）是RPT位设置为零且源设置为零的无限度量断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel messages are simply an optimization. The original Assert timeout mechanism will allow a subnet to eventually become consistent; the AssertCancel mechanism simply causes faster convergence. No special processing is required for an AssertCancel message, since it is simply an Assert message from the current winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel消息只是一种优化。最初的断言超时机制将允许子网最终变得一致；AssertCancel机制只会加快收敛速度。AssertCancel消息不需要特殊处理，因为它只是来自当前获胜者的断言消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.5. Assert State Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.5. 断言状态宏
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macros lost_assert(S,G,rpt,I), lost_assert(S,G,I), and lost_assert(*,G,I) are used in the olist computations of Section 4.1, and are defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏lost_assert（S，G，rpt，I）、lost_assert（S，G，I）和lost_assert（*，G，I）用于第4.1节的olist计算，定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool lost_assert(S,G,rpt,I) {
       if ( RPF_interface(RP(G)) == I  OR
            ( RPF_interface(S) == I AND SPTbit(S,G) == TRUE ) ) {
          return FALSE
       } else {
          return ( AssertWinner(S,G,I) != NULL AND
                   AssertWinner(S,G,I) != me )
       }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool lost_assert(S,G,rpt,I) {
       if ( RPF_interface(RP(G)) == I  OR
            ( RPF_interface(S) == I AND SPTbit(S,G) == TRUE ) ) {
          return FALSE
       } else {
          return ( AssertWinner(S,G,I) != NULL AND
                   AssertWinner(S,G,I) != me )
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool lost_assert(S,G,I) {
       if ( RPF_interface(S) == I ) {
          return FALSE
       } else {
          return ( AssertWinner(S,G,I) != NULL AND
                   AssertWinner(S,G,I) != me  AND
                   (AssertWinnerMetric(S,G,I) is better
                      than spt_assert_metric(S,I) )
       }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool lost_assert(S,G,I) {
       if ( RPF_interface(S) == I ) {
          return FALSE
       } else {
          return ( AssertWinner(S,G,I) != NULL AND
                   AssertWinner(S,G,I) != me  AND
                   (AssertWinnerMetric(S,G,I) is better
                      than spt_assert_metric(S,I) )
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: the term &#34;AssertWinnerMetric(S,G,I) is better than spt_assert_metric(S,I)&#34; is required to correctly handle the transition phase when a router has (S,G) join state, but has not yet set the SPT bit. In this case, it needs to ignore the assert state if it will win the assert once the SPTbit is set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：当路由器具有（S，G）连接状态但尚未设置spt位时，需要术语“AssertWinnerMetric（S，G，I）优于spt_assert_metric（S，I）”来正确处理过渡阶段。在这种情况下，如果设置SPTbit后它将赢得断言，则需要忽略断言状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool lost_assert(*,G,I) {
       if ( RPF_interface(RP(G)) == I ) {
          return FALSE
       } else {
          return ( AssertWinner(*,G,I) != NULL AND
                   AssertWinner(*,G,I) != me )
       }
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     bool lost_assert(*,G,I) {
       if ( RPF_interface(RP(G)) == I ) {
          return FALSE
       } else {
          return ( AssertWinner(*,G,I) != NULL AND
                   AssertWinner(*,G,I) != me )
       }
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinner(S,G,I) is the IP source address of the Assert(S,G) packet that won an Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinner（S，G，I）是赢得断言的断言（S，G）数据包的IP源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinner(*,G,I) is the IP source address of the Assert(*,G) packet that won an Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinner（*，G，I）是赢得断言的断言（*，G）数据包的IP源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinnerMetric(S,G,I) is the Assert metric of the Assert(S,G) packet that won an Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinnerMetric（S，G，I）是赢得断言的断言（S，G）数据包的断言度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinnerMetric(*,G,I) is the Assert metric of the Assert(*,G) packet that won an Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinnerMetric（*，G，I）是赢得断言的断言（*，G）数据包的断言度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinner(S,G,I) defaults to NULL and AssertWinnerMetric(S,G,I) defaults to Infinity when in the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在NoInfo状态下，AssertWinner（S，G，I）默认为NULL，AssertWinnerMetric（S，G，I）默认为无穷大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Summary of Assert Rules and Rationale
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断言规则和基本原理概述
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section summarizes the key rules for sending and reacting to asserts and the rationale for these rules. This section is not intended to be and should not be treated as a definitive specification of protocol behavior. The state machines and pseudocode should be consulted for that purpose. Rather, this section is intended to document important aspects of the Assert protocol behavior and to provide information that may prove helpful to the reader in understanding and implementing this part of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节总结了发送和回应资产的关键规则以及这些规则的基本原理。本节无意也不应被视为协议行为的最终规范。为此，应参考状态机和伪代码。相反，本节旨在记录断言协议行为的重要方面，并提供可能有助于读者理解和实现协议这一部分的信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Behavior: Downstream neighbors send Join(*,G) and Join(S,G) periodic messages to the appropriate RPF&#39; neighbor, i.e., the RPF neighbor as modified by the assert process. They are not always sent to the RPF neighbor as indicated by the MRIB. Normal suppression and override rules apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 行为：下游邻居将Join（*，G）和Join（S，G）定期消息发送到适当的RPF邻居，即由断言进程修改的RPF邻居。它们并不总是按照MRIB的指示发送到RPF邻居。正常抑制和覆盖规则适用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: By sending the periodic and triggered Join messages to the RPF&#39; neighbor instead of to the RPF neighbor, the downstream router avoids re-triggering the Assert process with every Join. A side effect of sending Joins to the Assert winner is that traffic will not switch back to the &#34;normal&#34; RPF neighbor until the Assert times out. This will not happen until data stops flowing, if item 8, below, is implemented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：通过向RPF的邻居而不是RPF邻居发送定期和触发的连接消息，下游路由器避免在每次连接时重新触发断言过程。向断言赢家发送连接的一个副作用是，在断言超时之前，通信量不会切换回“正常”RPF邻居。如果执行了下面的第8项，则在数据停止流动之前，不会发生这种情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Behavior: The assert winner for (*,G) acts as the local DR for (*,G) on behalf of IGMP/MLD members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 行为：（*，G）的断言获胜者代表IGMP/MLD成员充当（*，G）的本地DR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: This is required to allow a single router to merge PIM and IGMP/MLD joins and leaves. Without this, overrides don&#39;t work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：这是允许单个路由器合并PIM和IGMP/MLD连接和离开所必需的。没有这一点，覆盖就不起作用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Behavior: The assert winner for (S,G) acts as the local DR for (S,G) on behalf of IGMPv3 members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 行为：（S，G）的断言获胜者代表IGMPv3成员充当（S，G）的本地DR。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: Same rationale as for item 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：与第2项的理由相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Behavior: (S,G) and (*,G) prune overrides are sent to the RPF&#39; neighbor and not to the regular RPF neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 行为：（S，G）和（*，G）修剪覆盖被发送到RPF的邻居，而不是常规RPF邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: Same rationale as for item 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：与第1项的理由相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Behavior: An (S,G,rpt) prune override is not sent (at all) if RPF&#39;(S,G,rpt) != RPF&#39;(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 行为：如果RPF’（S，G，rpt）！=RPF&#39;（*，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: This avoids keeping state alive on the (S,G) tree when only (*,G) downstream members are left. Also, it avoids sending (S,G,rpt) joins to a router that is not on the (*,G) tree. This behavior might be confusing although this specification does indicate that such a join should be dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：这样可以避免在只剩下（*，G）下游成员时，使（S，G）树上的状态保持活动状态。此外，它还避免将（S、G、rpt）连接发送到不在（*，G）树上的路由器。尽管此规范确实指示应该删除这样的连接，但此行为可能会令人困惑。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Behavior: An assert loser that receives a Join(S,G) with an Upstream Neighbor Address that is its primary IP address on that interface cancels the (S,G) Assert Timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 行为：断言失败者接收到一个连接（S，G），其上游邻居地址是其在该接口上的主IP地址，则取消（S，G）断言计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: This is necessary in order to have rapid convergence in the event that the downstream router that initially sent a join to the prior Assert winner has undergone a topology change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：这是必要的，以便在最初向先前的断言赢家发送连接的下游路由器发生拓扑更改时快速收敛。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. Behavior: An assert loser that receives a Join(*,G) or a Join(*,*,RP(G)) with an Upstream Neighbor Address that is its primary IP address on that interface cancels the (*,G) Assert Timer and all (S,G) assert timers that do not have corresponding Prune(S,G,rpt) messages in the compound Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. 行为：如果断言丢失器接收到连接（*，G）或连接（*，*，RP（G）），且上游邻居地址是其在该接口上的主IP地址，则会取消（*，G）断言计时器以及在复合联接/修剪消息中没有相应修剪（S，G，rpt）消息的所有（S，G）断言计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: Same rationale as for item 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：与第6项的理由相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Behavior: An assert winner for (*,G) or (S,G) sends a canceling assert when it is about to stop forwarding on a (*,G) or an (S,G) entry. This behavior does not apply to (S,G,rpt).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. 行为：（*，G）或（S，G）的断言获胜者在将要停止对（*，G）或（S，G）项的转发时发送取消断言。此行为不适用于（S、G、rpt）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: This allows switching back to the shared tree after the last SPT router on the LAN leaves. Doing this prevents downstream routers on the shared tree from keeping SPT state alive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：这允许在LAN上的最后一个SPT路由器离开后切换回共享树。这样做可以防止共享树上的下游路由器使SPT状态保持活动状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Behavior: Resend the assert messages before timing out an assert. (This behavior is optional.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. 行为：在超时断言之前重新发送断言消息。（此行为是可选的。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: This prevents the periodic duplicates that would otherwise occur each time that an assert times out and is then re-established.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：这可以防止在每次断言超时然后重新建立时发生周期性重复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. Behavior: When RPF&#39;(S,G,rpt) changes to be the same as RPF&#39;(*,G) we need to trigger a Join(S,G,rpt) to RPF&#39;(*,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
10. 行为：当RPF&#39;（S，G，rpt）更改为与RPF&#39;（*，G）相同时，我们需要触发到RPF&#39;（*，G）的连接（S，G，rpt）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Rationale: This allows switching back to the RPT after the last SPT member leaves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
理由：这允许在最后一个SPT成员离开后切换回RPT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. PIM Bootstrap and RP Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. PIM引导和RP发现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For correct operation, every PIM router within a PIM domain must be able to map a particular multicast group address to the same RP. If this is not the case, then black holes may appear, where some receivers in the domain cannot receive some groups. A domain in this context is a contiguous set of routers that all implement PIM and are configured to operate within a common boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了正确操作，PIM域内的每个PIM路由器必须能够将特定的多播组地址映射到同一RP。如果不是这样，则可能出现黑洞，其中域中的某些接收器无法接收某些组。在此上下文中，域是一组连续的路由器，它们都实现PIM，并配置为在公共边界内运行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A notable exception to this is where a PIM domain is broken up into multiple administrative scope regions; these are regions where a border has been configured so that a range of multicast groups will not be forwarded across that border. For more information on Administratively Scoped IP Multicast, see RFC 2365. The modified criteria for admin-scoped regions are that the region is convex with respect to forwarding based on the MRIB, and that all PIM routers within the scope region map scoped groups to the same RP within that region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个值得注意的例外是PIM域被分成多个管理范围区域；在这些区域中，已配置了边界，以便一系列多播组不会跨该边界转发。有关管理作用域IP多播的更多信息，请参阅RFC 2365。管理范围区域的修改标准是，该区域相对于基于MRIB的转发是凸的，并且范围区域内的所有PIM路由器将范围组映射到该区域内的相同RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification does not mandate the use of a single mechanism to provide routers with the information to perform the group-to-RP mapping. Currently four mechanisms are possible, and all four have associated problems:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本规范不要求使用单一机制向路由器提供执行组到RP映射的信息。目前有四种机制是可能的，并且所有四种机制都存在相关问题：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Static Configuration A PIM router MUST support the static configuration of group-to-RP mappings. Such a mechanism is not robust to failures, but does at least provide a basic interoperability mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态配置PIM路由器必须支持组到RP映射的静态配置。这样一种机制对故障并不健壮，但至少提供了一种基本的互操作性机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Embedded-RP Embedded-RP defines an address allocation policy in which the address of the Rendezvous Point (RP) is encoded in an IPv6 multicast group address [17].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Embedded RP Embedded RP定义了一种地址分配策略，其中集合点（RP）的地址编码在IPv6多播组地址中[17]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cisco&#39;s Auto-RP Auto-RP uses a PIM Dense-Mode multicast group to announce group-to-RP mappings from a central location. This mechanism is not useful if PIM Dense-Mode is not being run in parallel with PIM Sparse-Mode, and was only intended for use with PIM Sparse-Mode Version 1. No standard specification currently exists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cisco的Auto RP Auto RP使用PIM密集模式多播组从中心位置宣布组到RP的映射。如果PIM密集模式未与PIM稀疏模式并行运行，并且仅用于PIM稀疏模式版本1，则此机制不可用。目前没有标准规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BootStrap Router (BSR) RFC 2362 specifies a bootstrap mechanism based on the automatic election of a bootstrap router (BSR). Any router in the domain that is configured to be a possible RP reports its candidacy to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引导路由器（BSR）RFC 2362基于引导路由器（BSR）的自动选择指定引导机制。域中任何配置为可能RP的路由器都会向
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
the BSR, and then a domain-wide flooding mechanism distributes the BSR&#39;s chosen set of RPs throughout the domain. As specified in RFC 2362, BSR is flawed in its handling of admin-scoped regions that are smaller than a PIM domain, but the mechanism does work for global-scoped groups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
BSR，然后是一个域范围的泛洪机制，在整个域中分发BSR选择的一组RP。如RFC 2362所述，BSR在处理小于PIM域的管理范围的区域时存在缺陷，但该机制确实适用于全局范围的组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As far as PIM-SM is concerned, the only important requirement is that all routers in the domain (or admin scope zone for scoped regions) receive the same set of group-range-to-RP mappings. This may be achieved through the use of any of these mechanisms, or through alternative mechanisms not currently specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
就PIM-SM而言，唯一重要的要求是域中的所有路由器（或范围区域的管理范围区域）接收相同的组范围到RP映射集。这可以通过使用这些机制中的任何一种来实现，或者通过当前未指定的替代机制来实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It must be operationally ensured that any RP address configured, learned, or advertised is reachable from all routers in the PIM domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须在操作上确保配置、学习或公布的任何RP地址可从PIM域中的所有路由器访问。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.1. Group-to-RP Mapping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.1. 组到RP映射
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using one of the mechanisms described above, a PIM router receives one or more possible group-range-to-RP mappings. Each mapping specifies a range of multicast groups (expressed as a group and mask) and the RP to which such groups should be mapped. Each mapping may also have an associated priority. It is possible to receive multiple mappings, all of which might match the same multicast group; this is the common case with BSR. The algorithm for performing the group-to-RP mapping is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用上述机制之一，PIM路由器接收一个或多个可能的组范围到RP映射。每个映射指定多播组的范围（表示为组和掩码）以及这些组应映射到的RP。每个映射也可能具有关联的优先级。可以接收多个映射，所有映射都可能匹配同一个多播组；这是BSR的常见情况。执行组到RP映射的算法如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Perform longest match on group-range to obtain a list of RPs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 对组范围执行最长匹配以获取RPs列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. From this list of matching RPs, find the one with highest priority. Eliminate any RPs from the list that have lower priorities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 从匹配的RPs列表中，找到优先级最高的RPs。从列表中删除优先级较低的所有RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. If only one RP remains in the list, use that RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 如果列表中只剩下一个RP，则使用该RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If multiple RPs are in the list, use the PIM hash function to choose one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 如果列表中有多个RP，请使用PIM哈希函数选择一个。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thus, if two or more group-range-to-RP mappings cover a particular group, the one with the longest mask is the mapping to use. If the mappings have the same mask length, then the one with the highest priority is chosen. If there is more than one matching entry with the same longest mask and the priorities are identical, then a hash function (see Section 4.7.2) is applied to choose the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，如果两个或多个“组范围到RP”映射覆盖一个特定的组，则具有最长掩码的映射就是要使用的映射。如果映射具有相同的掩码长度，则选择具有最高优先级的映射。如果有多个匹配条目具有相同的最长掩码，且优先级相同，则应用哈希函数（见第4.7.2节）选择RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm is invoked by a DR when it needs to determine an RP for a given group, e.g., upon reception of a packet or IGMP/MLD membership indication for a group for which the DR does not know the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当DR需要确定给定组的RP时，例如，在接收到DR不知道该组的分组或IGMP/MLD成员资格指示时，DR调用该算法
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP. It is invoked by any router that has (*,*,RP) state when a packet is received for which there is no corresponding (S,G) or (*,G) entry. Furthermore, the mapping function is invoked by all routers upon receiving a (*,G) or (*,*,RP) Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RP。当接收到没有相应（S，G）或（*，G）条目的数据包时，任何具有（*，*，RP）状态的路由器都会调用它。此外，所有路由器在接收（*，G）或（*，*，RP）连接/修剪消息时都会调用映射函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if the set of possible group-range-to-RP mappings changes, each router will need to check whether any existing groups are affected. This may, for example, cause a DR or acting DR to re-join a group, or cause it to restart register encapsulation to the new RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，如果可能的组范围到RP映射集发生更改，每个路由器将需要检查是否有任何现有组受到影响。例如，这可能导致DR或代理DR重新加入组，或导致其重新启动对新RP的寄存器封装。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Implementation note: the bootstrap mechanism described in RFC 2362 omitted step 1 above. However, of the implementations we are aware of, approximately half performed step 1 anyway. Note that implementations of BSR that omit step 1 will not correctly interoperate with implementations of this specification when used with the BSR mechanism described in [11].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
实现说明：RFC 2362中描述的引导机制省略了上面的步骤1。然而，在我们所知道的实现中，大约有一半执行了步骤1。请注意，当与[11]中描述的BSR机制一起使用时，省略步骤1的BSR实现将无法与本规范的实现正确互操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.2. Hash Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.2. 散列函数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hash function is used by all routers within a domain, to map a group to one of the RPs from the matching set of group-range-to-RP mappings (this set all have the same longest mask length and same highest priority). The algorithm takes as input the group address, and the addresses of the candidate RPs from the mappings, and gives as output one RP address to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个域内的所有路由器都使用哈希函数，将一个组从组范围到RP映射的匹配集映射到一个RP（这一组都具有相同的最长掩码长度和相同的最高优先级）。该算法以组地址和映射中的候选RP地址作为输入，并给出一个要使用的RP地址作为输出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol requires that all routers hash to the same RP within a domain (except for transients). The following hash function must be used in each router:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该协议要求所有路由器散列到域内的相同RP（瞬态除外）。每个路由器中必须使用以下哈希函数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. For RP addresses in the matching group-range-to-RP mappings, compute a value:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 对于匹配组范围到RP映射中的RP地址，计算一个值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Value(G,M,C(i))=
   (1103515245 * ((1103515245 * (G&amp;M)+12345) XOR C(i)) + 12345) mod 2^31
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Value(G,M,C(i))=
   (1103515245 * ((1103515245 * (G&amp;M)+12345) XOR C(i)) + 12345) mod 2^31
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
where C(i) is the RP address and M is a hash-mask. If BSR is being used, the hash-mask is given in the Bootstrap messages. If BSR is not being used, the alternative mechanism that supplies the group-range-to-RP mappings may supply the value, or else it defaults to a mask with the most significant 30 bits being one for IPv4 and the most significant 126 bits being one for IPv6. The hash-mask allows a small number of consecutive groups (e.g., 4) to always hash to the same RP. For instance, hierarchically-encoded data can be sent on consecutive group addresses to get the same delay and fate-sharing characteristics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
其中C（i）是RP地址，M是散列掩码。如果在引导掩码中使用了BSR，则在引导掩码中使用BSR。如果未使用BSR，则向RP映射提供组范围的替代机制可能会提供该值，否则它默认为一个掩码，对于IPv4，最高有效30位为1，对于IPv6，最高有效126位为1。哈希掩码允许少量连续组（例如，4）始终哈希到同一RP。例如，可以在连续组地址上发送分层编码的数据，以获得相同的延迟和命运共享特性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
For address families other than IPv4, a 32-bit digest to be used as C(i) and G must first be derived from the actual RP or group address. Such a digest method must be used consistently throughout the PIM domain. For IPv6 addresses, we recommend using the equivalent IPv4 address for an IPv4-compatible address, and the exclusive-or of each 32-bit segment of the address for all other IPv6 addresses. For example, the digest of the IPv6 address 3ffe:b00:c18:1::10 would be computed as 0x3ffe0b00 ^ 0x0c180001 ^ 0x00000000 ^ 0x00000010, where ^ represents the exclusive-or operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
对于IPv4以外的地址系列，用作C（i）和G的32位摘要必须首先从实际RP或组地址派生。这种摘要方法必须在整个PIM领域内一致使用。对于IPv6地址，我们建议将等效IPv4地址用于IPv4兼容地址，并将地址的每个32位段的异或用于所有其他IPv6地址。例如，IPv6地址3ffe:b00:c18:1:：10的摘要将被计算为0x3ffe0b00^0x0c180001^0x00000000^0x00000010，其中^表示异或操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The candidate RP with the highest resulting hash value is then the RP chosen by this Hash Function. If more than one RP has the same highest hash value, the RP with the highest IP address is chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 具有最高结果散列值的候选RP是该散列函数选择的RP。如果多个RP具有相同的最高哈希值，则选择IP地址最高的RP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Source-Specific Multicast
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. 源特定多播
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Source-Specific Multicast (SSM) service model [6] can be implemented with a strict subset of the PIM-SM protocol mechanisms. Both regular IP Multicast and SSM semantics can coexist on a single router, and both can be implemented using the PIM-SM protocol. A range of multicast addresses, currently 232.0.0.0/8 in IPv4 and FF3x::/32 for IPv6, is reserved for SSM, and the choice of semantics is determined by the multicast group address in both data packets and PIM messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
源特定多播（SSM）服务模型[6]可以通过PIM-SM协议机制的严格子集来实现。常规IP多播和SSM语义都可以在单个路由器上共存，并且都可以使用PIM-SM协议实现。SSM保留了一系列多播地址，目前IPv4为232.0.0.0/8，IPv6为FF3x:：/32，语义的选择由数据包和PIM消息中的多播组地址决定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8.1. Protocol Modifications for SSM Destination Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8.1. SSM目标地址的协议修改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following rules override the normal PIM-SM behavior for a multicast address G in the SSM range:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下规则覆盖SSM范围内多播地址G的正常PIM-SM行为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router MUST NOT send a (*,G) Join/Prune message for any reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 路由器不得出于任何原因发送（*，G）加入/删除消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router MUST NOT send an (S,G,rpt) Join/Prune message for any reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 路由器不得出于任何原因发送（S、G、rpt）加入/删除消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router MUST NOT send a Register message for any packet that is destined to an SSM address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 路由器不得发送目的地为SSM地址的任何数据包的注册消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router MUST NOT forward packets based on (*,G) or (S,G,rpt) state. The (*,G)- and (S,G,rpt)-related state summarization macros are NULL for any SSM address, for the purposes of packet forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 路由器不得基于（*，G）或（S，G，rpt）状态转发数据包。与（*，G）和（S，G，rpt）相关的状态摘要宏对于任何SSM地址都为空，用于数据包转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router acting as an RP MUST NOT forward any Register-encapsulated packet that has an SSM destination address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 作为RP的路由器不得转发任何具有SSM目标地址的寄存器封装数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The last two rules are present to deal with &#34;legacy&#34; routers unaware of SSM that may be sending (*,G) and (S,G,rpt) Join/Prunes, or Register messages for SSM destination addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后两条规则用于处理不知道SSM的“遗留”路由器，这些路由器可能正在发送（*，G）和（S，G，rpt）加入/删除SSM目标地址或注册SSM目标地址的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router MAY be configured to advertise itself as a Candidate RP for an SSM address. If so, it SHOULD respond with a Register-Stop message to any Register message containing a packet destined for an SSM address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 路由器可被配置为将其自身作为SSM地址的候选RP进行公告。如果是这样，它应该用寄存器停止消息响应任何寄存器消息，该消息包含一个发送到SSM地址的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A router MAY optimize out the creation and maintenance of (S,G,rpt) and (*,G) state for SSM destination addresses -- this state is not needed for SSM packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 路由器可以优化SSM目标地址（S，G，rpt）和（*，G）状态的创建和维护——SSM数据包不需要这种状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8.2. PIM-SSM-Only Routers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8.2. 仅限PIM SSM路由器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementer may choose to implement only the subset of PIM Sparse-Mode that provides SSM forwarding semantics.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现者可以选择仅实现提供SSM转发语义的PIM稀疏模式的子集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM-SSM-only router MUST implement the following portions of this specification:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仅PIM SSM路由器必须实现本规范的以下部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Upstream (S,G) state machine (Section 4.5.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 上游（S，G）状态机（第4.5.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Downstream (S,G) state machine (Section 4.5.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 下游（S，G）状态机（第4.5.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o (S,G) Assert state machine (Section 4.6.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o （S，G）断言状态机（第4.6.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Hello messages, neighbor discovery, and DR election (Section 4.3)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 你好消息、邻居发现和灾难恢复选择（第4.3节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Packet forwarding rules (Section 4.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 数据包转发规则（第4.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM-SSM-only router does not need to implement the following protocol elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仅PIM SSM路由器不需要实现以下协议元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Register state machine (Section 4.4)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 寄存器状态机（第4.4节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o (*,G), (S,G,rpt), and (*,*,RP) Downstream state machines (Sections 4.5.2, 4.5.4, and 4.5.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o （*，G）、（S，G，rpt）和（*，*，RP）下游状态机（第4.5.2、4.5.4和4.5.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o (*,G), (S,G,rpt), and (*,*,RP) Upstream state machines (Sections 4.5.6, 4.5.8, and 4.5.5)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o （*，G）、（S，G，rpt）和（*，*，RP）上游状态机（第4.5.6、4.5.8和4.5.5节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o (*,G) Assert state machine (Section 4.6.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o （*，G）断言状态机（第4.6.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Bootstrap RP Election (Section 4.7)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 引导RP选举（第4.7节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Keepalive Timer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 保持计时器
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SPTbit (Section 4.2.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SPTbit（第4.2.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Keepalive Timer should be treated as always running, and SPTbit should be treated as always being set for an SSM address. Additionally, the Packet forwarding rules of Section 4.2 can be simplified in a PIM-SSM-only router:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keepalive计时器应视为始终运行，而SPTbit应视为始终为SSM地址设置。此外，第4.2节的数据包转发规则可在仅PIM SSM路由器中简化：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined ) {
         oiflist = inherited_olist(S,G)
     } else if( iif is in inherited_olist(S,G) ) {
         send Assert(S,G) on iif
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if( iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined ) {
         oiflist = inherited_olist(S,G)
     } else if( iif is in inherited_olist(S,G) ) {
         send Assert(S,G) on iif
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
oiflist = oiflist (-) iif forward packet on all interfaces in oiflist
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
oiflist=oiflist（-）oiflist中所有接口上的iif转发数据包
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is nothing more than the reduction of the normal PIM-SM forwarding rule, with all (S,G,rpt) and (*,G) clauses replaced with NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这只不过是普通PIM-SM转发规则的简化，所有（S，G，rpt）和（*，G）子句都替换为NULL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. PIM Packet Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9. PIM数据包格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the details of the packet formats for PIM control messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍PIM控制消息的数据包格式的详细信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All PIM control messages have IP protocol number 103.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有PIM控制消息的IP协议号均为103。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM messages are either unicast (e.g., Registers and Register-Stop) or multicast with TTL 1 to the &#39;ALL-PIM-ROUTERS&#39; group (e.g., Join/Prune, Asserts, etc.). The source address used for unicast messages is a domain-wide reachable address; the source address used for multicast messages is the link-local address of the interface on which the message is being sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM消息可以是单播（例如，寄存器和寄存器停止）或TTL 1到“所有PIM路由器”组的多播（例如，加入/删除、断言等）。用于单播消息的源地址是域范围的可到达地址；用于多播消息的源地址是发送消息的接口的链路本地地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPv4 &#39;ALL-PIM-ROUTERS&#39; group is &#39;224.0.0.13&#39;. The IPv6 &#39;ALL-PIM-ROUTERS&#39; group is &#39;ff02::d&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4“所有PIM路由器”组为“224.0.0.13”。IPv6“ALL-PIM-ROUTERS”组为“ff02:：d”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM header common to all PIM messages is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有PIM消息共有的PIM标头为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Ver PIM Version number is 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM版本号为2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Types for specific PIM messages. PIM Types are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入特定PIM消息的类型。PIM类型包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Message Type                          Destination
   ---------------------------------------------------------------------
   0 = Hello                             Multicast to ALL-PIM-ROUTERS
   1 = Register                          Unicast to RP
   2 = Register-Stop                     Unicast to source of Register
                                            packet
   3 = Join/Prune                        Multicast to ALL-PIM-ROUTERS
   4 = Bootstrap                         Multicast to ALL-PIM-ROUTERS
   5 = Assert                            Multicast to ALL-PIM-ROUTERS
   6 = Graft (used in PIM-DM only)       Unicast to RPF&#39;(S)
   7 = Graft-Ack (used in PIM-DM only)   Unicast to source of Graft
                                            packet
   8 = Candidate-RP-Advertisement        Unicast to Domain&#39;s BSR
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Message Type                          Destination
   ---------------------------------------------------------------------
   0 = Hello                             Multicast to ALL-PIM-ROUTERS
   1 = Register                          Unicast to RP
   2 = Register-Stop                     Unicast to source of Register
                                            packet
   3 = Join/Prune                        Multicast to ALL-PIM-ROUTERS
   4 = Bootstrap                         Multicast to ALL-PIM-ROUTERS
   5 = Assert                            Multicast to ALL-PIM-ROUTERS
   6 = Graft (used in PIM-DM only)       Unicast to RPF&#39;(S)
   7 = Graft-Ack (used in PIM-DM only)   Unicast to source of Graft
                                            packet
   8 = Candidate-RP-Advertisement        Unicast to Domain&#39;s BSR
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Set to zero on transmission. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
传输时保留设置为零。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Checksum The checksum is a standard IP checksum, i.e., the 16-bit one&#39;s complement of the one&#39;s complement sum of the entire PIM message, excluding the &#34;Multicast data packet&#34; section of the Register message. For computing the checksum, the checksum field is zeroed. If the packet&#39;s length is not an integral number of 16-bit words, the packet is padded with a trailing byte of zero before performing the checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
校验和校验和是标准IP校验和，即整个PIM消息的16位1的补码，不包括寄存器消息的“多播数据包”部分。为了计算校验和，校验和字段被置零。如果数据包的长度不是16位字的整数，则在执行校验和之前，数据包将填充一个尾随字节零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
For IPv6, the checksum also includes the IPv6 &#34;pseudo-header&#34;, as specified in RFC 2460, Section 8.1 [5]. This &#34;pseudo-header&#34; is prepended to the PIM header for the purposes of calculating the checksum. The &#34;Upper-Layer Packet Length&#34; in the pseudo-header is set to the length of the PIM message, except in Register messages where it is set to the length of the PIM register header (8). The Next Header value used in the pseudo-header is 103.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
对于IPv6，校验和还包括IPv6“伪报头”，如RFC 2460第8.1[5]节所述。为了计算校验和，在PIM报头前加上“伪报头”。伪报头中的“上层数据包长度”设置为PIM消息的长度，但寄存器消息中的“上层数据包长度”设置为PIM寄存器报头（8）的长度除外。伪报头中使用的下一个报头值是103。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a message is received with an unrecognized PIM Ver or Type field, or if a message&#39;s destination does not correspond to the table above, the message MUST be discarded, and an error message SHOULD be logged to the administrator in a rate-limited manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果收到带有无法识别的PIM版本或类型字段的消息，或者如果消息的目的地与上表不符，则必须丢弃该消息，并以速率受限的方式向管理员记录错误消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1. Encoded Source and Group Address Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.1. 编码源和组地址格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoded-Unicast Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码单播地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Encoded-Unicast address takes the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码单播地址采用以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |     Unicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |     Unicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family The PIM address family of the &#39;Unicast Address&#39; field of this address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family此地址的“单播地址”字段的PIM地址系列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Values 0-127 are as assigned by the IANA for Internet Address Families in [7]. Values 128-250 are reserved to be assigned by the IANA for PIM-specific Address Families. Values 251 though 255 are designated for private use. As there is no assignment authority for this space, collisions should be expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
IANA为[7]中的互联网地址族指定了值0-127。IANA为PIM特定地址系列保留了128-250的值。值251到255指定为私人使用。由于此空间没有分配权限，因此可能会发生碰撞。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Type The type of encoding used within a specific Address Family. The value &#39;0&#39; is reserved for this field and represents the native encoding of the Address Family.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码类型特定地址族中使用的编码类型。值“0”是为此字段保留的，表示地址族的本机编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicast Address The unicast address as represented by the given Address Family and Encoding Type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单播地址由给定地址族和编码类型表示的单播地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoded-Group Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码组地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoded-Group addresses take the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码组地址采用以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Group multicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Group multicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上面描述的Addr族。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Type Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述编码类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[B]idirectional PIM Indicates the group range should use Bidirectional PIM [13]. For PIM-SM defined in this specification, this bit MUST be zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[B] I方向PIM表示组范围应使用双向PIM[13]。对于本规范中定义的PIM-SM，该位必须为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Transmitted as zero. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留传输为零。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Admin Scope [Z]one indicates the group range is an admin scope zone. This is used in the Bootstrap Router Mechanism [11] only. For all other purposes, this bit is set to zero and ignored on receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
管理范围[Z]一表示组范围是管理范围区域。这仅用于引导路由器机制[11]。出于所有其他目的，该位设置为零，并在接收时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mask Len The Mask length field is 8 bits. The value is the number of contiguous one bits that are left justified and used as a mask; when combined with the group address, it describes a range of groups. It is less than or equal to the address length in bits for the given Address Family and Encoding Type. If the message is sent for a single group, then the Mask length must equal the address length in bits for the given Address Family and Encoding Type (e.g., 32 for IPv4 native encoding, 128 for IPv6 native encoding).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
掩码长度掩码长度字段为8位。该值是左对齐并用作掩码的连续1位的数目；当与组地址结合使用时，它描述了一系列组。它小于或等于给定地址族和编码类型的地址长度（以位为单位）。如果为单个组发送消息，则掩码长度必须等于给定地址系列和编码类型的地址长度（以位为单位）（例如，IPv4本机编码为32，IPv6本机编码为128）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group multicast Address Contains the group address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组多播地址包含组地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoded-Source Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码源地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoded-Source address takes the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码源地址采用以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Addr Family   | Encoding Type | Rsrvd   |S|W|R|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Source Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Addr Family   | Encoding Type | Rsrvd   |S|W|R|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Source Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上面描述的Addr族。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Type Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述编码类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Transmitted as zero, ignored on receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留传输为零，接收时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S The Sparse bit is a 1-bit value, set to 1 for PIM-SM. It is used for PIM version 1 compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S稀疏位为1位值，对于PIM-SM设置为1。它用于PIM版本1的兼容性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W The WC (or WildCard) bit is a 1-bit value for use with PIM Join/Prune messages (see Section 4.9.5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W WC（或通配符）位是用于PIM连接/删除消息的1位值（见第4.9.5.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R The RPT (or Rendezvous Point Tree) bit is a 1-bit value for use with PIM Join/Prune messages (see Section 4.9.5.1). If the WC bit is 1, the RPT bit MUST be 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R RPT（或集合点树）位是一个1位值，用于PIM连接/删除消息（见第4.9.5.1节）。如果WC位为1，则RPT位必须为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mask Len The mask length field is 8 bits. The value is the number of contiguous one bits left justified used as a mask which, combined with the Source Address, describes a source subnet. The mask length MUST be equal to the mask length in bits for the given Address Family and Encoding Type (32 for IPv4 native and 128 for IPv6 native). A router SHOULD ignore any messages received with any other mask length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
掩码长度掩码长度字段为8位。该值是用作掩码的左对齐的连续一位的数目，该掩码与源地址一起描述源子网。掩码长度必须等于给定地址系列和编码类型的掩码长度（32表示IPv4本机，128表示IPv6本机）。路由器应忽略使用任何其他掩码长度接收的任何消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source Address The source address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
源地址源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.2. Hello Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.2. 你好消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is sent periodically by routers on all interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
它由所有接口上的路由器定期发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          OptionType           |         OptionLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          OptionValue                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          OptionType           |         OptionLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          OptionValue                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          OptionType           |         OptionLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          OptionValue                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          OptionType           |         OptionLength          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          OptionValue                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Version, Type, Reserved, Checksum Described in Section 4.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.9节中描述的PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptionType The type of the option given in the following OptionValue field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptionType以下OptionValue字段中给定的选项类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptionLength The length of the OptionValue field in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptionLength OptionValue字段的长度（以字节为单位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptionValue A variable length field, carrying the value of the option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptionValue一个可变长度字段，携带选项的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Option fields may contain the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项字段可能包含以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 1: Holdtime
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 选项类型1：保持时间
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 1             |         Length = 2            |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Holdtime             |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 1             |         Length = 2            |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Holdtime             |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Holdtime is the amount of time a receiver must keep the neighbor reachable, in seconds. If the Holdtime is set to &#39;0xffff&#39;, the receiver of this message never times out the neighbor. This may be used with dial-on-demand links, to avoid keeping the link up with periodic Hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Holdtime是接收器必须使邻居保持可访问状态的时间量，以秒为单位。如果Holdtime设置为“0xffff”，则此消息的接收者不会使邻居超时。这可以与按需拨号链接一起使用，以避免使用周期性Hello消息保持链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Hello messages with a Holdtime value set to &#39;0&#39; are also sent by a router on an interface about to go down or changing IP address (see Section 4.3.1). These are effectively goodbye messages, and the receiving routers should immediately time out the neighbor information for the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Holdtime值设置为“0”的Hello消息也由路由器在即将关闭或更改IP地址的接口上发送（请参阅第4.3.1节）。这些都是有效的告别消息，接收路由器应该立即为发送者超时邻居信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 2: LAN Prune Delay
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 选项类型2：LAN删除延迟
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 2             |          Length = 4           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |T|      Propagation_Delay      |      Override_Interval        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 2             |          Length = 4           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |T|      Propagation_Delay      |      Override_Interval        |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
The LAN Prune Delay option is used to tune the prune propagation delay on multi-access LANs. The T bit specifies the ability of the sending router to disable joins suppression. Propagation_Delay and Override_Interval are time intervals in units of milliseconds. A router originating a LAN Prune Delay option on interface I sets the Propagation_Delay field to the configured value of Propagation_Delay(I) and the value of the Override_Interval field to the value of Override_Interval(I). On a receiving router, the values of the fields are used to tune the value of the Effective_Override_Interval(I) and its derived timer values. Section 4.3.3 describes how these values affect the behavior of a router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
LAN修剪延迟选项用于调整多访问LAN上的修剪传播延迟。T位指定发送路由器禁用连接抑制的能力。传播延迟和覆盖间隔是以毫秒为单位的时间间隔。在接口I上发起LAN修剪延迟选项的路由器将传播延迟字段设置为传播延迟（I）的配置值，将覆盖间隔字段的值设置为覆盖间隔（I）的值。在接收路由器上，字段值用于调整有效_覆盖_间隔（I）的值及其导出的计时器值。第4.3.3节描述了这些值如何影响路由器的行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 3 to 16: reserved to be defined in future versions of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 选项类型3至16：保留在本文档的未来版本中定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 18: deprecated and should not be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 18:已弃用，不应使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 19: DR Priority
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 选项类型19：灾难恢复优先级
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 19            |          Length = 4           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         DR Priority                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 19            |          Length = 4           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                         DR Priority                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
DR Priority is a 32-bit unsigned number and should be considered in the DR election as described in Section 4.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
DR优先级是一个32位无符号数字，应在DR选择中予以考虑，如第4.3.2节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 20: Generation ID
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 选项类型20：生成ID
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 20            |          Length = 4           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       Generation ID                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 20            |          Length = 4           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |                       Generation ID                           |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Generation ID is a random 32-bit value for the interface on which the Hello message is sent. The Generation ID is regenerated whenever PIM forwarding is started or restarted on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Generation ID是发送Hello消息的接口的随机32位值。只要在接口上启动或重新启动PIM转发，就会重新生成生成ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o OptionType 24: Address List
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 选项类型24：地址列表
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 24            |      Length = &lt;Variable&gt;      |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Secondary Address 1 (Encoded-Unicast format)          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                    ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Secondary Address N (Encoded-Unicast format)          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |          Type = 24            |      Length = &lt;Variable&gt;      |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Secondary Address 1 (Encoded-Unicast format)          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                    ...
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     |         Secondary Address N (Encoded-Unicast format)          |
     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
The contents of the Address List Hello option are described in Section 4.3.4. All addresses within a single Address List must belong to the same address family.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
第4.3.4节描述了地址列表Hello选项的内容。单个地址列表中的所有地址必须属于同一地址族。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OptionTypes 17 through 65000 are assigned by the IANA. OptionTypes 65001 through 65535 are reserved for Private Use, as defined in [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项类型17到65000由IANA分配。选项类型65001至65535保留供私人使用，如[9]中所定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unknown options MUST be ignored and MUST NOT prevent a neighbor relationship from being formed. The &#34;Holdtime&#34; option MUST be implemented; the &#34;DR Priority&#34; and &#34;Generation ID&#34; options SHOULD be implemented. The &#34;Address List&#34; option MUST be implemented for IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须忽略未知选项，并且不能阻止邻居关系的形成。必须实施“保持时间”选项；应实施“DR优先级”和“生成ID”选项。IPv6必须实现“地址列表”选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.3. Register Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.3. 寄存器消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Register message is sent by the DR or a PMBR to the RP when a multicast packet needs to be transmitted on the RP-tree. The IP source address is set to the address of the DR, the destination address to the RP&#39;s address. The IP TTL of the PIM packet is the system&#39;s normal unicast TTL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当需要在RP树上传输多播数据包时，DR或PMBR向RP发送一条注册消息。IP源地址设置为DR的地址，目标地址设置为RP的地址。PIM数据包的IP TTL是系统的正常单播TTL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |B|N|                       Reserved2                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .                     Multicast data packet                     .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |B|N|                       Reserved2                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   .                     Multicast data packet                     .
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Version, Type, Reserved, Checksum Described in Section 4.9. Note that in order to reduce encapsulation overhead, the checksum for Registers is done only on the first 8 bytes of the packet, including the PIM header and the next 4 bytes, excluding the data packet portion. For interoperability reasons, a message carrying a checksum calculated over the entire PIM Register message should also be accepted. When calculating the checksum, the IPv6 pseudoheader &#34;Upper-Layer Packet Length&#34; is set to 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.9节中描述的PIM版本、类型、保留、校验和。注意，为了减少封装开销，寄存器的校验和仅在包的前8个字节上进行，包括PIM报头和下4个字节，不包括数据包部分。出于互操作性的原因，还应接受包含在整个PIM寄存器消息上计算的校验和的消息。计算校验和时，IPv6伪报头“上层数据包长度”设置为8。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B The Border bit. If the router is a DR for a source that it is directly connected to, it sets the B bit to 0. If the router is a PMBR for a source in a directly connected cloud, it sets the B bit to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B边界位。如果路由器是直接连接到的源的DR，它会将B位设置为0。如果路由器是直连云中某个源的PMBR，它会将B位设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N The Null-Register bit. Set to 1 by a DR that is probing the RP before expiring its local Register-Suppression Timer. Set to 0 otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N为空寄存器位。在RP的本地寄存器抑制计时器过期之前，由正在探测RP的DR设置为1。否则设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved2 Transmitted as zero, ignored on receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved2传输为零，接收时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast data packet The original packet sent by the source. This packet must be of the same address family as the encapsulating PIM packet, e.g., an IPv6 data packet must be encapsulated in an IPv6 PIM packet. Note that the TTL of the original packet is decremented before encapsulation, just like any other packet that is forwarded. In addition, the RP decrements the TTL after decapsulating, before forwarding the packet down the shared tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播数据包源发送的原始数据包。此数据包必须与封装的PIM数据包具有相同的地址系列，例如，IPv6数据包必须封装在IPv6 PIM数据包中。请注意，原始数据包的TTL在封装之前递减，就像转发的任何其他数据包一样。此外，RP在解除封装之后，在沿着共享树转发数据包之前，减小TTL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
For (S,G) Null-Registers, the Multicast data packet portion contains a dummy IP header with S as the source address, G as the destination address. When generating an IPv4 Null-Register message, the fields in the dummy IPv4 header SHOULD be filled in according to the following table. Other IPv4 header fields may contain any value that is valid for that field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
对于（S，G）空寄存器，多播数据分组部分包含伪IP报头，其中S作为源地址，G作为目的地址。生成IPv4空寄存器消息时，应根据下表填写虚拟IPv4标头中的字段。其他IPv4标头字段可能包含对该字段有效的任何值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        Field                  Value
        ---------------------------------------
        IP Version             4
        Header Length          5
        Checksum               Header checksum
        Fragmentation offset   0
        More Fragments         0
        Total Length           20
        IP Protocol            103 (PIM)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        Field                  Value
        ---------------------------------------
        IP Version             4
        Header Length          5
        Checksum               Header checksum
        Fragmentation offset   0
        More Fragments         0
        Total Length           20
        IP Protocol            103 (PIM)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
On receipt of an (S,G) Null-Register, if the Header Checksum field is non-zero, the recipient SHOULD check the checksum and discard null registers that have a bad checksum. The recipient SHOULD NOT check the value of any individual fields; a correct IP header checksum is sufficient. If the Header Checksum field is zero, the recipient MUST NOT check the checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
在收到（S，G）空寄存器时，如果标头校验和字段非零，则收件人应检查校验和并丢弃具有错误校验和的空寄存器。收件人不应检查任何单个字段的值；正确的IP报头校验和就足够了。如果标头校验和字段为零，则收件人不得检查校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
With IPv6, an implementation generates a dummy IP header followed by a dummy PIM header with values according to the following table in addition to the source and group. Other IPv6 header fields may contain any value that is valid for that field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
对于IPv6，除了源和组之外，实现还会生成一个虚拟IP头，后面是一个虚拟PIM头，该头的值如下表所示。其他IPv6标头字段可能包含对该字段有效的任何值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        Header Field   Value
        --------------------------------------
        IP Version     6
        Next Header    103 (PIM)
        Length         4
        PIM Version    0
        PIM Type       0
        PIM Reserved   0
        PIM Checksum   PIM checksum including
                       IPv6 &#34;pseudo-header&#34;;
                       see Section 4.9
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        Header Field   Value
        --------------------------------------
        IP Version     6
        Next Header    103 (PIM)
        Length         4
        PIM Version    0
        PIM Type       0
        PIM Reserved   0
        PIM Checksum   PIM checksum including
                       IPv6 &#34;pseudo-header&#34;;
                       see Section 4.9
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
On receipt of an IPv6 (S,G) Null-Register, if the dummy PIM header is present, the recipient SHOULD check the checksum and discard Null-Registers that have a bad checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
在收到IPv6（S，G）空寄存器时，如果存在伪PIM头，则接收方应检查校验和并丢弃具有错误校验和的空寄存器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.4. Register-Stop Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.4. 寄存器停止消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Register-Stop is unicast from the RP to the sender of the Register message. The IP source address is the address to which the register was addressed. The IP destination address is the source address of the register message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
寄存器停止从RP单播到寄存器消息的发送方。IP源地址是寄存器的地址。IP目标地址是寄存器消息的源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Group Address (Encoded-Group format)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Source Address (Encoded-Unicast format)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Group Address (Encoded-Group format)              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Source Address (Encoded-Unicast format)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Version, Type, Reserved, Checksum Described in Section 4.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.9节中描述的PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group Address The group address from the multicast data packet in the Register. Format described in Section 4.9.1. Note that for Register-Stops the Mask Len field contains the full address length * 8 (e.g., 32 for IPv4 native encoding), if the message is sent for a single group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组地址寄存器中多播数据包的组地址。第4.9.1节所述格式。请注意，如果为单个组发送消息，则对于寄存器停止，掩码Len字段包含完整地址长度*8（例如，IPv4本机编码为32）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source Address The host address of the source from the multicast data packet in the register. The format for this address is given in the Encoded-Unicast address in Section 4.9.1. A special wild card value consisting of an address field of all zeros can be used to indicate any source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
源地址来自寄存器中多播数据包的源的主机地址。该地址的格式见第4.9.1节中的编码单播地址。由全零地址字段组成的特殊通配符值可用于指示任何源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.5. Join/Prune Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.5. 加入/删除消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Join/Prune message is sent by routers towards upstream sources and RPs. Joins are sent to build shared trees (RP trees) or source trees (SPT). Prunes are sent to prune source trees when members leave groups as well as sources that do not use the shared tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器向上游源和RPs发送加入/删减消息。连接被发送到构建共享树（RP树）或源树（SPT）。当成员离开组以及不使用共享树的源时，将发送修剪以修剪源树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Upstream Neighbor Address (Encoded-Unicast format)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Reserved     | Num groups    |          Holdtime             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address 1 (Encoded-Group format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           .                                   |
   |                           .                                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address m (Encoded-Group format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Upstream Neighbor Address (Encoded-Unicast format)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Reserved     | Num groups    |          Holdtime             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address 1 (Encoded-Group format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           .                                   |
   |                           .                                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address m (Encoded-Group format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Joined Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address 1 (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             .                                 |
   |                             .                                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Pruned Source Address n (Encoded-Source format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Version, Type, Reserved, Checksum Described in Section 4.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.9节中描述的PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicast Upstream Neighbor Address The address of the upstream neighbor that is the target of the message. The format for this address is given in the Encoded-Unicast address in Section 4.9.1. For IPv6 the source address used for multicast messages is the link-local address of the interface on which the message is being sent. For IPv4, the source address is the primary address associated with that interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单播上行邻居地址作为消息目标的上行邻居的地址。该地址的格式见第4.9.1节中的编码单播地址。对于IPv6，用于多播消息的源地址是发送消息的接口的链路本地地址。对于IPv4，源地址是与该接口关联的主地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Transmitted as zero, ignored on receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留传输为零，接收时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Holdtime The amount of time a receiver must keep the Join/Prune state alive, in seconds. If the Holdtime is set to &#39;0xffff&#39;, the receiver of this message should hold the state until canceled by the appropriate canceling Join/Prune message, or timed out according to local policy. This may be used with dial-on-demand links, to avoid keeping the link up with periodic Join/Prune messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Holdtime接收器必须使连接/删除状态保持活动状态的时间量，以秒为单位。如果保持时间设置为“0xffff”，则此消息的接收者应保持状态，直到被相应的取消加入/删除消息取消，或根据本地策略超时。这可以与按需拨号链接一起使用，以避免使用定期加入/删除消息保持链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Note that the HoldTime must be larger than the J/P_Override_Interval(I).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
请注意，保持时间必须大于J/P_超控_间隔（I）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of Groups The number of multicast group sets contained in the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组数消息中包含的多播组集数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast group address For format description, see Section 4.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格式描述见第4.9.1节的多播组地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of Joined Sources Number of joined source addresses listed for a given group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已联接源的数目为给定组列出的已联接源地址的数目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joined Source Address 1 .. n This list contains the sources for a given group that the sending router will forward multicast datagrams from if received on the interface on which the Join/Prune message is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已加入源地址1。。n该列表包含给定组的源，如果在发送加入/删减消息的接口上收到，发送路由器将转发来自该组的多播数据报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
See Encoded-Source-Address format in Section 4.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
参见第4.9.1节中的编码源地址格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of Pruned Sources Number of pruned source addresses listed for a group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已修剪源的数目为组列出的已修剪源地址的数目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pruned Source Address 1 .. n This list contains the sources for a given group that the sending router does not want to forward multicast datagrams from when received on the interface on which the Join/Prune message is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
删除的源地址1。。n此列表包含发送路由器在发送加入/删除消息的接口上接收时不希望转发多播数据报的给定组的源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within one PIM Join/Prune message, all the Multicast Group Addresses, Joined Source addresses, and Pruned Source addresses MUST be of the same address family. It is NOT PERMITTED to mix IPv4 and IPv6 addresses within the same message. In addition, the address family of the fields in the message SHOULD be the same as the IP source and destination addresses of the packet. This permits maximum implementation flexibility for dual-stack IPv4/IPv6 routers. If a router receives a message with mixed family addresses, it SHOULD only process the addresses that are of the same family as the unicast upstream neighbor address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在一条PIM加入/删减消息中，所有多播组地址、加入的源地址和删减的源地址必须属于同一地址族。不允许在同一消息中混合使用IPv4和IPv6地址。此外，消息中字段的地址系列应与数据包的IP源地址和目标地址相同。这允许双栈IPv4/IPv6路由器实现最大的灵活性。如果路由器接收到具有混合族地址的消息，它应该只处理与单播上行邻居地址属于同一族的地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.5.1. Group Set Source List Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.5.1. 组集源列表规则
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described above, Join/Prune messages are composed of one or more group sets. Each set contains two source lists, the Joined Sources and the Pruned Sources. This section describes the different types of group sets and source list entries that can exist in a Join/Prune message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述，加入/删减消息由一个或多个组集组成。每个集合包含两个源列表，即连接的源和修剪的源。本节介绍加入/删除消息中可能存在的不同类型的组集和源列表项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two valid group set types:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有两种有效的组集类型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Wildcard Group Set The wildcard group set is represented by the entire multicast range: the beginning of the multicast address range in the group address field and the prefix length of the multicast address range in the mask length field of the Multicast Group Address (i.e., &#39;224.0.0.0/4&#39; for IPv4 or &#39;ff00::/8&#39; for IPv6). Each Join/Prune message SHOULD contain at most one wildcard group set. Each wildcard group set may contain one or more (*,*,RP) source list entries in either the Joined or Pruned lists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通配符组集通配符组集由整个多播范围表示：组地址字段中多播地址范围的开头和多播组地址的掩码长度字段中多播地址范围的前缀长度（即，IPv4为“224.0.0.0/4”，IPv6为“ff00:：/8”）。每个加入/删除消息最多应包含一个通配符组集。每个通配符组集可以包含一个或多个（*、*、RP）源列表条目，这些条目位于合并列表或修剪列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
A (*,*,RP) source list entry may only exist in a wildcard group set. When added to a Joined source list, this type of source entry expresses the router&#39;s interest in receiving traffic for all groups mapping to the specified RP. When added to a Pruned source list a (*,*,RP) entry expresses the router&#39;s interest to stop receiving such traffic. Note that as indicated by the Join/Prune state machines, such a Join or Prune will NOT override Join/Prune state created using a Group-Specific Set (see below).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（*，*，RP）源列表项只能存在于通配符组集中。当添加到连接的源列表时，此类型的源条目表示路由器对接收映射到指定RP的所有组的通信量感兴趣。当添加到修剪的源列表时（*，*，RP）条目表示路由器对停止接收此类通信量感兴趣。请注意，如连接/修剪状态机所示，这样的连接或修剪不会覆盖使用组特定集创建的连接/修剪状态（请参见下文）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
(*,*,RP) source list entries have the Source-Address set to the address of the RP, the Source-Address Mask-Len set to the full length of the IP address, and both the WC and RPT bits of the Source-Address set to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
（*，*，RP）源列表项的源地址设置为RP的地址，源地址掩码Len设置为IP地址的全长，源地址的WC和RPT位都设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group-Specific Set A Group-Specific Set is represented by a valid IP multicast address in the group address field and the full length of the IP address in the mask length field of the Multicast Group Address. Each Join/Prune message SHOULD NOT contain more than one group-specific set for the same IP multicast address. Each group-specific set may contain (*,G), (S,G,rpt), and (S,G) source list entries in the Joined or Pruned lists.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组特定集组特定集由组地址字段中的有效IP多播地址和多播组地址的掩码长度字段中的IP地址全长表示。对于同一IP多播地址，每个加入/删除消息不应包含多个组特定集。每个特定于组的集合可以包含（*，G）、（S，G，rpt）和（S，G）合并或删减列表中的源列表项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(*,G) The (*,G) source list entry is used in Join/Prune messages sent towards the RP for the specified group. It expresses interest (or lack thereof) in receiving traffic sent to the group through the Rendezvous-Point shared tree. There may only be one such entry in both the Joined and Pruned lists of a group-specific set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（*，G）源列表条目用于向指定组的RP发送的加入/删除消息。它表示对通过集合点共享树接收发送给组的流量感兴趣（或不感兴趣）。在特定于组的集合的联接列表和修剪列表中，可能只有一个这样的条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(*,G) source list entries have the Source-Address set to the address of the RP for group G, the Source-Address Mask-Len set to the full length of the IP address, and both the WC and RPT bits of the Encoded-Source-Address set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
（*，G）源列表项的源地址设置为G组RP的地址，源地址掩码Len设置为IP地址的全长，以及编码源地址集的WC和RPT位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(S,G,rpt) The (S,G,rpt) source list entry is used in Join/Prune messages sent towards the RP for the specified group. It expresses interest (or lack thereof) in receiving traffic through the shared tree sent by the specified source to this group. For each source address, the entry may exist in only one of the Joined and Pruned source lists of a group-specific set, but not both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（S，G，rpt）（，G，rpt）源列表条目用于向指定组的RP发送的加入/删除消息。它表示有兴趣（或没有兴趣）通过指定源发送给该组的共享树接收流量。对于每个源地址，条目可能仅存在于特定于组的集合的一个联接和修剪源列表中，但不能同时存在于这两个列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(S,G,rpt) source list entries have the Source-Address set to the address of the source S, the Source-Address Mask-Len set to the full length of the IP address, and the WC bit cleared and the RPT bit set in the Encoded-Source-Address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
（S、G、rpt）源列表项的源地址设置为源S的地址，源地址掩码Len设置为IP地址的全长，WC位清除，rpt位设置在编码源地址中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
(S,G) The (S,G) source list entry is used in Join/Prune messages sent towards the specified source. It expresses interest (or lack thereof) in receiving traffic through the shortest path tree sent by the source to the specified group. For each source address, the entry may exist in only one of the Joined and Pruned source lists of a group-specific set, but not both.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（S，G）（S，G）源列表条目用于发送到指定源的加入/删减消息。它表示对通过源发送到指定组的最短路径树接收流量感兴趣（或不感兴趣）。对于每个源地址，条目可能仅存在于特定于组的集合的一个联接和修剪源列表中，但不能同时存在于这两个列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
(S,G) source list entries have the Source-Address set to the address of the source S, the Source-Address Mask-Len set to the full length of the IP address, and both the WC and RPT bits of the Encoded-Source-Address cleared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
（S，G）源列表项将源地址设置为源S的地址，将源地址掩码Len设置为IP地址的全长，并清除编码源地址的WC和RPT位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules described above are sufficient to prevent invalid combinations of source list entries in group-specific sets. There are, however, a number of combinations that have a valid interpretation but that are not generated by the protocol as described in this specification:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述规则足以防止特定于组的集合中的源列表项的无效组合。然而，有许多组合具有有效的解释，但不是由本规范中所述的协议生成的：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Combining a (*,G) Join and a (S,G,rpt) Join entry in the same message is redundant as the (*,G) entry covers the information provided by the (S,G,rpt) entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在同一消息中组合（*，G）连接和（S，G，rpt）连接条目是多余的，因为（*，G）条目包含（S，G，rpt）条目提供的信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The same applies for a (*,G) Prunes and (S,G,rpt) Prunes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 这同样适用于（*，G）修剪和（S，G，rpt）修剪。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The combination of a (*,G) Prune and a (S,G,rpt) Join is also not generated. (S,G,rpt) Joins are only sent when the router is receiving all traffic for a group on the shared tree and it wishes to indicate a change for the particular source. As a (*,G) prune indicates that the router no longer wishes to receive shared tree traffic, the (S,G,rpt) Join would be meaningless.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 也不会生成（*，G）修剪和（S，G，rpt）联接的组合。（S、G、rpt）连接仅在路由器接收到共享树上某个组的所有通信量并且希望指示特定源的更改时发送。由于（*，G）删减表示路由器不再希望接收共享树流量，（S，G，rpt）连接将毫无意义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As Join/Prune messages are targeted to a single PIM neighbor, including both a (S,G) Join and a (S,G,rpt) Prune in the same message is usually redundant. The (S,G) Join informs the neighbor that the sender wishes to receive the particular source on the shortest path tree. It is therefore unnecessary for the router to say that it no longer wishes to receive it on the shared tree. However, there is a valid interpretation for this combination of entries. A downstream router may have to instruct its upstream only to start forwarding a specific source once it has started receiving the source on the shortest-path tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 由于Join/Prune消息是针对单个PIM邻居的，因此在同一消息中包括（S，G）Join和（S，G，rpt）Prune通常是冗余的。（S，G）连接通知邻居发送方希望接收最短路径树上的特定源。因此，路由器没有必要说它不再希望在共享树上接收它。然而，对这两个条目的组合有一个有效的解释。下游路由器在开始接收最短路径树上的源后，可能必须指示其上游仅开始转发特定源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The combination of a (S,G) Prune and a (S,G,rpt) Join could possibly be used by a router to switch from receiving a particular source on the shortest-path tree back to receiving it on the shared tree (provided that the RPF neighbor for the shortest-path and shared trees is common). However, Sparse-Mode PIM does not provide a mechanism for explicitly switching back to the shared tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o （S，G）修剪和（S，G，rpt）连接的组合可能被路由器用来从最短路径树上接收特定源切换回共享树上接收特定源（前提是最短路径和共享树的RPF邻居是公共的）。但是，稀疏模式PIM不提供显式切换回共享树的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules are summarized in the tables below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下表总结了这些规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----------++------+-------+-----------+-----------+-------+-------+
   |          ||Join  | Prune | Join      | Prune     | Join  | Prune |
   |          ||(*,G) | (*,G) | (S,G,rpt) | (S,G,rpt) | (S,G) | (S,G) |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Join      ||-     | no    | ?         | yes       | yes   | yes   |
   |(*,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Prune     ||no    | -     | ?         | ?         | yes   | yes   |
   |(*,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Join      ||?     | ?     | -         | no        | yes   | ?     |
   |(S,G,rpt) ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Prune     ||yes   | ?     | no        | -         | yes   | ?     |
   |(S,G,rpt) ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Join      ||yes   | yes   | yes       | yes       | -     | no    |
   |(S,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Prune     ||yes   | yes   | ?         | ?         | no    | -     |
   |(S,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----------++------+-------+-----------+-----------+-------+-------+
   |          ||Join  | Prune | Join      | Prune     | Join  | Prune |
   |          ||(*,G) | (*,G) | (S,G,rpt) | (S,G,rpt) | (S,G) | (S,G) |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Join      ||-     | no    | ?         | yes       | yes   | yes   |
   |(*,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Prune     ||no    | -     | ?         | ?         | yes   | yes   |
   |(*,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Join      ||?     | ?     | -         | no        | yes   | ?     |
   |(S,G,rpt) ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Prune     ||yes   | ?     | no        | -         | yes   | ?     |
   |(S,G,rpt) ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Join      ||yes   | yes   | yes       | yes       | -     | no    |
   |(S,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
   |Prune     ||yes   | yes   | ?         | ?         | no    | -     |
   |(S,G)     ||      |       |           |           |       |       |
   +----------++------+-------+-----------+-----------+-------+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +---------------++--------------+----------------+------------+
   |               ||Join (*,*,RP) | Prune (*,*,RP) | all others |
   +---------------++--------------+----------------+------------+
   |Join (*,*,RP)  ||-             | no             | yes        |
   +---------------++--------------+----------------+------------+
   |Prune (*,*,RP) ||no            | -              | yes        |
   +---------------++--------------+----------------+------------+
   |all others     ||yes           | yes            | see above  |
   +---------------++--------------+----------------+------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +---------------++--------------+----------------+------------+
   |               ||Join (*,*,RP) | Prune (*,*,RP) | all others |
   +---------------++--------------+----------------+------------+
   |Join (*,*,RP)  ||-             | no             | yes        |
   +---------------++--------------+----------------+------------+
   |Prune (*,*,RP) ||no            | -              | yes        |
   +---------------++--------------+----------------+------------+
   |all others     ||yes           | yes            | see above  |
   +---------------++--------------+----------------+------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
yes Allowed and expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
是的，这是允许的，也是期望的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no Combination is not allowed by the protocol and MUST NOT be generated by a router. A router MAY accept these messages, but the result is undefined. An error message MAY be logged to the administrator in a rate-limited manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
协议不允许任何组合，且不得由路由器生成。路由器可以接受这些消息，但结果未定义。可能会以速率受限的方式向管理员记录错误消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
? Combination not expected by the protocol, but well-defined. A router MAY accept it but SHOULD NOT generate it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
? 协议未预期的组合，但定义明确。路由器可以接受它，但不应生成它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The order of source list entries in a group set source list is not important, except where limited by the packet format itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组集合源列表中源列表项的顺序并不重要，除非受到数据包格式本身的限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.5.2. Group Set Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.5.2. 组集分段
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When building a Join/Prune for a particular neighbor, a router should try to include in the message as much of the information it needs to convey to the neighbor as possible. This implies adding one group set for each multicast group that has information pending transmission and within each set including all relevant source list entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在为特定邻居构建连接/修剪时，路由器应尝试在消息中包含尽可能多的需要传递给邻居的信息。这意味着为每个具有挂起传输的信息的多播组添加一个组集，并且在每个组内包括所有相关的源列表条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On a router with a large amount of multicast state, the number of entries that must be included may result in packets that are larger than the maximum IP packet size. In most such cases, the information may be split into multiple messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在具有大量多播状态的路由器上，必须包括的条目数可能导致数据包大于最大IP数据包大小。在大多数此类情况下，信息可能被拆分为多条消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is an exception with group sets that contain a (*,G) Joined source list entry. The group set expresses the router&#39;s interest in receiving all traffic for the specified group on the shared tree, and it MUST include an (S,G,rpt) Pruned source list entry for every source that the router does not wish to receive. This list of (S,G,rpt) Pruned source-list entries MUST not be split in multiple messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包含（*，G）联接源列表项的组集存在异常。组集表示路由器对在共享树上接收指定组的所有通信量感兴趣，并且它必须为路由器不希望接收的每个源包含一个（s、G、rpt）删减的源列表条目。此（S、G、rpt）修剪源列表项列表不能拆分为多条消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If only N (S,G,rpt) Prune entries fit into a maximum-sized Join/Prune message, but the router has more than N (S,G,rpt) Prunes to add, then the router MUST choose to include the first N (numerically smallest in network byte order) IP addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果只有N个（S，G，rpt）删减条目适合最大大小的加入/删减消息，但路由器要添加的删减超过N个（S，G，rpt），那么路由器必须选择包含前N个（网络字节顺序中数字最小的）IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.6. Assert Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.9.6. 断言消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Assert message is used to resolve forwarder conflicts between routers on a link. It is sent when a router receives a multicast data packet on an interface on which the router would normally have forwarded that packet. Assert messages may also be sent in response to an Assert message from another router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断言消息用于解决链路上路由器之间的转发器冲突。当路由器在其通常转发多播数据包的接口上接收到多播数据包时，发送该数据包。断言消息也可以响应来自另一路由器的断言消息而发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              Group Address (Encoded-Group format)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Source Address (Encoded-Unicast format)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|                      Metric Preference                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Metric                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              Group Address (Encoded-Group format)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Source Address (Encoded-Unicast format)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|                      Metric Preference                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Metric                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Version, Type, Reserved, Checksum Described in Section 4.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第4.9节中描述的PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group Address The group address for which the router wishes to resolve the forwarding conflict. This is an Encoded-Group address, as specified in Section 4.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组地址路由器希望解决转发冲突的组地址。这是第4.9.1节规定的编码组地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source Address Source address for which the router wishes to resolve the forwarding conflict. The source address MAY be set to zero for (*,G) asserts (see below). The format for this address is given in Encoded-Unicast-Address in Section 4.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
源地址路由器希望解决转发冲突的源地址。（*，G）断言的源地址可以设置为零（见下文）。第4.9.1节中的编码单播地址给出了该地址的格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R RPT-bit is a 1-bit value. The RPT-bit is set to 1 for Assert(*,G) messages and 0 for Assert(S,G) messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RPT位是1位值。对于断言（*，G）消息，RPT位设置为1；对于断言（S，G）消息，RPT位设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric Preference Preference value assigned to the unicast routing protocol that provided the route to the multicast source or Rendezvous-Point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分配给单播路由协议的度量首选项值，该协议提供到多播源或集合点的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric The unicast routing table metric associated with the route used to reach the multicast source or Rendezvous-Point. The metric is in units applicable to the unicast routing protocol used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric与用于到达多播源或集合点的路由相关联的单播路由表指标。度量单位适用于所使用的单播路由协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assert messages can be sent to resolve a forwarding conflict for all traffic to a given group or for a specific source and group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可以发送断言消息来解决发送到给定组或特定源和组的所有流量的转发冲突。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assert(S,G) Source-specific asserts are sent by routers forwarding a specific source on the shortest-path tree (SPTbit is TRUE). (S,G) Asserts have the Group-Address field set to the group G and the Source-Address field set to the source S. The RPT-bit is set to 0, the Metric-Preference is set to MRIB.pref(S) and the Metric is set to MRIB.metric(S).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断言（S，G）源特定断言由路由器发送，路由器在最短路径树上转发特定源（SPTbit为TRUE）。（S，G）断言将组地址字段设置为组G，将源地址字段设置为源S。RPT位设置为0，度量首选项设置为MRIB.pref（S），度量设置为MRIB.Metric（S）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assert(*,G) Group-specific asserts are sent by routers forwarding data for the group and source(s) under contention on the shared tree. (*,G) asserts have the Group-Address field set to the group G. For data-triggered Asserts, the Source-Address field MAY be set to the IP source address of the data packet that triggered the Assert and is set to zero otherwise. The RPT-bit is set to 1, the Metric-Preference is set to MRIB.pref(RP(G)), and the Metric is set to MRIB.metric(RP(G)).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断言（*，G）特定于组的断言由路由器发送，转发共享树上争用的组和源的数据。（*，G）断言将组地址字段设置为组G。对于数据触发的断言，源地址字段可以设置为触发断言的数据包的IP源地址，否则设置为零。RPT位设置为1，度量首选项设置为MRIB.pref（RP（G）），度量设置为MRIB.Metric（RP（G））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.10. PIM Timers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.10. PIM定时器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM maintains the following timers, as discussed in Section 4.1. All timers are countdown timers; they are set to a value and count down to zero, at which point they typically trigger an action. Of course they can just as easily be implemented as count-up timers, where the absolute expiry time is stored and compared against a real-time clock, but the language in this specification assumes that they count downwards to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM维护以下计时器，如第4.1节所述。所有计时器都是倒计时计时器；它们被设置为一个值并倒计时到零，在这一点上它们通常触发一个动作。当然，它们可以像计数计时器一样轻松实现，其中存储绝对到期时间并与实时时钟进行比较，但本规范中的语言假设它们向下计数为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Global Timers
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全球计时器
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per interface (I):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个接口（I）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Hello Timer: HT(I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
你好定时器：HT（I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Per neighbor (N):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
每邻居（N）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Neighbor Liveness Timer: NLT(N,I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
邻居活跃度计时器：NLT（N，I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Per active RP (RP):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
每有效RP（RP）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,*,RP) Join Expiry Timer: ET(*,*,RP,I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,*,RP) Join Expiry Timer: ET(*,*,RP,I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,*,RP) Prune-Pending Timer: PPT(*,*,RP,I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,*,RP) Prune-Pending Timer: PPT(*,*,RP,I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Per Group (G):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
每组（G）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,G) Join Expiry Timer: ET(*,G,I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,G) Join Expiry Timer: ET(*,G,I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,G) Prune-Pending Timer: PPT(*,G,I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,G) Prune-Pending Timer: PPT(*,G,I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,G) Assert Timer: AT(*,G,I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             (*,G) Assert Timer: AT(*,G,I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Per Source (S):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
每个来源：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
(S,G) Join Expiry Timer: ET(S,G,I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
（S，G）加入到期计时器：ET（S，G，I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
(S,G) Prune-Pending Timer: PPT(S,G,I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
（S，G）修剪挂起计时器：PPT（S，G，I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
(S,G) Assert Timer: AT(S,G,I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
（S，G）断言计时器：AT（S，G，I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
(S,G,rpt) Prune Expiry Timer: ET(S,G,rpt,I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
（S，G，rpt）修剪到期计时器：ET（S，G，rpt，I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
(S,G,rpt) Prune-Pending Timer: PPT(S,G,rpt,I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-18">
（S，G，rpt）删除挂起计时器：PPT（S，G，rpt，I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per active RP (RP):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每有效RP（RP）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        (*,*,RP) Upstream Join Timer: JT(*,*,RP)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        (*,*,RP) Upstream Join Timer: JT(*,*,RP)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Per Group (G):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每组（G）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        (*,G) Upstream Join Timer: JT(*,G)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        (*,G) Upstream Join Timer: JT(*,G)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Per Source (S):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
每个来源：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
(S,G) Upstream Join Timer: JT(S,G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
（S，G）上游加入计时器：JT（S，G）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
(S,G) Keepalive Timer: KAT(S,G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
（S，G）保持计时器：KAT（S，G）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
(S,G,rpt) Upstream Override Timer: OT(S,G,rpt)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
（S，G，rpt）上游超驰定时器：OT（S，G，rpt）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the DRs or relevant Assert Winners only:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仅在DRs或相关部门：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
Per Source,Group pair (S,G):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
每个源、组对（S、G）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Register-Stop Timer: RST(S,G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
寄存器停止计时器：RST（S，G）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11. Timer Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.11. 计时器值
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When timers are started or restarted, they are set to default values. This section summarizes those default values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
启动或重新启动计时器时，将其设置为默认值。本节总结了这些默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that protocol events or configuration may change the default value of a timer on a specific interface. When timers are initialized in this document, the value specific to the interface in context must be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，协议事件或配置可能会更改特定接口上计时器的默认值。在本文档中初始化计时器时，必须使用上下文中特定于接口的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the timers listed below (Prune-Pending, Upstream Join, Upstream Override) can be set to values that depend on the settings of the Propagation_Delay and Override_Interval of the corresponding interface. The default values for these are given below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面列出的一些计时器（修剪挂起、上游连接、上游覆盖）可以设置为取决于相应接口的传播延迟和覆盖间隔设置的值。下面给出了这些的默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variable Name: Propagation_Delay(I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
变量名称：传播延迟（I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------+----------------------+
|  Value Name                   |  Value       |  Explanation         |
+-------------------------------+--------------+----------------------+
|  Propagation_delay_default    |  0.5 secs    |  Expected            |
|                               |              |  propagation delay   |
|                               |              |  over the local      |
|                               |              |  link.               |
+-------------------------------+--------------+----------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------+----------------------+
|  Value Name                   |  Value       |  Explanation         |
+-------------------------------+--------------+----------------------+
|  Propagation_delay_default    |  0.5 secs    |  Expected            |
|                               |              |  propagation delay   |
|                               |              |  over the local      |
|                               |              |  link.               |
+-------------------------------+--------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default value of the Propagation_delay_default is chosen to be relatively large to provide compatibility with older PIM implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择传播延迟默认值相对较大，以提供与旧PIM实现的兼容性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variable Name: Override_Interval(I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
变量名称：覆盖间隔（I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+--------------------------+-----------------+-------------------------+
|  Value Name              |    Value        |    Explanation          |
+--------------------------+-----------------+-------------------------+
|  t_override_default      |    2.5 secs     |    Default delay        |
|                          |                 |    interval over        |
|                          |                 |    which to randomize   |
|                          |                 |    when scheduling a    |
|                          |                 |    delayed Join         |
|                          |                 |    message.             |
+--------------------------+-----------------+-------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+--------------------------+-----------------+-------------------------+
|  Value Name              |    Value        |    Explanation          |
+--------------------------+-----------------+-------------------------+
|  t_override_default      |    2.5 secs     |    Default delay        |
|                          |                 |    interval over        |
|                          |                 |    which to randomize   |
|                          |                 |    when scheduling a    |
|                          |                 |    delayed Join         |
|                          |                 |    message.             |
+--------------------------+-----------------+-------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timer Name: Hello Timer (HT(I))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定时器名称：你好定时器（HT（I））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------+--------+---------------------------------------+
|Value Name           | Value  | Explanation                           |
+---------------------+--------+---------------------------------------+
|Hello_Period         | 30 secs| Periodic interval for Hello messages. |
+---------------------+--------+---------------------------------------+
|Triggered_Hello_Delay| 5 secs | Randomized interval for initial Hello |
|                     |        | message on bootup or triggered Hello  |
|                     |        | message to a rebooting neighbor.      |
+---------------------+--------+---------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------+--------+---------------------------------------+
|Value Name           | Value  | Explanation                           |
+---------------------+--------+---------------------------------------+
|Hello_Period         | 30 secs| Periodic interval for Hello messages. |
+---------------------+--------+---------------------------------------+
|Triggered_Hello_Delay| 5 secs | Randomized interval for initial Hello |
|                     |        | message on bootup or triggered Hello  |
|                     |        | message to a rebooting neighbor.      |
+---------------------+--------+---------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At system power-up, the timer is initialized to rand(0, Triggered_Hello_Delay) to prevent synchronization. When a new or rebooting neighbor is detected, a responding Hello is sent within rand(0, Triggered_Hello_Delay).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
系统通电时，定时器初始化为rand（0，触发\u Hello\u延迟），以防止同步。当检测到新邻居或正在重新启动的邻居时，将在rand（0，触发的\u Hello\u延迟）内发送响应的Hello。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timer Name: Neighbor Liveness Timer (NLT(N,I))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定时器名称：邻居活跃度定时器（NLT（N，I））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+--------------------------+----------------------+--------------------+
| Value Name               |  Value               |  Explanation       |
+--------------------------+----------------------+--------------------+
| Default_Hello_Holdtime   |  3.5 * Hello_Period  |  Default holdtime  |
|                          |                      |  to keep neighbor  |
|                          |                      |  state alive       |
+--------------------------+----------------------+--------------------+
| Hello_Holdtime           |  from message        |  Holdtime from     |
|                          |                      |  Hello Message     |
|                          |                      |  Holdtime option.  |
+--------------------------+----------------------+--------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+--------------------------+----------------------+--------------------+
| Value Name               |  Value               |  Explanation       |
+--------------------------+----------------------+--------------------+
| Default_Hello_Holdtime   |  3.5 * Hello_Period  |  Default holdtime  |
|                          |                      |  to keep neighbor  |
|                          |                      |  state alive       |
+--------------------------+----------------------+--------------------+
| Hello_Holdtime           |  from message        |  Holdtime from     |
|                          |                      |  Hello Message     |
|                          |                      |  Holdtime option.  |
+--------------------------+----------------------+--------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Holdtime in a Hello Message should be set to (3.5 * Hello_Period), giving a default value of 105 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello消息中的保持时间应设置为（3.5*Hello_时段），默认值为105秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Expiry Timer (ET(*,*,RP,I), ET(*,G,I), ET(S,G,I),
   ET(S,G,rpt,I))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Expiry Timer (ET(*,*,RP,I), ET(*,G,I), ET(S,G,I),
   ET(S,G,rpt,I))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------+----------------+------------------------------------+
| Value Name     |  Value         |  Explanation                       |
+----------------+----------------+------------------------------------+
| J/P_HoldTime   |  from message  |  Holdtime from Join/Prune Message  |
+----------------+----------------+------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------+----------------+------------------------------------+
| Value Name     |  Value         |  Explanation                       |
+----------------+----------------+------------------------------------+
| J/P_HoldTime   |  from message  |  Holdtime from Join/Prune Message  |
+----------------+----------------+------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See details of JT(*,G) for the Holdtime that is included in Join/Prune Messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关Join/Prune消息中包含的保持时间，请参阅JT（*，G）的详细信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Prune-Pending Timer (PPT(*,*,RP,I), PPT(*,G,I),
   PPT(S,G,I), PPT(S,G,rpt,I))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Prune-Pending Timer (PPT(*,*,RP,I), PPT(*,G,I),
   PPT(S,G,I), PPT(S,G,rpt,I))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+--------------------------+---------------------+---------------------+
|Value Name                | Value               | Explanation         |
+--------------------------+---------------------+---------------------+
|J/P_Override_Interval(I)  | Default:            | Short period after  |
|                          | Effective_          | a join or prune to  |
|                          | Propagation_        | allow other         |
|                          | Delay(I) +          | routers on the LAN  |
|                          | EffectiveOverride_  | to override the     |
|                          | Interval(I)         | join or prune       |
+--------------------------+---------------------+---------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+--------------------------+---------------------+---------------------+
|Value Name                | Value               | Explanation         |
+--------------------------+---------------------+---------------------+
|J/P_Override_Interval(I)  | Default:            | Short period after  |
|                          | Effective_          | a join or prune to  |
|                          | Propagation_        | allow other         |
|                          | Delay(I) +          | routers on the LAN  |
|                          | EffectiveOverride_  | to override the     |
|                          | Interval(I)         | join or prune       |
+--------------------------+---------------------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that both the Effective_Propagation_Delay(I) and the Effective_Override_Interval(I) are interface-specific values that may change when Hello messages are received (see Section 4.3.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，有效_传播_延迟（I）和有效_覆盖_间隔（I）都是特定于接口的值，在收到Hello消息时可能会发生变化（参见第4.3.3节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Assert Timer (AT(*,G,I), AT(S,G,I))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Assert Timer (AT(*,G,I), AT(S,G,I))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------+---------------------+--------------------+
| Value Name                | Value               | Explanation        |
+---------------------------+---------------------+--------------------+
| Assert_Override_Interval  | Default: 3 secs     | Short interval     |
|                           |                     | before an assert   |
|                           |                     | times out where    |
|                           |                     | the assert winner  |
|                           |                     | resends an Assert  |
|                           |                     | message            |
+---------------------------+---------------------+--------------------+
| Assert_Time               | Default: 180 secs   | Period after last  |
|                           |                     | assert before      |
|                           |                     | assert state is    |
|                           |                     | timed out          |
+---------------------------+---------------------+--------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------+---------------------+--------------------+
| Value Name                | Value               | Explanation        |
+---------------------------+---------------------+--------------------+
| Assert_Override_Interval  | Default: 3 secs     | Short interval     |
|                           |                     | before an assert   |
|                           |                     | times out where    |
|                           |                     | the assert winner  |
|                           |                     | resends an Assert  |
|                           |                     | message            |
+---------------------------+---------------------+--------------------+
| Assert_Time               | Default: 180 secs   | Period after last  |
|                           |                     | assert before      |
|                           |                     | assert state is    |
|                           |                     | timed out          |
+---------------------------+---------------------+--------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that for historical reasons, the Assert message lacks a Holdtime field. Thus, changing the Assert Time from the default value is not recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，由于历史原因，Assert消息缺少Holdtime字段。因此，不建议将断言时间更改为默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Upstream Join Timer (JT(*,*,RP), JT(*,G), JT(S,G))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Timer Names: Upstream Join Timer (JT(*,*,RP), JT(*,G), JT(S,G))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------+--------------------+-----------------------------------+
|Value Name   | Value              | Explanation                       |
+-------------+--------------------+-----------------------------------+
|t_periodic   | Default: 60 secs   | Period between Join/Prune Messages|
+-------------+--------------------+-----------------------------------+
|t_suppressed | rand(1.1 *         | Suppression period when someone   |
|             | t_periodic, 1.4 *  | else sends a J/P message so we    |
|             | t_periodic) when   | don&#39;t need to do so.              |
|             | Suppression_       |                                   |
|             | Enabled(I) is      |                                   |
|             | true, 0 otherwise  |                                   |
+-------------+--------------------+-----------------------------------+
|t_override   | rand(0, Effective_ | Randomized delay to prevent       |
|             | Override_          | response implosion when sending a |
|             | Interval(I))       | join message to override someone  |
|             |                    | else&#39;s Prune message.             |
+-------------+--------------------+-----------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------+--------------------+-----------------------------------+
|Value Name   | Value              | Explanation                       |
+-------------+--------------------+-----------------------------------+
|t_periodic   | Default: 60 secs   | Period between Join/Prune Messages|
+-------------+--------------------+-----------------------------------+
|t_suppressed | rand(1.1 *         | Suppression period when someone   |
|             | t_periodic, 1.4 *  | else sends a J/P message so we    |
|             | t_periodic) when   | don&#39;t need to do so.              |
|             | Suppression_       |                                   |
|             | Enabled(I) is      |                                   |
|             | true, 0 otherwise  |                                   |
+-------------+--------------------+-----------------------------------+
|t_override   | rand(0, Effective_ | Randomized delay to prevent       |
|             | Override_          | response implosion when sending a |
|             | Interval(I))       | join message to override someone  |
|             |                    | else&#39;s Prune message.             |
+-------------+--------------------+-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t_periodic may be set to take into account such things as the configured bandwidth and expected average number of multicast route entries for the attached network or link (e.g., the period would be longer for lower-speed links, or for routers in the center of the network that expect to have a larger number of entries). If the Join/Prune-Period is modified during operation, these changes should be made relatively infrequently, and the router should continue to refresh at its previous Join/Prune-Period for at least Join/Prune-Holdtime, in order to allow the upstream router to adapt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t_periodic可以被设置为考虑诸如所连接的网络或链路的配置带宽和预期的多播路由条目的平均数量之类的事情（例如，对于速度较低的链路，或者对于网络中心的路由器，期望具有更多条目的周期将更长）。如果在操作过程中修改了加入/删减周期，则应相对不频繁地进行这些更改，并且路由器应在其上一个加入/删减周期至少在加入/删减保持时间内继续刷新，以便允许上游路由器适应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The holdtime specified in a Join/Prune message should be set to (3.5 * t_periodic).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
联接/删除消息中指定的保持时间应设置为（3.5*t_periodic）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t_override depends on the Effective_Override_Interval of the upstream interface, which may change when Hello messages are received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t_override取决于上游接口的有效_override_间隔，当接收到Hello消息时，该间隔可能会改变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t_suppressed depends on the Suppression State of the upstream interface (Section 4.3.3) and becomes zero when suppression is disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受抑制的t_取决于上游接口的抑制状态（第4.3.3节），当抑制被禁用时变为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timer Name: Upstream Override Timer (OT(S,G,rpt))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定时器名称：上游覆盖定时器（OT（S、G、rpt））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------+--------------------------+---------------------------+
| Value Name    | Value                    |  Explanation              |
+---------------+--------------------------+---------------------------+
| t_override    | see Upstream Join Timer  |  see Upstream Join Timer  |
+---------------+--------------------------+---------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------+--------------------------+---------------------------+
| Value Name    | Value                    |  Explanation              |
+---------------+--------------------------+---------------------------+
| t_override    | see Upstream Join Timer  |  see Upstream Join Timer  |
+---------------+--------------------------+---------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The upstream Override Timer is only ever set to t_override; this value is defined in the section on Upstream Join Timers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游超控定时器仅设置为t_超控；该值在上游连接计时器部分中定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timer Name: Keepalive Timer (KAT(S,G))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
计时器名称：Keepalive计时器（KAT（S，G））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-----------------------+-----------------------+----------------------+
| Value Name            |  Value                |  Explanation         |
+-----------------------+-----------------------+----------------------+
| Keepalive_Period      |  Default: 210 secs    |  Period after last   |
|                       |                       |  (S,G) data packet   |
|                       |                       |  during which (S,G)  |
|                       |                       |  Join state will be  |
|                       |                       |  maintained even in  |
|                       |                       |  the absence of      |
|                       |                       |  (S,G) Join          |
|                       |                       |  messages.           |
+-----------------------+-----------------------+----------------------+
| RP_Keepalive_Period   |  ( 3 * Register_      |  As                  |
|                       |  Suppression_Time )   |  Keepalive_Period,   |
|                       |  + Register_          |  but at the RP when  |
|                       |  Probe_Time           |  a Register-Stop is  |
|                       |                       |  sent.               |
+-----------------------+-----------------------+----------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-----------------------+-----------------------+----------------------+
| Value Name            |  Value                |  Explanation         |
+-----------------------+-----------------------+----------------------+
| Keepalive_Period      |  Default: 210 secs    |  Period after last   |
|                       |                       |  (S,G) data packet   |
|                       |                       |  during which (S,G)  |
|                       |                       |  Join state will be  |
|                       |                       |  maintained even in  |
|                       |                       |  the absence of      |
|                       |                       |  (S,G) Join          |
|                       |                       |  messages.           |
+-----------------------+-----------------------+----------------------+
| RP_Keepalive_Period   |  ( 3 * Register_      |  As                  |
|                       |  Suppression_Time )   |  Keepalive_Period,   |
|                       |  + Register_          |  but at the RP when  |
|                       |  Probe_Time           |  a Register-Stop is  |
|                       |                       |  sent.               |
+-----------------------+-----------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The normal keepalive period for the KAT(S,G) defaults to 210 seconds. However, at the RP, the keepalive period must be at least the Register_Suppression_Time, or the RP may time out the (S,G) state before the next Null-Register arrives. Thus, the KAT(S,G) is set to max(Keepalive_Period, RP_Keepalive_Period) when a Register-Stop is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
KAT（S，G）的正常保持期默认为210秒。然而，在RP处，保持期必须至少为寄存器抑制时间，否则RP可能在下一个空寄存器到达之前超时（S，G）状态。因此，当发送寄存器停止时，KAT（S，G）被设置为max（Keepalive_Period，RP_Keepalive_Period）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Timer Name: Register-Stop Timer (RST(S,G))
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定时器名称：寄存器停止定时器（RST（S，G））
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------+--------------------+---------------------+
|Value Name                 | Value              | Explanation         |
+---------------------------+--------------------+---------------------+
|Register_Suppression_Time  | Default: 60 secs   | Period during       |
|                           |                    | which a DR stops    |
|                           |                    | sending Register-   |
|                           |                    | encapsulated data   |
|                           |                    | to the RP after     |
|                           |                    | receiving a         |
|                           |                    | Register-Stop       |
|                           |                    | message.            |
+---------------------------+--------------------+---------------------+
|Register_Probe_Time        | Default: 5 secs    | Time before RST     |
|                           |                    | expires when a DR   |
|                           |                    | may send a Null-    |
|                           |                    | Register to the RP  |
|                           |                    | to cause it to      |
|                           |                    | resend a Register-  |
|                           |                    | Stop message.       |
+---------------------------+--------------------+---------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+---------------------------+--------------------+---------------------+
|Value Name                 | Value              | Explanation         |
+---------------------------+--------------------+---------------------+
|Register_Suppression_Time  | Default: 60 secs   | Period during       |
|                           |                    | which a DR stops    |
|                           |                    | sending Register-   |
|                           |                    | encapsulated data   |
|                           |                    | to the RP after     |
|                           |                    | receiving a         |
|                           |                    | Register-Stop       |
|                           |                    | message.            |
+---------------------------+--------------------+---------------------+
|Register_Probe_Time        | Default: 5 secs    | Time before RST     |
|                           |                    | expires when a DR   |
|                           |                    | may send a Null-    |
|                           |                    | Register to the RP  |
|                           |                    | to cause it to      |
|                           |                    | resend a Register-  |
|                           |                    | Stop message.       |
+---------------------------+--------------------+---------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Register_Suppression_Time or the Register_Probe_Time are configured to values other than the defaults, it MUST be ensured that the value of the Register_Probe_Time is less than half the value of the Register_Suppression_Time to prevent a possible negative value in the setting of the Register-Stop Timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果寄存器\u抑制\u时间或寄存器\u探测\u时间配置为默认值以外的值，则必须确保寄存器\u探测\u时间的值小于寄存器\u抑制\u时间值的一半，以防止寄存器停止计时器设置中可能出现负值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. IANA考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. PIM Address Family
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. PIM地址族
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM Address Family field was chosen to be 8 bits as a tradeoff between packet format and use of the IANA assigned numbers. Because when the PIM packet format was designed only 15 values were assigned for Address Families, and large numbers of new Address Family values were not envisioned, 8 bits seemed large enough. However, the IANA assigns Address Families in a 16-bit field. Therefore, the PIM Address Family is allocated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM地址族字段被选择为8位，作为数据包格式和IANA分配号码使用之间的折衷。因为在设计PIM数据包格式时，只为地址族分配了15个值，并且没有预见到大量新的地址族值，所以8位似乎足够大。但是，IANA在16位字段中分配地址族。因此，PIM地址系列分配如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Values 0 through 127 are designated to have the same meaning as IANA-assigned Address Family Numbers [7].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
值0到127指定为与IANA分配的地址系列号具有相同的含义[7]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Values 128 through 250 are designated to be assigned for PIM by the IANA based upon IESG Approval, as defined in [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
IANA根据IESG批准为PIM指定128到250的值，如[9]中所定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Values 251 through 255 are designated for Private Use, as defined
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
根据定义，值251到255指定为私人使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
in [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
在[9]中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. PIM Hello Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. PIM Hello选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Values 17 through 65000 are to be assigned by the IANA. Since the space is large, they may be assigned as First Come First Served as defined in [9]. Such assignments are valid for one year and may be renewed. Permanent assignments require a specification (see &#34;Specification Required&#34; in [9].)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA将分配值17至65000。由于空间较大，可按照[9]中的定义将其分配为先到先得。此类任务的有效期为一年，可以续签。永久性转让需要规范（见[9]中的“规范要求”）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes various possible security concerns related to the PIM-SM protocol, including a description of how to use IPsec to secure the protocol. The reader is referred to [15] and [16] for further discussion of PIM-SM and multicast security. The IPsec authentication header [8] MAY be used to provide data integrity protection and groupwise data origin authentication of PIM protocol messages. Authentication of PIM messages can protect against unwanted behaviors caused by unauthorized or altered PIM messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍与PIM-SM协议相关的各种可能的安全问题，包括如何使用IPsec保护协议的说明。读者可参考[15]和[16]进一步讨论PIM-SM和多播安全性。IPsec认证头[8]可用于提供PIM协议消息的数据完整性保护和分组数据源认证。PIM消息的身份验证可以防止未经授权或更改的PIM消息导致的不必要行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Attacks Based on Forged Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 基于伪造消息的攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The extent of possible damage depends on the type of counterfeit messages accepted. We next consider the impact of possible forgeries, including forged link-local (Join/Prune, Hello, and Assert) and forged unicast (Register and Register-Stop) messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能损坏的程度取决于所接受的假冒信息的类型。接下来我们考虑可能伪造的影响，包括伪造链路本地（连接/修剪、hello和断言）和伪造单播（登记和登记停止）消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. Forged Link-Local Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. 伪造链接本地消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Join/Prune, Hello, and Assert messages are all sent to the link-local ALL_PIM_ROUTERS multicast addresses and thus are not forwarded by a compliant router. A forged message of this type can only reach a LAN if it was sent by a local host or if it was allowed onto the LAN by a compromised or non-compliant router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Join/Prune、Hello和Assert消息都发送到本地链路all_PIM_路由器多播地址，因此不会由兼容路由器转发。这种类型的伪造消息只有在由本地主机发送或被受损或不兼容的路由器允许进入LAN时才能到达LAN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A forged Join/Prune message can cause multicast traffic to be delivered to links where there are no legitimate requesters, potentially wasting bandwidth on that link. A forged leave message on a multi-access LAN is generally not a significant attack in PIM, because any legitimately joined router on the LAN would override the leave with a join before the upstream router stops forwarding data to the LAN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 伪造的加入/删减消息可能会导致多播流量传递到没有合法请求者的链路，从而可能会浪费该链路上的带宽。在多址LAN上伪造的离开消息在PIM中通常不是重大攻击，因为LAN上任何合法连接的路由器都会在上游路由器停止向LAN转发数据之前用连接覆盖离开。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. By forging a Hello message, an unauthorized router can cause itself to be elected as the designated router on a LAN. The designated router on a LAN is (in the absence of asserts) responsible for forwarding traffic to that LAN on behalf of any
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 通过伪造Hello消息，未经授权的路由器可以使自己被选为LAN上的指定路由器。LAN上的指定路由器（在没有断言的情况下）负责代表任何用户将流量转发到该LAN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
local members. The designated router is also responsible for register-encapsulating to the RP any packets that are originated by hosts on the LAN. Thus, the ability of local hosts to send and receive multicast traffic may be compromised by a forged Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
当地成员。指定的路由器还负责向RP注册封装LAN上主机发起的任何数据包。因此，本地主机发送和接收多播流量的能力可能会受到伪造Hello消息的影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. By forging an Assert message on a multi-access LAN, an attacker could cause the legitimate designated forwarder to stop forwarding traffic to the LAN. Such a forgery would prevent any hosts downstream of that LAN from receiving traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 通过在多访问LAN上伪造断言消息，攻击者可以使合法的指定转发器停止向LAN转发流量。这种伪造将阻止该LAN下游的任何主机接收流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. Forged Unicast Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. 伪造单播消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Register messages and Register-Stop messages are forwarded by intermediate routers to their destination using normal IP forwarding. Without data origin authentication, an attacker who is located anywhere in the network may be able to forge a Register or Register-Stop message. We consider the effect of a forgery of each of these messages next.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
中间路由器使用普通IP转发将注册消息和注册停止消息转发到其目的地。如果没有数据源身份验证，位于网络中任何位置的攻击者都可能伪造注册或注册停止消息。接下来，我们考虑伪造这些消息的效果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. By forging a Register message, an attacker can cause the RP to inject forged traffic onto the shared multicast tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 通过伪造注册消息，攻击者可以使RP将伪造流量注入共享多播树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. By forging a Register-stop message, an attacker can prevent a legitimate DR from Registering packets to the RP. This can prevent local hosts on that LAN from sending multicast packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 通过伪造注册停止消息，攻击者可以阻止合法DR将数据包注册到RP。这可以阻止该LAN上的本地主机发送多播数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above two PIM messages are not changed by intermediate routers and need only be examined by the intended receiver. Thus, these messages can be authenticated end-to-end, using AH. Attacks on Register and Register-Stop messages do not apply to a PIM-SSM-only implementation, as these messages are not required for PIM-SSM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述两条PIM消息不会被中间路由器更改，只需由预期的接收器检查。因此，可以使用AH对这些消息进行端到端的身份验证。对寄存器和寄存器停止消息的攻击不适用于仅PIM SSM实现，因为PIM-SSM不需要这些消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Non-Cryptographic Authentication Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 非加密身份验证机制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM router SHOULD provide an option to limit the set of neighbors from which it will accept Join/Prune, Assert, and Hello messages. Either static configuration of IP addresses or an IPsec security association may be used. Furthermore, a PIM router SHOULD NOT accept protocol messages from a router from which it has not yet received a valid Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM路由器应该提供一个选项来限制它将从中接受加入/删减、断言和Hello消息的邻居集。可以使用IP地址的静态配置或IPsec安全关联。此外，PIM路由器不应接受来自尚未收到有效Hello消息的路由器的协议消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Designated Router MUST NOT register-encapsulate a packet and send it to the RP unless the source address of the packet is a legal address for the subnet on which the packet was received. Similarly, a Designated Router SHOULD NOT accept a Register-Stop packet whose IP source address is not a valid RP address for the local domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定路由器不得注册封装数据包并将其发送至RP，除非数据包的源地址是接收数据包的子网的合法地址。类似地，指定路由器不应接受IP源地址不是本地域有效RP地址的注册停止数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation SHOULD provide a mechanism to allow an RP to restrict the range of source addresses from which it accepts Register-encapsulated packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现应该提供一种机制，允许RP限制其接受寄存器封装数据包的源地址范围。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All options that restrict the range of addresses from which packets are accepted MUST default to allowing all packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有限制接受数据包的地址范围的选项必须默认为允许所有数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Authentication Using IPsec
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 使用IPsec的身份验证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPsec [8] transport mode using the Authentication Header (AH) is the recommended method to prevent the above attacks against PIM. The specific AH authentication algorithm and parameters, including the choice of authentication algorithm and the choice of key, are configured by the network administrator. When IPsec authentication is used, a PIM router should reject (drop without processing) any unauthorized PIM protocol messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用身份验证头（AH）的IPsec[8]传输模式是防止上述针对PIM的攻击的推荐方法。具体的AH认证算法和参数，包括认证算法的选择和密钥的选择，由网络管理员配置。当使用IPsec身份验证时，PIM路由器应拒绝（丢弃而不处理）任何未经授权的PIM协议消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To use IPsec, the administrator of a PIM network configures each PIM router with one or more security associations (SAs) and associated Security Parameter Indexes (SPIs) that are used by senders to authenticate PIM protocol messages and are used by receivers to authenticate received PIM protocol messages. This document does not describe protocols for establishing SAs. It assumes that manual configuration of SAs is performed, but it does not preclude the use of a negotiation protocol such as the Internet Key Exchange [14] to establish SAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要使用IPsec，PIM网络的管理员使用一个或多个安全关联（SA）和关联的安全参数索引（SPI）配置每个PIM路由器，发送方使用这些安全关联和关联的安全参数索引对PIM协议消息进行身份验证，接收方使用这些安全关联和关联的安全参数索引对接收到的PIM协议消息进行身份验证。本文档不描述建立SAs的协议。它假定执行SAs的手动配置，但并不排除使用协商协议（如Internet密钥交换[14]）来建立SAs。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec [8] provides protection against replayed unicast and multicast messages. The anti-replay option for IPsec SHOULD be enabled on all SAs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec[8]针对重播的单播和多播消息提供保护。应在所有SAs上启用IPsec的防重播选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections describe the SAs required to protect PIM protocol messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下各节描述了保护PIM协议消息所需的SAs。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Protecting Link-Local Multicast Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. 保护链路本地多播消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The network administrator defines an SA and SPI that are to be used to authenticate all link-local PIM protocol messages (Hello, Join/Prune, and Assert) on each link in a PIM domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
网络管理员定义SA和SPI，用于验证PIM域中每个链路上的所有链路本地PIM协议消息（Hello、Join/Prune和Assert）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec [8] allows (but does not require) different Security Policy Databases (SPD) for each router interface. If available, it may be desirable to configure the Security Policy Database at a PIM router such that all incoming and outgoing Join/Prune, Assert, and Hello packets use a different SA for each incoming or outgoing interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec[8]允许（但不要求）每个路由器接口使用不同的安全策略数据库（SPD）。如果可用，可能需要在PIM路由器上配置安全策略数据库，以便所有传入和传出的Join/Prune、Assert和Hello包对每个传入或传出接口使用不同的SA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. Protecting Unicast Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. 保护单播消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec can also be used to provide data origin authentication and data integrity protection for the Register and Register-Stop unicast messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec还可用于为寄存器和寄存器停止单播消息提供数据源身份验证和数据完整性保护。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. Register Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. 注册消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Security Policy Database at every PIM router is configured to select an SA to use when sending PIM Register packets to each rendezvous point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个PIM路由器上的安全策略数据库配置为在向每个集合点发送PIM注册数据包时选择要使用的SA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the most general mode of operation, the Security Policy Database at each DR is configured to select a unique SA and SPI for traffic sent to each RP. This allows each DR to have a different authentication algorithm and key to talk to the RP. However, this creates a daunting key management and distribution problem for the network administrator. Therefore, it may be preferable in PIM domains where all Designated Routers are under a single administrative control that the same authentication algorithm parameters (including the key) be used for all Registered packets in a domain, regardless of who are the RP and the DR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在最通用的操作模式下，每个DR的安全策略数据库配置为为发送到每个RP的流量选择唯一的SA和SPI。这允许每个DR具有不同的身份验证算法和密钥与RP进行通信。但是，这会给网络管理员带来令人生畏的密钥管理和分发问题。因此，在所有指定路由器处于单一管理控制下的PIM域中，无论RP和DR是谁，对于域中的所有注册分组使用相同的认证算法参数（包括密钥）可能是优选的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this &#34;single shared key&#34; mode of operation, the network administrator must choose an SPI for each DR that will be used to send it PIM protocol packets. The Security Policy Database at every DR is configured to select an SA (including the authentication algorithm, authentication parameters, and this SPI) when sending Register messages to this RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在这种“单一共享密钥”操作模式下，网络管理员必须为每个DR选择一个SPI，用于向其发送PIM协议数据包。每个DR的安全策略数据库配置为在向该RP发送注册消息时选择SA（包括身份验证算法、身份验证参数和该SPI）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By using a single authentication algorithm and associated parameters, the key distribution problem is simplified. Note, however, that this method has the property that, in order to change the authentication method or authentication key used, all routers in the domain must be updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过使用单一认证算法和相关参数，简化了密钥分配问题。但是，请注意，此方法的属性是，为了更改所使用的身份验证方法或身份验证密钥，必须更新域中的所有路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.2. Register-Stop Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.2. 注册停止消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, the Security Policy Database at each Rendezvous Point should be configured to choose an SA to use when sending Register-Stop messages. Because Register-Stop messages are unicast to the destination DR, a different SA and a potentially unique SPI are required for each DR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同样，应将每个集合点的安全策略数据库配置为在发送Register Stop消息时选择要使用的SA。由于寄存器停止消息是单播到目标DR的，因此每个DR都需要不同的SA和可能唯一的SPI。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to simplify the management problem, it may be acceptable to use the same authentication algorithm and authentication parameters, regardless of the sending RP and regardless of the destination DR. Although a unique SA is needed for each DR, the same authentication
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了简化管理问题，可以接受使用相同的认证算法和认证参数，而不考虑发送RP和目的地DR。尽管每个DR需要唯一的SA，但相同的认证
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
algorithm and authentication algorithm parameters (secret key) can be shared by all DRs and by all RPs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
算法和身份验证算法参数（密钥）可由所有DRs和所有RPs共享。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Denial-of-Service Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 拒绝服务攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of possible denial-of-service attacks against PIM that can be caused by generating false PIM protocol messages or even by generating data false traffic. Authenticating PIM protocol traffic prevents some, but not all, of these attacks. Three of the possible attacks include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
针对PIM的许多可能的拒绝服务攻击可能是由生成虚假PIM协议消息或甚至生成虚假数据流量引起的。对PIM协议流量进行身份验证可以防止部分（但不是全部）此类攻击。三种可能的攻击包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Sending packets to many different group addresses quickly can be a denial-of-service attack in and of itself. This will cause many register-encapsulated packets, loading the DR, the RP, and the routers between the DR and the RP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 将数据包快速发送到许多不同的组地址本身就是一种拒绝服务攻击。这将导致许多注册封装的数据包，加载DR、RP以及DR和RP之间的路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Forging Join messages can cause a multicast tree to get set up. A large number of forged joins can consume router resources and result in denial of service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 伪造加入消息会导致建立多播树。大量伪造连接会消耗路由器资源并导致拒绝服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Forging a (*,*,RP) join presents a possibility for a denial-of-service attack by causing all traffic in the domain to flow to the PMBR issuing the join. (*,*,RP) behavior is included here primarily for backwards compatibility with prior revisions of the spec. However, the implementation of (*,*,RP) and PMBR is optional. When using (*,*,RP), the security concerns should be carefully considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 伪造（*，*，RP）连接会导致域中的所有流量流向发出连接的PMBR，从而导致拒绝服务攻击的可能性。（*，*，RP）行为主要是为了向后兼容先前版本的规范。但是（*，*，RP）和PMBR的实现是可选的。使用（*、*、RP）时，应仔细考虑安全问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM was designed over many years by a large group of people, including ideas, comments, and corrections from Deborah Estrin, Dino Farinacci, Ahmed Helmy, David Thaler, Steve Deering, Van Jacobson, C. Liu, Puneet Sharma, Liming Wei, Tom Pusateri, Tony Ballardie, Scott Brim, Jon Crowcroft, Paul Francis, Joel Halpern, Horst Hodel, Polly Huang, Stephen Ostrowski, Lixia Zhang, Girish Chandranmenon, Brian Haberman, Hal Sandick, Mike Mroz, Garry Kump, Pavlin Radoslavov, Mike Davison, James Huang, Christopher Thomas Brown, and James Lingard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM由一大群人多年来设计，包括黛博拉·埃斯特林、迪诺·法里纳奇、艾哈迈德·赫尔米、大卫·泰勒、史蒂夫·迪林、范·雅各布森、C·刘、普奈特·夏尔马、魏黎明、汤姆·普萨特里、托尼·巴拉迪、斯科特·布里姆、乔恩·克劳克罗夫特、保罗·弗朗西斯、乔尔·哈珀、霍斯特·霍德尔、波利·黄、，Stephen Ostrowski、Lixia Zhang、Girish Chandranmenon、Brian Haberman、Hal Sandick、Mike Mroz、Garry Kump、Pavlin Radoslavov、Mike Davison、James Huang、Christopher Thomas Brown和James Lingard。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks are due to the American Licorice Company, for its obscure but possibly essential role in the creation of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
感谢美国甘草公司在本文件的编制过程中所起的不起眼但可能至关重要的作用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A. Thyagarajan, &#34;Internet Group Management Protocol, Version 3&#34;, RFC 3376, October 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Cain，B.，Deering，S.，Kouvelas，I.，Fenner，B.，和A.Thyagarajan，“互联网组管理协议，第3版”，RFC 3376，2002年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Deering, S., &#34;Host extensions for IP multicasting&#34;, STD 5, RFC 1112, August 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Deering，S.，“IP多播的主机扩展”，STD 5，RFC 1112，1989年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Deering, S., Fenner, W., and B. Haberman, &#34;Multicast Listener Discovery (MLD) for IPv6&#34;, RFC 2710, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Deering，S.，Fenner，W.和B.Haberman，“IPv6的多播侦听器发现（MLD）”，RFC 2710，1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Deering，S.和R.Hinden，“互联网协议，第6版（IPv6）规范”，RFC 2460，1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Holbrook, H. and B. Cain, &#34;Source-Specific Multicast for IP&#34;, RFC 4507, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Holbrook，H.和B.Cain，“IP的源特定多播”，RFC 4507，2006年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] IANA, &#34;Address Family Numbers&#34;, &lt;http://www.iana.org/assignments/address-family-numbers&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] IANA，“地址家庭号码”&lt;http://www.iana.org/assignments/address-family-numbers&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Kent, S. and K. Seo, &#34;Security Architecture for the Internet Protocol&#34;, RFC 4301, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Kent，S.和K.Seo，“互联网协议的安全架构”，RFC 43012005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 2434, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Narten，T.和H.Alvestrand，“在RFCs中编写IANA注意事项部分的指南”，BCP 26，RFC 2434，1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Bates, T., Rekhter, Y., Chandra, R., and D. Katz, &#34;Multiprotocol Extensions for BGP-4&#34;, RFC 2858, June 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Bates，T.，Rekhter，Y.，Chandra，R.，和D.Katz，“BGP-4的多协议扩展”，RFC 28582000年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Bhaskar, N., Gall, A., Lingard, J., and S. Venaas, &#34;Bootstrap Router (BSR) Mechanism for PIM Sparse Mode&#34;, Work in Progress, May 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Bhaskar，N.，Gall，A.，Lingard，J.，和S.Venaas，“PIM稀疏模式的引导路由器（BSR）机制”，正在进行的工作，2006年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Black, D., &#34;Differentiated Services and Tunnels&#34;, RFC 2983, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Black，D.，“差异化服务和隧道”，RFC 2983，2000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, &#34;Bi-directional Protocol Independent Multicast&#34;, Work in Progress, October 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Handley，M.，Kouvelas，I.，Speakman，T.，和L.Vicisano，“双向协议独立多播”，正在进行的工作，2005年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] Kaufman, C., &#34;Internet Key Exchange (IKEv2) Protocol&#34;, RFC 4306, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] Kaufman，C.，“因特网密钥交换（IKEv2）协议”，RFC 4306，2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Savola, P., Lehtonen, R., and D. Meyer, &#34;Protocol Independent Multicast - Sparse Mode (PIM-SM) Multicast Routing Security Issues and Enhancements&#34;, RFC 4609, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Savola，P.，Lehtonen，R.，和D.Meyer，“协议独立多播-稀疏模式（PIM-SM）多播路由安全问题和增强”，RFC 4609，2006年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Savola, P. and J. Lingard, &#34;Last-hop Threats to Protocol Independent Multicast (PIM)&#34;, Work in Progress, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Savola，P.和J.Lingard，“协议独立多播（PIM）的最后一跳威胁”，正在进行的工作，2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Savola, P. and B. Haberman, &#34;Embedding the Rendezvous Point (RP) Address in an IPv6 Multicast Address&#34;, RFC 3956, November 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Savola，P.和B.Haberman，“将集合点（RP）地址嵌入IPv6多播地址”，RFC 3956，2004年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Thaler, D., &#34;Interoperability Rules for Multicast Routing Protocols&#34;, RFC 2715, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Thaler，D.，“多播路由协议的互操作性规则”，RFC 2715，1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A. PIM Multicast Border Router Behavior
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录A.PIM多播边界路由器行为
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some cases, PIM-SM domains will interconnect with non-PIM multicast domains. In these cases, the border routers of the PIM domain speak PIM-SM on some interfaces and speak other multicast routing protocols on other interfaces. Such routers are termed PIM Multicast Border Routers (PMBRs). In general, RFC 2715 [18] provides rules for interoperability between different multicast routing protocols. In this appendix, we specify how PMBRs differ from regular PIM-SM routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在某些情况下，PIM-SM域将与非PIM多播域互连。在这些情况下，PIM域的边界路由器在某些接口上讲PIM-SM，在其他接口上讲其他多播路由协议。这种路由器被称为PIM多播边界路由器（PMBR）。通常，RFC 2715[18]为不同多播路由协议之间的互操作性提供了规则。在本附录中，我们详细说明了PMBR与常规PIM-SM路由器的区别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the point of view of PIM-SM, a PMBR has two tasks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从PIM-SM的角度来看，PMBR有两个任务：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To ensure that traffic from sources outside the PIM-SM domain reaches receivers inside the domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 确保来自PIM-SM域外的源的流量到达域内的接收器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To ensure that traffic from sources inside the PIM-SM domain reaches receivers outside the domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 确保来自PIM-SM域内的源的流量到达域外的接收器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We note that multiple PIM-SM domains are sometimes connected together using protocols such as Multicast Source Discovery Protocol (MSDP), which provides information about active external sources, but does not follow RFC 2715. In such cases, the domains are not connected via PMBRs because Join(S,G) messages traverse the border between domains. A PMBR is required when no PIM messages can traverse the border.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们注意到，多个PIM-SM域有时使用多播源发现协议（MSDP）等协议连接在一起，该协议提供有关活动外部源的信息，但不遵循RFC 2715。在这种情况下，域不通过PMBR连接，因为Join（S，G）消息穿过域之间的边界。当不需要PMBR消息时，可以遍历PMBR消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. Sources External to the PIM-SM Domain
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. PIM-SM域外部的源
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PMBR needs to ensure that traffic from multicast sources external to the PIM-SM domain reaches receivers inside the domain. The PMBR will follow the rules in RFC 2715, such that traffic from external sources reaches the PMBR itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PMBR需要确保来自PIM-SM域外部的多播源的流量到达域内的接收器。PMBR将遵循RFC 2715中的规则，以便来自外部源的流量到达PMBR本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
According to RFC 2715, the PIM-SM component of the PMBR will receive an (S,G) Creation event when data from an (S,G) data packet from an external source first reaches the PMBR. If RPF_interface(S) is an interface in the PIM-SM domain, the packet cannot be originated into the PIM domain at this router, and the PIM-SM component of the PMBR will not process the packet. Otherwise, the PMBR will then act exactly as if it were the DR for this source (see Section 4.4.1), with the following modifications:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据RFC 2715，当来自外部源的（S，G）数据分组的数据首先到达PMBR时，PMBR的PIM-SM组件将接收（S，G）创建事件。如果RPF_接口是PIM-SM域中的接口，则该数据包不能在该路由器处起源于PIM域，PMBR的PIM-SM组件将不会处理该数据包。否则，PMBR将完全像该来源的DR一样工作（见第4.4.1节），并进行以下修改：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Border-bit is set in all PIM Register messages sent for these sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在为这些源发送的所有PIM寄存器消息中设置边界位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DirectlyConnected(S) is treated as being TRUE for these sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于这些源，DirectlyConnected被视为TRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The PIM-SM forwarding rule &#34;iif == RPF_interface(S)&#34; is relaxed to be TRUE if iif is any interface that is not part of the PIM-SM component of the PMBR (see Section 4.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果iif是任何不属于PMBR PIM-SM组件的接口，则PIM-SM转发规则“iif==RPF_接口”放宽为真（见第4.2节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. Sources Internal to the PIM-SM Domain
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. PIM-SM域内部的源
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PMBR needs to ensure that traffic from sources inside the PIM-SM domain reaches receivers outside the domain. Using terminology from RFC 2715, there are two possible scenarios for this:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PMBR需要确保来自PIM-SM域内的源的流量到达域外的接收器。使用RFC 2715中的术语，有两种可能的情况：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Another component of the PMBR is a wildcard receiver. In this case, the PIM-SM component of the PMBR must ensure that traffic from all internal sources reaches the PMBR until it is informed otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PMBR的另一个组件是通配符接收器。在这种情况下，PMBR的PIM-SM组件必须确保来自所有内部源的流量到达PMBR，直到另行通知。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Note that certain profiles of PIM-SM (e.g., PIM-SSM, PIM-SM with Embedded RP) cannot interoperate with a neighboring wildcard receiver domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请注意，PIM-SM的某些配置文件（例如，PIM-SSM、带嵌入式RP的PIM-SM）无法与相邻的通配符接收器域互操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No other component of the PMBR is a wildcard receiver. In this case the PMBR will receive explicit information as to which groups or (source,group) pairs the external domains wish to receive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PMBR的任何其他组件都不是通配符接收器。在这种情况下，PMBR将收到外部域希望接收哪些组或（源、组）对的明确信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the former case, the PMBR will need to send a Join(*,*,RP) to all the active RPs in the PIM-SM domain. It may also send a Join(*,*,RP) to all the candidate RPs in the PIM-SM domain. This will cause all traffic in the domain to reach the PMBR. The PMBR may then act as if it were a DR with directly connected receivers and trigger the transition to a shortest path tree (see Section 4.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在前一种情况下，PMBR需要向PIM-SM域中的所有活动RP发送联接（*，*，RP）。它还可以向PIM-SM域中的所有候选RP发送加入（*，*，RP）。这将导致域中的所有流量到达PMBR。然后，PMBR可以像直接连接接收器的DR一样工作，并触发到最短路径树的转换（见第4.2.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the latter case, the PMBR will not need to send Join(*,*,RP) messages. However, the PMBR will still need to act as a DR with directly connected receivers on behalf of the external receivers in terms of being able to switch to the shortest-path tree for internally-reached sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在后一种情况下，PMBR不需要发送Join（*，*，RP）消息。然而，就能够切换到内部到达的源的最短路径树而言，PMBR仍需要作为直接连接的接收器的DR，代表外部接收器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
According to RFC 2715, the PIM-SM component of the PMBR may receive a number of alerts generated by events in the external routing components. To implement the above behavior, one reasonable way to map these alerts into PIM-SM state is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据RFC 2715，PMBR的PIM-SM组件可以接收由外部路由组件中的事件生成的多个警报。为了实现上述行为，将这些警报映射到PIM-SM状态的一种合理方法如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a PIM-SM component receives an (S,G) Prune alert, it sets local_receiver_include(S,G,I) to FALSE for the discard interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当PIM-SM组件收到（S，G）删减警报时，它会将discard接口的local_receiver_include（S，G，I）设置为FALSE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a PIM-SM component receives a (*,G) Prune alert, it sets local_receiver_include(*,G,I) to FALSE for the discard interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当PIM-SM组件收到（*，G）删减警报时，它会将discard接口的local_receiver_include（*，G，I）设置为FALSE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a PIM-SM component receives an (S,G) Join alert, it sets local_receiver_include(S,G,I) to TRUE for the discard interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当PIM-SM组件接收到（S，G）加入警报时，它会将discard接口的local_receiver_include（S，G，I）设置为TRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a PIM-SM component receives a (*,G) Join alert, it sets local_receiver_include(*,G,I) to TRUE for the discard interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当PIM-SM组件收到（*，G）连接警报时，它会将discard接口的local_receiver_include（*，G，I）设置为TRUE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a PIM-SM component receives a (*,*) Join alert, it sets DownstreamJPState(*,*,RP,I) to Join state on the discard interface for all RPs in the PIM-SM domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当PIM-SM组件收到（*，*）连接警报时，它会在PIM-SM域中所有RP的丢弃接口上将DownstreamJPState（*，*，RP，I）设置为连接状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a PIM-SM component receives a (*,*) Prune alert, it sets DownstreamJPState(*,*,RP,I) to NoInfo state on the discard interface for all RPs in the PIM-SM domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当PIM-SM组件收到（*，*）删减警报时，它会在PIM-SM域中所有RP的丢弃接口上将DownstreamJPState（*，*，RP，I）设置为NoInfo状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We refer above to the discard interface because the macros and state machines are interface specific, but we need to have PIM state that is not associated with any actual PIM-SM interface. Implementers are free to implement this in any reasonable manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们在上面提到discard接口，因为宏和状态机是特定于接口的，但我们需要具有与任何实际PIM-SM接口不关联的PIM状态。实现者可以以任何合理的方式自由地实现这一点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that these state changes will then cause additional PIM-SM state machine transitions in the normal way.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，这些状态更改将以正常方式导致额外的PIM-SM状态机转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These rules are, however, not sufficient to allow pruning off the (*,*,RP) tree. Some additional rules provide guidance as to one way this may be done:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
但是，这些规则不足以允许修剪（*，*，RP）树。一些附加规则提供了一种方法的指南：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the PMBR has joined on the (*,*,RP) tree, then it should set DownstreamJPState(*,G,I) to JOIN on the discard interface for all active groups.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果PMBR已在（*，*，RP）树上加入，则应将DownstreamJPState（*，G，I）设置为在所有活动组的放弃界面上加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the router receives a (S,G) prune alert, it will need to set DownstreamJPState(S,G,rpt,I) to PRUNE on the discard interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果路由器收到（S，G）删减警报，它将需要在discard接口上设置DownstreamJPState（S，G，rpt，I）进行删减。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the router receives a (*,G) prune alert, it will need to set DownstreamJPState(S,G,rpt,I) to PRUNE on the discard interface for all active sources sending to G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果路由器收到（*，G）删减警报，它将需要在丢弃接口上为发送到G的所有活动源设置DownstreamJPState（S，G，rpt，I）以删减。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rationale for this is that there is no way in PIM-SM to prune traffic off the (*,*,RP) tree, except by Joining the (*,G) tree and then pruning each source individually.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其基本原理是，在PIM-SM中，除了加入（*，G）树，然后分别修剪每个源之外，没有办法从（*，*，RP）树上修剪流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix B. Index
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录B.索引
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   Address_List. . . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Assert(*,G) . . . . . . . . . . . . . . . . . . . . . . . . . .27,128
   Assert(S,G) . . . . . . . . . . . . . . . . . . . . . . . . . .27,128
   AssertCancel(*,G) . . . . . . . . . . . . . . . . . . . . . . . 97,99
   AssertCancel(S,G) . . . . . . . . . . . . . . . . . . . . . .80,90,99
   AssertTimer(*,G,I). . . . . . . . . . . . . . . . . . . .16,24,91,132
   AssertTimer(S,G,I). . . . . . . . . . . . . . . . . . . .18,24,84,132
   AssertTrackingDesired(*,G,I). . . . . . . . . . . . . . . . .93,94,96
   AssertTrackingDesired(S,G,I). . . . . . . . . . . . . . . 85,86,87,89
   AssertWinner(*,G,I) . . . . . . . . . . . . . . . .16,22,24,93,97,100
   AssertWinner(S,G,I) . . . . . . . . . . . . . .18,22,24,86,90,100,100
   AssertWinnerMetric(*,G,I) . . . . . . . . . . . . . . . . . 16,97,101
   AssertWinnerMetric(S,G,I) . . . . . . . . . . . . . . . . . 18,90,101
   assert_metric . . . . . . . . . . . . . . . . . . . . . . . . . .  98
   Assert_Override_Interval. . . . . . . . . . . . . . . . . . 90,97,132
   Assert_Time . . . . . . . . . . . . . . . . . . . . . . . . 90,97,132
   AT(*,G,I) . . . . . . . . . . . . . . . . . . . . . .16,24,91,129,132
   AT(S,G,I) . . . . . . . . . . . . . . . . . . . . . .18,24,84,129,132
   CheckSwitchToSpt(S,G) . . . . . . . . . . . . . . . . . . . . . 27,28
   CouldAssert(*,G,I). . . . . . . . . . . . . . . . . . .92,93,94,95,98
   CouldAssert(S,G,I). . . . . . . . . . . . . . . . . 84,86,87,88,89,98
   CouldRegister(S,G). . . . . . . . . . . . . . . . . . . . . . . 39,41
   Default_Hello_Holdtime. . . . . . . . . . . . . . . . . . . . . .  33
   DirectlyConnected(S). . . . . . . . . . . . . . . . . 27,27,29,41,143
   DownstreamJPState(*,*,RP,I) . . . . . . . . . . . . . . . . . .23,145
   DownstreamJPState(*,G,I). . . . . . . . . . . . . . . . . . . . .  23
   DownstreamJPState(S,G,I). . . . . . . . . . . . . . . . . . . . 23,40
   DownstreamJPState(S,G,rpt,I). . . . . . . . . . . . . . . . . . .  23
   DR(I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33
   dr_is_better(a,b,I) . . . . . . . . . . . . . . . . . . . . . . 33,33
   DR_Priority . . . . . . . . . . . . . . . . . . . . . . . . .31,32,33
   Effective_Override_Interval(I). . . . . . . . . . . . . . .36,114,132
   Effective_Propagation_Delay(I). . . . . . . . . . . . . . . . .35,132
   ET(*,*,RP,I). . . . . . . . . . . . . . . . . . . . . . 15,46,128,131
   ET(*,G,I) . . . . . . . . . . . . . . . . . . . . . . . 16,50,128,131
   ET(S,G,I) . . . . . . . . . . . . . . . . . . . . . . . 18,53,129,131
   ET(S,G,rpt,I) . . . . . . . . . . . . . . . . . . . .20,57,59,129,131
   GenID . . . . . . . . . . . . . . . . . 15,17,19,31,64,68,70,73,85,93
   Hash_Function . . . . . . . . . . . . . . . . . . . . . . . . .12,105
   Hello_Holdtime. . . . . . . . . . . . . . . . . . . . . . . . .33,131
   Hello_Period. . . . . . . . . . . . . . . . . . . . . . . . . .31,130
   HT(I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .31,130
   IGMP. . . . . . . . . . . . . . . . . . . . . . . . 6,8,17,23,101,105
   immediate_olist(*,*,RP) . . . . . . . . . . . . . . . . . . . . 22,64
   immediate_olist(*,G). . . . . . . . . . . . . . . . . . . . . . 22,68
   immediate_olist(S,G). . . . . . . . . . . . . . . . . . . . .22,40,73
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   Address_List. . . . . . . . . . . . . . . . . . . . . . . . . . .  31
   Assert(*,G) . . . . . . . . . . . . . . . . . . . . . . . . . .27,128
   Assert(S,G) . . . . . . . . . . . . . . . . . . . . . . . . . .27,128
   AssertCancel(*,G) . . . . . . . . . . . . . . . . . . . . . . . 97,99
   AssertCancel(S,G) . . . . . . . . . . . . . . . . . . . . . .80,90,99
   AssertTimer(*,G,I). . . . . . . . . . . . . . . . . . . .16,24,91,132
   AssertTimer(S,G,I). . . . . . . . . . . . . . . . . . . .18,24,84,132
   AssertTrackingDesired(*,G,I). . . . . . . . . . . . . . . . .93,94,96
   AssertTrackingDesired(S,G,I). . . . . . . . . . . . . . . 85,86,87,89
   AssertWinner(*,G,I) . . . . . . . . . . . . . . . .16,22,24,93,97,100
   AssertWinner(S,G,I) . . . . . . . . . . . . . .18,22,24,86,90,100,100
   AssertWinnerMetric(*,G,I) . . . . . . . . . . . . . . . . . 16,97,101
   AssertWinnerMetric(S,G,I) . . . . . . . . . . . . . . . . . 18,90,101
   assert_metric . . . . . . . . . . . . . . . . . . . . . . . . . .  98
   Assert_Override_Interval. . . . . . . . . . . . . . . . . . 90,97,132
   Assert_Time . . . . . . . . . . . . . . . . . . . . . . . . 90,97,132
   AT(*,G,I) . . . . . . . . . . . . . . . . . . . . . .16,24,91,129,132
   AT(S,G,I) . . . . . . . . . . . . . . . . . . . . . .18,24,84,129,132
   CheckSwitchToSpt(S,G) . . . . . . . . . . . . . . . . . . . . . 27,28
   CouldAssert(*,G,I). . . . . . . . . . . . . . . . . . .92,93,94,95,98
   CouldAssert(S,G,I). . . . . . . . . . . . . . . . . 84,86,87,88,89,98
   CouldRegister(S,G). . . . . . . . . . . . . . . . . . . . . . . 39,41
   Default_Hello_Holdtime. . . . . . . . . . . . . . . . . . . . . .  33
   DirectlyConnected(S). . . . . . . . . . . . . . . . . 27,27,29,41,143
   DownstreamJPState(*,*,RP,I) . . . . . . . . . . . . . . . . . .23,145
   DownstreamJPState(*,G,I). . . . . . . . . . . . . . . . . . . . .  23
   DownstreamJPState(S,G,I). . . . . . . . . . . . . . . . . . . . 23,40
   DownstreamJPState(S,G,rpt,I). . . . . . . . . . . . . . . . . . .  23
   DR(I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33
   dr_is_better(a,b,I) . . . . . . . . . . . . . . . . . . . . . . 33,33
   DR_Priority . . . . . . . . . . . . . . . . . . . . . . . . .31,32,33
   Effective_Override_Interval(I). . . . . . . . . . . . . . .36,114,132
   Effective_Propagation_Delay(I). . . . . . . . . . . . . . . . .35,132
   ET(*,*,RP,I). . . . . . . . . . . . . . . . . . . . . . 15,46,128,131
   ET(*,G,I) . . . . . . . . . . . . . . . . . . . . . . . 16,50,128,131
   ET(S,G,I) . . . . . . . . . . . . . . . . . . . . . . . 18,53,129,131
   ET(S,G,rpt,I) . . . . . . . . . . . . . . . . . . . .20,57,59,129,131
   GenID . . . . . . . . . . . . . . . . . 15,17,19,31,64,68,70,73,85,93
   Hash_Function . . . . . . . . . . . . . . . . . . . . . . . . .12,105
   Hello_Holdtime. . . . . . . . . . . . . . . . . . . . . . . . .33,131
   Hello_Period. . . . . . . . . . . . . . . . . . . . . . . . . .31,130
   HT(I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .31,130
   IGMP. . . . . . . . . . . . . . . . . . . . . . . . 6,8,17,23,101,105
   immediate_olist(*,*,RP) . . . . . . . . . . . . . . . . . . . . 22,64
   immediate_olist(*,G). . . . . . . . . . . . . . . . . . . . . . 22,68
   immediate_olist(S,G). . . . . . . . . . . . . . . . . . . . .22,40,73
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   infinite_assert_metric(). . . . . . . . . . . . . . . . . . . . .  99
   inherited_olist(S,G). . . . . . . . . . . . . . 22,27,40,43,73,86,108
   inherited_olist(S,G,rpt). . . . . . . . . . . . . . 22,27,29,76,79,81
   I_Am_Assert_Loser(*,G,I). . . . . . . . . . . . . . . . . . . . .  24
   I_Am_Assert_Loser(S,G,I). . . . . . . . . . . . . . . . . . . . .  24
   I_am_DR(I). . . . . . . . . . . . . . . . . . . . . . .22,33,41,86,93
   I_am_RP(G). . . . . . . . . . . . . . . . . . . . . . . . . . . 43,44
   J/P_Holdtime. . . . . . . . . . . . .47,51,55,59,65,69,74,121,131,133
   J/P_Override_Interval(I). . . . . . . . . . . . . 48,51,55,59,121,132
   JoinDesired(*,*,RP) . . . . . . . . . . . . . . . . . . . . . . 64,79
   JoinDesired(*,G). . . . . . . . . . . . . . . . . . . .17,68,79,86,97
   JoinDesired(S,G). . . . . . . . . . . . . . . . . . 19,29,73,86,88,90
   joins(*,*,RP(G)). . . . . . . . . . . . . . . . . . . . . . . . .  22
   joins(*,*,RP) . . . . . . . . . . . . . . . . . . . . . . 22,23,86,93
   joins(*,G). . . . . . . . . . . . . . . . . . . . . . . . 22,23,86,93
   joins(S,G). . . . . . . . . . . . . . . . . . . . . . . . . .22,23,86
   JT(*,*,RP). . . . . . . . . . . . . . . . . . . . . . . 15,62,129,133
   JT(*,G) . . . . . . . . . . . . . . . . . . . . . . . . 16,67,129,133
   JT(S,G) . . . . . . . . . . . . . . . . . . . . . . . . 18,71,129,133
   KAT(S,G). . . . . . . . . . . . . . .18,26,27,28,41,43,73,108,129,134
   KeepaliveTimer(S,G) . . . . . . . 18,26,27,27,28,41,43,73,108,129,134
   Keepalive_Period. . . . . . . . . . . . . . . . . . . . . . . .27,134
   lan_delay_enabled(I). . . . . . . . . . . . . . . . . . . . . . 35,36
   LAN_Prune_Delay . . . . . . . . . . . . . . . . . . . . . . . . .  31
   local_receiver_exclude(S,G,I) . . . . . . . . . . . . . . . . . .  23
   local_receiver_include(*,G,I) . . . . . . . . . . . . . . . 23,93,144
   local_receiver_include(S,G,I) . . . . . . . . . . . . . . . . . 23,86
   local_receiver_include(S,G,I).. . . . . . . . . . . . . . . . . . 144
   lost_assert(*,G). . . . . . . . . . . . . . . . . . . . . . .22,24,86
   lost_assert(*,G,I). . . . . . . . . . . . . . . . . . . . . 22,24,100
   lost_assert(S,G). . . . . . . . . . . . . . . . . . . . . . . . 22,24
   lost_assert(S,G,I). . . . . . . . . . . . . . . . . . . . . 22,24,100
   lost_assert(S,G,rpt). . . . . . . . . . . . . . . . . . . . . . .  24
   lost_assert(S,G,rpt,I). . . . . . . . . . . . . . . . . . . . .24,100
   MBGP. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6,7
   MFIB. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6,13
   MLD . . . . . . . . . . . . . . . . . . . . . . . . 6,8,17,23,101,105
   MRIB. . . . . . . . . . . . . .6,7,11,15,19,25,62,66,66,75,98,103,128
   MRIB.next_hop(host) . . . . . . . . . . . . . . . . . . . 24,25,62,64
   my_assert_metric(*,G,I) . . . . . . . . . . . . . . . . . . . . .  94
   my_assert_metric(S,G,I) . . . . . . . . . . . . . . . . . 85,89,92,98
   NBR(Interface,IP_address) . . . . . . . . . . . . . . .25,37,62,64,66
   NLT(N,I). . . . . . . . . . . . . . . . . . . . . . . . 14,33,128,131
   OT(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . . 20,77,129,134
   Override_Interval(I). . . . . . . . . . . . . 14,31,34,36,114,130,132
   packet_arrives_on_rp_tunnel(pkt). . . . . . . . . . . . . . . . .  43
   pim_exclude(S,G). . . . . . . . . . . . . . . . . . . . . 22,22,28,86
   pim_include(*,G). . . . . . . . . . . . . . . . . . 17,22,22,28,86,93
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   infinite_assert_metric(). . . . . . . . . . . . . . . . . . . . .  99
   inherited_olist(S,G). . . . . . . . . . . . . . 22,27,40,43,73,86,108
   inherited_olist(S,G,rpt). . . . . . . . . . . . . . 22,27,29,76,79,81
   I_Am_Assert_Loser(*,G,I). . . . . . . . . . . . . . . . . . . . .  24
   I_Am_Assert_Loser(S,G,I). . . . . . . . . . . . . . . . . . . . .  24
   I_am_DR(I). . . . . . . . . . . . . . . . . . . . . . .22,33,41,86,93
   I_am_RP(G). . . . . . . . . . . . . . . . . . . . . . . . . . . 43,44
   J/P_Holdtime. . . . . . . . . . . . .47,51,55,59,65,69,74,121,131,133
   J/P_Override_Interval(I). . . . . . . . . . . . . 48,51,55,59,121,132
   JoinDesired(*,*,RP) . . . . . . . . . . . . . . . . . . . . . . 64,79
   JoinDesired(*,G). . . . . . . . . . . . . . . . . . . .17,68,79,86,97
   JoinDesired(S,G). . . . . . . . . . . . . . . . . . 19,29,73,86,88,90
   joins(*,*,RP(G)). . . . . . . . . . . . . . . . . . . . . . . . .  22
   joins(*,*,RP) . . . . . . . . . . . . . . . . . . . . . . 22,23,86,93
   joins(*,G). . . . . . . . . . . . . . . . . . . . . . . . 22,23,86,93
   joins(S,G). . . . . . . . . . . . . . . . . . . . . . . . . .22,23,86
   JT(*,*,RP). . . . . . . . . . . . . . . . . . . . . . . 15,62,129,133
   JT(*,G) . . . . . . . . . . . . . . . . . . . . . . . . 16,67,129,133
   JT(S,G) . . . . . . . . . . . . . . . . . . . . . . . . 18,71,129,133
   KAT(S,G). . . . . . . . . . . . . . .18,26,27,28,41,43,73,108,129,134
   KeepaliveTimer(S,G) . . . . . . . 18,26,27,27,28,41,43,73,108,129,134
   Keepalive_Period. . . . . . . . . . . . . . . . . . . . . . . .27,134
   lan_delay_enabled(I). . . . . . . . . . . . . . . . . . . . . . 35,36
   LAN_Prune_Delay . . . . . . . . . . . . . . . . . . . . . . . . .  31
   local_receiver_exclude(S,G,I) . . . . . . . . . . . . . . . . . .  23
   local_receiver_include(*,G,I) . . . . . . . . . . . . . . . 23,93,144
   local_receiver_include(S,G,I) . . . . . . . . . . . . . . . . . 23,86
   local_receiver_include(S,G,I).. . . . . . . . . . . . . . . . . . 144
   lost_assert(*,G). . . . . . . . . . . . . . . . . . . . . . .22,24,86
   lost_assert(*,G,I). . . . . . . . . . . . . . . . . . . . . 22,24,100
   lost_assert(S,G). . . . . . . . . . . . . . . . . . . . . . . . 22,24
   lost_assert(S,G,I). . . . . . . . . . . . . . . . . . . . . 22,24,100
   lost_assert(S,G,rpt). . . . . . . . . . . . . . . . . . . . . . .  24
   lost_assert(S,G,rpt,I). . . . . . . . . . . . . . . . . . . . .24,100
   MBGP. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6,7
   MFIB. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .6,13
   MLD . . . . . . . . . . . . . . . . . . . . . . . . 6,8,17,23,101,105
   MRIB. . . . . . . . . . . . . .6,7,11,15,19,25,62,66,66,75,98,103,128
   MRIB.next_hop(host) . . . . . . . . . . . . . . . . . . . 24,25,62,64
   my_assert_metric(*,G,I) . . . . . . . . . . . . . . . . . . . . .  94
   my_assert_metric(S,G,I) . . . . . . . . . . . . . . . . . 85,89,92,98
   NBR(Interface,IP_address) . . . . . . . . . . . . . . .25,37,62,64,66
   NLT(N,I). . . . . . . . . . . . . . . . . . . . . . . . 14,33,128,131
   OT(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . . 20,77,129,134
   Override_Interval(I). . . . . . . . . . . . . 14,31,34,36,114,130,132
   packet_arrives_on_rp_tunnel(pkt). . . . . . . . . . . . . . . . .  43
   pim_exclude(S,G). . . . . . . . . . . . . . . . . . . . . 22,22,28,86
   pim_include(*,G). . . . . . . . . . . . . . . . . . 17,22,22,28,86,93
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   pim_include(S,G). . . . . . . . . . . . . . . . . . . .19,22,22,28,86
   PPT(*,*,RP,I) . . . . . . . . . . . . . . . . . . . . . 15,46,128,132
   PPT(*,G,I). . . . . . . . . . . . . . . . . . . . . . . 16,50,129,132
   PPT(S,G,I). . . . . . . . . . . . . . . . . . . . . . . 18,53,129,132
   PPT(S,G,rpt,I). . . . . . . . . . . . . . . . . . . .20,57,59,129,132
   Propagation_Delay(I). . . . . . . . . . . . . . . . . . 31,35,130,132
   Propagation_delay_default . . . . . . . . . . . . . . . . . . .35,130
   PruneDesired(S,G,rpt) . . . . . . . . . . . . . . . . . . 79,80,88,90
   prunes(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . . .22,23,86
   Register-Stop(*,G). . . . . . . . . . . . . . . . . . . . . . . .  42
   Register-Stop(S,G). . . . . . . . . . . . . . . . . . . . . . . .  43
   Register-StopTimer(S,G) . . . . . . . . . . . . . . . . 38,39,129,135
   Register_Probe_Time . . . . . . . . . . . . . . . . . . . . 39,44,135
   Register_Suppression_Time . . . . . . . . . . . . . . . . . 39,44,135
   RP(G) . . . . . . . . . . . . 5,22,24,40,43,49,68,77,86,93,99,102,128
   RPF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6
   RPF&#39;(*,G) . . . . . . . . . . . . . . . . 24,29,67,68,70,76,79,97,101
   RPF&#39;(S,G) . . . . . . . . . . . . . . . . . . . 25,29,71,76,79,90,101
   RPF&#39;(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . .24,76,79,102
   RPF_interface . . . . . . . . . . . . . . . . . . . . . . . . . .  93
   RPF_interface(host) . . . . . .24,27,29,41,68,69,74,86,93,100,108,143
   RPTJoinDesired(G) . . . . . . . . . . . . . . . . . . . . . .79,81,93
   rpt_assert_metric(G,I). . . . . . . . . . . . . . . . . . . .96,97,99
   RST(S,G). . . . . . . . . . . . . . . . . . . . . . . . 38,39,129,135
   SPTbit(S,G) . . . . . . . 19,27,29,43,53,74,76,79,86,86,89,90,100,108
   spt_assert_metric(S,I). . . . . . . . . . . . . . . . . . . 90,98,100
   SSM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10,106
   Suppression_Enabled(I). . . . . . . . . . . . . . . . . . . . .36,133
   SwitchToSptDesired(S,G) . . . . . . . . . . . . . . . . . . .28,28,43
   TIB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6,13,26
   Triggered_Hello_Delay . . . . . . . . . . . . . . . . . . . 31,32,130
   t_joinsuppress. . . . . . . . . . . . . . . . . . . . .64,65,68,69,74
   t_override. . . . . . . . . . . . . . . . . . . . 64,68,73,78,133,134
   t_override_default. . . . . . . . . . . . . . . . . . . . . . .36,130
   t_periodic. . . . . . . . . . . . . . . . . . . . . . . .64,68,73,133
   t_suppressed. . . . . . . . . . . . . . . . . . . .36,65,69,73,74,133
   Update_SPTbit(S,G,iif). . . . . . . . . . . . . . . . . . . . . 27,29
   UpstreamJPState(S,G). . . . . . . . . . . . . . . . . . . . . .27,108
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   pim_include(S,G). . . . . . . . . . . . . . . . . . . .19,22,22,28,86
   PPT(*,*,RP,I) . . . . . . . . . . . . . . . . . . . . . 15,46,128,132
   PPT(*,G,I). . . . . . . . . . . . . . . . . . . . . . . 16,50,129,132
   PPT(S,G,I). . . . . . . . . . . . . . . . . . . . . . . 18,53,129,132
   PPT(S,G,rpt,I). . . . . . . . . . . . . . . . . . . .20,57,59,129,132
   Propagation_Delay(I). . . . . . . . . . . . . . . . . . 31,35,130,132
   Propagation_delay_default . . . . . . . . . . . . . . . . . . .35,130
   PruneDesired(S,G,rpt) . . . . . . . . . . . . . . . . . . 79,80,88,90
   prunes(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . . .22,23,86
   Register-Stop(*,G). . . . . . . . . . . . . . . . . . . . . . . .  42
   Register-Stop(S,G). . . . . . . . . . . . . . . . . . . . . . . .  43
   Register-StopTimer(S,G) . . . . . . . . . . . . . . . . 38,39,129,135
   Register_Probe_Time . . . . . . . . . . . . . . . . . . . . 39,44,135
   Register_Suppression_Time . . . . . . . . . . . . . . . . . 39,44,135
   RP(G) . . . . . . . . . . . . 5,22,24,40,43,49,68,77,86,93,99,102,128
   RPF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6
   RPF&#39;(*,G) . . . . . . . . . . . . . . . . 24,29,67,68,70,76,79,97,101
   RPF&#39;(S,G) . . . . . . . . . . . . . . . . . . . 25,29,71,76,79,90,101
   RPF&#39;(S,G,rpt) . . . . . . . . . . . . . . . . . . . . . .24,76,79,102
   RPF_interface . . . . . . . . . . . . . . . . . . . . . . . . . .  93
   RPF_interface(host) . . . . . .24,27,29,41,68,69,74,86,93,100,108,143
   RPTJoinDesired(G) . . . . . . . . . . . . . . . . . . . . . .79,81,93
   rpt_assert_metric(G,I). . . . . . . . . . . . . . . . . . . .96,97,99
   RST(S,G). . . . . . . . . . . . . . . . . . . . . . . . 38,39,129,135
   SPTbit(S,G) . . . . . . . 19,27,29,43,53,74,76,79,86,86,89,90,100,108
   spt_assert_metric(S,I). . . . . . . . . . . . . . . . . . . 90,98,100
   SSM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10,106
   Suppression_Enabled(I). . . . . . . . . . . . . . . . . . . . .36,133
   SwitchToSptDesired(S,G) . . . . . . . . . . . . . . . . . . .28,28,43
   TIB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6,13,26
   Triggered_Hello_Delay . . . . . . . . . . . . . . . . . . . 31,32,130
   t_joinsuppress. . . . . . . . . . . . . . . . . . . . .64,65,68,69,74
   t_override. . . . . . . . . . . . . . . . . . . . 64,68,73,78,133,134
   t_override_default. . . . . . . . . . . . . . . . . . . . . . .36,130
   t_periodic. . . . . . . . . . . . . . . . . . . . . . . .64,68,73,133
   t_suppressed. . . . . . . . . . . . . . . . . . . .36,65,69,73,74,133
   Update_SPTbit(S,G,iif). . . . . . . . . . . . . . . . . . . . . 27,29
   UpstreamJPState(S,G). . . . . . . . . . . . . . . . . . . . . .27,108
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bill Fenner AT&amp;T Labs - Research 1 River Oaks Place San Jose, CA 95134
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比尔·芬纳AT&amp;T实验室-加利福尼亚州圣何塞河橡树广场研究1号，邮编95134
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: fenner@research.att.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: fenner@research.att.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mark Handley Department of Computer Science University College London Gower Street London WC1E 6BT United Kingdom
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
马克·汉德利英国伦敦高尔街大学学院计算机科学系伦敦WC1E 6BT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: M.Handley@cs.ucl.ac.uk
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: M.Handley@cs.ucl.ac.uk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugh Holbrook Arastra, Inc. P.O. Box 10905 Palo Alto, CA 94303
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
休·霍尔布鲁克·阿拉斯特拉公司，邮政信箱10905，加利福尼亚州帕洛阿尔托市，邮编94303
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: holbrook@arastra.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: holbrook@arastra.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Isidor Kouvelas Cisco Systems 170 W. Tasman Drive San Jose, CA 95134
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
美国加利福尼亚州圣何塞塔斯曼大道西170号伊西多·库维拉斯思科系统公司，邮编95134
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: kouvelas@cisco.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: kouvelas@cisco.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2006).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2006年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其包含的信息是按“原样”提供的，贡献者、他/她所代表或赞助的组织（如有）、互联网协会和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
确认
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC编辑器功能的资金由IETF行政支持活动（IASA）提供。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
