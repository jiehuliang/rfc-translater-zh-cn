<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 2246:  The TLS Protocol Version 1.0  中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2246</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2246">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 2246:  The TLS Protocol Version 1.0  中文翻译</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc2246">
              https://datatracker.ietf.org/doc/html/rfc2246
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 2246</strong></span><br>
          <span class="updated_by">翻译编辑 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                         T. Dierks
Request for Comments: 2246                                     Certicom
Category: Standards Track                                      C. Allen
                                                               Certicom
                                                           January 1999
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                         T. Dierks
Request for Comments: 2246                                     Certicom
Category: Standards Track                                      C. Allen
                                                               Certicom
                                                           January 1999
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
The TLS Protocol Version 1.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-28">
TLS协议版本1.0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本备忘录的状况
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1999年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies Version 1.0 of the Transport Layer Security (TLS) protocol. The TLS protocol provides communications privacy over the Internet. The protocol allows client/server applications to communicate in a way that is designed to prevent eavesdropping, tampering, or message forgery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档规定了传输层安全（TLS）协议的1.0版。TLS协议提供了互联网上的通信隐私。该协议允许客户机/服务器应用程序以防止窃听、篡改或消息伪造的方式进行通信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Introduction 3 2. Goals 4 3. Goals of this document 5 4. Presentation language 5 4.1. Basic block size 6 4.2. Miscellaneous 6 4.3. Vectors 6 4.4. Numbers 7 4.5. Enumerateds 7 4.6. Constructed types 8 4.6.1. Variants 9 4.7. Cryptographic attributes 10 4.8. Constants 11 5. HMAC and the pseudorandom function 11 6. The TLS Record Protocol 13 6.1. Connection states 14
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 导言3 2。目标4.3。本文件的目标5 4。演示语言5.4.1。基本块大小6 4.2。杂项6 4.3。向量6.4.4。数字7.4.5。列举7.4.6。构造类型8 4.6.1。变体9.4.7。加密属性10 4.8。常数11 5。HMAC和伪随机函数11 6。TLS记录协议13.6.1。连接状态14
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.2. Record layer 16 6.2.1. Fragmentation 16 6.2.2. Record compression and decompression 17 6.2.3. Record payload protection 18 6.2.3.1. Null or standard stream cipher 19 6.2.3.2. CBC block cipher 19 6.3. Key calculation 21 6.3.1. Export key generation example 22 7. The TLS Handshake Protocol 23 7.1. Change cipher spec protocol 24 7.2. Alert protocol 24 7.2.1. Closure alerts 25 7.2.2. Error alerts 26 7.3. Handshake Protocol overview 29 7.4. Handshake protocol 32 7.4.1. Hello messages 33 7.4.1.1. Hello request 33 7.4.1.2. Client hello 34 7.4.1.3. Server hello 36 7.4.2. Server certificate 37 7.4.3. Server key exchange message 39 7.4.4. Certificate request 41 7.4.5. Server hello done 42 7.4.6. Client certificate 43 7.4.7. Client key exchange message 43 7.4.7.1. RSA encrypted premaster secret message 44 7.4.7.2. Client Diffie-Hellman public value 45 7.4.8. Certificate verify 45 7.4.9. Finished 46 8. Cryptographic computations 47 8.1. Computing the master secret 47 8.1.1. RSA 48 8.1.2. Diffie-Hellman 48 9. Mandatory Cipher Suites 48 10. Application data protocol 48 A. Protocol constant values 49 A.1. Record layer 49 A.2. Change cipher specs message 50 A.3. Alert messages 50 A.4. Handshake protocol 51 A.4.1. Hello messages 51 A.4.2. Server authentication and key exchange messages 52 A.4.3. Client authentication and key exchange messages 53 A.4.4. Handshake finalization message 54 A.5. The CipherSuite 54 A.6. The Security Parameters 56 B. Glossary 57 C. CipherSuite definitions 61
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6.2. 记录第16层6.2.1。碎片16 6.2.2。记录压缩和解压缩17 6.2.3。记录有效载荷保护18 6.2.3.1。空或标准流密码19 6.2.3.2。CBC分组密码19 6.3。关键计算21 6.3.1。导出密钥生成示例22 7。TLS握手协议23 7.1。更改密码规范协议24 7.2。警报协议24 7.2.1。关闭警报25 7.2.2。错误警报26 7.3。握手协议概述29 7.4。握手协议327.4.1。你好消息337.4.1.1。你好，请求337.4.1.2。客户你好347.4.1.3。服务器hello 367.4.2。服务器证书37 7.4.3。服务器密钥交换消息39 7.4.4。证书申请417.4.5。服务器hello完成427.4.6。客户证书43 7.4.7。客户端密钥交换消息43 7.4.7.1。RSA加密的premaster机密消息44 7.4.7.2。客户Diffie Hellman公共价值45 7.4.8。证书验证45 7.4.9。完成468。密码计算47 8.1。计算主秘密478.1.1。RSA 48 8.1.2。迪菲·赫尔曼48 9。强制性密码套件48 10。应用数据协议48A。协议常量值49A.1。记录第49A.2层。更改密码规格信息50A.3。警报信息50 A.4。握手协议51A.4.1。你好，信息51A.4.2。服务器身份验证和密钥交换消息52 A.4.3。客户端身份验证和密钥交换消息53 A.4.4。握手结束信息54 A.5。密码套件54 A.6。安全参数56 B.术语表57 C.密码套件定义61
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
D. Implementation Notes 64 D.1. Temporary RSA keys 64 D.2. Random Number Generation and Seeding 64 D.3. Certificates and authentication 65 D.4. CipherSuites 65 E. Backward Compatibility With SSL 66 E.1. Version 2 client hello 67 E.2. Avoiding man-in-the-middle version rollback 68 F. Security analysis 69 F.1. Handshake protocol 69 F.1.1. Authentication and key exchange 69 F.1.1.1. Anonymous key exchange 69 F.1.1.2. RSA key exchange and authentication 70 F.1.1.3. Diffie-Hellman key exchange with authentication 71 F.1.2. Version rollback attacks 71 F.1.3. Detecting attacks against the handshake protocol 72 F.1.4. Resuming sessions 72 F.1.5. MD5 and SHA 72 F.2. Protecting application data 72 F.3. Final notes 73 G. Patent Statement 74 Security Considerations 75 References 75 Credits 77 Comments 78 Full Copyright Statement 80
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
D.实施说明64 D.1。临时RSA密钥64 D.2。随机数生成和播种64 D.3。证书和认证65 D.4。密码套件65 E.与SSL 66 E.1的向后兼容性。版本2客户端hello 67 E.2。避免中间人版本回滚68 F.安全分析69 F.1。握手协议69 F.1.1。认证和密钥交换69 F.1.1.1。匿名密钥交换69 F.1.1.2。RSA密钥交换和身份验证70 F.1.1.3。Diffie-Hellman密钥交换与认证71 F.1.2。版本回滚攻击71 F.1.3。检测针对握手协议72 F.1.4的攻击。续会72 F.1.5。MD5和SHA 72 F.2。保护应用程序数据72 F.3。最终注释73 G.专利声明74安全注意事项75参考文献75学分77评论78完整版权声明80
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary goal of the TLS Protocol is to provide privacy and data integrity between two communicating applications. The protocol is composed of two layers: the TLS Record Protocol and the TLS Handshake Protocol. At the lowest level, layered on top of some reliable transport protocol (e.g., TCP[TCP]), is the TLS Record Protocol. The TLS Record Protocol provides connection security that has two basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS协议的主要目标是在两个通信应用程序之间提供隐私和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。在最底层，在某些可靠传输协议（如TCP[TCP]）之上的是TLS记录协议。TLS记录协议提供具有两个基本属性的连接安全性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The connection is private. Symmetric cryptography is used for data encryption (e.g., DES [DES], RC4 [RC4], etc.) The keys for this symmetric encryption are generated uniquely for each connection and are based on a secret negotiated by another protocol (such as the TLS Handshake Protocol). The Record Protocol can also be used without encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 连接是私有的。对称加密用于数据加密（例如DES[DES]、RC4[RC4]等）。此对称加密的密钥为每个连接唯一生成，并基于另一协议（如TLS握手协议）协商的秘密。记录协议也可以在不加密的情况下使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The connection is reliable. Message transport includes a message integrity check using a keyed MAC. Secure hash functions (e.g., SHA, MD5, etc.) are used for MAC computations. The Record Protocol can operate without a MAC, but is generally only used in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 连接可靠。消息传输包括使用密钥MAC的消息完整性检查。安全散列函数（如SHA、MD5等）用于MAC计算。记录协议可以在没有MAC的情况下运行，但通常仅用于
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
this mode while another protocol is using the Record Protocol as a transport for negotiating security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
此模式下，另一个协议使用记录协议作为协商安全参数的传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Protocol is used for encapsulation of various higher level protocols. One such encapsulated protocol, the TLS Handshake Protocol, allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives its first byte of data. The TLS Handshake Protocol provides connection security that has three basic properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS记录协议用于封装各种更高级别的协议。一个这样的封装协议，TLS握手协议，允许服务器和客户端在应用协议发送或接收其第一字节数据之前相互认证并协商加密算法和加密密钥。TLS握手协议提供具有三个基本属性的连接安全性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The peer&#39;s identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA [RSA], DSS [DSS], etc.). This authentication can be made optional, but is generally required for at least one of the peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 对等方的身份可以使用非对称或公钥加密（例如RSA[RSA]、DSS[DSS]等）进行身份验证。此身份验证可以是可选的，但通常至少对一个对等方是必需的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The negotiation of a shared secret is secure: the negotiated secret is unavailable to eavesdroppers, and for any authenticated connection the secret cannot be obtained, even by an attacker who can place himself in the middle of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 共享秘密的协商是安全的：协商的秘密对于窃听者是不可用的，并且对于任何经过验证的连接，都不能获得秘密，即使攻击者可以将自己置于连接的中间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 协商是可靠的：任何攻击者都无法在未被通信各方检测到的情况下修改协商通信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One advantage of TLS is that it is application protocol independent. Higher level protocols can layer on top of the TLS Protocol transparently. The TLS standard, however, does not specify how protocols add security with TLS; the decisions on how to initiate TLS handshaking and how to interpret the authentication certificates exchanged are left up to the judgment of the designers and implementors of protocols which run on top of TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS的一个优点是它独立于应用程序协议。更高级别的协议可以透明地在TLS协议之上分层。然而，TLS标准没有规定协议如何增加TLS的安全性；关于如何启动TLS握手以及如何解释交换的身份验证证书的决定留给在TLS之上运行的协议的设计者和实现者来判断。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Goals
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 目标
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goals of TLS Protocol, in order of their priority, are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS协议的目标，按照优先级顺序，是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. Cryptographic security: TLS should be used to establish a secure connection between two parties.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. 加密安全性：应使用TLS在双方之间建立安全连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. Interoperability: Independent programmers should be able to develop applications utilizing TLS that will then be able to successfully exchange cryptographic parameters without knowledge of one another&#39;s code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. 互操作性：独立程序员应该能够利用TLS开发应用程序，然后能够在不知道彼此代码的情况下成功地交换加密参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. Extensibility: TLS seeks to provide a framework into which new public key and bulk encryption methods can be incorporated as necessary. This will also accomplish two sub-goals: to prevent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. 可扩展性：TLS寻求提供一个框架，在必要时可以将新的公钥和批量加密方法合并到该框架中。这还将实现两个次级目标：预防
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
the need to create a new protocol (and risking the introduction of possible new weaknesses) and to avoid the need to implement an entire new security library.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
需要创建一个新的协议（并有可能引入新的弱点），避免需要实现一个完整的新安全库。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. Relative efficiency: Cryptographic operations tend to be highly CPU intensive, particularly public key operations. For this reason, the TLS protocol has incorporated an optional session caching scheme to reduce the number of connections that need to be established from scratch. Additionally, care has been taken to reduce network activity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. 相对效率：加密操作往往是CPU密集型的，尤其是公钥操作。因此，TLS协议包含了可选的会话缓存方案，以减少需要从头开始建立的连接数。此外，还注意减少网络活动。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Goals of this document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 本文件的目标
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the TLS protocol itself are based on the SSL 3.0 Protocol Specification as published by Netscape. The differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that TLS 1.0 and SSL 3.0 do not interoperate (although TLS 1.0 does incorporate a mechanism by which a TLS implementation can back down to SSL 3.0). This document is intended primarily for readers who will be implementing the protocol and those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups. For that reason, many of the algorithm-dependent data structures and rules are included in the body of the text (as opposed to in an appendix), providing easier access to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档和TLS协议本身基于Netscape发布的SSL 3.0协议规范。此协议与SSL 3.0之间的差异并不显著，但它们的显著性足以使TLS 1.0和SSL 3.0无法互操作（尽管TLS 1.0确实包含了一种机制，通过该机制TLS实现可以返回到SSL 3.0）。本文档主要面向将要实施协议的读者以及对其进行密码分析的读者。编写规范时就考虑到了这一点，旨在反映这两个群体的需求。因此，许多依赖于算法的数据结构和规则都包含在正文中（而不是附录中），从而更容易访问它们。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not intended to supply any details of service definition nor interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档不打算提供服务定义或接口定义的任何详细信息，尽管它确实涵盖了维护可靠安全性所需的策略选择领域。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Presentation language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 表示语言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document deals with the formatting of data in an external representation. The following very basic and somewhat casually defined presentation syntax will be used. The syntax draws from several sources in its structure. Although it resembles the programming language &#34;C&#34; in its syntax and XDR [XDR] in both its syntax and intent, it would be risky to draw too many parallels. The purpose of this presentation language is to document TLS only, not to have general application beyond that particular goal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档处理外部表示中的数据格式。将使用以下非常基本且随意定义的表示语法。该语法从其结构中的多个源中提取。尽管它在语法上与编程语言“C”相似，在语法和意图上与XDR[XDR]相似，但画太多的平行线是有风险的。此演示语言的目的是仅记录TLS，而不是在特定目标之外进行一般应用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Basic block size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 基本块大小
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The representation of all data items is explicitly specified. The basic data block size is one byte (i.e. 8 bits). Multiple byte data items are concatenations of bytes, from left to right, from top to bottom. From the bytestream a multi-byte item (a numeric in the example) is formed (using C notation) by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
明确指定了所有数据项的表示形式。基本数据块大小为一个字节（即8位）。多字节数据项是从左到右、从上到下的字节串联。从ByTestStream中，多字节项（本例中为数字）通过以下方式形成（使用C表示法）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
               ... | byte[n-1];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       value = (byte[0] &lt;&lt; 8*(n-1)) | (byte[1] &lt;&lt; 8*(n-2)) |
               ... | byte[n-1];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This byte ordering for multi-byte values is the commonplace network byte order or big endian format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多字节值的字节顺序是常见的网络字节顺序或big-endian格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Miscellaneous
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 混杂的
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Comments begin with &#34;/*&#34; and end with &#34;*/&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注释以“/*”开头，以“*/”结尾。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional components are denoted by enclosing them in &#34;[[ ]]&#34; double brackets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可选组件用“[]]”双括号括起来表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Single byte entities containing uninterpreted data are of type opaque.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包含未解释数据的单字节实体属于不透明类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Vectors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 载体
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A vector (single dimensioned array) is a stream of homogeneous data elements. The size of the vector may be specified at documentation time or left unspecified until runtime. In either case the length declares the number of bytes, not the number of elements, in the vector. The syntax for specifying a new type T&#39; that is a fixed length vector of type T is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向量（一维数组）是同质数据元素的流。向量的大小可以在文档编制时指定，也可以在运行时才指定。在任何一种情况下，长度都声明向量中的字节数，而不是元素数。指定新类型T&#39;的语法为
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
T T&#39;[n];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
T′[n]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here T&#39; occupies n bytes in the data stream, where n is a multiple of the size of T. The length of the vector is not included in the encoded stream.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里，T&#39;在数据流中占据n个字节，其中n是T大小的倍数。矢量的长度不包括在编码流中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, Datum is defined to be three consecutive bytes that the protocol does not interpret, while Data is three consecutive Datum, consuming a total of nine bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在下面的示例中，数据被定义为协议不解释的三个连续字节，而数据是三个连续的数据，总共消耗九个字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque Datum[3];      /* three uninterpreted bytes */
       Datum Data[9];        /* 3 consecutive 3 byte vectors */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque Datum[3];      /* three uninterpreted bytes */
       Datum Data[9];        /* 3 consecutive 3 byte vectors */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variable length vectors are defined by specifying a subrange of legal lengths, inclusively, using the notation &lt;floor..ceiling&gt;. When encoded, the actual length precedes the vector&#39;s contents in the byte stream. The length will be in the form of a number consuming as many bytes as required to hold the vector&#39;s specified maximum (ceiling) length. A variable length vector with an actual length field of zero is referred to as an empty vector.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可变长度向量是通过指定合法长度的子范围来定义的，包括使用符号&lt;floor..天花&gt;。编码时，实际长度先于字节流中向量的内容。长度将以一个数字的形式出现，该数字消耗的字节数与保持向量指定的最大（上限）长度所需的字节数相同。实际长度字段为零的可变长度向量称为空向量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       T T&#39;&lt;floor..ceiling&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       T T&#39;&lt;floor..ceiling&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, mandatory is a vector that must contain between 300 and 400 bytes of type opaque. It can never be empty. The actual length field consumes two bytes, a uint16, sufficient to represent the value 400 (see Section 4.4). On the other hand, longer can represent up to 800 bytes of data, or 400 uint16 elements, and it may be empty. Its encoding will include a two byte actual length field prepended to the vector. The length of an encoded vector must be an even multiple of the length of a single element (for example, a 17 byte vector of uint16 would be illegal).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在下面的示例中，强制是一个必须包含300到400字节类型不透明的向量。它永远不会是空的。实际长度字段消耗两个字节，一个uint16，足以表示值400（参见第4.4节）。另一方面，longer可以表示多达800字节的数据或400个uint16元素，并且它可能是空的。它的编码将包括一个在向量前面的两字节实际长度字段。编码向量的长度必须是单个元素长度的偶数倍（例如，uint16的17字节向量是非法的）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque mandatory&lt;300..400&gt;;
             /* length field is 2 bytes, cannot be empty */
       uint16 longer&lt;0..800&gt;;
             /* zero to 400 16-bit unsigned integers */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque mandatory&lt;300..400&gt;;
             /* length field is 2 bytes, cannot be empty */
       uint16 longer&lt;0..800&gt;;
             /* zero to 400 16-bit unsigned integers */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 数字
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic numeric data type is an unsigned byte (uint8). All larger numeric data types are formed from fixed length series of bytes concatenated as described in Section 4.1 and are also unsigned. The following numeric types are predefined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本数字数据类型是无符号字节（uint8）。所有较大的数值数据类型都是由固定长度的字节序列组成的，如第4.1节所述，这些字节串接在一起，并且也是无符号的。以下数字类型是预定义的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uint8 uint16[2];
       uint8 uint24[3];
       uint8 uint32[4];
       uint8 uint64[8];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uint8 uint16[2];
       uint8 uint24[3];
       uint8 uint32[4];
       uint8 uint64[8];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All values, here and elsewhere in the specification, are stored in &#34;network&#34; or &#34;big-endian&#34; order; the uint32 represented by the hex bytes 01 02 03 04 is equivalent to the decimal value 16909060.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
规范中的所有值都以“网络”或“大端”顺序存储；十六进制字节01 02 03 04表示的uint32相当于十进制值16909060。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Enumerateds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 列举
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An additional sparse data type is available called enum. A field of type enum can only assume the values declared in the definition. Each definition is a different type. Only enumerateds of the same type may be assigned or compared. Every element of an enumerated must
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
另一种稀疏数据类型称为enum。enum类型的字段只能采用定义中声明的值。每个定义都是不同的类型。只能分配或比较相同类型的枚举。枚举的每个元素都必须
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
be assigned a value, as demonstrated in the following example. Since the elements of the enumerated are not ordered, they can be assigned any unique value, in any order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定一个值，如下例所示。由于枚举的元素没有顺序，因此可以按任何顺序为它们分配任何唯一的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Enumerateds occupy as much space in the byte stream as would its maximal defined ordinal value. The following definition would cause one byte to be used to carry fields of type Color.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
枚举数在字节流中占用的空间与其定义的最大序数值相同。以下定义将导致使用一个字节来携带Color类型的字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { red(3), blue(5), white(7) } Color;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { red(3), blue(5), white(7) } Color;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One may optionally specify a value without its associated tag to force the width definition without defining a superfluous element. In the following example, Taste will consume two bytes in the data stream but can only assume the values 1, 2 or 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可以选择指定一个没有关联标记的值，以强制进行宽度定义，而不定义多余的元素。在下面的示例中，Taste将在数据流中消耗两个字节，但只能假定值为1、2或4。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The names of the elements of an enumeration are scoped within the defined type. In the first example, a fully qualified reference to the second element of the enumeration would be Color.blue. Such qualification is not required if the target of the assignment is well specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
枚举元素的名称在定义的类型范围内。在第一个示例中，枚举的第二个元素的完全限定引用是Color.blue。如果明确规定了任务目标，则不需要此类资格。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Color color = Color.blue;     /* overspecified, legal */
       Color color = blue;           /* correct, type implicit */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Color color = Color.blue;     /* overspecified, legal */
       Color color = blue;           /* correct, type implicit */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For enumerateds that are never converted to external representation, the numerical information may be omitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于从未转换为外部表示的枚举，可以省略数字信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { low, medium, high } Amount;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { low, medium, high } Amount;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. Constructed types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 构造类型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure types may be constructed from primitive types for convenience. Each specification declares a new, unique type. The syntax for definition is much like that of C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为方便起见，可以从基元类型构造结构类型。每个规范都声明了一个新的、唯一的类型。定义的语法与C非常相似。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
         T1 f1;
         T2 f2;
         ...
         Tn fn;
       } [[T]];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
         T1 f1;
         T2 f2;
         ...
         Tn fn;
       } [[T]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fields within a structure may be qualified using the type&#39;s name using a syntax much like that available for enumerateds. For example, T.f2 refers to the second field of the previous declaration. Structure definitions may be embedded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结构中的字段可以使用类型名称限定，并使用类似于枚举的语法。例如，T.f2引用上一个声明的第二个字段。可以嵌入结构定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Variants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. 变体
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Defined structures may have variants based on some knowledge that is available within the environment. The selector must be an enumerated type that defines the possible variants the structure defines. There must be a case arm for every element of the enumeration declared in the select. The body of the variant structure may be given a label for reference. The mechanism by which the variant is selected at runtime is not prescribed by the presentation language.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义的结构可能具有基于环境中可用的某些知识的变体。选择器必须是定义结构定义的可能变量的枚举类型。select中声明的枚举的每个元素都必须有一个大小写臂。变体结构的主体可提供一个标签以供参考。表示语言没有规定在运行时选择变体的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           T1 f1;
           T2 f2;
           ....
           Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               ....
               case en: Ten;
           } [[fv]];
       } [[Tv]];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           T1 f1;
           T2 f2;
           ....
           Tn fn;
           select (E) {
               case e1: Te1;
               case e2: Te2;
               ....
               case en: Ten;
           } [[fv]];
       } [[Tv]];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { apple, orange } VariantTag;
       struct {
           uint16 number;
           opaque string&lt;0..10&gt;; /* variable length */
       } V1;
       struct {
           uint32 number;
           opaque string[10];    /* fixed length */
       } V2;
       struct {
           select (VariantTag) { /* value of selector is implicit */
               case apple: V1;   /* VariantBody, tag = apple */
               case orange: V2;  /* VariantBody, tag = orange */
           } variant_body;       /* optional label on variant */
       } VariantRecord;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { apple, orange } VariantTag;
       struct {
           uint16 number;
           opaque string&lt;0..10&gt;; /* variable length */
       } V1;
       struct {
           uint32 number;
           opaque string[10];    /* fixed length */
       } V2;
       struct {
           select (VariantTag) { /* value of selector is implicit */
               case apple: V1;   /* VariantBody, tag = apple */
               case orange: V2;  /* VariantBody, tag = orange */
           } variant_body;       /* optional label on variant */
       } VariantRecord;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Variant structures may be qualified (narrowed) by specifying a value for the selector prior to the type. For example, a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过在类型之前为选择器指定一个值，可以限定（缩小）变体结构。例如，一个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
orange VariantRecord
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
桔黄色条纹
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is a narrowed type of a VariantRecord containing a variant_body of type V2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
是一种变型记录的窄型，包含V2型变型体。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. Cryptographic attributes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. 加密属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The four cryptographic operations digital signing, stream cipher encryption, block cipher encryption, and public key encryption are designated digitally-signed, stream-ciphered, block-ciphered, and public-key-encrypted, respectively. A field&#39;s cryptographic processing is specified by prepending an appropriate key word designation before the field&#39;s type specification. Cryptographic keys are implied by the current session state (see Section 6.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数字签名、流密码加密、分组密码加密和公钥加密这四种加密操作分别指定为数字签名、流密码、分组密码和公钥加密。字段的加密处理是通过在字段的类型规范之前添加适当的关键字指定来指定的。加密密钥由当前会话状态暗示（参见第6.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In digital signing, one-way hash functions are used as input for a signing algorithm. A digitally-signed element is encoded as an opaque vector &lt;0..2^16-1&gt;, where the length is specified by the signing algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在数字签名中，单向散列函数用作签名算法的输入。数字签名元素被编码为不透明向量&lt;0..2^16-1&gt;，其中长度由签名算法和密钥指定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In RSA signing, a 36-byte structure of two hashes (one SHA and one MD5) is signed (encrypted with the private key). It is encoded with PKCS #1 block type 0 or type 1 as described in [PKCS1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在RSA签名中，对两个哈希（一个SHA和一个MD5）组成的36字节结构进行签名（用私钥加密）。它使用PKCS#1块类型0或类型1编码，如[PKCS1]中所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In DSS, the 20 bytes of the SHA hash are run directly through the Digital Signing Algorithm with no additional hashing. This produces two values, r and s. The DSS signature is an opaque vector, as above, the contents of which are the DER encoding of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在DSS中，SHA散列的20个字节直接通过数字签名算法运行，无需额外的散列。这将产生两个值r和s。DSS签名是一个不透明的向量，如上所述，其内容为DER编码：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Dss-Sig-Value  ::=  SEQUENCE  {
            r       INTEGER,
            s       INTEGER
       }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Dss-Sig-Value  ::=  SEQUENCE  {
            r       INTEGER,
            s       INTEGER
       }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically-secure keyed pseudorandom number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在流密码加密中，明文与加密安全密钥伪随机数生成器生成的相同数量的输出进行异或运算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In block cipher encryption, every block of plaintext encrypts to a block of ciphertext. All block cipher encryption is done in CBC (Cipher Block Chaining) mode, and all items which are block-ciphered will be an exact multiple of the cipher block length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在分组密码加密中，每个明文块加密为一个密文块。所有的分组密码加密都是在CBC（cipher block Chaining）模式下完成的，所有被分组加密的项目都是密码块长度的精确倍数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In public key encryption, a public key algorithm is used to encrypt data in such a way that it can be decrypted only with the matching private key. A public-key-encrypted element is encoded as an opaque vector &lt;0..2^16-1&gt;, where the length is specified by the signing algorithm and key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在公钥加密中，使用公钥算法对数据进行加密，使其只能用匹配的私钥解密。公钥加密元素被编码为不透明向量&lt;0..2^16-1&gt;，其中长度由签名算法和密钥指定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RSA encrypted value is encoded with PKCS #1 block type 2 as described in [PKCS1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA加密值使用PKCS#1块类型2进行编码，如[PKCS1]中所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在以下示例中：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stream-ciphered struct {
           uint8 field1;
           uint8 field2;
           digitally-signed opaque hash[20];
       } UserType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stream-ciphered struct {
           uint8 field1;
           uint8 field2;
           digitally-signed opaque hash[20];
       } UserType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of hash are used as input for the signing algorithm, then the entire structure is encrypted with a stream cipher. The length of this structure, in bytes would be equal to 2 bytes for field1 and field2, plus two bytes for the length of the signature, plus the length of the output of the signing algorithm. This is known due to the fact that the algorithm and key used for the signing are known prior to encoding or decoding this structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
哈希的内容用作签名算法的输入，然后使用流密码对整个结构进行加密。此结构的长度（以字节为单位）等于field1和field2的2个字节，再加上签名长度的两个字节，再加上签名算法输出的长度。这是已知的，因为用于签名的算法和密钥在编码或解码该结构之前是已知的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. 常数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Typed constants can be defined for purposes of specification by declaring a symbol of the desired type and assigning values to it. Under-specified types (opaque, variable length vectors, and structures that contain opaque) cannot be assigned values. No fields of a multi-element structure or vector may be elided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过声明所需类型的符号并为其赋值，可以为规范定义类型化常量。在指定的类型（不透明、可变长度向量和包含不透明的结构）下，无法指定值。不得省略多元素结构或向量的任何字段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           uint8 f1;
           uint8 f2;
       } Example1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           uint8 f1;
           uint8 f2;
       } Example1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Example1 ex1 = {1, 4};  /* assigns f1 = 1, f2 = 4 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMAC and the pseudorandom function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. HMAC与伪随机函数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of operations in the TLS record and handshake layer required a keyed MAC; this is a secure digest of some data protected by a secret. Forging the MAC is infeasible without knowledge of the MAC secret. The construction we use for this operation is known as HMAC, described in [HMAC].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS记录和握手层中的许多操作需要密钥MAC；这是受机密保护的某些数据的安全摘要。如果不知道MAC的秘密，伪造MAC是不可行的。我们用于此操作的结构称为HMAC，如[HMAC]所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC can be used with a variety of different hash algorithms. TLS uses it in the handshake with two different algorithms: MD5 and SHA-1, denoting these as HMAC_MD5(secret, data) and HMAC_SHA(secret,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HMAC可以与各种不同的哈希算法一起使用。TLS在握手中使用了两种不同的算法：MD5和SHA-1，表示为HMAC_MD5（机密，数据）和HMAC_SHA（机密，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
data). Additional hash algorithms can be defined by cipher suites and used to protect record data, but MD5 and SHA-1 are hard coded into the description of the handshaking for this version of the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据）。额外的散列算法可以由密码套件定义并用于保护记录数据，但是MD5和SHA-1被硬编码到该版本协议的握手描述中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, a construction is required to do expansion of secrets into blocks of data for the purposes of key generation or validation. This pseudo-random function (PRF) takes as input a secret, a seed, and an identifying label and produces an output of arbitrary length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，为了密钥生成或验证的目的，需要一个构造来将秘密扩展到数据块中。这个伪随机函数（PRF）以一个秘密、一个种子和一个识别标签作为输入，并产生任意长度的输出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to make the PRF as secure as possible, it uses two hash algorithms in a way which should guarantee its security if either algorithm remains secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了使PRF尽可能安全，它使用了两种哈希算法，如果其中一种算法保持安全，则应保证其安全性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, we define a data expansion function, P_hash(secret, data) which uses a single hash function to expand a secret and seed into an arbitrary quantity of output:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
首先，我们定义了一个数据扩展函数P_hash（secret，data），它使用一个散列函数来扩展一个秘密并将其种子植入任意数量的输出：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + HMAC_hash(secret, A(2) + seed) + HMAC_hash(secret, A(3) + seed) + ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
P_hash（secret，seed）=HMAC_hash（secret，A（1）+seed）+HMAC_hash（secret，A（2）+seed）+HMAC_hash（secret，A（3）+seed）+。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Where + indicates concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中+表示串联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A() is defined as:
       A(0) = seed
       A(i) = HMAC_hash(secret, A(i-1))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A() is defined as:
       A(0) = seed
       A(i) = HMAC_hash(secret, A(i-1))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P_hash can be iterated as many times as is necessary to produce the required quantity of data. For example, if P_SHA-1 was being used to create 64 bytes of data, it would have to be iterated 4 times (through A(4)), creating 80 bytes of output data; the last 16 bytes of the final iteration would then be discarded, leaving 64 bytes of output data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P_散列可以根据需要多次迭代以生成所需数量的数据。例如，如果使用P_SHA-1创建64字节的数据，则必须迭代4次（通过A（4）），创建80字节的输出数据；最终迭代的最后16个字节将被丢弃，留下64个字节的输出数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS&#39;s PRF is created by splitting the secret into two halves and using one half to generate data with P_MD5 and the other half to generate data with P_SHA-1, then exclusive-or&#39;ing the outputs of these two expansion functions together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS的PRF是通过将机密分为两半，使用一半与P_MD5生成数据，另一半与P_SHA-1生成数据，然后将这两个扩展函数的输出一起异或而创建的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S1 and S2 are the two halves of the secret and each is the same length. S1 is taken from the first half of the secret, S2 from the second half. Their length is created by rounding up the length of the overall secret divided by two; thus, if the original secret is an odd number of bytes long, the last byte of S1 will be the same as the first byte of S2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S1和S2是秘密的两部分，每部分长度相同。S1取自《秘密》的前半部分，S2取自《秘密》的后半部分。它们的长度是通过将整个秘密的长度四舍五入除以二而产生的；因此，如果原始机密是奇数字节长，则S1的最后一个字节将与S2的第一个字节相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       L_S = length in bytes of secret;
       L_S1 = L_S2 = ceil(L_S / 2);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       L_S = length in bytes of secret;
       L_S1 = L_S2 = ceil(L_S / 2);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secret is partitioned into two halves (with the possibility of one shared byte) as described above, S1 taking the first L_S1 bytes and S2 the last L_S2 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述，秘密被分成两半（可能有一个共享字节），S1取第一个L_S1字节，S2取最后一个L_S2字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PRF is then defined as the result of mixing the two pseudorandom streams by exclusive-or&#39;ing them together.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，PRF被定义为通过将两个伪随机流互斥或“或”组合在一起来混合这两个伪随机流的结果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
                                  P_SHA-1(S2, label + seed);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR
                                  P_SHA-1(S2, label + seed);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The label is an ASCII string. It should be included in the exact form it is given without a length byte or trailing null character. For example, the label &#34;slithy toves&#34; would be processed by hashing the following bytes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
标签是ASCII字符串。它应该包含在给定的确切形式中，没有长度字节或尾随空字符。例如，标签“slithy toves”将通过散列以下字节进行处理：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
73 6C 69 74 68 79 20 74 6F 76 65 73
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
73 6C 69 74 68 79 20 74 6F 76 65 73
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that because MD5 produces 16 byte outputs and SHA-1 produces 20 byte outputs, the boundaries of their internal iterations will not be aligned; to generate a 80 byte output will involve P_MD5 being iterated through A(5), while P_SHA-1 will only iterate through A(4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，因为MD5产生16字节的输出，而SHA-1产生20字节的输出，所以它们内部迭代的边界不会对齐；要生成一个80字节的输出，需要通过（5）迭代P_MD5，而P_SHA-1只会通过（4）迭代。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. The TLS Record Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. TLS记录协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Protocol is a layered protocol. At each layer, messages may include fields for length, description, and content. The Record Protocol takes messages to be transmitted, fragments the data into manageable blocks, optionally compresses the data, applies a MAC, encrypts, and transmits the result. Received data is decrypted, verified, decompressed, and reassembled, then delivered to higher level clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS记录协议是一个分层协议。在每一层，消息可能包括长度、描述和内容字段。记录协议接收要传输的消息，将数据分割成可管理的块，选择性地压缩数据，应用MAC，加密并传输结果。接收到的数据经过解密、验证、解压缩和重新组装，然后发送到更高级别的客户端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Four record protocol clients are described in this document: the handshake protocol, the alert protocol, the change cipher spec protocol, and the application data protocol. In order to allow extension of the TLS protocol, additional record types can be supported by the record protocol. Any new record types should allocate type values immediately beyond the ContentType values for the four record types described here (see Appendix A.2). If a TLS implementation receives a record type it does not understand, it should just ignore it. Any protocol designed for use over TLS must be carefully designed to deal with all possible attacks against it. Note that because the type and length of a record are not protected by encryption, care should be take to minimize the value of traffic analysis of these values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文描述了四种记录协议客户端：握手协议、警报协议、更改密码规范协议和应用程序数据协议。为了允许TLS协议的扩展，记录协议可以支持其他记录类型。任何新的记录类型都应为此处描述的四种记录类型分配超出ContentType值的类型值（见附录A.2）。如果TLS实现接收到它不理解的记录类型，它应该忽略它。任何设计用于TLS的协议都必须仔细设计，以应对所有可能的攻击。请注意，由于记录的类型和长度不受加密保护，因此应注意最小化这些值的流量分析值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Connection states
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 连接状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLS connection state is the operating environment of the TLS Record Protocol. It specifies a compression algorithm, encryption algorithm, and MAC algorithm. In addition, the parameters for these algorithms are known: the MAC secret and the bulk encryption keys and IVs for the connection in both the read and the write directions. Logically, there are always four connection states outstanding: the current read and write states, and the pending read and write states. All records are processed under the current read and write states. The security parameters for the pending states can be set by the TLS Handshake Protocol, and the Handshake Protocol can selectively make either of the pending states current, in which case the appropriate current state is disposed of and replaced with the pending state; the pending state is then reinitialized to an empty state. It is illegal to make a state which has not been initialized with security parameters a current state. The initial current state always specifies that no encryption, compression, or MAC will be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS连接状态是TLS记录协议的操作环境。它指定了压缩算法、加密算法和MAC算法。此外，这些算法的参数是已知的：MAC密钥和大容量加密密钥以及读写方向连接的IVs。从逻辑上讲，始终存在四种未完成的连接状态：当前读写状态和挂起读写状态。所有记录都在当前读写状态下处理。待决状态的安全参数可由TLS握手协议设置，并且握手协议可选择性地使任一待决状态成为当前状态，在这种情况下，适当的当前状态被处理并替换为待决状态；然后将挂起状态重新初始化为空状态。将未使用安全参数初始化的状态设置为当前状态是非法的。初始当前状态始终指定不使用加密、压缩或MAC。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The security parameters for a TLS Connection read and write state are set by providing the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过提供以下值来设置TLS连接读写状态的安全参数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection end Whether this entity is considered the &#34;client&#34; or the &#34;server&#34; in this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
连接结束此实体在此连接中被视为“客户端”还是“服务器”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bulk encryption algorithm An algorithm to be used for bulk encryption. This specification includes the key size of this algorithm, how much of that key is secret, whether it is a block or stream cipher, the block size of the cipher (if appropriate), and whether it is considered an &#34;export&#34; cipher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
批量加密算法用于批量加密的算法。此规范包括此算法的密钥大小、该密钥的保密程度、是块密码还是流密码、密码的块大小（如果合适），以及是否将其视为“导出”密码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC algorithm An algorithm to be used for message authentication. This specification includes the size of the hash which is returned by the MAC algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC算法用于消息身份验证的算法。该规范包括MAC算法返回的哈希的大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression algorithm An algorithm to be used for data compression. This specification must include all information the algorithm requires to do compression.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩算法用于数据压缩的算法。此规范必须包含算法进行压缩所需的所有信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret A 48 byte secret shared between the two peers in the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主密钥连接中两个对等方共享的48字节密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client random A 32 byte value provided by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client random客户端提供的32字节值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server random A 32 byte value provided by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server random服务器提供的32字节值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These parameters are defined in the presentation language as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些参数在表示语言中定义为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { server, client } ConnectionEnd;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { stream, block } CipherType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { stream, block } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { true, false } IsExportable;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { true, false } IsExportable;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The algorithms specified in CompressionMethod,
          BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       /* The algorithms specified in CompressionMethod,
          BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ConnectionEnd          entity;
           BulkCipherAlgorithm    bulk_cipher_algorithm;
           CipherType             cipher_type;
           uint8                  key_size;
           uint8                  key_material_length;
           IsExportable           is_exportable;
           MACAlgorithm           mac_algorithm;
           uint8                  hash_size;
           CompressionMethod      compression_algorithm;
           opaque                 master_secret[48];
           opaque                 client_random[32];
           opaque                 server_random[32];
       } SecurityParameters;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ConnectionEnd          entity;
           BulkCipherAlgorithm    bulk_cipher_algorithm;
           CipherType             cipher_type;
           uint8                  key_size;
           uint8                  key_material_length;
           IsExportable           is_exportable;
           MACAlgorithm           mac_algorithm;
           uint8                  hash_size;
           CompressionMethod      compression_algorithm;
           opaque                 master_secret[48];
           opaque                 client_random[32];
           opaque                 server_random[32];
       } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The record layer will use the security parameters to generate the following six items:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
记录层将使用安全参数生成以下六项：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client write MAC secret server write MAC secret client write key server write key client write IV (for block ciphers only) server write IV (for block ciphers only)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
客户端写入MAC机密服务器写入MAC机密客户端写入密钥服务器写入密钥客户端写入IV（仅限块密码）服务器写入IV（仅限块密码）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client write parameters are used by the server when receiving and processing records and vice-versa. The algorithm used for generating these items from the security parameters is described in section 6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
服务器在接收和处理记录时使用客户端写入参数，反之亦然。第6.3节描述了用于从安全参数生成这些项的算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the security parameters have been set and the keys have been generated, the connection states can be instantiated by making them the current states. These current states must be updated for each record processed. Each connection state includes the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦设置了安全参数并生成了密钥，就可以通过将它们设置为当前状态来实例化连接状态。必须为处理的每个记录更新这些当前状态。每个连接状态包括以下元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression state The current state of the compression algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩状态压缩算法的当前状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher state The current state of the encryption algorithm. This will consist of the scheduled key for that connection. In addition, for block ciphers running in CBC mode (the only mode specified for TLS), this will initially contain the IV for that connection state and be updated to contain the ciphertext of the last block encrypted or decrypted as records are processed. For stream ciphers, this will contain whatever the necessary state information is to allow the stream to continue to encrypt or decrypt data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密码状态加密算法的当前状态。这将包括该连接的计划密钥。此外，对于在CBC模式（为TLS指定的唯一模式）下运行的块密码，该模式最初将包含该连接状态的IV，并更新为包含在处理记录时加密或解密的最后一个块的密文。对于流密码，它将包含任何必要的状态信息，以允许流继续加密或解密数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC secret The MAC secret for this connection as generated above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC机密上面生成的此连接的MAC机密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence number Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number must be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. A sequence number is incremented after each record: specifically, the first record which is transmitted under a particular connection state should use sequence number 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
序列号每个连接状态都包含一个序列号，该序列号分别针对读和写状态进行维护。每当连接状态变为活动状态时，序列号必须设置为零。序列号为uint64类型，不得超过2^64-1。序列号在每个记录后递增：具体来说，在特定连接状态下传输的第一个记录应使用序列号0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Record layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 记录层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Record Layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS记录层在任意大小的非空块中接收来自更高层的未解释数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Fragmentation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. 碎裂
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The record layer fragments information blocks into TLSPlaintext records carrying data in chunks of 2^14 bytes or less. Client message boundaries are not preserved in the record layer (i.e., multiple client messages of the same ContentType may be coalesced into a single TLSPlaintext record, or a single message may be fragmented across several records).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
记录层将信息块分割成TLSPlaintext记录，其中包含2^14字节或更少的数据块。客户端消息边界不保留在记录层中（即，相同ContentType的多个客户端消息可能合并到单个TLSPlaintext记录中，或者单个消息可能在多个记录中分段）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           uint8 major, minor;
       } ProtocolVersion;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           uint8 major, minor;
       } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum {
           change_cipher_spec(20), alert(21), handshake(22),
           application_data(23), (255)
       } ContentType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum {
           change_cipher_spec(20), alert(21), handshake(22),
           application_data(23), (255)
       } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           opaque fragment[TLSPlaintext.length];
       } TLSPlaintext;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           opaque fragment[TLSPlaintext.length];
       } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The higher level protocol used to process the enclosed fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入用于处理封闭片段的更高级别协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The version of the protocol being employed. This document describes TLS Version 1.0, which uses the version { 3, 1 }. The version value 3.1 is historical: TLS version 1.0 is a minor modification to the SSL 3.0 protocol, which bears the version value 3.0. (See Appendix A.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版本正在使用的协议的版本。本文档描述了TLS版本1.0，它使用版本{3，1}。版本值3.1是历史版本：TLS版本1.0是对SSL 3.0协议的一个小修改，该协议具有版本值3.0。（见附录A.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSPlaintext.fragment. The length should not exceed 2^14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length以下TLSPlaintext.fragment的长度（以字节为单位）。长度不应超过2^14。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The application data. This data is transparent and treated as an independent block to be dealt with by the higher level protocol specified by the type field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分割应用程序数据。此数据是透明的，并被视为独立的块，由类型字段指定的更高级别协议处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Data of different TLS Record layer content types may be interleaved. Application data is generally of lower precedence for transmission than other content types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：不同TLS记录层内容类型的数据可以交错。应用程序数据的传输优先级通常低于其他内容类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Record compression and decompression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. 记录压缩和解压缩
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All records are compressed using the compression algorithm defined in the current session state. There is always an active compression algorithm; however, initially it is defined as CompressionMethod.null. The compression algorithm translates a TLSPlaintext structure into a TLSCompressed structure. Compression functions are initialized with default state information whenever a connection state is made active.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用当前会话状态中定义的压缩算法压缩所有记录。总是有一个主动的压缩算法；但是，最初它被定义为CompressionMethod.null。压缩算法将TLSPlaintText结构转换为TLS压缩结构。每当连接状态处于活动状态时，压缩函数都会使用默认状态信息初始化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compression must be lossless and may not increase the content length by more than 1024 bytes. If the decompression function encounters a TLSCompressed.fragment that would decompress to a length in excess of 2^14 bytes, it should report a fatal decompression failure error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩必须是无损的，并且不能将内容长度增加1024字节以上。如果解压缩函数遇到一个TLSCompressed.fragment，它将解压缩到超过2^14字节的长度，它将报告一个致命的解压缩失败错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ContentType type;       /* same as TLSPlaintext.type */
           ProtocolVersion version;/* same as TLSPlaintext.version */
           uint16 length;
           opaque fragment[TLSCompressed.length];
       } TLSCompressed;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ContentType type;       /* same as TLSPlaintext.type */
           ProtocolVersion version;/* same as TLSPlaintext.version */
           uint16 length;
           opaque fragment[TLSCompressed.length];
       } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSCompressed.fragment. The length should not exceed 2^14 + 1024.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length以下TLSCompressed.fragment的长度（以字节为单位）。长度不应超过2^14+1024。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The compressed form of TLSPlaintext.fragment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
片段TLSPlaintext.fragment的压缩形式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: A CompressionMethod.null operation is an identity operation; no fields are altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：CompressionMethod.null操作是标识操作；没有字段被更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: Decompression functions are responsible for ensuring that messages cannot cause internal buffer overflows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现说明：解压缩功能负责确保消息不会导致内部缓冲区溢出。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. Record payload protection
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3. 记录有效载荷保护
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encryption and MAC functions translate a TLSCompressed structure into a TLSCiphertext. The decryption functions reverse the process. The MAC of the record also includes a sequence number so that missing, extra or repeated messages are detectable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加密和MAC功能将TLS压缩结构转换为TLSCiphertext。解密函数会反转此过程。记录的MAC还包括序列号，以便可以检测到丢失、额外或重复的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           select (CipherSpec.cipher_type) {
               case stream: GenericStreamCipher;
               case block: GenericBlockCipher;
           } fragment;
       } TLSCiphertext;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ContentType type;
           ProtocolVersion version;
           uint16 length;
           select (CipherSpec.cipher_type) {
               case stream: GenericStreamCipher;
               case block: GenericBlockCipher;
           } fragment;
       } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type field is identical to TLSCompressed.type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型类型字段与TLSCompressed.type相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The version field is identical to TLSCompressed.version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版本版本字段与TLSCompressed.version相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length (in bytes) of the following TLSCiphertext.fragment. The length may not exceed 2^14 + 2048.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length以下TLSCiphertext.fragment的长度（以字节为单位）。长度不得超过2^14+2048。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment The encrypted form of TLSCompressed.fragment, with the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用MAC对TLSCompressed.fragment的加密形式进行分段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1. Null or standard stream cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.1. 空或标准流密码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stream ciphers (including BulkCipherAlgorithm.null - see Appendix A.6) convert TLSCompressed.fragment structures to and from stream TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
流密码（包括BulkCipherGorithm.null-见附录A.6）将TLSCompressed.fragment结构转换为流TLSCiphertext.fragment结构，并将其转换为流TLSCiphertext.fragment结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stream-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
       } GenericStreamCipher;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       stream-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
       } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MAC is generated as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC生成为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +
                     TLSCompressed.version + TLSCompressed.length +
                     TLSCompressed.fragment));
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       HMAC_hash(MAC_write_secret, seq_num + TLSCompressed.type +
                     TLSCompressed.version + TLSCompressed.length +
                     TLSCompressed.fragment));
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where &#34;+&#34; denotes concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中“+”表示串联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seq_num The sequence number for this record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seq_num此记录的序列号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash The hashing algorithm specified by SecurityParameters.mac_algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
哈希SecurityParameters.mac_算法指定的哈希算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the MAC is computed before encryption. The stream cipher encrypts the entire block, including the MAC. For stream ciphers that do not use a synchronization vector (such as RC4), the stream cipher state from the end of one record is simply used on the subsequent packet. If the CipherSuite is TLS_NULL_WITH_NULL_NULL, encryption consists of the identity operation (i.e., the data is not encrypted and the MAC size is zero implying that no MAC is used). TLSCiphertext.length is TLSCompressed.length plus CipherSpec.hash_size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，MAC是在加密之前计算的。流密码加密整个块，包括MAC。对于不使用同步向量（如RC4）的流密码，一条记录末尾的流密码状态仅用于后续数据包。如果密码套件为TLS_NULL_WITH_NULL_NULL，则加密包括标识操作（即，数据未加密，MAC大小为零，表示未使用MAC）。TLSCiphertext.length是TLSCompressed.length加上CipherSpec.hash_大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2. CBC block cipher
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.3.2. 分组密码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For block ciphers (such as RC2 or DES), the encryption and MAC functions convert TLSCompressed.fragment structures to and from block TLSCiphertext.fragment structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于块密码（如RC2或DES），加密和MAC函数将TLSCimpressed.fragment结构转换为块TLSCiphertext.fragment结构，或从块TLSCiphertext.fragment结构转换为块TLSCiphertext.fragment结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       } GenericBlockCipher;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       block-ciphered struct {
           opaque content[TLSCompressed.length];
           opaque MAC[CipherSpec.hash_size];
           uint8 padding[GenericBlockCipher.padding_length];
           uint8 padding_length;
       } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MAC is generated as described in Section 6.2.3.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAC的生成如第6.2.3.1节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding Padding that is added to force the length of the plaintext to be an integral multiple of the block cipher&#39;s block length. The padding may be any length up to 255 bytes long, as long as it results in the TLSCiphertext.length being an integral multiple of the block length. Lengths longer than necessary might be desirable to frustrate attacks on a protocol based on analysis of the lengths of exchanged messages. Each uint8 in the padding data vector must be filled with the padding length value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
填充添加的填充，用于强制明文长度为分组密码的块长度的整数倍。填充可以是最长255字节的任何长度，只要它导致TLSCiphertext.length是块长度的整数倍。根据对交换消息长度的分析，可能需要更长的长度来阻止对协议的攻击。填充数据向量中的每个uint8必须用填充长度值填充。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding_length The padding length should be such that the total size of the GenericBlockCipher structure is a multiple of the cipher&#39;s block length. Legal values range from zero to 255, inclusive. This length specifies the length of the padding field exclusive of the padding_length field itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
padding_length填充长度应确保GenericBlockCipher结构的总大小是密码块长度的倍数。合法值的范围从零到255（包括零和255）。此长度指定填充字段的长度，不包括填充长度字段本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encrypted data length (TLSCiphertext.length) is one more than the sum of TLSCompressed.length, CipherSpec.hash_size, and padding_length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加密数据长度（TLSCiphertext.length）比TLSCompressed.length、CipherSpec.hash_大小和padding_长度之和大一倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Example: If the block length is 8 bytes, the content length (TLSCompressed.length) is 61 bytes, and the MAC length is 20 bytes, the length before padding is 82 bytes. Thus, the padding length modulo 8 must be equal to 6 in order to make the total length an even multiple of 8 bytes (the block length). The padding length can be 6, 14, 22, and so on, through 254. If the padding length were the minimum necessary, 6, the padding would be 6 bytes, each containing the value 6. Thus, the last 8 octets of the GenericBlockCipher before block encryption would be xx 06 06 06 06 06 06 06, where xx is the last octet of the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
示例：如果块长度为8字节，则内容长度（TLSCompressed.length）为61字节，MAC长度为20字节，则填充前的长度为82字节。因此，为了使总长度为8字节（块长度）的偶数倍，填充长度模8必须等于6。填充长度可以是6、14、22等等，一直到254。如果填充长度为所需的最小值6，则填充将为6个字节，每个字节包含值6。因此，在分组加密之前，GenericBlockCipher的最后8个八位字节将是xx 06，其中xx是MAC的最后一个八位字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: With block ciphers in CBC mode (Cipher Block Chaining) the initialization vector (IV) for the first record is generated with the other keys and secrets when the security parameters are set. The IV for subsequent records is the last ciphertext block from the previous record.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：对于CBC模式的分组密码（密码分组链接），当设置安全参数时，第一条记录的初始化向量（IV）与其他密钥和机密一起生成。后续记录的IV是前一记录的最后一个密文块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Key calculation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 关键计算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Record Protocol requires an algorithm to generate keys, IVs, and MAC secrets from the security parameters provided by the handshake protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
记录协议需要一种算法来根据握手协议提供的安全参数生成密钥、IVs和MAC机密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master secret is hashed into a sequence of secure bytes, which are assigned to the MAC secrets, keys, and non-export IVs required by the current connection state (see Appendix A.6). CipherSpecs require a client write MAC secret, a server write MAC secret, a client write key, a server write key, a client write IV, and a server write IV, which are generated from the master secret in that order. Unused values are empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主密钥被散列成一系列安全字节，这些字节被分配给当前连接状态所需的MAC密钥、密钥和非导出IV（见附录a.6）。CipherSpec需要客户机写入MAC密钥、服务器写入MAC密钥、客户机写入密钥、服务器写入密钥、客户机写入IV和服务器写入IV，这些密钥按照主密钥的顺序生成。未使用的值为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When generating keys and MAC secrets, the master secret is used as an entropy source, and the random values provide unencrypted salt material and IVs for exportable ciphers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成密钥和MAC密钥时，主密钥用作熵源，随机值提供未加密的salt材料和可导出密码的IVs。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To generate the key material, compute
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要生成关键材质，请计算
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
key_block = PRF(SecurityParameters.master_secret, &#34;key expansion&#34;, SecurityParameters.server_random + SecurityParameters.client_random);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
key\u block=PRF（SecurityParameters.master\u secret，“密钥扩展”，SecurityParameters.server\u random+SecurityParameters.client\u random）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
until enough output has been generated. Then the key_block is partitioned as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
直到产生足够的输出。然后按如下方式对密钥块进行分区：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       client_write_MAC_secret[SecurityParameters.hash_size]
       server_write_MAC_secret[SecurityParameters.hash_size]
       client_write_key[SecurityParameters.key_material_length]
       server_write_key[SecurityParameters.key_material_length]
       client_write_IV[SecurityParameters.IV_size]
       server_write_IV[SecurityParameters.IV_size]
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       client_write_MAC_secret[SecurityParameters.hash_size]
       server_write_MAC_secret[SecurityParameters.hash_size]
       client_write_key[SecurityParameters.key_material_length]
       server_write_key[SecurityParameters.key_material_length]
       client_write_IV[SecurityParameters.IV_size]
       server_write_IV[SecurityParameters.IV_size]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client_write_IV and server_write_IV are only generated for non-export block ciphers. For exportable block ciphers, the initialization vectors are generated later, as described below. Any extra key_block material is discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端写入IV和服务器写入IV仅为非导出分组密码生成。对于可导出的分组密码，稍后生成初始化向量，如下所述。任何额外的键块材质都将被丢弃。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementation note: The cipher spec which is defined in this document which requires the most material is 3DES_EDE_CBC_SHA: it requires 2 x 24 byte keys, 2 x 20 byte MAC secrets, and 2 x 8 byte IVs, for a total of 104 bytes of key material.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实施说明：本文件中定义的需要最多材料的密码规范是3DES_EDE_CBC_SHA：它需要2 x 24字节的密钥、2 x 20字节的MAC机密和2 x 8字节的IVs，总共需要104字节的密钥材料。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Exportable encryption algorithms (for which CipherSpec.is_exportable is true) require additional processing as follows to derive their final write keys:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可导出加密算法（CipherSpec.is_Exportable为true）需要进行以下附加处理，以导出其最终写入密钥：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       final_client_write_key =
       PRF(SecurityParameters.client_write_key,
                                  &#34;client write key&#34;,
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
       final_server_write_key =
       PRF(SecurityParameters.server_write_key,
                                  &#34;server write key&#34;,
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       final_client_write_key =
       PRF(SecurityParameters.client_write_key,
                                  &#34;client write key&#34;,
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
       final_server_write_key =
       PRF(SecurityParameters.server_write_key,
                                  &#34;server write key&#34;,
                                  SecurityParameters.client_random +
                                  SecurityParameters.server_random);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Exportable encryption algorithms derive their IVs solely from the random values from the hello messages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可导出加密算法仅从hello消息中的随机值派生其IVs：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       iv_block = PRF(&#34;&#34;, &#34;IV block&#34;, SecurityParameters.client_random +
                      SecurityParameters.server_random);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       iv_block = PRF(&#34;&#34;, &#34;IV block&#34;, SecurityParameters.client_random +
                      SecurityParameters.server_random);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The iv_block is partitioned into two initialization vectors as the key_block was above:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iv_块被划分为两个初始化向量，因为键_块位于上面：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client_write_IV[SecurityParameters.IV_size] server_write_IV[SecurityParameters.IV_size]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
客户端写入IV[SecurityParameters.IV大小]服务器写入IV[SecurityParameters.IV大小]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the PRF is used without a secret in this case: this just means that the secret has a length of zero bytes and contributes nothing to the hashing in the PRF.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，在这种情况下，使用PRF时没有密码：这只是意味着密码的长度为零字节，对PRF中的哈希没有任何贡献。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Export key generation example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. 导出密钥生成示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 requires five random bytes for each of the two encryption keys and 16 bytes for each of the MAC keys, for a total of 42 bytes of key material. The PRF output is stored in the key_block. The key_block is partitioned, and the write keys are salted because this is an exportable encryption algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5需要两个加密密钥各5个随机字节，MAC密钥各16个字节，总共需要42字节的密钥材料。PRF输出存储在key_块中。密钥块是分区的，写入密钥是加盐的，因为这是一种可导出的加密算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       key_block               = PRF(master_secret,
                                     &#34;key expansion&#34;,
                                     server_random +
                                     client_random)[0..41]
       client_write_MAC_secret = key_block[0..15]
       server_write_MAC_secret = key_block[16..31]
       client_write_key        = key_block[32..36]
       server_write_key        = key_block[37..41]
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       key_block               = PRF(master_secret,
                                     &#34;key expansion&#34;,
                                     server_random +
                                     client_random)[0..41]
       client_write_MAC_secret = key_block[0..15]
       server_write_MAC_secret = key_block[16..31]
       client_write_key        = key_block[32..36]
       server_write_key        = key_block[37..41]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
final_client_write_key = PRF(client_write_key, &#34;client write key&#34;, client_random + server_random)[0..15] final_server_write_key = PRF(server_write_key, &#34;server write key&#34;, client_random + server_random)[0..15]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
最终客户端写入密钥=PRF（客户端写入密钥，“客户端写入密钥”，客户端随机+服务器随机）[0..15]最终服务器写入密钥=PRF（服务器写入密钥，“服务器写入密钥”，客户端随机+服务器随机）[0..15]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       iv_block                = PRF(&#34;&#34;, &#34;IV block&#34;, client_random +
                                     server_random)[0..15]
       client_write_IV = iv_block[0..7]
       server_write_IV = iv_block[8..15]
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       iv_block                = PRF(&#34;&#34;, &#34;IV block&#34;, client_random +
                                     server_random)[0..15]
       client_write_IV = iv_block[0..7]
       server_write_IV = iv_block[8..15]
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. The TLS Handshake Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. TLS握手协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol consists of a suite of three sub-protocols which are used to allow peers to agree upon security parameters for the record layer, authenticate themselves, instantiate negotiated security parameters, and report error conditions to each other.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS握手协议由一套三个子协议组成，这些协议用于允许对等方就记录层的安全参数达成一致、自我验证、实例化协商的安全参数以及相互报告错误情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Handshake Protocol is responsible for negotiating a session, which consists of the following items:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手协议负责协商会话，会话包括以下各项：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session identifier An arbitrary byte sequence chosen by the server to identify an active or resumable session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话标识符服务器选择的用于标识活动或可恢复会话状态的任意字节序列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer certificate X509v3 [X509] certificate of the peer. This element of the state may be null.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方证书X509v3[X509]对等方的证书。状态的此元素可能为null。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression method The algorithm used to compress data prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩方法加密前用于压缩数据的算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher spec Specifies the bulk data encryption algorithm (such as null, DES, etc.) and a MAC algorithm (such as MD5 or SHA). It also defines cryptographic attributes such as the hash_size. (See Appendix A.6 for formal definition)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher spec指定批量数据加密算法（如null、DES等）和MAC算法（如MD5或SHA）。它还定义加密属性，如哈希值大小。（正式定义见附录A.6）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret 48-byte secret shared between the client and server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主密钥客户端和服务器之间共享的48字节密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is resumable A flag indicating whether the session can be used to initiate new connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
是可恢复的—指示会话是否可用于启动新连接的标志。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These items are then used to create security parameters for use by the Record Layer when protecting application data. Many connections can be instantiated using the same session through the resumption feature of the TLS Handshake Protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，这些项用于创建安全参数，以供记录层在保护应用程序数据时使用。通过TLS握手协议的恢复功能，可以使用同一会话实例化许多连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Change cipher spec protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 更改密码规范协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change cipher spec protocol exists to signal transitions in ciphering strategies. The protocol consists of a single message, which is encrypted and compressed under the current (not the pending) connection state. The message consists of a single byte of value 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
change cipher spec协议存在于加密策略的信号转换中。该协议由单个消息组成，在当前（而不是挂起）连接状态下对其进行加密和压缩。该消息由值为1的单个字节组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           enum { change_cipher_spec(1), (255) } type;
       } ChangeCipherSpec;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           enum { change_cipher_spec(1), (255) } type;
       } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The change cipher spec message is sent by both the client and server to notify the receiving party that subsequent records will be protected under the newly negotiated CipherSpec and keys. Reception of this message causes the receiver to instruct the Record Layer to immediately copy the read pending state into the read current state. Immediately after sending this message, the sender should instruct the record layer to make the write pending state the write active state. (See section 6.1.) The change cipher spec message is sent during the handshake after the security parameters have been agreed upon, but before the verifying finished message is sent (see section 7.4.9).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更改密码规范消息由客户端和服务器发送，以通知接收方后续记录将受到新协商的密码规范和密钥的保护。接收到该消息后，接收器指示记录层立即将读取挂起状态复制到读取当前状态。发送此消息后，发送方应立即指示记录层将写挂起状态设置为写活动状态。（见第6.1节。）更改密码规范消息在安全参数商定后的握手过程中发送，但在发送验证完成消息之前发送（见第7.4.9节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Alert protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 警报协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the content types supported by the TLS Record layer is the alert type. Alert messages convey the severity of the message and a description of the alert. Alert messages with a level of fatal result in the immediate termination of the connection. In this case, other connections corresponding to the session may continue, but the session identifier must be invalidated, preventing the failed session from being used to establish new connections. Like other messages, alert messages are encrypted and compressed, as specified by the current connection state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS记录层支持的内容类型之一是警报类型。警报消息传达消息的严重性和警报的说明。具有致命级别的警报消息会导致连接立即终止。在这种情况下，与会话相对应的其他连接可能会继续，但会话标识符必须无效，以防止失败的会话用于建立新连接。与其他消息一样，警报消息按照当前连接状态进行加密和压缩。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum {
           close_notify(0),
           unexpected_message(10),
           bad_record_mac(20),
           decryption_failed(21),
           record_overflow(22),
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum {
           close_notify(0),
           unexpected_message(10),
           bad_record_mac(20),
           decryption_failed(21),
           record_overflow(22),
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
 decompression_failure(30), handshake_failure(40), bad_certificate(42), unsupported_certificate(43), certificate_revoked(44), certificate_expired(45), certificate_unknown(46), illegal_parameter(47), unknown_ca(48), access_denied(49), decode_error(50), decrypt_error(51), export_restriction(60), protocol_version(70), insufficient_security(71), internal_error(80), user_canceled(90), no_renegotiation(100), (255) } AlertDescription;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
解压\u失败（30）、握手\u失败（40）、坏\u证书（42）、不支持的\u证书（43）、证书\u吊销（44）、证书\u过期（45）、证书\u未知（46）、非法\u参数（47）、未知\u ca（48）、拒绝访问\u（49）、解码\u错误（50）、解密\u错误（51）、导出\u限制（60）、协议\u版本（70）、安全性不足（71），内部错误（80），用户取消（90），无重新协商（100），（255）}警报说明；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           AlertLevel level;
           AlertDescription description;
       } Alert;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           AlertLevel level;
           AlertDescription description;
       } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. Closure alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. 关闭警报
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client and the server must share knowledge that the connection is ending in order to avoid a truncation attack. Either party may initiate the exchange of closing messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端和服务器必须共享连接即将结束的知识，以避免截断攻击。任何一方均可发起交易结束信息的交换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
close_notify This message notifies the recipient that the sender will not send any more messages on this connection. The session becomes unresumable if any connection is terminated without proper close_notify messages with level equal to warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
close_notify此邮件通知收件人发件人将不再在此连接上发送任何邮件。如果任何连接在未正确关闭的情况下终止，会话将变得不可恢复。通知级别等于警告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Either party may initiate a close by sending a close_notify alert. Any data received after a closure alert is ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任何一方均可通过发送关闭通知警报启动关闭。关闭警报后收到的任何数据都将被忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each party is required to send a close_notify alert before closing the write side of the connection. It is required that the other party respond with a close_notify alert of its own and close down the connection immediately, discarding any pending writes. It is not required for the initiator of the close to wait for the responding close_notify alert before closing the read side of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在关闭连接的写入端之前，要求各方发送close_notify警报。要求另一方响应其自身的close_notify警报，并立即关闭连接，丢弃任何挂起的写入。关闭的发起人不需要在关闭连接的读取端之前等待响应的关闭通知警报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the application protocol using TLS provides that any data may be carried over the underlying transport after the TLS connection is closed, the TLS implementation must receive the responding close_notify alert before indicating to the application layer that the TLS connection has ended. If the application protocol will not transfer any additional data, but will only close the underlying transport connection, then the implementation may choose to close the transport without waiting for the responding close_notify. No part of this standard should be taken to dictate the manner in which a usage profile for TLS manages its data transport, including when connections are opened or closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用TLS的应用程序协议规定，在TLS连接关闭后，任何数据都可能通过底层传输传输，则TLS实现必须在向应用程序层指示TLS连接已结束之前接收响应的close_notify警报。如果应用程序协议不会传输任何附加数据，而只会关闭底层传输连接，则实现可以选择关闭传输，而不等待响应的关闭通知。本标准的任何部分都不应规定TLS使用概要文件管理其数据传输的方式，包括连接打开或关闭时的方式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NB: It is assumed that closing a connection reliably delivers pending data before destroying the transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：假设在破坏传输之前，关闭连接可以可靠地传递挂起的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. Error alerts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. 错误警报
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error handling in the TLS Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Upon transmission or receipt of an fatal alert message, both parties immediately close the connection. Servers and clients are required to forget any session-identifiers, keys, and secrets associated with a failed connection. The following error alerts are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS握手协议中的错误处理非常简单。当检测到错误时，检测方向另一方发送消息。在传输或接收到致命警报消息后，双方立即关闭连接。服务器和客户端需要忘记与失败连接相关的任何会话标识符、密钥和机密。定义了以下错误警报：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unexpected_message An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
意外消息收到不适当的消息。此警报始终是致命的，在正确实现之间的通信中不应出现此警报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_record_mac This alert is returned if a record is received with an incorrect MAC. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u记录\u mac如果接收到带有错误mac的记录，将返回此警报。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decryption_failed A TLSCiphertext decrypted in an invalid way: either it wasn`t an even multiple of the block length or its padding values, when checked, weren`t correct. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解密失败。TLSCiphertext以无效方式解密：要么不是块长度的偶数倍，要么其填充值在选中时不正确。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
record_overflow A TLSCiphertext record was received which had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
记录溢出收到长度超过2^14+2048字节的TLSCiphertext记录，或解密为长度超过2^14+1024字节的TLSCompressed记录。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decompression_failure The decompression function received improper input (e.g. data that would expand to excessive length). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解压失败解压功能接收到不正确的输入（例如，数据会扩展到过长）。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
handshake_failure Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手失败接收到握手失败警报消息表明，在提供可用选项的情况下，发送方无法协商一组可接受的安全参数。这是一个致命的错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_certificate A certificate was corrupt, contained signatures that did not verify correctly, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
坏证书证书证书已损坏，包含未正确验证的签名等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unsupported_certificate A certificate was of an unsupported type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不受支持的\u证书证书的类型不受支持。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_revoked A certificate was revoked by its signer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书\u已吊销证书的签名者已吊销证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_expired A certificate has expired or is not currently valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书\u过期证书已过期或当前无效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_unknown Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书\u未知处理证书时出现其他一些（未指定）问题，使其无法接受。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
illegal_parameter A field in the handshake was out of range or inconsistent with other fields. This is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非法参数握手中的字段超出范围或与其他字段不一致。这总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
unknown_ca A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn`t be matched with a known, trusted CA. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未知\u ca收到有效的证书链或部分链，但证书未被接受，因为找不到ca证书或无法与已知的受信任ca匹配。此消息始终是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access_denied A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拒绝访问收到有效证书，但当应用访问控制时，发件人决定不继续协商。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decode_error A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解码\错误无法解码消息，因为某些字段超出指定范围或消息长度不正确。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
decrypt_error A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解密错误握手加密操作失败，包括无法正确验证签名、解密密钥交换或验证完成的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
export_restriction A negotiation not in compliance with export restrictions was detected; for example, attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出口限制检测到不符合出口限制的谈判；例如，尝试为RSA_导出握手方法传输1024位临时RSA密钥。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
protocol_version The protocol version the client has attempted to negotiate is recognized, but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
协议\u版本客户端尝试协商的协议版本已被识别，但不受支持。（例如，出于安全原因，可以避免使用旧的协议版本）。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
insufficient_security Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当协商失败时，返回的\u安全性不足，而不是握手\u失败，特别是因为服务器需要比客户端支持的密码更安全的密码。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
internal_error An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue (such as a memory allocation failure). This message is always fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
内部错误与对等方或协议正确性无关的内部错误使其无法继续（如内存分配失败）。这个消息总是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
user_canceled This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户_已取消此握手由于与协议故障无关的原因而被取消。如果用户在握手完成后取消操作，则只需发送关闭通知来关闭连接就更合适了。此警报后应发出关闭通知。此消息通常是一个警告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no_renegotiation Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert; at that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate would be where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始握手后，客户端响应hello请求或服务器响应客户端hello时不发送重新协商。其中任何一项通常都会导致重新谈判；如果不合适，接收者应发出此警报；此时，原始请求者可以决定是否继续连接。一种情况是，服务器产生了一个进程来满足请求；进程在启动时可能会收到安全参数（密钥长度、身份验证等），在该点之后可能很难传达对这些参数的更改。此消息始终是一个警告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all errors where an alert level is not explicitly specified, the sending party may determine at its discretion whether this is a fatal error or not; if an alert with a level of warning is received, the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于未明确规定警报级别的所有错误，发送方可自行决定这是否为致命错误；如果收到警告级别的警报，则
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
receiving party may decide at its discretion whether to treat this as a fatal error or not. However, all messages which are transmitted with a level of fatal must be treated as fatal messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收方可自行决定是否将其视为致命错误。但是，以致命级别传输的所有消息必须视为致命消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Handshake Protocol overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 握手协议概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The cryptographic parameters of the session state are produced by the TLS Handshake Protocol, which operates on top of the TLS Record Layer. When a TLS client and server first start communicating, they agree on a protocol version, select cryptographic algorithms, optionally authenticate each other, and use public-key encryption techniques to generate shared secrets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话状态的加密参数由TLS握手协议生成，该协议在TLS记录层上运行。当TLS客户机和服务器第一次开始通信时，它们就协议版本达成一致，选择加密算法，选择性地相互验证，并使用公钥加密技术生成共享机密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol involves the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS握手协议包括以下步骤：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Exchange hello messages to agree on algorithms, exchange random values, and check for session resumption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 交换hello消息以同意算法、交换随机值并检查会话恢复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Exchange the necessary cryptographic parameters to allow the client and server to agree on a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 交换必要的加密参数，以允许客户端和服务器就主密钥达成一致。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Exchange certificates and cryptographic information to allow the client and server to authenticate themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 交换证书和加密信息以允许客户端和服务器进行自身身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Generate a master secret from the premaster secret and exchanged random values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 从主密钥和交换的随机值生成主密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Provide security parameters to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 向记录层提供安全参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- Allow the client and server to verify that their peer has calculated the same security parameters and that the handshake occurred without tampering by an attacker.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
- 允许客户端和服务器验证其对等方是否计算了相同的安全参数，以及握手是否在未被攻击者篡改的情况下发生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that higher layers should not be overly reliant on TLS always negotiating the strongest possible connection between two peers: there are a number of ways a man in the middle attacker can attempt to make two entities drop down to the least secure method they support. The protocol has been designed to minimize this risk, but there are still attacks available: for example, an attacker could block access to the port a secure service runs on, or attempt to get the peers to negotiate an unauthenticated connection. The fundamental rule is that higher levels must be cognizant of what their security requirements are and never transmit information over a channel less secure than what they require. The TLS protocol is secure, in that any cipher suite offers its promised level of security: if you negotiate 3DES with a 1024 bit RSA key exchange with a host whose certificate you have verified, you can expect to be that secure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，高层不应该过分依赖TLS，总是在两个对等体之间协商最强的可能连接：中间攻击者可以尝试使两个实体下降到它们支持的最不安全的方法。该协议旨在将此风险降至最低，但仍然存在可用的攻击：例如，攻击者可能会阻止对运行安全服务的端口的访问，或试图让对等方协商未经验证的连接。基本规则是，更高级别的人员必须了解他们的安全要求是什么，并且决不能通过低于他们要求的安全性的通道传输信息。TLS协议是安全的，因为任何密码套件都提供其承诺的安全级别：如果您与已验证其证书的主机协商使用1024位RSA密钥交换的3DE，那么您可以期望是安全的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, you should never send data over a link encrypted with 40 bit security unless you feel that data is worth no more than the effort required to break that encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
但是，除非您认为数据的价值不超过破坏该加密所需的努力，否则决不应通过使用40位安全性加密的链接发送数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These goals are achieved by the handshake protocol, which can be summarized as follows: The client sends a client hello message to which the server must respond with a server hello message, or else a fatal error will occur and the connection will fail. The client hello and server hello are used to establish security enhancement capabilities between client and server. The client hello and server hello establish the following attributes: Protocol Version, Session ID, Cipher Suite, and Compression Method. Additionally, two random values are generated and exchanged: ClientHello.random and ServerHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些目标是通过握手协议实现的，握手协议可以概括如下：客户端发送客户端hello消息，服务器必须用服务器hello消息响应该消息，否则将发生致命错误，连接将失败。客户端hello和服务器hello用于在客户端和服务器之间建立安全增强功能。客户端hello和服务器hello建立以下属性：协议版本、会话ID、密码套件和压缩方法。此外，还会生成并交换两个随机值：ClientHello.random和ServerHello.random。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The actual key exchange uses up to four messages: the server certificate, the server key exchange, the client certificate, and the client key exchange. New key exchange methods can be created by specifying a format for these messages and defining the use of the messages to allow the client and server to agree upon a shared secret. This secret should be quite long; currently defined key exchange methods exchange secrets which range from 48 to 128 bytes in length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实际的密钥交换最多使用四条消息：服务器证书、服务器密钥交换、客户端证书和客户端密钥交换。可以通过为这些消息指定格式并定义消息的使用来创建新的密钥交换方法，以允许客户端和服务器就共享密钥达成一致。这个秘密应该很长；当前定义的密钥交换方法交换长度为48到128字节的秘密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following the hello messages, the server will send its certificate, if it is to be authenticated. Additionally, a server key exchange message may be sent, if it is required (e.g. if their server has no certificate, or if its certificate is for signing only). If the server is authenticated, it may request a certificate from the client, if that is appropriate to the cipher suite selected. Now the server will send the server hello done message, indicating that the hello-message phase of the handshake is complete. The server will then wait for a client response. If the server has sent a certificate request message, the client must send the certificate message. The client key exchange message is now sent, and the content of that message will depend on the public key algorithm selected between the client hello and the server hello. If the client has sent a certificate with signing ability, a digitally-signed certificate verify message is sent to explicitly verify the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在hello消息之后，服务器将发送其证书（如果要对其进行身份验证）。此外，如果需要，可以发送服务器密钥交换消息（例如，如果其服务器没有证书，或者其证书仅用于签名）。如果服务器经过身份验证，它可能会从客户端请求证书（如果该证书适用于所选的密码套件）。现在，服务器将发送服务器hello done消息，指示握手的hello消息阶段已完成。然后，服务器将等待客户端响应。如果服务器已发送证书请求消息，则客户端必须发送证书消息。现在发送客户机密钥交换消息，该消息的内容将取决于在客户机hello和服务器hello之间选择的公钥算法。如果客户端已发送具有签名功能的证书，则会发送数字签名证书验证消息以显式验证证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At this point, a change cipher spec message is sent by the client, and the client copies the pending Cipher Spec into the current Cipher Spec. The client then immediately sends the finished message under the new algorithms, keys, and secrets. In response, the server will send its own change cipher spec message, transfer the pending to the current Cipher Spec, and send its finished message under the new
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此时，客户机将发送更改密码规范消息，并将挂起的密码规范复制到当前密码规范中。然后，客户机立即根据新算法、密钥和机密发送完成的消息。作为响应，服务器将发送其自己的更改密码规范消息，将挂起的密码规范传输到当前密码规范，并在新密码规范下发送其完成的消息
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cipher Spec. At this point, the handshake is complete and the client and server may begin to exchange application layer data. (See flow chart below.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密码规范。此时，握手完成，客户端和服务器可能开始交换应用层数据。（见下面的流程图。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
客户端服务器
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ClientHello                  --------&gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ClientHello                  --------&gt;
                                                      ServerHello
                                                     Certificate*
                                               ServerKeyExchange*
                                              CertificateRequest*
                                   &lt;--------      ServerHelloDone
      Certificate*
      ClientKeyExchange
      CertificateVerify*
      [ChangeCipherSpec]
      Finished                     --------&gt;
                                               [ChangeCipherSpec]
                                   &lt;--------             Finished
      Application Data             &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
Fig. 1 - Message flow for a full handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
图1-完整握手的消息流
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Indicates optional or situation-dependent messages that are not always sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 指示并非始终发送的可选消息或情况相关消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
Note: To help avoid pipeline stalls, ChangeCipherSpec is an independent TLS Protocol content type, and is not actually a TLS handshake message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-2">
注意：为了帮助避免管道暂停，ChangeCipherSpec是一种独立的TLS协议内容类型，实际上不是TLS握手消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the client and server decide to resume a previous session or duplicate an existing session (instead of negotiating new security parameters) the message flow is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当客户端和服务器决定恢复以前的会话或复制现有会话（而不是协商新的安全参数）时，消息流如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client sends a ClientHello using the Session ID of the session to be resumed. The server then checks its session cache for a match. If a match is found, and the server is willing to re-establish the connection under the specified session state, it will send a ServerHello with the same Session ID value. At this point, both client and server must send change cipher spec messages and proceed directly to finished messages. Once the re-establishment is complete, the client and server may begin to exchange application layer data. (See flow chart below.) If a Session ID match is not found, the server generates a new session ID and the TLS client and server perform a full handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端使用要恢复的会话的会话ID发送ClientHello。然后服务器检查其会话缓存是否匹配。如果找到匹配项，并且服务器愿意在指定的会话状态下重新建立连接，它将发送具有相同会话ID值的ServerHello。此时，客户端和服务器都必须发送更改密码规范消息，并直接处理完成的消息。一旦重建完成，客户端和服务器就可以开始交换应用层数据。（请参阅下面的流程图。）如果找不到会话ID匹配，服务器将生成新的会话ID，TLS客户端和服务器将执行完全握手。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Client Server
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
客户端服务器
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ClientHello                   --------&gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&gt;
      Application Data              &lt;-------&gt;     Application Data
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ClientHello                   --------&gt;
                                                       ServerHello
                                                [ChangeCipherSpec]
                                    &lt;--------             Finished
      [ChangeCipherSpec]
      Finished                      --------&gt;
      Application Data              &lt;-------&gt;     Application Data
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Fig. 2 - Message flow for an abbreviated handshake
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
图2-简短握手的消息流
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents and significance of each message will be presented in detail in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下各节将详细介绍每条信息的内容和意义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 握手协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS Handshake Protocol is one of the defined higher level clients of the TLS Record Protocol. This protocol is used to negotiate the secure attributes of a session. Handshake messages are supplied to the TLS Record Layer, where they are encapsulated within one or more TLSPlaintext structures, which are processed and transmitted as specified by the current active session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS握手协议是TLS记录协议定义的更高级别客户端之一。此协议用于协商会话的安全属性。握手消息被提供给TLS记录层，在TLS记录层中，它们被封装在一个或多个TLSPlaintext结构中，并按照当前活动会话状态的指定进行处理和传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum {
           hello_request(0), client_hello(1), server_hello(2),
           certificate(11), server_key_exchange (12),
           certificate_request(13), server_hello_done(14),
           certificate_verify(15), client_key_exchange(16),
           finished(20), (255)
       } HandshakeType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum {
           hello_request(0), client_hello(1), server_hello(2),
           certificate(11), server_key_exchange (12),
           certificate_request(13), server_hello_done(14),
           certificate_verify(15), client_key_exchange(16),
           finished(20), (255)
       } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           HandshakeType msg_type;    /* handshake type */
           uint24 length;             /* bytes in message */
           select (HandshakeType) {
               case hello_request:       HelloRequest;
               case client_hello:        ClientHello;
               case server_hello:        ServerHello;
               case certificate:         Certificate;
               case server_key_exchange: ServerKeyExchange;
               case certificate_request: CertificateRequest;
               case server_hello_done:   ServerHelloDone;
               case certificate_verify:  CertificateVerify;
               case client_key_exchange: ClientKeyExchange;
               case finished:            Finished;
           } body;
       } Handshake;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           HandshakeType msg_type;    /* handshake type */
           uint24 length;             /* bytes in message */
           select (HandshakeType) {
               case hello_request:       HelloRequest;
               case client_hello:        ClientHello;
               case server_hello:        ServerHello;
               case certificate:         Certificate;
               case server_key_exchange: ServerKeyExchange;
               case certificate_request: CertificateRequest;
               case server_hello_done:   ServerHelloDone;
               case certificate_verify:  CertificateVerify;
               case client_key_exchange: ClientKeyExchange;
               case finished:            Finished;
           } body;
       } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake protocol messages are presented below in the order they must be sent; sending handshake messages in an unexpected order results in a fatal error. Unneeded handshake messages can be omitted, however. Note one exception to the ordering: the Certificate message is used twice in the handshake (from server to client, then from client to server), but described only in its first position. The one message which is not bound by these ordering rules in the Hello Request message, which can be sent at any time, but which should be ignored by the client if it arrives in the middle of a handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手协议消息按其必须发送的顺序显示在下面；以意外顺序发送握手消息会导致致命错误。然而，不需要的握手信息可以省略。注意排序的一个例外：证书消息在握手中使用了两次（从服务器到客户端，然后从客户端到服务器），但仅在第一个位置进行描述。在Hello请求消息中不受这些排序规则约束的一条消息，该消息可以在任何时间发送，但是如果客户端到达握手的中间，该消息应该被客户端忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Hello messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. 你好消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hello phase messages are used to exchange security enhancement capabilities between the client and server. When a new session begins, the Record Layer&#39;s connection state encryption, hash, and compression algorithms are initialized to null. The current connection state is used for renegotiation messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hello阶段消息用于在客户端和服务器之间交换安全增强功能。当新会话开始时，记录层的连接状态加密、哈希和压缩算法将初始化为null。当前连接状态用于重新协商消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. Hello request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. 你好请求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The hello request message may be sent by the server at any time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送此消息的时间：服务器可随时发送hello请求消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: Hello request is a simple notification that the client should begin the negotiation process anew by sending a client hello message when convenient. This message will be ignored by the client if the client is currently negotiating a session. This message may be ignored by the client if it does not wish to renegotiate a session, or the client may, if it wishes, respond with a no_renegotiation alert. Since handshake messages are intended to have transmission precedence over application data, it is expected that the negotiation will begin before no more than a few records are received from the client. If the server sends a hello request but does not receive a client hello in response, it may close the connection with a fatal alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：Hello request是一个简单的通知，客户机应在方便时通过发送客户机Hello消息重新开始协商过程。如果客户端当前正在协商会话，则客户端将忽略此消息。如果客户端不希望重新协商会话，则可能会忽略此消息，或者如果客户端愿意，可能会以“无重新协商”警报进行响应。由于握手消息的传输优先于应用程序数据，因此在从客户端接收到不超过几个记录之前，协商将开始。如果服务器发送hello请求但未收到客户机hello响应，则可能会通过致命警报关闭连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending a hello request, servers should not repeat the request until the subsequent handshake negotiation is complete.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送hello请求后，服务器不应重复该请求，直到后续握手协商完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct { } HelloRequest;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: This message should never be included in the message hashes which are maintained throughout the handshake and used in the finished messages and the certificate verify message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：此消息不应包含在整个握手过程中维护的消息哈希中，并在完成的消息和证书验证消息中使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. Client hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. 客户你好
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: When a client first connects to a server it is required to send the client hello as its first message. The client can also send a client hello in response to a hello request or on its own initiative in order to renegotiate the security parameters in an existing connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何时发送此消息：当客户端首次连接到服务器时，需要将客户端hello作为其第一条消息发送。客户机还可以发送客户机hello以响应hello请求，或者主动发送，以便在现有连接中重新协商安全参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Structure of this message: The client hello message includes a random structure, which is used later in the protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
此消息的结构：客户端hello消息包含一个随机结构，稍后在协议中使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           struct {
              uint32 gmt_unix_time;
              opaque random_bytes[28];
           } Random;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           struct {
              uint32 gmt_unix_time;
              opaque random_bytes[28];
           } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
gmt_unix_time The current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, GMT) according to the sender&#39;s internal clock. Clocks are not required to be set correctly by the basic TLS Protocol; higher level or application protocols may define additional requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
gmt_unix_time根据发送方的内部时钟，以标准unix 32位格式（自1970年1月1日午夜开始的秒数，gmt）显示当前时间和日期。基本TLS协议不要求正确设置时钟；更高级别或应用程序协议可能会定义附加要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random_bytes 28 bytes generated by a secure random number generator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
随机字节由安全随机数生成器生成的28个字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client hello message includes a variable length session identifier. If not empty, the value identifies a session between the same client and server whose security parameters the client wishes to reuse. The session identifier may be from an earlier connection, this connection, or another currently active connection. The second option is useful if the client only wishes to update the random structures and derived values of a connection, while the third option makes it possible to establish several independent secure connections without repeating the full handshake protocol. These independent connections may occur sequentially or simultaneously; a SessionID becomes valid when the handshake negotiating it completes with the exchange of Finished messages and persists until removed due to aging or because a fatal error was encountered on a connection associated with the session. The actual contents of the SessionID are defined by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户机hello消息包括一个可变长度的会话标识符。如果不为空，则该值标识同一客户端和服务器之间的会话，客户端希望重用其安全参数。会话标识符可以来自较早的连接、此连接或另一个当前活动的连接。如果客户机只希望更新连接的随机结构和派生值，则第二个选项很有用，而第三个选项可以在不重复完整握手协议的情况下建立多个独立的安全连接。这些独立的连接可以连续或同时发生；当握手协商完成并交换完成的消息时，SessionID将变为有效，并持续存在，直到由于老化或与会话关联的连接上遇到致命错误而被删除。SessionID的实际内容由服务器定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque SessionID&lt;0..32&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque SessionID&lt;0..32&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Warning: Because the SessionID is transmitted without encryption or immediate MAC protection, servers must not place confidential information in session identifiers or let the contents of fake session identifiers cause any breach of security. (Note that the content of the handshake as a whole, including the SessionID, is protected by the Finished messages exchanged at the end of the handshake.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
警告：由于SessionID是在没有加密或立即MAC保护的情况下传输的，因此服务器不得在会话标识符中放置机密信息，也不得让虚假会话标识符的内容造成任何安全漏洞。（请注意，整个握手的内容（包括SessionID）受握手结束时交换的完成消息的保护。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CipherSuite list, passed from the client to the server in the client hello message, contains the combinations of cryptographic algorithms supported by the client in order of the client&#39;s preference (favorite choice first). Each CipherSuite defines a key exchange algorithm, a bulk encryption algorithm (including secret key length) and a MAC algorithm. The server will select a cipher suite or, if no acceptable choices are presented, return a handshake failure alert and close the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
CipherSuite列表在客户机hello消息中从客户机传递到服务器，包含客户机支持的加密算法组合，按客户机的首选项顺序排列（首选项优先）。每个密码套件定义一个密钥交换算法、一个批量加密算法（包括密钥长度）和一个MAC算法。服务器将选择密码套件，如果没有可接受的选项，则返回握手失败警报并关闭连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uint8 CipherSuite[2];    /* Cryptographic suite selector */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       uint8 CipherSuite[2];    /* Cryptographic suite selector */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client hello includes a list of compression algorithms supported by the client, ordered according to the client&#39;s preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户机hello包括客户机支持的压缩算法列表，根据客户机的偏好排序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ProtocolVersion client_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suites&lt;2..2^16-1&gt;;
           CompressionMethod compression_methods&lt;1..2^8-1&gt;;
       } ClientHello;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ProtocolVersion client_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suites&lt;2..2^16-1&gt;;
           CompressionMethod compression_methods&lt;1..2^8-1&gt;;
       } ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client_version The version of the TLS protocol by which the client wishes to communicate during this session. This should be the latest (highest valued) version supported by the client. For this version of the specification, the version will be 3.1 (See Appendix E for details about backward compatibility).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端版本客户端希望在此会话期间通信的TLS协议版本。这应该是客户端支持的最新（最高值）版本。对于本规范版本，版本为3.1（有关向后兼容性的详细信息，请参见附录E）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random A client-generated random structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
随机客户端生成的随机结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id The ID of a session the client wishes to use for this connection. This field should be empty if no session_id is available or the client wishes to generate new security parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话\u id客户端希望用于此连接的会话的id。如果没有可用的会话id或客户端希望生成新的安全参数，则此字段应为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suites This is a list of the cryptographic options supported by the client, with the client&#39;s first preference first. If the session_id field is not empty (implying a session resumption request) this vector must include at least the cipher_suite from that session. Values are defined in Appendix A.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suites这是客户机支持的加密选项列表，首先是客户机的首选项。如果会话id字段不为空（意味着会话恢复请求），则此向量必须至少包含该会话的密码套件。数值在附录A.5中定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_methods This is a list of the compression methods supported by the client, sorted by client preference. If the session_id field is not empty (implying a session resumption request) it must include the compression_method from that session. This vector must contain, and all implementations must support, CompressionMethod.null. Thus, a client and server will always be able to agree on a compression method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩方法这是客户机支持的压缩方法列表，按客户机首选项排序。如果session_id字段不是空的（意味着会话恢复请求），它必须包含来自该会话的compression_方法。此向量必须包含并且所有实现都必须支持CompressionMethod.null。因此，客户机和服务器始终能够就压缩方法达成一致。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After sending the client hello message, the client waits for a server hello message. Any other handshake message returned by the server except for a hello request is treated as a fatal error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送客户机hello消息后，客户机等待服务器hello消息。服务器返回的任何其他握手消息（hello请求除外）都被视为致命错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forward compatibility note: In the interests of forward compatibility, it is permitted for a client hello message to include extra data after the compression methods. This data must be included in the handshake hashes, but must otherwise be ignored. This is the only handshake message for which this is legal; for all other messages, the amount of data in the message must match the description of the message precisely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前向兼容性注意：为了前向兼容性，允许客户端hello消息在压缩方法之后包含额外数据。此数据必须包含在握手哈希中，否则必须忽略。这是唯一合法的握手信息；对于所有其他消息，消息中的数据量必须与消息的描述精确匹配。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. Server hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. 服务器你好
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The server will send this message in response to a client hello message when it was able to find an acceptable set of algorithms. If it cannot find such a match, it will respond with a handshake failure alert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何时发送此消息：当服务器能够找到一组可接受的算法时，它将发送此消息以响应客户机hello消息。如果找不到这样的匹配项，它将发出握手失败警报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
           ProtocolVersion server_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suite;
           CompressionMethod compression_method;
       } ServerHello;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
           ProtocolVersion server_version;
           Random random;
           SessionID session_id;
           CipherSuite cipher_suite;
           CompressionMethod compression_method;
       } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server_version This field will contain the lower of that suggested by the client in the client hello and the highest supported by the server. For this version of the specification, the version is 3.1 (See Appendix E for details about backward compatibility).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
服务器版本此字段将包含客户端hello中客户端建议的较低版本和服务器支持的最高版本。对于本规范版本，版本为3.1（有关向后兼容性的详细信息，请参见附录E）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random This structure is generated by the server and must be different from (and independent of) ClientHello.random.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
random此结构由服务器生成，必须与ClientHello.random不同（且独立于ClientHello.random）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id This is the identity of the session corresponding to this connection. If the ClientHello.session_id was non-empty, the server will look in its session cache for a match. If a match is found and the server is willing to establish the new connection using the specified session state, the server will respond with the same value as was supplied by the client. This indicates a resumed session and dictates that the parties must proceed directly to the finished messages. Otherwise this field will contain a different value identifying the new session. The server may return an empty session_id to indicate that the session will not be cached and therefore cannot be resumed. If a session is resumed, it must be resumed using the same cipher suite it was originally negotiated with.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话\u id这是与此连接对应的会话的标识。如果ClientHello.session_id非空，服务器将在其会话缓存中查找匹配项。如果找到匹配项，并且服务器愿意使用指定的会话状态建立新连接，则服务器将使用客户端提供的相同值进行响应。这表示会话已恢复，并指示各方必须直接进入已完成的消息。否则，此字段将包含标识新会话的不同值。服务器可能会返回一个空会话id，以指示该会话不会被缓存，因此无法恢复。如果会话恢复，则必须使用最初与之协商的密码套件恢复会话。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suite The single cipher suite selected by the server from the list in ClientHello.cipher_suites. For resumed sessions this field is the value from the state of the session being resumed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_suite服务器从ClientHello.cipher_suite中的列表中选择的单个密码套件。对于恢复的会话，此字段是正在恢复的会话状态的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compression_method The single compression algorithm selected by the server from the list in ClientHello.compression_methods. For resumed sessions this field is the value from the resumed session state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩方法服务器从ClientHello.compression\u方法列表中选择的单一压缩算法。对于恢复的会话，此字段是恢复的会话状态的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Server certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. 服务器证书
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The server must send a certificate whenever the agreed-upon key exchange method is not an anonymous one. This message will always immediately follow the server hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何时发送此消息：只要商定的密钥交换方法不是匿名方法，服务器就必须发送证书。此消息将始终紧跟在服务器hello消息之后。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: The certificate type must be appropriate for the selected cipher suite&#39;s key exchange algorithm, and is generally an X.509v3 certificate. It must contain a key which matches the key exchange method, as follows. Unless otherwise specified, the signing
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：证书类型必须适合所选密码套件的密钥交换算法，并且通常是X.509v3证书。它必须包含与密钥交换方法匹配的密钥，如下所示。除非另有规定，否则签署
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
algorithm for the certificate must be the same as the algorithm for the certificate key. Unless otherwise specified, the public key may be of any length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
证书的算法必须与证书密钥的算法相同。除非另有规定，公钥可以是任意长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Key Exchange Algorithm Certificate Key Type
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
密钥交换算法证书密钥类型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA RSA public key; the certificate must allow the key to be used for encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA公钥；证书必须允许密钥用于加密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA_EXPORT RSA public key of length greater than 512 bits which can be used for signing, or a key of 512 bits or shorter which can be used for either encryption or signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
RSA_导出长度大于512位的RSA公钥（可用于签名），或长度小于等于512位的密钥（可用于加密或签名）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS DSS public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS DSS公钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS_EXPORT DSS public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_DSS_导出DSS公钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA RSA public key which can be used for signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA公钥，可用于签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA_EXPORT RSA public key which can be used for signing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DHE_RSA_导出可用于签名的RSA公钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_DSS Diffie-Hellman key. The algorithm used to sign the certificate should be DSS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_DSS Diffie Hellman密钥。用于签署证书的算法应为DSS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_RSA Diffie-Hellman key. The algorithm used to sign the certificate should be RSA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
DH_RSA Diffie-Hellman密钥。用于签署证书的算法应为RSA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All certificate profiles, key and cryptographic formats are defined by the IETF PKIX working group [PKIX]. When a key usage extension is present, the digitalSignature bit must be set for the key to be eligible for signing, as described above, and the keyEncipherment bit must be present to allow encryption, as described above. The keyAgreement bit must be set on Diffie-Hellman certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有证书配置文件、密钥和加密格式由IETF PKIX工作组[PKIX]定义。当存在密钥使用扩展时，如上所述，必须设置数字签名位以使密钥符合签名条件，并且如上所述，必须存在密钥加密位以允许加密。必须在Diffie-Hellman证书上设置keyAgreement位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As CipherSuites which specify new key exchange methods are specified for the TLS Protocol, they will imply certificate format and the required encoded keying information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于为TLS协议指定了指定新密钥交换方法的密码套件，它们将暗示证书格式和所需的编码密钥信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       opaque ASN.1Cert&lt;1..2^24-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       opaque ASN.1Cert&lt;1..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
       } Certificate;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ASN.1Cert certificate_list&lt;0..2^24-1&gt;;
       } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate_list This is a sequence (chain) of X.509v3 certificates. The sender&#39;s certificate must come first in the list. Each following certificate must directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate which specifies the root certificate authority may optionally be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书列表这是X.509v3证书的序列（链）。发件人的证书必须排在列表的第一位。下列证书必须直接证明其前面的证书。由于证书验证要求独立分发根密钥，因此可以选择从链中省略指定根证书颁发机构的自签名证书，前提是远程端必须已经拥有该证书，以便在任何情况下对其进行验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same message type and structure will be used for the client&#39;s response to a certificate request message. Note that a client may send no certificates if it does not have an appropriate certificate to send in response to the server&#39;s authentication request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端对证书请求消息的响应将使用相同的消息类型和结构。请注意，如果客户端没有响应服务器的身份验证请求而发送的适当证书，则客户端可能不会发送任何证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: PKCS #7 [PKCS7] is not used as the format for the certificate vector because PKCS #6 [PKCS6] extended certificates are not used. Also PKCS #7 defines a SET rather than a SEQUENCE, making the task of parsing the list more difficult.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：PKCS#7[PKCS7]未用作证书向量的格式，因为未使用PKCS#6[PKCS6]扩展证书。PKCS#7还定义了一个集合而不是一个序列，这使得解析列表的任务更加困难。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. Server key exchange message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. 服务器密钥交换消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This message will be sent immediately after the server certificate message (or the server hello message, if this is an anonymous negotiation).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送此消息的时间：此消息将在服务器证书消息（或服务器hello消息，如果这是匿名协商）之后立即发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The server key exchange message is sent by the server only when the server certificate message (if sent) does not contain enough data to allow the client to exchange a premaster secret. This is true for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
服务器密钥交换消息仅在服务器证书消息（如果已发送）包含的数据不足以允许客户端交换premaster机密时由服务器发送。这适用于以下密钥交换方法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA_EXPORT (if the public key in the server certificate is longer than 512 bits) DHE_DSS DHE_DSS_EXPORT DHE_RSA DHE_RSA_EXPORT DH_anon
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA_导出（如果服务器证书中的公钥长度超过512位）DHE_DSS DHE_DSS_导出DHE_RSA DHE_RSA_导出DHU anon
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
It is not legal to send the server key exchange message for the following key exchange methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
为以下密钥交换方法发送服务器密钥交换消息是不合法的：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA RSA_EXPORT (when the public key in the server certificate is less than or equal to 512 bits in length) DH_DSS DH_RSA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
RSA RSA_导出（当服务器证书中的公钥长度小于或等于512位时）DH_DSS DH_RSA
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: This message conveys cryptographic information to allow the client to communicate the premaster secret: either an RSA public key to encrypt the premaster secret with, or a Diffie-Hellman public key with which the client can complete a key exchange (with the result being the premaster secret.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：此消息传递加密信息以允许客户端通信premaster机密：使用RSA公钥加密premaster机密，或使用Diffie-Hellman公钥，客户端可以使用该公钥完成密钥交换（结果为premaster机密）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As additional CipherSuites are defined for TLS which include new key exchange algorithms, the server key exchange message will be sent if and only if the certificate type associated with the key exchange algorithm does not provide enough information for the client to exchange a premaster secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于为包含新密钥交换算法的TLS定义了其他密码套件，因此只有当且仅当与密钥交换算法关联的证书类型没有为客户端提供足够的信息来交换premaster机密时，才会发送服务器密钥交换消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: According to current US export law, RSA moduli larger than 512 bits may not be used for key exchange in software exported from the US. With this message, the larger RSA keys encoded in certificates may be used to sign temporary shorter RSA keys for the RSA_EXPORT key exchange method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：根据美国现行出口法，在从美国出口的软件中，大于512位的RSA模不可用于密钥交换。通过此消息，证书中编码的较大RSA密钥可用于为RSA_导出密钥交换方法的临时较短RSA密钥签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           opaque rsa_modulus&lt;1..2^16-1&gt;;
           opaque rsa_exponent&lt;1..2^16-1&gt;;
       } ServerRSAParams;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           opaque rsa_modulus&lt;1..2^16-1&gt;;
           opaque rsa_exponent&lt;1..2^16-1&gt;;
       } ServerRSAParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_modulus The modulus of the server&#39;s temporary RSA key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_module服务器临时rsa密钥的模数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_exponent The public exponent of the server&#39;s temporary RSA key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
rsa_指数服务器临时rsa密钥的公共指数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           opaque dh_p&lt;1..2^16-1&gt;;
           opaque dh_g&lt;1..2^16-1&gt;;
           opaque dh_Ys&lt;1..2^16-1&gt;;
       } ServerDHParams;     /* Ephemeral DH parameters */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           opaque dh_p&lt;1..2^16-1&gt;;
           opaque dh_g&lt;1..2^16-1&gt;;
           opaque dh_Ys&lt;1..2^16-1&gt;;
       } ServerDHParams;     /* Ephemeral DH parameters */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_p The prime modulus used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_p用于Diffie-Hellman运算的素模。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_g The generator used for the Diffie-Hellman operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_g用于Diffie-Hellman操作的发电机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_Ys The server&#39;s Diffie-Hellman public value (g^X mod p).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_Ys服务器的Diffie-Hellman公共值（g^X mod p）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           select (KeyExchangeAlgorithm) {
               case diffie_hellman:
                   ServerDHParams params;
                   Signature signed_params;
               case rsa:
                   ServerRSAParams params;
                   Signature signed_params;
           };
       } ServerKeyExchange;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           select (KeyExchangeAlgorithm) {
               case diffie_hellman:
                   ServerDHParams params;
                   Signature signed_params;
               case rsa:
                   ServerRSAParams params;
                   Signature signed_params;
           };
       } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
params The server&#39;s key exchange parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
params服务器的密钥交换参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
signed_params For non-anonymous key exchanges, a hash of the corresponding params value, with the signature appropriate to that hash applied.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
非匿名密钥交换的签名参数，对应参数值的散列，并应用与该散列相应的签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       md5_hash
           MD5(ClientHello.random + ServerHello.random + ServerParams);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       md5_hash
           MD5(ClientHello.random + ServerHello.random + ServerParams);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sha_hash
           SHA(ClientHello.random + ServerHello.random + ServerParams);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       sha_hash
           SHA(ClientHello.random + ServerHello.random + ServerParams);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       select (SignatureAlgorithm)
       {   case anonymous: struct { };
           case rsa:
               digitally-signed struct {
                   opaque md5_hash[16];
                   opaque sha_hash[20];
               };
           case dsa:
               digitally-signed struct {
                   opaque sha_hash[20];
               };
       } Signature;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       select (SignatureAlgorithm)
       {   case anonymous: struct { };
           case rsa:
               digitally-signed struct {
                   opaque md5_hash[16];
                   opaque sha_hash[20];
               };
           case dsa:
               digitally-signed struct {
                   opaque sha_hash[20];
               };
       } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. Certificate request
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. 证书申请
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: A non-anonymous server can optionally request a certificate from the client, if appropriate for the selected cipher suite. This message, if sent, will immediately follow the Server Key Exchange message (if it is sent; otherwise, the Server Certificate message).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送此消息的时间：如果适用于所选密码套件，非匿名服务器可以选择从客户端请求证书。此消息如果已发送，将立即跟随服务器密钥交换消息（如果已发送，则跟随服务器证书消息）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       enum {
           rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
           (255)
       } ClientCertificateType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       enum {
           rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
           (255)
       } ClientCertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque DistinguishedName&lt;1..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       opaque DistinguishedName&lt;1..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
           DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
       } CertificateRequest;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
           DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
       } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
certificate_types This field is a list of the types of certificates requested, sorted in order of the server&#39;s preference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
证书类型此字段是请求的证书类型的列表，按服务器的首选项排序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
certificate_authorities A list of the distinguished names of acceptable certificate authorities. These distinguished names may specify a desired distinguished name for a root CA or for a subordinate CA; thus, this message can be used both to describe known roots and a desired authorization space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
证书颁发机构可接受证书颁发机构的可分辨名称列表。这些可分辨名称可以为根CA或从属CA指定所需的可分辨名称；因此，该消息可用于描述已知根和所需的授权空间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: DistinguishedName is derived from [X509].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：DifferentiedName源自[X509]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: It is a fatal handshake_failure alert for an anonymous server to request client identification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：匿名服务器请求客户端标识是一个致命的握手失败警报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. Server hello done
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. 服务器你好，完毕
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: The server hello done message is sent by the server to indicate the end of the server hello and associated messages. After sending this message the server will wait for a client response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送此消息的时间：服务器发送服务器hello done消息以指示服务器hello和相关消息的结束。发送此消息后，服务器将等待客户端响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: This message means that the server is done sending messages to support the key exchange, and the client can proceed with its phase of the key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：此消息表示服务器已完成发送消息以支持密钥交换，客户端可以继续其密钥交换阶段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Upon receipt of the server hello done message the client should verify that the server provided a valid certificate if required and check that the server hello parameters are acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
收到服务器hello done消息后，客户端应验证服务器是否提供了有效的证书（如果需要），并检查服务器hello参数是否可接受。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct { } ServerHelloDone;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6. Client certificate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.6. 客户端证书
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This is the first message the client can send after receiving a server hello done message. This message is only sent if the server requests a certificate. If no suitable certificate is available, the client should send a certificate message containing no certificates. If client authentication is required by the server for the handshake to continue, it may respond with a fatal handshake failure alert. Client certificates are sent using the Certificate structure defined in Section 7.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何时发送此消息：这是客户端在收到服务器hello done消息后可以发送的第一条消息。仅当服务器请求证书时，才会发送此消息。如果没有合适的证书可用，客户端应发送不包含证书的证书消息。如果服务器需要客户端身份验证才能继续握手，它可能会发出致命握手失败警报。使用第7.4.2节中定义的证书结构发送客户端证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: When using a static Diffie-Hellman based key exchange method (DH_DSS or DH_RSA), if client authentication is requested, the Diffie-Hellman group and generator encoded in the client&#39;s certificate must match the server specified Diffie-Hellman parameters if the client&#39;s parameters are to be used for the key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：当使用基于Diffie-Hellman的静态密钥交换方法（DH_DSS或DH_RSA）时，如果请求客户端身份验证，则客户端证书中编码的Diffie-Hellman组和生成器必须与服务器指定的Diffie-Hellman参数匹配（如果客户端的参数用于密钥交换）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7. Client key exchange message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7. 客户端密钥交换消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This message is always sent by the client. It will immediately follow the client certificate message, if it is sent. Otherwise it will be the first message sent by the client after it receives the server hello done message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何时发送此消息：此消息始终由客户端发送。如果发送了客户端证书消息，它将立即跟随该消息。否则，它将是客户端在收到服务器hello done消息后发送的第一条消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: With this message, the premaster secret is set, either though direct transmission of the RSA-encrypted secret, or by the transmission of Diffie-Hellman parameters which will allow each side to agree upon the same premaster secret. When the key exchange method is DH_RSA or DH_DSS, client certification has been requested, and the client was able to respond with a certificate which contained a Diffie-Hellman public key whose parameters (group and generator) matched those specified by the server in its certificate, this message will not contain any data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：通过此消息，可以通过直接传输RSA加密的秘密，或者通过传输Diffie-Hellman参数来设置premaster秘密，这将允许各方同意相同的premaster秘密。当密钥交换方法为DH_RSA或DH_DSS时，已请求客户端证书，并且客户端能够使用包含Diffie-Hellman公钥的证书进行响应，该公钥的参数（组和生成器）与服务器在其证书中指定的参数相匹配，此消息将不包含任何数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Structure of this message: The choice of messages depends on which key exchange method has been selected. See Section 7.4.3 for the KeyExchangeAlgorithm definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的结构：消息的选择取决于选择的密钥交换方法。有关KeyExchangeAlgorithm的定义，请参见第7.4.3节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           select (KeyExchangeAlgorithm) {
               case rsa: EncryptedPreMasterSecret;
               case diffie_hellman: ClientDiffieHellmanPublic;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           select (KeyExchangeAlgorithm) {
               case rsa: EncryptedPreMasterSecret;
               case diffie_hellman: ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           } exchange_keys;
       } ClientKeyExchange;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           } exchange_keys;
       } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1. RSA encrypted premaster secret message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.1. RSA加密的主密钥消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: If RSA is being used for key agreement and authentication, the client generates a 48-byte premaster secret, encrypts it using the public key from the server&#39;s certificate or the temporary RSA key provided in a server key exchange message, and sends the result in an encrypted premaster secret message. This structure is a variant of the client key exchange message, not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：如果RSA用于密钥协商和身份验证，客户端将生成一个48字节的premaster机密，使用服务器证书中的公钥或服务器密钥交换消息中提供的临时RSA密钥对其进行加密，并将结果发送到加密的premaster机密消息中。此结构是客户端密钥交换消息的变体，而不是消息本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
           ProtocolVersion client_version;
           opaque random[46];
       } PreMasterSecret;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
           ProtocolVersion client_version;
           opaque random[46];
       } PreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
client_version The latest (newest) version supported by the client. This is used to detect version roll-back attacks. Upon receiving the premaster secret, the server should check that this value matches the value transmitted by the client in the client hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
客户端版本客户端支持的最新（最新）版本。这用于检测版本回滚攻击。收到premaster机密后，服务器应检查该值是否与客户端hello消息中客户端传输的值匹配。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
random 46 securely-generated random bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
随机生成的随机字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           public-key-encrypted PreMasterSecret pre_master_secret;
       } EncryptedPreMasterSecret;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           public-key-encrypted PreMasterSecret pre_master_secret;
       } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: An attack discovered by Daniel Bleichenbacher [BLEI] can be used to attack a TLS server which is using PKCS#1 encoded RSA. The attack takes advantage of the fact that by failing in different ways, a TLS server can be coerced into revealing whether a particular message, when decrypted, is properly PKCS#1 formatted or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：Daniel Bleichenbacher[BLEI]发现的攻击可用于攻击使用PKCS#1编码RSA的TLS服务器。该攻击利用了这样一个事实，即通过以不同的方式失败，TLS服务器可以被强制显示特定消息在解密时是否正确设置了PKCS#1格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The best way to avoid vulnerability to this attack is to treat incorrectly formatted messages in a manner indistinguishable from correctly formatted RSA blocks. Thus, when it receives an incorrectly formatted RSA block, a server should generate a random 48-byte value and proceed using it as the premaster secret. Thus, the server will act identically whether the received RSA block is correctly encoded or not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
避免此攻击漏洞的最佳方法是以与正确格式化的RSA块无法区分的方式处理格式错误的消息。因此，当服务器收到格式不正确的RSA块时，它应该生成一个随机的48字节值，并继续将其用作premaster机密。因此，无论接收到的RSA块是否正确编码，服务器都将以相同的方式工作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
pre_master_secret This random value is generated by the client and is used to generate the master secret, as specified in Section 8.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
pre_master_secret此随机值由客户端生成，用于生成主密钥，如第8.1节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2. Client Diffie-Hellman public value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.7.2. 客户Diffie Hellman公共价值
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: This structure conveys the client&#39;s Diffie-Hellman public value (Yc) if it was not already included in the client&#39;s certificate. The encoding used for Yc is determined by the enumerated PublicValueEncoding. This structure is a variant of the client key exchange message, not a message in itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：如果客户机的证书中尚未包含Diffie-Hellman公共值（Yc），则此结构传递该客户机的Diffie-Hellman公共值。Yc使用的编码由枚举的PublicValueEncoding确定。此结构是客户端密钥交换消息的变体，而不是消息本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
implicit If the client certificate already contains a suitable Diffie-Hellman key, then Yc is implicit and does not need to be sent again. In this case, the Client Key Exchange message will be sent, but will be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
隐式如果客户端证书已经包含合适的Diffie-Hellman密钥，则Yc是隐式的，不需要再次发送。在这种情况下，客户端密钥交换消息将被发送，但将为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
explicit Yc needs to be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
需要发送明确的Yc。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           select (PublicValueEncoding) {
               case implicit: struct { };
               case explicit: opaque dh_Yc&lt;1..2^16-1&gt;;
           } dh_public;
       } ClientDiffieHellmanPublic;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           select (PublicValueEncoding) {
               case implicit: struct { };
               case explicit: opaque dh_Yc&lt;1..2^16-1&gt;;
           } dh_public;
       } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_Yc The client&#39;s Diffie-Hellman public value (Yc).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dh_Yc客户的Diffie Hellman公共价值（Yc）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8. Certificate verify
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.8. 证书验证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: This message is used to provide explicit verification of a client certificate. This message is only sent following a client certificate that has signing capability (i.e. all certificates except those containing fixed Diffie-Hellman parameters). When sent, it will immediately follow the client key exchange message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
何时发送此消息：此消息用于提供客户端证书的显式验证。此消息仅在具有签名功能的客户端证书（即除包含固定Diffie-Hellman参数的证书外的所有证书）之后发送。发送时，它将立即跟随客户端密钥交换消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
            Signature signature;
       } CertificateVerify;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Structure of this message:
       struct {
            Signature signature;
       } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The Signature type is defined in 7.4.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
签名类型在7.4.3中定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CertificateVerify.signature.md5_hash MD5(handshake_messages);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
CertificateVerify.signature.md5\u哈希md5（握手消息）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Certificate.signature.sha_hash SHA(handshake_messages);
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Certificate.signature.sha_hash sha（握手消息）；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here handshake_messages refers to all handshake messages sent or received starting at client hello up to but not including this message, including the type and length fields of the handshake messages. This is the concatenation of all the Handshake structures as defined in 7.4 exchanged thus far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里，握手_消息是指从客户端hello开始发送或接收到的所有握手消息，直到但不包括此消息，包括握手消息的类型和长度字段。这是迄今为止7.4中定义的所有握手结构的串联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9. Finished
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.9. 完成了
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When this message will be sent: A finished message is always sent immediately after a change cipher spec message to verify that the key exchange and authentication processes were successful. It is essential that a change cipher spec message be received between the other handshake messages and the Finished message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送此消息的时间：始终在更改密码规范消息之后立即发送完成的消息，以验证密钥交换和身份验证过程是否成功。必须在其他握手消息和完成的消息之间接收更改密码规范消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Meaning of this message: The finished message is the first protected with the just-negotiated algorithms, keys, and secrets. Recipients of finished messages must verify that the contents are correct. Once a side has sent its Finished message and received and validated the Finished message from its peer, it may begin to send and receive application data over the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此消息的含义：完成的消息是第一个使用刚刚协商的算法、密钥和机密进行保护的消息。完成邮件的收件人必须验证内容是否正确。一旦一方发送了完成的消息并从其对等方接收并验证了完成的消息，它就可以开始通过连接发送和接收应用程序数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           opaque verify_data[12];
       } Finished;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           opaque verify_data[12];
       } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       verify_data
           PRF(master_secret, finished_label, MD5(handshake_messages) +
           SHA-1(handshake_messages)) [0..11];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       verify_data
           PRF(master_secret, finished_label, MD5(handshake_messages) +
           SHA-1(handshake_messages)) [0..11];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
finished_label For Finished messages sent by the client, the string &#34;client finished&#34;. For Finished messages sent by the server, the string &#34;server finished&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
finished\由客户端发送的已完成消息的标签，字符串“client finished”。对于服务器发送的已完成消息，字符串“server Finished”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
handshake_messages All of the data from all handshake messages up to but not including this message. This is only data visible at the handshake layer and does not include record layer headers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
握手\信息在该消息之前（但不包括该消息）所有握手消息中的所有数据。这是握手层上唯一可见的数据，不包括记录层标题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
This is the concatenation of all the Handshake structures as defined in 7.4 exchanged thus far.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
这是迄今为止7.4中定义的所有握手结构的串联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is a fatal error if a finished message is not preceded by a change cipher spec message at the appropriate point in the handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在握手的适当位置，完成的消息前面没有更改密码规范消息，则这是一个致命错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The hash contained in finished messages sent by the server incorporate Sender.server; those sent by the client incorporate Sender.client. The value handshake_messages includes all handshake messages starting at client hello up to, but not including, this finished message. This may be different from handshake_messages in Section 7.4.8 because it would include the certificate verify message (if sent). Also, the handshake_messages for the finished message sent by the client will be different from that for the finished message sent by the server, because the one which is sent second will include the prior one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
服务器发送的已完成邮件中包含的哈希包含Sender.server；客户端发送的邮件包含Sender.client。值handshake_messages包括从客户端hello开始直到（但不包括）此完成消息的所有握手消息。这可能不同于第7.4.8节中的握手消息，因为它将包括证书验证消息（如果已发送）。此外，客户端发送的已完成消息的握手_消息将与服务器发送的已完成消息的握手_消息不同，因为第二次发送的握手_消息将包括前一次。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Change cipher spec messages, alerts and any other record types are not handshake messages and are not included in the hash computations. Also, Hello Request messages are omitted from handshake hashes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：更改密码规范消息、警报和任何其他记录类型不是握手消息，也不包括在哈希计算中。此外，握手哈希中省略了Hello请求消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Cryptographic computations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 密码计算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to begin connection protection, the TLS Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The authentication, encryption, and MAC algorithms are determined by the cipher_suite selected by the server and revealed in the server hello message. The compression algorithm is negotiated in the hello messages, and the random values are exchanged in the hello messages. All that remains is to calculate the master secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了开始连接保护，TLS记录协议需要指定一套算法、主密钥以及客户端和服务器随机值。身份验证、加密和MAC算法由服务器选择并在服务器hello消息中显示的密码套件确定。压缩算法在hello消息中协商，随机值在hello消息中交换。剩下的就是计算主秘密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Computing the master secret
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 计算主秘密
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For all key exchange methods, the same algorithm is used to convert the pre_master_secret into the master_secret. The pre_master_secret should be deleted from memory once the master_secret has been computed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于所有密钥交换方法，使用相同的算法将pre_master_秘密转换为master_秘密。在计算主密钥后，应从内存中删除预主密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
master_secret = PRF(pre_master_secret, &#34;master secret&#34;, ClientHello.random + ServerHello.random) [0..47];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
master_secret=PRF（pre_master_secret，“master secret”，ClientHello.random+ServerHello.random）[0..47]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master secret is always exactly 48 bytes in length. The length of the premaster secret will vary depending on key exchange method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主密钥的长度始终恰好为48字节。根据密钥交换方法，premaster密钥的长度会有所不同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. RSA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.1. RSA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RSA is used for server authentication and key exchange, a 48- byte pre_master_secret is generated by the client, encrypted under the server&#39;s public key, and sent to the server. The server uses its private key to decrypt the pre_master_secret. Both parties then convert the pre_master_secret into the master_secret, as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当RSA用于服务器身份验证和密钥交换时，客户端会生成一个48字节的pre_master_密钥，并在服务器的公钥下进行加密，然后发送到服务器。服务器使用其私钥解密pre_master_机密。然后，双方将pre_master_secret转换为master_secret，如上所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA digital signatures are performed using PKCS #1 [PKCS1] block type 1. RSA public key encryption is performed using PKCS #1 block type 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA数字签名使用PKCS#1[PKCS1]块类型1执行。RSA公钥加密使用PKCS#1块类型2执行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. Diffie-Hellman
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1.2. 密钥交换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A conventional Diffie-Hellman computation is performed. The negotiated key (Z) is used as the pre_master_secret, and is converted into the master_secret, as specified above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
执行常规的Diffie-Hellman计算。协商密钥（Z）用作pre_master_secret，并转换为master_secret，如上所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Diffie-Hellman parameters are specified by the server, and may be either ephemeral or contained within the server&#39;s certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：Diffie-Hellman参数由服务器指定，可以是短暂的，也可以包含在服务器的证书中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Mandatory Cipher Suites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 强制密码套件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of an application profile standard specifying otherwise, a TLS compliant application MUST implement the cipher suite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在没有应用程序配置文件标准另有规定的情况下，符合TLS的应用程序必须实现密码套件TLS_DHE_DSS_和_3DES_EDE_CBC_SHA。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Application data protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 应用数据协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application data messages are carried by the Record Layer and are fragmented, compressed and encrypted based on the current connection state. The messages are treated as transparent data to the record layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序数据消息由记录层承载，并根据当前连接状态进行分段、压缩和加密。消息被视为对记录层透明的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A. Protocol constant values
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
A.协议常量值
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes protocol types and constants.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍协议类型和常量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. Record layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 记录层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        uint8 major, minor;
    } ProtocolVersion;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        uint8 major, minor;
    } ProtocolVersion;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    ProtocolVersion version = { 3, 1 };     /* TLS v1.0 */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    ProtocolVersion version = { 3, 1 };     /* TLS v1.0 */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum {
        change_cipher_spec(20), alert(21), handshake(22),
        application_data(23), (255)
    } ContentType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum {
        change_cipher_spec(20), alert(21), handshake(22),
        application_data(23), (255)
    } ContentType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSPlaintext.length];
    } TLSPlaintext;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSPlaintext.length];
    } TLSPlaintext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSCompressed.length];
    } TLSCompressed;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        opaque fragment[TLSCompressed.length];
    } TLSCompressed;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        select (CipherSpec.cipher_type) {
            case stream: GenericStreamCipher;
            case block:  GenericBlockCipher;
        } fragment;
    } TLSCiphertext;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ContentType type;
        ProtocolVersion version;
        uint16 length;
        select (CipherSpec.cipher_type) {
            case stream: GenericStreamCipher;
            case block:  GenericBlockCipher;
        } fragment;
    } TLSCiphertext;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    stream-ciphered struct {
        opaque content[TLSCompressed.length];
        opaque MAC[CipherSpec.hash_size];
    } GenericStreamCipher;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    stream-ciphered struct {
        opaque content[TLSCompressed.length];
        opaque MAC[CipherSpec.hash_size];
    } GenericStreamCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    block-ciphered struct {
        opaque content[TLSCompressed.length];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    block-ciphered struct {
        opaque content[TLSCompressed.length];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        opaque MAC[CipherSpec.hash_size];
        uint8 padding[GenericBlockCipher.padding_length];
        uint8 padding_length;
    } GenericBlockCipher;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        opaque MAC[CipherSpec.hash_size];
        uint8 padding[GenericBlockCipher.padding_length];
        uint8 padding_length;
    } GenericBlockCipher;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. Change cipher specs message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. 更改密码规格消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        enum { change_cipher_spec(1), (255) } type;
    } ChangeCipherSpec;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        enum { change_cipher_spec(1), (255) } type;
    } ChangeCipherSpec;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. Alert messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. 警报消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { warning(1), fatal(2), (255) } AlertLevel;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum {
            close_notify(0),
            unexpected_message(10),
            bad_record_mac(20),
            decryption_failed(21),
            record_overflow(22),
            decompression_failure(30),
            handshake_failure(40),
            bad_certificate(42),
            unsupported_certificate(43),
            certificate_revoked(44),
            certificate_expired(45),
            certificate_unknown(46),
            illegal_parameter(47),
            unknown_ca(48),
            access_denied(49),
            decode_error(50),
            decrypt_error(51),
            export_restriction(60),
            protocol_version(70),
            insufficient_security(71),
            internal_error(80),
            user_canceled(90),
            no_renegotiation(100),
            (255)
        } AlertDescription;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum {
            close_notify(0),
            unexpected_message(10),
            bad_record_mac(20),
            decryption_failed(21),
            record_overflow(22),
            decompression_failure(30),
            handshake_failure(40),
            bad_certificate(42),
            unsupported_certificate(43),
            certificate_revoked(44),
            certificate_expired(45),
            certificate_unknown(46),
            illegal_parameter(47),
            unknown_ca(48),
            access_denied(49),
            decode_error(50),
            decrypt_error(51),
            export_restriction(60),
            protocol_version(70),
            insufficient_security(71),
            internal_error(80),
            user_canceled(90),
            no_renegotiation(100),
            (255)
        } AlertDescription;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        AlertLevel level;
        AlertDescription description;
    } Alert;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        AlertLevel level;
        AlertDescription description;
    } Alert;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. Handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. 握手协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum {
        hello_request(0), client_hello(1), server_hello(2),
        certificate(11), server_key_exchange (12),
        certificate_request(13), server_hello_done(14),
        certificate_verify(15), client_key_exchange(16),
        finished(20), (255)
    } HandshakeType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum {
        hello_request(0), client_hello(1), server_hello(2),
        certificate(11), server_key_exchange (12),
        certificate_request(13), server_hello_done(14),
        certificate_verify(15), client_key_exchange(16),
        finished(20), (255)
    } HandshakeType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        HandshakeType msg_type;
        uint24 length;
        select (HandshakeType) {
            case hello_request:       HelloRequest;
            case client_hello:        ClientHello;
            case server_hello:        ServerHello;
            case certificate:         Certificate;
            case server_key_exchange: ServerKeyExchange;
            case certificate_request: CertificateRequest;
            case server_hello_done:   ServerHelloDone;
            case certificate_verify:  CertificateVerify;
            case client_key_exchange: ClientKeyExchange;
            case finished:            Finished;
        } body;
    } Handshake;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        HandshakeType msg_type;
        uint24 length;
        select (HandshakeType) {
            case hello_request:       HelloRequest;
            case client_hello:        ClientHello;
            case server_hello:        ServerHello;
            case certificate:         Certificate;
            case server_key_exchange: ServerKeyExchange;
            case certificate_request: CertificateRequest;
            case server_hello_done:   ServerHelloDone;
            case certificate_verify:  CertificateVerify;
            case client_key_exchange: ClientKeyExchange;
            case finished:            Finished;
        } body;
    } Handshake;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.1. Hello messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.1. 你好消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct { } HelloRequest;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct { } HelloRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        uint32 gmt_unix_time;
        opaque random_bytes[28];
    } Random;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        uint32 gmt_unix_time;
        opaque random_bytes[28];
    } Random;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    opaque SessionID&lt;0..32&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    opaque SessionID&lt;0..32&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
uint8 CipherSuite[2];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
uint8密码套件[2]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suites&lt;2..2^16-1&gt;;
        CompressionMethod compression_methods&lt;1..2^8-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion client_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suites&lt;2..2^16-1&gt;;
        CompressionMethod compression_methods&lt;1..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
} ClientHello;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
}克利恩泰罗；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion server_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suite;
        CompressionMethod compression_method;
    } ServerHello;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion server_version;
        Random random;
        SessionID session_id;
        CipherSuite cipher_suite;
        CompressionMethod compression_method;
    } ServerHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.2. Server authentication and key exchange messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.2. 服务器身份验证和密钥交换消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    opaque ASN.1Cert&lt;2^24-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    opaque ASN.1Cert&lt;2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ASN.1Cert certificate_list&lt;1..2^24-1&gt;;
    } Certificate;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ASN.1Cert certificate_list&lt;1..2^24-1&gt;;
    } Certificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { rsa, diffie_hellman } KeyExchangeAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        opaque RSA_modulus&lt;1..2^16-1&gt;;
        opaque RSA_exponent&lt;1..2^16-1&gt;;
    } ServerRSAParams;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        opaque RSA_modulus&lt;1..2^16-1&gt;;
        opaque RSA_exponent&lt;1..2^16-1&gt;;
    } ServerRSAParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        opaque DH_p&lt;1..2^16-1&gt;;
        opaque DH_g&lt;1..2^16-1&gt;;
        opaque DH_Ys&lt;1..2^16-1&gt;;
    } ServerDHParams;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        opaque DH_p&lt;1..2^16-1&gt;;
        opaque DH_g&lt;1..2^16-1&gt;;
        opaque DH_Ys&lt;1..2^16-1&gt;;
    } ServerDHParams;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        select (KeyExchangeAlgorithm) {
            case diffie_hellman:
                ServerDHParams params;
                Signature signed_params;
            case rsa:
                ServerRSAParams params;
                Signature signed_params;
        };
    } ServerKeyExchange;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        select (KeyExchangeAlgorithm) {
            case diffie_hellman:
                ServerDHParams params;
                Signature signed_params;
            case rsa:
                ServerRSAParams params;
                Signature signed_params;
        };
    } ServerKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { anonymous, rsa, dsa } SignatureAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    select (SignatureAlgorithm)
    {   case anonymous: struct { };
        case rsa:
            digitally-signed struct {
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    select (SignatureAlgorithm)
    {   case anonymous: struct { };
        case rsa:
            digitally-signed struct {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                opaque md5_hash[16];
                opaque sha_hash[20];
            };
        case dsa:
            digitally-signed struct {
                opaque sha_hash[20];
            };
    } Signature;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                opaque md5_hash[16];
                opaque sha_hash[20];
            };
        case dsa:
            digitally-signed struct {
                opaque sha_hash[20];
            };
    } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum {
        rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
        (255)
    } ClientCertificateType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum {
        rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
        (255)
    } ClientCertificateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    opaque DistinguishedName&lt;1..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    opaque DistinguishedName&lt;1..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
        DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
    } CertificateRequest;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ClientCertificateType certificate_types&lt;1..2^8-1&gt;;
        DistinguishedName certificate_authorities&lt;3..2^16-1&gt;;
    } CertificateRequest;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct { } ServerHelloDone;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct { } ServerHelloDone;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.3. Client authentication and key exchange messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.3. 客户端身份验证和密钥交换消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        select (KeyExchangeAlgorithm) {
            case rsa: EncryptedPreMasterSecret;
            case diffie_hellman: DiffieHellmanClientPublicValue;
        } exchange_keys;
    } ClientKeyExchange;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        select (KeyExchangeAlgorithm) {
            case rsa: EncryptedPreMasterSecret;
            case diffie_hellman: DiffieHellmanClientPublicValue;
        } exchange_keys;
    } ClientKeyExchange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion client_version;
        opaque random[46];
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        ProtocolVersion client_version;
        opaque random[46];
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
} PreMasterSecret;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
}秘密；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        public-key-encrypted PreMasterSecret pre_master_secret;
    } EncryptedPreMasterSecret;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        public-key-encrypted PreMasterSecret pre_master_secret;
    } EncryptedPreMasterSecret;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { implicit, explicit } PublicValueEncoding;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        select (PublicValueEncoding) {
            case implicit: struct {};
            case explicit: opaque DH_Yc&lt;1..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        select (PublicValueEncoding) {
            case implicit: struct {};
            case explicit: opaque DH_Yc&lt;1..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        } dh_public;
    } ClientDiffieHellmanPublic;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        } dh_public;
    } ClientDiffieHellmanPublic;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        Signature signature;
    } CertificateVerify;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        Signature signature;
    } CertificateVerify;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.4. Handshake finalization message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4.4. 握手结束消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        opaque verify_data[12];
    } Finished;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
        opaque verify_data[12];
    } Finished;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. The CipherSuite
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. 密码套件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following values define the CipherSuite codes used in the client hello and server hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下值定义了客户端hello和服务器hello消息中使用的密码套件代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A CipherSuite defines a cipher specification supported in TLS Version 1.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密码套件定义TLS版本1.0中支持的密码规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS_NULL_WITH_NULL_NULL is specified and is the initial state of a TLS connection during the first handshake on that channel, but must not be negotiated, as it provides no more protection than an unsecured connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定了TLS_NULL_WITH_NULL_NULL，是该通道上第一次握手期间TLS连接的初始状态，但不得协商，因为它提供的保护不比不安全的连接多。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_NULL_WITH_NULL_NULL                = { 0x00,0x00 };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_NULL_WITH_NULL_NULL                = { 0x00,0x00 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following CipherSuite definitions require that the server provide an RSA certificate that can be used for key exchange. The server may request either an RSA or a DSS signature-capable certificate in the certificate request message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下密码套件定义要求服务器提供可用于密钥交换的RSA证书。服务器可以在证书请求消息中请求支持RSA或DSS签名的证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
    CipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
    CipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
    CipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
    CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
    CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
    CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_RSA_WITH_NULL_MD5                  = { 0x00,0x01 };
    CipherSuite TLS_RSA_WITH_NULL_SHA                  = { 0x00,0x02 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5         = { 0x00,0x03 };
    CipherSuite TLS_RSA_WITH_RC4_128_MD5               = { 0x00,0x04 };
    CipherSuite TLS_RSA_WITH_RC4_128_SHA               = { 0x00,0x05 };
    CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     = { 0x00,0x06 };
    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07 };
    CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };
    CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };
    CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following CipherSuite definitions are used for server-authenticated (and optionally client-authenticated) Diffie-Hellman. DH denotes cipher suites in which the server&#39;s certificate contains the Diffie-Hellman parameters signed by the certificate authority
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下密码套件定义用于服务器身份验证（以及可选的客户端身份验证）Diffie Hellman。DH表示密码套件，其中服务器的证书包含由证书颁发机构签名的Diffie-Hellman参数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(CA). DHE denotes ephemeral Diffie-Hellman, where the Diffie-Hellman parameters are signed by a DSS or RSA certificate, which has been signed by the CA. The signing algorithm used is specified after the DH or DHE parameter. The server can request an RSA or DSS signature-capable certificate from the client for client authentication or it may request a Diffie-Hellman certificate. Any Diffie-Hellman certificate provided by the client must use the parameters (group and generator) described by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（CA）。DHE表示短暂的Diffie-Hellman，其中Diffie-Hellman参数由已由CA签名的DSS或RSA证书签名。使用的签名算法在DH或DHE参数后指定。服务器可以从客户端请求支持RSA或DSS签名的证书以进行客户端身份验证，也可以请求Diffie-Hellman证书。客户端提供的任何Diffie-Hellman证书都必须使用服务器描述的参数（组和生成器）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
    CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
    CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
    CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
    CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B };
    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };
    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };
    CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };
    CipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };
    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x10 };
    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x11 };
    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           = { 0x00,0x12 };
    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13 };
    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };
    CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };
    CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following cipher suites are used for completely anonymous Diffie-Hellman communications in which neither party is authenticated. Note that this mode is vulnerable to man-in-the-middle attacks and is therefore deprecated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下密码套件用于完全匿名的Diffie-Hellman通信，其中任何一方都没有经过身份验证。请注意，此模式容易受到中间人攻击，因此不推荐使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
    CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };
    CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };
    CipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };
    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA           = { 0x00,0x1A };
    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x1B };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: All cipher suites whose first byte is 0xFF are considered private and can be used for defining local/experimental algorithms. Interoperability of such types is a local matter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：第一个字节为0xFF的所有密码套件都被视为专用密码套件，可用于定义本地/实验算法。此类类型的互操作性是一个局部问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Additional cipher suites can be registered by publishing an RFC which specifies the cipher suites, including the necessary TLS protocol information, including message encoding, premaster secret derivation, symmetric encryption and MAC calculation and appropriate reference information for the algorithms involved. The RFC editor&#39;s office may, at its discretion, choose to publish specifications for cipher suites which are not completely described (e.g., for classified algorithms) if it finds the specification to be of technical interest and completely specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注：可通过发布RFC注册其他密码套件，RFC指定密码套件，包括必要的TLS协议信息，包括消息编码、premaster秘密推导、对称加密和MAC计算，以及相关算法的适当参考信息。如果RFC编辑办公室发现规范具有技术意义且完全指定，则可自行决定发布未完全描述的密码套件规范（例如，用于分类算法）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: The cipher suite values { 0x00, 0x1C } and { 0x00, 0x1D } are reserved to avoid collision with Fortezza-based cipher suites in SSL 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：保留密码套件值{0x00，0x1C}和{0x00，0x1D}，以避免与SSL 3中基于Fortezza的密码套件发生冲突。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.6. The Security Parameters
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.6. 安全参数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These security parameters are determined by the TLS Handshake Protocol and provided as parameters to the TLS Record Layer in order to initialize a connection state. SecurityParameters includes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些安全参数由TLS握手协议确定，并作为参数提供给TLS记录层，以便初始化连接状态。安全参数包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null(0), (255) } CompressionMethod;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { server, client } ConnectionEnd;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { server, client } ConnectionEnd;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, rc4, rc2, des, 3des, des40, idea }
       BulkCipherAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, rc4, rc2, des, 3des, des40, idea }
       BulkCipherAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { stream, block } CipherType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { stream, block } CipherType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { true, false } IsExportable;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { true, false } IsExportable;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       enum { null, md5, sha } MACAlgorithm;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* The algorithms specified in CompressionMethod,
   BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   /* The algorithms specified in CompressionMethod,
   BulkCipherAlgorithm, and MACAlgorithm may be added to. */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ConnectionEnd entity;
           BulkCipherAlgorithm bulk_cipher_algorithm;
           CipherType cipher_type;
           uint8 key_size;
           uint8 key_material_length;
           IsExportable is_exportable;
           MACAlgorithm mac_algorithm;
           uint8 hash_size;
           CompressionMethod compression_algorithm;
           opaque master_secret[48];
           opaque client_random[32];
           opaque server_random[32];
       } SecurityParameters;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ConnectionEnd entity;
           BulkCipherAlgorithm bulk_cipher_algorithm;
           CipherType cipher_type;
           uint8 key_size;
           uint8 key_material_length;
           IsExportable is_exportable;
           MACAlgorithm mac_algorithm;
           uint8 hash_size;
           CompressionMethod compression_algorithm;
           opaque master_secret[48];
           opaque client_random[32];
           opaque server_random[32];
       } SecurityParameters;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B. Glossary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
B.词汇表
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
application protocol An application protocol is a protocol that normally layers directly on top of the transport layer (e.g., TCP/IP). Examples include HTTP, TELNET, FTP, and SMTP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用协议应用协议是一种通常直接在传输层（如TCP/IP）之上分层的协议。示例包括HTTP、TELNET、FTP和SMTP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
asymmetric cipher See public key cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非对称密码参见公钥密码术。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
authentication Authentication is the ability of one entity to determine the identity of another entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
身份验证是一个实体确定另一个实体身份的能力。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
block cipher A block cipher is an algorithm that operates on plaintext in groups of bits, called blocks. 64 bits is a common block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分组密码分组密码是一种以位为单位对明文进行运算的算法，称为块。64位是常见的块大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bulk cipher A symmetric encryption algorithm used to encrypt large quantities of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
批量密码用于加密大量数据的对称加密算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher block chaining (CBC) CBC is a mode in which every plaintext block encrypted with a block cipher is first exclusive-ORed with the previous ciphertext block (or, in the case of the first block, with the initialization vector). For decryption, every block is first decrypted, then exclusive-ORed with the previous ciphertext block (or IV).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密码块链接（CBC）CBC是一种模式，其中使用块密码加密的每个明文块首先与前一个密文块（或者，在第一个块的情况下，与初始化向量）进行异或运算。对于解密，首先对每个块进行解密，然后与前一个密文块（或IV）进行异或运算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate As part of the X.509 protocol (a.k.a. ISO Authentication framework), certificates are assigned by a trusted Certificate Authority and provide a strong binding between a party&#39;s identity or some other attributes and its public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书作为X.509协议（又称ISO认证框架）的一部分，证书由受信任的证书颁发机构分配，并在一方的身份或某些其他属性与其公钥之间提供强绑定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client The application entity that initiates a TLS connection to a server. This may or may not imply that the client initiated the underlying transport connection. The primary operational difference between the server and client is that the server is generally authenticated, while the client is only optionally authenticated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端启动到服务器的TLS连接的应用程序实体。这可能意味着客户机启动了底层传输连接，也可能不是。服务器和客户机之间的主要操作区别在于，服务器通常经过身份验证，而客户机只是选择性地经过身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client write key The key used to encrypt data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端写入密钥用于加密客户端写入的数据的密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
client write MAC secret The secret data used to authenticate data written by the client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端写入MAC机密用于验证客户端写入的数据的机密数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
connection A connection is a transport (in the OSI layering model definition) that provides a suitable type of service. For TLS, such connections are peer to peer relationships. The connections are transient. Every connection is associated with one session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
连接连接是（在OSI分层模型定义中）提供适当类型服务的传输。对于TLS，这种连接是对等关系。连接是暂时的。每个连接都与一个会话相关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Encryption Standard DES is a very widely used symmetric encryption algorithm. DES is a block cipher with a 56 bit key and an 8 byte block size. Note that in TLS, for key generation purposes, DES is treated as having an 8 byte key length (64 bits), but it still only provides 56 bits of protection. (The low bit of each key byte is presumed to be set to produce odd parity in that key byte.) DES can also be operated in a mode where three independent keys and three encryptions are used for each block of data; this uses 168 bits of key (24 bytes in the TLS key generation method) and provides the equivalent of 112 bits of security. [DES], [3DES]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据加密标准DES是一种应用非常广泛的对称加密算法。DES是一种具有56位密钥和8字节块大小的分组密码。请注意，在TLS中，出于密钥生成目的，DES被视为具有8字节密钥长度（64位），但它仍然仅提供56位保护。（假定每个密钥字节的低位被设置为在该密钥字节中产生奇偶校验。）DES也可以在一种模式下运行，其中每个数据块使用三个独立密钥和三个加密；这使用168位密钥（在TLS密钥生成方法中为24字节），并提供相当于112位的安全性。[DES]，[3DES]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Digital Signature Standard (DSS) A standard for digital signing, including the Digital Signing Algorithm, approved by the National Institute of Standards and Technology, defined in NIST FIPS PUB 186, &#34;Digital Signature Standard,&#34; published May, 1994 by the U.S. Dept. of Commerce. [DSS]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数字签名标准（DSS）：美国国家标准与技术研究所批准的数字签名标准，包括数字签名算法，由美国商务部于1994年5月发布的NIST FIPS PUB 186“数字签名标准”中定义。[决策支持系统]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
digital signatures Digital signatures utilize public key cryptography and one-way hash functions to produce a signature of the data that can be authenticated, and is difficult to forge or repudiate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数字签名数字签名利用公钥密码和单向散列函数生成数据签名，该数据签名可通过身份验证，且难以伪造或否认。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
handshake An initial negotiation between client and server that establishes the parameters of their transactions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手客户端和服务器之间建立其事务参数的初始协商。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Initialization Vector (IV) When a block cipher is used in CBC mode, the initialization vector is exclusive-ORed with the first plaintext block prior to encryption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始化向量（IV）当分组密码在CBC模式下使用时，初始化向量在加密之前与第一个明文块进行异或运算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IDEA A 64-bit block cipher designed by Xuejia Lai and James Massey. [IDEA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lai和James Massey设计的64位分组密码。[想法]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message Authentication Code (MAC) A Message Authentication Code is a one-way hash computed from a message and some secret data. It is difficult to forge without knowing the secret data. Its purpose is to detect if the message has been altered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息身份验证码（MAC）消息身份验证码是根据消息和某些机密数据计算的单向散列。不知道秘密数据就很难伪造。其目的是检测消息是否已被更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
master secret Secure secret data used for generating encryption keys, MAC secrets, and IVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主机密用于生成加密密钥、MAC机密和IVs的安全机密数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 MD5 is a secure hashing function that converts an arbitrarily long data stream into a digest of fixed size (16 bytes). [MD5]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 MD5是一个安全的哈希函数，它将任意长的数据流转换为固定大小（16字节）的摘要。[MD5]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
public key cryptography A class of cryptographic techniques employing two-key ciphers. Messages encrypted with the public key can only be decrypted with the associated private key. Conversely, messages signed with the private key can be verified with the public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公钥密码术采用两种密钥密码的一类密码技术。使用公钥加密的消息只能使用关联的私钥解密。相反，使用私钥签名的消息可以使用公钥进行验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
one-way hash function A one-way transformation that converts an arbitrary amount of data into a fixed-length hash. It is computationally hard to reverse the transformation or to find collisions. MD5 and SHA are examples of one-way hash functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单向散列函数将任意数量的数据转换为固定长度散列的单向转换。在计算上很难反转变换或找到碰撞。MD5和SHA是单向散列函数的示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC2 A block cipher developed by Ron Rivest at RSA Data Security, Inc. [RSADSI] described in [RC2].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC2由RSA Data Security，Inc.[RSADSI]的Ron Rivest开发的分组密码，如[RC2]所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC4 A stream cipher licensed by RSA Data Security [RSADSI]. A compatible cipher is described in [RC4].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RC4由RSA数据安全[RSADSI]授权的流密码。[RC4]中描述了兼容的密码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA A very widely used public-key algorithm that can be used for either encryption or digital signing. [RSA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA是一种广泛使用的公钥算法，可用于加密或数字签名。[RSA]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
salt Non-secret random data used to make export encryption keys resist precomputation attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于使导出加密密钥抵抗预计算攻击的salt非机密随机数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server The server is the application entity that responds to requests for connections from clients. See also under client.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
服务器服务器是响应客户端连接请求的应用程序实体。另请参见“客户端”下的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session A TLS session is an association between a client and a server. Sessions are created by the handshake protocol. Sessions define a set of cryptographic security parameters, which can be shared among multiple connections. Sessions are used to avoid the expensive negotiation of new security parameters for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话TLS会话是客户端和服务器之间的关联。会话是通过握手协议创建的。会话定义一组加密安全参数，可在多个连接之间共享。会话用于避免为每个连接协商昂贵的新安全参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session identifier A session identifier is a value generated by a server that identifies a particular session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话标识符会话标识符是由服务器生成的用于标识特定会话的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server write key The key used to encrypt data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
服务器写入密钥用于加密服务器写入的数据的密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server write MAC secret The secret data used to authenticate data written by the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
服务器写入MAC机密用于验证服务器写入的数据的机密数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA The Secure Hash Algorithm is defined in FIPS PUB 180-1. It produces a 20-byte output. Note that all references to SHA actually use the modified SHA-1 algorithm. [SHA]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHA安全哈希算法在FIPS PUB 180-1中定义。它产生一个20字节的输出。请注意，所有对SHA的引用实际上都使用修改后的SHA-1算法。[民政事务局局长]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSL Netscape&#39;s Secure Socket Layer protocol [SSL3]. TLS is based on SSL Version 3.0
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SSL Netscape的安全套接字层协议[SSL3]。TLS基于SSL版本3.0
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
stream cipher An encryption algorithm that converts a key into a cryptographically-strong keystream, which is then exclusive-ORed with the plaintext.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
流密码一种加密算法，将密钥转换为加密强密钥流，然后与明文进行异或运算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
symmetric cipher See bulk cipher.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对称密码参见批量密码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transport Layer Security (TLS) This protocol; also, the Transport Layer Security working group of the Internet Engineering Task Force (IETF). See &#34;Comments&#34; at the end of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
传输层安全（TLS）协议；此外，互联网工程任务组（IETF）的传输层安全工作组。见本文件末尾的“评论”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C. CipherSuite definitions
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
C.密码套件定义
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
CipherSuite Is Key Cipher Hash Exportable Exchange
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
CipherSuite是密钥密码哈希可导出交换
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
TLS_NULL_WITH_NULL_NULL * NULL NULL NULL TLS_RSA_WITH_NULL_MD5 * RSA NULL MD5 TLS_RSA_WITH_NULL_SHA * RSA NULL SHA TLS_RSA_EXPORT_WITH_RC4_40_MD5 * RSA_EXPORT RC4_40 MD5 TLS_RSA_WITH_RC4_128_MD5 RSA RC4_128 MD5 TLS_RSA_WITH_RC4_128_SHA RSA RC4_128 SHA TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 * RSA_EXPORT RC2_CBC_40 MD5 TLS_RSA_WITH_IDEA_CBC_SHA RSA IDEA_CBC SHA TLS_RSA_EXPORT_WITH_DES40_CBC_SHA * RSA_EXPORT DES40_CBC SHA TLS_RSA_WITH_DES_CBC_SHA RSA DES_CBC SHA TLS_RSA_WITH_3DES_EDE_CBC_SHA RSA 3DES_EDE_CBC SHA TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA * DH_DSS_EXPORT DES40_CBC SHA TLS_DH_DSS_WITH_DES_CBC_SHA DH_DSS DES_CBC SHA TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA DH_DSS 3DES_EDE_CBC SHA TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA * DH_RSA_EXPORT DES40_CBC SHA TLS_DH_RSA_WITH_DES_CBC_SHA DH_RSA DES_CBC SHA TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA DH_RSA 3DES_EDE_CBC SHA TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC SHA TLS_DHE_DSS_WITH_DES_CBC_SHA DHE_DSS DES_CBC SHA TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA DHE_DSS 3DES_EDE_CBC SHA TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC SHA TLS_DHE_RSA_WITH_DES_CBC_SHA DHE_RSA DES_CBC SHA TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA DHE_RSA 3DES_EDE_CBC SHA TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 * DH_anon_EXPORT RC4_40 MD5 TLS_DH_anon_WITH_RC4_128_MD5 DH_anon RC4_128 MD5 TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA DH_anon DES40_CBC SHA TLS_DH_anon_WITH_DES_CBC_SHA DH_anon DES_CBC SHA TLS_DH_anon_WITH_3DES_EDE_CBC_SHA DH_anon 3DES_EDE_CBC SHA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10月10日，你有什么想法（CBC）的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，CBC的概念，教教教教教教教教教教教教教教教教教教教教的出口，教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教的教这是一个基于CBC的健康决策支持系统研究结果是一个数字加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密加密SHA TLS_DHE_DSS_与CBC_SHA DHE_DSS_EDE_CBC_SHA我们的研究成果是一个关于RSA的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的基金会的128 MD5 TLS DH anon出口与CBC SHA DH anon DES40 CBC SHA与CBC合作的第三方为CBC，与CBC合作的第三方为CBC，与CBC合作的第三方为CBC，与CBC合作的第三方为CBC
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Indicates IsExportable is True
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 指示IsExportable为True
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Key Exchange Algorithm Description Key size limit
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
密钥交换算法描述密钥大小限制
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DHE_DSS Ephemeral DH with DSS signatures None DHE_DSS_EXPORT Ephemeral DH with DSS signatures DH = 512 bits DHE_RSA Ephemeral DH with RSA signatures None DHE_RSA_EXPORT Ephemeral DH with RSA signatures DH = 512 bits, RSA = none DH_anon Anonymous DH, no signatures None DH_anon_EXPORT Anonymous DH, no signatures DH = 512 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DHE_DSS带有DSS签名的短命DH无DHE_DSS_导出带有DSS签名的短命DH DH=512位DHE_RSA带有RSA签名的短命DH无DHE_RSA_导出带有RSA签名的短命DH DH DH=512位，RSA=None DH anon Anonymous DH，无签名None DH anon anon_导出匿名DH，无签名DH=512位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DH_DSS DH with DSS-based certificates None DH_DSS_EXPORT DH with DSS-based certificates DH = 512 bits DH_RSA DH with RSA-based certificates None DH_RSA_EXPORT DH with RSA-based certificates DH = 512 bits, RSA = none NULL No key exchange N/A RSA RSA key exchange None RSA_EXPORT RSA key exchange RSA = 512 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
DH_DSS DH with DSS-based certificates无DH_DSS_导出DH with DSS-based certificates DH=512位DH_RSA DH with RSA-based certificates无DH_RSA_导出DH with RSA-based certicates DH=512位RSA=None NULL无密钥交换N/A RSA密钥交换无RSA_导出RSA密钥交换RSA=512位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key size limit The key size limit gives the size of the largest public key that can be legally used for encryption in cipher suites that are exportable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密钥大小限制密钥大小限制提供可合法用于可导出密码套件加密的最大公钥的大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 Key Expanded Effective IV Block Cipher Type Material Key Material Key Bits Size Size
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
密钥扩展有效IV分组密码类型材质密钥材质密钥位大小
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
NULL * Stream 0 0 0 0 N/A IDEA_CBC Block 16 16 128 8 8 RC2_CBC_40 * Block 5 16 40 8 8 RC4_40 * Stream 5 16 40 0 N/A RC4_128 Stream 16 16 128 0 N/A DES40_CBC * Block 5 8 40 8 8 DES_CBC Block 8 8 56 8 8 3DES_EDE_CBC Block 24 24 168 8 8
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
空*流0 0 0 0 0 N/A创意CBC区块16 16 128 8 RC2 8 CBC区块5 16 40 8 RC4 40*流5 16 40 0 N/A RC4 8 128流16 16 128 0 N/A设计CBC区块5 8 40 8设计CBC区块8 56 8 3设计CBC区块24 24 168 8
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Indicates IsExportable is true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 表示IsExportable为true。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Indicates whether this is a stream cipher or a block cipher running in CBC mode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型指示这是以CBC模式运行的流密码还是分组密码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key Material The number of bytes from the key_block that are used for generating the write keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Key Material键块中用于生成写入键的字节数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Expanded Key Material The number of bytes actually fed into the encryption algorithm
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
扩展密钥材料实际输入加密算法的字节数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Effective Key Bits How much entropy material is in the key material being fed into the encryption routines.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有效密钥位输入加密例程的密钥材料中有多少熵材料。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV Size How much data needs to be generated for the initialization vector. Zero for stream ciphers; equal to the block size for block ciphers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IV大小需要为初始化向量生成多少数据。流密码为零；等于分组密码的块大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Block Size The amount of data a block cipher enciphers in one chunk; a block cipher running in CBC mode can only encrypt an even multiple of its block size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
块大小块密码在一个块中加密的数据量；在CBC模式下运行的分组密码只能加密其块大小的偶数倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
 Hash Hash Padding function Size Size NULL 0 0 MD5 16 48 SHA 20 40
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
哈希填充函数大小NULL 0 0 MD5 16 48 SHA 20 40
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D. Implementation Notes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
D.实施说明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS protocol cannot prevent many common security mistakes. This section provides several recommendations to assist implementors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS协议无法防止许多常见的安全错误。本节提供了一些帮助实施者的建议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.1. Temporary RSA keys
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.1. 临时RSA密钥
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
US Export restrictions limit RSA keys used for encryption to 512 bits, but do not place any limit on lengths of RSA keys used for signing operations. Certificates often need to be larger than 512 bits, since 512-bit RSA keys are not secure enough for high-value transactions or for applications requiring long-term security. Some certificates are also designated signing-only, in which case they cannot be used for key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
美国出口限制将用于加密的RSA密钥限制为512位，但不限制用于签名操作的RSA密钥的长度。证书通常需要大于512位，因为512位RSA密钥对于高价值事务或需要长期安全性的应用程序来说不够安全。有些证书也被指定为仅签名，在这种情况下，它们不能用于密钥交换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the public key in the certificate cannot be used for encryption, the server signs a temporary RSA key, which is then exchanged. In exportable applications, the temporary RSA key should be the maximum allowable length (i.e., 512 bits). Because 512-bit RSA keys are relatively insecure, they should be changed often. For typical electronic commerce applications, it is suggested that keys be changed daily or every 500 transactions, and more often if possible. Note that while it is acceptable to use the same temporary key for multiple transactions, it must be signed each time it is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当证书中的公钥不能用于加密时，服务器会签署一个临时RSA密钥，然后交换该密钥。在可导出应用程序中，临时RSA密钥应为允许的最大长度（即512位）。因为512位RSA密钥相对不安全，所以应该经常更改它们。对于典型的电子商务应用程序，建议每天或每500笔交易更换一次密钥，如果可能，更频繁地更换密钥。请注意，虽然可以对多个事务使用同一临时密钥，但每次使用时都必须对其进行签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA key generation is a time-consuming process. In many cases, a low-priority process can be assigned the task of key generation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RSA密钥生成是一个耗时的过程。在许多情况下，可以为低优先级进程分配密钥生成任务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a new key is completed, the existing temporary key can be replaced with the new one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每当新密钥完成时，可以用新密钥替换现有的临时密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.2. Random Number Generation and Seeding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.2. 随机数的产生和播种
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS requires a cryptographically-secure pseudorandom number generator (PRNG). Care must be taken in designing and seeding PRNGs. PRNGs based on secure hash operations, most notably MD5 and/or SHA, are acceptable, but cannot provide more security than the size of the random number generator state. (For example, MD5-based PRNGs usually provide 128 bits of state.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS需要加密安全的伪随机数生成器（PRNG）。在设计和播种PRNG时必须小心。基于安全散列操作（最显著的是MD5和/或SHA）的PRNG是可以接受的，但不能提供比随机数生成器状态更大的安全性。（例如，基于MD5的PRNG通常提供128位状态。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To estimate the amount of seed material being produced, add the number of bits of unpredictable information in each seed byte. For example, keystroke timing values taken from a PC compatible&#39;s 18.2 Hz timer provide 1 or 2 secure bits each, even though the total size of the counter value is 16 bits or more. To seed a 128-bit PRNG, one would thus require approximately 100 such timer values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要估计正在生成的种子材料的数量，请在每个种子字节中添加不可预测信息的位数。例如，即使计数器值的总大小为16位或更多，从PC兼容的18.2 Hz定时器获取的击键定时值也会提供1或2个安全位。因此，要为128位PRNG设定种子，需要大约100个这样的计时器值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Warning: The seeding functions in RSAREF and versions of BSAFE prior to 3.0 are order-independent. For example, if 1000 seed bits are supplied, one at a time, in 1000 separate calls to the seed function, the PRNG will end up in a state which depends only on the number of 0 or 1 seed bits in the seed data (i.e., there are 1001 possible final states). Applications using BSAFE or RSAREF must take extra care to ensure proper seeding. This may be accomplished by accumulating seed bits into a buffer and processing them all at once or by processing an incrementing counter with every seed bit; either method will reintroduce order dependence into the seeding process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
警告：RSAREF和BSAFE 3.0之前版本中的种子设定功能与订单无关。例如，如果在对seed函数的1000次单独调用中一次提供1000个种子位，则PRNG将处于仅取决于种子数据中0或1个种子位的数量的状态（即，存在1001个可能的最终状态）。使用BSAFE或RSAREF的应用程序必须格外小心，以确保正确播种。这可以通过将种子位累积到缓冲器中并一次性处理它们来实现，或者通过对每个种子位处理递增计数器来实现；这两种方法都将在播种过程中重新引入顺序依赖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.3. Certificates and authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.3. 证书和身份验证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations are responsible for verifying the integrity of certificates and should generally support certificate revocation messages. Certificates should always be verified to ensure proper signing by a trusted Certificate Authority (CA). The selection and addition of trusted CAs should be done very carefully. Users should be able to view information about the certificate and root CA.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现负责验证证书的完整性，通常应支持证书撤销消息。应始终验证证书，以确保由受信任的证书颁发机构（CA）正确签名。应非常小心地选择和添加受信任的CA。用户应该能够查看有关证书和根CA的信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.4. CipherSuites
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
D.4. 密码套件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS supports a range of key sizes and security levels, including some which provide no or minimal security. A proper implementation will probably not support many cipher suites. For example, 40-bit encryption is easily broken, so implementations requiring strong security should not allow 40-bit keys. Similarly, anonymous Diffie-Hellman is strongly discouraged because it cannot prevent man-in-the-middle attacks. Applications should also enforce minimum and maximum key sizes. For example, certificate chains containing 512-bit RSA keys or signatures are not appropriate for high-security applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS支持一系列密钥大小和安全级别，包括一些不提供安全性或最低安全性的密钥。正确的实现可能不支持许多密码套件。例如，40位加密很容易被破坏，因此需要强安全性的实现不应该允许使用40位密钥。类似地，匿名Diffie Hellman也被强烈劝阻，因为它无法阻止中间人攻击。应用程序还应强制执行最小和最大密钥大小。例如，包含512位RSA密钥或签名的证书链不适用于高安全性应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E. Backward Compatibility With SSL
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
E.与SSL的向后兼容性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For historical reasons and in order to avoid a profligate consumption of reserved port numbers, application protocols which are secured by TLS 1.0, SSL 3.0, and SSL 2.0 all frequently share the same connection port: for example, the https protocol (HTTP secured by SSL or TLS) uses port 443 regardless of which security protocol it is using. Thus, some mechanism must be determined to distinguish and negotiate among the various protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出于历史原因，为了避免滥用保留端口号，由TLS 1.0、SSL 3.0和SSL 2.0保护的应用程序协议通常共享相同的连接端口：例如，https协议（由SSL或TLS保护的HTTP）使用端口443，而不管它使用的是哪种安全协议。因此，必须确定某种机制来区分和协商各种协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS version 1.0 and SSL 3.0 are very similar; thus, supporting both is easy. TLS clients who wish to negotiate with SSL 3.0 servers should send client hello messages using the SSL 3.0 record format and client hello structure, sending {3, 1} for the version field to note that they support TLS 1.0. If the server supports only SSL 3.0, it will respond with an SSL 3.0 server hello; if it supports TLS, with a TLS server hello. The negotiation then proceeds as appropriate for the negotiated protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS版本1.0和SSL 3.0非常相似；因此，支持两者都很容易。希望与SSL 3.0服务器协商的TLS客户端应使用SSL 3.0记录格式和客户端hello结构发送客户端hello消息，并为版本字段发送{3，1}，以注意它们支持TLS 1.0。如果服务器仅支持SSL 3.0，它将使用SSL 3.0服务器hello进行响应；如果它支持TLS，请使用TLS服务器hello。然后，根据谈判达成的协议进行适当的谈判。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, a TLS server which wishes to interoperate with SSL 3.0 clients should accept SSL 3.0 client hello messages and respond with an SSL 3.0 server hello if an SSL 3.0 client hello is received which has a version field of {3, 0}, denoting that this client does not support TLS.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类似地，如果接收到版本字段为{3，0}的SSL 3.0客户端hello，则希望与SSL 3.0客户端互操作的TLS服务器应接受SSL 3.0客户端hello消息，并使用SSL 3.0服务器hello进行响应，这表示此客户端不支持TLS。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Whenever a client already knows the highest protocol known to a server (for example, when resuming a session), it should initiate the connection in that native protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
只要客户机已经知道服务器已知的最高协议（例如，在恢复会话时），它就应该以该本机协议启动连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS 1.0 clients that support SSL Version 2.0 servers must send SSL Version 2.0 client hello messages [SSL2]. TLS servers should accept either client hello format if they wish to support SSL 2.0 clients on the same connection port. The only deviations from the Version 2.0 specification are the ability to specify a version with a value of three and the support for more ciphering types in the CipherSpec.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
支持SSL 2.0版服务器的TLS 1.0客户端必须发送SSL 2.0版客户端hello消息[SSL2]。如果TLS服务器希望在同一连接端口上支持SSL 2.0客户端，则应接受任一客户端hello格式。与版本2.0规范的唯一不同之处是能够指定一个值为3的版本，以及在CipherSpec中支持更多的加密类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Warning: The ability to send Version 2.0 client hello messages will be phased out with all due haste. Implementors should make every effort to move forward as quickly as possible. Version 3.0 provides better mechanisms for moving to newer versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
警告：发送2.0版客户机hello消息的功能将被逐步取消。实施者应尽一切努力尽快向前推进。版本3.0为移动到新版本提供了更好的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following cipher specifications are carryovers from SSL Version 2.0. These are assumed to use RSA for key exchange and authentication.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下密码规范是SSL 2.0版的延续。假设它们使用RSA进行密钥交换和身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
       V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
       V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };
       V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };
       V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                  = { 0x04,0x00,0x80 };
       V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
       V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
       V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       V2CipherSpec TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5
                                                  = { 0x04,0x00,0x80 };
       V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5     = { 0x05,0x00,0x80 };
       V2CipherSpec TLS_DES_64_CBC_WITH_MD5       = { 0x06,0x00,0x40 };
       V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 = { 0x07,0x00,0xC0 };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cipher specifications native to TLS can be included in Version 2.0 client hello messages using the syntax below. Any V2CipherSpec element with its first byte equal to zero will be ignored by Version 2.0 servers. Clients sending any of the above V2CipherSpecs should also include the TLS equivalent (see Appendix A.5):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS固有的密码规范可以使用以下语法包含在2.0版客户端hello消息中。版本2.0服务器将忽略第一个字节等于零的V2CipherSpec元素。发送上述V2CipherSpec的客户还应包括TLS等效物（见附录A.5）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       V2CipherSpec (see TLS name) = { 0x00, CipherSuite };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       V2CipherSpec (see TLS name) = { 0x00, CipherSuite };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.1. Version 2 client hello
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.1. 版本2客户端你好
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Version 2.0 client hello message is presented below using this document&#39;s presentation model. The true definition is still assumed to be the SSL Version 2.0 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面使用本文档的表示模型显示了2.0版客户端hello消息。真正的定义仍然假定为SSL版本2.0规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uint8 V2CipherSpec[3];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
uint8 V2CipherSpec[3]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           uint8 msg_type;
           Version version;
           uint16 cipher_spec_length;
           uint16 session_id_length;
           uint16 challenge_length;
           V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
           opaque session_id[V2ClientHello.session_id_length];
           Random challenge;
       } V2ClientHello;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           uint8 msg_type;
           Version version;
           uint16 cipher_spec_length;
           uint16 session_id_length;
           uint16 challenge_length;
           V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];
           opaque session_id[V2ClientHello.session_id_length];
           Random challenge;
       } V2ClientHello;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
msg_type This field, in conjunction with the version field, identifies a version 2 client hello message. The value should be one (1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
msg_type此字段与version字段一起标识version 2客户端hello消息。该值应为一（1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version The highest version of the protocol supported by the client (equals ProtocolVersion.version, see Appendix A.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版本客户端支持的协议的最高版本（等于ProtocolVersion.version，见附录A.1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_spec_length This field is the total length of the field cipher_specs. It cannot be zero and must be a multiple of the V2CipherSpec length (3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密码规格长度此字段是字段密码规格的总长度。它不能为零，并且必须是V2CipherSpec长度（3）的倍数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id_length This field must have a value of either zero or 16. If zero, the client is creating a new session. If 16, the session_id field will contain the 16 bytes of session identification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话id长度此字段的值必须为零或16。如果为零，则客户端正在创建新会话。如果为16，会话id字段将包含16字节的会话标识。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge_length The length in bytes of the client&#39;s challenge to the server to authenticate itself. This value must be 32.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge_length客户端向服务器发出的验证自身身份的质询的长度（以字节为单位）。此值必须为32。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
cipher_specs This is a list of all CipherSpecs the client is willing and able to use. There must be at least one CipherSpec acceptable to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密码规格这是客户愿意并能够使用的所有密码规格的列表。必须至少有一个服务器可接受的CipherSpec。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
session_id If this field&#39;s length is not zero, it will contain the identification for a session that the client wishes to resume.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话id如果此字段的长度不是零，它将包含客户端希望恢复的会话的标识。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
challenge The client challenge to the server for the server to identify itself is a (nearly) arbitrary length random. The TLS server will right justify the challenge data to become the ClientHello.random data (padded with leading zeroes, if necessary), as specified in this protocol specification. If the length of the challenge is greater than 32 bytes, only the last 32 bytes are used. It is legitimate (but not necessary) for a V3 server to reject a V2 ClientHello that has fewer than 16 bytes of challenge data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
质询客户端对服务器的质询是（几乎）任意长度的随机质询。按照本协议规范的规定，TLS服务器将正确证明质询数据成为ClientHello.random数据（如有必要，用前导零填充）。如果质询的长度大于32字节，则仅使用最后32字节。V3服务器拒绝具有少于16字节质询数据的V2 ClientHello是合法的（但不是必需的）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: Requests to resume a TLS session should use a TLS client hello.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：恢复TLS会话的请求应使用TLS客户端hello。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.2. Avoiding man-in-the-middle version rollback
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
E.2. 避免中间人版本回滚
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When TLS clients fall back to Version 2.0 compatibility mode, they should use special PKCS #1 block formatting. This is done so that TLS servers will reject Version 2.0 sessions with TLS-capable clients.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当TLS客户端退回到2.0版兼容模式时，它们应该使用特殊的PKCS#1块格式。这样做的目的是，TLS服务器将拒绝具有TLS功能的客户端的2.0版会话。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When TLS clients are in Version 2.0 compatibility mode, they set the right-hand (least-significant) 8 random bytes of the PKCS padding (not including the terminal null of the padding) for the RSA encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY to 0x03 (the other padding bytes are random). After decrypting the ENCRYPTED-KEY-DATA field, servers that support TLS should issue an error if these eight padding bytes are 0x03. Version 2.0 servers receiving blocks padded in this manner will proceed normally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当TLS客户端处于版本2.0兼容模式时，它们将PKCS填充的右侧（最低有效）8个随机字节（不包括填充的终端null）设置为0x03（其他填充字节是随机的），以便对CLIENT-MASTER-KEY的ENCRYPTED-KEY-DATA字段进行RSA加密。解密加密的-KEY-DATA字段后，如果这八个填充字节为0x03，则支持TLS的服务器应发出错误。接收以这种方式填充的块的2.0版服务器将正常运行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F. Security analysis
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
F.安全分析
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLS protocol is designed to establish a secure connection between a client and a server communicating over an insecure channel. This document makes several traditional assumptions, including that attackers have substantial computational resources and cannot obtain secret information from sources outside the protocol. Attackers are assumed to have the ability to capture, modify, delete, replay, and otherwise tamper with messages sent over the communication channel. This appendix outlines how TLS has been designed to resist a variety of attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS协议旨在通过不安全通道在客户端和服务器之间建立安全连接。本文档做出了一些传统假设，包括攻击者拥有大量计算资源，无法从协议之外的来源获取机密信息。假定攻击者能够捕获、修改、删除、重播或以其他方式篡改通过通信通道发送的消息。本附录概述了TLS是如何设计来抵御各种攻击的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1. Handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1. 握手协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The handshake protocol is responsible for selecting a CipherSpec and generating a Master Secret, which together comprise the primary cryptographic parameters associated with a secure session. The handshake protocol can also optionally authenticate parties who have certificates signed by a trusted certificate authority.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
握手协议负责选择密码规范并生成主密钥，其共同包括与安全会话相关联的主要密码参数。握手协议还可以选择性地对拥有由可信证书颁发机构签署的证书的各方进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1. Authentication and key exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1. 身份验证和密钥交换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS supports three authentication modes: authentication of both parties, server authentication with an unauthenticated client, and total anonymity. Whenever the server is authenticated, the channel is secure against man-in-the-middle attacks, but completely anonymous sessions are inherently vulnerable to such attacks. Anonymous servers cannot authenticate clients. If the server is authenticated, its certificate message must provide a valid certificate chain leading to an acceptable certificate authority. Similarly, authenticated clients must supply an acceptable certificate to the server. Each party is responsible for verifying that the other&#39;s certificate is valid and has not expired or been revoked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS支持三种身份验证模式：双方身份验证、未经身份验证的客户端的服务器身份验证和完全匿名。只要服务器经过身份验证，通道就可以安全地抵御中间人攻击，但完全匿名会话本身就容易受到此类攻击。匿名服务器无法对客户端进行身份验证。如果服务器经过身份验证，则其证书消息必须提供一个有效的证书链，指向可接受的证书颁发机构。类似地，经过身份验证的客户端必须向服务器提供可接受的证书。各方负责验证另一方的证书是否有效且未过期或被撤销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general goal of the key exchange process is to create a pre_master_secret known to the communicating parties and not to attackers. The pre_master_secret will be used to generate the master_secret (see Section 8.1). The master_secret is required to generate the certificate verify and finished messages, encryption keys, and MAC secrets (see Sections 7.4.8, 7.4.9 and 6.3). By sending a correct finished message, parties thus prove that they know the correct pre_master_secret.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
密钥交换过程的总体目标是创建通信方而非攻击者所知的pre_master_秘密。pre_master_secret将用于生成master_secret（参见第8.1节）。生成证书验证和完成的消息、加密密钥和MAC机密需要主密钥（见第7.4.8、7.4.9和6.3节）。通过发送正确的完成消息，双方证明他们知道正确的pre_master_机密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.1. Anonymous key exchange
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.1. 匿名密钥交换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Completely anonymous sessions can be established using RSA or Diffie-Hellman for key exchange. With anonymous RSA, the client encrypts a pre_master_secret with the server&#39;s uncertified public key
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完全匿名会话可以使用RSA或Diffie Hellman建立，用于密钥交换。使用匿名RSA，客户机使用服务器的未经认证的公钥加密预主密钥
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extracted from the server key exchange message. The result is sent in a client key exchange message. Since eavesdroppers do not know the server&#39;s private key, it will be infeasible for them to decode the pre_master_secret. (Note that no anonymous RSA Cipher Suites are defined in this document).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从服务器密钥交换消息中提取。结果在客户端密钥交换消息中发送。由于窃听者不知道服务器的私钥，因此他们无法解码pre_master_机密。（请注意，本文档中未定义匿名RSA密码套件）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With Diffie-Hellman, the server&#39;s public parameters are contained in the server key exchange message and the client&#39;s are sent in the client key exchange message. Eavesdroppers who do not know the private values should not be able to find the Diffie-Hellman result (i.e. the pre_master_secret).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用Diffie Hellman，服务器的公共参数包含在服务器密钥交换消息中，而客户端的公共参数则在客户端密钥交换消息中发送。不知道私有值的窃听者应该无法找到Diffie Hellman结果（即pre_master_secret）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Warning: Completely anonymous connections only provide protection against passive eavesdropping. Unless an independent tamper-proof channel is used to verify that the finished messages were not replaced by an attacker, server authentication is required in environments where active man-in-the-middle attacks are a concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
警告：完全匿名连接仅提供被动窃听保护。除非使用独立的防篡改通道来验证完成的消息是否未被攻击者替换，否则在存在中间人攻击的环境中，需要进行服务器身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.2. RSA key exchange and authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.2. RSA密钥交换和身份验证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With RSA, key exchange and server authentication are combined. The public key may be either contained in the server&#39;s certificate or may be a temporary RSA key sent in a server key exchange message. When temporary RSA keys are used, they are signed by the server&#39;s RSA or DSS certificate. The signature includes the current ClientHello.random, so old signatures and temporary keys cannot be replayed. Servers may use a single temporary RSA key for multiple negotiation sessions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用RSA，密钥交换和服务器身份验证结合在一起。公钥可以包含在服务器的证书中，也可以是服务器密钥交换消息中发送的临时RSA密钥。使用临时RSA密钥时，它们由服务器的RSA或DSS证书签名。签名包含当前的ClientHello.random，因此无法重放旧签名和临时密钥。服务器可以为多个协商会话使用单个临时RSA密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: The temporary RSA key option is useful if servers need large certificates but must comply with government-imposed size limits on keys used for key exchange.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：如果服务器需要大型证书，但必须遵守政府对用于密钥交换的密钥施加的大小限制，则临时RSA密钥选项非常有用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After verifying the server&#39;s certificate, the client encrypts a pre_master_secret with the server&#39;s public key. By successfully decoding the pre_master_secret and producing a correct finished message, the server demonstrates that it knows the private key corresponding to the server certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在验证服务器的证书后，客户端使用服务器的公钥加密pre_master_密钥。通过成功解码pre_master_secret并生成正确的完成消息，服务器证明它知道与服务器证书对应的私钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RSA is used for key exchange, clients are authenticated using the certificate verify message (see Section 7.4.8). The client signs a value derived from the master_secret and all preceding handshake messages. These handshake messages include the server certificate, which binds the signature to the server, and ServerHello.random, which binds the signature to the current handshake process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当RSA用于密钥交换时，使用证书验证消息对客户端进行身份验证（请参见第7.4.8节）。客户端对从master_secret和前面所有握手消息派生的值进行签名。这些握手消息包括将签名绑定到服务器的服务器证书和将签名绑定到当前握手过程的ServerHello.random。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.3. Diffie-Hellman key exchange with authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.1.3. 具有身份验证的Diffie-Hellman密钥交换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When Diffie-Hellman key exchange is used, the server can either supply a certificate containing fixed Diffie-Hellman parameters or can use the server key exchange message to send a set of temporary Diffie-Hellman parameters signed with a DSS or RSA certificate. Temporary parameters are hashed with the hello.random values before signing to ensure that attackers do not replay old parameters. In either case, the client can verify the certificate or signature to ensure that the parameters belong to the server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用Diffie-Hellman密钥交换时，服务器可以提供包含固定Diffie-Hellman参数的证书，也可以使用服务器密钥交换消息发送一组使用DSS或RSA证书签名的临时Diffie-Hellman参数。临时参数在签名之前会使用hello.random值进行散列，以确保攻击者不会重播旧参数。在这两种情况下，客户机都可以验证证书或签名，以确保参数属于服务器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has a certificate containing fixed Diffie-Hellman parameters, its certificate contains the information required to complete the key exchange. Note that in this case the client and server will generate the same Diffie-Hellman result (i.e., pre_master_secret) every time they communicate. To prevent the pre_master_secret from staying in memory any longer than necessary, it should be converted into the master_secret as soon as possible. Client Diffie-Hellman parameters must be compatible with those supplied by the server for the key exchange to work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果客户机具有包含固定Diffie-Hellman参数的证书，则其证书包含完成密钥交换所需的信息。注意，在这种情况下，客户机和服务器在每次通信时都会生成相同的Diffie-Hellman结果（即pre_master_secret）。为了防止pre_master_secret在内存中停留的时间超过需要，应尽快将其转换为master_secret。客户端Diffie-Hellman参数必须与服务器提供的参数兼容，密钥交换才能工作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client has a standard DSS or RSA certificate or is unauthenticated, it sends a set of temporary parameters to the server in the client key exchange message, then optionally uses a certificate verify message to authenticate itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果客户机具有标准DSS或RSA证书或未经身份验证，它会在客户机密钥交换消息中向服务器发送一组临时参数，然后可选地使用证书验证消息对自身进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.2. Version rollback attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.2. 版本回滚攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because TLS includes substantial improvements over SSL Version 2.0, attackers may try to make TLS-capable clients and servers fall back to Version 2.0. This attack can occur if (and only if) two TLS-capable parties use an SSL 2.0 handshake.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于TLS对SSL 2.0版进行了实质性改进，攻击者可能会试图使支持TLS的客户端和服务器退回到2.0版。如果（且仅当）两个支持TLS的方使用SSL 2.0握手，则可能发生此攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the solution using non-random PKCS #1 block type 2 message padding is inelegant, it provides a reasonably secure way for Version 3.0 servers to detect the attack. This solution is not secure against attackers who can brute force the key and substitute a new ENCRYPTED-KEY-DATA message containing the same key (but with normal padding) before the application specified wait threshold has expired. Parties concerned about attacks of this scale should not be using 40-bit encryption keys anyway. Altering the padding of the least-significant 8 bytes of the PKCS padding does not impact security for the size of the signed hashes and RSA key lengths used in the protocol, since this is essentially equivalent to increasing the input block size by 8 bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管使用非随机PKCS#1 block type 2消息填充的解决方案并不美观，但它为3.0版服务器提供了一种合理安全的方法来检测攻击。此解决方案不安全，攻击者可以在应用程序指定的等待阈值过期之前强行使用密钥并替换包含相同密钥（但具有正常填充）的新加密密钥数据消息。担心这种规模的攻击的各方无论如何都不应该使用40位加密密钥。更改PKCS填充的最低有效8字节的填充不会影响协议中使用的签名哈希大小和RSA密钥长度的安全性，因为这本质上相当于将输入块大小增加8字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.3. Detecting attacks against the handshake protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.3. 检测针对握手协议的攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attacker might try to influence the handshake exchange to make the parties select different encryption algorithms than they would normally choose. Because many implementations will support 40-bit exportable encryption and some may even support null encryption or MAC algorithms, this attack is of particular concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
攻击者可能试图影响握手交换，使双方选择不同于通常选择的加密算法。由于许多实现将支持40位可导出加密，有些甚至可能支持空加密或MAC算法，因此这种攻击尤其令人担忧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others&#39; finished messages. Without the master_secret, the attacker cannot repair the finished messages, so the attack will be discovered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于此攻击，攻击者必须主动更改一条或多条握手消息。如果发生这种情况，客户端和服务器将为握手消息哈希计算不同的值。因此，双方将不接受对方已完成的消息。如果没有master_secret，攻击者无法修复完成的消息，因此将发现攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.4. Resuming sessions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.4. 续会
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a connection is established by resuming a session, new ClientHello.random and ServerHello.random values are hashed with the session&#39;s master_secret. Provided that the master_secret has not been compromised and that the secure hash operations used to produce the encryption keys and MAC secrets are secure, the connection should be secure and effectively independent from previous connections. Attackers cannot use known encryption keys or MAC secrets to compromise the master_secret without breaking the secure hash operations (which use both SHA and MD5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当通过恢复会话建立连接时，新的ClientHello.random和ServerHello.random值将使用会话的master_secret散列。如果主密钥未被泄露，并且用于生成加密密钥和MAC密钥的安全哈希操作是安全的，则连接应该是安全的，并且有效地独立于以前的连接。攻击者不能使用已知的加密密钥或MAC机密泄露主密钥，而不破坏安全哈希操作（同时使用SHA和MD5）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sessions cannot be resumed unless both the client and server agree. If either party suspects that the session may have been compromised, or that certificates may have expired or been revoked, it should force a full handshake. An upper limit of 24 hours is suggested for session ID lifetimes, since an attacker who obtains a master_secret may be able to impersonate the compromised party until the corresponding session ID is retired. Applications that may be run in relatively insecure environments should not write session IDs to stable storage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除非客户端和服务器都同意，否则无法恢复会话。如果任何一方怀疑会话可能已被泄露，或者证书可能已过期或被吊销，则应强制进行完全握手。建议会话ID生命周期的上限为24小时，因为获得master_机密的攻击者可能能够模拟受攻击方，直到相应的会话ID失效。可能在相对不安全的环境中运行的应用程序不应将会话ID写入稳定的存储。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.5. MD5 and SHA
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.1.5. MD5和SHA
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS uses hash functions very conservatively. Where possible, both MD5 and SHA are used in tandem to ensure that non-catastrophic flaws in one algorithm will not break the overall protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLS非常保守地使用哈希函数。在可能的情况下，MD5和SHA同时使用，以确保一个算法中的非灾难性缺陷不会破坏整个协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.2. Protecting application data
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.2. 保护应用程序数据
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The master_secret is hashed with the ClientHello.random and ServerHello.random to produce unique data encryption keys and MAC secrets for each connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主密钥使用ClientHello.random和ServerHello.random散列，为每个连接生成唯一的数据加密密钥和MAC密钥。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Outgoing data is protected with a MAC before transmission. To prevent message replay or modification attacks, the MAC is computed from the MAC secret, the sequence number, the message length, the message contents, and two fixed character strings. The message type field is necessary to ensure that messages intended for one TLS Record Layer client are not redirected to another. The sequence number ensures that attempts to delete or reorder messages will be detected. Since sequence numbers are 64-bits long, they should never overflow. Messages from one party cannot be inserted into the other&#39;s output, since they use independent MAC secrets. Similarly, the server-write and client-write keys are independent so stream cipher keys are used only once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
传出数据在传输前由MAC保护。为了防止消息重播或修改攻击，MAC由MAC密码、序列号、消息长度、消息内容和两个固定字符串计算。message type字段是确保一个TLS记录层客户端的消息不会重定向到另一个客户端所必需的。序列号可确保检测到删除或重新排序邮件的尝试。由于序列号的长度为64位，因此它们永远不会溢出。来自一方的消息不能插入到另一方的输出中，因为它们使用独立的MAC机密。类似地，服务器写入密钥和客户端写入密钥是独立的，因此流密码密钥只使用一次。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an attacker does break an encryption key, all messages encrypted with it can be read. Similarly, compromise of a MAC key can make message modification attacks possible. Because MACs are also encrypted, message-alteration attacks generally require breaking the encryption algorithm as well as the MAC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果攻击者确实破坏了加密密钥，则可以读取使用该密钥加密的所有消息。类似地，泄露MAC密钥可能导致消息修改攻击。由于MAC也是加密的，因此消息更改攻击通常需要破坏加密算法和MAC。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
Note: MAC secrets may be larger than encryption keys, so messages can remain tamper resistant even if encryption keys are broken.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-1">
注意：MAC机密可能大于加密密钥，因此即使加密密钥被破坏，消息也可以保持防篡改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.3. Final notes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
F.3. 最后说明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For TLS to be able to provide a secure connection, both the client and server systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了使TLS能够提供安全连接，客户端和服务器系统、密钥和应用程序都必须是安全的。此外，实现必须没有安全错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys, 40-bit bulk encryption keys, and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该系统仅与所支持的最薄弱的密钥交换和身份验证算法一样强大，并且只能使用可靠的加密功能。使用短公钥、40位批量加密密钥和匿名服务器时应格外小心。在决定哪些证书和证书颁发机构是可接受的时，实现和用户必须小心；不诚实的证书颁发机构会造成巨大的损失。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
G. Patent Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
G.专利声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some of the cryptographic algorithms proposed for use in this protocol have patent claims on them. In addition Netscape Communications Corporation has a patent claim on the Secure Sockets Layer (SSL) work that this standard is based on. The Internet Standards Process as defined in RFC 2026 requests that a statement be obtained from a Patent holder indicating that a license will be made available to applicants under reasonable terms and conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本协议中提议使用的一些加密算法拥有专利权。此外，Netscape Communications Corporation对本标准所基于的安全套接字层（SSL）工作拥有专利权。RFC 2026中定义的互联网标准流程要求从专利持有人处获得一份声明，表明将根据合理的条款和条件向申请人提供许可证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Massachusetts Institute of Technology has granted RSA Data Security, Inc., exclusive sub-licensing rights to the following patent issued in the United States:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
麻省理工学院授予RSA Data Security，Inc.在美国发布的以下专利的独家分许可权：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Cryptographic Communications System and Method (&#34;RSA&#34;), No. 4,405,829
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
密码通信系统和方法（“RSA”），第4405829号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communications Corporation has been issued the following patent in the United States:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communications Corporation已在美国获得以下专利：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Secure Socket Layer Application Program Apparatus And Method (&#34;SSL&#34;), No. 5,657,390
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
安全套接字层应用程序装置和方法（“SSL”），第5657390号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communications has issued the following statement:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Netscape Communications发布了以下声明：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Intellectual Property Rights
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Secure Sockets Layer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
安全套接字层
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
The United States Patent and Trademark Office (&#34;the PTO&#34;) recently issued U.S. Patent No. 5,657,390 (&#34;the SSL Patent&#34;) to Netscape for inventions described as Secure Sockets Layers (&#34;SSL&#34;). The IETF is currently considering adopting SSL as a transport protocol with security features. Netscape encourages the royalty-free adoption and use of the SSL protocol upon the following terms and conditions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
美国专利商标局（“PTO”）最近向Netscape发布了第5657390号美国专利（“SSL专利”），用于描述为安全套接字层（“SSL”）的发明。IETF目前正在考虑采用SSL作为具有安全特性的传输协议。Netscape鼓励根据以下条款和条件免费采用和使用SSL协议：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* If you already have a valid SSL Ref license today which includes source code from Netscape, an additional patent license under the SSL patent is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* 如果您现在已经拥有包含Netscape源代码的有效SSL Ref许可证，则不需要SSL专利下的附加专利许可证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* If you don&#39;t have an SSL Ref license, you may have a royalty free license to build implementations covered by the SSL Patent Claims or the IETF TLS specification provided that you do not to assert any patent rights against Netscape or other companies for the implementation of SSL or the IETF TLS recommendation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
* 如果您没有SSL Ref许可证，您可以拥有免版税许可证来构建SSL专利声明或IETF TLS规范所涵盖的实现，前提是您不主张针对Netscape或其他公司实施SSL或IETF TLS建议的任何专利权。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
What are &#34;Patent Claims&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
什么是“专利权利要求”：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Patent claims are claims in an issued foreign or domestic patent that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
专利权利要求是在已发布的国外或国内专利中的权利要求，其：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1) must be infringed in order to implement methods or build products according to the IETF TLS specification; or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
1) 为了根据IETF TLS规范实施方法或制造产品，必须违反；或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2) patent claims which require the elements of the SSL patent claims and/or their equivalents to be infringed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
2) 要求侵犯SSL专利权利要求和/或其等效内容的专利权利要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Internet Society, Internet Architecture Board, Internet Engineering Steering Group and the Corporation for National Research Initiatives take no position on the validity or scope of the patents and patent applications, nor on the appropriateness of the terms of the assurance. The Internet Society and other groups mentioned above have not made any determination as to any other intellectual property rights which may apply to the practice of this standard. Any further consideration of these matters is the user&#39;s own responsibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
互联网协会、互联网架构委员会、互联网工程指导小组和国家研究计划公司对专利和专利申请的有效性或范围以及保证条款的适当性不持任何立场。互联网协会和上述其他团体尚未就可能适用于本标准实践的任何其他知识产权做出任何决定。用户有责任进一步考虑这些问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Security Considerations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
安全考虑
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security issues are discussed throughout this memo.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录中讨论了安全问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
工具书类
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3DES] W. Tuchman, &#34;Hellman Presents No Shortcut Solutions To DES,&#34; IEEE Spectrum, v. 16, n. 7, July 1979, pp40-41.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3DES]W.Tuchman，“Hellman没有为DES提供捷径解决方案”，IEEE Spectrum，v。16，n。1979年7月7日，第40-41页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BLEI] Bleichenbacher D., &#34;Chosen Ciphertext Attacks against Protocols Based on RSA Encryption Standard PKCS #1&#34; in Advances in Cryptology -- CRYPTO&#39;98, LNCS vol. 1462, pages: 1--12, 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BLEI]Bleichenbacher D.，“针对基于RSA加密标准PKCS#1的协议的选择密文攻击”，载于《密码学进展——CRYPTO&#39;98》，LNCS第1462卷，第1-12页，1998年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DES] ANSI X3.106, &#34;American National Standard for Information Systems-Data Link Encryption,&#34; American National Standards Institute, 1983.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DES]ANSI X3.106，“美国信息系统数据链路加密国家标准”，美国国家标准协会，1983年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DH1] W. Diffie and M. E. Hellman, &#34;New Directions in Cryptography,&#34; IEEE Transactions on Information Theory, V. IT-22, n. 6, Jun 1977, pp. 74-84.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DH1]W.Diffie和M.E.Hellman，“密码学的新方向”，IEEE信息论交易，V.IT-22，n。1977年6月6日，第74-84页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS] NIST FIPS PUB 186, &#34;Digital Signature Standard,&#34; National Institute of Standards and Technology, U.S. Department of Commerce, May 18, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DSS]NIST FIPS PUB 186，“数字签名标准”，美国商务部国家标准与技术研究所，1994年5月18日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FTP] Postel J., and J. Reynolds, &#34;File Transfer Protocol&#34;, STD 9, RFC 959, October 1985.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FTP]Postel J.和J.Reynolds，“文件传输协议”，标准9，RFC 959，1985年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP] Berners-Lee, T., Fielding, R., and H. Frystyk, &#34;Hypertext Transfer Protocol -- HTTP/1.0&#34;, RFC 1945, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HTTP]Berners Lee，T.，Fielding，R.，和H.Frystyk，“超文本传输协议——HTTP/1.0”，RFC 1945，1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HMAC] Krawczyk, H., Bellare, M., and R. Canetti, &#34;HMAC: Keyed-Hashing for Message Authentication,&#34; RFC 2104, February 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HMAC]Krawczyk，H.，Bellare，M.，和R.Canetti，“HMAC：用于消息身份验证的键控哈希”，RFC 2104，1997年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDEA] X. Lai, &#34;On the Design and Security of Block Ciphers,&#34; ETH Series in Information Processing, v. 1, Konstanz: Hartung-Gorre Verlag, 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[IDEA]X.Lai，“分组密码的设计与安全”，信息处理ETH系列，v。康斯坦茨：哈东·高尔·韦拉格，1992年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD2] Kaliski, B., &#34;The MD2 Message Digest Algorithm&#34;, RFC 1319, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD2]Kaliski，B.，“MD2消息摘要算法”，RFC 1319，1992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest, R., &#34;The MD5 Message Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5]Rivest，R.，“MD5消息摘要算法”，RFC 13211992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1] RSA Laboratories, &#34;PKCS #1: RSA Encryption Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS1]RSA实验室，“PKCS#1:RSA加密标准”，1.5版，1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS6] RSA Laboratories, &#34;PKCS #6: RSA Extended Certificate Syntax Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS6]RSA实验室，“PKCS#6:RSA扩展证书语法标准”，1.5版，1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS7] RSA Laboratories, &#34;PKCS #7: RSA Cryptographic Message Syntax Standard,&#34; version 1.5, November 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKCS7]RSA实验室，“PKCS#7:RSA加密消息语法标准”，1.5版，1993年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKIX] Housley, R., Ford, W., Polk, W. and D. Solo, &#34;Internet Public Key Infrastructure: Part I: X.509 Certificate and CRL Profile&#34;, RFC 2459, January 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PKIX]Housley，R.，Ford，W.，Polk，W.和D.Solo，“互联网公钥基础设施：第一部分：X.509证书和CRL配置文件”，RFC 2459，1999年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC2] Rivest, R., &#34;A Description of the RC2(r) Encryption Algorithm&#34;, RFC 2268, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC2]Rivest，R.，“RC2（R）加密算法的描述”，RFC 2268，1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC4] Thayer, R. and K. Kaukonen, A Stream Cipher Encryption Algorithm, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RC4]Thayer，R.和K.Kaukonen，一种流密码加密算法，正在进行中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSA] R. Rivest, A. Shamir, and L. M. Adleman, &#34;A Method for Obtaining Digital Signatures and Public-Key Cryptosystems,&#34; Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120- 126.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSA]R.Rivest，A.Shamir和L.M.Adleman，“获取数字签名和公钥密码系统的方法”，ACM通信，v。21，n。1978年2月2日，第120-126页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSADSI] Contact RSA Data Security, Inc., Tel: 415-595-8782
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RSADSI]联系RSA数据安全公司，电话：415-595-8782
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH] B. Schneier. Applied Cryptography: Protocols, Algorithms, and Source Code in C, Published by John Wiley &amp; Sons, Inc. 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SCH]B.Schneier。应用密码学：C语言的协议、算法和源代码，由John Wiley&amp;Sons，Inc.于1994年出版。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA] NIST FIPS PUB 180-1, &#34;Secure Hash Standard,&#34; National Institute of Standards and Technology, U.S. Department of Commerce, Work in Progress, May 31, 1994.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SHA]NIST FIPS PUB 180-1，“安全哈希标准”，美国商务部国家标准与技术研究所，正在进行的工作，1994年5月31日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL2] Hickman, Kipp, &#34;The SSL Protocol&#34;, Netscape Communications Corp., Feb 9, 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL2]希克曼，基普，“SSL协议”，网景通信公司，1995年2月9日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL3] A. Frier, P. Karlton, and P. Kocher, &#34;The SSL 3.0 Protocol&#34;, Netscape Communications Corp., Nov 18, 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SSL3]A.Frier，P.Karlton和P.Kocher，“SSL 3.0协议”，网景通信公司，1996年11月18日。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP] Postel, J., &#34;Transmission Control Protocol,&#34; STD 7, RFC 793, September 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TCP]Postel，J.，“传输控制协议”，STD 7，RFC 793，1981年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL] Postel J., and J. Reynolds, &#34;Telnet Protocol Specifications&#34;, STD 8, RFC 854, May 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL]Postel J.和J.Reynolds，“Telnet协议规范”，STD 8，RFC 854，1993年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL] Postel J., and J. Reynolds, &#34;Telnet Option Specifications&#34;, STD 8, RFC 855, May 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[TEL]Postel J.和J.Reynolds，“Telnet选项规范”，STD 8，RFC 855，1993年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X509] CCITT. Recommendation X.509: &#34;The Directory - Authentication Framework&#34;. 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X509]CCITT。建议X.509：“目录认证框架”。1988
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR] R. Srinivansan, Sun Microsystems, RFC-1832: XDR: External Data Representation Standard, August 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XDR]R.Srinivansan，太阳微系统公司，RFC-1832:XDR：外部数据表示标准，1995年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Credits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
信用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Win Treese Open Market
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
赢得Treese公开市场
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: treese@openmarket.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: treese@openmarket.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Editors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编辑
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Christopher Allen Tim Dierks Certicom Certicom
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
克里斯托弗·艾伦·蒂姆·迪克斯认证公司
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: callen@certicom.com         EMail: tdierks@certicom.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: callen@certicom.com         EMail: tdierks@certicom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tim Dierks Philip L. Karlton Certicom Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tim Dierks Philip L.Karlton Certicom Netscape Communications
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: tdierks@certicom.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: tdierks@certicom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alan O. Freier Paul C. Kocher Netscape Communications Independent Consultant
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
艾伦·O·弗雷尔·保罗·C·科赫网景通信独立顾问
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: freier@netscape.com         EMail: pck@netcom.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: freier@netscape.com         EMail: pck@netcom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other contributors
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其他贡献者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Martin Abadi Robert Relyea Digital Equipment Corporation Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
马丁·阿巴迪·罗伯特·雷耶数字设备公司网景通信
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: ma@pa.dec.com               EMail: relyea@netscape.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: ma@pa.dec.com               EMail: relyea@netscape.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ran Canetti Jim Roskind IBM Watson Research Center Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ran Canetti Jim Roskind IBM沃森研究中心Netscape Communications
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: canetti@watson.ibm.com      EMail: jar@netscape.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: canetti@watson.ibm.com      EMail: jar@netscape.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taher Elgamal Micheal J. Sabin, Ph. D. Securify Consulting Engineer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taher Elgamal Micheal J.Sabin，安全咨询工程师博士
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: elgamal@securify.com        EMail: msabin@netcom.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: elgamal@securify.com        EMail: msabin@netcom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anil R. Gangolli Dan Simon Structured Arts Computing Corp. Microsoft
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Anil R.Gangolli Dan Simon结构化艺术计算公司微软
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: gangolli@structuredarts.com EMail:  dansimon@microsoft.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: gangolli@structuredarts.com EMail:  dansimon@microsoft.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kipp E.B. Hickman Tom Weinstein Netscape Communications Netscape Communications
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kipp E.B.Hickman Tom Weinstein Netscape Communications Netscape Communications
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: kipp@netscape.com           EMail: tomw@netscape.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: kipp@netscape.com           EMail: tomw@netscape.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugo Krawczyk IBM Watson Research Center
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hugo Krawczyk IBM沃森研究中心
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: hugo@watson.ibm.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: hugo@watson.ibm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Comments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
评论
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The discussion list for the IETF TLS working group is located at the e-mail address &lt;ietf-tls@lists.consensus.com&gt;. Information on the group and information on how to subscribe to the list is at &lt;http://lists.consensus.com/&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF TLS工作组的讨论列表位于电子邮件地址&lt;IETF-tls@lists.consensus.com&gt;. 有关组的信息以及如何订阅列表的信息，请访问&lt;http://lists.consensus.com/&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Archives of the list can be found at:
       &lt;http://www.imc.org/ietf-tls/mail-archive/&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Archives of the list can be found at:
       &lt;http://www.imc.org/ietf-tls/mail-archive/&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1999). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1999年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
