<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 3072:  Structured Data Exchange Format (SDXF) 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC3072 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3072</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc3072.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">原文</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 3072:  Structured Data Exchange Format (SDXF)  中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc3072" target="_blank">
              https://datatracker.ietf.org/doc/html/rfc3072
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 3072</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                       M. Wildgrube
Request for Comments: 3072                                    March 2001
Category: Informational
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                       M. Wildgrube
Request for Comments: 3072                                    March 2001
Category: Informational
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Structured Data Exchange Format (SDXF)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
结构化数据交换格式（SDXF）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本备忘录的状况
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录为互联网社区提供信息。它没有规定任何类型的互联网标准。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2001年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG Note
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
IESG注释
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies a data exchange format and, partially, an API that can be used for creating and parsing such a format. The IESG notes that the same problem space can be addressed using formats that the IETF normally uses including ASN.1 and XML. The document reader is strongly encouraged to carefully read section 13 before choosing SDXF over ASN.1 or XML. Further, when storing text in SDXF, the user is encourage to use the datatype for UTF-8, specified in section 2.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档指定了数据交换格式，部分还指定了可用于创建和解析此类格式的API。IESG指出，可以使用IETF通常使用的格式（包括ASN.1和XML）解决相同的问题空间。强烈建议文档读者在选择SDXF而不是ASN.1或XML之前仔细阅读第13节。此外，在SDXF中存储文本时，鼓励用户使用第2.5节中指定的UTF-8数据类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification describes an all-purpose interchange format for use as a file format or for net-working. Data is organized in chunks which can be ordered in hierarchical structures. This format is self-describing and CPU-independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本规范描述了用作文件格式或网络工作的通用交换格式。数据被组织成块，可以按层次结构排序。这种格式是自描述的，与CPU无关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction ................................................. 2
   2.  Description of the SDXF data format .......................... 3
   3.  Introduction to the SDXF functions ........................... 5
   3.1 General remarks .............................................. 5
   3.2 Writing a SDXF buffer ........................................ 5
   3.3 Reading a SDXF buffer ........................................ 6
   3.4 Example ...................................................... 6
   4.  Platform independence ........................................ 8
   5.  Compression .................................................. 9
   6.  Encryption ...................................................11
   7.  Arrays........................................................11
   8.  Description of the SDXF functions ............................12
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction ................................................. 2
   2.  Description of the SDXF data format .......................... 3
   3.  Introduction to the SDXF functions ........................... 5
   3.1 General remarks .............................................. 5
   3.2 Writing a SDXF buffer ........................................ 5
   3.3 Reading a SDXF buffer ........................................ 6
   3.4 Example ...................................................... 6
   4.  Platform independence ........................................ 8
   5.  Compression .................................................. 9
   6.  Encryption ...................................................11
   7.  Arrays........................................................11
   8.  Description of the SDXF functions ............................12
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   8.1 Introduction .................................................12
   8.2 Basic definitions ............................................13
   8.3 Definitions for C++ ..........................................15
   8.4 Common Definitions ...........................................16
   8.5 Special functions ............................................17
   9.  &#39;Support&#39; of UTF-8 ...........................................19
   10.  Security Considerations .....................................19
   11.  Some general hints ..........................................20
   12.  IANA Considerations .........................................20
   13.  Discussion ..................................................21
   13.1 SDXF vs. ASN.1 ..............................................21
   13.2 SDXF vs. XML ................................................22
   14.  Author&#39;s Address ............................................24
   15.  Acknowledgements ............................................24
   16.  References ..................................................24
   17.  Full Copyright Statement ....................................26
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   8.1 Introduction .................................................12
   8.2 Basic definitions ............................................13
   8.3 Definitions for C++ ..........................................15
   8.4 Common Definitions ...........................................16
   8.5 Special functions ............................................17
   9.  &#39;Support&#39; of UTF-8 ...........................................19
   10.  Security Considerations .....................................19
   11.  Some general hints ..........................................20
   12.  IANA Considerations .........................................20
   13.  Discussion ..................................................21
   13.1 SDXF vs. ASN.1 ..............................................21
   13.2 SDXF vs. XML ................................................22
   14.  Author&#39;s Address ............................................24
   15.  Acknowledgements ............................................24
   16.  References ..................................................24
   17.  Full Copyright Statement ....................................26
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the Structured Data eXchange Format (SDXF) is to permit the interchange of an arbitrary structured data block with different kinds of data (numerical, text, bitstrings). Because data is normalized to an abstract computer architecture independent &#34;network format&#34;, SDXF is usable as a network interchange data format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结构化数据交换格式（SDXF）的目的是允许任意结构化数据块与不同类型的数据（数字、文本、位字符串）进行交换。由于数据被规范化为独立于抽象计算机体系结构的“网络格式”，因此SDXF可用作网络交换数据格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This data format is not limited to any application, the demand for this format is that it is usable as a text format for word-processing, as a picture format, a sound format, for remote procedure calls with complex parameters, suitable for document formats, for interchanging business data, etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该数据格式不限于任何应用程序，对该格式的需求是，它可用作文字处理的文本格式、图片格式、声音格式、具有复杂参数的远程过程调用、适合文档格式、交换业务数据等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF is self-describing, every program can unpack every SDXF-data without knowing the meaning of the individual data elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF是自描述的，每个程序都可以解包每个SDXF数据，而不知道单个数据元素的含义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Together with the description of the data format a set of functions will be introduced. With the help of these functions one can create and access the data elements of SDXF. The idea is that a programmer should only use these functions instead of maintaining the structure by himself on the level of bits and bytes. (In the speech of object-oriented programming these functions are methods of an object which works as a handle for a given SDXF data block.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在介绍数据格式的同时，还将介绍一组函数。借助这些函数，可以创建和访问SDXF的数据元素。其思想是程序员应该只使用这些函数，而不是自己在位和字节级别上维护结构。（在面向对象编程中，这些函数是对象的方法，用作给定SDXF数据块的句柄。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF is not limited to a specific platform, along with a correct preparation of the SDXF functions the SDXF data can be interchanged (via network or data carrier) across the boundaries of different architectures (specified by the character code like ASCII, ANSI or EBCDIC and the byte order for binary data).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF不限于特定平台，只要正确准备SDXF功能，SDXF数据就可以（通过网络或数据载体）跨不同体系结构的边界进行交换（由ASCII、ANSI或EBCDIC等字符代码以及二进制数据的字节顺序指定）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF is also prepared to compress and encrypt parts or the whole block of SDXF data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF还准备对部分或整个SDXF数据块进行压缩和加密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2. Description of SDXF data format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2. SDXF数据格式说明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.1 First we introduce the term &#34;chunk&#34;. A chunk is a data structure with a fixed set of components. A chunk may be &#34;elementary&#34; or &#34;structured&#34;. The latter one contains itself one or more other chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.1 首先我们介绍术语“块”。块是一种具有固定组件集的数据结构。语块可以是“基本的”或“结构化的”。后者本身包含一个或多个其他块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A chunk consists of a header and the data body (content):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
区块由标头和数据体（内容）组成：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----------+-----+-------+-----------------------------------+
   | Name     | Pos.| Length| Description                       |
   +----------+-----+-------+-----------------------------------+
   | chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |
   | flags    |  3  |   1   | type and properties of this chunk |
   | length   |  4  |   3   | length  of the following data     |
   | content  |  7  |   *)  | net data or a list of of chunks   |
   +----------+-----+-------+-----------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----------+-----+-------+-----------------------------------+
   | Name     | Pos.| Length| Description                       |
   +----------+-----+-------+-----------------------------------+
   | chunk-ID |  1  |   2   | ID of the chunk (unsigned short)  |
   | flags    |  3  |   1   | type and properties of this chunk |
   | length   |  4  |   3   | length  of the following data     |
   | content  |  7  |   *)  | net data or a list of of chunks   |
   +----------+-----+-------+-----------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(* as stated in &#34;length&#34;. total length of chunk is length+6. The chunk ID is a non-zero positive number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（*如“长度”中所述。区块的总长度为长度+6。区块ID为非零正数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
or more visually:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
或者更直观地说：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+-...
   | chunkID | fl | length       |  content
   +----+----+----+----+----+----+----+----+----+-...
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+-...
   | chunkID | fl | length       |  content
   +----+----+----+----+----+----+----+----+----+-...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
or in ASN.1 syntax:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
或在ASN.1语法中：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   chunk  ::=  SEQUENCE
   {
     chunkID INTEGER (1..65535),
     flags   BIT STRING,
     length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)
     content OCTET STRING
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   chunk  ::=  SEQUENCE
   {
     chunkID INTEGER (1..65535),
     flags   BIT STRING,
     length  OCTET STRING SIZE 3, -- or: INTEGER (0..16777215)
     content OCTET STRING
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.2 Structured chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.2 结构化块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A structured chunk is marked as such by the flag byte (see 2.5). Opposed to an elementary chunk its content consists of a list of chunks (elementary or structured):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结构化块由标志字节标记（见2.5）。与基本块相对，其内容由一系列块（基本块或结构化块）组成：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----+-+---+-------+-------+-------+-----+-------+
   | id |f|len| chunk | chunk | chunk | ... | chunk |
   +----+-+---+-------+-------+-------+-----+-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----+-+---+-------+-------+-------+-----+-------+
   | id |f|len| chunk | chunk | chunk | ... | chunk |
   +----+-+---+-------+-------+-------+-----+-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the help of this concept you can reproduce every hierarchically structured data into a SDXF chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有了这个概念的帮助，您可以将每个层次结构的数据复制到SDXF块中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.3 Some Remarks about the internal representation of the chunk&#39;s elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.3 关于区块元素的内部表示的一些备注：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Binary values are always in high-order-first (big endian) format, like the binary values in the IP header (network format). A length of 300 (=256 + 32 + 12) is stored as
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
二进制值始终采用高阶优先（big-endian）格式，就像IP报头中的二进制值一样（网络格式）。300（=256+32+12）的长度存储为
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+--
   |         |    | 00   01   2C |  content
   +----+----+----+----+----+----+----+----+----+--
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +----+----+----+----+----+----+----+----+----+--
   |         |    | 00   01   2C |  content
   +----+----+----+----+----+----+----+----+----+--
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in hexadecimal notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用十六进制表示法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is also valid for the chunk-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这对于chunk-ID也是有效的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.4 Character values in the content portion are also an object of adaptation: see chapter 4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.4 内容部分中的字符值也是改编的对象：参见第4章。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.5 Meaning of the flag-bits: Let us represent the flag byte in this manner:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.5 标志位的含义：让我们用以下方式表示标志字节：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+
     |0|1|2|3|4|5|6|7|
     +-+-+-+-+-+-+-+-+
      | | | | | | | |
      | | | | | | | +-- reserved
      | | | | | | +---- array
      | | | | | +------ short chunk
      | | | | +-------- encrypted chunk
      | | | +---------- compressed chunk
      | | |
      +-+-+------------ data type (0..7)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     +-+-+-+-+-+-+-+-+
     |0|1|2|3|4|5|6|7|
     +-+-+-+-+-+-+-+-+
      | | | | | | | |
      | | | | | | | +-- reserved
      | | | | | | +---- array
      | | | | | +------ short chunk
      | | | | +-------- encrypted chunk
      | | | +---------- compressed chunk
      | | |
      +-+-+------------ data type (0..7)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
data types are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据类型包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0 -- pending structure (chunk is inconsistent, see also 11.1) 1 -- structure 2 -- bit string 3 -- numeric 4 -- character 5 -- float (ANSI/IEEE 754-1985)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
0--挂起结构（数据块不一致，另见11.1）1--结构2--位字符串3--数字4--字符5--浮点（ANSI/IEEE 754-1985）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6 -- UTF-8 7 -- reserved
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6--UTF-8 7--预留
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.6 A short chunk has no data body. The 3 byte Length field is used as data bytes instead. This is used in order to save space when there are many small chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.6 短块没有数据体。3字节长度字段用作数据字节。当有许多小块时，这是为了节省空间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.7 Compressed and encrypted chunks are explained in chapter 5 and 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.7 第5章和第6章解释了压缩和加密的块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.8 Arrays are explained in chapter 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.8 第7章对数组进行了解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.9 Handling of UTF-8 is explained in chapter 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.9 第9章解释了UTF-8的处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.10 Not all combinations of bits are allowed or reasonable:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
2.10 并非所有位的组合都是允许的或合理的：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- the flags &#39;array&#39; and &#39;short&#39; are mutually exclusive. - &#39;short&#39; is not applicable for data type &#39;structure&#39; and &#39;float&#39;. - &#39;array&#39; is not applicable for data type &#39;structure&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 标志“array”和“short”是互斥的。-&#39;short&#39;不适用于数据类型&#39;structure&#39;和&#39;float&#39;。-数组“”不适用于数据类型“结构”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Introduction to the SDXF functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. SDXF函数简介
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 General remarks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 一般评论
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The functionality of the SDXF concept is not bounded to any programming language, but of course the functions themselves must be coded in a particular language. I discuss these functions in C and C++, because in the meanwhile these languages are available on almost all platforms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF概念的功能不受任何编程语言的限制，但当然，函数本身必须用特定语言编码。我讨论了C和C++中的这些函数，因为这些语言在几乎所有的平台上都是可用的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All these functions for reading and writing SDXF chunks uses only one parameter, a parameter structure. In C++ this parameter structure is part of the &#34;SDXF class&#34; and the SDXF functions are methods of this class.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有这些用于读取和写入SDXF块的函数只使用一个参数，即参数结构。在C++中，这个参数结构是“SDXF类”的一部分，SDXF函数是这个类的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An exact description of the interface is given in chapter 8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第8章给出了接口的准确描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Writing a SDXF buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 写入SDXF缓冲区
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For to write SDXF chunks, there are following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要编写SDXF块，有以下函数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init -- initialize the parameter structure create -- create a new chunk leave -- &#34;close&#34; a structured chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init--初始化参数结构create--创建一个新块离开--“关闭”一个结构化块
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 Reading a SDXF buffer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3 读取SDXF缓冲区
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For to read SDXF chunks, there are following functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要读取SDXF块，有以下函数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init -- initialize the parameter structure enter -- &#34;go into&#34; a structured chunk next -- &#34;go to&#34; the next chunk inside a structured chunk extract -- extract the content of an elementary chunk into user&#39;s data area leave -- &#34;go out&#34; off a structured chunk
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
init--初始化参数结构输入--“进入”结构化块下一个--“进入”结构化块内的下一个块提取--将基本块的内容提取到用户的数据区域离开--“退出”结构化块
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4 Example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4 例子：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4.1 Writing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
3.4.1 写作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For demonstration we use a reduced (outlined) C++ Form of these functions with polymorph definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了演示，我们使用缩写（概述）C++函数形式的这些函数与多态性定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void create (short chunkID); // opens a new structure, void create (short chunkID, char *string); // creates a new chunk with dataType character, etc.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
void create（短chunkID）；//打开一个新结构，void create（短chunkID，char*string）；//使用数据类型字符等创建新块）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
顺序如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDXF x(new); // create the SDXF object &#34;x&#34; for a new chunk
                // includes the &#34;init&#34;
   x.create (3301);   // opens a new structure
   x.create (3302, &#34;first chunk&#34;);
   x.create (3303, &#34;second chunk&#34;);
   x.create (3304);   // opens a new structure
   x.create (3305, &#34;chunk in a structure&#34;);
   x.create (3306, &#34;next chunk in a structure&#34;);
   x.leave ();        // closes the inner structure
   x.create (3307, &#34;third chunk&#34;);
   x.leave ();        // closes the outer structure
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDXF x(new); // create the SDXF object &#34;x&#34; for a new chunk
                // includes the &#34;init&#34;
   x.create (3301);   // opens a new structure
   x.create (3302, &#34;first chunk&#34;);
   x.create (3303, &#34;second chunk&#34;);
   x.create (3304);   // opens a new structure
   x.create (3305, &#34;chunk in a structure&#34;);
   x.create (3306, &#34;next chunk in a structure&#34;);
   x.leave ();        // closes the inner structure
   x.create (3307, &#34;third chunk&#34;);
   x.leave ();        // closes the outer structure
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
creates a chunk which we can show graphically like:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
创建一个块，我们可以将其以图形方式显示，如：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   3301
    |
    +--- 3302 = &#34;first chunk&#34;
    |
    +--- 3303 = &#34;second chunk&#34;
    |
    +--- 3304
    |      |
    |      +--- 3305 = &#34;chunk in a structure&#34;
    |      |
    |      +--- 3306 = &#34;next chunk in a structure&#34;
    |
    +--- 3307 = &#34;last chunk&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   3301
    |
    +--- 3302 = &#34;first chunk&#34;
    |
    +--- 3303 = &#34;second chunk&#34;
    |
    +--- 3304
    |      |
    |      +--- 3305 = &#34;chunk in a structure&#34;
    |      |
    |      +--- 3306 = &#34;next chunk in a structure&#34;
    |
    +--- 3307 = &#34;last chunk&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2 Reading
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2 阅读
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A typically access to a structured SDXF chunk is a selection inside a loop:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对结构化SDXF区块的典型访问是循环内的选择：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDXF x(old); // defines a SDXF object &#34;x&#34; for an old chunk
   x.enter ();  // enters the structure
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDXF x(old); // defines a SDXF object &#34;x&#34; for an old chunk
   x.enter ();  // enters the structure
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   while (x.rc == 0) // 0 == ok, rc will set by the SDXF functions
   {
     switch (x.chunkID)
     {
       case 3302:
         x.extract (data1, maxLength1);
                   // extr. 1st chunk into data1
         break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   while (x.rc == 0) // 0 == ok, rc will set by the SDXF functions
   {
     switch (x.chunkID)
     {
       case 3302:
         x.extract (data1, maxLength1);
                   // extr. 1st chunk into data1
         break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case 3303:
         x.extract (data2, maxLength2);
                   // extr. 2nd chunk into data2
         break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case 3303:
         x.extract (data2, maxLength2);
                   // extr. 2nd chunk into data2
         break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case 3304:  // we know this is a structure
         x.enter (); // enters the inner structure
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case 3304:  // we know this is a structure
         x.enter (); // enters the inner structure
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         while (x.rc == 0) // inner loop
         {
           switch (x.chunkID)
           {
             case 3305:
               x.extract (data3, maxLength3);
                         // extr. the chunk inside struct.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         while (x.rc == 0) // inner loop
         {
           switch (x.chunkID)
           {
             case 3305:
               x.extract (data3, maxLength3);
                         // extr. the chunk inside struct.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               break;
             case 3306:
               x.extract (data4, maxLength4);
                         // extr. 2nd chunk inside struct.
               break;
           }
           x.next (); // returns x.rc == 1 at end of structure
         } // end-while
         break;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               break;
             case 3306:
               x.extract (data4, maxLength4);
                         // extr. 2nd chunk inside struct.
               break;
           }
           x.next (); // returns x.rc == 1 at end of structure
         } // end-while
         break;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case 3307:
         x.extract (data5, maxLength5);
                   // extract last chunk into data
         break;
       // default: none - ignore unknown chunks !!!
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       case 3307:
         x.extract (data5, maxLength5);
                   // extract last chunk into data
         break;
       // default: none - ignore unknown chunks !!!
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     } // end-switch
     x.next (); // returns x.rc = 1 at end of structure
   } // end-while
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     } // end-switch
     x.next (); // returns x.rc = 1 at end of structure
   } // end-while
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Platform independence
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 平台独立性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The very most of the computer platforms today have a 8-Bits-in-a-Byte architecture, which enables data exchange between these platforms. But there are two significant points in which platforms may be different:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当今的大多数计算机平台都有一个8位字节体系结构，可以在这些平台之间进行数据交换。但平台可能有两个重要的不同点：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) The representation of binary numerical (the short and long int and floats).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
a) 二进制数字的表示（短整型和长整型以及浮点型）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) The representation of characters (ASCII/ANSI vs. EBCDIC)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
b) 字符的表示（ASCII/ANSI与EBCDIC）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Point (a) is the phenomenon of &#34;byte swapping&#34;: How is a short int value 259 = 0x0103 = X&#39;0103&#39; be stored at address 4402?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第（a）点是“字节交换”现象：如何在地址4402处存储短int值259=0x0103=X&#39;0103？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two flavours are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这两种口味是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4402 4403 01 03 the big-endian, and 03 01 the little-endian.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4402 4403 01 03大端，03 01小端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Point (b) is represented by a table of the assignment of the 256 possible values of a Byte to printable or control characters. (In ASCII the letter &#34;A&#34; is assigned to value (or position) 0x41 = 65, in EBCDIC it is 0xC1 = 193.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
点（b）由一个表表示，该表将一个字节的256个可能值分配给可打印字符或控制字符。（在ASCII中，字母“A”被分配给值（或位置）0x41=65，在EBCDIC中，字母“A”被分配给值（或位置）0xC1=193。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The solution of these problems is to normalize the data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些问题的解决方案是规范化数据：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We fix:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们确定：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) The internal representation of binary numerals are 2-complements in big-endian order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) 二进制数字的内部表示是大端序的2-补码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) The internal representation of characters is ISO 8859-1 (also known as Latin 1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) 字符的内部表示法是ISO 8859-1（也称为拉丁语1）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fixing of point (b) should be regarded as a first strike. In some environment 8859-1 seems not to be the best choice, in a greek or russian environment 8859-5 or 8859-7 are appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（b）点的确定应视为第一次打击。在某些环境中，8859-1似乎不是最佳选择，在希腊或俄罗斯环境中，8859-5或8859-7是合适的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless, in a specific group (or world) of applications, that is to say all the applications which wants to interchange data with a defined protocol (via networking or diskette or something else), this internal character table must be unique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，在特定的应用程序组（或世界）中，也就是说，所有希望使用定义的协议（通过网络、软盘或其他方式）交换数据的应用程序，该内部字符表必须是唯一的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
So a possibility to define a translation table (and his inversion) should be given.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，应该给出定义翻译表（和他的倒装）的可能性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Important: You construct a SDXF chunk not for a specific addressee, but you adapt your data into a normalized format (or network format).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重要提示：您不是为特定的收件人构建SDXF块，而是将数据调整为规范化格式（或网络格式）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This adaption is not done by the programmer, it will be done by the create and extract function. An administrator has take care of defining the correct translation tables.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这种自适应不是由程序员完成的，而是由create和extract函数完成的。管理员必须负责定义正确的翻译表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Compression
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 压缩
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) are compressed. This data is not further interpretable until it is decompressed. Compression is transparently done by the SDXF functions: &#34;create&#34; does the compression for elementary chunks, &#34;leave&#34; for structured chunks, &#34;extract&#34; does the decompression for elementary chunks, &#34;enter&#34; for structured chunks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如2.5所述，有一个标志位声明压缩以下数据（基本数据或结构化数据）。在解压之前，此数据无法进一步解释。压缩是由SDXF函数透明地完成的：“create”对基本块进行压缩，“leave”对结构化块进行压缩，“extract”对基本块进行解压缩，“enter”对结构化块进行解压缩。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transparently means that the programmer has only to tell the SDXF functions that he want compress the following chunk(s).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
透明意味着程序员只需告诉SDXF函数他想要压缩以下块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For choosing between different compression methods and for controlling the decompressed (original) length, there is an additional definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于选择不同的压缩方法和控制解压缩（原始）长度，还有一个额外的定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the chunk header for a compressed chunk, a compression header is following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在压缩块的块头之后，压缩头如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------+---------------+----------------&gt;
   |      chunk header     | compr. header | compressed data
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
   |chunkID|flg|   length  |md | orglength |
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------+---------------+----------------&gt;
   |      chunk header     | compr. header | compressed data
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
   |chunkID|flg|   length  |md | orglength |
   +---+---+---+---+---+---+---+---+---+---+----------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- &#39;orglength&#39; is the original (decompressed) length of the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- “orglength”是数据的原始（解压缩）长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- &#39;md&#39; is the &#34;compression method&#34;: Two methods are described here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- “md”是“压缩方法”：这里描述了两种方法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
# method 01 for a simple (fast but not very effective) &#34;Run Length 1&#34; or &#34;Byte Run 1&#34; algorithm. (More then two consecutive identical characters are replaced by the number of these characters and the character itself.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#方法01用于简单（快速但不是非常有效）“运行长度1”或“字节运行1”算法。（超过两个连续的相同字符将替换为这些字符的数量和字符本身。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
more precisely:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
更准确地说：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The compressed data consists of several sections of various length. Every section starts with a &#34;counter&#34; byte, a signed &#34;tiny&#34; (8 bit) integer, which contains a length information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
压缩数据由不同长度的几个部分组成。每个部分都以一个“计数器”字节开始，这是一个有符号的“微小”（8位）整数，它包含一个长度信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         If this byte contains the value &#34;n&#34;,
         with n &gt;= 0 (and n &lt;128), the next n+1 bytes will be taken
         unchanged;
         with n &lt; 0 (and n &gt; -128), the next byte will be replicated
         -n+1 times;
         n = -128 will be ignored.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         If this byte contains the value &#34;n&#34;,
         with n &gt;= 0 (and n &lt;128), the next n+1 bytes will be taken
         unchanged;
         with n &lt; 0 (and n &gt; -128), the next byte will be replicated
         -n+1 times;
         n = -128 will be ignored.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Appending blanks will be cutted in general. If these are necessary, they can be reconstructed while &#34;extract&#34;ing with the parameter field &#34;filler&#34; (see 8.2.1) set to space character.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
一般情况下，将切割附加坯料。如有必要，可在“提取”时将参数字段“填充”（见8.2.1）设置为空格字符，对其进行重构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
# method 02 for the wonderful &#34;deflate&#34; algorithm which comes from the &#34;zip&#34;-people. The authors are: Jean-loup Gailly (deflate routine), Mark Adler (inflate routine), and others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
#方法02用于奇妙的“deflate”算法，该算法来自“zip”-人。作者是：Jean loup Gailly（放气程序）、Mark Adler（充气程序）和其他人。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The deflate format is described in [DEFLATE].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
[deflate]中描述了deflate格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The values for the compression method number are maintained by IANA, see chap. 12.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
压缩方法编号的值由IANA维护，见第12.1章。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Encryption
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 加密
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As stated in 2.5 there is a flag bit which declares that the following data (elementary or structured) is encrypted. This data is not interpretable until it is decrypted. En/Decryption is transparently done by the SDXF functions, &#34;create&#34; does the encryption for elementary chunks, &#34;leave&#34; for structured chunks, &#34;extract&#34; does the decryption for elementary chunks, &#34;enter&#34; for structured chunks. (Yes it sounds very similar to chapter 5.) More then one encryption method for a given range of applications is not very reasonable. Some encryption algorithms work with block ciphering algorithms. That means that the length of the data to encrypt must be rounded up to the next multiple of this block length. This blocksize (zero means non-blocking) is reported by the encryption interface routine (addressed by the option field *encryptProc, see chapter 8.5) with mode=3. If blocking is used, at least one byte is added, the last byte of the lengthening data contains the number of added bytes minus one. With this the decryption interface routine can calculate the real data length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如2.5所述，有一个标志位声明以下数据（基本数据或结构化数据）已加密。此数据在解密之前不可解释。En/解密由SDXF函数透明地完成，“创建”对基本块进行加密，“保留”对结构化块进行加密，“提取”对基本块进行解密，“输入”对结构化块进行加密。（是的，听起来与第5章非常相似。）对于给定的应用范围，不止一种加密方法是不合理的。一些加密算法与块加密算法一起工作。这意味着要加密的数据长度必须向上舍入到该块长度的下一个倍数。此块大小（零表示非阻塞）由加密接口例程（由选项字段*encryptProc寻址，参见第8.5章）报告，模式=3。如果使用阻塞，则至少添加一个字节，加长数据的最后一个字节包含添加的字节数减去一。通过这种方式，解密接口例程可以计算实际数据长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application (or network connect handshaking protocol) needs to negotiate an encryption method it should be used a method number maintained by IANA, see chap. 12.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果应用程序（或网络连接握手协议）需要协商加密方法，则应使用IANA维护的方法编号，参见第12.2章。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even the en/decryption is done transparently, an encryption key (password) must be given to the SDXF functions. Encryption is done after translating character data into, decryption is done before translation from the internal (&#34;network-&#34;) format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
即使加密/解密是透明的，也必须为SDXF函数提供加密密钥（密码）。加密是在将字符数据转换为之后完成的，解密是在从内部（“网络-”）格式转换之前完成的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If both, encryption and compression are applied on the same chunk, compression is done first - compression on good encrypted data (same strings appears as different after encryption) tends to zero compression rates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在同一块上同时应用加密和压缩，则首先进行压缩-对加密良好的数据（加密后相同的字符串显示为不同的字符串）的压缩率趋于零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Arrays
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 阵列
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An array is a sequence of chunks with identical chunk-ID, length and data type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数组是具有相同块ID、长度和数据类型的块序列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At first a hint: in principle a special definition in SDXF for such an array is not really necessary:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
首先有一个提示：原则上，SDXF中对这样一个数组的特殊定义并不是真正必要的：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not forbidden that there are more than one chunk with equal chunk-ID within the same structured chunk.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不禁止在同一结构化块中存在多个具有相同块ID的块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore with a sequence of SDX_next / SDX_extract calls one can fill the destination array step by step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，通过一系列SDX_next/SDX_extract调用，可以一步一步地填充目标数组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there are many occurrences of chunks with the same chunk-ID (and a comparative small length), the overhead of the chunk-packages may be significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果出现许多具有相同块ID（且长度相对较小）的块，则块包的开销可能会很大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore the array flag is introduced. An array chunk has only one chunk header for the complete sequence of elementary chunks. After the chunk header for an array chunk, an array header is following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此引入了数组标志。对于基本块的完整序列，数组块只有一个块头。在数组块的块头之后，数组头如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a short integer (big endian!) which contains the number of the array elements (CT). Every element has a fixed length (EL), so the chunklength (CL) is CL = EL * CT + 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是一个短整数（大端！），包含数组元素数（CT）。每个元素都有一个固定的长度（EL），因此chunklength（CL）是CL=EL*CT+2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The data elements follows immediately after the array header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据元素紧跟在数组头之后。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The complete array will be constructed by SDX_create, the complete array will be read by SDX_extract.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完整数组将由SDX_create构建，完整数组将由SDX_extract读取。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The parameter fields (see 8.2.1) &#39;dataLength&#39; and &#39;count&#39; are used for the SDXF functions &#39;extract&#39; and &#39;create&#39;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参数字段（见8.2.1）“数据长度”和“计数”用于SDXF函数“提取”和“创建”：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field &#39;dataLength&#39; is the common length of the array elements, &#39;count&#39; is the actual dimension of the array for &#39;create&#39; (input).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字段“dataLength”是数组元素的公共长度，“count”是“create”（输入）数组的实际维度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the &#39;extract&#39; function &#39;count&#39; acts both as an input and output parameter:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于“提取”功能，“计数”同时作为输入和输出参数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Input : the maximum dimension output: the actual array dimension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
输入：最大维度输出：实际数组维度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(If output count is greater than input count, the &#39;data cutted&#39; warning will be responded and the destination array is filled up to the maximum dimension.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（如果输出计数大于输入计数，将响应“数据剪切”警告，并将目标数组填充到最大维度。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Description of the SDXF functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. SDXF函数的说明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following the principles of Object Oriented Programming, not only the description of the data is necessary, but also the functions which manipulate data - the &#34;methods&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遵循面向对象编程的原则，不仅需要对数据进行描述，还需要操作数据的函数“方法”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For the programmer knowing the methods is more important than knowing the data structure, the methods has to know the exact specifications of the data and guarantees the consistence of the data while creating them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于程序员来说，了解方法比了解数据结构更重要，方法必须知道数据的确切规格，并在创建数据时保证数据的一致性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SDXF object is an instance of a parameter structure which acts as a programming interface. Especially it points to an actual SDXF data chunk, and, while processing on this data, there is a pointer to the actual inner chunk which will be the focus for the next operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF对象是作为编程接口的参数结构的实例。特别是它指向一个实际的SDXF数据块，并且在处理该数据时，有一个指向实际内部块的指针，该块将是下一个操作的焦点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The benefit of an exact interface description is the same as using for example the standard C library functions: By using standard interfaces your code remains platform independent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
精确接口描述的好处与使用标准C库函数的好处相同：通过使用标准接口，代码保持平台独立。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 Basic definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2 基本定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1 The SDXF Parameter structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.1 SDXF参数结构
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All SDXF access functions need only one parameter, a pointer to the SDXF parameter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有SDXF访问函数只需要一个参数，即指向SDXF参数结构的指针：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First 3 prerequisite definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前3个先决条件定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef short int      ChunkID;
   typedef unsigned char  Byte;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef short int      ChunkID;
   typedef unsigned char  Byte;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct Chunk
   {
     ChunkID    chunkID;
     Byte       flags;
     char       length [3];
     Byte       data;
   } Chunk;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct Chunk
   {
     ChunkID    chunkID;
     Byte       flags;
     char       length [3];
     Byte       data;
   } Chunk;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
And now the parameter structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在是参数结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct
   {
     ChunkID  chunkID;       // name (ID) of Chunk
     Byte    *container;     // pointer to the whole Chunk
     long     bufferSize;    // size of container
     Chunk   *currChunk;     // pointer to actual Chunk
     long     dataLength;    // length of data in Chunk
     long     maxLength;     // max. length of Chunk for SDX_extract
     long     remainingSize; // rem. size in cont. after SDX_create
     long     value;         // for data type numeric
     double   fvalue;        // for data type float
     char    *function;      // name of the executed SDXF function
     Byte    *data;          // pointer to Data
     Byte    *cryptkey;      // pointer to Crypt Key
     short    count;         // (max.) number of elements in an array
     short    dataType;      // Chunk data type / init open type
     short    ec;            // extended return-code
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct
   {
     ChunkID  chunkID;       // name (ID) of Chunk
     Byte    *container;     // pointer to the whole Chunk
     long     bufferSize;    // size of container
     Chunk   *currChunk;     // pointer to actual Chunk
     long     dataLength;    // length of data in Chunk
     long     maxLength;     // max. length of Chunk for SDX_extract
     long     remainingSize; // rem. size in cont. after SDX_create
     long     value;         // for data type numeric
     double   fvalue;        // for data type float
     char    *function;      // name of the executed SDXF function
     Byte    *data;          // pointer to Data
     Byte    *cryptkey;      // pointer to Crypt Key
     short    count;         // (max.) number of elements in an array
     short    dataType;      // Chunk data type / init open type
     short    ec;            // extended return-code
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     short    rc;            // return-code
     short    level;         // level of hierarchy
     char     filler;        // filler char for SDX_extract
     Byte     encrypt;       // Indication if data to encrypt (0 / 1)
     Byte     compression;   // compression method
                             //   (00=none, 01=RL1, 02=zip/deflate)
   } SDX_obj, *SDX_handle;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     short    rc;            // return-code
     short    level;         // level of hierarchy
     char     filler;        // filler char for SDX_extract
     Byte     encrypt;       // Indication if data to encrypt (0 / 1)
     Byte     compression;   // compression method
                             //   (00=none, 01=RL1, 02=zip/deflate)
   } SDX_obj, *SDX_handle;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Only the &#34;public&#34; fields of the parameter structure which acts as input and output for the SDXF functions is described here. A given implementation may add some &#34;private&#34; fields to this structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此处仅描述作为SDXF函数输入和输出的参数结构的“公共”字段。给定的实现可能会将一些“私有”字段添加到此结构中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2 Basic Functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2.2 基本功能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All these functions works with a SDX_handle as the only formal parameter. Every function returns as output ec and rc as a report of success. For the values for ec, rc and dataType see chap. 8.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有这些函数都使用SDX_句柄作为唯一的形式参数。每个函数作为输出ec返回，rc作为成功报告返回。有关ec、rc和数据类型的值，请参见第8.4章。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. SDX_init : Initialize the parameter structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
1. SDX_init：初始化参数结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
input : container, dataType, bufferSize (for dataType = SDX_NEW only) output: currChunk, dataLength (for dataType = SDX_OLD only), ec, rc, the other fields of the parameter structure will be initialized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
输入：container、dataType、bufferSize（仅适用于dataType=SDX_NEW）输出：currcunk、dataLength（仅适用于dataType=SDX_OLD）、ec、rc，参数结构的其他字段将被初始化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. SDX_enter : Enter a structured chunk. You can access the first chunk inside this structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
2. SDX_enter：输入结构化块。您可以访问此结构化块中的第一个块。输入：无输出：currChunk、chunkID、数据长度、级别、数据类型、ec、rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. SDX_leave : Leave the actual entered structured chunk. input : none output: currChunk, chunkID, dataLength, level, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
3. SDX_leave：保留实际输入的结构化块。输入：无输出：currChunk、chunkID、数据长度、级别、数据类型、ec、rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. SDX_next : Go to the next chunk inside a structured chunk. input : none output: currChunk, chunkID, dataLength, dataType, count, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
4. SDX_next：转到结构化块中的下一块。输入：无输出：currChunk，chunkID，dataLength，dataType，count，ec，rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
At the end of a structured chunk SDX_next returns rc = SDX_RC_failed and ec = SDX_EC_eoc (end of chunk) The actual structured chunk is SDX_leave&#39;d automatically.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
在结构化块的末尾，SDX_next返回rc=SDX_rc_failed和ec=SDX_ec_eoc（块的末尾），实际的结构化块将自动离开。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5. SDX_extract : Extract data of the actual chunk. (If actual chunk is structured, only a copy is done, elsewhere the data is converted to host format.) input / output depends on the dataType:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
5. SDX_extract：提取实际块的数据。（如果实际数据块是结构化的，则只进行复制，其他地方的数据将转换为主机格式。）输入/输出取决于数据类型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if dataType is structured, binary or char: input : data, maxLength, count, filler output: dataLength, count, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果数据类型为结构化、二进制或字符：输入：数据、maxLength、计数、填充输出：dataLength、计数、ec、rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
if dataType is numeric (float resp.): input : none output: value (fvalue resp.), ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
如果数据类型为数字（浮动响应）：输入：无输出：值（fvalue响应），ec，rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6. SDX_select : Go to the (next) chunk with a given chunkID. input : chunkID output: currChunk, dataLength, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
6. SDX_选择：使用给定的chunkID转到（下一个）块。输入：chunkID输出：currChunk、dataLength、dataType、ec、rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7. SDX_create : Creating a new chunk (at the end of the actual structured chunk). input : chunkID, dataLength, data, (f)value, dataType, compression, encrypt, count update: remainingSize, level output: currChunk, dataLength, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
7. SDX_create：创建一个新块（在实际结构化块的末尾）。输入：chunkID，dataLength，数据，（f）值，数据类型，压缩，加密，计数更新：remainingSize，级别输出：currChunk，dataLength，ec，rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8. SDX_append : Append a complete chunk at the end of the actual structured chunk). input : data, maxLength, currChunk update: remainingSize, level output: chunkID, chunkLength, maxLength, dataType, ec, rc
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-4">
8. SDX_append：在实际结构化块的末尾追加一个完整块）。输入：数据，maxLength，currChunk更新：remainingSize，级别输出：chunkID，chunkLength，maxLength，数据类型，ec，rc
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 Definitions for C++
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.3 C++的定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is the specification of the SDXF class in C++: (The type &#39;Byte&#39; is defined as &#34;unsigned char&#34; for bitstrings, opposed to &#34;signed char&#34; for character strings)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是C++中SDXF类的规范：（“Byte”类型对于位字符串定义为“unsigned char”，而对于字符串定义为“signed char”）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
class C_SDXF { public:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类C_SDXF{public:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
// constructors and destructor: C_SDXF (); // dummy C_SDXF (Byte *cont); // old container C_SDXF (Byte *cont, long size); // new container C_SDXF (long size); // new container ~C_SDXF (); // methods:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
//构造函数和析构函数：C_SDXF（）；//虚拟C_SDXF（字节*续）；//旧容器C_SDXF（字节*cont，长尺寸）；//新集装箱C_SDXF（长尺寸）；//新容器~C_SDXF（）；//方法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void init  (void);                   // old container
     void init  (Byte *cont);             // old container
     void init  (Byte *cont, long size);  // new container
     void init  (long size);              // new container
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void init  (void);                   // old container
     void init  (Byte *cont);             // old container
     void init  (Byte *cont, long size);  // new container
     void init  (long size);              // new container
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void enter   (void);
     void leave   (void);
     void next    (void);
     long extract (Byte *data, long length);    // chars, bits
     long extract (void);                       // numeric data
     void create  (ChunkID);                    // structured
     void create  (ChunkID, long value);        // numeric
     void create  (ChunkID, double fvalue);     // float
     void create  (ChunkID, Byte *data, long length);// binary
     void create  (ChunkID, char *data);             // chars
     void set_compression (Byte compression_method);
     void set_encryption  (Byte *encryption_key);
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     void enter   (void);
     void leave   (void);
     void next    (void);
     long extract (Byte *data, long length);    // chars, bits
     long extract (void);                       // numeric data
     void create  (ChunkID);                    // structured
     void create  (ChunkID, long value);        // numeric
     void create  (ChunkID, double fvalue);     // float
     void create  (ChunkID, Byte *data, long length);// binary
     void create  (ChunkID, char *data);             // chars
     void set_compression (Byte compression_method);
     void set_encryption  (Byte *encryption_key);
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
// interface:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
//接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     ChunkID  id;        // see 8.4.1
     short    dataType;  // see 8.4.2
     long     length;    // length of data or chunk
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     ChunkID  id;        // see 8.4.1
     short    dataType;  // see 8.4.2
     long     length;    // length of data or chunk
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     long     value;
     double   fvalue;
     short    rc;  // the raw return code       see 8.4.3
     short    ec;  // the extended return code  see 8.4.4
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     long     value;
     double   fvalue;
     short    rc;  // the raw return code       see 8.4.3
     short    ec;  // the extended return code  see 8.4.4
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
protected: // implementation dependent ...
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
受保护：//依赖于实现。。。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
};
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4 Common Definitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4 共同定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.1 Definition of ChunkID:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.1 ChunkID的定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef short ChunkID;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
typedef短ChunkID；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.2 Values for dataType:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.2 数据类型的值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_DT_inconsistent = 0 SDX_DT_structured = 1 SDX_DT_binary = 2 SDX_DT_numeric = 3 SDX_DT_char = 4 SDX_DT_float = 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_DT_不一致=0 SDX_DT_结构化=1 SDX_DT_二进制=2 SDX_DT_数值=3 SDX_DT_字符=4 SDX_DT_浮点=5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDX_DT_UTF8             = 6
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDX_DT_UTF8             = 6
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 data types for SDX_init: SDX_OLD = 1 SDX_NEW = 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_init的数据类型：SDX_OLD=1 SDX_NEW=2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.3 Values for rc:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.3 rc的值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_RC_ok = 0 SDX_RC_failed = 1 SDX_RC_warning = 1 SDX_RC_illegalOperation = 2 SDX_RC_dataError = 3 SDX_RC_parameterError = 4 SDX_RC_programError = 5 SDX_RC_noMemory = 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDX_RC_ok=0 SDX_RC_failed=1 SDX_RC_warning=1 SDX_RC_illegalOperation=2 SDX_RC_dataError=3 SDX_RC_参数Error=4 SDX_RC_programError=5 SDX_RC_Nomenomery=6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.4 Values for ec:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
8.4.4 ec值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDX_EC_ok              =  0
   SDX_EC_eoc             =  1 // end of chunk
   SDX_EC_notFound        =  2
   SDX_EC_dataCutted      =  3
   SDX_EC_overflow        =  4
   SDX_EC_wrongInitType   =  5
   SDX_EC_comprerr        =  6 // compression error
   SDX_EC_forbidden       =  7
   SDX_EC_unknown         =  8
   SDX_EC_levelOvflw      =  9
   SDX_EC_paramMissing    = 10
   SDX_EC_magicError      = 11
   SDX_EC_not_consistent  = 12
   SDX_EC_wrongDataType   = 13
   SDX_EC_noMemory        = 14
   SDX_EC_error           = 99 // rc is sufficiently
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDX_EC_ok              =  0
   SDX_EC_eoc             =  1 // end of chunk
   SDX_EC_notFound        =  2
   SDX_EC_dataCutted      =  3
   SDX_EC_overflow        =  4
   SDX_EC_wrongInitType   =  5
   SDX_EC_comprerr        =  6 // compression error
   SDX_EC_forbidden       =  7
   SDX_EC_unknown         =  8
   SDX_EC_levelOvflw      =  9
   SDX_EC_paramMissing    = 10
   SDX_EC_magicError      = 11
   SDX_EC_not_consistent  = 12
   SDX_EC_wrongDataType   = 13
   SDX_EC_noMemory        = 14
   SDX_EC_error           = 99 // rc is sufficiently
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5 Special functions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.5 特殊功能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Besides the basic definitions there is a global function (SDX_getOptions) which returns a pointer to a global table of options.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了基本定义之外，还有一个全局函数（SDX_getOptions），它返回指向全局选项表的指针。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the help of these options you can adapt the behaviour of SDXF. Especially you can define an alternative pair of translation tables or an alternative function which reads these tables from an external resource (p.e. from disk).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
借助这些选项，您可以调整SDXF的行为。特别是，您可以定义一对可选的转换表或从外部资源（即从磁盘）读取这些表的可选函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Within this table of options there is also a pointer to the function which is used for encryption / decryption: You can install your own encryption algorithm by setting this pointer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在此选项表中，还有一个指向用于加密/解密的函数的指针：您可以通过设置此指针安装自己的加密算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The options pointer is received by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项指针由以下人员接收：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDX_TOptions *opt = SDX_getOptions ();
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   SDX_TOptions *opt = SDX_getOptions ();
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct
   {
    Byte            *toHost;        // Trans tab net -&gt; host
    Byte            *toNet;         // Trans tab host -&gt; net
    int              maxlevel;      // highest possible level
    int              translation;   // translation net &lt;-&gt; host
                                    // is in effect=1 or not=0
    TEncryptProc    *encryptProc;   // alternate encryption routine
    TGetTablesProc  *getTablesProc; // alternate routine defining
                                    // translation Tables
    TcvtUTF8Proc    *convertUTF8;   // routine to convert to/from UTF-8
   }  SDX_TOptions;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef struct
   {
    Byte            *toHost;        // Trans tab net -&gt; host
    Byte            *toNet;         // Trans tab host -&gt; net
    int              maxlevel;      // highest possible level
    int              translation;   // translation net &lt;-&gt; host
                                    // is in effect=1 or not=0
    TEncryptProc    *encryptProc;   // alternate encryption routine
    TGetTablesProc  *getTablesProc; // alternate routine defining
                                    // translation Tables
    TcvtUTF8Proc    *convertUTF8;   // routine to convert to/from UTF-8
   }  SDX_TOptions;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef long TencryptProc (
     int   mode,   // 1= to encrypt, 2= to decrypt, 3= encrypted length
     Byte *buffer, // data to en/decrypt
     long  len,    // len: length of buffer
     char *passw); // Password
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef long TencryptProc (
     int   mode,   // 1= to encrypt, 2= to decrypt, 3= encrypted length
     Byte *buffer, // data to en/decrypt
     long  len,    // len: length of buffer
     char *passw); // Password
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    // returns length of en/de-crypted data
    // (parameter buffer and passw are ignored for mode=3)
    // returns blocksize for mode=3 and len=0.
    // blocksize is zero for non-blocking algorithms
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    // returns length of en/de-crypted data
    // (parameter buffer and passw are ignored for mode=3)
    // returns blocksize for mode=3 and len=0.
    // blocksize is zero for non-blocking algorithms
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef int TGetTablesProc (Byte **toNet, Byte **toHost);
    // toNet, toHost: pointer to output params.  Both params
    // points to translation tables of 256 Bytes.
    // returns success: 1 = ok, 0 = error.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef int TGetTablesProc (Byte **toNet, Byte **toHost);
    // toNet, toHost: pointer to output params.  Both params
    // points to translation tables of 256 Bytes.
    // returns success: 1 = ok, 0 = error.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef int TcvtUTF8Proc
   ( int   mode,     // 1 = to UTF-8, 2 = from UTF-8
     Byte *target, int *targetlength,  // output
     Byte *source, int sourcelength);  // input
   // targetlength contains maximal size as input param.
   // returns success: 1 = ok, 0 = no conversion
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   typedef int TcvtUTF8Proc
   ( int   mode,     // 1 = to UTF-8, 2 = from UTF-8
     Byte *target, int *targetlength,  // output
     Byte *source, int sourcelength);  // input
   // targetlength contains maximal size as input param.
   // returns success: 1 = ok, 0 = no conversion
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
9. &#39;Support&#39; of UTF-8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
9. UTF-8的“支持”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many systems supports [UTF-8] as a character format for transferred data. The benefit is that no fixing of a specific character set for an application is needed because the set of &#39;all&#39; characters is used, represented by the &#39;Universal Character Set&#39; UCS-2 [UCS], a double byte coding for characters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
许多系统支持[UTF-8]作为传输数据的字符格式。好处是不需要为应用程序修复特定字符集，因为使用了“所有”字符集，由“通用字符集”UCS-2[UCS]表示，这是字符的双字节编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF does not really deal with UTF-8 by itself, there are many possibilities to interprete an UTF-8 sequence: The application may:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF本身并不能真正处理UTF-8，有许多可能解释UTF-8序列：应用程序可能：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- reconstruct the UCS-2 sequence, - accepts only the pure ASCII character and maps non-ASCII to a special &#39;non-printable&#39; character. - target is pure ASCII, non-ASCII is replaced in a senseful manner (French accented vowels replaced by vowels without accents, etc.). - target is a specific ANSI character set, the non-ASCII chars are mapped as possible, other replaced to a &#39;non-printable&#39;. - etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 重建UCS-2序列，-仅接受纯ASCII字符，并将非ASCII映射到特殊的“不可打印”字符。-目标是纯ASCII，非ASCII以有意义的方式替换（法语重音元音替换为无重音元音，等等）目标是一个特定的ANSI字符集，非ASCII字符尽可能映射，其他字符替换为“不可打印”等
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
But SDXF offers an interface for the &#39;extract&#39; and &#39;create&#39; functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
但SDXF为“提取”和“创建”功能提供了接口：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A function pointer may be specified in the options table to maintain this possibility (see 8.5). Default for this pointer is NULL: No further conversions are done by SDXF, the data are copied &#39;as is&#39;, it is treated as a bit string as for data type &#39;binary&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可在选项表中指定函数指针，以保持这种可能性（见8.5）。此指针的默认值为NULL：SDXF不进行进一步的转换，数据按“原样”复制，与数据类型“二进制”一样，它被视为位字符串。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If this function is specified, it is used by the &#39;create&#39; function with the &#39;toUTF8&#39; mode, and by the &#39;extract&#39; function with the &#39; fromUTF8&#39; mode. The invoking of these functions is done by SDXF transparently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果指定了此函数，“创建”函数使用“toUTF8”模式，而“提取”函数使用“fromUTF8”模式。这些函数的调用由SDXF透明地完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the function returns zero (no conversion) SDXF copies the data without conversion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果函数返回零（无转换），SDXF将复制数据而不进行转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any corruption of data in the chunk headers denounce the complete SDXF structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
区块头中的任何数据损坏都表明完整的SDXF结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any corruption of data in a encrypted or compressed SDXF structure makes this chunk unusable. An integrity check after decryption or decompression should be done by the &#34;enter&#34; function.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加密或压缩的SDXF结构中的任何数据损坏都会导致此块不可用。解密或解压缩后的完整性检查应由“enter”函数完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While using TCP/IP (more precisely: IP) as a transmission medium we can trust on his CRC check on the transport layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当使用TCP/IP（更准确地说：IP）作为传输介质时，我们可以信任他在传输层上的CRC检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Some general hints
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 一些一般提示
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A consistent construction of a SDXF structure is done if every &#34;create&#34; to a structured chunk is closed by a paired &#34;leave&#34;. While a structured chunk is under construction, his data type is set to zero - that means: this chunk is inconsistent. The SDX_leave function sets the datatype to &#34;structured&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 如果对结构化块的每个“创建”都被成对的“离开”关闭，那么就完成了SDXF结构的一致构造。当一个结构化块正在构建时，他的数据类型被设置为零——这意味着：这个块是不一致的。SDX_leave函数将数据类型设置为“结构化”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. While creating an elementary chunk a platform dependent transformation to a platform independent format of the data is performed - at the end of construction the content of the buffer is ready to transport to another site, without any further translation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 在创建基本块时，将执行平台相关的数据转换为平台无关的数据格式-在构建结束时，缓冲区的内容准备好传输到另一个站点，而无需进一步翻译。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. As you see no data definition in your programming language is needed for to construct a specific SDXF structure. The data is created dynamically by function calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 正如您所见，构建特定的SDXF结构不需要编程语言中的数据定义。数据是通过函数调用动态创建的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. With SDXF as a base you can define protocols for client / server applications. These protocols may be extended in downward compatibility manner by following two rules:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 以SDXF为基础，您可以为客户机/服务器应用程序定义协议。这些协议可以通过以下两条规则以向下兼容的方式扩展：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Rule 1: Ignore unknown chunkIDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
规则1：忽略未知的chunkID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Rule 2: The sequence of chunks should not be significant.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
规则2：组块的顺序不应该很重要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. IANA考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compression and encryption algorithms for SDXF is not fixed, SDXF is open for various algorithms. Therefore an agreement is necessary to interprete the compression and encryption algorithm method numbers. (Encryption methods are not a semantic part of SDXF, but may be used for a connection protocol to negotiate the encryption method to use.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SDXF的压缩和加密算法不是固定的，SDXF对各种算法开放。因此，有必要达成协议来解释压缩和加密算法方法编号。（加密方法不是SDXF的语义部分，但可用于连接协议，以协商要使用的加密方法。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following two items are registered by IANA:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA注册了以下两个项目：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 COMPRESSION METHODS FOR SDXF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.1 SDXF的压缩方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The compressed SDXF chunk starts with a &#34;compression header&#34;. This header contains the compression method as an unsigned 1-Byte integer (1-255). These numbers are assigned by IANA and listed here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
压缩的SDXF块以“压缩头”开头。此标头将压缩方法包含为无符号1字节整数（1-255）。这些编号由IANA分配，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   compression
    method     Description                     Hints
   ---------   ------------------------------- -------------
         01    RUN-LENGTH algorithm            see chap. 5
         02    DEFLATE (ZIP)                   see [DEFLATE]
     03-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   compression
    method     Description                     Hints
   ---------   ------------------------------- -------------
         01    RUN-LENGTH algorithm            see chap. 5
         02    DEFLATE (ZIP)                   see [DEFLATE]
     03-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 ENCRYPTION METHODS FOR SDXF
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12.2 SDXF的加密方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An unique encryption method is fixed or negotiated by handshaking. For the latter one a number for each encryption method is necessary. These numbers are unsigned 1-Byte integers (1-255). These numbers are assigned by IANA and listed here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一的加密方法是固定的或通过握手协商的。对于后者，每种加密方法都需要一个数字。这些数字是无符号1字节整数（1-255）。这些编号由IANA分配，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   encryption
     method    Description
    ---------  ------------------------------
     01-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   encryption
     method    Description
    ---------  ------------------------------
     01-239    IANA to assign
    240-255    private or application specific
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.3 Hints for assigning a number:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
12.3 分配号码的提示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Developers which want to register a compression or encrypt method for SDXF should contact IANA for a method number. The ASSIGNED NUMBERS document should be referred to for a current list of METHOD numbers and their corresponding protocols, see [IANA]. The new method SHOULD be a standard published as a RFC or by a established standardization organization (as OSI).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
希望为SDXF注册压缩或加密方法的开发人员应联系IANA以获取方法编号。有关方法编号及其相应协议的当前列表，请参考分配编号文件，请参见[IANA]。新方法应为RFC或已建立的标准化组织（OSI）发布的标准。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Discussion
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 讨论
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are already some standards for Internet data exchanging, IETF prefers ASN.1 and XML therefore. So the reasons for establish a new data format should be discussed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
互联网数据交换已经有了一些标准，因此IETF更喜欢ASN.1和XML。因此，应该讨论建立新数据格式的原因。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1 SDXF vs. ASN.1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1 SDXF与ASN.1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The demand of ASN.1 (see [ASN.1]) is to serve program language independent means to define data structures. The real data format which is used to send the data is not defined by ASN.1 but usually BER or PER (or some derivates of them like CER and DER) are used in this context, see [BER] and [PER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1（参见[ASN.1]）的要求是提供独立于程序语言的方法来定义数据结构。ASN.1未定义用于发送数据的实际数据格式，但在此上下文中通常使用BER或PER（或CER和DER等其派生形式），请参见[BER]和[PER]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The idea behind ASN.1 is: On every platform on which a given application is to develop descriptions of the used data structures are available in ASN.1 notation. Out off these notations the real language dependent definitions are generated with the help of an ASN.1-compiler.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1背后的思想是：在每个平台上，给定的应用程序都可以在ASN.1符号中描述所使用的数据结构。在ASN.1编译器的帮助下，除了这些符号外，真正的语言相关定义是生成的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This compiler generates also transform functions for these data structures for to pack and unpack to and from the BER (or other) format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该编译器还为这些数据结构生成转换函数，以便在BER（或其他）格式之间进行打包和解包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A direct comparison between ASN.1 and SDXF is somehow inappropriate: The data format of SDXF is related rather to BER (and relatives). The use of ASN.1 to define data structures is no contradiction to SDXF, but: SDXF does not require a complete data structure to build the message to send, nor a complete data structure will be generated out off the received message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
直接比较ASN.1和SDXF在某种程度上是不合适的：SDXF的数据格式与误码率（BER）相关。使用ASN.1定义数据结构与SDXF并不矛盾，但是：SDXF不需要完整的数据结构来构建要发送的消息，也不需要从接收到的消息中生成完整的数据结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The main difference lies in the concept of building and interpretation of the message, I want to name it the &#34;static&#34; and &#34;dynamic&#34; concept:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主要区别在于信息的构建和解释概念，我想将其命名为“静态”和“动态”概念：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ASN.1 uses a &#34;static&#34; approach: The whole data structure must exists before the message can be created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ASN.1使用“静态”方法：在创建消息之前，必须存在整个数据结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXF constructs and interpretes the message in a &#34;dynamic&#34; way, the message will be packed and unpacked step by step by SDXF functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXF以“动态”的方式构造和解释消息，消息将通过SDXF函数逐步打包和解包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of static structures may be appropriate for a series of applications, but for complex tasks it is often impossible to define the message as a whole. As an example try to define an ASN.1 description for a complex structured text document which is presented in XML: There are sections and paragraphs and text elements which may recursively consist of sections with specific text attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
静态结构的使用可能适用于一系列应用程序，但对于复杂任务，通常不可能将消息定义为一个整体。例如，尝试为以XML表示的复杂结构化文本文档定义ASN.1描述：有节、段落和文本元素，它们可能递归地由具有特定文本属性的节组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2 SDXF vs. XML
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2 SDXF与XML
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On the one hand SDXF and XML are similar as they can handle any recursive complex data stream. The main difference is the kind of data which are to be maintained:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一方面，SDXF和XML很相似，因为它们可以处理任何递归的复杂数据流。主要区别在于需要维护的数据类型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XML works with pure text data (though it should be noted that the character representation is not standardized by XML). And: a XML document with all his tags is readable by human. Binary data as graphic is not included directly but may be referenced by an external link as in HTML.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o XML使用纯文本数据（尽管应该注意，字符表示不是XML标准化的）。而且：一个包含所有his标记的XML文档是可读的。作为图形的二进制数据不直接包括在内，但可以通过HTML中的外部链接引用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In XML there is no strong separation between informational and control data, escape characters (like &#34;&lt;&#34; and &#34;&amp;&#34;) and the &lt;![CDATA[...]]&gt; construction are used to distinguish between these two types of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在XML中，信息数据和控制数据、转义字符（如“&lt;”和“&amp;”）和&lt;之间没有很强的分离！[CDATA[…]]&gt;构造用于区分这两种类型的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXF maintains machine-readable data, it is not designed to be readable by human nor to edit SDXF data with a text editor (even more if compression and encryption is used). With the help of the SDXF functions you have a quick and easy access to every data element. The standard parser for a SDXF data structure follows always a simple template, the &#34;while - switch -case ID - enter/extract&#34; pattern as outlined in chap. 3.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SDXF维护机器可读的数据，它不是为人类可读而设计的，也不是为使用文本编辑器编辑SDXF数据而设计的（如果使用压缩和加密，则更是如此）。借助SDXF函数，您可以快速轻松地访问每个数据元素。SDXF数据结构的标准解析器始终遵循一个简单的模板，“while-switch-case ID-enter/extract”模式，如第3.4.2章所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because of the complete different philosophy behind XML and SDXF (and even ASN.1) a direct comparison may not be very senseful, as XML has its own right to exist next to ASN.1 (and even SDXF).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于XML和SDXF（甚至是ASN.1）背后的理念完全不同，直接比较可能不是很有意义，因为XML有它自己的权利存在于ASN.1（甚至是SDXF）的旁边。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nevertheless there is a chance to convert a XML data stream into a SDXF structure: As a first strike, every XML tag becomes a SDXF chunk ID. An elementary sequence &lt;tag&gt;pure text&lt;/tag&gt; can be transformed into an elementary (non-structured) chunk with data type &#34;character&#34;. Tags with attributes and sequences with nested tags are transformed into structured chunks. Because XML allows a tag sequence everywhere in a text stream, an artificially &#34;elementary text&#34; tag must be introduced: If &lt;t&gt; is the tag for text elements, the sequence:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管如此，还是有机会将XML数据流转换为SDXF结构：首先，每个XML标记都成为SDXF块ID。基本序列&lt;tag&gt;纯文本&lt;tag&gt;可以转换为数据类型为“character”的基本（非结构化）块。将具有属性的标记和具有嵌套标记的序列转换为结构化块。由于XML允许标记序列在文本流中的任何位置，因此必须引入人工的“基本文本”标记：如果&lt;t&gt;是文本元素的标记，则序列：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   &lt;t&gt;this is a text &lt;attr value=&#39;bold&#39;&gt;with&lt;/attr&gt; attributes&lt;/t&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   &lt;t&gt;this is a text &lt;attr value=&#39;bold&#39;&gt;with&lt;/attr&gt; attributes&lt;/t&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is to be &#34;in thought&#34; replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将“思考中”替换为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   &lt;t&gt;&lt;et&gt;this is a text &lt;/et&gt;&lt;attr value=&#39;bold&#39;&gt;&lt;et&gt;with&lt;/et&gt;&lt;/attr&gt;
   &lt;et&gt; attributes&lt;/et&gt;&lt;/t&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   &lt;t&gt;&lt;et&gt;this is a text &lt;/et&gt;&lt;attr value=&#39;bold&#39;&gt;&lt;et&gt;with&lt;/et&gt;&lt;/attr&gt;
   &lt;et&gt; attributes&lt;/et&gt;&lt;/t&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(With &#34;et&#34; as the &#34;elementary text&#34; tag)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（将“et”作为“基本文本”标记）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This results in following SDXF structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这将导致以下SDXF结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ID_t
   |
   +-- ID_et = &#34; this is a text &#34;
   |
   +-- ID_attr
   |   |
   |   +-- ID_value = &#34;bold&#34;
   |   |
   |   +-- ID_et = &#34;with&#34;
   |
   +-- ID_et = &#34; attributes&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ID_t
   |
   +-- ID_et = &#34; this is a text &#34;
   |
   +-- ID_attr
   |   |
   |   +-- ID_value = &#34;bold&#34;
   |   |
   |   +-- ID_et = &#34;with&#34;
   |
   +-- ID_et = &#34; attributes&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID_t and ID_et may be represented by the same chunk ID, only distinguished by the data type (&#34;structured&#34; for &lt;t&gt; and &#34;character&#34; for &lt;et&gt;)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID_t和ID_et可以由相同的块ID表示，仅通过数据类型（“结构化”表示&lt;t&gt;，而“字符”表示&lt;et&gt;）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Binary data as pictures can be directly imbedded into a SDXF structure instead referencing them as an external link like in HTML.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为图片的二进制数据可以直接嵌入到SDXF结构中，而不是像HTML中那样作为外部链接引用它们。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. Author&#39;s Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. 作者地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Max Wildgrube Schlossstrasse 120 60486 Frankfurt Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
德国法兰克福MaxWildgrube Schlossstrasse 120 60486
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: max@wildgrube.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: max@wildgrube.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I would like to thank Michael J. Slifcak (mslifcak@iss.net) for the supporting discussions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我要感谢Michael J.Slifcak(mslifcak@iss.net)支持讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASN.1] Information processing systems - Open Systems Interconnection, &#34;Specification of Abstract Syntax Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8824, December 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASN.1]信息处理系统-开放系统互连，“抽象语法符号1规范（ASN.1）”，国际标准化组织，国际标准88241987年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BER] Information Processing Systems - Open Systems Interconnection - &#34;Specification of Basic Encoding Rules for Abstract Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8825-1, December 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BER]信息处理系统-开放系统互连-“抽象符号1（ASN.1）基本编码规则规范”，国际标准化组织，国际标准8825-11987年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DEFLATE] Deutsch, P., &#34;DEFLATE Compressed Data Format Specification version 1.3&#34;, RFC 1951, May 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DEFLATE]Deutsch，P.，“DEFLATE压缩数据格式规范1.3版”，RFC1951，1996年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [IANA]    Internet Assigned Numbers Authority,
             http://www.iana.org/numbers.htm
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   [IANA]    Internet Assigned Numbers Authority,
             http://www.iana.org/numbers.htm
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PER] Information Processing Systems - Open Systems Interconnection -&#34;Specification of Packed Encoding Rules for Abstract Syntax Notation One (ASN.1)&#34;, International Organization for Standardization, International Standard 8825-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[PER]信息处理系统-开放系统互连-“抽象语法符号1（ASN.1）的压缩编码规则规范”，国际标准化组织，国际标准8825-2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UCS] ISO/IEC 10646-1:1993. International Standard -- Information technology -- Universal Multiple-Octet Coded Character Set (UCS)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UCS]ISO/IEC 10646-1:1993。国际标准信息技术通用多八位编码字符集（UCS）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UTF8] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, RFC 2279, January 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UTF8]Yergeau，F.，“UTF-8，ISO 10646的转换格式”，RFC 2279，1998年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. 完整版权声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2001). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2001年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
确认
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC编辑功能的资金目前由互联网协会提供。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
