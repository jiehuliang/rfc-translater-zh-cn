<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RFC 6369: Forwarding and Control Element Separation (ForCES) Implementation Experience 中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC Trans</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="privacy-policy.html">Privacy Policy</a>
        <a class="nav-item nav-link" href="contact.html">Contact</a>
        <a class="nav-item nav-link" href="../figs/html/index.html">Figs</a>
      </div>
      <div class="navbar-nav ml-auto">
        <span class="navbar-text"><small>@tex2e</small></span>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6369</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6369">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h4 class="alert-heading">RFC 6369: Forwarding and Control Element Separation (ForCES) Implementation Experience 中文翻译</h4>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc6369">
              https://datatracker.ietf.org/doc/html/rfc6369
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 6369</strong></span><br>
          <span class="updated_by">翻译编辑 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                     E. Haleplidis
Request for Comments: 6369                                O. Koufopavlou
Category: Informational                                       S. Denazis
ISSN: 2070-1721                                     University of Patras
                                                          September 2011
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                     E. Haleplidis
Request for Comments: 6369                                O. Koufopavlou
Category: Informational                                       S. Denazis
ISSN: 2070-1721                                     University of Patras
                                                          September 2011
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
Forwarding and Control Element Separation (ForCES) Implementation Experience
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
转发和控制元素分离（ForCES）实施经验
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Control Element Separation (ForCES) protocol defines a standard communication and control mechanism through which a Control Element (CE) can control the behavior of a Forwarding Element (FE). This document captures the experience of implementing the ForCES protocol and model. Its aim is to help others by providing examples and possible strategies for implementing the ForCES protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发和控制元素分离（ForCES）协议定义了一种标准的通信和控制机制，通过该机制，控制元素（CE）可以控制转发元素（FE）的行为。本文件总结了实施部队协议和模型的经验。其目的是通过提供实施《部队议定书》的实例和可能的战略来帮助他人。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is not an Internet Standards Track specification; it is published for informational purposes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件不是互联网标准跟踪规范；它是为了提供信息而发布的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。并非IESG批准的所有文件都适用于任何级别的互联网标准；见RFC 5741第2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6369.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc6369.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（c）2011 IETF信托基金和确定为文件作者的人员。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从该文档中提取的代码组件必须
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包括信托法律条款第4.e节中所述的简化BSD许可证文本，且不提供简化BSD许可证中所述的担保。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
     1.1.  Document Goal  . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Terminology and Conventions  . . . . . . . . . . . . . . . . .  3
   3.  ForCES Architecture  . . . . . . . . . . . . . . . . . . . . .  4
     3.1.  Pre-Association Setup - Initial Configuration  . . . . . .  5
     3.2.  TML  . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     3.3.  Model  . . . . . . . . . . . . . . . . . . . . . . . . . .  6
       3.3.1.  Components . . . . . . . . . . . . . . . . . . . . . .  6
       3.3.2.  LFBs . . . . . . . . . . . . . . . . . . . . . . . . .  9
     3.4.  Protocol . . . . . . . . . . . . . . . . . . . . . . . . . 10
       3.4.1.  TLVs . . . . . . . . . . . . . . . . . . . . . . . . . 10
       3.4.2.  Message Deserialization  . . . . . . . . . . . . . . . 13
       3.4.3.  Message Serialization  . . . . . . . . . . . . . . . . 15
   4.  Development Platforms  . . . . . . . . . . . . . . . . . . . . 15
   5.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 16
   6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16
   7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 17
     7.1.  Normative References . . . . . . . . . . . . . . . . . . . 17
     7.2.  Informative References . . . . . . . . . . . . . . . . . . 17
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
     1.1.  Document Goal  . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Terminology and Conventions  . . . . . . . . . . . . . . . . .  3
   3.  ForCES Architecture  . . . . . . . . . . . . . . . . . . . . .  4
     3.1.  Pre-Association Setup - Initial Configuration  . . . . . .  5
     3.2.  TML  . . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     3.3.  Model  . . . . . . . . . . . . . . . . . . . . . . . . . .  6
       3.3.1.  Components . . . . . . . . . . . . . . . . . . . . . .  6
       3.3.2.  LFBs . . . . . . . . . . . . . . . . . . . . . . . . .  9
     3.4.  Protocol . . . . . . . . . . . . . . . . . . . . . . . . . 10
       3.4.1.  TLVs . . . . . . . . . . . . . . . . . . . . . . . . . 10
       3.4.2.  Message Deserialization  . . . . . . . . . . . . . . . 13
       3.4.3.  Message Serialization  . . . . . . . . . . . . . . . . 15
   4.  Development Platforms  . . . . . . . . . . . . . . . . . . . . 15
   5.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 16
   6.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16
   7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 17
     7.1.  Normative References . . . . . . . . . . . . . . . . . . . 17
     7.2.  Informative References . . . . . . . . . . . . . . . . . . 17
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forwarding and Control Element Separation (ForCES) defines an architectural framework and associated protocols to standardize information exchange between the control plane and the forwarding plane in a ForCES Network Element (ForCES NE). [RFC3654] defines the ForCES requirements, and [RFC3746] defines the ForCES framework.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发和控制元素分离（ForCES）定义了一个体系结构框架和相关协议，以标准化ForCES网元（ForCES NE）中控制平面和转发平面之间的信息交换。[RFC3654]定义了部队需求，[RFC3746]定义了部队框架。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ForCES protocol works in a master-slave mode in which Forwarding Elements (FEs) are slaves and Control Elements (CEs) are masters. The protocol includes commands for transport of Logical Functional Block (LFB) configuration information, association setup, status, and event notifications, etc. The reader is encouraged to read the Forwarding and Control Element Separation Protocol [RFC5810] for further information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ForCES协议在主从模式下工作，其中转发元素（FEs）是从元素，控制元素（ce）是主元素。该协议包括用于传输逻辑功能块（LFB）配置信息、关联设置、状态和事件通知等的命令。建议读者阅读转发和控制元件分离协议[RFC5810]以了解更多信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5812] presents a formal way to define FE LFBs using XML. LFB configuration components, capabilities, and associated events are defined when LFBs are formally created. The LFBs within the Forwarding Element (FE) are accordingly controlled in a standardized way by the ForCES protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5812]提供了一种使用XML定义FE LFB的正式方法。LFB配置组件、功能和相关事件在正式创建LFB时定义。转发元件（FE）内的LFB相应地由ForCES协议以标准化方式控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Transport Mapping Layer (TML) transports the protocol messages. The TML is where the issues of how to achieve transport-level reliability, congestion control, multicast, ordering, etc., are handled. It is expected that more than one TML will be standardized. The various possible TMLs could vary their implementations based on the capabilities of underlying media and transport. However, since each TML is standardized, interoperability is guaranteed as long as both endpoints support the same TML. All ForCES protocol layer implementations must be portable across all TMLs. Although more than one TML may be standardized for the ForCES protocol, all ForCES implementations must implement the Stream Control Transmission Protocol (SCTP) TML [RFC5811].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
传输映射层（TML）传输协议消息。TML是处理如何实现传输级可靠性、拥塞控制、多播、排序等问题的地方。预计不止一个TML将标准化。各种可能的TML可以根据底层媒体和传输的能力而改变其实现。但是，由于每个TML都是标准化的，只要两个端点都支持相同的TML，就可以保证互操作性。所有部队协议层实现必须可移植到所有TML。尽管可以为ForCES协议标准化多个TML，但所有ForCES实施必须实现流控制传输协议（SCTP）TML[RFC5811]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Control Element Separation Applicability Statement [RFC6041] captures the applicable areas in which ForCES can be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发和控制元件分离适用性声明[RFC6041]捕获了可使用力的适用区域。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Document Goal
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 文件目标
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document captures the experience of implementing the ForCES protocol and model, and its main goal is to provide alternatives, ideas, and proposals as how it can be implemented, not to tell others how to implement it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件收集了实施部队协议和模型的经验，其主要目标是提供替代方案、想法和建议，说明如何实施，而不是告诉其他人如何实施。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, this document mentions possible problems and potential choices that can be made, in an attempt to help implementors develop their own products.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，本文档还提到了可能存在的问题和可能做出的选择，以帮助实施者开发他们自己的产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, this document assumes that the reader has become familiar with the three main ForCES RFCs: the Forwarding and Control Element Separation Protocol [RFC5810], the Forwarding and Control Element Separation Forwarding Element Model [RFC5812], and the SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation Protocol [RFC5811].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，本文档假设读者已经熟悉三种主要力量RFC：转发和控制元素分离协议[RFC5810]、转发和控制元素分离转发元素模型[RFC5812]和基于SCTP的传输映射层（TML）用于转发和控制元素分离协议[RFC5811]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology and Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 术语和公约
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The terminology used in this document is the same as in the Forwarding and Control Element Separation Protocol [RFC5810]; some of the definitions below are copied from that document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中使用的术语与转发和控制元件分离协议[RFC5810]中的术语相同；下面的一些定义是从该文档中复制的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Control Element (CE): A logical entity that implements the ForCES protocol and uses it to instruct one or more FEs on how to process packets. CEs handle functionality such as the execution of control and signaling protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
控制元素（CE）：实现ForCES协议并使用它指示一个或多个FEs如何处理数据包的逻辑实体。CEs处理控制和信令协议的执行等功能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forwarding Element (FE): A logical entity that implements the ForCES protocol. FEs use the underlying hardware to provide per-packet processing and handling as directed/controlled by one or more CEs via the ForCES protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发元素（FE）：实现ForCES协议的逻辑实体。FEs使用底层硬件，按照一个或多个CE通过ForCES协议的指示/控制，提供每包处理和处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFB (Logical Functional Block): The basic building block that is operated on by the ForCES protocol. The LFB is a well-defined, logically separable functional block that resides in an FE and is controlled by the CE via the ForCES protocol. The LFB may reside at the FE&#39;s data path and process packets or may be purely an FE control or configuration entity that is operated on by the CE. Note that the LFB is a functionally accurate abstraction of the FE&#39;s processing capabilities but not a hardware-accurate representation of the FE implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFB（逻辑功能块）：由ForCES协议操作的基本构建块。LFB是一个定义良好、逻辑上可分离的功能块，位于FE中，由CE通过ForCES协议控制。LFB可以驻留在FE的数据路径上并处理分组，或者可以是由CE操作的纯粹FE控制或配置实体。请注意，LFB是FE处理能力的功能精确抽象，但不是FE实现的硬件精确表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFB Class and LFB Instance: LFBs are categorized by LFB classes. An LFB instance represents an LFB class (or type) existence. There may be multiple instances of the same LFB class (or type) in an FE. An LFB class is represented by an LFB class ID, and an LFB instance is represented by an LFB instance ID. As a result, an LFB class ID associated with an LFB instance ID uniquely specifies an LFB existence.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFB类和LFB实例：LFB按LFB类分类。LFB实例表示LFB类（或类型）的存在。FE中可能存在同一LFB类（或类型）的多个实例。LFB类由LFB类ID表示，LFB实例由LFB实例ID表示。因此，与LFB实例ID关联的LFB类ID唯一地指定LFB的存在。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFB Component: Operational parameters of the LFBs that must be visible to the CEs are conceptualized in the FE model as the LFB components. The LFB components include, for example, flags, single parameter arguments, complex arguments, and tables that the CE can read and/or write via the ForCES protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFB组件：CEs必须可见的LFB操作参数在FE模型中被概念化为LFB组件。LFB组件包括，例如，标志、单参数参数参数、复杂参数以及CE可以通过ForCES协议读取和/或写入的表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ForCES Protocol: While there may be multiple protocols used within the overall ForCES architecture, the terms &#34;ForCES protocol&#34; and &#34;protocol&#34; refer to the Fp reference points in the ForCES framework [RFC3746]. This protocol does not apply to CE-to-CE communication, FE-to-FE communication, or communication between FE and CE Managers. Basically, the ForCES protocol works in a master-slave mode in which FEs are slaves and CEs are masters. This document defines the specifications for this ForCES protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部队协议：虽然在整个部队体系结构中可能使用多个协议，但术语“部队协议”和“协议”指的是部队框架中的Fp参考点[RFC3746]。本协议不适用于CE-to-CE通信、FE-to-FE通信或FE与CE经理之间的通信。基本上，ForCES协议在主-从模式下工作，其中FEs是从机，ce是主机。本文件定义了本协议的规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. ForCES Architecture
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 部队建筑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ForCES has undergone two successful interoperability tests, where very few issues were caught and resolved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部队已经经历了两次成功的互操作性测试，很少发现和解决问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses the ForCES architecture, implementation challenges, and ways to overcome these challenges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节讨论了ForCES体系结构、实施挑战以及克服这些挑战的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Pre-Association Setup - Initial Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 预关联设置-初始配置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The initial configuration of the FE and the CE is done by the FE Manager and the CE Manager, respectively. These entities have not as yet been standardized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FE和CE的初始配置分别由FE管理器和CE管理器完成。这些实体尚未标准化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The simplest solution is static configuration files, which play the role of the Managers and are read by FEs and CEs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最简单的解决方案是静态配置文件，它扮演管理器的角色，由FEs和CEs读取。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more dynamic solutions, however, it is expected that the Managers will be entities that will talk to each other and exchange details regarding the associations. Any developer can create any Manager, but they should at least be able to exchange the details below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，对于更具动态性的解决方案，预期管理者将是相互交谈并交换有关关联的详细信息的实体。任何开发人员都可以创建任何经理，但他们至少应该能够交换以下详细信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the FE Manager side:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FE经理方面：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. FE Identifiers (FEIDs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. FE标识符（FEID）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. FE IP addresses, if the FEs and CEs will be communicating via network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. FE IP地址，如果FEs和CEs将通过网络进行通信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TML. The TML that will be used. If this is omitted, then SCTP must be chosen as default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TML。将使用的TML。如果省略此项，则必须选择SCTP作为默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. TML priority ports. If this is omitted as well, then the CE must use the default values from the respective TML RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. TML优先端口。如果也省略了这一点，则CE必须使用相应TML RFC的默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From the CE Manager side:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从CE经理方面：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. CE Identifiers (CEIDs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. CE标识符（CEID）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. CE IP addresses, if the FEs and CEs will be communicating via network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. CE IP地址，如果FEs和CEs将通过网络进行通信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TML. The TML that will be used. If this is omitted, then SCTP must be chosen as default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. TML。将使用的TML。如果省略此项，则必须选择SCTP作为默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. TML priority ports. If this is omitted as well, then the FE must use the default values from the respective TML RFC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. TML优先端口。如果也省略了这一点，则FE必须使用相应TML RFC的默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. TML
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. TML
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All ForCES implementations must support the SCTP TML. Even if another TML will be chosen by the developer, SCTP is mandatory and must be supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有部队实施必须支持SCTP TML。即使开发人员将选择另一个TML，SCTP也是强制性的，必须得到支持。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several issues that should concern a developer for the TML:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TML开发人员应该关注几个问题：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Security. TML must be secure according to the respective RFC. For SCTP, you have to use IPsec.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 安全TML必须根据相应的RFC进行保护。对于SCTP，您必须使用IPsec。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Remote connection. While ForCES is meant to be used locally, both interoperability tests have proven that ForCES can be deployed everywhere that SCTP/IP is available. In both interoperability tests, there were connections between Greece and China, and the performance was very satisfactory. However, in order for the FE and CE to work in a non-local environment, an implementor must ensure that the SCTP-TML ports are forwarded to the CE and/or FE if they are behind NATs; if there is a firewall, it will allow the SCTP ports through. These were identified during the first ForCES interoperability test and documented in the Implementation Report for Forwarding and Control Element Separation [RFC6053].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 远程连接。虽然部队将在本地使用，但两项互操作性测试都证明，部队可以部署在SCTP/IP可用的任何地方。在这两个互操作性测试中，希腊和中国之间都有联系，性能非常令人满意。然而，为了使FE和CE在非本地环境中工作，实施者必须确保SCTP-TML端口转发给CE和/或FE（如果它们在NAT后面）；如果有防火墙，它将允许SCTP端口通过。这些是在第一次部队互操作性测试期间确定的，并记录在转发和控制元件分离实施报告[RFC6053]中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ForCES model is inherently very dynamic. Using the basic atomic data types that are specified in the model, new atomic (single valued) and/or compound (structures and arrays) datatypes can be built. Thus, developers are free to create their own LFBs. One other advantage that the ForCES model provides is inheritance. New versions of existing LFBs can be created to suit any extra developer requirements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
力模型本质上是非常动态的。使用模型中指定的基本原子数据类型，可以构建新的原子（单值）和/或复合（结构和数组）数据类型。因此，开发人员可以自由创建自己的LFB。ForCES模型提供的另一个优点是继承。可以创建现有LFB的新版本，以满足任何额外的开发人员需求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The difficulty for a developer is to create an architecture that is completely scalable so there is no need to write the same code for new LFBs, new components, etc. Developers can just create code for the defined atomic values, and new components can then be built based on already written code, thus reusing it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
开发人员的困难在于创建一个完全可伸缩的体系结构，因此无需为新LFB、新组件等编写相同的代码。开发人员只需为定义的原子值创建代码，然后可以基于已编写的代码构建新组件，从而重用它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model itself provides the key, which is inheritance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
模型本身提供了密钥，即继承。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.1. 组件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, a basic component needs to be created as the mother of all the components that has the basic parameters of all the components:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
首先，需要创建一个基本组件作为具有所有组件基本参数的所有组件的母亲：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The ID of the component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 组件的ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The access rights of the component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 组件的访问权限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If it is an optional component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果是可选组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If it is of variable size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果是可变大小的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Minimum data size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 最小数据大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Maximum data size.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 最大数据大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the data size of the component is not variable, then the size is either the minimum or the maximum size, as both should have the same value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果组件的数据大小不是可变的，则大小为最小或最大大小，因为两者应具有相同的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Next, some basic functions are in order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接下来，按顺序介绍一些基本功能：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A common constructor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 公共构造函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A common destructor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 常见的析构函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Retrieve Component ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 检索组件ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Retrieve access right property.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 检索访问权限属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Query if it is an optional component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 查询它是否是可选组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get Full Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取完整数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Set Full Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设置完整数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get Sparse Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取稀疏数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Set Sparse Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设置稀疏数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Del Full Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 删除全部数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Del Sparse Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 删除稀疏数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get Property.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Set Property.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设置属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get Value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取价值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Set Value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设置值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Del Value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Del值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Clone component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 克隆组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Get/Set/Del Full Data, Get/Set/Del Sparse Data, and Get/Set Property functions handle the respective ForCES commands and return the respective TLV, for example, Set Full Data should return a RESULT-TLV. The Get Value, Set Value, and Del Value functions are called from Get Full/Sparse Data, Set Full/Sparse Data, and Del Full/ Sparse Data respectively and provide the interface to the actual values in the hardware, separating the forces handling logic from the interface to the actual values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Get/Set/Del Full Data、Get/Set/Del Sparse Data和Get/Set Property函数处理相应的ForCES命令并返回相应的TLV，例如，“Set Full Data”应返回RESULT-TLV。分别从Get Full/Sparse Data、Set Full/Sparse Data和Del Full/Sparse Data调用Get Value、Set Value和Del Value函数，为硬件中的实际值提供接口，将力处理逻辑从接口分离到实际值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Get Data function should return the value of the data only, not in TLV format.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Get Data函数应该只返回数据的值，而不是TLV格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Clone function seems out of place. This function must return a new component that has the exact same values and attributes. This function is useful in array components as described further below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
克隆功能似乎不合适。此函数必须返回具有完全相同的值和属性的新组件。如下文所述，此函数在阵列组件中非常有用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only requirement is to implement the base atomic data types. Any new atomic datatype can be built as a child of a base data type, which will inherit all the functions and, if necessary, override them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一的要求是实现基本原子数据类型。任何新的原子数据类型都可以构建为基本数据类型的子数据类型，它将继承所有函数，并在必要时重写它们。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The struct component can then be built. A struct component is a component by itself but consists of a number of atomic components. These atomic components create a static array within the struct. The ID of each atomic component is the array&#39;s index. For a struct component, the Clone function must create and return an exact copy of the struct component with the same static array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后可以构建结构组件。结构组件本身就是一个组件，但由许多原子组件组成。这些原子组件在结构中创建一个静态数组。每个原子组件的ID是数组的索引。对于结构组件，克隆函数必须使用相同的静态数组创建并返回结构组件的精确副本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most difficult component to be built is the array. The difficulty lies in the actual benefit of the model: you have absolute freedom over what you build. An array is an array of components. In all rows, you have the exact same type of component, either a single component or a struct. The struct can have multiple single components or a combination of single components, structs, arrays, and so on. So, the difficulty lies in how to create a new row, a new component by itself. This is where the Clone function is very useful. For the array, a mother component that can spawn new components exactly like itself is needed. Once a Set command is received, the mother component can spawn a new component if the targeted row does not exist and add it into the array; with the Set Full Data function, the value is set in the recently spawned component, as the spawned component knows how the data is created. In order to distinguish these spawned components from each other and their functionality, some kind of index is required that will also reflect how the actual data of the specific component is stored on the hardware.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最难构建的组件是阵列。困难在于该模型的实际好处：您对所构建的内容拥有绝对的自由。数组是组件的数组。在所有行中，都有完全相同类型的组件，单个组件或结构。结构可以有多个单个组件或单个组件、结构、数组等的组合。所以，困难在于如何创建一个新行，一个新组件本身。这就是克隆功能非常有用的地方。对于阵列，需要一个能够生成与自身完全相同的新组件的母组件。接收到Set命令后，如果目标行不存在，则母组件可以生成一个新组件，并将其添加到数组中；使用Set Full Data函数，该值在最近生成的组件中设置，因为生成的组件知道如何创建数据。为了区分这些衍生组件及其功能，需要某种索引，该索引还将反映特定组件的实际数据如何存储在硬件上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the basic constructors of all possible components are created, then a developer only has to create LFB components or datatypes as a child of one of the already-created components, and the only thing the developer really needs to add is the three functions of Get Value, Set Value, and Del Value of each component, which is platform dependent. The rest stays the same.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦创建了所有可能组件的基本构造函数，那么开发人员只需创建LFB组件或数据类型作为已创建组件之一的子组件，并且开发人员真正需要添加的唯一内容是每个组件的Get Value、Set Value和Del Value这三个函数，这取决于平台。其余的保持不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. LFBs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3.2. LFBs
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same architecture in the components can be used for the LFBs, allowing a developer to write LFB handling code only once. The parent LFB has some basic attributes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组件中的相同体系结构可用于LFB，允许开发人员只编写一次LFB处理代码。父LFB具有一些基本属性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The LFB Class ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LFB类ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The LFB Instance ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LFB实例ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An Array of Components.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 组件的数组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An Array of Capabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一系列的能力。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An Array of Events.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一系列事件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following are some common functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下是一些常见功能：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Handle Configuration Command.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 句柄配置命令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Handle Query Command.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 句柄查询命令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get Class ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取类ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get Instance ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取实例ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once these are created, each LFB can inherit all these from the parent, and the only thing it has to do is add the components that have already been created.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
创建这些组件后，每个LFB都可以从父级继承所有这些组件，它唯一要做的就是添加已经创建的组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An example can be seen in Figure 1. The following code creates a part of FEProtocolLFB:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图1中可以看到一个示例。以下代码创建FEProtocolLFB的一部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //FEID
   cui = new Component_uInt(FEPO_FEID, ACCESS_READ_ONLY, FE_id);
   Components[cui-&gt;get_ComponentId()]=cui; //Add component to array list
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //FEID
   cui = new Component_uInt(FEPO_FEID, ACCESS_READ_ONLY, FE_id);
   Components[cui-&gt;get_ComponentId()]=cui; //Add component to array list
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //Current FEHB Policy Value
   cub = new Component_uByte(FEPO_FEHBPolicy, ACCESS_READ_WRITE, 0);
   Components[cub-&gt;get_ComponentId()]=cub; //Add component to array list
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //Current FEHB Policy Value
   cub = new Component_uByte(FEPO_FEHBPolicy, ACCESS_READ_WRITE, 0);
   Components[cub-&gt;get_ComponentId()]=cub; //Add component to array list
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //FEIDs for BackupCEs Array
   cui = new Component_uInt(0, ACCESS_READ_WRITE, 0);
   ca = new Component_Array(FEPO_BackupCEs, ACCESS_READ_WRITE);
   ca-&gt;AddRow(cui, 1);
   ca-&gt;AddMotherComponent(cui);
   Components[ca-&gt;get_ComponentId()]=ca; //Add component to array list
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   //FEIDs for BackupCEs Array
   cui = new Component_uInt(0, ACCESS_READ_WRITE, 0);
   ca = new Component_Array(FEPO_BackupCEs, ACCESS_READ_WRITE);
   ca-&gt;AddRow(cui, 1);
   ca-&gt;AddMotherComponent(cui);
   Components[ca-&gt;get_ComponentId()]=ca; //Add component to array list
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Figure 1: Example Code for Creating Part of FEProtocolLFB
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
图1：创建FEFB部分的示例代码
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same concept can be applied to handling LFBs as one FE. An FE is a collection of LFBs. Thus, all LFBs can be stored in an array based on the LFB&#39;s class id, version, and instance. Then, what is required is an LFBHandler that will handle the array of LFBs. A specific LFB, for example, can be addressed using the following scheme:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同样的概念也可以应用于处理LFB作为一个FE。FE是LFB的集合。因此，所有LFB都可以基于LFB的类id、版本和实例存储在一个数组中。然后，需要一个LFBHandler来处理LFB数组。例如，可以使用以下方案来解决特定LFB：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFBs[ClassID][Version][InstanceID]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LFBs[ClassID][Version][InstanceID]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: While an array can be used in components, capabilities, and events, a hash table or a similar concept is better suited for storing LFBs using the component ID as the hash key with linked lists for collision handling, as the created array can have large gaps if the values of LFB Class ID vary greatly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：虽然可以在组件、功能和事件中使用数组，但哈希表或类似概念更适合使用组件ID作为哈希键存储LFB，并使用链表进行冲突处理，因为如果LFB类ID的值变化很大，则创建的数组可能会有较大的间隙。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1. TLVs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1. 阈限值
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal for protocol handling is to create a general and scalable architecture that handles all protocol messages instead of something implementation specific. There are certain difficulties that have to be overcome first.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
协议处理的目标是创建一个通用的、可扩展的体系结构来处理所有协议消息，而不是特定于实现的消息。有些困难必须首先克服。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the model allows a developer to define any LFB required, the protocol has been thus created to give the user the freedom to configure and query any component, whatever the underlying model. While this is a strong point for the protocol itself, one difficulty lies with the unknown underlying model and the unlimited number of types of messages that can be created, making creating generic code a daunting task.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于该模型允许开发人员定义所需的任何LFB，因此创建该协议是为了让用户能够自由地配置和查询任何组件，无论底层模型是什么。虽然这是协议本身的一个优点，但一个困难在于未知的底层模型和可以创建的无限类型的消息，这使得创建通用代码成为一项艰巨的任务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, the protocol also allows two different path approaches to LFB components, and the CE or FE must handle both or even a mix of them, making a generic decoding of the protocol message difficult.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，该协议还允许对LFB组件采用两种不同的路径方法，CE或FE必须同时处理这两种方法，甚至混合处理这两种方法，这使得协议消息的通用解码变得困难。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another difficulty also arises from the batching capabilities of the protocol. You can have multiple Operations within a message; you can select more than one LFB to command and more than one component to manipulate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
协议的批处理能力也带来了另一个困难。一条消息中可以有多个操作；您可以选择多个LFB来命令和多个组件来操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A possible solution is again provided by inheritance. There are two basic components in a protocol message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
继承再次提供了一种可能的解决方案。协议消息中有两个基本组件：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The common header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 公共标题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The rest of the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 信息的其余部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of the message is divided in Type-Length-Value (TLV) units and, in one case, Index-Length-Value (ILV) units.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息的其余部分按类型长度值（TLV）单位划分，在一种情况下，按索引长度值（ILV）单位划分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TLV hierarchy can be seen in Figure 2:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV层次结构如图2所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      Common Header
                            |
            +---------------+---------------+---------------+
            |               |               |               |
         REDIRECT-TLV  LFBselect-TLV   ASResult-TLV   ASTreason-TLV
                            |
                            |
                        OPER-TLV
                            |
                            |
                      PATH-DATA-TLV  ---&gt; Optional KEYINFO-TLV
                            |
              +-------------+-------------+-------------+
              |             |             |             |
          SPARSEDATA-TLV  RESULT-TLV  FULLDATA-TLV  PATH-DATA-TLV
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      Common Header
                            |
            +---------------+---------------+---------------+
            |               |               |               |
         REDIRECT-TLV  LFBselect-TLV   ASResult-TLV   ASTreason-TLV
                            |
                            |
                        OPER-TLV
                            |
                            |
                      PATH-DATA-TLV  ---&gt; Optional KEYINFO-TLV
                            |
              +-------------+-------------+-------------+
              |             |             |             |
          SPARSEDATA-TLV  RESULT-TLV  FULLDATA-TLV  PATH-DATA-TLV
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
Figure 2: ForCES TLV Hierarchy
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-22">
图2：强制TLV层次结构
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above figure shows only the basic hierarchical level of TLVs and does not show batching. Also, this figure does not show the recursion that can occur at the last level of the hierarchy. The figure shows one kind of recursion with a PATH-DATA-TLV within a PATH-DATA-TLV. A FULLDATA-TLV can be within a FULLDATA-TLV and a SPARSEDATA-TLV. The possible combination of TLVs are described in detail in the Forwarding and Control Element Separation Protocol [RFC5810] as well as the data-packing rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上图仅显示TLV的基本层次结构级别，未显示批处理。此外，此图未显示在层次结构的最后一级可能发生的递归。该图显示了PATH-DATA-TLV中PATH-DATA-TLV的一种递归。FULLDATA-TLV可以在FULLDATA-TLV和SPARA-TLV中。在转发和控制元素分离协议[RFC5810]以及数据打包规则中详细描述了TLV的可能组合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLV&#39;s main attributes are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV的主要属性包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 类型
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 长
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 数据
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An array of TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TLV阵列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The array of TLVs is the next hierarchical level of TLVs nested in this TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV数组是嵌套在此TLV中的下一层次TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A TLV&#39;s common function could be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV的常见功能可能是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A basic constructor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一个基本的构造器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A constructor using data from the wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用导线数据的构造函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Add a new TLV for next level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 为下一级添加新的TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get the next TLV of next level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取下一级别的下一TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get a specific TLV of next level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取下一级别的特定TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Replace a TLV of next level.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 更换下一级TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get the Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get the Length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Set the Data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设置数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Set the Length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设定长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Set the Type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设置类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Serialize the header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 序列化标头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Serialize the TLV to be written on the wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 序列化要在导线上写入的TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All TLVs inherit these functions and attributes and either override them or create new where it is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有TLV继承这些函数和属性，并在需要时覆盖它们或创建新的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2. Message Deserialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2. 消息反序列化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Following is an algorithm for deserializing any protocol message:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下是反序列化任何协议消息的算法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Get the message header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 获取消息头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Read the length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 读长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Check the message type to understand what kind of message this is.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 检查消息类型以了解这是什么类型的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the length is larger than the message header, then there is data for this message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 如果长度大于消息头，则存在此消息的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. A check can be made here regarding the message type and the length of the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 可以在此处检查消息类型和消息长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is a Query or Config type, then there are LFBselect-TLVs for this level:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果消息是查询或配置类型，则此级别有LFBselect TLV：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Read the next 2 shorts(type-length). If the type is an LFBselect-TLV, then the message is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 阅读下面两条短裤（输入长度）。如果类型为LFBselect TLV，则消息有效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Read the necessary length for this LFBselect-TLV, and create the LFBselect-TLV from the data of the wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 读取此LFBselect TLV的必要长度，并根据导线数据创建LFBselect TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Add this LFBselect-TLV to the main header array of LFBselect-TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 将此LFBselect TLV添加到LFBselect TLV的主标头数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Repeat all above steps until the rest of the message has finished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 重复以上所有步骤，直到消息的其余部分完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next level of TLVs is OPER-TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV的下一个级别是操作TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Read the next 2 shorts(type-length). If the type is an OPER-TLV, then the message is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 阅读下面两条短裤（输入长度）。如果类型为OPER-TLV，则消息有效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Read the necessary length for this OPER-TLV, and create the OPER-TLV from the data of the wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 读取此OPER-TLV的必要长度，并根据导线数据创建OPER-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Add this OPER-TLV to the LFBselect-TLV array of TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 将此OPER-TLV添加到TLV的LFBselect TLV数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Do this until the rest of the LFBselect-TLV has finished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 执行此操作，直到LFBselect TLV的其余部分完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The next level of TLVs is PATH-DATA-TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TLV的下一个级别是路径数据TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Read the next 2 shorts(type-length). If the type is a PATH-DATA-TLV, then the message is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 阅读下面两条短裤（输入长度）。如果类型为PATH-DATA-TLV，则消息有效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Read the necessary length for this PATH-DATA-TLV, and create the PATH-DATA-TLV from the data of the wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 读取此PATH-DATA-TLV的必要长度，并根据导线的数据创建PATH-DATA-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Add this PATH-DATA-TLV to the OPER-TLV&#39;s array of TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 将此PATH-DATA-TLV添加到OPER-TLV的TLV数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Do this until the rest of the OPER-TLV is finished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 执行此操作，直到操作TLV的其余部分完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here it gets interesting, as the next level of PATH-DATA-TLVs can be one of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里很有趣，因为下一级路径数据TLV可以是以下之一：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o PATH-DATA-TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 路径数据TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FULLDATA-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o FULLDATA-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SPARSEDATA-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SPARA-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RESULT-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 结果-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The solution to this difficulty is recursion. If the next TLV is a PATH-DATA-TLV, then the PATH-DATA-TLV that is created uses the same kind of deserialization until it reaches a FULLDATA-TLV or SPARSEDATA-TLV. There can be only one FULLDATA-TLV or SPARSEDATA-TLV within a PATH-DATA-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
解决这个困难的办法是递归。如果下一个TLV是PATH-DATA-TLV，则创建的PATH-DATA-TLV将使用相同类型的反序列化，直到到达FULLDATA-TLV或SPARA-TLV。PATH-DATA-TLV中只能有一个FULLDATA-TLV或SPARA-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Read the next 2 shorts(type-length).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 阅读下面两条短裤（输入长度）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. If the Type is a PATH-DATA-TLV, then repeat the previous algorithm but add the PATH-DATA-TLV to this PATH-DATA-TLV&#39;s array of TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 如果类型是PATH-DATA-TLV，则重复前面的算法，但将PATH-DATA-TLV添加到此PATH-DATA-TLV的TLV数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Do this until the rest of the PATH-DATA-TLV is finished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 执行此操作，直到PATH-DATA-TLV的其余部分完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. If the Type is a FULLDATA-TLV, then create the FULLDATA-TLV from the message and add this to the PATH-DATA-TLV&#39;s array of TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 如果类型为FULLDATA-TLV，则从消息中创建FULLDATA-TLV，并将其添加到PATH-DATA-TLV的TLV数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. If the Type is a SPARSEDATA-TLV, then create the SPARSEDATA-TLV from the message and add this to the PATH-DATA-TLV&#39;s array of TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 如果类型是SPARSTATA-TLV，则从消息中创建SPARSTATA-TLV，并将其添加到PATH-DATA-TLV的TLV数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. If the Type is a RESULT-TLV, then create the RESULT-TLV from the message and add this to the PATH-DATA-TLV&#39;s array of TLVs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 如果类型是RESULT-TLV，则从消息中创建RESULT-TLV，并将其添加到PATH-DATA-TLV的TLV数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is a Query, it must not have any kind of data inside the PATH-DATA-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果消息是查询，则在PATH-data-TLV中不得包含任何类型的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is a Query Response, then it must have either a RESULT-TLV or a FULLDATA-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果消息是查询响应，那么它必须具有RESULT-TLV或FULLDATA-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is a Config, it must contain either a FULLDATA-TLV or a SPARSEDATA-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果消息是配置，则必须包含FULLDATA-TLV或SPARA-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is a Config Response, it must contain a RESULT-TLV.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果消息是配置响应，则必须包含RESULT-TLV。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
More details regarding message validation can be read in Section 7 of the Forwarding and Control Element Separation Protocol [RFC5810].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关消息验证的更多详细信息，请参阅转发和控制元件分离协议[RFC5810]第7节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: When deserializing, implementors must take care to ignore padding of TLVs as all must be 32-bit aligned. The length value in TLVs includes the Type and Length (4 bytes) but does not include padding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：当反序列化时，实现者必须注意忽略TLV的填充，因为所有TLV都必须是32位对齐的。TLV中的长度值包括类型和长度（4字节），但不包括填充。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3. Message Serialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3. 消息序列化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same concept can be applied in the message creation process. Having the TLVs ready, a developer can go bottom up. All that is required is the serialization function that will transform the TLV into bytes ready to be transferred on the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在消息创建过程中也可以应用相同的概念。准备好TLV后，开发人员可以自下而上。所需的只是将TLV转换为准备在网络上传输的字节的序列化函数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, for the creation of a simple query from the CE to the FE, all the PATH-DATA-TLVs are created. Then they will be serialized and inserted into an OPER-TLV, which in turn will be serialized and inserted into an LFBselect-TLV. The LFBselect-TLV will then be serialized and entered into the Common Header, which will be passed to the TML to be transported to the FE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如，为了创建从CE到FE的简单查询，将创建所有路径数据TLV。然后，它们将被序列化并插入OPER-TLV，OPER-TLV将被序列化并插入LFBselect TLV。然后，LFBselect TLV将被序列化并输入到公共标头中，该标头将被传递到TML以传输到FE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Having an array of TLVs inside a TLV that is next in the TLV hierarchy allows the developer to insert any number of next-level TLVs, thus creating any kind of message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在TLV层次结构中的下一个TLV中拥有TLV数组允许开发人员插入任意数量的下一级TLV，从而创建任何类型的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: When the TLV is serialized to be written on the wire, implementors must take care to include padding to TLVs as all must be 32-bit aligned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：当TLV被序列化以写在线路上时，实现者必须注意将填充包含到TLV中，因为所有填充都必须是32位对齐的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Development Platforms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 开发平台
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any development platform that can support the SCTP TML and the TML of the developer&#39;s choosing is available for use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任何能够支持SCTP TML和开发人员选择的TML的开发平台都可以使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Figure 3 provides an initial survey of SCTP support for C/C++ and Java at the present time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图3提供了目前对C/C++和Java的SCTP支持的初步调查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         /-------------+-------------+-------------+-------------\
         |\ Platform   |             |             |             |
         | ----------\ |   Windows   |    Linux    |   Solaris   |
         |  Language  \|             |             |             |
         +-------------+-------------+-------------+-------------+
         |             |             |             |             |
         |    C/C++    |  Supported  |  Supported  |  Supported  |
         |             |             |             |             |
         +-------------+-------------+-------------+-------------+
         |             |   Limited   |             |             |
         |    Java     | Third Party |  Supported  |  Supported  |
         |             | Not from SUN|             |             |
         \-------------+-------------+-------------+-------------/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         /-------------+-------------+-------------+-------------\
         |\ Platform   |             |             |             |
         | ----------\ |   Windows   |    Linux    |   Solaris   |
         |  Language  \|             |             |             |
         +-------------+-------------+-------------+-------------+
         |             |             |             |             |
         |    C/C++    |  Supported  |  Supported  |  Supported  |
         |             |             |             |             |
         +-------------+-------------+-------------+-------------+
         |             |   Limited   |             |             |
         |    Java     | Third Party |  Supported  |  Supported  |
         |             | Not from SUN|             |             |
         \-------------+-------------+-------------+-------------/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Figure 3: SCTP Support on Operating Systems
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
图3：操作系统上的SCTP支持
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A developer should be aware of some limitations regarding Java implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
开发人员应该了解有关Java实现的一些限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Java inherently does not support unsigned types. A workaround can be found in the creation of classes that do the translation of unsigned types to Java types. The problem is that the unsigned long cannot be used as-is in the Java platform. The proposed set of classes can be found in [JavaUnsignedTypes].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Java本身不支持无符号类型。在创建将无符号类型转换为Java类型的类时，可以找到一种解决方法。问题是，无符号long不能像在Java平台中那样使用。建议的类集可以在[JavaUnsignedTypes]中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Acknowledgements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The authors would like to thank Adrian Farrel for sponsoring this document and Jamal Hadi Salim for discussions that made this document better.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作者要感谢阿德里安·法雷尔（Adrian Farrel）赞助本文件，并感谢贾马尔·哈迪·萨利姆（Jamal Hadi Salim）通过讨论使本文件变得更好。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Developers of ForCES FEs and CEs must take the Security Considerations of the Forwarding and Control Element Separation Framework [RFC3746] and the Forwarding and Control Element Separation Protocol [RFC5810] into account.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
部队FEs和CEs的开发者必须考虑转发和控制元素分离框架[RFC3746]以及转发和控制元素分离协议[RFC5810]的安全考虑。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Also, as specified in the Security Considerations section of the SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation Protocol [RFC5811], transport-level security has to be ensured by IPsec.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，根据转发和控制元素分离协议[RFC5811]基于SCTP的传输映射层（TML）的安全注意事项部分的规定，必须通过IPsec确保传输级别的安全性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5810] Doria, A., Hadi Salim, J., Haas, R., Khosravi, H., Wang, W., Dong, L., Gopal, R., and J. Halpern, &#34;Forwarding and Control Element Separation (ForCES) Protocol Specification&#34;, RFC 5810, March 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5810]Doria，A.，Hadi Salim，J.，Haas，R.，Khosravi，H.，Wang，W.，Dong，L.，Gopal，R.，和J.Halpern，“转发和控制元件分离（部队）协议规范”，RFC 58102010年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5811] Hadi Salim, J. and K. Ogawa, &#34;SCTP-Based Transport Mapping Layer (TML) for the Forwarding and Control Element Separation (ForCES) Protocol&#34;, RFC 5811, March 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5811]Hadi Salim，J.和K.Ogawa，“转发和控制元素分离（ForCES）协议的基于SCTP的传输映射层（TML）”，RFC 58112010年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5812] Halpern, J. and J. Hadi Salim, &#34;Forwarding and Control Element Separation (ForCES) Forwarding Element Model&#34;, RFC 5812, March 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5812]Halpern，J.和J.Hadi Salim，“转发和控制单元分离（部队）转发单元模型”，RFC 5812，2010年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6041] Crouch, A., Khosravi, H., Doria, A., Wang, X., and K. Ogawa, &#34;Forwarding and Control Element Separation (ForCES) Applicability Statement&#34;, RFC 6041, October 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6041]Crouch，A.，Khosravi，H.，Doria，A.，Wang，X.，和K.Ogawa，“转发和控制元件分离（部队）适用性声明”，RFC 60412010年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6053] Haleplidis, E., Ogawa, K., Wang, W., and J. Hadi Salim, &#34;Implementation Report for Forwarding and Control Element Separation (ForCES)&#34;, RFC 6053, November 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6053]Haleplidis，E.，Ogawa，K.，Wang，W.，和J.Hadi Salim，“转发和控制分队（部队）实施报告”，RFC 60532010年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[JavaUnsignedTypes] &#34;Java Unsigned Types&#34;, &lt;http://nam.ece.upatras.gr/index.php?q=node/44&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[JavaUnsignedTypes]“Java未签名类型”&lt;http://nam.ece.upatras.gr/index.php?q=node/44&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3654] Khosravi, H. and T. Anderson, &#34;Requirements for Separation of IP Control and Forwarding&#34;, RFC 3654, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3654]Khosravi，H.和T.Anderson，“IP控制和转发分离的要求”，RFC 3654，2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3746] Yang, L., Dantu, R., Anderson, T., and R. Gopal, &#34;Forwarding and Control Element Separation (ForCES) Framework&#34;, RFC 3746, April 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3746]Yang，L.，Dantu，R.，Anderson，T.，和R.Gopal，“转发和控制单元分离（部队）框架”，RFC 37462004年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Evangelos Haleplidis University of Patras Department of Electrical &amp; Computer Engineering Patras 26500 Greece
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
佩特雷大学电气与计算机工程系帕特雷26500希腊分校
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: ehalep@ece.upatras.gr
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: ehalep@ece.upatras.gr
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Odysseas Koufopavlou University of Patras Department of Electrical &amp; Computer Engineering Patras 26500 Greece
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
OdssSoukoufopav娄佩特雷大学电气与计算机工程系帕特雷26500希腊
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: odysseas@ece.upatras.gr
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: odysseas@ece.upatras.gr
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Spyros Denazis University of Patras Department of Electrical &amp; Computer Engineering Patras 26500 Greece
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
佩特雷大学电气与计算机工程系帕特雷26500希腊分校
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: sdena@upatras.gr
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: sdena@upatras.gr
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
