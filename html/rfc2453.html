<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 2453:  RIP Version 2 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC 2453:  RIP Version 2 中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">2453</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc2453">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 2453:  RIP Version 2  中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc2453">
              https://datatracker.ietf.org/doc/html/rfc2453
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 2453</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          G. Malkin
Request for Comments: 2453                                  Bay Networks
Obsoletes: 1723, 1388                                      November 1998
STD: 56
Category: Standards Track
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          G. Malkin
Request for Comments: 2453                                  Bay Networks
Obsoletes: 1723, 1388                                      November 1998
STD: 56
Category: Standards Track
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
RIP Version 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-29">
RIP第2版本
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本备忘录的状况
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1998年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an extension of the Routing Information Protocol (RIP), as defined in [1], to expand the amount of useful information carried in RIP messages and to add a measure of security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了[1]中定义的路由信息协议（RIP）的扩展，以扩展RIP消息中携带的有用信息量，并添加安全措施。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A companion document will define the SNMP MIB objects for RIP-2 [2]. An additional document will define cryptographic security improvements for RIP-2 [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附带文档将为RIP-2[2]定义SNMP MIB对象。另外一份文件将定义RIP-2[3]的加密安全改进。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgements
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
致谢
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
I would like to thank the IETF RIP Working Group for their help in improving the RIP-2 protocol. Much of the text for the background discussions about distance vector protocols and some of the descriptions of the operation of RIP were taken from &#34;Routing Information Protocol&#34; by C. Hedrick [1]. Some of the final editing on the document was done by Scott Bradner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我要感谢IETF RIP工作组在改进RIP-2协议方面提供的帮助。关于距离向量协议的背景讨论和RIP操作的一些描述的大部分文本取自C.Hedrick[1]的“路由信息协议”。该文件的一些最终编辑工作由斯科特·布拉德纳完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Justification  . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Current RIP  . . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.  Basic Protocol . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.1   Introduction   . . . . . . . . . . . . . . . . . . . . . . .  3
   3.2   Limitations of the Protocol  . . . . . . . . . . . . . . . .  5
   3.3.  Organization of this document  . . . . . . . . . . . . . . .  6
   3.4   Distance Vector Algorithms . . . . . . . . . . . . . . . . .  6
   3.4.1    Dealing with changes in topology  . . . . . . . . . . . . 12
   3.4.2    Preventing instability  . . . . . . . . . . . . . . . . . 13
   3.4.3    Split horizon . . . . . . . . . . . . . . . . . . . . . . 15
   3.4.4    Triggered updates . . . . . . . . . . . . . . . . . . . . 17
   3.5   Protocol Specification   . . . . . . . . . . . . . . . . . . 18
   3.6   Message Format . . . . . . . . . . . . . . . . . . . . . . . 20
   3.7   Addressing Considerations  . . . . . . . . . . . . . . . . . 22
   3.8   Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
   3.9   Input Processing . . . . . . . . . . . . . . . . . . . . . . 25
   3.9.1    Request Messages  . . . . . . . . . . . . . . . . . . . . 25
   3.9.2    Response Messages . . . . . . . . . . . . . . . . . . . . 26
   3.10  Output Processing  . . . . . . . . . . . . . . . . . . . . . 28
   3.10.1   Triggered Updates . . . . . . . . . . . . . . . . . . . . 29
   3.10.2   Generating Response Messages. . . . . . . . . . . . . . . 30
   4.  Protocol Extensions  . . . . . . . . . . . . . . . . . . . . . 31
   4.1   Authentication . . . . . . . . . . . . . . . . . . . . . . . 31
   4.2   Route Tag  . . . . . . . . . . . . . . . . . . . . . . . . . 32
   4.3   Subnet Mask  . . . . . . . . . . . . . . . . . . . . . . . . 32
   4.4   Next Hop . . . . . . . . . . . . . . . . . . . . . . . . . . 33
   4.5   Multicasting . . . . . . . . . . . . . . . . . . . . . . . . 33
   4.6   Queries  . . . . . . . . . . . . . . . . . . . . . . . . . . 33
   5.  Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . 34
   5.1   Compatibility Switch . . . . . . . . . . . . . . . . . . . . 34
   5.2   Authentication . . . . . . . . . . . . . . . . . . . . . . . 34
   5.3   Larger Infinity  . . . . . . . . . . . . . . . . . . . . . . 35
   5.4   Addressless Links  . . . . . . . . . . . . . . . . . . . . . 35
   6.  Interaction between version 1 and version 2  . . . . . . . . . 35
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 36
   Appendices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
   References . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
   Author&#39;s Address . . . . . . . . . . . . . . . . . . . . . . . . . 38
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 39
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Justification  . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Current RIP  . . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.  Basic Protocol . . . . . . . . . . . . . . . . . . . . . . . .  3
   3.1   Introduction   . . . . . . . . . . . . . . . . . . . . . . .  3
   3.2   Limitations of the Protocol  . . . . . . . . . . . . . . . .  5
   3.3.  Organization of this document  . . . . . . . . . . . . . . .  6
   3.4   Distance Vector Algorithms . . . . . . . . . . . . . . . . .  6
   3.4.1    Dealing with changes in topology  . . . . . . . . . . . . 12
   3.4.2    Preventing instability  . . . . . . . . . . . . . . . . . 13
   3.4.3    Split horizon . . . . . . . . . . . . . . . . . . . . . . 15
   3.4.4    Triggered updates . . . . . . . . . . . . . . . . . . . . 17
   3.5   Protocol Specification   . . . . . . . . . . . . . . . . . . 18
   3.6   Message Format . . . . . . . . . . . . . . . . . . . . . . . 20
   3.7   Addressing Considerations  . . . . . . . . . . . . . . . . . 22
   3.8   Timers . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
   3.9   Input Processing . . . . . . . . . . . . . . . . . . . . . . 25
   3.9.1    Request Messages  . . . . . . . . . . . . . . . . . . . . 25
   3.9.2    Response Messages . . . . . . . . . . . . . . . . . . . . 26
   3.10  Output Processing  . . . . . . . . . . . . . . . . . . . . . 28
   3.10.1   Triggered Updates . . . . . . . . . . . . . . . . . . . . 29
   3.10.2   Generating Response Messages. . . . . . . . . . . . . . . 30
   4.  Protocol Extensions  . . . . . . . . . . . . . . . . . . . . . 31
   4.1   Authentication . . . . . . . . . . . . . . . . . . . . . . . 31
   4.2   Route Tag  . . . . . . . . . . . . . . . . . . . . . . . . . 32
   4.3   Subnet Mask  . . . . . . . . . . . . . . . . . . . . . . . . 32
   4.4   Next Hop . . . . . . . . . . . . . . . . . . . . . . . . . . 33
   4.5   Multicasting . . . . . . . . . . . . . . . . . . . . . . . . 33
   4.6   Queries  . . . . . . . . . . . . . . . . . . . . . . . . . . 33
   5.  Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . 34
   5.1   Compatibility Switch . . . . . . . . . . . . . . . . . . . . 34
   5.2   Authentication . . . . . . . . . . . . . . . . . . . . . . . 34
   5.3   Larger Infinity  . . . . . . . . . . . . . . . . . . . . . . 35
   5.4   Addressless Links  . . . . . . . . . . . . . . . . . . . . . 35
   6.  Interaction between version 1 and version 2  . . . . . . . . . 35
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 36
   Appendices . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
   References . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
   Author&#39;s Address . . . . . . . . . . . . . . . . . . . . . . . . . 38
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 39
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Justification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 正当理由
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the advent of OSPF and IS-IS, there are those who believe that RIP is obsolete. While it is true that the newer IGP routing protocols are far superior to RIP, RIP does have some advantages. Primarily, in a small network, RIP has very little overhead in terms of bandwidth used and configuration and management time. RIP is also very easy to implement, especially in relation to the newer IGPs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
随着OSPF和IS-IS的出现，有人认为RIP已经过时。虽然较新的IGP路由协议确实远远优于RIP，但RIP确实有一些优势。基本上，在小型网络中，RIP在使用带宽、配置和管理时间方面的开销非常小。RIP也很容易实现，尤其是对于较新的IGP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, there are many, many more RIP implementations in the field than OSPF and IS-IS combined. It is likely to remain that way for some years yet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，该领域的RIP实现比OSPF和IS-IS的组合多得多。这种情况可能会持续几年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given that RIP will be useful in many environments for some period of time, it is reasonable to increase RIP&#39;s usefulness. This is especially true since the gain is far greater than the expense of the change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑到RIP将在一段时间内在许多环境中有用，因此增加RIP的有用性是合理的。这一点尤其正确，因为收益远远大于变革的代价。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Current RIP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 电流撕裂
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current RIP-1 message contains the minimal amount of information necessary for routers to route messages through a network. It also contains a large amount of unused space, owing to its origins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当前的RIP-1消息包含路由器通过网络路由消息所需的最小信息量。由于它的起源，它还包含大量未使用的空间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The current RIP-1 protocol does not consider autonomous systems and IGP/EGP interactions, subnetting [11], and authentication since implementations of these postdate RIP-1. The lack of subnet masks is a particularly serious problem for routers since they need a subnet mask to know how to determine a route. If a RIP-1 route is a network route (all non-network bits 0), the subnet mask equals the network mask. However, if some of the non-network bits are set, the router cannot determine the subnet mask. Worse still, the router cannot determine if the RIP-1 route is a subnet route or a host route. Currently, some routers simply choose the subnet mask of the interface over which the route was learned and determine the route type from that.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当前RIP-1协议不考虑自系统和IGP/EGP相互作用、子网（11）和自这些日期RIP-1实现以来的认证。缺少子网掩码对于路由器来说是一个特别严重的问题，因为它们需要一个子网掩码来知道如何确定路由。如果RIP-1路由是网络路由（所有非网络位为0），则子网掩码等于网络掩码。但是，如果设置了一些非网络位，则路由器无法确定子网掩码。更糟糕的是，路由器无法确定RIP-1路由是子网路由还是主机路由。目前，一些路由器只需选择接口的子网掩码，通过该子网掩码学习路由，并根据该子网掩码确定路由类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Basic Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 基本协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP is a routing protocol based on the Bellman-Ford (or distance vector) algorithm. This algorithm has been used for routing computations in computer networks since the early days of the ARPANET. The particular packet formats and protocol described here are based on the program &#34;routed,&#34; which is included with the Berkeley distribution of Unix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP是一种基于Bellman-Ford（或距离向量）算法的路由协议。自ARPANET诞生之初，该算法就被用于计算机网络中的路由计算。这里描述的特定数据包格式和协议基于Unix的Berkeley发行版中包含的程序“routed”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In an international network, such as the Internet, it is very unlikely that a single routing protocol will used for the entire network. Rather, the network will be organized as a collection of Autonomous Systems (AS), each of which will, in general, be administered by a single entity. Each AS will have its own routing technology, which may differ among AS&#39;s. The routing protocol used within an AS is referred to as an Interior Gateway Protocol (IGP). A separate protocol, called an Exterior Gateway Protocol (EGP), is used to transfer routing information among the AS&#39;s. RIP was designed to work as an IGP in moderate-size AS&#39;s. It is not intended for use in more complex environments. For information on the context into which RIP-1 is expected to fit, see Braden and Postel [6].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在一个国际网络中，例如因特网，整个网络不太可能使用单一的路由协议。相反，该网络将被组织为自治系统（as）的集合，通常每个系统将由单个实体管理。每个AS都有自己的路由技术，这在AS之间可能有所不同。AS中使用的路由协议称为内部网关协议（IGP）。一个单独的协议称为外部网关协议（EGP），用于在AS之间传输路由信息。RIP被设计成中等尺寸的IGP。它不适用于更复杂的环境。有关RIP-1预计适合的环境的信息，请参见Braden和Postel[6]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP uses one of a class of routing algorithms known as Distance Vector algorithms. The earliest description of this class of algorithms known to the author is in Ford and Fulkerson [8]. Because of this, they are sometimes known as Ford-Fulkerson algorithms. The term Bellman-Ford is also used, and derives from the fact that the formulation is based on Bellman&#39;s equation [4]. The presentation in this document is closely based on [5]. This document contains a protocol specification. For an introduction to the mathematics of routing algorithms, see [1]. The basic algorithms used by this protocol were used in computer routing as early as 1969 in the ARPANET. However, the specific ancestry of this protocol is within the Xerox network protocols. The PUP protocols [7] used the Gateway Information Protocol to exchange routing information. A somewhat updated version of this protocol was adopted for the Xerox Network Systems (XNS) architecture, with the name Routing Information Protocol [9]. Berkeley&#39;s routed is largely the same as the Routing Information Protocol, with XNS addresses replaced by a more general address format capable of handling IPv4 and other types of address, and with routing updates limited to one every 30 seconds. Because of this similarity, the term Routing Information Protocol (or just RIP) is used to refer to both the XNS protocol and the protocol used by routed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP使用一种称为距离向量算法的路由算法。作者已知的这类算法的最早描述在Ford和Fulkerson[8]中。因此，它们有时被称为福特-富尔克森算法。术语Bellman-Ford也被使用，其来源是公式基于Bellman方程[4]。本文件中的介绍主要基于[5]。本文档包含协议规范。有关路由算法数学的介绍，请参见[1]。该协议使用的基本算法早在1969年就在ARPANET中用于计算机路由。然而，该协议的具体起源在施乐网络协议中。PUP协议[7]使用网关信息协议交换路由信息。施乐网络系统（XNS）架构采用了该协议的更新版本，名称为路由信息协议[9]。伯克利的路由协议与路由信息协议基本相同，XNS地址被一种更通用的地址格式所取代，该格式能够处理IPv4和其他类型的地址，并且路由更新限制为每30秒更新一次。由于这种相似性，术语路由信息协议（或只是RIP）被用来指代XNS协议和routed所使用的协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP is intended for use within the IP-based Internet. The Internet is organized into a number of networks connected by special purpose gateways known as routers. The networks may be either point-to-point links or more complex networks such as Ethernet or token ring. Hosts and routers are presented with IP datagrams addressed to some host. Routing is the method by which the host or router decides where to send the datagram. It may be able to send the datagram directly to the destination, if that destination is on one of the networks that are directly connected to the host or router. However, the interesting case is when the destination is not directly reachable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP旨在用于基于IP的互联网。互联网被组织成若干网络，通过称为路由器的专用网关连接。网络可以是点到点链路或更复杂的网络，例如以太网或令牌环。主机和路由器都有IP数据报，发往某个主机。路由是主机或路由器决定向何处发送数据报的方法。如果目的地位于直接连接到主机或路由器的网络之一上，则它可能能够将数据报直接发送到目的地。然而，有趣的情况是，目的地无法直接到达。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this case, the host or router attempts to send the datagram to a router that is nearer the destination. The goal of a routing protocol is very simple: It is to supply the information that is needed to do routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在这种情况下，主机或路由器尝试将数据报发送到距离目标较近的路由器。路由协议的目标非常简单：它提供进行路由所需的信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 Limitations of the Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2 议定书的限制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This protocol does not solve every possible routing problem. As mentioned above, it is primary intended for use as an IGP in networks of moderate size. In addition, the following specific limitations are be mentioned:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该协议并不能解决所有可能的路由问题。如上所述，它主要用于中等规模网络中的IGP。此外，还应提及以下具体限制：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The protocol is limited to networks whose longest path (the network&#39;s diameter) is 15 hops. The designers believe that the basic protocol design is inappropriate for larger networks. Note that this statement of the limit assumes that a cost of 1 is used for each network. This is the way RIP is normally configured. If the system administrator chooses to use larger costs, the upper bound of 15 can easily become a problem.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 该协议仅限于最长路径（网络直径）为15跳的网络。设计者认为，基本协议设计不适用于较大的网络。请注意，此限制声明假定每个网络的成本为1。这是RIP的正常配置方式。如果系统管理员选择使用更大的成本，15的上限很容易成为问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The protocol depends upon &#34;counting to infinity&#34; to resolve certain unusual situations. (This will be explained in the next section.) If the system of networks has several hundred networks, and a routing loop was formed involving all of them, the resolution of the loop would require either much time (if the frequency of routing updates were limited) or bandwidth (if updates were sent whenever changes were detected). Such a loop would consume a large amount of network bandwidth before the loop was corrected. We believe that in realistic cases, this will not be a problem except on slow lines. Even then, the problem will be fairly unusual, since various precautions are taken that should prevent these problems in most cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 该协议依靠“无限计数”来解决某些异常情况。（这将在下一节中解释。）如果网络系统有几百个网络，并且形成了一个包含所有网络的路由环路，则环路的解决将需要很多时间（如果路由更新的频率受到限制）或带宽（如果在检测到更改时发送更新）。这样的循环将在纠正循环之前消耗大量网络带宽。我们相信，在现实情况下，这将不会是一个问题，除非在慢线。即便如此，这个问题还是相当不寻常的，因为在大多数情况下，我们采取了各种预防措施来预防这些问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- This protocol uses fixed &#34;metrics&#34; to compare alternative routes. It is not appropriate for situations where routes need to be chosen based on real-time parameters such a measured delay, reliability, or load. The obvious extensions to allow metrics of this type are likely to introduce instabilities of a sort that the protocol is not designed to handle.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 该协议使用固定的“度量”来比较备选路由。这不适用于需要根据实时参数（如测量的延迟、可靠性或负载）选择路线的情况。允许这种类型的度量的明显扩展很可能会引入协议设计无法处理的不稳定性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Organization of this document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 本文件的组织
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The main body of this document is organized into two parts, which occupy the next two sections:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件正文分为两部分，以下两部分为正文：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
A conceptual development and justification of distance vector algorithms in general.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
一般距离向量算法的概念发展和论证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
The actual protocol description.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-8">
实际的协议描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of these two sections can largely stand on its own. Section 3.4 attempts to give an informal presentation of the mathematical underpinnings of the algorithm. Note that the presentation follows a &#34;spiral&#34; method. An initial, fairly simple algorithm is described. Then refinements are added to it in successive sections. Section 3.5 is the actual protocol description. Except where specific references are made to section 3.4, it should be possible to implement RIP entirely from the specifications given in section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这两个部分在很大程度上都可以独立存在。第3.4节试图非正式介绍算法的数学基础。请注意，演示遵循“螺旋”方法。描述了一个初始的、相当简单的算法。然后在连续的章节中对其进行细化。第3.5节是实际的协议说明。除非具体参考第3.4节，否则应可完全按照第3.5节给出的规范实施RIP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 Distance Vector Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4 距离向量算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routing is the task of finding a path from a sender to a desired destination. In the IP &#34;Internet model&#34; this reduces primarily to a matter of finding a series of routers between the source and destination networks. As long as a message or datagram remains on a single network or subnet, any forwarding problems are the responsibility of technology that is specific to the network. For example, Ethernet and the ARPANET each define a way in which any sender can talk to any specified destination within that one network. IP routing comes in primarily when messages must go from a sender on one network to a destination on a different one. In that case, the message must pass through one or more routers connecting the networks. If the networks are not adjacent, the message may pass through several intervening networks, and the routers connecting them. Once the message gets to a router that is on the same network as the destination, that network&#39;s own technology is used to get to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由是查找从发送方到所需目的地的路径的任务。在IP“Internet模型”中，这主要归结为在源网络和目标网络之间查找一系列路由器的问题。只要消息或数据报保留在单个网络或子网上，任何转发问题都由特定于网络的技术负责。例如，以太网和ARPANET各自定义了一种方式，任何发送方都可以通过这种方式与该网络中的任何指定目的地进行通信。IP路由主要出现在消息必须从一个网络上的发送者发送到另一个网络上的目的地时。在这种情况下，消息必须通过连接网络的一个或多个路由器。如果网络不相邻，则消息可能会通过多个中间网络以及连接这些网络的路由器。一旦消息到达与目的地位于同一网络上的路由器，该网络自身的技术将用于到达目的地。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout this section, the term &#34;network&#34; is used generically to cover a single broadcast network (e.g., an Ethernet), a point to point line, or the ARPANET. The critical point is that a network is treated as a single entity by IP. Either no forwarding decision is necessary (as with a point to point line), or that forwarding is done in a manner that is transparent to IP, allowing IP to treat the entire network as a single fully-connected system (as with an Ethernet or the ARPANET). Note that the term &#34;network&#34; is used in a somewhat different way in discussions of IP addressing. We are using the term &#34;network&#34; here to refer to subnets in cases where subnet
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本节中，术语“网络”一般用于涵盖单个广播网络（例如以太网）、点对点线路或ARPANET。关键点在于IP将网络视为单个实体。要么不需要转发决定（如点对点线路），要么转发以对IP透明的方式进行，允许IP将整个网络视为一个完全连接的系统（如以太网或ARPANET）。请注意，在讨论IP寻址时，术语“网络”的使用方式有所不同。我们在这里使用术语“网络”指的是子网，在这种情况下，子网
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
addressing is in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
寻址正在使用中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A number of different approaches for finding routes between networks are possible. One useful way of categorizing these approaches is on the basis of the type of information the routers need to exchange in order to be able to find routes. Distance vector algorithms are based on the exchange of only a small amount of information. Each entity (router or host) that participates in the routing protocol is assumed to keep information about all of the destinations within the system. Generally, information about all entities connected to one network is summarized by a single entry, which describes the route to all destinations on that network. This summarization is possible because as far as IP is concerned, routing within a network is invisible. Each entry in this routing database includes the next router to which datagrams destined for the entity should be sent. In addition, it includes a &#34;metric&#34; measuring the total distance to the entity. Distance is a somewhat generalized concept, which may cover the time delay in getting messages to the entity, the dollar cost of sending messages to it, etc. Distance vector algorithms get their name from the fact that it is possible to compute optimal routes when the only information exchanged is the list of these distances. Furthermore, information is only exchanged among entities that are adjacent, that is, entities that share a common network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有许多不同的方法可以在网络之间找到路由。对这些方法进行分类的一个有用方法是根据路由器为了能够找到路由而需要交换的信息类型。距离向量算法仅基于少量信息的交换。假设参与路由协议的每个实体（路由器或主机）都保存有关系统内所有目的地的信息。通常，关于连接到一个网络的所有实体的信息由一个条目汇总，该条目描述到该网络上所有目的地的路由。这种总结是可能的，因为就IP而言，网络中的路由是不可见的。此路由数据库中的每个条目都包括下一个路由器，该路由器应向该实体发送数据报。此外，它还包括一个“度量”，用于测量到实体的总距离。距离是一个有点广义的概念，它可能包括向实体发送消息的时间延迟、向实体发送消息的美元成本等。距离向量算法之所以得名，是因为当交换的唯一信息是这些距离的列表时，可以计算最佳路由。此外，信息仅在相邻实体（即共享公共网络的实体）之间交换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although routing is most commonly based on information about networks, it is sometimes necessary to keep track of the routes to individual hosts. The RIP protocol makes no formal distinction between networks and hosts. It simply describes exchange of information about destinations, which may be either networks or hosts. (Note however, that it is possible for an implementor to choose not to support host routes. See section 3.2.) In fact, the mathematical developments are most conveniently thought of in terms of routes from one host or router to another. When discussing the algorithm in abstract terms, it is best to think of a routing entry for a network as an abbreviation for routing entries for all of the entities connected to that network. This sort of abbreviation makes sense only because we think of networks as having no internal structure that is visible at the IP level. Thus, we will generally assign the same distance to every entity in a given network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然路由通常基于网络信息，但有时需要跟踪到各个主机的路由。RIP协议在网络和主机之间没有正式的区别。它简单地描述了有关目的地（可能是网络或主机）的信息交换。（但是请注意，实施者可以选择不支持主机路由。请参见第3.2节。）事实上，数学发展最方便的方式是考虑从一台主机或路由器到另一台主机或路由器的路由。在抽象地讨论算法时，最好将网络的路由条目视为连接到该网络的所有实体的路由条目的缩写。这种缩写之所以有意义，只是因为我们认为网络没有在IP级别可见的内部结构。因此，我们通常为给定网络中的每个实体分配相同的距离。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We said above that each entity keeps a routing database with one entry for every possible destination in the system. An actual implementation is likely to need to keep the following information about each destination:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们在上面说过，每个实体都有一个路由数据库，其中包含系统中每个可能目的地的一个条目。实际实现可能需要保留有关每个目的地的以下信息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- address: in IP implementations of these algorithms, this will be the IP address of the host or network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 地址：在这些算法的IP实现中，这将是主机或网络的IP地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- router: the first router along the route to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 路由器：沿路线到达目的地的第一个路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- interface: the physical network which must be used to reach the first router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 接口：必须用于到达第一个路由器的物理网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- metric: a number, indicating the distance to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 公制：一个数字，表示到目的地的距离。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- timer: the amount of time since the entry was last updated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 计时器：自上次更新条目以来的时间量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, various flags and other internal information will probably be included. This database is initialized with a description of the entities that are directly connected to the system. It is updated according to information received in messages from neighboring routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，可能会包括各种标志和其他内部信息。该数据库使用直接连接到系统的实体的描述进行初始化。它根据从相邻路由器收到的消息中的信息进行更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most important information exchanged by the hosts and routers is carried in update messages. Each entity that participates in the routing scheme sends update messages that describe the routing database as it currently exists in that entity. It is possible to maintain optimal routes for the entire system by using only information obtained from neighboring entities. The algorithm used for that will be described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主机和路由器交换的最重要的信息在更新消息中进行。参与路由方案的每个实体都会发送更新消息，以描述该实体中当前存在的路由数据库。通过仅使用从相邻实体获得的信息，可以维持整个系统的最佳路由。下一节将描述用于此目的的算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we mentioned above, the purpose of routing is to find a way to get datagrams to their ultimate destinations. Distance vector algorithms are based on a table in each router listing the best route to every destination in the system. Of course, in order to define which route is best, we have to have some way of measuring goodness. This is referred to as the &#34;metric&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述，路由的目的是找到一种将数据报发送到最终目的地的方法。距离向量算法基于每个路由器中的一个表，该表列出了到系统中每个目的地的最佳路由。当然，为了确定哪条路线是最好的，我们必须有一些衡量善的方法。这被称为“度量”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In simple networks, it is common to use a metric that simply counts how many routers a message must go through. In more complex networks, a metric is chosen to represent the total amount of delay that the message suffers, the cost of sending it, or some other quantity which may be minimized. The main requirement is that it must be possible to represent the metric as a sum of &#34;costs&#34; for individual hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在简单的网络中，通常使用一个指标来计算一条消息必须经过多少路由器。在更复杂的网络中，选择一个度量来表示消息遭受的总延迟量、发送消息的成本，或者可以最小化的一些其他数量。主要要求是必须能够将度量表示为单个跃点的“成本”之和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Formally, if it is possible to get from entity i to entity j directly (i.e., without passing through another router between), then a cost, d(i,j), is associated with the hop between i and j. In the normal case where all entities on a given network are considered to be the same, d(i,j) is the same for all destinations on a given network, and represents the cost of using that network. To get the metric of a complete route, one just adds up the costs of the individual hops
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在形式上，如果可以直接从实体i到实体j（即，不通过实体i和实体j之间的另一个路由器），则成本d（i，j）与i和j之间的跳相关联。在给定网络上的所有实体被认为是相同的正常情况下，d（i，j）对于给定网络上的所有目的地是相同的，并且表示使用该网络的成本。要获得完整路线的度量，只需将各个跳数的成本相加即可
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
that make up the route. For the purposes of this memo, we assume that the costs are positive integers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这就是路线。在本备忘录中，我们假设成本为正整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let D(i,j) represent the metric of the best route from entity i to entity j. It should be defined for every pair of entities. d(i,j) represents the costs of the individual steps. Formally, let d(i,j) represent the cost of going directly from entity i to entity j. It is infinite if i and j are not immediate neighbors. (Note that d(i,i) is infinite. That is, we don&#39;t consider there to be a direct connection from a node to itself.) Since costs are additive, it is easy to show that the best metric must be described by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
设D（i，j）表示从实体i到实体j的最佳路径的度量。它应该为每对实体定义。d（i，j）表示各个步骤的成本。形式上，让d（i，j）表示直接从实体i到实体j的成本。如果i和j不是近邻，则它是无限的。（注意D（i，i）是无限的，也就是说，我们不考虑从节点到自身的直接连接）。因为成本是可加的，所以很容易证明最好的度量必须被描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
 D(i,i) = 0, all i D(i,j) = min [d(i,k) + D(k,j)], otherwise k and that the best routes start by going from i to those neighbors k for which d(i,k) + D(k,j) has the minimum value. (These things can be shown by induction on the number of steps in the routes.) Note that we can limit the second equation to k&#39;s that are immediate neighbors of i. For the others, d(i,k) is infinite, so the term involving them can never be the minimum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
D（i，i）=0，所有的id（i，j）=min[D（i，k）+D（k，j）]，否则k，最佳路由从i到D（i，k）+D（k，j）具有最小值的邻居k开始。（这些可以通过归纳路径中的步数来表示。）注意，我们可以将第二个方程限制为k，k是i的近邻。对于其他的，d（i，k）是无限的，因此涉及它们的项永远不可能是最小值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It turns out that one can compute the metric by a simple algorithm based on this. Entity i gets its neighbors k to send it their estimates of their distances to the destination j. When i gets the estimates from k, it adds d(i,k) to each of the numbers. This is simply the cost of traversing the network between i and k. Now and then i compares the values from all of its neighbors and picks the smallest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事实证明，可以通过基于此的简单算法来计算度量。实体i让其邻居k向其发送其到目的地j的距离估计值。当我从k得到估计值时，它把d（i，k）加到每个数字上。这只是在i和k之间穿越网络的成本。我不时比较它所有邻居的值，然后选择最小的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A proof is given in [2] that this algorithm will converge to the correct estimates of D(i,j) in finite time in the absence of topology changes. The authors make very few assumptions about the order in which the entities send each other their information, or when the min is recomputed. Basically, entities just can&#39;t stop sending updates or recomputing metrics, and the networks can&#39;t delay messages forever. (Crash of a routing entity is a topology change.) Also, their proof does not make any assumptions about the initial estimates of D(i,j), except that they must be non-negative. The fact that these fairly weak assumptions are good enough is important. Because we don&#39;t have to make assumptions about when updates are sent, it is safe to run the algorithm asynchronously. That is, each entity can send updates according to its own clock. Updates can be dropped by the network, as long as they don&#39;t all get dropped. Because we don&#39;t have to make assumptions about the starting condition, the algorithm can handle changes. When the system changes, the routing algorithm starts moving to a new equilibrium, using the old one as its starting point. It is important that the algorithm will converge in finite
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文[2]证明了在没有拓扑变化的情况下，该算法将在有限时间内收敛到D（i，j）的正确估计。作者很少假设实体之间相互发送信息的顺序，也很少假设何时重新计算最小值。基本上，实体无法停止发送更新或重新计算指标，网络也无法永远延迟消息。（路由实体的崩溃是一种拓扑变化。）此外，他们的证明没有对D（i，j）的初始估计做出任何假设，除非它们必须是非负的。这些相当弱的假设足够好这一事实很重要。因为我们不必对何时发送更新做出假设，所以异步运行算法是安全的。也就是说，每个实体都可以根据自己的时钟发送更新。更新可以被网络删除，只要它们没有全部被删除。因为我们不必对起始条件进行假设，所以算法可以处理更改。当系统发生变化时，路由算法开始移动到一个新的平衡点，使用旧的平衡点作为其起点。算法在有限域内收敛是很重要的
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time no matter what the starting point. Otherwise certain kinds of changes might lead to non-convergent behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
时间无论起点是什么。否则，某些类型的更改可能会导致非收敛行为。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The statement of the algorithm given above (and the proof) assumes that each entity keeps copies of the estimates that come from each of its neighbors, and now and then does a min over all of the neighbors. In fact real implementations don&#39;t necessarily do that. They simply remember the best metric seen so far, and the identity of the neighbor that sent it. They replace this information whenever they see a better (smaller) metric. This allows them to compute the minimum incrementally, without having to store data from all of the neighbors.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上面给出的算法声明（以及证明）假设每个实体保留来自其每个邻居的估计的副本，并且不时对所有邻居执行一次min。事实上，真正的实现并不一定要做到这一点。他们只记得迄今为止看到的最好的度量，以及发送它的邻居的身份。每当他们看到更好（更小）的指标时，他们就会替换这些信息。这允许他们以增量方式计算最小值，而不必存储来自所有邻居的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is one other difference between the algorithm as described in texts and those used in real protocols such as RIP: the description above would have each entity include an entry for itself, showing a distance of zero. In fact this is not generally done. Recall that all entities on a network are normally summarized by a single entry for the network. Consider the situation of a host or router G that is connected to network A. C represents the cost of using network A (usually a metric of one). (Recall that we are assuming that the internal structure of a network is not visible to IP, and thus the cost of going between any two entities on it is the same.) In principle, G should get a message from every other entity H on network A, showing a cost of 0 to get from that entity to itself. G would then compute C + 0 as the distance to H. Rather than having G look at all of these identical messages, it simply starts out by making an entry for network A in its table, and assigning it a metric of C. This entry for network A should be thought of as summarizing the entries for all other entities on network A. The only entity on A that can&#39;t be summarized by that common entry is G itself, since the cost of going from G to G is 0, not C. But since we never need those 0 entries, we can safely get along with just the single entry for network A. Note one other implication of this strategy: because we don&#39;t need to use the 0 entries for anything, hosts that do not function as routers don&#39;t need to send any update messages. Clearly hosts that don&#39;t function as routers (i.e., hosts that are connected to only one network) can have no useful information to contribute other than their own entry D(i,i) = 0. As they have only the one interface, it is easy to see that a route to any other network through them will simply go in that interface and then come right back out it. Thus the cost of such a route will be greater than the best cost by at least C. Since we don&#39;t need the 0 entries, non-routers need not participate in the routing protocol at all.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
文本中描述的算法与实际协议（如RIP）中使用的算法之间还有另一个区别：上面的描述将使每个实体包含一个自身的条目，显示为零的距离。事实上，这并不是一般的做法。回想一下，网络上的所有实体通常由网络的单个条目汇总。考虑连接到网络的主机或路由器G的情况。C表示使用网络A的成本（通常为1的度量）。（回想一下，我们假设网络的内部结构对IP不可见，因此在网络上的任何两个实体之间移动的成本是相同的。）原则上，G应该从网络a上的每个其他实体H获得一条消息，显示从该实体到自身的成本为0。然后G将计算C+0作为到H的距离。与其让G查看所有这些相同的消息，它只需在表中为网络A创建一个条目，并为其指定一个度量C。网络a的这个条目应被视为汇总网络a上所有其他实体的条目。a上唯一不能由该公共条目汇总的实体是G本身，因为从G到G的成本是0，而不是C。但因为我们从不需要这些0条目，我们可以安全地只使用网络A的单个条目。请注意此策略的另一个含义：因为我们不需要将0条目用于任何事情，所以不作为路由器运行的主机不需要发送任何更新消息。显然，不作为路由器工作的主机（即，仅连接到一个网络的主机）除了其自身的条目D（i，i）=0之外，没有其他有用的信息可供提供。由于它们只有一个接口，很容易看到通过它们到任何其他网络的路由只需进入该接口，然后直接从该接口返回。因此，这种路由的成本将比最佳成本至少高出C。因为我们不需要0条目，非路由器根本不需要参与路由协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let us summarize what a host or router G does. For each destination in the system, G will keep a current estimate of the metric for that destination (i.e., the total cost of getting to it) and the identity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
让我们总结一下主机或路由器G的功能。对于系统中的每个目的地，G将保留该目的地的度量（即到达目的地的总成本）和身份的当前估计
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
of the neighboring router on whose data that metric is based. If the destination is on a network that is directly connected to G, then G simply uses an entry that shows the cost of using the network, and the fact that no router is needed to get to the destination. It is easy to show that once the computation has converged to the correct metrics, the neighbor that is recorded by this technique is in fact the first router on the path to the destination. (If there are several equally good paths, it is the first router on one of them.) This combination of destination, metric, and router is typically referred to as a route to the destination with that metric, using that router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该度量基于其数据的相邻路由器的。如果目的地位于直接连接到G的网络上，那么G只需使用一个条目来显示使用网络的成本，以及无需路由器即可到达目的地的事实。很容易证明，一旦计算收敛到正确的度量，通过这种技术记录的邻居实际上是到达目的地的路径上的第一个路由器。（如果有多条同样好的路径，则它是其中一条路径上的第一个路由器。）目的地、度量和路由器的这种组合通常被称为使用该路由器到具有该度量的目的地的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.ne The method so far only has a way to lower the metric, as the existing metric is kept until a smaller one shows up. It is possible that the initial estimate might be too low. Thus, there must be a way to increase the metric. It turns out to be sufficient to use the following rule: suppose the current route to a destination has metric D and uses router G. If a new set of information arrived from some source other than G, only update the route if the new metric is better than D. But if a new set of information arrives from G itself, always update D to the new value. It is easy to show that with this rule, the incremental update process produces the same routes as a calculation that remembers the latest information from all the neighbors and does an explicit minimum. (Note that the discussion so far assumes that the network configuration is static. It does not allow for the possibility that a system might fail.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4.ne到目前为止，该方法只能降低指标，因为现有指标会一直保持到较小的指标出现为止。初步估计可能太低。因此，必须有一种方法来增加度量。使用以下规则就足够了：假设到目的地的当前路由具有度量D并使用路由器G。如果一组新信息来自G以外的其他来源，则仅当新度量优于D时才更新路由。但如果一组新信息来自G本身，则始终将D更新为新值。很容易看出，使用此规则，增量更新过程产生的路由与记住所有邻居的最新信息并执行显式最小值的计算相同。（注意，到目前为止的讨论假设网络配置是静态的。它不允许系统发生故障的可能性。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To summarize, here is the basic distance vector algorithm as it has been developed so far. (Note that this is not a statement of the RIP protocol. There are several refinements still to be added.) The following procedure is carried out by every entity that participates in the routing protocol. This must include all of the routers in the system. Hosts that are not routers may participate as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总而言之，这里是迄今为止开发的基本距离向量算法。（请注意，这不是RIP协议的声明。还有一些改进需要补充。）以下过程由参与路由协议的每个实体执行。这必须包括系统中的所有路由器。非路由器的主机也可以参与。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Keep a table with an entry for every possible destination in the system. The entry contains the distance D to the destination, and the first router G on the route to that network. Conceptually, there should be an entry for the entity itself, with metric 0, but this is not actually included.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 为系统中每个可能的目的地保留一个表项。该条目包含到目的地的距离D，以及到该网络的路由上的第一个路由器G。从概念上讲，实体本身应该有一个条目，度量值为0，但实际上不包括该条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Periodically, send a routing update to every neighbor. The update is a set of messages that contain all of the information from the routing table. It contains an entry for each destination, with the distance shown to that destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 定期向每个邻居发送路由更新。更新是一组包含路由表中所有信息的消息。它包含每个目的地的一个条目，其中显示了到该目的地的距离。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- When a routing update arrives from a neighbor G&#39;, add the cost associated with the network that is shared with G&#39;. (This should be the network over which the update arrived.) Call the resulting
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 当路由更新从邻居G&#39;到达时，添加与G&#39;共享的网络相关的成本。（这应该是更新到达的网络。）调用生成的
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
distance D&#39;. Compare the resulting distances with the current routing table entries. If the new distance D&#39; for N is smaller than the existing value D, adopt the new route. That is, change the table entry for N to have metric D&#39; and router G&#39;. If G&#39; is the router from which the existing route came, i.e., G&#39; = G, then use the new metric even if it is larger than the old one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
距离D’。将结果距离与当前路由表项进行比较。如果N的新距离D&#39;小于现有值D，则采用新路线。也就是说，将N的表项更改为具有度量D&#39;和路由器G&#39;。如果G&#39;是现有路由来自的路由器，即G&#39;=G，则使用新度量，即使它大于旧度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1 Dealing with changes in topology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1 处理拓扑中的更改
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The discussion above assumes that the topology of the network is fixed. In practice, routers and lines often fail and come back up. To handle this possibility, we need to modify the algorithm slightly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上面的讨论假设网络的拓扑结构是固定的。在实践中，路由器和线路经常出现故障并重新启动。为了处理这种可能性，我们需要稍微修改算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The theoretical version of the algorithm involved a minimum over all immediate neighbors. If the topology changes, the set of neighbors changes. Therefore, the next time the calculation is done, the change will be reflected. However, as mentioned above, actual implementations use an incremental version of the minimization. Only the best route to any given destination is remembered. If the router involved in that route should crash, or the network connection to it break, the calculation might never reflect the change. The algorithm as shown so far depends upon a router notifying its neighbors if its metrics change. If the router crashes, then it has no way of notifying neighbors of a change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法的理论版本涉及所有近邻的最小值。如果拓扑更改，则邻居集也会更改。因此，下次进行计算时，将反映出变化。然而，如上所述，实际实现使用了最小化的增量版本。只有到达任何给定目的地的最佳路线才会被记住。如果该路由所涉及的路由器崩溃，或者与它的网络连接中断，那么计算可能永远不会反映出变化。到目前为止，所示的算法取决于路由器在其度量发生变化时通知其邻居。如果路由器崩溃，那么它无法通知邻居更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to handle problems of this kind, distance vector protocols must make some provision for timing out routes. The details depend upon the specific protocol. As an example, in RIP every router that participates in routing sends an update message to all its neighbors once every 30 seconds. Suppose the current route for network N uses router G. If we don&#39;t hear from G for 180 seconds, we can assume that either the router has crashed or the network connecting us to it has become unusable. Thus, we mark the route as invalid. When we hear from another neighbor that has a valid route to N, the valid route will replace the invalid one. Note that we wait for 180 seconds before timing out a route even though we expect to hear from each neighbor every 30 seconds. Unfortunately, messages are occasionally lost by networks. Thus, it is probably not a good idea to invalidate a route based on a single missed message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了处理这类问题，距离向量协议必须为路由超时做一些准备。细节取决于具体的协议。例如，在RIP中，参与路由的每个路由器每30秒向其所有邻居发送一次更新消息。假设网络N的当前路由使用路由器G。如果我们在180秒内没有收到G的消息，我们可以假设路由器已经崩溃，或者连接到它的网络已经不可用。因此，我们将路由标记为无效。当我们听到另一个邻居有一个到N的有效路由时，有效路由将替换无效路由。请注意，我们会等待180秒，然后再对路由进行计时，即使我们希望每30秒收到一个邻居的消息。不幸的是，网络偶尔会丢失消息。因此，基于单个丢失的消息使路由无效可能不是一个好主意。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As we will see below, it is useful to have a way to notify neighbors that there currently isn&#39;t a valid route to some network. RIP, along with several other protocols of this class, does this through a normal update message, by marking that network as unreachable. A specific metric value is chosen to indicate an unreachable destination; that metric value is larger than the largest valid metric that we expect to see. In the existing implementation of RIP, 16 is used. This value is normally referred to as &#34;infinity&#34;, since
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正如我们将在下面看到的，有一种方法可以通知邻居当前没有到某个网络的有效路由，这很有用。RIP和该类的其他几个协议通过一条普通的更新消息来实现这一点，将该网络标记为不可访问。选择特定度量值以指示无法到达的目的地；该度量值大于我们期望看到的最大有效度量。在RIP的现有实现中，使用了16。该值通常称为“无穷大”，因为
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
it is larger than the largest valid metric. 16 may look like a surprisingly small number. It is chosen to be this small for reasons that we will see shortly. In most implementations, the same convention is used internally to flag a route as invalid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
它大于最大的有效度量。16可能看起来是一个令人惊讶的小数字。选择它这么小的原因我们很快就会看到。在大多数实现中，相同的约定在内部用于将路由标记为无效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2 Preventing instability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2 防止不稳定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm as presented up to this point will always allow a host or router to calculate a correct routing table. However, that is still not quite enough to make it useful in practice. The proofs referred to above only show that the routing tables will converge to the correct values in finite time. They do not guarantee that this time will be small enough to be useful, nor do they say what will happen to the metrics for networks that become inaccessible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目前提出的算法将始终允许主机或路由器计算正确的路由表。然而，这还不足以使它在实践中发挥作用。上述证明仅表明路由表将在有限时间内收敛到正确的值。他们不能保证这段时间足够小，可以发挥作用，也不能保证无法访问的网络的指标会发生什么变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is easy enough to extend the mathematics to handle routes becoming inaccessible. The convention suggested above will do that. We choose a large metric value to represent &#34;infinity&#34;. This value must be large enough that no real metric would ever get that large. For the purposes of this example, we will use the value 16. Suppose a network becomes inaccessible. All of the immediately neighboring routers time out and set the metric for that network to 16. For purposes of analysis, we can assume that all the neighboring routers have gotten a new piece of hardware that connects them directly to the vanished network, with a cost of 16. Since that is the only connection to the vanished network, all the other routers in the system will converge to new routes that go through one of those routers. It is easy to see that once convergence has happened, all the routers will have metrics of at least 16 for the vanished network. Routers one hop away from the original neighbors would end up with metrics of at least 17; routers two hops away would end up with at least 18, etc. As these metrics are larger than the maximum metric value, they are all set to 16. It is obvious that the system will now converge to a metric of 16 for the vanished network at all routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
扩展数学来处理变得不可访问的路径是很容易的。上述建议的公约将做到这一点。我们选择一个较大的度量值来表示“无穷大”。该值必须足够大，以确保任何实际度量都不会达到如此大的值。在本例中，我们将使用值16。假设网络变得不可访问。所有紧邻的路由器超时，并将该网络的度量设置为16。为了便于分析，我们可以假设所有相邻的路由器都获得了一个新的硬件，将它们直接连接到消失的网络，成本为16美元。由于这是到消失网络的唯一连接，系统中的所有其他路由器将汇聚到通过其中一个路由器的新路由。很容易看出，一旦发生融合，所有路由器的网络指标至少为16。距离原始邻居一跳的路由器的度量值至少为17；两个跃点之外的路由器将至少有18个，以此类推。由于这些度量值大于最大度量值，它们都设置为16。很明显，对于所有路由器上消失的网络，该系统现在将收敛到16。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unfortunately, the question of how long convergence will take is not amenable to quite so simple an answer. Before going any further, it will be useful to look at an example (taken from [2]). Note that what we are about to show will not happen with a correct implementation of RIP. We are trying to show why certain features are needed. In the following example the letters correspond to routers, and the lines to networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不幸的是，融合需要多长时间的问题并不是一个非常简单的答案。在进一步讨论之前，先看一个示例（取自[2]）。请注意，我们将要展示的内容不会在RIP的正确实现中发生。我们试图说明为什么需要某些功能。在下面的示例中，字母对应路由器，线路对应网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     A-----B
      \   / \
       \ /  |
        C  /    all networks have cost 1, except
        | /     for the direct link from C to D, which
        |/      has cost 10
        D
        |&lt;=== target network
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     A-----B
      \   / \
       \ /  |
        C  /    all networks have cost 1, except
        | /     for the direct link from C to D, which
        |/      has cost 10
        D
        |&lt;=== target network
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each router will have a table showing a route to each network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个路由器都有一个表，显示到每个网络的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, for purposes of this illustration, we show only the routes from each router to the network marked at the bottom of the diagram.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，出于本图的目的，我们仅显示从每个路由器到图底部标记的网络的路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
D: directly connected, metric 1 B: route via D, metric 2 C: route via B, metric 3 A: route via B, metric 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-11">
D：直接连接，度量1 B：经由D的路由，度量2 C：经由B的路由，度量3 A：经由B的路由，度量3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now suppose that the link from B to D fails. The routes should now adjust to use the link from C to D. Unfortunately, it will take a while for this to this to happen. The routing changes start when B notices that the route to D is no longer usable. For simplicity, the chart below assumes that all routers send updates at the same time. The chart shows the metric for the target network, as it appears in the routing table at each router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在假设从B到D的链接失败。现在应该调整路由以使用从C到D的链路。不幸的是，这需要一段时间才能实现。当B发现到D的路由不再可用时，路由更改开始。为简单起见，下表假设所有路由器同时发送更新。该图表显示了目标网络的指标，它显示在每个路由器的路由表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       time ------&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       time ------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
D: dir, 1 dir, 1 dir, 1 dir, 1 ... dir, 1 dir, 1 B: unreach C, 4 C, 5 C, 6 C, 11 C, 12 C: B, 3 A, 4 A, 5 A, 6 A, 11 D, 11 A: B, 3 C, 4 C, 5 C, 6 C, 11 C, 12
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
迪尔，1迪尔，1迪尔，1迪尔，1迪尔，1。。。目录，1目录，1 B：未读C，4 C，5 C，6 C，11 C，12 C:B，3 A，4 A，5 A，6 A，11 D，11 A:B，3 C，4 C，5 C，6 C，11 C，12
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dir = directly connected unreach = unreachable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
dir=直接连接的未连接=无法连接
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Here&#39;s the problem: B is able to get rid of its failed route using a timeout mechanism, but vestiges of that route persist in the system for a long time. Initially, A and C still think they can get to D via B. So, they keep sending updates listing metrics of 3. In the next iteration, B will then claim that it can get to D via either A or C. Of course, it can&#39;t. The routes being claimed by A and C are now gone, but they have no way of knowing that yet. And even when they discover that their routes via B have gone away, they each think there is a route available via the other. Eventually the system converges, as all the mathematics claims it must. But it can take some time to do so. The worst case is when a network becomes
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
问题是：B能够使用超时机制摆脱失败的路由，但该路由的残余在系统中保留很长时间。起初，A和C仍然认为他们可以通过B到达D。因此，他们不断发送更新，列出了3的指标。在下一次迭代中，B将声称它可以通过A或C到达D。当然，它不能。A和C声称的路线现在已经消失了，但他们还没有办法知道这一点。甚至当他们发现他们通过B的路线已经消失时，他们都认为有一条路线可以通过另一条。正如所有数学理论所宣称的那样，系统最终会收敛。但这样做可能需要一些时间。最坏的情况是当网络变得
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
completely inaccessible from some part of the system. In that case, the metrics may increase slowly in a pattern like the one above until they finally reach infinity. For this reason, the problem is called &#34;counting to infinity&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从系统的某些部分完全无法访问。在这种情况下，度量可能会以类似于上述模式的方式缓慢增加，直到它们最终达到无穷大。因此，这个问题被称为“数到无穷”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
You should now see why &#34;infinity&#34; is chosen to be as small as possible. If a network becomes completely inaccessible, we want counting to infinity to be stopped as soon as possible. Infinity must be large enough that no real route is that big. But it shouldn&#39;t be any bigger than required. Thus the choice of infinity is a tradeoff between network size and speed of convergence in case counting to infinity happens. The designers of RIP believed that the protocol was unlikely to be practical for networks with a diameter larger than 15.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在，您应该了解为什么选择“无限”尽可能小。如果网络变得完全不可访问，我们希望尽可能快地停止无限计数。无限必须足够大，以至于没有真正的路线那么大。但它不应该比要求的大。因此，选择无穷大是网络规模和收敛速度之间的折衷，以防计数到无穷大。RIP的设计者认为，该协议不太可能适用于直径大于15的网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are several things that can be done to prevent problems like this. The ones used by RIP are called &#34;split horizon with poisoned reverse&#34;, and &#34;triggered updates&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有几件事可以做，以防止像这样的问题。RIP所使用的被称为“带有毒反转的分割地平线”和“触发更新”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3 Split horizon
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.3 分裂地平线
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that some of the problem above is caused by the fact that A and C are engaged in a pattern of mutual deception. Each claims to be able to get to D via the other. This can be prevented by being a bit more careful about where information is sent. In particular, it is never useful to claim reachability for a destination network to the neighbor(s) from which the route was learned. &#34;Split horizon&#34; is a scheme for avoiding problems caused by including routes in updates sent to the router from which they were learned. The &#34;simple split horizon&#34; scheme omits routes learned from one neighbor in updates sent to that neighbor. &#34;Split horizon with poisoned reverse&#34; includes such routes in updates, but sets their metrics to infinity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，上面的一些问题是由A和C相互欺骗的模式引起的。每个人都声称能够通过另一个到达D。这可以通过更仔细地了解信息的发送位置来防止。特别是，声称目的地网络对从中学习路由的邻居的可达性是没有用的。“分割地平线”是一种方案，用于避免将路由包含在发送到从中学习路由的路由器的更新中所引起的问题。“简单分割地平线”方案在发送给一个邻居的更新中忽略了从该邻居那里学到的路由。“带有毒反转的分割地平线”在更新中包括这些路线，但将它们的度量设置为无穷大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If A thinks it can get to D via C, its messages to C should indicate that D is unreachable. If the route through C is real, then C either has a direct connection to D, or a connection through some other router. C&#39;s route can&#39;t possibly go back to A, since that forms a loop. By telling C that D is unreachable, A simply guards against the possibility that C might get confused and believe that there is a route through A. This is obvious for a point to point line. But consider the possibility that A and C are connected by a broadcast network such as an Ethernet, and there are other routers on that network. If A has a route through C, it should indicate that D is unreachable when talking to any other router on that network. The other routers on the network can get to C themselves. They would never need to get to C via A. If A&#39;s best route is really through C, no other router on that network needs to know that A can reach D. This is fortunate, because it means that the same update message that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果A认为它可以通过C到达D，那么它发送给C的消息应该表明D是不可到达的。如果通过C的路由是实路由，那么C要么直接连接到D，要么通过其他路由器连接。C的路线不可能回到A，因为它形成了一个循环。通过告诉C D是不可到达的，A简单地防止了C可能会混淆的可能性，并相信有一条路线通过A。这对于点对点线来说是显而易见的。但是考虑A和C通过广播网络（例如以太网）连接的可能性，并且在该网络上还有其他路由器。如果A有一条通过C的路由，它应该表明D在与该网络上的任何其他路由器通话时是不可到达的。网络上的其他路由器可以自己访问C。他们永远不需要通过A到达C。如果A的最佳路径是通过C，那么该网络上的任何其他路由器都不需要知道A可以到达D。这是幸运的，因为这意味着
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is used for C can be used for all other routers on the same network. Thus, update messages can be sent by broadcast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于C，可用于同一网络上的所有其他路由器。因此，更新消息可以通过广播发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, split horizon with poisoned reverse is safer than simple split horizon. If two routers have routes pointing at each other, advertising reverse routes with a metric of 16 will break the loop immediately. If the reverse routes are simply not advertised, the erroneous routes will have to be eliminated by waiting for a timeout. However, poisoned reverse does have a disadvantage: it increases the size of the routing messages. Consider the case of a campus backbone connecting a number of different buildings. In each building, there is a router connecting the backbone to a local network. Consider what routing updates those routers should broadcast on the backbone network. All that the rest of the network really needs to know about each router is what local networks it is connected to. Using simple split horizon, only those routes would appear in update messages sent by the router to the backbone network. If split horizon with poisoned reverse is used, the router must mention all routes that it learns from the backbone, with metrics of 16. If the system is large, this can result in a large update message, almost all of whose entries indicate unreachable networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般来说，反向有毒的分割地平线比简单的分割地平线更安全。如果两个路由器的路由彼此指向对方，则以16为度量的反向路由广告将立即中断循环。如果根本没有公布反向路由，则必须通过等待超时来消除错误路由。然而，中毒反向确实有一个缺点：它增加了路由消息的大小。考虑一个校园主干连接多个不同建筑的情况。在每栋建筑中，都有一个路由器将主干网连接到本地网络。考虑路由器在主干网络上应该广播哪些路由更新。网络的其他部分真正需要了解的是每个路由器连接到的本地网络。使用简单的拆分地平线，只有这些路由才会出现在路由器发送到主干网的更新消息中。如果使用带有毒反向的拆分地平线，路由器必须提到它从主干网学习到的所有路由，度量值为16。如果系统较大，则可能会产生较大的更新消息，几乎所有条目都表示无法访问网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a static sense, advertising reverse routes with a metric of 16 provides no additional information. If there are many routers on one broadcast network, these extra entries can use significant bandwidth. The reason they are there is to improve dynamic behavior. When topology changes, mentioning routes that should not go through the router as well as those that should can speed up convergence. However, in some situations, network managers may prefer to accept somewhat slower convergence in order to minimize routing overhead. Thus implementors may at their option implement simple split horizon rather than split horizon with poisoned reverse, or they may provide a configuration option that allows the network manager to choose which behavior to use. It is also permissible to implement hybrid schemes that advertise some reverse routes with a metric of 16 and omit others. An example of such a scheme would be to use a metric of 16 for reverse routes for a certain period of time after routing changes involving them, and thereafter omitting them from updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在静态意义上，指标为16的反向路线广告不提供额外信息。如果一个广播网络上有多个路由器，这些额外的条目可能会占用大量带宽。它们存在的原因是为了改善动态行为。当拓扑结构发生变化时，提及不应该通过路由器的路由以及应该通过路由器的路由可以加快收敛速度。然而，在某些情况下，网络管理者可能更愿意接受较慢的收敛速度，以最小化路由开销。因此，实施者可以选择实施简单的拆分地平线，而不是使用有毒的反向拆分地平线，或者他们可以提供一个配置选项，允许网络管理器选择要使用的行为。也允许实施混合方案，以16的度量为某些反向路线做广告，而忽略其他路线。这种方案的一个例子是，在涉及反向路由的路由更改之后的一段时间内，对反向路由使用16的度量，然后在更新中忽略它们。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The router requirements RFC [11] specifies that all implementation of RIP must use split horizon and should also use split horizon with poisoned reverse, although there may be a knob to disable poisoned reverse.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器要求RFC[11]规定，RIP的所有实现必须使用分割地平线，并且还应使用带有中毒反转的分割地平线，尽管可能有一个旋钮来禁用中毒反转。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.4 Triggered updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.4 触发的更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Split horizon with poisoned reverse will prevent any routing loops that involve only two routers. However, it is still possible to end up with patterns in which three routers are engaged in mutual deception. For example, A may believe it has a route through B, B through C, and C through A. Split horizon cannot stop such a loop. This loop will only be resolved when the metric reaches infinity and the network involved is then declared unreachable. Triggered updates are an attempt to speed up this convergence. To get triggered updates, we simply add a rule that whenever a router changes the metric for a route, it is required to send update messages almost immediately, even if it is not yet time for one of the regular update message. (The timing details will differ from protocol to protocol. Some distance vector protocols, including RIP, specify a small time delay, in order to avoid having triggered updates generate excessive network traffic.) Note how this combines with the rules for computing new metrics. Suppose a router&#39;s route to destination N goes through router G. If an update arrives from G itself, the receiving router is required to believe the new information, whether the new metric is higher or lower than the old one. If the result is a change in metric, then the receiving router will send triggered updates to all the hosts and routers directly connected to it. They in turn may each send updates to their neighbors. The result is a cascade of triggered updates. It is easy to show which routers and hosts are involved in the cascade. Suppose a router G times out a route to destination N. G will send triggered updates to all of its neighbors. However, the only neighbors who will believe the new information are those whose routes for N go through G. The other routers and hosts will see this as information about a new route that is worse than the one they are already using, and ignore it. The neighbors whose routes go through G will update their metrics and send triggered updates to all of their neighbors. Again, only those neighbors whose routes go through them will pay attention. Thus, the triggered updates will propagate backwards along all paths leading to router G, updating the metrics to infinity. This propagation will stop as soon as it reaches a portion of the network whose route to destination N takes some other path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
带有毒反向的分割地平线将防止任何只涉及两个路由器的路由循环。然而，仍然有可能以三个路由器相互欺骗的模式结束。例如，A可能认为它有一条经过B、B到C、C到A的路线。拆分地平线无法阻止这样的循环。只有当度量值达到无穷大且所涉及的网络被声明为不可访问时，才会解析此循环。触发更新是为了加速这种融合。要获得触发的更新，我们只需添加一条规则，即每当路由器更改路由的度量时，它几乎需要立即发送更新消息，即使还没有时间发送一条常规更新消息。（定时细节因协议而异。一些距离向量协议（包括RIP）指定了一个小的时间延迟，以避免触发的更新产生过多的网络流量。）请注意这与计算新指标的规则是如何结合的。假设一个路由器到目的地N的路由经过路由器G。如果更新从G本身到达，则接收路由器需要相信新信息，无论新度量是高于还是低于旧度量。如果结果是度量值发生变化，则接收路由器将向直接连接到它的所有主机和路由器发送触发的更新。他们可以依次向邻居发送更新。结果是一系列触发的更新。很容易显示级联中涉及哪些路由器和主机。假设路由器G超时到目的地N的路由，G将向其所有邻居发送触发的更新。然而，唯一相信新信息的邻居是那些N的路由通过G的邻居。其他路由器和主机会将此视为比他们已经使用的路由更差的新路由的信息，并忽略它。路由通过G的邻居将更新其度量并向其所有邻居发送触发的更新。同样，只有那些路线经过的邻居才会注意。因此，触发的更新将沿着通向路由器G的所有路径向后传播，将度量更新到无穷大。一旦到达到目的地N的路由采用其他路径的网络部分，该传播就会停止。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the system could be made to sit still while the cascade of triggered updates happens, it would be possible to prove that counting to infinity will never happen. Bad routes would always be removed immediately, and so no routing loops could form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果系统能够在触发的更新级联发生时静止不动，那么就有可能证明数到无穷远永远不会发生。坏路由总是会立即被删除，因此不会形成路由循环。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unfortunately, things are not so nice. While the triggered updates are being sent, regular updates may be happening at the same time. Routers that haven&#39;t received the triggered update yet will still be sending out information based on the route that no longer exists. It
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不幸的是，情况并非如此美好。在发送触发的更新时，可能同时发生定期更新。尚未收到触发更新的路由器仍将根据不再存在的路由发送信息。信息技术
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
is possible that after the triggered update has gone through a router, it might receive a normal update from one of these routers that hasn&#39;t yet gotten the word. This could reestablish an orphaned remnant of the faulty route. If triggered updates happen quickly enough, this is very unlikely. However, counting to infinity is still possible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有可能在触发的更新经过路由器之后，它可能会从其中一个尚未获得该字的路由器接收到正常更新。这可能会重新建立故障线路的孤立残余。如果触发的更新发生得足够快，这是不太可能的。然而，数到无穷大仍然是可能的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The router requirements RFC [11] specifies that all implementation of RIP must implement triggered update for deleted routes and may implement triggered updates for new routes or change of routes. RIP implementations must also limit the rate which of triggered updates may be trandmitted. (see section 3.10.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器要求RFC[11]规定，RIP的所有实现必须对已删除的路由执行触发更新，并可对新路由或路由更改执行触发更新。RIP实现还必须限制触发更新的传输速率。（见第3.10.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5 Protocol Specification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5 协议规范
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP is intended to allow routers to exchange information for computing routes through an IPv4-based network. Any router that uses RIP is assumed to have interfaces to one or more networks, otherwise it isn&#39;t really a router. These are referred to as its directly-connected networks. The protocol relies on access to certain information about each of these networks, the most important of which is its metric. The RIP metric of a network is an integer between 1 and 15, inclusive. It is set in some manner not specified in this protocol; however, given the maximum path limit of 15, a value of 1 is usually used. Implementations should allow the system administrator to set the metric of each network. In addition to the metric, each network will have an IPv4 destination address and subnet mask associated with it. These are to be set by the system administrator in a manner not specified in this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP旨在允许路由器通过基于IPv4的网络交换计算路由的信息。任何使用RIP的路由器都假定有一个或多个网络的接口，否则它就不是真正的路由器。这些被称为其直接连接的网络。该协议依赖于对每个网络的特定信息的访问，其中最重要的是其度量。网络的RIP度量是一个介于1和15之间（包括1和15）的整数。以本协议未规定的方式设置；但是，如果最大路径限制为15，则通常使用值1。实现应该允许系统管理员设置每个网络的度量。除了度量之外，每个网络都将有一个IPv4目标地址和与其关联的子网掩码。这些由系统管理员以本协议中未指定的方式进行设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any host that uses RIP is assumed to have interfaces to one or more networks. These are referred to as its &#34;directly-connected networks&#34;. The protocol relies on access to certain information about each of these networks. The most important is its metric or &#34;cost&#34;. The metric of a network is an integer between 1 and 15 inclusive. It is set in some manner not specified in this protocol. Most existing implementations always use a metric of 1. New implementations should allow the system administrator to set the cost of each network. In addition to the cost, each network will have an IPv4 network number and a subnet mask associated with it. These are to be set by the system administrator in a manner not specified in this protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设任何使用RIP的主机都有到一个或多个网络的接口。这些被称为“直接连接的网络”。该协议依赖于对每个网络的特定信息的访问。最重要的是它的度量或“成本”。网络的度量是一个介于1和15（含1和15）之间的整数。它是以本协议中未指定的某种方式设置的。大多数现有的实现总是使用1的度量。新的实现应该允许系统管理员设置每个网络的成本。除了成本之外，每个网络都有一个IPv4网络号和一个子网掩码。这些由系统管理员以本协议中未指定的方式进行设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the rules specified in section 3.7 assume that there is a single subnet mask applying to each IPv4 network, and that only the subnet masks for directly-connected networks are known. There may be systems that use different subnet masks for different subnets within a single network. There may also be instances where it is desirable
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，第3.7节中指定的规则假定每个IPv4网络都有一个子网掩码，并且只有直接连接网络的子网掩码是已知的。可能有一些系统在单个网络中为不同的子网使用不同的子网掩码。在某些情况下，这也是可取的
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for a system to know the subnets masks of distant networks. Network-wide distribution of routing information which contains different subnet masks is permitted if all routers in the network are running the extensions presented in this document. However, if all routers in the network are not running these extensions distribution of routing information containing different subnet masks must be limited to avoid interoperability problems. See sections 3.7 and 4.3 for the rules governing subnet distribution.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用于系统了解远程网络的子网掩码。如果网络中的所有路由器都运行本文档中介绍的扩展，则允许在网络范围内分发包含不同子网掩码的路由信息。但是，如果网络中的所有路由器都没有运行这些扩展，则必须限制包含不同子网掩码的路由信息的分发，以避免互操作性问题。有关子网分布的规则，请参见第3.7节和第4.3节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each router that implements RIP is assumed to have a routing table. This table has one entry for every destination that is reachable throughout the system operating RIP. Each entry contains at least the following information:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设每个实现RIP的路由器都有一个路由表。此表中的每个目的地都有一个条目，可在整个系统操作过程中访问。每个条目至少包含以下信息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The IPv4 address of the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 目标的IPv4地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- A metric, which represents the total cost of getting a datagram from the router to that destination. This metric is the sum of the costs associated with the networks that would be traversed to get to the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 一种度量，表示从路由器到该目的地获取数据报的总成本。该指标是与到达目的地所需的网络相关的成本之和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The IPv4 address of the next router along the path to the destination (i.e., the next hop). If the destination is on one of the directly-connected networks, this item is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 沿目标路径（即下一跳）的下一个路由器的IPv4地址。如果目标位于其中一个直接连接的网络上，则不需要此项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- A flag to indicate that information about the route has changed recently. This will be referred to as the &#34;route change flag.&#34;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 指示有关路线的信息最近已更改的标志。这将被称为“路线变更标志”
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Various timers associated with the route. See section 3.6 for more details on timers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 与路线相关的各种计时器。有关计时器的更多详细信息，请参见第3.6节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The entries for the directly-connected networks are set up by the router using information gathered by means not specified in this protocol. The metric for a directly-connected network is set to the cost of that network. As mentioned, 1 is the usual cost. In that case, the RIP metric reduces to a simple hop-count. More complex metrics may be used when it is desirable to show preference for some networks over others (e.g., to indicate of differences in bandwidth or reliability).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
直接连接网络的条目由路由器使用通过本协议中未指定的方式收集的信息设置。直接连接网络的指标设置为该网络的成本。如前所述，1是通常的成本。在这种情况下，RIP度量减少为一个简单的跃点计数。当需要显示对某些网络的偏好超过其他网络时（例如，指示带宽或可靠性的差异），可以使用更复杂的度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support the extensions detailed in this document, each entry must additionally contain a subnet mask. The subnet mask allows the router (along with the IPv4 address of the destination) to identify the different subnets within a single network as well as the subnets masks of distant networks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了支持本文档中详述的扩展，每个条目还必须包含子网掩码。子网掩码允许路由器（连同目的地的IPv4地址）识别单个网络中的不同子网以及远程网络的子网掩码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementors may also choose to allow the system administrator to enter additional routes. These would most likely be routes to hosts or networks outside the scope of the routing system. They are referred to as &#34;static routes.&#34; Entries for destinations other than these initial ones are added and updated by the algorithms described in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实施者还可以选择允许系统管理员输入其他路由。这些很可能是路由系统范围之外的主机或网络的路由。它们被称为“静态路由”。除了这些初始路由之外，其他目的地的条目将通过以下部分中描述的算法添加和更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order for the protocol to provide complete information on routing, every router in the AS must participate in the protocol. In cases where multiple IGPs are in use, there must be at least one router which can leak routing information between the protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了使协议提供有关路由的完整信息，AS中的每个路由器都必须参与协议。在使用多个IGP的情况下，必须至少有一个路由器可以泄漏协议之间的路由信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6 Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6 消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP is a UDP-based protocol. Each router that uses RIP has a routing process that sends and receives datagrams on UDP port number 520, the RIP-1/RIP-2 port. All communications intended for another routers&#39;s RIP process are sent to the RIP port. All routing update messages are sent from the RIP port. Unsolicited routing update messages have both the source and destination port equal to the RIP port. Update messages sent in response to a request are sent to the port from which the request came. Specific queries may be sent from ports other than the RIP port, but they must be directed to the RIP port on the target machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP是一种基于UDP的协议。每个使用RIP的路由器都有一个路由过程，在UDP端口520（RIP-1/RIP-2端口）上发送和接收数据报。用于另一路由器RIP进程的所有通信都发送到RIP端口。所有路由更新消息都从RIP端口发送。未经请求的路由更新消息的源端口和目标端口均等于RIP端口。响应请求而发送的更新消息将发送到发出请求的端口。特定查询可以从RIP端口以外的端口发送，但必须定向到目标机器上的RIP端口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RIP packet format is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP数据包格式为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  command (1)  |  version (1)  |       must be zero (2)        |
      +---------------+---------------+-------------------------------+
      |                                                               |
      ~                         RIP Entry (20)                        ~
      |                                                               |
      +---------------+---------------+---------------+---------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  command (1)  |  version (1)  |       must be zero (2)        |
      +---------------+---------------+-------------------------------+
      |                                                               |
      ~                         RIP Entry (20)                        ~
      |                                                               |
      +---------------+---------------+---------------+---------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There may be between 1 and 25 (inclusive) RIP entries. A RIP-1 entry has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能有1到25个（含）RIP条目。RIP-1条目具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | address family identifier (2) |      must be zero (2)         |
      +-------------------------------+-------------------------------+
      |                        IPv4 address (4)                       |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                           metric (4)                          |
      +---------------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | address family identifier (2) |      must be zero (2)         |
      +-------------------------------+-------------------------------+
      |                        IPv4 address (4)                       |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                        must be zero (4)                       |
      +---------------------------------------------------------------+
      |                           metric (4)                          |
      +---------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Field sizes are given in octets. Unless otherwise specified, fields contain binary integers, in network byte order, with the most-significant octet first (big-endian). Each tick mark represents one bit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字段大小以八位字节表示。除非另有规定，否则字段包含二进制整数，按网络字节顺序排列，最重要的八位位组在前（大端）。每个记号代表一位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every message contains a RIP header which consists of a command and a version number. This section of the document describes version 1 of the protocol; section 4 describes the version 2 extensions. The command field is used to specify the purpose of this message. The commands implemented in version 1 and 2 are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每条消息都包含一个RIP头，它由一个命令和一个版本号组成。本节描述了协议的第1版；第4节描述了版本2扩展。命令字段用于指定此消息的用途。在版本1和2中实现的命令包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1 - request A request for the responding system to send all or part of its routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1-请求响应系统发送其全部或部分路由表的请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2 - response A message containing all or part of the sender&#39;s routing table. This message may be sent in response to a request, or it may be an unsolicited routing update generated by the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2-响应包含发件人路由表全部或部分内容的消息。此消息可以响应请求而发送，也可以是发送方生成的未经请求的路由更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each of these message types, in version 1, the remainder of the datagram contains a list of Route Entries (RTEs). Each RTE in this list contains an Address Family Identifier (AFI), destination IPv4 address, and the cost to reach that destination (metric).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于这些消息类型中的每一种，在版本1中，数据报的其余部分包含路由条目（RTE）列表。此列表中的每个RTE都包含地址族标识符（AFI）、目标IPv4地址和到达该目标的成本（度量）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The AFI is the type of address. For RIP-1, only AF_INET (2) is generally supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AFI是地址的类型。对于RIP-1，通常只支持AF_INET（2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The metric field contains a value between 1 and 15 (inclusive) which specifies the current metric for the destination; or the value 16 (infinity), which indicates that the destination is not reachable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
metric字段包含一个介于1和15（包括）之间的值，该值指定目标的当前度量；或值16（无穷大），表示无法到达目的地。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7 Addressing Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.7 处理考虑事项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Distance vector routing can be used to describe routes to individual hosts or to networks. The RIP protocol allows either of these possibilities. The destinations appearing in request and response messages can be networks, hosts, or a special code used to indicate a default address. In general, the kinds of routes actually used will depend upon the routing strategy used for the particular network. Many networks are set up so that routing information for individual hosts is not needed. If every node on a given network or subnet is accessible through the same routers, then there is no reason to mention individual hosts in the routing tables. However, networks that include point-to-point lines sometimes require routers to keep track of routes to certain nodes. Whether this feature is required depends upon the addressing and routing approach used in the system. Thus, some implementations may choose not to support host routes. If host routes are not supported, they are to be dropped when they are received in response messages (see section 3.7.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
距离向量路由可用于描述到单个主机或网络的路由。RIP协议允许这两种可能性中的任何一种。请求和响应消息中出现的目的地可以是网络、主机或用于指示默认地址的特殊代码。通常，实际使用的路由类型取决于特定网络使用的路由策略。许多网络的设置都是为了不需要单个主机的路由信息。如果给定网络或子网上的每个节点都可以通过相同的路由器访问，那么就没有理由在路由表中提及各个主机。然而，包含点到点线路的网络有时需要路由器跟踪到特定节点的路由。是否需要此功能取决于系统中使用的寻址和路由方法。因此，一些实现可能选择不支持主机路由。如果不支持主机路由，则在响应消息中接收到主机路由时，将删除主机路由（见第3.7.2节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RIP-1 packet format does not distinguish among various types of address. Fields that are labeled &#34;address&#34; can contain any of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP-1数据包格式不区分不同类型的地址。标记为“地址”的字段可以包含以下任何内容：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
host address subnet number network number zero (default route)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
主机地址子网号网络号零（默认路由）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Entities which use RIP-1 are assumed to use the most specific information available when routing a datagram. That is, when routing a datagram, its destination address must first be checked against the list of node addresses. Then it must be checked to see whether it matches any known subnet or network number. Finally, if none of these match, the default route is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设使用RIP-1的实体在路由数据报时使用最具体的可用信息。也就是说，在路由数据报时，必须首先对照节点地址列表检查其目标地址。然后必须检查它是否匹配任何已知的子网或网络号。最后，如果这些都不匹配，则使用默认路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node evaluates information that it receives via RIP-1, its interpretation of an address depends upon whether it knows the subnet mask that applies to the net. If so, then it is possible to determine the meaning of the address. For example, consider net 128.6. It has a subnet mask of 255.255.255.0. Thus 128.6.0.0 is a network number, 128.6.4.0 is a subnet number, and 128.6.4.1 is a node address. However, if the node does not know the subnet mask, evaluation of an address may be ambiguous. If there is a non-zero node part, there is no clear way to determine whether the address represents a subnet number or a node address. As a subnet number would be useless without the subnet mask, addresses are assumed to represent nodes in this situation. In order to avoid this sort of ambiguity, when using version 1, nodes must not send subnet routes to nodes that cannot be expected to know the appropriate subnet mask. Normally hosts only know the subnet masks for directly-connected networks. Therefore, unless special provisions have been made,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点评估通过RIP-1接收的信息时，其对地址的解释取决于它是否知道应用于网络的子网掩码。如果是这样，则可以确定地址的含义。例如，考虑Net 128.6。它的子网掩码为255.255.255.0。因此，128.6.0.0是网络号，128.6.4.0是子网号，128.6.4.1是节点地址。但是，如果节点不知道子网掩码，则地址的计算可能不明确。如果存在非零节点部分，则无法明确确定该地址是表示子网号还是表示节点地址。由于没有子网掩码，子网编号将毫无用处，因此假定地址表示这种情况下的节点。为了避免这种模糊性，在使用版本1时，节点不得将子网路由发送到无法预期知道相应子网掩码的节点。通常，主机只知道直接连接网络的子网掩码。因此,除非有特别规定,，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
routes to a subnet must not be sent outside the network of which the subnet is a part. RIP-2 (see section 4) eliminates the subnet/host ambiguity by including the subnet mask in the routing entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
到子网的路由不得发送到该子网所属的网络之外。RIP-2（参见第4节）通过在路由条目中包含子网掩码来消除子网/主机的模糊性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This &#34;subnet filtering&#34; is carried out by the routers at the &#34;border&#34; of the subnetted network. These are routers which connect that network with some other network. Within the subnetted network, each subnet is treated as an individual network. Routing entries for each subnet are circulated by RIP. However, border routers send only a single entry for the network as a whole to nodes in other networks. This means that a border router will send different information to different neighbors. For neighbors connected to the subnetted network, it generates a list of all subnets to which it is directly connected, using the subnet number. For neighbors connected to other networks, it makes a single entry for the network as a whole, showing the metric associated with that network. This metric would normally be the smallest metric for the subnets to which the router is attached.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此“子网过滤”由子网网络“边界”处的路由器执行。这些路由器将该网络与其他网络连接起来。在子网网络中，每个子网都被视为一个单独的网络。每个子网的路由条目由RIP循环。但是，边界路由器仅将整个网络的单个条目发送给其他网络中的节点。这意味着边界路由器将向不同的邻居发送不同的信息。对于连接到子网网络的邻居，它使用子网编号生成其直接连接到的所有子网的列表。对于连接到其他网络的邻居，它为整个网络创建一个条目，显示与该网络关联的度量。该度量通常是路由器连接到的子网的最小度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, border routers must not mention host routes for nodes within one of the directly-connected networks in messages to other networks. Those routes will be subsumed by the single entry for the network as a whole.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类似地，边界路由器不得在到其他网络的消息中提及一个直接连接网络内的节点的主机路由。这些路线将包含在整个网络的单个条目中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The router requirements RFC [11] specifies that all implementation of RIP should support host routes but if they do not then they must ignore any received host routes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器要求RFC[11]规定，RIP的所有实现都应支持主机路由，但如果不支持，则必须忽略任何接收到的主机路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The special address 0.0.0.0 is used to describe a default route. A default route is used when it is not convenient to list every possible network in the RIP updates, and when one or more closely-connected routers in the system are prepared to handle traffic to the networks that are not listed explicitly. These routers should create RIP entries for the address 0.0.0.0, just as if it were a network to which they are connected. The decision as to how routers create entries for 0.0.0.0 is left to the implementor. Most commonly, the system administrator will be provided with a way to specify which routers should create entries for 0.0.0.0; however, other mechanisms are possible. For example, an implementor might decide that any router which speaks BGP should be declared to be a default router. It may be useful to allow the network administrator to choose the metric to be used in these entries. If there is more than one default router, this will make it possible to express a preference for one over the other. The entries for 0.0.0.0 are handled by RIP in exactly the same manner as if there were an actual network with this address. System administrators should take care to make sure that routes to 0.0.0.0 do not propagate further than is intended. Generally, each autonomous system has its own preferred default
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特殊地址0.0.0.0用于描述默认路由。当无法方便地在RIP更新中列出所有可能的网络时，以及当系统中一个或多个紧密连接的路由器准备处理到未明确列出的网络的流量时，使用默认路由。这些路由器应该为地址0.0.0.0创建RIP条目，就像它们所连接的网络一样。路由器如何为0.0.0.0创建条目的决定权留给实现者。最常见的是，系统管理员可以指定哪些路由器应该为0.0.0.0创建条目；然而，其他机制也是可能的。例如，一个实现者可能会决定说BGP的任何路由器都应该声明为默认路由器。允许网络管理员选择要在这些条目中使用的度量可能很有用。如果有多个默认路由器，则可以表示对其中一个路由器的偏好。0.0.0.0的条目由RIP以完全相同的方式处理，就像有一个实际的网络具有此地址一样。系统管理员应注意确保到0.0.0.0的路由不会传播得超出预期范围。通常，每个自治系统都有自己的首选默认值
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
router. Thus, routes involving 0.0.0.0 should generally not leave the boundary of an autonomous system. The mechanisms for enforcing this are not specified in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器。因此，涉及0.0.0.0的路线通常不应离开自治系统的边界。本文件中未规定强制执行此操作的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8 Timers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.8 计时器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes all events that are triggered by timers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍计时器触发的所有事件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every 30 seconds, the RIP process is awakened to send an unsolicited Response message containing the complete routing table (see section 3.9 on Split Horizon) to every neighboring router. When there are many routers on a single network, there is a tendency for them to synchronize with each other such that they all issue updates at the same time. This can happen whenever the 30 second timer is affected by the processing load on the system. It is undesirable for the update messages to become synchronized, since it can lead to unnecessary collisions on broadcast networks. Therefore, implementations are required to take one of two precautions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每隔30秒，RIP进程就会被唤醒，向每个相邻路由器发送一条包含完整路由表（参见第3.9节“拆分地平线”）的非请求响应消息。当一个网络上有多个路由器时，它们有相互同步的趋势，因此它们都会同时发布更新。只要30秒计时器受到系统上处理负载的影响，就会发生这种情况。不希望更新消息同步，因为这可能导致广播网络上不必要的冲突。因此，实施需要采取以下两种预防措施之一：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The 30-second updates are triggered by a clock whose rate is not affected by system load or the time required to service the previous update timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 30秒更新由一个时钟触发，该时钟的速率不受系统负载或维护前一个更新计时器所需的时间的影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The 30-second timer is offset by a small random time (+/- 0 to 5 seconds) each time it is set. (Implementors may wish to consider even larger variation in the light of recent research results [10])
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 每次设置30秒计时器时，它都会被一个小的随机时间（+/-0到5秒）偏移。（实施者可能希望根据最近的研究结果考虑更大的变化〔10〕。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two timers associated with each route, a &#34;timeout&#34; and a &#34;garbage-collection&#34; time. Upon expiration of the timeout, the route is no longer valid; however, it is retained in the routing table for a short time so that neighbors can be notified that the route has been dropped. Upon expiration of the garbage-collection timer, the route is finally removed from the routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个路由都有两个计时器，一个是“超时”时间，另一个是“垃圾收集”时间。超时过期后，路由不再有效；但是，它会在路由表中保留一段短时间，以便通知邻居路由已被丢弃。垃圾收集计时器过期后，路由最终从路由表中删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The timeout is initialized when a route is established, and any time an update message is received for the route. If 180 seconds elapse from the last time the timeout was initialized, the route is considered to have expired, and the deletion process described below begins for that route.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当建立路由时，以及在任何时候收到路由的更新消息时，都会初始化超时。如果从上次初始化超时时间起经过180秒，则认为该路由已过期，下面描述的删除过程将针对该路由开始。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Deletions can occur for one of two reasons: the timeout expires, or the metric is set to 16 because of an update received from the current router (see section 3.7.2 for a discussion of processing updates from other routers). In either case, the following events happen:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
删除可能是由于以下两个原因之一：超时过期，或者由于从当前路由器接收到更新而将度量设置为16（有关处理来自其他路由器的更新的讨论，请参阅第3.7.2节）。无论哪种情况，都会发生以下事件：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The garbage-collection timer is set for 120 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 垃圾收集计时器设置为120秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The metric for the route is set to 16 (infinity). This causes the route to be removed from service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 路由的度量设置为16（无穷大）。这将导致路由从服务中删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The route change flag is set to indicate that this entry has been changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 路由更改标志设置为指示此条目已更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- The output process is signalled to trigger a response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 向输出进程发送信号以触发响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Until the garbage-collection timer expires, the route is included in all updates sent by this router. When the garbage-collection timer expires, the route is deleted from the routing table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在垃圾收集计时器过期之前，路由将包含在此路由器发送的所有更新中。当垃圾收集计时器过期时，路由将从路由表中删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Should a new route to this network be established while the garbage-collection timer is running, the new route will replace the one that is about to be deleted. In this case the garbage-collection timer must be cleared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在垃圾收集计时器运行时建立到此网络的新路由，则新路由将替换即将删除的路由。在这种情况下，必须清除垃圾收集计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Triggered updates also use a small timer; however, this is best described in section 3.9.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
触发更新也使用一个小定时器；然而，第3.9.1节对此进行了最好的描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9 Input Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9 输入处理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section will describe the handling of datagrams received on the RIP port. Processing will depend upon the value in the command field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节将描述在RIP端口上接收的数据报的处理。处理将取决于命令字段中的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
See sections 4.6 and 5.1 for details on handling version numbers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关处理版本号的详细信息，请参见第4.6节和第5.1节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.1 Request Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.1 请求消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Request is used to ask for a response containing all or part of a router&#39;s routing table. Normally, Requests are sent as broadcasts (multicasts for RIP-2), from the RIP port, by routers which have just come up and are seeking to fill in their routing tables as quickly as possible. However, there may be situations (e.g., router monitoring) where the routing table of only a single router is needed. In this case, the Request should be sent directly to that router from a UDP port other than the RIP port. If such a Request is received, the router responds directly to the requestor&#39;s address and port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请求用于请求包含全部或部分路由器路由表的响应。通常，请求是通过刚刚出现的路由器从RIP端口以广播（RIP-2的多播）的形式发送的，这些路由器正试图尽快填写路由表。然而，可能存在只需要单个路由器的路由表的情况（例如，路由器监控）。在这种情况下，请求应该直接从UDP端口（而不是RIP端口）发送到路由器。如果收到这样的请求，路由器将直接响应请求者的地址和端口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Request is processed entry by entry. If there are no entries, no response is given. There is one special case. If there is exactly one entry in the request, and it has an address family identifier of zero and a metric of infinity (i.e., 16), then this is a request to send the entire routing table. In that case, a call is made to the output process to send the routing table to the requesting
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请求被逐条处理。如果没有条目，则不会给出响应。有一种特殊情况。如果请求中只有一个条目，且其地址族标识符为零，度量为无穷大（即16），则这是发送整个路由表的请求。在这种情况下，对输出进程进行调用，将路由表发送到请求进程
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
address/port. Except for this special case, processing is quite simple. Examine the list of RTEs in the Request one by one. For each entry, look up the destination in the router&#39;s routing database and, if there is a route, put that route&#39;s metric in the metric field of the RTE. If there is no explicit route to the specified destination, put infinity in the metric field. Once all the entries have been filled in, change the command from Request to Response and send the datagram back to the requestor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
地址/端口。除此特殊情况外，处理非常简单。逐个检查请求中的RTE列表。对于每个条目，在路由器的路由数据库中查找目的地，如果有路由，则将该路由的度量放入RTE的度量字段中。如果没有到指定目的地的显式路由，请在度量字段中输入无穷大。填写完所有条目后，将命令从请求更改为响应，并将数据报发送回请求者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there is a difference in metric handling for specific and whole-table requests. If the request is for a complete routing table, normal output processing is done, including Split Horizon (see section 3.9 on Split Horizon). If the request is for specific entries, they are looked up in the routing table and the information is returned as is; no Split Horizon processing is done. The reason for this distinction is the expectation that these requests are likely to be used for different purposes. When a router first comes up, it multicasts a Request on every connected network asking for a complete routing table. It is assumed that these complete routing tables are to be used to update the requestor&#39;s routing table. For this reason, Split Horizon must be done. It is further assumed that a Request for specific networks is made only by diagnostic software, and is not used for routing. In this case, the requester would want to know the exact contents of the routing table and would not want any information hidden or modified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，特定表请求和整个表请求的度量处理存在差异。如果请求的是完整的路由表，则完成正常的输出处理，包括分割视界（参见第3.9节分割视界）。如果请求是针对特定条目的，则在路由表中查找这些条目，并按原样返回信息；不进行分割地平线处理。这种区别的原因是期望这些请求可能用于不同的目的。当路由器第一次出现时，它在每个连接的网络上多播一个请求，请求一个完整的路由表。假设这些完整的路由表用于更新请求者的路由表。因此，必须进行水平分割。进一步假设对特定网络的请求仅由诊断软件发出，不用于路由。在这种情况下，请求者希望知道路由表的确切内容，并且不希望隐藏或修改任何信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.2 Response Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.9.2 响应消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Response can be received for one of several different reasons:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
收到响应的原因有以下几种：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- response to a specific query - regular update (unsolicited response) - triggered update caused by a route change
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 对特定查询的响应-定期更新（主动响应）-由路由更改引起的触发更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Processing is the same no matter why the Response was generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论生成响应的原因是什么，处理都是相同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because processing of a Response may update the router&#39;s routing table, the Response must be checked carefully for validity. The Response must be ignored if it is not from the RIP port. The datagram&#39;s IPv4 source address should be checked to see whether the datagram is from a valid neighbor; the source of the datagram must be on a directly-connected network. It is also worth checking to see whether the response is from one of the router&#39;s own addresses. Interfaces on broadcast networks may receive copies of their own broadcasts/multicasts immediately. If a router processes its own output as new input, confusion is likely so such datagrams must be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因为响应的处理可能会更新路由器的路由表，所以必须仔细检查响应的有效性。如果响应不是来自RIP端口，则必须忽略该响应。应检查数据报的IPv4源地址，以查看数据报是否来自有效的邻居；数据报的源必须位于直接连接的网络上。同样值得检查的是，看看响应是否来自路由器自己的地址之一。广播网络上的接口可立即接收其自身广播/多播的副本。如果路由器将自己的输出处理为新的输入，则可能会出现混淆，因此必须忽略此类数据报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the datagram as a whole has been validated, process the RTEs in the Response one by one. Again, start by doing validation. Incorrect metrics and other format errors usually indicate misbehaving neighbors and should probably be brought to the administrator&#39;s attention. For example, if the metric is greater than infinity, ignore the entry but log the event. The basic validation tests are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦数据报作为一个整体进行了验证，则逐个处理响应中的RTE。同样，从验证开始。不正确的度量和其他格式错误通常表示邻居行为不端，可能应该引起管理员的注意。例如，如果度量值大于无穷大，则忽略该条目，但记录事件。基本验证测试包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- is the destination address valid (e.g., unicast; not net 0 or 127) - is the metric valid (i.e., between 1 and 16, inclusive)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 目标地址是否有效（例如，单播；不是网络0或127）-度量是否有效（即，介于1和16之间，包括1和16之间）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any check fails, ignore that entry and proceed to the next. Again, logging the error is probably a good idea.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果任何检查失败，请忽略该条目并继续下一步。同样，记录错误可能是一个好主意。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the entry has been validated, update the metric by adding the cost of the network on which the message arrived. If the result is greater than infinity, use infinity. That is,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
验证条目后，通过添加消息到达的网络的成本来更新度量。如果结果大于无穷大，则使用无穷大。就是，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
metric = MIN (metric + cost, infinity)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
公制=最小值（公制+成本，无穷大）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now, check to see whether there is already an explicit route for the destination address. If there is no such route, add this route to the routing table, unless the metric is infinity (there is no point in adding a route which is unusable). Adding a route to the routing table consists of:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在，检查目标地址是否已经有显式路由。如果没有这样的路由，则将此路由添加到路由表中，除非度量为无穷大（添加不可用的路由没有意义）。将路由添加到路由表包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Setting the destination address to the destination address in the RTE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 将目标地址设置为RTE中的目标地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Setting the metric to the newly calculated metric (as described above)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 将度量设置为新计算的度量（如上所述）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Set the next hop address to be the address of the router from which the datagram came
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 将下一个跃点地址设置为数据报来自的路由器的地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Initialize the timeout for the route. If the garbage-collection timer is running for this route, stop it (see section 3.6 for a discussion of the timers)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 初始化路由的超时。如果垃圾收集计时器正在为此路由运行，请停止它（有关计时器的讨论，请参阅第3.6节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Set the route change flag
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 设置路线更改标志
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Signal the output process to trigger an update (see section 3.8.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 向输出过程发送信号以触发更新（见第3.8.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there is an existing route, compare the next hop address to the address of the router from which the datagram came. If this datagram is from the same router as the existing route, reinitialize the timeout. Next, compare the metrics. If the datagram is from the same router as the existing route, and the new metric is different
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果存在现有路由，则将下一跳地址与数据报来自的路由器的地址进行比较。如果此数据报来自与现有路由相同的路由器，请重新初始化超时。接下来，比较指标。如果数据报来自与现有路由相同的路由器，并且新的度量不同
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
than the old one; or, if the new metric is lower than the old one; do the following actions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比旧的要多；或者，如果新指标低于旧指标；执行以下操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Adopt the route from the datagram (i.e., put the new metric in and adjust the next hop address, if necessary).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 采用来自数据报的路由（即，放入新的度量，并在必要时调整下一跳地址）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- Set the route change flag and signal the output process to trigger an update
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 设置路由更改标志并向输出进程发送信号以触发更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- If the new metric is infinity, start the deletion process (described above); otherwise, re-initialize the timeout
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 如果新度量为无穷大，则开始删除过程（如上所述）；否则，请重新初始化超时
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the new metric is infinity, the deletion process begins for the route, which is no longer used for routing packets. Note that the deletion process is started only when the metric is first set to infinity. If the metric was already infinity, then a new deletion process is not started.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果新的度量为无穷大，则删除过程开始于不再用于路由数据包的路由。请注意，删除过程仅在度量首次设置为无穷大时启动。如果度量值已为无穷大，则不会启动新的删除过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the new metric is the same as the old one, it is simplest to do nothing further (beyond re-initializing the timeout, as specified above); but, there is a heuristic which could be applied. Normally, it is senseless to replace a route if the new route has the same metric as the existing route; this would cause the route to bounce back and forth, which would generate an intolerable number of triggered updates. However, if the existing route is showing signs of timing out, it may be better to switch to an equally-good alternative route immediately, rather than waiting for the timeout to happen. Therefore, if the new metric is the same as the old one, examine the timeout for the existing route. If it is at least halfway to the expiration point, switch to the new route. This heuristic is optional, but highly recommended.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果新度量与旧度量相同，则最简单的方法是不做任何进一步的操作（如上所述重新初始化超时）；但是，有一种启发式方法可以应用。通常，如果新路线与现有路线具有相同的指标，则更换路线是毫无意义的；这将导致路由来回反弹，这将产生无法忍受的触发更新数量。但是，如果现有路由显示超时迹象，则最好立即切换到同样好的替代路由，而不是等待超时发生。因此，如果新度量与旧度量相同，请检查现有路由的超时。如果距离到期点至少有一半，则切换到新路线。此启发式是可选的，但强烈推荐。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any entry that fails these tests is ignored, as it is no better than the current route.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任何未通过这些测试的条目都将被忽略，因为它并不比当前路由更好。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10 Output Processing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10 输出处理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the processing used to create response messages that contain all or part of the routing table. This processing may be triggered in any of the following ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍用于创建包含全部或部分路由表的响应消息的处理过程。此处理可通过以下任一方式触发：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- By input processing, when a Request is received (this Response is unicast to the requestor; see section 3.7.1)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 通过输入处理，当收到请求时（该响应是单播给请求者的；参见第3.7.1节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- By the regular routing update (broadcast/multicast every 30 seconds) router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 通过常规路由更新（每30秒广播/多播一次）路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- By triggered updates (broadcast/multicast when a route changes)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
- 通过触发更新（路由更改时广播/多播）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a Response is to be sent to all neighbors (i.e., a regular or triggered update), a Response message is directed to the router at the far end of each connected point-to-point link, and is broadcast (multicast for RIP-2) on all connected networks which support broadcasting. Thus, one Response is prepared for each directly-connected network, and sent to the appropriate address (direct or broadcast/multicast). In most cases, this reaches all neighboring routers. However, there are some cases where this may not be good enough. This may involve a network that is not a broadcast network (e.g., the ARPANET), or a situation involving dumb routers. In such cases, it may be necessary to specify an actual list of neighboring routers and send a datagram to each one explicitly. It is left to the implementor to determine whether such a mechanism is needed, and to define how the list is specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当响应要发送到所有邻居（即，定期或触发更新）时，响应消息被定向到每个连接的点到点链路远端的路由器，并在所有支持广播的连接网络上广播（RIP-2的多播）。因此，为每个直接连接的网络准备一个响应，并发送到适当的地址（直接或广播/多播）。在大多数情况下，这会到达所有相邻的路由器。然而，在某些情况下，这可能不够好。这可能涉及非广播网络的网络（例如，ARPANET），或涉及哑路由器的情况。在这种情况下，可能需要指定相邻路由器的实际列表，并显式地向每个路由器发送数据报。由实现者确定是否需要这样的机制，并定义如何指定列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.1 Triggered Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.1 触发的更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Triggered updates require special handling for two reasons. First, experience shows that triggered updates can cause excessive load on networks with limited capacity or networks with many routers on them. Therefore, the protocol requires that implementors include provisions to limit the frequency of triggered updates. After a triggered update is sent, a timer should be set for a random interval between 1 and 5 seconds. If other changes that would trigger updates occur before the timer expires, a single update is triggered when the timer expires. The timer is then reset to another random value between 1 and 5 seconds. A triggered update should be suppressed if a regular update is due by the time the triggered update would be sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
触发的更新需要特殊处理，原因有二。首先，经验表明，触发的更新可能会导致容量有限的网络或具有多个路由器的网络负载过大。因此，该协议要求实现者包括限制触发更新频率的规定。发送触发更新后，应将计时器设置为1到5秒之间的随机间隔。如果其他会触发更新的更改在计时器过期之前发生，则会在计时器过期时触发单个更新。然后将计时器重置为1到5秒之间的另一个随机值。如果定期更新在发送触发的更新时到期，则应禁止触发的更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Second, triggered updates do not need to include the entire routing table. In principle, only those routes which have changed need to be included. Therefore, messages generated as part of a triggered update must include at least those routes that have their route change flag set. They may include additional routes, at the discretion of the implementor; however, sending complete routing updates is strongly discouraged. When a triggered update is processed, messages should be generated for every directly-connected network. Split Horizon processing is done when generating triggered updates as well as normal updates (see section 3.9). If, after Split Horizon processing for a given network, a changed route will appear unchanged on that network (e.g., it appears with an infinite metric), the route need not be sent. If no routes need be sent on that network, the update may be omitted. Once all of the triggered updates have been generated, the route change flags should be cleared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其次，触发的更新不需要包括整个路由表。原则上，只需包括已更改的路线。因此，作为触发更新的一部分生成的消息必须至少包括那些设置了路由更改标志的路由。实施者可自行决定是否包括其他路线；但是，强烈建议不要发送完整的路由更新。处理触发的更新时，应为每个直接连接的网络生成消息。在生成触发更新和正常更新时，会执行分割地平线处理（参见第3.9节）。如果在对给定网络进行拆分地平线处理后，更改的路由将在该网络上显示为不变（例如，它以无限度量显示），则无需发送该路由。如果不需要在该网络上发送路由，则可以省略更新。生成所有触发的更新后，应清除路由更改标志。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If input processing is allowed while output is being generated, appropriate interlocking must be done. The route change flags should not be changed as a result of processing input while a triggered update message is being generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在生成输出时允许进行输入处理，则必须进行适当的联锁。在生成触发的更新消息时，不应由于处理输入而更改路由更改标志。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only difference between a triggered update and other update messages is the possible omission of routes that have not changed. The remaining mechanisms, described in the next section, must be applied to all updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
触发的更新消息和其他更新消息之间的唯一区别是可能遗漏了未更改的路由。下一节中描述的其余机制必须应用于所有更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.2 Generating Response Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.10.2 生成响应消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes how a Response message is generated for a particular directly-connected network:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍如何为特定的直接连接网络生成响应消息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Set the version number to either 1 or 2. The mechanism for deciding which version to send is implementation specific; however, if this is the Response to a Request, the Response version should match the Request version. Set the command to Response. Set the bytes labeled &#34;must be zero&#34; to zero. Start filling in RTEs. Recall that there is a limit of 25 RTEs to a Response; if there are more, send the current Response and start a new one. There is no defined limit to the number of datagrams which make up a Response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将版本号设置为1或2。决定发送哪个版本的机制是特定于实现的；但是，如果这是对请求的响应，则响应版本应与请求版本匹配。将命令设置为Response。将标记为“必须为零”的字节设置为零。开始填写RTE。回想一下，一个响应限制为25个RTE；如果有更多响应，请发送当前响应并启动新响应。对组成响应的数据报的数量没有定义的限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To fill in the RTEs, examine each route in the routing table. If a triggered update is being generated, only entries whose route change flags are set need be included. If, after Split Horizon processing, the route should not be included, skip it. If the route is to be included, then the destination address and metric are put into the RTE. Routes must be included in the datagram even if their metrics are infinite.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要填写RTE，请检查路由表中的每条路由。如果正在生成触发的更新，则只需要包含设置了路由更改标志的条目。如果在分割地平线处理后，不应包括路线，则跳过该路线。如果要包括路由，则将目标地址和度量放入RTE中。即使路由的度量是无限的，它们也必须包含在数据报中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Protocol Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 协议扩展
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section does not change the RIP protocol per se. Rather, it provides extensions to the message format which allows routers to share important additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节不会更改RIP协议本身。相反，它提供了消息格式的扩展，允许路由器共享重要的附加信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The same header format is used for RIP-1 and RIP-2 messages (see section 3.4). The format for the 20-octet route entry (RTE) for RIP-2 is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RIP-1和RIP-2消息使用相同的报头格式（见第3.4节）。RIP-2的20个八位组进路入口（RTE）格式为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Address Family Identifier (2) |        Route Tag (2)          |
   +-------------------------------+-------------------------------+
   |                         IP Address (4)                        |
   +---------------------------------------------------------------+
   |                         Subnet Mask (4)                       |
   +---------------------------------------------------------------+
   |                         Next Hop (4)                          |
   +---------------------------------------------------------------+
   |                         Metric (4)                            |
   +---------------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Address Family Identifier (2) |        Route Tag (2)          |
   +-------------------------------+-------------------------------+
   |                         IP Address (4)                        |
   +---------------------------------------------------------------+
   |                         Subnet Mask (4)                       |
   +---------------------------------------------------------------+
   |                         Next Hop (4)                          |
   +---------------------------------------------------------------+
   |                         Metric (4)                            |
   +---------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Address Family Identifier, IP Address, and Metric all have the meanings defined in section 3.4. The Version field will specify version number 2 for RIP messages which use authentication or carry information in any of the newly defined fields.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
地址族标识符、IP地址和度量均具有第3.4节中定义的含义。版本字段将为使用身份验证或在任何新定义的字段中携带信息的RIP消息指定版本号2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1 认证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since authentication is a per message function, and since there is only one 2-octet field available in the message header, and since any reasonable authentication scheme will require more than two octets, the authentication scheme for RIP version 2 will use the space of an entire RIP entry. If the Address Family Identifier of the first (and only the first) entry in the message is 0xFFFF, then the remainder of the entry contains the authentication. This means that there can be, at most, 24 RIP entries in the remainder of the message. If authentication is not in use, then no entries in the message should have an Address Family Identifier of 0xFFFF. A RIP message which contains an authentication entry would begin with the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于身份验证是每条消息的功能，并且由于消息头中只有一个2-octet字段可用，并且由于任何合理的身份验证方案将需要两个以上的octet，因此RIP版本2的身份验证方案将使用整个RIP条目的空间。如果消息中第一个（且仅第一个）条目的地址族标识符为0xFFFF，则该条目的其余部分包含身份验证。这意味着在消息的其余部分最多可以有24个RIP条目。如果未使用身份验证，则消息中的任何条目的地址族标识符都不应为0xFFFF。包含身份验证条目的RIP消息将以以下格式开头：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Command (1)   | Version (1)   |            unused             |
   +---------------+---------------+-------------------------------+
   |             0xFFFF            |    Authentication Type (2)    |
   +-------------------------------+-------------------------------+
   ~                       Authentication (16)                     ~
   +---------------------------------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Command (1)   | Version (1)   |            unused             |
   +---------------+---------------+-------------------------------+
   |             0xFFFF            |    Authentication Type (2)    |
   +-------------------------------+-------------------------------+
   ~                       Authentication (16)                     ~
   +---------------------------------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Currently, the only Authentication Type is simple password and it is type 2. The remaining 16 octets contain the plain text password. If the password is under 16 octets, it must be left-justified and padded to the right with nulls (0x00).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目前，唯一的身份验证类型是简单密码，它是类型2。其余16个八位字节包含纯文本密码。如果密码小于16个八位字节，则必须左对齐，并用空值（0x00）填充到右侧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 Route Tag
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2 路线标签
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Route Tag (RT) field is an attribute assigned to a route which must be preserved and readvertised with a route. The intended use of the Route Tag is to provide a method of separating &#34;internal&#34; RIP routes (routes for networks within the RIP routing domain) from &#34;external&#34; RIP routes, which may have been imported from an EGP or another IGP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由标记（RT）字段是分配给路由的属性，必须保留该属性并与路由一起读取。路由标签的预期用途是提供一种将“内部”RIP路由（RIP路由域内网络的路由）与“外部”RIP路由（可能已从EGP或另一IGP导入）分离的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routers supporting protocols other than RIP should be configurable to allow the Route Tag to be configured for routes imported from different sources. For example, routes imported from EGP or BGP should be able to have their Route Tag either set to an arbitrary value, or at least to the number of the Autonomous System from which the routes were learned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
支持RIP以外协议的路由器应可配置为允许为从不同来源导入的路由配置路由标签。例如，从EGP或BGP导入的路由应该能够将其路由标签设置为任意值，或者至少设置为从中学习路由的自治系统的编号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other uses of the Route Tag are valid, as long as all routers in the RIP domain use it consistently. This allows for the possibility of a BGP-RIP protocol interactions document, which would describe methods for synchronizing routing in a transit network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由标记的其他用途是有效的，只要RIP域中的所有路由器一致地使用它。这使得BGP-RIP协议交互文档成为可能，该文档将描述在运输网络中同步路由的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 Subnet mask
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3 子网掩码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Subnet Mask field contains the subnet mask which is applied to the IP address to yield the non-host portion of the address. If this field is zero, then no subnet mask has been included for this entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子网掩码字段包含应用于IP地址以生成地址的非主机部分的子网掩码。如果此字段为零，则此条目不包含子网掩码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On an interface where a RIP-1 router may hear and operate on the information in a RIP-2 routing entry the following rules apply:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在RIP-1路由器可能听到并操作RIP-2路由条目中信息的接口上，以下规则适用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) information internal to one network must never be advertised into another network,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1) 一个网络内部的信息决不能发布到另一个网络，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) information about a more specific subnet may not be advertised where RIP-1 routers would consider it a host route, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2) 在RIP-1路由器将其视为主机路由的情况下，不可能发布关于更具体的子网的信息；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3) supernet routes (routes with a netmask less specific than the &#34;natural&#34; network mask) must not be advertised where they could be misinterpreted by RIP-1 routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3) 超级网路由（网络掩码不如“自然”网络掩码具体的路由）不得在可能被RIP-1路由器误解的地方发布广告。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4 Next Hop
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4 下一跳地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The immediate next hop IP address to which packets to the destination specified by this route entry should be forwarded. Specifying a value of 0.0.0.0 in this field indicates that routing should be via the originator of the RIP advertisement. An address specified as a next hop must, per force, be directly reachable on the logical subnet over which the advertisement is made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送到此路由条目指定的目的地的数据包应转发到的下一跳IP地址。在此字段中指定值0.0.0.0表示路由应通过RIP广告的发起人进行。指定为下一个跃点的地址必须在进行播发的逻辑子网上可直接访问。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The purpose of the Next Hop field is to eliminate packets being routed through extra hops in the system. It is particularly useful when RIP is not being run on all of the routers on a network. A simple example is given in Appendix A. Note that Next Hop is an &#34;advisory&#34; field. That is, if the provided information is ignored, a possibly sub-optimal, but absolutely valid, route may be taken. If the received Next Hop is not directly reachable, it should be treated as 0.0.0.0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下一跳字段的目的是消除通过系统中的额外跳路由的数据包。当RIP没有在网络上的所有路由器上运行时，它特别有用。附录A中给出了一个简单的示例。请注意，下一跳是一个“咨询”字段。也就是说，如果忽略提供的信息，则可能采取次优但绝对有效的路线。如果接收到的下一跳无法直接到达，则应将其视为0.0.0.0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5 Multicasting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5 多播
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to reduce unnecessary load on those hosts which are not listening to RIP-2 messages, an IP multicast address will be used for periodic broadcasts. The IP multicast address is 224.0.0.9. Note that IGMP is not needed since these are inter-router messages which are not forwarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了减少未收听RIP-2消息的主机上不必要的负载，IP多播地址将用于定期广播。IP多播地址为224.0.0.9。请注意，不需要IGMP，因为这些是未转发的路由器间消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
On NBMA networks, unicast addressing may be used. However, if a response addressed to the RIP-2 multicast address is received, it should be accepted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在NBMA网络上，可以使用单播寻址。但是，如果接收到针对RIP-2多播地址的响应，则应接受该响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to maintain backwards compatibility, the use of the multicast address will be configurable, as described in section 5.1. If multicasting is used, it should be used on all interfaces which support it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了保持向后兼容性，多播地址的使用将是可配置的，如第5.1节所述。如果使用多播，则应在支持多播的所有接口上使用多播。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6 Queries
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6 询问
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a RIP-2 router receives a RIP-1 Request, it should respond with a RIP-1 Response. If the router is configured to send only RIP-2 messages, it should not respond to a RIP-1 Request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果RIP-2路由器接收到RIP-1请求，它应该以RIP-1响应进行响应。如果路由器配置为仅发送RIP-2消息，则不应响应RIP-1请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Compatibility
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 兼容性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC [1] showed considerable forethought in its specification of the handling of version numbers. It specifies that RIP messages of version 0 are to be discarded, that RIP messages of version 1 are to be discarded if any Must Be Zero (MBZ) field is non-zero, and that RIP messages of any version greater than 1 should not be discarded simply because an MBZ field contains a value other than zero. This means that the new version of RIP is totally backwards compatible with existing RIP implementations which adhere to this part of the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC[1]在其版本号处理规范中表现出相当的前瞻性。它指定要丢弃版本0的RIP消息，如果任何必须为零（MBZ）字段为非零，则要丢弃版本1的RIP消息，并且不应仅仅因为MBZ字段包含非零的值而丢弃大于1的任何版本的RIP消息。这意味着RIP的新版本与遵守本规范这一部分的现有RIP实现完全向后兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 Compatibility Switch
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1 兼容开关
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A compatibility switch is necessary for two reasons. First, there are implementations of RIP-1 in the field which do not follow RFC [1] as described above. Second, the use of multicasting would prevent RIP-1 systems from receiving RIP-2 updates (which may be a desired feature in some cases). This switch should be configurable on a per-interface basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出于两个原因，兼容性开关是必要的。首先，该领域中有一些RIP-1的实现，它们不遵循上述RFC[1]。其次，多播的使用将阻止RIP-1系统接收RIP-2更新（在某些情况下，这可能是一种理想的功能）。此开关应可根据每个接口进行配置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The switch has four settings: RIP-1, in which only RIP-1 messages are sent; RIP-1 compatibility, in which RIP-2 messages are broadcast; RIP-2, in which RIP-2 messages are multicast; and &#34;none&#34;, which disables the sending of RIP messages. It is recommended that the default setting be either RIP-1 or RIP-2, but not RIP-1 compatibility. This is because of the potential problems which can occur on some topologies. RIP-1 compatibility should only be used when all of the consequences of its use are well understood by the network administrator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该开关有四种设置：RIP-1，其中仅发送RIP-1消息；RIP-1兼容性，其中RIP-2消息被广播；RIP-2，其中RIP-2消息是多播的；和“无”，这将禁用RIP消息的发送。建议默认设置为RIP-1或RIP-2，但不是RIP-1兼容性。这是因为某些拓扑可能会出现潜在问题。只有当网络管理员充分理解RIP-1使用的所有后果时，才应使用RIP-1兼容性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For completeness, routers should also implement a receive control switch which would determine whether to accept, RIP-1 only, RIP-2 only, both, or none. It should also be configurable on a per-interface basis. It is recommended that the default be compatible with the default chosen for sending updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为完整起见，路由器还应实现一个接收控制交换机，该交换机将决定是否接受、仅RIP-1、仅RIP-2、两者都接受或不接受。它还应该可以根据每个接口进行配置。建议默认设置与为发送更新而选择的默认设置兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2 认证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   The following algorithm should be used to authenticate a RIP message.
   If the router is not configured to authenticate RIP-2 messages, then
   RIP-1 and unauthenticated RIP-2 messages will be accepted;
   authenticated RIP-2 messages shall be discarded.  If the router is
   configured to authenticate RIP-2 messages, then RIP-1 messages and
   RIP-2 messages which pass authentication testing shall be accepted;
   unauthenticated and failed authentication RIP-2 messages shall be
   discarded.  For maximum security, RIP-1 messages should be ignored
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   The following algorithm should be used to authenticate a RIP message.
   If the router is not configured to authenticate RIP-2 messages, then
   RIP-1 and unauthenticated RIP-2 messages will be accepted;
   authenticated RIP-2 messages shall be discarded.  If the router is
   configured to authenticate RIP-2 messages, then RIP-1 messages and
   RIP-2 messages which pass authentication testing shall be accepted;
   unauthenticated and failed authentication RIP-2 messages shall be
   discarded.  For maximum security, RIP-1 messages should be ignored
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
when authentication is in use (see section 4.1); otherwise, the routing information from authenticated messages will be propagated by RIP-1 routers in an unauthenticated manner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用认证时（见第4.1节）；否则，来自已验证消息的路由信息将由RIP-1路由器以未经验证的方式传播。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since an authentication entry is marked with an Address Family Identifier of 0xFFFF, a RIP-1 system would ignore this entry since it would belong to an address family other than IP. It should be noted, therefore, that use of authentication will not prevent RIP-1 systems from seeing RIP-2 messages. If desired, this may be done using multicasting, as described in sections 4.5 and 5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于身份验证条目用地址族标识符0xFFFF标记，RIP-1系统将忽略此条目，因为它将属于IP以外的地址族。因此，应该注意，使用身份验证不会阻止RIP-1系统看到RIP-2消息。如果需要，可以使用多播，如第4.5节和第5.1节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 Larger Infinity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3 大无穷大
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While on the subject of compatibility, there is one item which people have requested: increasing infinity. The primary reason that this cannot be done is that it would violate backwards compatibility. A larger infinity would obviously confuse older versions of rip. At best, they would ignore the route as they would ignore a metric of 16. There was also a proposal to make the Metric a single octet and reuse the high three octets, but this would break any implementations which treat the metric as a 4-octet entity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在兼容性问题上，有一项是人们要求的：增加无限。不能这样做的主要原因是它会破坏向后兼容性。更大的无穷大显然会混淆旧版本的rip。充其量，他们会忽略路线，因为他们会忽略16个指标。还有人建议将度量值设置为单个八位字节，并重用高三个八位字节，但这将破坏将度量值视为4个八位字节实体的任何实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 Addressless Links
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4 无地址链接
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As in RIP-1, addressless links will not be supported by RIP-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与RIP-1一样，RIP-2不支持无地址链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Interaction between version 1 and version 2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 版本1和版本2之间的交互
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because version 1 packets do not contain subnet information, the semantics employed by routers on networks that contain both version 1 and version 2 networks should be limited to that of version 1. Otherwise it is possible either to create blackhole routes (i.e., routes for networks that do not exist) or to create excessive routing information in a version 1 environment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于版本1数据包不包含子网信息，因此包含版本1和版本2网络的网络上的路由器所使用的语义应限于版本1的语义。否则，可能会创建黑洞路由（即不存在的网络路由）或在版本1环境中创建过多的路由信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some implementations attempt to automatically summarize groups of adjacent routes into single entries, the goal being to reduce the total number of entries. This is called auto-summarization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一些实现试图将相邻路由组自动汇总为单个条目，目的是减少条目总数。这称为自动摘要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifically, when using both version 1 and version 2 within a network, a single subnet mask should be used throughout the network. In addition, auto-summarization mechanisms should be disabled for such networks, and implementations must provide mechanisms to disable auto-summarization.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具体来说，在网络中同时使用版本1和版本2时，应在整个网络中使用单个子网掩码。此外，应该为此类网络禁用自动摘要机制，并且实现必须提供禁用自动摘要的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic RIP protocol is not a secure protocol. To bring RIP-2 in line with more modern routing protocols, an extensible authentication mechanism has been incorporated into the protocol enhancements. This mechanism is described in sections 4.1 and 5.2. Security is further enhanced by the mechanism described in [3].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基本RIP协议不是安全协议。为了使RIP-2与更现代的路由协议保持一致，协议增强功能中加入了可扩展的身份验证机制。第4.1节和第5.2节描述了该机制。[3]中描述的机制进一步增强了安全性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录A
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is a simple example of the use of the next hop field in a rip entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是一个在rip条目中使用下一跳字段的简单示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      -----   -----   -----           -----   -----   -----
      |IR1|   |IR2|   |IR3|           |XR1|   |XR2|   |XR3|
      --+--   --+--   --+--           --+--   --+--   --+--
        |       |       |               |       |       |
      --+-------+-------+---------------+-------+-------+--
        &lt;-------------RIP-2-------------&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      -----   -----   -----           -----   -----   -----
      |IR1|   |IR2|   |IR3|           |XR1|   |XR2|   |XR3|
      --+--   --+--   --+--           --+--   --+--   --+--
        |       |       |               |       |       |
      --+-------+-------+---------------+-------+-------+--
        &lt;-------------RIP-2-------------&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assume that IR1, IR2, and IR3 are all &#34;internal&#34; routers which are under one administration (e.g. a campus) which has elected to use RIP-2 as its IGP. XR1, XR2, and XR3, on the other hand, are under separate administration (e.g. a regional network, of which the campus is a member) and are using some other routing protocol (e.g. OSPF). XR1, XR2, and XR3 exchange routing information among themselves such that they know that the best routes to networks N1 and N2 are via XR1, to N3, N4, and N5 are via XR2, and to N6 and N7 are via XR3. By setting the Next Hop field correctly (to XR2 for N3/N4/N5, to XR3 for N6/N7), only XR1 need exchange RIP-2 routes with IR1/IR2/IR3 for routing to occur without additional hops through XR1. Without the Next Hop (for example, if RIP-1 were used) it would be necessary for XR2 and XR3 to also participate in the RIP-2 protocol to eliminate extra hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设IR1、IR2和IR3都是“内部”路由器，属于一个选择使用RIP-2作为其IGP的管理机构（例如校园）。另一方面，XR1、XR2和XR3处于单独的管理之下（例如，校园是其成员的区域网络），并且使用一些其他路由协议（例如，OSPF）。XR1、XR2和XR3在它们之间交换路由信息，以便它们知道到网络N1和N2的最佳路由是通过XR1，到N3、N4和N5的最佳路由是通过XR2，到N6和N7的最佳路由是通过XR3。通过正确设置下一个跃点字段（对于N3/N4/N5，设置为XR2；对于N6/N7，设置为XR3），只有XR1需要与IR1/IR2/IR3交换RIP-2路由，才能在没有额外跃点的情况下通过XR1进行路由。如果没有下一个跃点（例如，如果使用了RIP-1），XR2和XR3也必须参与RIP-2协议以消除额外的跃点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
References
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
工具书类
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Hedrick, C., &#34;Routing Information Protocol&#34;, STD 34, RFC 1058, Rutgers University, June 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Hedrick，C.，“路由信息协议”，标准34，RFC 1058，罗格斯大学，1988年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Malkin, G., and F. Baker, &#34;RIP Version 2 MIB Extension&#34;, RFC 1389, January 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Malkin，G.和F.Baker，“RIP版本2 MIB扩展”，RFC 1389，1993年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Baker, F., and R. Atkinson, &#34;RIP-II MD5 Authentication&#34;, RFC 2082, January 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Baker，F.和R.Atkinson，“RIP-II MD5认证”，RFC 2082，1997年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Bellman, R. E., &#34;Dynamic Programming&#34;, Princeton University Press, Princeton, N.J., 1957.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] 贝尔曼，R.E.，“动态规划”，普林斯顿大学出版社，普林斯顿，新泽西州，1957年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Bertsekas, D. P., and Gallaher, R. G., &#34;Data Networks&#34;, Prentice-Hall, Englewood Cliffs, N.J., 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Bertsekas，D.P.和Gallaher，R.G.，“数据网络”，新泽西州恩格尔伍德悬崖普伦蒂斯大厅，1987年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Braden, R., and Postel, J., &#34;Requirements for Internet Gateways&#34;, STD 4, RFC 1009, June 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Braden，R.和Postel，J.，“互联网网关的要求”，标准4，RFC 1009，1987年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Boggs, D. R., Shoch, J. F., Taft, E. A., and Metcalfe, R. M., &#34;Pup: An Internetwork Architecture&#34;, IEEE Transactions on Communications, April 1980.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Boggs，D.R.，Shoch，J.F.，Taft，E.A.，和Metcalfe，R.M.，“Pup：一种网络架构”，IEEE通信交易，1980年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Ford, L. R. Jr., and Fulkerson, D. R., &#34;Flows in Networks&#34;, Princeton University Press, Princeton, N.J., 1962.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] 福特，L.R.Jr.和富尔克森，D.R.，“网络中的流量”，普林斯顿大学出版社，普林斯顿，新泽西州，1962年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Xerox Corp., &#34;Internet Transport Protocols&#34;, Xerox System Integration Standard XSIS 028112, December 1981.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] 施乐公司，“互联网传输协议”，施乐系统集成标准XSIS 028112，1981年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Floyd, S., and V. Jacobson, &#34;The synchronization of Periodic Routing Messages,&#34; ACM Sigcom &#39;93 symposium, September 1993.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Floyd，S.和V.Jacobson，“定期路由消息的同步”，ACM Sigcom&#39;93研讨会，1993年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Baker, F., &#34;Requirements for IP Version 4 Routers.&#34; RFC 1812, June 1995.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Baker，F.，“IP版本4路由器的要求”，RFC1812，1995年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Gary Scott Malkin Bay Networks 8 Federal Street Billerica, MA 01821
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加里·斯科特·马尔金湾网络8号联邦街马里兰州比尔里卡01821
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Phone: (978) 916-4237 EMail: gmalkin@baynetworks.com
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
电话：（978）916-4237电子邮件：gmalkin@baynetworks.com
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (1998). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（1998年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其译本可复制并提供给他人，对其进行评论或解释或协助其实施的衍生作品可全部或部分编制、复制、出版和分发，不受任何限制，前提是上述版权声明和本段包含在所有此类副本和衍生作品中。但是，不得以任何方式修改本文件本身，例如删除版权通知或对互联网协会或其他互联网组织的引用，除非出于制定互联网标准的需要，在这种情况下，必须遵循互联网标准过程中定义的版权程序，或根据需要将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述授予的有限许可是永久性的，互联网协会或其继承人或受让人不会撤销。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein is provided on an &#34;AS IS&#34; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件和其中包含的信息是按“原样”提供的，互联网协会和互联网工程任务组否认所有明示或暗示的保证，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
