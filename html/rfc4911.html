<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 4911: Encoding Instructions for the Robust XML Encoding Rules (RXER)中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC4911 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">打赏</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4911</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4911">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 4911: Encoding Instructions for the Robust XML Encoding Rules (RXER) 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc4911">
              https://datatracker.ietf.org/doc/html/rfc4911
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 4911</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                            S. Legg
Request for Comments: 4911                                       eB2Bcom
Category: Experimental                                         July 2007
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                            S. Legg
Request for Comments: 4911                                       eB2Bcom
Category: Experimental                                         July 2007
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
 Encoding Instructions for the Robust XML Encoding Rules (RXER)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
健壮XML编码规则（RXER）的编码说明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这份备忘录为互联网社区定义了一个实验性协议。它没有规定任何类型的互联网标准。要求进行讨论并提出改进建议。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）IETF信托基金（2007年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines encoding instructions that may be used in an Abstract Syntax Notation One (ASN.1) specification to alter how ASN.1 values are encoded by the Robust XML Encoding Rules (RXER) and Canonical Robust XML Encoding Rules (CRXER), for example, to encode a component of an ASN.1 value as an Extensible Markup Language (XML) attribute rather than as a child element. Some of these encoding instructions also affect how an ASN.1 specification is translated into an Abstract Syntax Notation X (ASN.X) specification. Encoding instructions that allow an ASN.1 specification to reference definitions in other XML schema languages are also defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档定义了可在抽象语法表示法1（ASN.1）规范中使用的编码指令，以改变稳健XML编码规则（RXER）和规范稳健XML编码规则（CRXER）对ASN.1值进行编码的方式，例如，将ASN.1值的组件编码为可扩展标记语言（XML）属性，而不是作为子元素。其中一些编码指令还影响ASN.1规范如何转换为抽象语法符号X（ASN.X）规范。还定义了允许ASN.1规范引用其他XML模式语言中的定义的编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................3
   2. Conventions .....................................................3
   3. Definitions .....................................................4
   4. Notation for RXER Encoding Instructions .........................4
   5. Component Encoding Instructions .................................6
   6. Reference Encoding Instructions .................................8
   7. Expanded Names of Components ...................................10
   8. The ATTRIBUTE Encoding Instruction .............................11
   9. The ATTRIBUTE-REF Encoding Instruction .........................12
   10. The COMPONENT-REF Encoding Instruction ........................13
   11. The ELEMENT-REF Encoding Instruction ..........................16
   12. The LIST Encoding Instruction .................................17
   13. The NAME Encoding Instruction .................................19
   14. The REF-AS-ELEMENT Encoding Instruction .......................19
   15. The REF-AS-TYPE Encoding Instruction ..........................20
   16. The SCHEMA-IDENTITY Encoding Instruction ......................22
   17. The SIMPLE-CONTENT Encoding Instruction .......................22
   18. The TARGET-NAMESPACE Encoding Instruction .....................23
   19. The TYPE-AS-VERSION Encoding Instruction ......................24
   20. The TYPE-REF Encoding Instruction .............................25
   21. The UNION Encoding Instruction ................................26
   22. The VALUES Encoding Instruction ...............................27
   23. Insertion Encoding Instructions ...............................29
   24. The VERSION-INDICATOR Encoding Instruction ....................32
   25. The GROUP Encoding Instruction ................................34
      25.1. Unambiguous Encodings ....................................36
           25.1.1. Grammar Construction ..............................37
           25.1.2. Unique Component Attribution ......................47
           25.1.3. Deterministic Grammars ............................52
           25.1.4. Attributes in Unknown Extensions ..................54
   26. Security Considerations .......................................56
   27. References ....................................................56
      27.1. Normative References .....................................56
      27.2. Informative References ...................................57
   Appendix A. GROUP Encoding Instruction Examples ...................58
   Appendix B. Insertion Encoding Instruction Examples ...............74
   Appendix C. Extension and Versioning Examples .....................87
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................3
   2. Conventions .....................................................3
   3. Definitions .....................................................4
   4. Notation for RXER Encoding Instructions .........................4
   5. Component Encoding Instructions .................................6
   6. Reference Encoding Instructions .................................8
   7. Expanded Names of Components ...................................10
   8. The ATTRIBUTE Encoding Instruction .............................11
   9. The ATTRIBUTE-REF Encoding Instruction .........................12
   10. The COMPONENT-REF Encoding Instruction ........................13
   11. The ELEMENT-REF Encoding Instruction ..........................16
   12. The LIST Encoding Instruction .................................17
   13. The NAME Encoding Instruction .................................19
   14. The REF-AS-ELEMENT Encoding Instruction .......................19
   15. The REF-AS-TYPE Encoding Instruction ..........................20
   16. The SCHEMA-IDENTITY Encoding Instruction ......................22
   17. The SIMPLE-CONTENT Encoding Instruction .......................22
   18. The TARGET-NAMESPACE Encoding Instruction .....................23
   19. The TYPE-AS-VERSION Encoding Instruction ......................24
   20. The TYPE-REF Encoding Instruction .............................25
   21. The UNION Encoding Instruction ................................26
   22. The VALUES Encoding Instruction ...............................27
   23. Insertion Encoding Instructions ...............................29
   24. The VERSION-INDICATOR Encoding Instruction ....................32
   25. The GROUP Encoding Instruction ................................34
      25.1. Unambiguous Encodings ....................................36
           25.1.1. Grammar Construction ..............................37
           25.1.2. Unique Component Attribution ......................47
           25.1.3. Deterministic Grammars ............................52
           25.1.4. Attributes in Unknown Extensions ..................54
   26. Security Considerations .......................................56
   27. References ....................................................56
      27.1. Normative References .....................................56
      27.2. Informative References ...................................57
   Appendix A. GROUP Encoding Instruction Examples ...................58
   Appendix B. Insertion Encoding Instruction Examples ...............74
   Appendix C. Extension and Versioning Examples .....................87
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines encoding instructions [X.680-1] that may be used in an Abstract Syntax Notation One (ASN.1) [X.680] specification to alter how ASN.1 values are encoded by the Robust XML Encoding Rules (RXER) [RXER] and Canonical Robust XML Encoding Rules (CRXER) [RXER], for example, to encode a component of an ASN.1 value as an Extensible Markup Language (XML) [XML10] attribute rather than as a child element. Some of these encoding instructions also affect how an ASN.1 specification is translated into an Abstract Syntax Notation X (ASN.X) specification [ASN.X].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档定义了编码指令[X.680-1]，该指令可在抽象语法符号1（ASN.1）[X.680]规范中使用，以改变稳健XML编码规则（RXER）[RXER]和规范稳健XML编码规则（CRXER）[RXER]对ASN.1值的编码方式，将ASN.1值的组件编码为可扩展标记语言（XML）[XML10]属性，而不是子元素。其中一些编码指令还影响ASN.1规范如何转换为抽象语法符号X（ASN.X）规范[ASN.X]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document also defines encoding instructions that allow an ASN.1 specification to incorporate the definitions of types, elements, and attributes in specifications written in other XML schema languages. References to XML Schema [XSD1] types, elements, and attributes, RELAX NG [RNG] named patterns and elements, and XML document type definition (DTD) [XML10] element types are supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档还定义了编码指令，允许ASN.1规范将类型、元素和属性的定义合并到用其他XML模式语言编写的规范中。支持对XML模式[XSD1]类型、元素和属性、RELAXNG[RNG]命名模式和元素以及XML文档类型定义（DTD）[XML10]元素类型的引用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In most cases, the effect of an encoding instruction is only briefly mentioned in this document. The precise effects of these encoding instructions are described fully in the specifications for RXER [RXER] and ASN.X [ASN.X], at the points where they apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在大多数情况下，本文档仅简要介绍编码指令的效果。这些编码指令的精确效果在RXER[RXER]和ASN.X[ASN.X]的规范中的适用点进行了详细描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Conventions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 习俗
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34; and &#34;MAY&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [BCP14]. The key word &#34;OPTIONAL&#34; is exclusively used with its ASN.1 meaning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“要求”、“应”、“不得”、“应”、“不应”、“建议”和“可”应按照BCP 14、RFC 2119[BCP14]中的说明进行解释。关键词“可选”仅用于其ASN.1含义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Throughout this document &#34;type&#34; shall be taken to mean an ASN.1 type, and &#34;value&#34; shall be taken to mean an ASN.1 abstract value, unless qualified otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本文件中，“类型”应被视为ASN.1类型，“值”应被视为ASN.1抽象值，除非另有限定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A reference to an ASN.1 production [X.680] (e.g., Type, NamedType) is a reference to text in an ASN.1 specification corresponding to that production. Throughout this document, &#34;component&#34; is synonymous with NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对ASN.1产品[X.680]（例如，Type，NamedType）的引用是对与该产品对应的ASN.1规范中文本的引用。在本文档中，“组件”与NamedType同义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document uses the namespace prefix &#34;xsi:&#34; to stand for the namespace name [XMLNS10] &#34;http://www.w3.org/2001/XMLSchema-instance&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档使用名称空间前缀“xsi:”表示名称空间名称[XMLNS10]”http://www.w3.org/2001/XMLSchema-instance&#34;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example ASN.1 definitions in this document are assumed to be defined in an ASN.1 module with a TagDefault of &#34;AUTOMATIC TAGS&#34; and an EncodingReferenceDefault [X.680-1] of &#34;RXER INSTRUCTIONS&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档中的示例ASN.1定义假定在ASN.1模块中定义，标记默认值为“自动标记”，编码参考默认值为“RXER指令”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following definition of base type is used in specifying a number of encoding instructions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面的基类型定义用于指定许多编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (base type): If a type, T, is a constrained type, then the base type of T is the base type of the type that is constrained; else if T is a prefixed type, then the base type of T is the base type of the type that is prefixed; else if T is a type notation that references or denotes another type (i.e., DefinedType, ObjectClassFieldType, SelectionType, TypeFromObject, or ValueSetFromObjects), then the base type of T is the base type of the type that is referenced or denoted; otherwise, the base type of T is T itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（基类型）：如果类型T是受约束类型，则T的基类型是受约束类型的基类型；否则，如果T是前缀类型，则T的基类型是前缀类型的基类型；否则，如果T是引用或表示另一类型（即DefinedType、ObjectClassFieldType、SelectionType、TypeFromObject或ValueSetFromObjects）的类型表示法，则T的基类型是被引用或表示的类型的基类型；否则，T的基类型就是T本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: A tagged type is a special case of a prefixed type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：标记类型是前缀类型的特例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Notation for RXER Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. RXER编码指令的符号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The grammar of ASN.1 permits the application of encoding instructions [X.680-1], through type prefixes and encoding control sections, that modify how abstract values are encoded by nominated encoding rules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1的语法允许应用编码指令[X.680-1]，通过类型前缀和编码控制部分修改指定编码规则对抽象值的编码方式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The generic notation for type prefixes and encoding control sections is defined by the ASN.1 basic notation [X.680] [X.680-1], and includes an encoding reference to identify the specific encoding rules that are affected by the encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型前缀和编码控制部分的通用表示法由ASN.1基本表示法[X.680][X.680-1]定义，并包括一个编码引用，用于标识受编码指令影响的特定编码规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The encoding reference that identifies the Robust XML Encoding rules is literally RXER. An RXER encoding instruction applies equally to both RXER and CRXER encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
标识健壮XML编码规则的编码引用实际上是RXER。RXER编码指令同样适用于RXER和CRXER编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specific notation for an encoding instruction for a specific set of encoding rules is left to the specification of those encoding rules. Consequently, this companion document to the RXER specification [RXER] defines the notation for RXER encoding instructions. Specifically, it elaborates the EncodingInstruction and EncodingInstructionAssignmentList placeholder productions of the ASN.1 basic notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于一组特定的编码规则，编码指令的特定符号由这些编码规则的规范决定。因此，RXER规范[RXER]的本配套文件定义了RXER编码指令的符号。具体来说，它阐述了ASN.1基本符号的EncodingInstruction和EncodingInstructionAssignmentList占位符产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the context of the RXER encoding reference, the EncodingInstruction production is defined as follows, using the conventions of the ASN.1 basic notation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在RXER编码参考的上下文中，使用ASN.1基本符号的约定，编码指令生成定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      EncodingInstruction ::=
          AttributeInstruction |
          AttributeRefInstruction |
          ComponentRefInstruction |
          ElementRefInstruction |
          GroupInstruction |
          InsertionsInstruction |
          ListInstruction |
          NameInstruction |
          RefAsElementInstruction |
          RefAsTypeInstruction |
          SimpleContentInstruction |
          TypeAsVersionInstruction |
          TypeRefInstruction |
          UnionInstruction |
          ValuesInstruction |
          VersionIndicatorInstruction
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      EncodingInstruction ::=
          AttributeInstruction |
          AttributeRefInstruction |
          ComponentRefInstruction |
          ElementRefInstruction |
          GroupInstruction |
          InsertionsInstruction |
          ListInstruction |
          NameInstruction |
          RefAsElementInstruction |
          RefAsTypeInstruction |
          SimpleContentInstruction |
          TypeAsVersionInstruction |
          TypeRefInstruction |
          UnionInstruction |
          ValuesInstruction |
          VersionIndicatorInstruction
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the context of the RXER encoding reference, the EncodingInstructionAssignmentList production (which only appears in an encoding control section) is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在RXER编码引用的上下文中，EncodingInstructionAssignmentList产品（仅出现在编码控制部分）定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      EncodingInstructionAssignmentList ::=
          SchemaIdentityInstruction ?
          TargetNamespaceInstruction ?
          TopLevelComponents ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      EncodingInstructionAssignmentList ::=
          SchemaIdentityInstruction ?
          TargetNamespaceInstruction ?
          TopLevelComponents ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TopLevelComponents ::= TopLevelComponent TopLevelComponents ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TopLevelComponents ::= TopLevelComponent TopLevelComponents ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TopLevelComponent ::= &#34;COMPONENT&#34; NamedType
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TopLevelComponent ::= &#34;COMPONENT&#34; NamedType
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (top-level NamedType): A NamedType is a top-level NamedType (equivalently, a top-level component) if and only if it is the NamedType in a TopLevelComponent. A NamedType nested within the Type of the NamedType of a TopLevelComponent is not itself a top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（顶级NamedType）：NamedType是顶级NamedType（相当于顶级组件），当且仅当它是TopLevelComponent中的NamedType时。嵌套在TopLevelComponent的NamedType类型中的NamedType本身不是顶级NamedType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Specification writers should note that non-trivial types defined within a top-level NamedType will not be visible to ASN.1 tools that do not understand RXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：规范编写者应该注意，顶级NamedType中定义的非平凡类型对于不理解RXER的ASN.1工具将不可见。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although a top-level NamedType only appears in an RXER encoding control section, the default encoding reference for the module [X.680-1] still applies when parsing a top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管顶级NamedType仅出现在RXER编码控制部分中，但在解析顶级NamedType时，模块[X.680-1]的默认编码参考仍然适用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each top-level NamedType within a module SHALL have a distinct identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
模块内的每个顶级命名类型应具有不同的标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NamedType production is defined by the ASN.1 basic notation. The other productions are described in subsequent sections and make use of the following productions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NamedType产品由ASN.1基本符号定义。其他产品将在后续章节中介绍，并使用以下产品：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NCNameValue ::= Value
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NCNameValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AnyURIValue ::= Value
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AnyURIValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      QNameValue ::= Value
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      QNameValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NameValue ::= Value
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NameValue ::= Value
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Value production is defined by the ASN.1 basic notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
价值生产由ASN.1基本符号定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The governing type for the Value in an NCNameValue is the NCName type from the AdditionalBasicDefinitions module [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NCNameValue中值的控制类型是AdditionalBasicDefinitions模块[RXER]中的NCName类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The governing type for the Value in an AnyURIValue is the AnyURI type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AnyURIValue中值的控制类型是AdditionalBasicDefinitions模块中的AnyURI类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The governing type for the Value in a QNameValue is the QName type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QNameValue中值的控制类型是AdditionalBasicDefinitions模块中的QName类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The governing type for the Value in a NameValue is the Name type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NameValue中值的控制类型是AdditionalBasicDefinitions模块中的名称类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Value in an NCNameValue, AnyURIValue, QNameValue, or NameValue SHALL NOT be a DummyReference [X.683] and SHALL NOT textually contain a nested DummyReference.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NCNameValue、AnyURIValue、QNameValue或NameValue中的值不得为DummyReference[X.683]，且不得在文本中包含嵌套的DummyReference。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Thus, encoding instructions are not permitted to be parameterized in any way. This restriction will become important if a future specification for ASN.X explicitly represents parameterized definitions and parameterized references instead of expanding out parameterized references as in the current specification. A parameterized definition could not be directly translated into ASN.X if it contained encoding instructions that were not fully specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：因此，编码指令不允许以任何方式参数化。如果ASN.X的未来规范显式表示参数化定义和参数化引用，而不是像当前规范那样扩展参数化引用，则此限制将变得非常重要。如果参数化定义包含未完全指定的编码指令，则无法将其直接转换为ASN.X。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Component Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 组件编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain of the RXER encoding instructions are categorized as component encoding instructions. The component encoding instructions are the ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, NAME, REF-AS-ELEMENT, SIMPLE-CONTENT, TYPE-AS-VERSION, and VERSION-INDICATOR encoding instructions (whose notations are described respectively by AttributeInstruction, AttributeRefInstruction, ComponentRefInstruction, GroupInstruction,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些RXER编码指令被归类为组件编码指令。组件编码指令是ATTRIBUTE、ATTRIBUTE-REF、component-REF、GROUP、ELEMENT-REF、NAME、REF-AS-ELEMENT、SIMPLE-CONTENT、TYPE-AS-VERSION和VERSION-INDICATOR编码指令（其符号分别由AttributeInstruction、AttributeRefInstruction、ComponentRefInstruction、GroupInstruction、，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ElementRefInstruction, NameInstruction, RefAsElementInstruction, SimpleContentInstruction, TypeAsVersionInstruction, and VersionIndicatorInstruction).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ElementRefInstruction、NameInstruction、RefAsElementInstruction、SimpleContentInstruction、TypeAsVersionInstruction和VersionIndicatorInstruction）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the EncodingPrefixedType for a component encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组件编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) the Type in a NamedType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) NamedType中的类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) the Type in an EncodingPrefixedType in a PrefixedType in a BuiltinType in a Type that is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) EncodingPrefixedType中的类型PrefixedType中的类型在类型为（1）到（4）之一的内置类型中，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) the Type in an TaggedType in a PrefixedType in a BuiltinType in a Type that is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 类型为（1）到（4）之一的内置类型中的PrefixedType中的TaggedType中的类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) the Type in a ConstrainedType (excluding a TypeWithConstraint) in a Type that is one of (1) to (4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 属于（1）到（4）之一的类型中的ConstrainedType（不包括TypeWithConstraint）中的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: The effect of this condition is to force the component encoding instructions to be textually within the NamedType to which they apply. Only case (2) can be true on the first iteration as the Type belongs to an EncodingPrefixedType; however, any of (1) to (4) can be true on subsequent iterations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：此条件的效果是强制组件编码指令以文本形式在其应用的NamedType中。在第一次迭代中，只有情况（2）可以为真，因为该类型属于EncodingPrefixedType；但是，在后续迭代中，（1）到（4）中的任何一个都可能为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Case (4) is not permitted when the encoding instruction is the ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, or REF-AS-ELEMENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当编码指令是ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF或REF-AS-ELEMENT编码指令时，不允许使用情况（4）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NamedType in case (1) is said to be &#34;subject to&#34; the component encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
案例（1）中的NamedType被称为“服从”组件编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A top-level NamedType SHALL NOT be subject to an ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, or SIMPLE-CONTENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
顶级命名类型不受ATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT或SIMPLE-CONTENT编码指令的约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: This condition does not preclude these encoding instructions being used on a nested NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：此条件不排除在嵌套NamedType上使用这些编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A NamedType SHALL NOT be subject to two or more component encoding instructions of the same kind, e.g., a NamedType is not permitted to be subject to two NAME encoding instructions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个命名类型不受两个或两个以上同类组件编码指令的约束，例如，一个命名类型不允许受两个名称编码指令的约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, and TYPE-AS-VERSION encoding instructions are mutually exclusive. The NAME, ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, and REF-AS-ELEMENT encoding instructions are mutually exclusive. A NamedType SHALL NOT be subject to two or more encoding instructions that are mutually exclusive.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ATTRIBUTE、ATTRIBUTE-REF、COMPONENT-REF、GROUP、ELEMENT-REF、REF-AS-ELEMENT、SIMPLE-CONTENT和TYPE-AS-VERSION编码指令是互斥的。名称、ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF和REF-AS-ELEMENT编码指令是互斥的。命名类型不受两个或多个相互排斥的编码指令的约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SelectionType [X.680] SHALL NOT be used to select the Type from a NamedType that is subject to an ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF or REF-AS-ELEMENT encoding instruction. The other component encoding instructions are not inherited by the type denoted by a SelectionType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SelectionType[X.680]不得用于从受ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF或REF-AS-ELEMENT编码指令约束的NamedType中选择类型。由SelectionType表示的类型不会继承其他组件编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (attribute component): An attribute component is a NamedType that is subject to an ATTRIBUTE or ATTRIBUTE-REF encoding instruction, or subject to a COMPONENT-REF encoding instruction that references a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（属性组件）：属性组件是服从属性或属性-REF编码指令的NamedType，或服从引用服从属性编码指令的顶级NamedType的component-REF编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (element component): An element component is a NamedType that is not subject to an ATTRIBUTE, ATTRIBUTE-REF, GROUP, or SIMPLE-CONTENT encoding instruction, and not subject to a COMPONENT-REF encoding instruction that references a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该元素是一个简单的属性组，而不是一个简单的属性组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: A NamedType subject to a GROUP or SIMPLE-CONTENT encoding instruction is neither an attribute component nor an element component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：服从组或简单内容编码指令的NamedType既不是属性组件，也不是元素组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Reference Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 参考编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain of the RXER encoding instructions are categorized as reference encoding instructions. The reference encoding instructions are the ATTRIBUTE-REF, COMPONENT-REF, ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, and TYPE-REF encoding instructions (whose notations are described respectively by AttributeRefInstruction, ComponentRefInstruction, ElementRefInstruction, RefAsElementInstruction, RefAsTypeInstruction, and TypeRefInstruction). These encoding instructions (except COMPONENT-REF) allow an ASN.1 specification to incorporate the definitions of types, elements, and attributes in specifications written in other XML schema languages, through implied constraints on the markup that may appear in values of the Markup ASN.1 type from the AdditionalBasicDefinitions module [RXER] (for ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, and TYPE-REF) or the UTF8String type (for ATTRIBUTE-REF). References to XML Schema [XSD1] types, elements, and attributes, RELAX NG [RNG] named patterns and elements, and XML document type definition (DTD) [XML10] element types are supported. References to ASN.1 types and top-level components are also permitted. The COMPONENT-REF encoding instruction provides a more direct method of referencing a top-level component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些RXER编码指令被归类为参考编码指令。引用编码指令是ATTRIBUTE-REF、COMPONENT-REF、ELEMENT-REF、REF-AS-ELEMENT、REF-AS-TYPE和TYPE-REF编码指令（其符号分别由attributerefininstruction、ComponentRefInstruction、ElementRefInstruction、RefAsElementInstruction、RefAsTypeInstruction和TypeRefInstruction描述）。这些编码指令（COMPONENT-REF除外）允许ASN.1规范通过对标记的隐含约束（可能出现在AdditionalBasicDefinitions模块[RXER]中的标记ASN.1类型的值中）合并以其他XML模式语言编写的规范中的类型、元素和属性的定义（对于ELEMENT-REF、REF-AS-ELEMENT、REF-AS-TYPE和TYPE-REF）或UTF8String类型（对于ATTRIBUTE-REF）。对XML模式[XSD1]类型、元素和属性、RELAXNG[RNG]命名模式和元素以及XML文档类型定义（DTD）[XML10]的引用支持元素类型。还允许引用ASN.1类型和顶级组件。COMPONENT-REF编码指令提供了引用顶级组件的更直接方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the EncodingPrefixedType for an ELEMENT-REF, REF-AS-ELEMENT, REF-AS-TYPE, or TYPE-REF encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ELEMENT-REF、REF-AS-ELEMENT、REF-AS-Type或Type-REF编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a ReferencedType that is a DefinedType that is a typereference (not a DummyReference) or ExternalTypeReference that references the Markup ASN.1 type from the AdditionalBasicDefinitions module [RXER], or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) ReferencedType是一个定义类型，它是一个typereference（不是DummyReference）或ExternalTypeReference，它引用AdditionalBasicDefinitions模块[RXER]中的标记ASN.1类型，或者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (3), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（3）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (3) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（1）到（3）之一，EncodingPrefixedType中的EncodingPrefix不包含引用编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Case (3) and similar cases for the ATTRIBUTE-REF and COMPONENT-REF encoding instructions have the effect of making the reference encoding instructions mutually exclusive as well as singly occurring.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：ATTRIBUTE-REF和COMPONENT-REF编码指令的情况（3）和类似情况具有使参考编码指令相互排斥以及单独出现的效果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With respect to the REF-AS-TYPE and TYPE-REF encoding instructions, the DefinedType in case (1) is said to be &#34;subject to&#34; the encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
关于REF-AS-TYPE和TYPE-REF编码指令，情况（1）中定义的类型被称为“服从”编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The restrictions on the Type in the EncodingPrefixedType for an ATTRIBUTE-REF encoding instruction are specified in Section 9. The restrictions on the Type in the EncodingPrefixedType for a COMPONENT-REF encoding instruction are specified in Section 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第9节规定了对ATTRIBUTE-REF编码指令的EncodingPrefixedType中的类型的限制。第10节规定了对COMPONENT-REF编码指令的EncodingPrefixedType中的类型的限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reference encoding instructions make use of a common production defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考编码指令使用如下定义的通用产品：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RefParameters ::= ContextParameter ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RefParameters ::= ContextParameter ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ContextParameter ::= &#34;CONTEXT&#34; AnyURIValue
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ContextParameter ::= &#34;CONTEXT&#34; AnyURIValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A RefParameters instance provides extra information about a reference to a definition. A ContextParameter is used when a reference is ambiguous, i.e., refers to definitions in more than one schema document or external DTD subset. This situation would occur, for example, when importing types with the same name from independently developed XML Schemas defined without a target namespace [XSD1]. When used in conjunction with a reference to an element type in an external DTD subset, the AnyURIValue in the ContextParameter is the system identifier (a Uniform Resource Identifier or URI [URI]) of the external DTD subset; otherwise, the AnyURIValue is a URI that indicates the intended schema document, either an XML Schema specification, a RELAX NG specification, or an ASN.1 or ASN.X specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RefParameters实例提供有关对定义的引用的额外信息。当引用不明确时，即引用多个模式文档或外部DTD子集中的定义时，使用ContextParameter。例如，当从未定义目标命名空间[XSD1]的独立开发的XML模式中导入具有相同名称的类型时，就会出现这种情况。当与对外部DTD子集中的元素类型的引用一起使用时，ContextParameter中的AnyURIValue是外部DTD子集的系统标识符（统一资源标识符或URI[URI]）；否则，AnyURIValue是一个URI，它指示预期的模式文档，可以是XML模式规范、RELAXNG规范，也可以是ASN.1或ASN.X规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Expanded Names of Components
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 组件的扩展名称
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each NamedType has an associated expanded name [XMLNS10], determined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个NamedType都有一个关联的扩展名[XMLNS10]，确定如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) if the NamedType is subject to a NAME encoding instruction, then the local name of the expanded name is the character string specified by the NCNameValue of the NAME encoding instruction,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 如果NamedType受名称编码指令约束，则扩展名称的本地名称是名称编码指令的NCNameValue指定的字符串，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) else if the NamedType is subject to a COMPONENT-REF encoding instruction, then the expanded name is the same as the expanded name of the referenced top-level NamedType,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 否则，如果NamedType遵循COMPONENT-REF编码指令，则扩展名与引用的顶级NamedType的扩展名相同，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) else if the NamedType is subject to an ATTRIBUTE-REF or ELEMENT-REF encoding instruction, then the namespace name of the expanded name is equal to the namespace-name component of the QNameValue of the encoding instruction, and the local name is equal to the local-name component of the QNameValue,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 否则，如果NamedType受ATTRIBUTE-REF或ELEMENT-REF编码指令的约束，则扩展名称的名称空间名称等于编码指令的QNameValue的名称空间名称组件，本地名称等于QNameValue的本地名称组件，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) else if the NamedType is subject to a REF-AS-ELEMENT encoding instruction, then the local name of the expanded name is the LocalPart [XMLNS10] of the qualified name specified by the NameValue of the encoding instruction,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 否则，如果NamedType受REF-AS-ELEMENT编码指令约束，则扩展名称的本地名称是编码指令的NameValue指定的限定名称的LocalPart[XMLNS10]，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) otherwise, the local name of the expanded name is the identifier of the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) 否则，扩展名称的本地名称就是NamedType的标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In cases (1) and (5), if the NamedType is a top-level NamedType and the module containing the NamedType has a TARGET-NAMESPACE encoding instruction, then the namespace name of the expanded name is the character string specified by the AnyURIValue of the TARGET-NAMESPACE encoding instruction; otherwise, the namespace name has no value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在情况（1）和（5）中，如果NamedType是顶级NamedType，并且包含NamedType的模块具有目标名称空间编码指令，则扩展名称的名称空间名称是目标名称空间编码指令的AnyURIValue指定的字符串；否则，名称空间名称没有值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Thus, the TARGET-NAMESPACE encoding instruction applies to a top-level NamedType but not to any other NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：因此，TARGET-NAMESPACE编码指令适用于顶级NamedType，但不适用于任何其他NamedType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In case (4), if the encoding instruction contains a Namespace, then the namespace name of the expanded name is the character string specified by the AnyURIValue of the Namespace; otherwise, the namespace name has no value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在案例（4）中，如果编码指令包含名称空间，则扩展名称的名称空间名称是由名称空间的AnyURIValue指定的字符串；否则，名称空间名称没有值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The expanded names for the attribute components of a CHOICE, SEQUENCE, or SET type MUST be distinct. The expanded names for the components of a CHOICE, SEQUENCE, or SET type that are not attribute components MUST be distinct. These tests are applied after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项、序列或集合类型的属性组件的扩展名称必须是不同的。非属性组件的选项、序列或集合类型的组件的扩展名称必须是不同的。这些试验在X.680第24.4条[X.680]中规定的转换组件之后进行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Two components of the same CHOICE, SEQUENCE, or SET type may have the same expanded name if one of them is an attribute component and the other is not. Note that the &#34;not&#34; case includes components that are subject to a GROUP or SIMPLE-CONTENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：相同选择、序列或集合类型的两个组件可能具有相同的扩展名，如果其中一个是属性组件，而另一个不是。注意，“not”情况包括服从分组或简单内容编码指令的组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The expanded name of a top-level NamedType subject to an ATTRIBUTE encoding instruction MUST be distinct from the expanded name of every other top-level NamedType subject to an ATTRIBUTE encoding instruction in the same module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性编码指令的顶级NamedType主题的扩展名必须不同于同一模块中属性编码指令的其他所有顶级NamedType主题的扩展名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The expanded name of a top-level NamedType not subject to an ATTRIBUTE encoding instruction MUST be distinct from the expanded name of every other top-level NamedType not subject to an ATTRIBUTE encoding instruction in the same module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不受属性编码指令约束的顶级NamedType的扩展名必须与同一模块中所有其他不受属性编码指令约束的顶级NamedType的扩展名不同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Two top-level components may have the same expanded name if one of them is an attribute component and the other is not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：如果两个顶级组件中的一个是属性组件，而另一个不是属性组件，则它们可能具有相同的扩展名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. The ATTRIBUTE Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 属性编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ATTRIBUTE encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an XML attribute instead of as a child element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性编码指令使RXER编码器将应用它的组件的值编码为XML属性，而不是子元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for an ATTRIBUTE encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AttributeInstruction ::= &#34;ATTRIBUTE&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AttributeInstruction ::= &#34;ATTRIBUTE&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base type of the type of a NamedType that is subject to an ATTRIBUTE encoding instruction SHALL NOT be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受属性编码指令约束的NamedType类型的基本类型不得为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a CHOICE, SET, or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 类型的选择、集合或集合，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 序列类型，而不是从AdditionalBasicDefinitions模块[RXER]定义QName类型的序列类型（即，允许使用QName），或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 一种类型序列，其中SequenceOfType不受列表编码指令的约束，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) an open type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 开放式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      PersonalDetails ::= SEQUENCE {
          firstName   [ATTRIBUTE] UTF8String,
          middleName  [ATTRIBUTE] UTF8String,
          surname     [ATTRIBUTE] UTF8String
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      PersonalDetails ::= SEQUENCE {
          firstName   [ATTRIBUTE] UTF8String,
          middleName  [ATTRIBUTE] UTF8String,
          surname     [ATTRIBUTE] UTF8String
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. The ATTRIBUTE-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. ATTRIBUTE-REF编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ATTRIBUTE-REF encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an XML attribute instead of as a child element, where the attribute&#39;s name is a qualified name of the attribute declaration referenced by the encoding instruction. In addition, the ATTRIBUTE-REF encoding instruction causes values of the UTF8String type to be restricted to conform to the type of the attribute declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ATTRIBUTE-REF编码指令使RXER编码器将其应用到的组件的值编码为XML属性，而不是子元素，其中属性名称是编码指令引用的属性声明的限定名称。此外，ATTRIBUTE-REF编码指令会限制UTF8String类型的值，以符合属性声明的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for an ATTRIBUTE-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ATTRIBUTE-REF编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AttributeRefInstruction ::=
          &#34;ATTRIBUTE-REF&#34; QNameValue RefParameters
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AttributeRefInstruction ::=
          &#34;ATTRIBUTE-REF&#34; QNameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taken together, the QNameValue and the ContextParameter in the RefParameters (if present) MUST reference an XML Schema attribute declaration or a top-level NamedType that is subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总之，RefParameters（如果存在）中的QNameValue和ContextParameter必须引用XML架构属性声明或受属性编码指令约束的顶级NamedType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type of a referenced XML Schema attribute declaration SHALL NOT be, either directly or by derivation, the XML Schema type QName, NOTATION, ENTITY, ENTITIES, or anySimpleType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引用的XML模式属性声明的类型不得直接或通过派生方式为XML模式类型QName、NOTATION、ENTITY、ENTITIES或anySimpleType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Values of these types require information from the context of the attribute for interpretation. Because an ATTRIBUTE-REF encoding instruction is restricted to prefixing the ASN.1 UTF8String type, there is no mechanism to capture such context.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：这些类型的值需要来自属性上下文的信息进行解释。由于ATTRIBUTE-REF编码指令仅限于作为ASN.1 UTF8String类型的前缀，因此没有捕获此类上下文的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type of a referenced top-level NamedType SHALL NOT be, either directly or by subtyping, the QName type from the AdditionalBasicDefinitions module [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引用的顶级NamedType的类型不得直接或通过子类型与AdditionalBasicDefinitions模块[RXER]中的QName类型相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the EncodingPrefixedType for an ATTRIBUTE-REF encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ATTRIBUTE-REF编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) the UTF8String type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) UTF8String类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (3), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（3）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (3) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（1）到（3）之一，EncodingPrefixedType中的EncodingPrefix不包含引用编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The identifier of a NamedType subject to an ATTRIBUTE-REF encoding instruction does not contribute to the name of attributes in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the local name of the referenced attribute declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受ATTRIBUTE-REF编码指令约束的NamedType的标识符不影响RXER编码中的属性名称。为保持一致性，标识符应尽可能与被引用属性声明的本地名称相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. The COMPONENT-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. COMPONENT-REF编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ASN.1 basic notation does not have a concept of a top-level NamedType and therefore does not have a mechanism to reference a top-level NamedType. The COMPONENT-REF encoding instruction provides a way to specify that a NamedType within a combining type definition is equivalent to a referenced top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1基本表示法没有顶级NamedType的概念，因此没有引用顶级NamedType的机制。COMPONENT-REF编码指令提供了一种方法，用于指定组合类型定义中的NamedType等同于引用的顶级NamedType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a COMPONENT-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPONENT-REF编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ComponentRefInstruction ::= &#34;COMPONENT-REF&#34; ComponentReference
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ComponentRefInstruction ::= &#34;COMPONENT-REF&#34; ComponentReference
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ComponentReference ::=
          InternalComponentReference |
          ExternalComponentReference
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ComponentReference ::=
          InternalComponentReference |
          ExternalComponentReference
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      InternalComponentReference ::= identifier FromModule ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      InternalComponentReference ::= identifier FromModule ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      FromModule ::= &#34;FROM&#34; GlobalModuleReference
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      FromModule ::= &#34;FROM&#34; GlobalModuleReference
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ExternalComponentReference ::= modulereference &#34;.&#34; identifier
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ExternalComponentReference ::= modulereference &#34;.&#34; identifier
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GlobalModuleReference production is defined by the ASN.1 basic notation [X.680]. If the GlobalModuleReference is absent from an InternalComponentReference, then the identifier MUST be the identifier of a top-level NamedType in the same module. If the GlobalModuleReference is present in an InternalComponentReference, then the identifier MUST be the identifier of a top-level NamedType in the referenced module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GlobalModuleReference产品由ASN.1基本符号[X.680]定义。如果InternalComponentReference中缺少GlobalModuleReference，则该标识符必须是同一模块中顶级NamedType的标识符。如果GlobalModuleReference存在于InternalComponentReference中，则该标识符必须是被引用模块中顶级NamedType的标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The modulereference in an ExternalComponentReference is used in the same way as a modulereference in an ExternalTypeReference. The identifier in an ExternalComponentReference MUST be the identifier of a top-level NamedType in the referenced module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ExternalComponentReference中的modulereference与ExternalTypeReference中的modulereference的使用方式相同。ExternalComponentReference中的标识符必须是所引用模块中顶级NamedType的标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the EncodingPrefixedType for a COMPONENT-REF encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPONENT-REF编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a ReferencedType that is a DefinedType that is a typereference (not a DummyReference) or an ExternalTypeReference, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) ReferencedType是一个定义类型，它是一个类型引用（不是DummyReference）或一个ExternalTypeReference，或者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a BuiltinType or ReferencedType that is one of the productions in Table 1 in Section 5 of the specification for RXER [RXER], or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) RXER[RXER]规范第5节表1中的产品之一的内置类型或引用类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（4）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (4) and the EncodingPrefix in the EncodingPrefixedType does not contain a reference encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（1）到（4）之一，EncodingPrefixedType中的EncodingPrefix不包含引用编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The restrictions on the use of RXER encoding instructions are such that no other RXER encoding instruction is permitted within a NamedType if the NamedType is subject to a COMPONENT-REF encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用RXER编码指令的限制是，如果NamedType受COMPONENT-REF编码指令的约束，则NamedType中不允许使用其他RXER编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the top-level NamedType referenced by the COMPONENT-REF encoding instruction MUST be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
COMPONENT-REF编码指令引用的顶级NamedType中的类型必须为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) if the preceding case (1) is used, a ReferencedType that is a DefinedType that is a typereference or ExternalTypeReference that references the same type as the DefinedType in case (1), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(a) 如果使用前一种情况（1），则为定义类型的ReferencedType，该定义类型为typereference或ExternalTypeReference，其引用的类型与情况（1）中定义类型相同，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) if the preceding case (2) is used, a BuiltinType or ReferencedType that is the same as the BuiltinType or ReferencedType in case (2), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(b) 如果使用前一种情况（2），则为与情况（2）中的内置类型或ReferencedType相同的内置类型或ReferencedType，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(c) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (a) to (c), and the EncodingPrefix in the EncodingPrefixedType contains an RXER encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(c) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型是（a）到（c）之一，EncodingPrefixedType中的EncodingPrefix包含RXER编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In principle, the COMPONENT-REF encoding instruction creates a notional NamedType where the expanded name is that of the referenced top-level NamedType and the Type in case (1) or (2) is substituted by the Type of the referenced top-level NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原则上，COMPONENT-REF编码指令创建一个概念性的NamedType，其中扩展名称是引用的顶级NamedType的名称，而案例（1）或（2）中的类型被引用的顶级NamedType的类型替换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In practice, it is sufficient for non-RXER encoders and decoders to use the original NamedType rather than the notional NamedType because the Type in case (1) or (2) can only differ from the Type of the referenced top-level NamedType by having fewer RXER encoding instructions, and RXER encoding instructions are ignored by non-RXER encoders and decoders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实际上，非RXER编码器和解码器使用原始NamedType而不是名义上的NamedType就足够了，因为情况（1）或（2）中的类型只能通过较少的RXER编码指令与引用的顶级NamedType的类型不同，非RXER编码器和解码器忽略RXER编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although any prefixes for the Type in case (1) or (2) would be bypassed, it is sufficient for RXER encoders and decoders to use the referenced top-level NamedType instead of the notional NamedType because these prefixes cannot be RXER encoding instructions (except, of course, for the COMPONENT-REF encoding instruction) and can have no effect on an RXER encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然（1）或（2）中类型的任何前缀都将被绕过，但RXER编码器和解码器使用引用的顶级NamedType而不是名义上的NamedType就足够了，因为这些前缀不能是RXER编码指令（当然，对于COMPONENT-REF编码指令除外）并且对RXER编码没有影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Modules ::= SEQUENCE OF
          module [COMPONENT-REF module
                     FROM AbstractSyntaxNotation-X
                         { 1 3 6 1 4 1 21472 1 0 1 }]
                     ModuleDefinition
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Modules ::= SEQUENCE OF
          module [COMPONENT-REF module
                     FROM AbstractSyntaxNotation-X
                         { 1 3 6 1 4 1 21472 1 0 1 }]
                     ModuleDefinition
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that the &#34;module&#34; top-level NamedType in the AbstractSyntaxNotation-X module is defined like so:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
请注意，AbstractSyntaxNotation-X模块中的“模块”顶级NamedType定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
COMPONENT module ModuleDefinition
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
组件模块定义
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ASN.X translation of the SEQUENCE OF type definition provides a more natural representation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
类型定义序列的ASN.X转换提供了更自然的表示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;namedType xmlns:asnx=&#34;urn:ietf:params:xml:ns:asnx&#34;
                    name=&#34;Modules&#34;&gt;
          &lt;sequenceOf&gt;
           &lt;element ref=&#34;asnx:module&#34;/&gt;
          &lt;/sequenceOf&gt;
         &lt;/namedType&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;namedType xmlns:asnx=&#34;urn:ietf:params:xml:ns:asnx&#34;
                    name=&#34;Modules&#34;&gt;
          &lt;sequenceOf&gt;
           &lt;element ref=&#34;asnx:module&#34;/&gt;
          &lt;/sequenceOf&gt;
         &lt;/namedType&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Aside: The &lt;namedType&gt; element in ASN.X corresponds to a TypeAssignment, not a NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
旁白：ASN.X中的&lt;namedType&gt;元素对应于类型分配，而不是namedType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The identifier of a NamedType subject to a COMPONENT-REF encoding instruction does not contribute to an RXER encoding. For the sake of consistency with other encoding rules, the identifier SHOULD be the same as the identifier in the ComponentRefInstruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受COMPONENT-REF编码指令约束的NamedType的标识符不支持RXER编码。为了与其他编码规则保持一致，标识符应与ComponentRef指令中的标识符相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. The ELEMENT-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. ELEMENT-REF编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ELEMENT-REF encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an element where the element&#39;s name is a qualified name of the element declaration referenced by the encoding instruction. In addition, the ELEMENT-REF encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the type of the element declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ELEMENT-REF编码指令使RXER编码器将其应用到的组件的值编码为元素，其中元素名称是编码指令引用的元素声明的限定名称。此外，ELEMENT-REF编码指令会限制标记ASN.1类型的值，以符合元素声明的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for an ELEMENT-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ELEMENT-REF编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ElementRefInstruction ::= &#34;ELEMENT-REF&#34; QNameValue RefParameters
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ElementRefInstruction ::= &#34;ELEMENT-REF&#34; QNameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taken together, the QNameValue and the ContextParameter in the RefParameters (if present) MUST reference an XML Schema element declaration, a RELAX NG element definition, or a top-level NamedType that is not subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总之，RefParameters（如果存在）中的QNameValue和ContextParameter必须引用XML架构元素声明、RELAX NG元素定义或不受属性编码指令约束的顶级NamedType。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A referenced XML Schema element declaration MUST NOT have a type that requires the presence of values for the XML Schema ENTITY or ENTITIES types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引用的XML架构元素声明的类型不能要求存在XML架构实体或实体类型的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：CRXER不支持实体声明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AnySchema ::= CHOICE {
          module   [ELEMENT-REF {
                       namespace-name
                           &#34;urn:ietf:params:xml:ns:asnx&#34;,
                       local-name &#34;module&#34; }]
                   Markup,
          schema   [ELEMENT-REF {
                       namespace-name
                           &#34;http://www.w3.org/2001/XMLSchema&#34;,
                       local-name &#34;schema&#34; }]
                   Markup,
          grammar  [ELEMENT-REF {
                       namespace-name
                           &#34;http://relaxng.org/ns/structure/1.0&#34;,
                       local-name &#34;grammar&#34; }]
                   Markup
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AnySchema ::= CHOICE {
          module   [ELEMENT-REF {
                       namespace-name
                           &#34;urn:ietf:params:xml:ns:asnx&#34;,
                       local-name &#34;module&#34; }]
                   Markup,
          schema   [ELEMENT-REF {
                       namespace-name
                           &#34;http://www.w3.org/2001/XMLSchema&#34;,
                       local-name &#34;schema&#34; }]
                   Markup,
          grammar  [ELEMENT-REF {
                       namespace-name
                           &#34;http://relaxng.org/ns/structure/1.0&#34;,
                       local-name &#34;grammar&#34; }]
                   Markup
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The ASN.X translation of the choice type definition provides a more natural representation:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
选择类型定义的ASN.X翻译提供了更自然的表示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;namedType xmlns:asnx=&#34;urn:ietf:params:xml:ns:asnx&#34;
                    xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34;
                    xmlns:rng=&#34;http://relaxng.org/ns/structure/1.0&#34;
                    name=&#34;AnySchema&#34;&gt;
          &lt;choice&gt;
           &lt;element ref=&#34;asnx:module&#34; embedded=&#34;true&#34;/&gt;
           &lt;element ref=&#34;xs:schema&#34; embedded=&#34;true&#34;/&gt;
           &lt;element ref=&#34;rng:grammar&#34; embedded=&#34;true&#34;/&gt;
          &lt;/choice&gt;
         &lt;/namedType&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;namedType xmlns:asnx=&#34;urn:ietf:params:xml:ns:asnx&#34;
                    xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34;
                    xmlns:rng=&#34;http://relaxng.org/ns/structure/1.0&#34;
                    name=&#34;AnySchema&#34;&gt;
          &lt;choice&gt;
           &lt;element ref=&#34;asnx:module&#34; embedded=&#34;true&#34;/&gt;
           &lt;element ref=&#34;xs:schema&#34; embedded=&#34;true&#34;/&gt;
           &lt;element ref=&#34;rng:grammar&#34; embedded=&#34;true&#34;/&gt;
          &lt;/choice&gt;
         &lt;/namedType&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The identifier of a NamedType subject to an ELEMENT-REF encoding instruction does not contribute to the name of an element in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the local name of the referenced element declaration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受ELEMENT-REF编码指令约束的NamedType的标识符不会对RXER编码中的元素名称起作用。为保持一致性，标识符应尽可能与被引用元素声明的本地名称相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. The LIST Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 列表编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LIST encoding instruction causes an RXER encoder to encode a value of a SEQUENCE OF type as a white-space-separated list of the component values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表编码指令使RXER编码器将类型序列的值编码为以空格分隔的组件值列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a LIST encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ListInstruction ::= &#34;LIST&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ListInstruction ::= &#34;LIST&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in an EncodingPrefixedType for a LIST encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
列表编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a BuiltinType that is a SequenceOfType of the &#34;SEQUENCE OF NamedType&#34; form, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 一种内置类型，它是“NamedType序列”表单的SequenceOfType，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a ConstrainedType that is a TypeWithConstraint of the &#34;SEQUENCE Constraint OF NamedType&#34; form or &#34;SEQUENCE SizeConstraint OF NamedType&#34; form, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 是“NamedType的序列约束”形式或“NamedType的序列大小约束”形式的TypeWithConstraint的ConstrainedType，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（5）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（5）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型为（1）到（5）之一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The effect of this condition is to force the LIST encoding instruction to be textually co-located with the SequenceOfType or TypeWithConstraint to which it applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此条件的效果是强制列表编码指令与应用该指令的SequenceOfType或TypeWithConstraint在文本上共存。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: This makes it clear to a reader that the encoding instruction applies to every use of the type no matter how it might be referenced.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：这向读者清楚地表明，编码指令适用于类型的每一次使用，无论它如何被引用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SequenceOfType in case (1) and the TypeWithConstraint in case (2) are said to be &#34;subject to&#34; the LIST encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
案例（1）中的类型序列和案例（2）中的类型WithConstraint被称为“服从”列表编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A SequenceOfType or TypeWithConstraint SHALL NOT be subject to more than one LIST encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型序列或带有约束的类型不得受一个以上列表编码指令的约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base type of the component type of a SequenceOfType or TypeWithConstraint that is subject to a LIST encoding instruction MUST be one of the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受列表编码指令约束的SequenceOfType或TypeWithConstraint的组件类型的基类型必须是以下类型之一：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) the BOOLEAN, INTEGER, ENUMERATED, REAL, OBJECT IDENTIFIER, RELATIVE-OID, GeneralizedTime, or UTCTime type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 布尔、整数、枚举、实数、对象标识符、相对OID、泛化时间或UTCTime类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) the NCName, AnyURI, Name, or QName type from the AdditionalBasicDefinitions module [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) AdditionalBasicDefinitions模块[RXER]中的NCName、AnyURI、Name或QName类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: While it would be feasible to allow the component type to also be any character string type that is constrained such that all its abstract values have a length greater than zero and none of its abstract values contain any white space characters, testing whether this condition is satisfied can be quite involved. For the sake of simplicity, only certain immediately useful constrained UTF8String types, which are known to be suitable, are permitted (i.e., NCName, AnyURI, and Name).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：虽然允许组件类型也是任何字符串类型都是可行的，但它的所有抽象值的长度都大于零，并且它的抽象值都不包含任何空白字符，测试是否满足此条件可能会非常复杂。为了简单起见，只允许某些已知适合的立即有用的受约束UTF8String类型（即NCName、AnyURI和Name）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NamedType in a SequenceOfType or TypeWithConstraint that is subject to a LIST encoding instruction MUST NOT be subject to an ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, or TYPE-AS-VERSION encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SequenceOfType或TypeWithConstraint中受列表编码指令约束的NamedType不能受属性、属性-REF、组件-REF、组、元素-REF、引用为元素、简单内容或类型为版本编码指令的约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      UpdateTimes ::= [LIST] SEQUENCE OF updateTime GeneralizedTime
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      UpdateTimes ::= [LIST] SEQUENCE OF updateTime GeneralizedTime
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. The NAME Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 名称编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NAME encoding instruction causes an RXER encoder to use a nominated character string instead of a component&#39;s identifier wherever that identifier would otherwise appear in the encoding (e.g., as an element or attribute name).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名称编码指令使RXER编码器使用指定的字符串，而不是组件的标识符，否则该标识符将出现在编码中（例如，作为元素或属性名称）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a NAME encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名称编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NameInstruction ::= &#34;NAME&#34; &#34;AS&#34;? NCNameValue
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NameInstruction ::= &#34;NAME&#34; &#34;AS&#34;? NCNameValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          foo-att   [ATTRIBUTE] [NAME AS &#34;Foo&#34;] INTEGER,
          foo-elem  [NAME &#34;Foo&#34;] INTEGER
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          foo-att   [ATTRIBUTE] [NAME AS &#34;Foo&#34;] INTEGER,
          foo-elem  [NAME &#34;Foo&#34;] INTEGER
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. The REF-AS-ELEMENT Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. REF-AS-ELEMENT编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REF-AS-ELEMENT encoding instruction causes an RXER encoder to encode a value of the component to which it is applied as an element where the element&#39;s name is the name of the external DTD subset element type declaration referenced by the encoding instruction. In addition, the REF-AS-ELEMENT encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the content and attributes permitted by that element type declaration and its associated attribute-list declarations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REF-AS-ELEMENT编码指令使RXER编码器将其应用到的组件的值编码为元素，其中元素的名称是编码指令引用的外部DTD子集元素类型声明的名称。此外，REF-AS-ELEMENT编码指令会限制标记ASN.1类型的值，以符合该元素类型声明及其关联属性列表声明所允许的内容和属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a REF-AS-ELEMENT encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REF-AS-ELEMENT编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RefAsElementInstruction ::=
          &#34;REF-AS-ELEMENT&#34; NameValue Namespace ? RefParameters
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RefAsElementInstruction ::=
          &#34;REF-AS-ELEMENT&#34; NameValue Namespace ? RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Namespace ::= &#34;NAMESPACE&#34; AnyURIValue
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Namespace ::= &#34;NAMESPACE&#34; AnyURIValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taken together, the NameValue and the ContextParameter in the RefParameters (if present) MUST reference an element type declaration in an external DTD subset that is conformant with Namespaces in XML 1.0 [XMLNS10].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总之，RefParameters（如果存在）中的NameValue和ContextParameter必须引用外部DTD子集中的元素类型声明，该子集符合XML 1.0[XMLNS10]中的名称空间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Namespace is present if and only if the Name of the referenced element type declaration conforms to a PrefixedName (a QName) [XMLNS10], in which case the Namespace specifies the namespace name to be associated with the Prefix of the PrefixedName.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当且仅当引用的元素类型声明的名称符合PrefixedName（QName）[XMLNS10]时，才存在名称空间，在这种情况下，名称空间指定要与PrefixedName的前缀关联的名称空间名称。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The referenced element type declaration MUST NOT require the presence of attributes of type ENTITY or ENTITIES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引用的元素类型声明不得要求存在一个或多个实体类型的属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：CRXER不支持实体声明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Suppose that the following external DTD subset has been defined with a system identifier of &#34;http://www.example.com/inventory&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
假设以下外部DTD子集已定义为系统标识符“http://www.example.com/inventory&#34;:
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;?xml version=&#39;1.0&#39;?&gt;
         &lt;!ELEMENT product EMPTY&gt;
         &lt;!ATTLIST product
             name       CDATA #IMPLIED
             partNumber CDATA #REQUIRED
             quantity   CDATA #REQUIRED &gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;?xml version=&#39;1.0&#39;?&gt;
         &lt;!ELEMENT product EMPTY&gt;
         &lt;!ATTLIST product
             name       CDATA #IMPLIED
             partNumber CDATA #REQUIRED
             quantity   CDATA #REQUIRED &gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The product element type declaration can be referenced as an element in an ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
产品元素类型声明可以作为ASN.1类型定义中的元素引用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         CHOICE {
             product  [REF-AS-ELEMENT &#34;product&#34;
                          CONTEXT &#34;http://www.example.com/inventory&#34;]
                      Markup
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         CHOICE {
             product  [REF-AS-ELEMENT &#34;product&#34;
                          CONTEXT &#34;http://www.example.com/inventory&#34;]
                      Markup
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Here is the ASN.X translation of this ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下是此ASN.1类型定义的ASN.X翻译：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;type&gt;
          &lt;choice&gt;
           &lt;element elementType=&#34;product&#34;
                    context=&#34;http://www.example.com/inventory&#34;/&gt;
          &lt;/choice&gt;
         &lt;/type&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;type&gt;
          &lt;choice&gt;
           &lt;element elementType=&#34;product&#34;
                    context=&#34;http://www.example.com/inventory&#34;/&gt;
          &lt;/choice&gt;
         &lt;/type&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The identifier of a NamedType subject to a REF-AS-ELEMENT encoding instruction does not contribute to the name of an element in an RXER encoding. For the sake of consistency, the identifier SHOULD, where possible, be the same as the Name of the referenced element type declaration (or the LocalPart if the Name conforms to a PrefixedName).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受REF-AS-ELEMENT编码指令约束的NamedType的标识符不影响RXER编码中的元素名称。为保持一致性，标识符应尽可能与引用的元素类型声明的名称相同（如果名称符合前缀名称，则与LocalPart相同）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. The REF-AS-TYPE Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. REF-AS-TYPE编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The REF-AS-TYPE encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to the content and attributes permitted by a nominated element type declaration and its associated attribute-list declarations in an external DTD subset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REF-AS-TYPE编码指令使标记ASN.1类型的值受到限制，以符合外部DTD子集中指定元素类型声明及其关联属性列表声明所允许的内容和属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a REF-AS-TYPE encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REF-AS-TYPE编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RefAsTypeInstruction ::= &#34;REF-AS-TYPE&#34; NameValue RefParameters
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RefAsTypeInstruction ::= &#34;REF-AS-TYPE&#34; NameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taken together, the NameValue and the ContextParameter of the RefParameters (if present) MUST reference an element type declaration in an external DTD subset that is conformant with Namespaces in XML 1.0 [XMLNS10].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总之，RefParameters（如果存在）的NameValue和ContextParameter必须引用外部DTD子集中的元素类型声明，该子集符合XML 1.0[XMLNS10]中的名称空间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The referenced element type declaration MUST NOT require the presence of attributes of type ENTITY or ENTITIES.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引用的元素类型声明不得要求存在一个或多个实体类型的属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：CRXER不支持实体声明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The product element type declaration can be referenced as a type in an ASN.1 definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
产品元素类型声明可以作为ASN.1定义中的类型引用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SEQUENCE OF inventoryItem [REF-AS-TYPE &#34;product&#34; CONTEXT &#34;http://www.example.com/inventory&#34;] Markup
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
库存项目的顺序[REF-AS-TYPE“产品”上下文”http://www.example.com/inventory“]标记
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Here is the ASN.X translation of this definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下是该定义的ASN.X翻译：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;sequenceOf&gt;
          &lt;element name=&#34;inventoryItem&#34;&gt;
           &lt;type elementType=&#34;product&#34;
                 context=&#34;http://www.example.com/inventory&#34;/&gt;
          &lt;/element&gt;
         &lt;/sequenceOf&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;sequenceOf&gt;
          &lt;element name=&#34;inventoryItem&#34;&gt;
           &lt;type elementType=&#34;product&#34;
                 context=&#34;http://www.example.com/inventory&#34;/&gt;
          &lt;/element&gt;
         &lt;/sequenceOf&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that when an element type declaration is referenced as a type, the Name of the element type declaration does not contribute to RXER encodings. For example, child elements in the RXER encoding of values of the above SEQUENCE OF type would resemble the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
请注意，当元素类型声明被引用为类型时，元素类型声明的名称不会影响RXER编码。例如，上述类型序列值的RXER编码中的子元素类似于以下内容：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;inventoryItem name=&#34;hammer&#34; partNumber=&#34;1543&#34; quantity=&#34;29&#34;/&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;inventoryItem name=&#34;hammer&#34; partNumber=&#34;1543&#34; quantity=&#34;29&#34;/&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. The SCHEMA-IDENTITY Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. SCHEMA-IDENTITY编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SCHEMA-IDENTITY encoding instruction associates a unique identifier, a URI [URI], with the ASN.1 module containing the encoding instruction. This encoding instruction has no effect on an RXER encoder but does have an effect on the translation of an ASN.1 specification into an ASN.X representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SCHEMA-IDENTITY编码指令将唯一标识符URI[URI]与包含编码指令的ASN.1模块相关联。此编码指令对RXER编码器没有影响，但对ASN.1规范转换为ASN.X表示有影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a SCHEMA-IDENTITY encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
模式标识编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SchemaIdentityInstruction ::= &#34;SCHEMA-IDENTITY&#34; AnyURIValue
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SchemaIdentityInstruction ::= &#34;SCHEMA-IDENTITY&#34; AnyURIValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The character string specified by the AnyURIValue of each SCHEMA-IDENTITY encoding instruction MUST be distinct. In particular, successive versions of an ASN.1 module must each have a different schema identity URI value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个SCHEMA-IDENTITY编码指令的AnyURIValue指定的字符串必须是不同的。特别是，ASN.1模块的后续版本必须具有不同的模式标识URI值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. The SIMPLE-CONTENT Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
17. 简单内容编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SIMPLE-CONTENT encoding instruction causes an RXER encoder to encode a value of a component of a SEQUENCE or SET type without encapsulation in a child element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
简单内容编码指令使RXER编码器对序列或集合类型的组件的值进行编码，而不封装在子元素中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a SIMPLE-CONTENT encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
简单内容编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SimpleContentInstruction ::= &#34;SIMPLE-CONTENT&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SimpleContentInstruction ::= &#34;SIMPLE-CONTENT&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A NamedType subject to a SIMPLE-CONTENT encoding instruction SHALL be in a ComponentType in a ComponentTypeList in a RootComponentTypeList. At most one such NamedType of a SEQUENCE or SET type is permitted to be subject to a SIMPLE-CONTENT encoding instruction. If any component is subject to a SIMPLE-CONTENT encoding instruction, then all other components in the same SEQUENCE or SET type definition MUST be attribute components. These tests are applied after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受简单内容编码指令约束的命名类型应位于根ComponentTypeList中ComponentTypeList中的ComponentType中。序列或集合类型中最多允许有一个这样的NamedType接受简单内容编码指令。如果任何组件受简单内容编码指令的约束，则相同序列或集合类型定义中的所有其他组件都必须是属性组件。这些试验在X.680第24.4条[X.680]中规定的转换组件之后进行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Child elements and simple content are mutually exclusive. Specification writers should note that use of the SIMPLE-CONTENT encoding instruction on a component of an extensible SEQUENCE or SET type means that all future extensions to the SEQUENCE or SET type are restricted to being attribute components with the limited set of types that are permitted for attribute components. Using an ATTRIBUTE encoding instruction instead of a SIMPLE-CONTENT encoding instruction avoids this limitation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：子元素和简单内容是相互排斥的。规范编写者应该注意，在可扩展序列或集合类型的组件上使用简单内容编码指令意味着序列或集合类型的所有未来扩展都被限制为具有属性组件所允许的有限类型集的属性组件。使用属性编码指令而不是简单内容编码指令可以避免此限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base type of the type of a NamedType that is subject to a SIMPLE-CONTENT encoding instruction SHALL NOT be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受简单内容编码指令约束的NamedType类型的基本类型不得为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a SET or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 一套或一套类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a CHOICE type where the ChoiceType is not subject to a UNION encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 选择类型不受联合编码指令约束的选择类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 序列类型，而不是从AdditionalBasicDefinitions模块[RXER]定义QName类型的序列类型（即，允许使用QName），或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 一种类型序列，其中SequenceOfType不受列表编码指令的约束，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) an open type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) 开放式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the type of a NamedType subject to a SIMPLE-CONTENT encoding instruction has abstract values with an empty character data translation [RXER] (i.e., an empty encoding), then the NamedType SHALL NOT be marked OPTIONAL or DEFAULT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果受简单内容编码指令约束的NamedType类型具有空字符数据转换[RXER]（即空编码）的抽象值，则NamedType不应标记为可选或默认。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          units   [ATTRIBUTE] UTF8String,
          amount  [SIMPLE-CONTENT] INTEGER
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          units   [ATTRIBUTE] UTF8String,
          amount  [SIMPLE-CONTENT] INTEGER
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. The TARGET-NAMESPACE Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
18. 目标命名空间编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TARGET-NAMESPACE encoding instruction associates an XML namespace name [XMLNS10], a URI [URI], with the type, object class, value, object, and object set references defined in the ASN.1 module containing the encoding instruction. In addition, it associates the namespace name with each top-level NamedType in the RXER encoding control section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TARGET-NAMESPACE编码指令将XML命名空间名称[XMLNS10]、URI[URI]与包含编码指令的ASN.1模块中定义的类型、对象类、值、对象和对象集引用相关联。此外，它将名称空间名称与RXER编码控制部分中的每个顶级NamedType相关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a TARGET-NAMESPACE encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目标命名空间编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TargetNamespaceInstruction ::=
          &#34;TARGET-NAMESPACE&#34; AnyURIValue Prefix ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TargetNamespaceInstruction ::=
          &#34;TARGET-NAMESPACE&#34; AnyURIValue Prefix ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Prefix ::= &#34;PREFIX&#34; NCNameValue
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Prefix ::= &#34;PREFIX&#34; NCNameValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The AnyURIValue SHALL NOT specify an empty string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AnyURIValue不应指定空字符串。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (target namespace): If an ASN.1 module contains a TARGET-NAMESPACE encoding instruction, then the target namespace of the module is the character string specified by the AnyURIValue of the TARGET-NAMESPACE encoding instruction; otherwise, the target namespace of the module is said to be absent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（目标名称空间）：如果ASN.1模块包含目标名称空间编码指令，则模块的目标名称空间是由目标名称空间编码指令的AnyURIValue指定的字符串；否则，称模块的目标命名空间不存在。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two or more ASN.1 modules MAY have the same non-absent target namespace if and only if the expanded names of the top-level attribute components are distinct across all those modules, the expanded names of the top-level element components are distinct across all those modules, and the defined type, object class, value, object, and object set references are distinct in their category across all those modules.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
两个或多个ASN.1模块可能具有相同的非缺失目标命名空间，当且仅当顶级属性组件的扩展名称在所有这些模块中是不同的，顶级元素组件的扩展名称在所有这些模块中是不同的，并且定义的类型、对象类、值、对象、，对象集引用在所有这些模块中的类别是不同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Prefix, if present, suggests an NCName to use as the namespace prefix in namespace declarations involving the target namespace. An RXER encoder is not obligated to use the nominated namespace prefix.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前缀（如果存在）建议在涉及目标命名空间的命名空间声明中使用NCName作为命名空间前缀。RXER编码器没有义务使用指定的名称空间前缀。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If there are no top-level components, then the RXER encodings produced using a module with a TARGET-NAMESPACE encoding instruction are backward compatible with the RXER encodings produced by the same module without the TARGET-NAMESPACE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果没有顶级组件，则使用带有目标命名空间编码指令的模块生成的RXER编码与不带目标命名空间编码指令的相同模块生成的RXER编码向后兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. The TYPE-AS-VERSION Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
19. TYPE-AS-VERSION编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TYPE-AS-VERSION encoding instruction causes an RXER encoder to include an xsi:type attribute in the encoding of a value of the component to which the encoding instruction is applied. This attribute allows an XML Schema [XSD1] validator to select, if available, the appropriate XML Schema translation for the version of the ASN.1 specification used to create the encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TYPE-AS-VERSION编码指令使RXER编码器在对应用编码指令的组件的值进行编码时包含xsi:TYPE属性。此属性允许XMLSchema[XSD1]验证器为用于创建编码的ASN.1规范版本选择适当的XML模式转换（如果可用）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Translations of an ASN.1 specification into a compatible XML Schema are expected to be slightly different across versions because of progressive extensions to the ASN.1 specification. Any incompatibilities between these translations can be accommodated if each version uses a different target namespace. The target namespace will be evident in the value of the xsi:type attribute and will cause an XML Schema validator to use the appropriate version. This mechanism also accommodates an ASN.1 type that is renamed in a later version of the ASN.1 specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：ASN.1规范到兼容的XML模式的转换在不同版本之间预计会略有不同，因为ASN.1规范的渐进扩展。如果每个版本使用不同的目标名称空间，则可以解决这些翻译之间的任何不兼容问题。目标名称空间将在xsi:type属性的值中显示，并将导致XML模式验证器使用适当的版本。该机制还支持在ASN.1规范的更高版本中重命名的ASN.1类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a TYPE-AS-VERSION encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TYPE-AS-VERSION编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TypeAsVersionInstruction ::= &#34;TYPE-AS-VERSION&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TypeAsVersionInstruction ::= &#34;TYPE-AS-VERSION&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in a NamedType that is subject to a TYPE-AS-VERSION encoding instruction MUST be a namespace-qualified reference [RXER].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NamedType中服从“类型为版本”编码指令的类型必须是命名空间限定引用[RXER]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The addition of a TYPE-AS-VERSION encoding instruction does not affect the backward compatibility of RXER encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
添加类型转换编码指令不会影响RXER编码的向后兼容性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: In a translation of an ASN.1 specification into XML Schema, any Type in a NamedType that is subject to a TYPE-AS-VERSION encoding instruction is expected to be translated into the XML Schema anyType so that the xsi:type attribute acts as a switch to select the appropriate version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：在将ASN.1规范转换为XML模式时，NamedType中受Type-AS-VERSION编码指令约束的任何类型都应转换为XML模式anyType，以便xsi:Type属性充当选择适当版本的开关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. The TYPE-REF Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
20. TYPE-REF编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TYPE-REF encoding instruction causes values of the Markup ASN.1 type to be restricted to conform to a specific XML Schema named type, RELAX NG named pattern or an ASN.1 defined type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TYPE-REF编码指令导致标记ASN.1类型的值被限制为符合名为TYPE、RELAX-NG-named-pattern或ASN.1定义类型的特定XML模式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Referencing an ASN.1 type in a TYPE-REF encoding instruction does not have the effect of imposing a requirement to preserve the Infoset [INFOSET] representation of the RXER encoding of an abstract value of the type. It is still sufficient to preserve just the abstract value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：在type-REF编码指令中引用ASN.1类型不会产生强制要求保留该类型抽象值的RXER编码的Infoset[Infoset]表示的效果。仅保留抽象值就足够了。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a TYPE-REF encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TYPE-REF编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TypeRefInstruction ::= &#34;TYPE-REF&#34; QNameValue RefParameters
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      TypeRefInstruction ::= &#34;TYPE-REF&#34; QNameValue RefParameters
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Taken together, the QNameValue and the ContextParameter of the RefParameters (if present) MUST reference an XML Schema named type, a RELAX NG named pattern, or an ASN.1 defined type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总之，RefParameters的QNameValue和ContextParameter（如果存在）必须引用名为type的XML模式、名为RELAXNG的模式或ASN.1定义的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A referenced XML Schema type MUST NOT require the presence of values for the XML Schema ENTITY or ENTITIES types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引用的XML架构类型不得要求存在XML架构实体或实体类型的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Entity declarations are not supported by CRXER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：CRXER不支持实体声明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The QNameValue SHALL NOT be a direct reference to the XML Schema NOTATION type [XSD2] (i.e., the namespace name &#34;http://www.w3.org/2001/XMLSchema&#34; and local name &#34;NOTATION&#34;); however, a reference to an XML Schema type derived from the NOTATION type is permitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
QNameValue不能直接引用XML模式表示法类型[XSD2]（即名称空间名称）http://www.w3.org/2001/XMLSchema“和本地名称”符号）；但是，允许引用从标记类型派生的XML模式类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: This restriction is to ensure that the lexical space [XSD2] of the referenced type is actually populated with the names of notations [XSD1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：此限制是为了确保引用类型的词法空间[XSD2]实际上填充了符号[XSD1]的名称。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyDecimal ::=
          [TYPE-REF {
              namespace-name &#34;http://www.w3.org/2001/XMLSchema&#34;,
              local-name     &#34;decimal&#34; }]
          Markup
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyDecimal ::=
          [TYPE-REF {
              namespace-name &#34;http://www.w3.org/2001/XMLSchema&#34;,
              local-name     &#34;decimal&#34; }]
          Markup
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that the ASN.X translation of this ASN.1 type definition provides a more natural way to reference the XML Schema decimal type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
请注意，此ASN.1类型定义的ASN.X转换提供了一种更自然的方式来引用XML模式十进制类型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;namedType xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34;
                    name=&#34;MyDecimal&#34;&gt;
          &lt;type ref=&#34;xs:decimal&#34; embedded=&#34;true&#34;/&gt;
         &lt;/namedType&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         &lt;namedType xmlns:xs=&#34;http://www.w3.org/2001/XMLSchema&#34;
                    name=&#34;MyDecimal&#34;&gt;
          &lt;type ref=&#34;xs:decimal&#34; embedded=&#34;true&#34;/&gt;
         &lt;/namedType&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. The UNION Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
21. 联合编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UNION encoding instruction causes an RXER encoder to encode the value of an alternative of a CHOICE type without encapsulation in a child element. The chosen alternative is optionally indicated with a member attribute. The optional PrecedenceList also allows a specification writer to alter the order in which an RXER decoder will consider the alternatives of the CHOICE as it determines which alternative has been used (if the actual alternative has not been specified through the member attribute).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNION encoding指令使RXER编码器对选择类型的替代值进行编码，而不封装在子元素中。所选备选方案可选地用成员属性表示。可选的优先权也允许规范写入器改变RXER解码器将考虑选择的替代品的顺序，因为它决定了使用了哪个替代品（如果实际的替代品没有通过成员属性指定）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a UNION encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
联合编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      UnionInstruction ::= &#34;UNION&#34; AlternativesPrecedence ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      UnionInstruction ::= &#34;UNION&#34; AlternativesPrecedence ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AlternativesPrecedence ::= &#34;PRECEDENCE&#34; PrecedenceList
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AlternativesPrecedence ::= &#34;PRECEDENCE&#34; PrecedenceList
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      PrecedenceList ::= identifier PrecedenceList ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      PrecedenceList ::= identifier PrecedenceList ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the EncodingPrefixedType for a UNION encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
联合编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a BuiltinType that is a ChoiceType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 选择类型的内置类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（4）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (4), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（4）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) PrefixedType的内置类型，该类型是EncodingPrefixedType，其中EncodingPrefixedType中的类型是（1）到（4）之一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ChoiceType in case (1) is said to be &#34;subject to&#34; the UNION encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
案例（1）中的ChoiceType被称为“服从”联合编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base type of the type of each alternative of a ChoiceType that is subject to a UNION encoding instruction SHALL NOT be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受联合编码指令约束的ChoiceType的每个备选类型的基本类型不得为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a CHOICE, SET, or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 类型的选择、集合或集合，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a SEQUENCE type other than the one defining the QName type from the AdditionalBasicDefinitions module [RXER] (i.e., QName is allowed), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 序列类型，而不是从AdditionalBasicDefinitions模块[RXER]定义QName类型的序列类型（即，允许使用QName），或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 一种类型序列，其中SequenceOfType不受列表编码指令的约束，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) an open type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 开放式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each identifier in the PrecedenceList MUST be the identifier of a NamedType in the ChoiceType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PrecenceList中的每个标识符都必须是ChoiceType中NamedType的标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A particular identifier SHALL NOT appear more than once in the same PrecedenceList.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特定标识符在同一优先列表中不得出现多次。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every NamedType in a ChoiceType that is subject to a UNION encoding instruction MUST NOT be subject to an ATTRIBUTE, ATTRIBUTE-REF, COMPONENT-REF, GROUP, ELEMENT-REF, REF-AS-ELEMENT, SIMPLE-CONTENT, or TYPE-AS-VERSION encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ChoiceType中受联合编码指令约束的每个NamedType不得受属性、属性-REF、组件-REF、组、元素-REF、REF-AS-ELEMENT、简单内容或类型-AS-VERSION编码指令约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [UNION PRECEDENCE basicName] CHOICE {
          extendedName  UTF8String,
          basicName     PrintableString
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [UNION PRECEDENCE basicName] CHOICE {
          extendedName  UTF8String,
          basicName     PrintableString
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. The VALUES Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
22. 值编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The VALUES encoding instruction causes an RXER encoder to use nominated names instead of the identifiers that would otherwise appear in the encoding of a value of a BIT STRING, ENUMERATED, or INTEGER type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VALUES encoding指令使RXER编码器使用指定名称，而不是在编码位字符串、枚举或整数类型的值时出现的标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a VALUES encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ValuesInstruction ::=
          &#34;VALUES&#34; AllValuesMapped ? ValueMappingList ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ValuesInstruction ::=
          &#34;VALUES&#34; AllValuesMapped ? ValueMappingList ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AllValuesMapped ::= AllCapitalized | AllUppercased
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AllValuesMapped ::= AllCapitalized | AllUppercased
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AllCapitalized ::= &#34;ALL&#34; &#34;CAPITALIZED&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AllCapitalized ::= &#34;ALL&#34; &#34;CAPITALIZED&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AllUppercased ::= &#34;ALL&#34; &#34;UPPERCASED&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      AllUppercased ::= &#34;ALL&#34; &#34;UPPERCASED&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ValueMappingList ::= ValueMapping ValueMappingList ?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ValueMappingList ::= ValueMapping ValueMappingList ?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ValueMapping ::= &#34;,&#34; identifier &#34;AS&#34; NCNameValue
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      ValueMapping ::= &#34;,&#34; identifier &#34;AS&#34; NCNameValue
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the EncodingPrefixedType for a VALUES encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a BuiltinType that is a BitStringType with a NamedBitList, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 一种内置类型，它是具有NamedBitList的BitStringType，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a BuiltinType that is an EnumeratedType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) EnumeratedType的内置类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a BuiltinType that is an IntegerType with a NamedNumberList, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 一种内置类型，它是名为Number List的IntegerType，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (6), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（6）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (6), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（6）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) PrefixedType的内置类型，该类型是EncodingPrefixedType，其中EncodingPrefixedType中的类型是（1）到（6）之一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The effect of this condition is to force the VALUES encoding instruction to be textually co-located with the type definition to which it applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此条件的效果是强制值编码指令在文本上与其应用的类型定义位于同一位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The BitStringType, EnumeratedType, or IntegerType in case (1), (2), or (3), respectively, is said to be &#34;subject to&#34; the VALUES encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第（1）、（2）或（3）种情况下，BitStringType、EnumeratedType或IntegerType分别被称为“服从”值编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A BitStringType, EnumeratedType, or IntegerType SHALL NOT be subject to more than one VALUES encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
BitStringType、EnumeratedType或IntegerType不得接受多个值编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each identifier in a ValueMapping MUST be an identifier appearing in the NamedBitList, Enumerations, or NamedNumberList, as the case may be.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ValueMapping中的每个标识符都必须是出现在NamedBitList、Enumerations或NamedNumber列表中的标识符（视情况而定）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The identifier in a ValueMapping SHALL NOT be the same as the identifier in any other ValueMapping for the same ValueMappingList.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ValueMappingList的ValueMapping中的标识符不得与任何其他ValueMapping中的标识符相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (replacement name): Each identifier in a BitStringType, EnumeratedType, or IntegerType subject to a VALUES encoding instruction has a replacement name. If there is a ValueMapping for the identifier, then the replacement name is the character string specified by the NCNameValue in the ValueMapping; else if AllCapitalized is used, then the replacement name is the identifier with the first character uppercased; else if AllUppercased is used, then the replacement name is the identifier with all its characters uppercased; otherwise, the replacement name is the identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（替换名称）：受值编码指令约束的BitStringType、EnumeratedType或IntegerType中的每个标识符都有一个替换名称。如果标识符存在ValueMapping，则替换名称为ValueMapping中NCNameValue指定的字符串；否则，如果使用AllCapitalized，则替换名称是第一个字符大写的标识符；否则，如果使用AllUppercased，则替换名称是标识符，其所有字符都大写；否则，替换名称就是标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The replacement names for the identifiers in a BitStringType subject to a VALUES encoding instruction MUST be distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受值编码指令约束的BitStringType中标识符的替换名称必须是不同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The replacement names for the identifiers in an EnumeratedType subject to a VALUES encoding instruction MUST be distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受值编码指令约束的EnumeratedType中标识符的替换名称必须是不同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The replacement names for the identifiers in an IntegerType subject to a VALUES encoding instruction MUST be distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
服从值编码指令的IntegerType中标识符的替换名称必须是不同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Traffic-Light ::= [VALUES ALL CAPITALIZED, red AS &#34;RED&#34;]
          ENUMERATED {
              red,    -- Replacement name is RED.
              amber,  -- Replacement name is Amber.
              green   -- Replacement name is Green.
          }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Traffic-Light ::= [VALUES ALL CAPITALIZED, red AS &#34;RED&#34;]
          ENUMERATED {
              red,    -- Replacement name is RED.
              amber,  -- Replacement name is Amber.
              green   -- Replacement name is Green.
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. Insertion Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
23. 插入编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certain of the RXER encoding instructions are categorized as insertion encoding instructions. The insertion encoding instructions are the NO-INSERTIONS, HOLLOW-INSERTIONS, SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, and MULTIFORM-INSERTIONS encoding instructions (whose notations are described respectively by NoInsertionsInstruction, HollowInsertionsInstruction, SingularInsertionsInstruction, UniformInsertionsInstruction, and MultiformInsertionsInstruction).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些RXER编码指令被归类为插入编码指令。插入编码指令有无插入、空插入、单插入、均匀插入和多形式插入编码指令（其符号分别由NOINSERTIONS指令、HOLLOWINSERTIONS指令、SingularInsERTIONS指令、UniformInsERTIONS指令和MultiformInsERTIONS指令描述）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for the insertion encoding instructions is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
插入编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      InsertionsInstruction ::=
          NoInsertionsInstruction |
          HollowInsertionsInstruction |
          SingularInsertionsInstruction |
          UniformInsertionsInstruction |
          MultiformInsertionsInstruction
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      InsertionsInstruction ::=
          NoInsertionsInstruction |
          HollowInsertionsInstruction |
          SingularInsertionsInstruction |
          UniformInsertionsInstruction |
          MultiformInsertionsInstruction
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NoInsertionsInstruction ::= &#34;NO-INSERTIONS&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      NoInsertionsInstruction ::= &#34;NO-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      HollowInsertionsInstruction ::= &#34;HOLLOW-INSERTIONS&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      HollowInsertionsInstruction ::= &#34;HOLLOW-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SingularInsertionsInstruction ::= &#34;SINGULAR-INSERTIONS&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SingularInsertionsInstruction ::= &#34;SINGULAR-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      UniformInsertionsInstruction ::= &#34;UNIFORM-INSERTIONS&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      UniformInsertionsInstruction ::= &#34;UNIFORM-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MultiformInsertionsInstruction ::= &#34;MULTIFORM-INSERTIONS&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MultiformInsertionsInstruction ::= &#34;MULTIFORM-INSERTIONS&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the GROUP encoding instruction on components with extensible types can lead to situations where an unknown extension could be associated with more than one extension insertion point. The insertion encoding instructions remove this ambiguity by limiting the form that extensions can take. That is, the insertion encoding instructions indicate what extensions can be made to an ASN.1 specification without breaking forward compatibility for RXER encodings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在具有可扩展类型的组件上使用组编码指令可能会导致未知扩展可能与多个扩展插入点关联的情况。插入编码指令通过限制扩展可以采用的形式来消除这种歧义。也就是说，插入编码指令指示可以对ASN.1规范进行哪些扩展，而不会破坏RXER编码的前向兼容性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Forward compatibility means the ability for a decoder to successfully decode an encoding containing extensions introduced into a version of the specification that is more recent than the one used by the decoder.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：前向兼容性是指解码器能够成功解码包含引入规范版本的扩展的编码，该版本比解码器使用的版本更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the most general case, an extension to a CHOICE, SET, or SEQUENCE type will generate zero or more attributes and zero or more elements, due to the potential use of the GROUP and ATTRIBUTE encoding instructions by the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在最一般的情况下，由于扩展可能使用组和属性编码指令，对选项、集合或序列类型的扩展将生成零个或多个属性以及零个或多个元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MULTIFORM-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of one or more elements and zero or more attributes. No restriction is placed on the names of the elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MULTIFORM-INSERTIONS编码指令表示，由类型的前向兼容扩展生成的RXER编码将始终由一个或多个元素以及零个或多个属性组成。元素的名称没有限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Of necessity, the names of the attributes will all be different in any given encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：当然，属性的名称在任何给定的编码中都是不同的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UNIFORM-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of one or more elements having the same expanded name, and zero or more attributes. The expanded name shared by the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UNIFORM-INSERTIONS编码指令表示，由类型的前向兼容扩展生成的RXER编码将始终由一个或多个具有相同扩展名的元素以及零个或多个属性组成。用户共享的扩展名称
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
elements in one particular encoding is not required to be the same as the expanded name shared by the elements in any other encoding of the extension. For example, in one encoding of the extension the elements might all be called &#34;foo&#34;, while in another encoding of the extension they might all be called &#34;bar&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一种特定编码中的元素不需要与扩展的任何其他编码中的元素共享的扩展名相同。例如，在扩展的一种编码中，元素可能全部称为“foo”，而在扩展的另一种编码中，元素可能全部称为“bar”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SINGULAR-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of a single element and zero or more attributes. The name of the single element is not required to be the same in every possible encoding of the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SINGULAR-INSERTIONS编码指令表示由类型的前向兼容扩展生成的RXER编码将始终由单个元素和零个或多个属性组成。在扩展的每个可能编码中，单个元素的名称不必相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The HOLLOW-INSERTIONS encoding instruction indicates that the RXER encodings produced by forward-compatible extensions to a type will always consist of zero elements and zero or more attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
HOLLOW-INSERTIONS编码指令表示由类型的前向兼容扩展生成的RXER编码将始终由零个元素和零个或多个属性组成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NO-INSERTIONS encoding instruction indicates that no forward-compatible extensions can be made to a type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NO-INSERTIONS编码指令表示不能对类型进行前向兼容扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Examples of forward-compatible extensions are provided in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附录C中提供了向前兼容扩展的示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in the EncodingPrefixedType for an insertion encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
插入编码指令的EncodingPrefixedType中的类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a BuiltinType that is a ChoiceType where the ChoiceType is not subject to a UNION encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) ChoiceType不受联合编码指令约束的内置类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a BuiltinType that is a SequenceType or SetType, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) SequenceType或SetType的内置类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a ConstrainedType that is not a TypeWithConstraint where the Type in the ConstrainedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 不是TypeWithConstraint的ConstrainedType，其中ConstrainedType中的类型为（1）到（5）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) a BuiltinType that is a PrefixedType that is a TaggedType where the Type in the TaggedType is one of (1) to (5), or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 一种内置类型，其前缀类型为TaggedType，其中TaggedType中的类型为（1）到（5）之一，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) a BuiltinType that is a PrefixedType that is an EncodingPrefixedType where the Type in the EncodingPrefixedType is one of (1) to (5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) PrefixedType是EncodingPrefixedType的内置类型，其中EncodingPrefixedType中的类型为（1）到（5）之一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Case (2) is not permitted when the insertion encoding instruction is the SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, or MULTIFORM-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当插入编码指令是单数插入、均匀插入或多形式插入编码指令时，不允许出现情况（2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Because extensions to a SET or SEQUENCE type are serial and effectively optional, the SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, and MULTIFORM-INSERTIONS encoding instructions offer no advantage over unrestricted extensions (for a SET or SEQUENCE). For example, an optional series of singular insertions generates zero or more elements and zero or more attributes, just like an unrestricted extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：由于集合或序列类型的扩展是串行的，并且实际上是可选的，因此单数插入、统一插入和多形式插入编码指令与不受限制的扩展（对于集合或序列）相比没有优势。例如，一系列可选的单数插入生成零个或多个元素和零个或多个属性，就像无限制扩展一样。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in case (1) or case (2) is said to be &#34;subject to&#34; the insertion encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
情况（1）或情况（2）中的类型被称为“服从”插入编码指令。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Type in case (1) or case (2) MUST be extensible, either explicitly or by default.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
案例（1）或案例（2）中的类型必须是可扩展的，可以是显式的，也可以是默认的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A Type SHALL NOT be subject to more than one insertion encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个类型不得受多个插入编码指令的约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The insertion encoding instructions indicate what kinds of extensions can be made to a type without breaking forward compatibility, but they do not prohibit extensions that do break forward compatibility. That is, it is not an error for a type&#39;s base type to contain extensions that do not satisfy an insertion encoding instruction affecting the type. However, if any such extensions are made, then a new value SHOULD be introduced into the extensible set of permitted values for a version indicator attribute, or attributes (see Section 24), whose scope encompasses the extensions. An example is provided in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
插入编码指令指示在不破坏前向兼容性的情况下可以对类型进行哪些类型的扩展，但它们并不禁止破坏前向兼容性的扩展。也就是说，类型的基类型包含不满足影响该类型的插入编码指令的扩展不是错误。但是，如果进行了任何此类扩展，则应在版本指示器属性的可扩展允许值集中引入新值（参见第24节），其范围包括扩展。附录C中提供了一个示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24. The VERSION-INDICATOR Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
24. 版本指示符编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The VERSION-INDICATOR encoding instruction provides a mechanism for RXER decoders to be alerted that an encoding contains extensions that break forward compatibility (see the preceding section).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
VERSION-INDICATOR编码指令提供了一种机制，用于提醒RXER解码器编码包含破坏前向兼容性的扩展（请参阅上一节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a VERSION-INDICATOR encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版本指示符编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      VersionIndicatorInstruction ::= &#34;VERSION-INDICATOR&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      VersionIndicatorInstruction ::= &#34;VERSION-INDICATOR&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A NamedType that is subject to a VERSION-INDICATOR encoding instruction MUST also be subject to an ATTRIBUTE encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受版本指示符编码指令约束的NamedType也必须受属性编码指令约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type of the NamedType that is subject to the VERSION-INDICATOR encoding instruction MUST be directly or indirectly a constrained type where the set of permitted values is defined to be extensible. Each value represents a different version of the ASN.1 specification. Ordinarily, an application will set the value of a version indicator
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受版本指示符编码指令约束的NamedType的类型必须直接或间接为约束类型，其中允许的值集定义为可扩展的。每个值代表ASN.1规范的不同版本。通常，应用程序将设置版本指示符的值
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
attribute to be the last of these permitted values. An application MAY set the value of the version indicator attribute to the value corresponding to an earlier version of the specification if it has not used any of the extensions added in a subsequent version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
属性是这些允许值中的最后一个。如果应用程序没有使用在后续版本中添加的任何扩展，则可以将version indicator属性的值设置为与规范的早期版本相对应的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an RXER decoder encounters a value of the type that is not one of the root values or extension additions (but that is still allowed since the set of permitted values is extensible), then this indicates that the decoder is using a version of the ASN.1 specification that is not compatible with the version used to produce the encoding. In such cases, the decoder SHOULD treat the element containing the attribute as having an unknown ASN.1 type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果RXER解码器遇到的类型值不是根值或扩展附加值之一（但由于允许的值集是可扩展的，因此仍然允许），则这表示解码器使用的ASN.1规范版本与用于生成编码的版本不兼容。在这种情况下，解码器应将包含属性的元素视为具有未知ASN.1类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: A version indicator attribute only indicates an incompatibility with respect to RXER encodings. Other encodings are not affected because the GROUP encoding instruction does not apply to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：版本指示符属性仅表示RXER编码不兼容。其他编码不受影响，因为组编码指令不适用于它们。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Examples
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In this first example, the decoder is using an incompatible older version if the value of the version attribute in a received RXER encoding is not 1, 2, or 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在第一个示例中，如果接收到的RXER编码中的version属性的值不是1、2或3，则解码器正在使用不兼容的旧版本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             version  [ATTRIBUTE] [VERSION-INDICATOR]
                          INTEGER (1, ..., 2..3),
             message  MessageType
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             version  [ATTRIBUTE] [VERSION-INDICATOR]
                          INTEGER (1, ..., 2..3),
             message  MessageType
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In this second example, the decoder is using an incompatible older version if the value of the format attribute in a received RXER encoding is not &#34;1.0&#34;, &#34;1.1&#34;, or &#34;2.0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在第二个示例中，如果接收到的RXER编码中的format属性的值不是“1.0”、“1.1”或“2.0”，则解码器正在使用不兼容的旧版本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             format   [ATTRIBUTE] [VERSION-INDICATOR]
                          UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34; | &#34;2.0&#34;),
             message  MessageType
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             format   [ATTRIBUTE] [VERSION-INDICATOR]
                          UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34; | &#34;2.0&#34;),
             message  MessageType
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An extensive example is provided in Appendix C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
附录C中提供了一个广泛的示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is not necessary for every extensible type to have its own version indicator attribute. It would be typical for only the types of top-level element components to include a version indicator attribute, which would serve as the version indicator for all of the nested components.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
并非每个可扩展类型都有自己的版本指示符属性。典型的情况是，只有顶级元素组件的类型才包含版本指示符属性，该属性将用作所有嵌套组件的版本指示符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25. The GROUP Encoding Instruction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25. 分组编码指令
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The GROUP encoding instruction causes an RXER encoder to encode a value of the component to which it is applied without encapsulation as an element. It allows the construction of non-trivial content models for element content.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组编码指令使RXER编码器对其应用的组件的值进行编码，而不封装为元素。它允许为元素内容构建非平凡的内容模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The notation for a GROUP encoding instruction is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组编码指令的符号定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      GroupInstruction ::= &#34;GROUP&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      GroupInstruction ::= &#34;GROUP&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The base type of the type of a NamedType that is subject to a GROUP encoding instruction SHALL be either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受组编码指令约束的NamedType类型的基本类型应为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a SEQUENCE, SET, or SET OF type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 序列类型的序列、集合或集合，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a CHOICE type where the ChoiceType is not subject to a UNION encoding instruction, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 选择类型不受联合编码指令约束的选择类型，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a SEQUENCE OF type where the SequenceOfType is not subject to a LIST encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 一种类型序列，其中SequenceOfType不受列表编码指令的约束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SEQUENCE type in case (1) SHALL NOT be the associated type for a built-in type, SHALL NOT be a type from the AdditionalBasicDefinitions module [RXER], and SHALL NOT contain a component that is subject to a SIMPLE-CONTENT encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
案例（1）中的序列类型不得为内置类型的关联类型，不得为AdditionalBasicDefinitions模块[RXER]中的类型，且不得包含受简单内容编码指令约束的组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Thus, the CHARACTER STRING, EMBEDDED PDV, EXTERNAL, REAL, and QName types are excluded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：因此，不包括字符串、嵌入式PDV、外部、实数和QName类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The CHOICE type in case (2) SHALL NOT be a type from the AdditionalBasicDefinitions module.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
案例（2）中的选择类型不得为AdditionalBasicDefinitions模块中的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Thus, the Markup type is excluded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：因此，标记类型被排除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (visible component): Ignoring all type constraints, the visible components for a type that is directly or indirectly a combining ASN.1 type (i.e., SEQUENCE, SET, CHOICE, SEQUENCE OF, or SET OF) is the set of components of the combining type definition plus, for each NamedType (of the combining type definition) that is subject to a GROUP encoding instruction, the visible components for the type of the NamedType. The visible components are determined after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（可见组件）：忽略所有类型约束，直接或间接为组合ASN类型的类型的可见组件。1类型（即，序列、集合、选择、序列或集合）是组合类型定义的组件集，加上每个NamedType（组合类型定义的）它受组编码指令的约束，即NamedType类型的可见组件。可见成分在X.680第24.4条[X.680]中规定的变换成分后确定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: The set of visible attribute and element components for a type is the set of all the components of the type, and any nested types, that describe attributes and child elements appearing in the RXER encodings of values of the outer type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：类型的可见属性和元素组件集是该类型的所有组件以及任何嵌套类型的集合，这些组件描述了外部类型值的RXER编码中出现的属性和子元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A GROUP encoding instruction MUST NOT be used where it would cause a NamedType to be a visible component of the type of that same NamedType (which is only possible if the type definition is recursive).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果组编码指令会导致NamedType成为同一NamedType类型的可见组件，则不得使用该指令（仅当类型定义为递归时才可能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Components subject to a GROUP encoding instruction might be translated into a compatible XML Schema [XSD1] as group definitions. A NamedType that is visible to its own type is analogous to a circular group, which XML Schema disallows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：受组编码指令约束的组件可以作为组定义转换为兼容的XML模式[XSD1]。对自己的类型可见的NamedType类似于循环组，XML模式不允许循环组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 25.1 imposes additional conditions on the use of the GROUP encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第25.1节对组编码指令的使用施加了附加条件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any use of the GROUP encoding instruction, there is a type, the including type, that contains the component subject to the GROUP encoding instruction, and a type, the included type, that is the base type of that component. Either type can have an extensible content model, either by directly using ASN.1 extensibility or by including through another GROUP encoding instruction some other type that is extensible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在组编码指令的任何使用中，都有一个类型（包括类型）包含服从组编码指令的组件，还有一个类型（包括类型）是该组件的基本类型。这两种类型都可以有一个可扩展的内容模型，可以直接使用ASN.1可扩展性，也可以通过另一个组编码指令包含其他可扩展的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The including and included types may be defined in different ASN.1 modules, in which case the owner of the including type, i.e., the person or organization having the authority to add extensions to the including type&#39;s definition, may be different from the owner of the included type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包含类型和包含类型可以在不同的ASN.1模块中定义，在这种情况下，包含类型的所有者，即有权向包含类型的定义添加扩展的人员或组织，可能与包含类型的所有者不同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the owner of the including type is not using the most recent version of the included type&#39;s definition, then the owner of the including type might add an extension to the including type that is valid with respect to the older version of the included type, but is later found to be invalid when the latest versions of the including and included type definitions are brought together (perhaps by a third party). Although the owner of the including type must necessarily be aware of the existence of the included type, the reverse is not necessarily true. The owner of the included type could add an extension to the included type without realizing that it invalidates someone else&#39;s including type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果包含类型的所有者未使用包含类型定义的最新版本，则包含类型的所有者可能会向包含类型添加一个扩展，该扩展对包含类型的旧版本有效，但是，当include和included类型定义的最新版本汇集在一起时（可能是由第三方提供的），发现它是无效的。尽管包含类型的所有者必须知道包含类型的存在，但情况并非如此。包含类型的所有者可以向包含类型添加扩展，而不会意识到它会使其他人的包含类型无效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid these problems, a GROUP encoding instruction MUST NOT be used if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为避免这些问题，在以下情况下，不得使用组编码指令：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) the included type is defined in a different module from the including type, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 包含类型在与包含类型不同的模块中定义，并且
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) the included type has an extensible content model, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 包含的类型具有可扩展的内容模型，并且
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) changes to the included type are not coordinated with the owner of the including type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 对包含类型的更改不与包含类型的所有者协调。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Changes in the included type are coordinated with the owner of the including type if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
包括类型的变更应与包括类型的所有者协调，前提是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) the owner of the included type is also the owner of the including type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 包含类型的所有者也是包含类型的所有者，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) the owner of the including type is collaborating with the owner of the included type, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 包含类型的所有者正在与包含类型的所有者协作，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) all changes will be vetted by a common third party before being approved and published.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 在批准和发布之前，所有变更将由共同的第三方进行审查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1. Unambiguous Encodings
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1. 明确的编码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unregulated use of the GROUP encoding instruction can easily lead to specifications in which distinct abstract values have indistinguishable RXER encodings, i.e., ambiguous encodings. This section imposes restrictions on the use of the GROUP encoding instruction to ensure that distinct abstract values have distinct RXER encodings. In addition, these restrictions ensure that an abstract value can be easily decoded in a single pass without back-tracking.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不受管制地使用组编码指令很容易导致不同的抽象值具有不可区分的RXER编码的规范，即不明确的编码。本节对组编码指令的使用施加限制，以确保不同的抽象值具有不同的RXER编码。此外，这些限制确保了抽象值可以在一次传递中轻松解码，而无需回溯。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An RXER decoder for an ASN.1 type can be abstracted as a recognizer for a notional language, consisting of element and attribute expanded names, where the type definition describes the grammar for that language (in fact it is a context-free grammar). The restrictions on a type definition to ensure easy, unambiguous decoding are more conveniently, completely, and simply expressed as conditions on this associated grammar. Implementations are not expected to verify type definitions exactly in the manner to be described; however, the procedure used MUST produce the same result.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1类型的RXER解码器可以抽象为概念语言的识别器，由元素和属性扩展名组成，其中类型定义描述了该语言的语法（实际上它是一种上下文无关语法）。对类型定义的限制可以确保轻松、明确的解码，这些限制可以更方便、完整、简单地表示为该关联语法的条件。实现不希望以描述的方式准确地验证类型定义；但是，使用的程序必须产生相同的结果。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 25.1.1 describes the procedure for recasting as a grammar a type definition containing components subject to the GROUP encoding instruction. Sections 25.1.2 and 25.1.3 specify conditions that the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第25.1.1节描述了将包含受分组编码指令约束的组件的类型定义重铸为语法的过程。第25.1.2节和第25.1.3节规定了以下条件：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
grammar must satisfy for the type definition to be valid. Section 25.1.4 describes how unrecognized attributes are accepted by the grammar for an extensible type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
语法必须满足才能使类型定义有效。第25.1.4节描述了语法如何接受可扩展类型的未识别属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Appendices A and B have extensive examples.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附录A和B有大量的例子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.1. Grammar Construction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.1. 语法结构
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A grammar consists of a collection of productions.  A production has
   a left-hand side and a right-hand side (in this document, separated
   by the &#34;::=&#34; symbol).  The left-hand side (in a context-free grammar)
   is a single non-terminal symbol.  The right-hand side is a sequence
   of non-terminal and terminal symbols.  The terminal symbols are the
   lexical items of the language that the grammar describes.  One of the
   non-terminals is nominated to be the start symbol.  A valid sequence
   of terminals for the language can be generated from the grammar by
   beginning with the start symbol and repeatedly replacing any
   non-terminal with the right-hand side of one of the productions where
   that non-terminal is on the production&#39;s left-hand side.  The final
   sequence of terminals is achieved when there are no remaining
   non-terminals to replace.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A grammar consists of a collection of productions.  A production has
   a left-hand side and a right-hand side (in this document, separated
   by the &#34;::=&#34; symbol).  The left-hand side (in a context-free grammar)
   is a single non-terminal symbol.  The right-hand side is a sequence
   of non-terminal and terminal symbols.  The terminal symbols are the
   lexical items of the language that the grammar describes.  One of the
   non-terminals is nominated to be the start symbol.  A valid sequence
   of terminals for the language can be generated from the grammar by
   beginning with the start symbol and repeatedly replacing any
   non-terminal with the right-hand side of one of the productions where
   that non-terminal is on the production&#39;s left-hand side.  The final
   sequence of terminals is achieved when there are no remaining
   non-terminals to replace.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: X.680 describes the ASN.1 basic notation using a context-free grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：X.680使用上下文无关语法描述了ASN.1基本符号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each NamedType has an associated primary and secondary non-terminal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个NamedType都有一个关联的主非终结符和辅助非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: The secondary non-terminal for a NamedType is used when the base type of the type in the NamedType is a SEQUENCE OF type or SET OF type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：当NamedType中类型的基类型是类型序列或类型集时，使用NamedType的次要非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ExtensionAddition and ExtensionAdditionAlternative has an associated non-terminal. There is a non-terminal associated with the extension insertion point of each extensible type. There is also a primary start non-terminal (this is the start symbol) and a secondary start non-terminal. The exact nature of the non-terminals is not important, however all the non-terminals MUST be mutually distinct.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个ExtensionAddition和ExtensionAdditionalAlternative都有一个关联的非终端。每个可扩展类型的扩展插入点都有一个非终端。还有一个主启动非终端（这是启动符号）和一个辅助启动非终端。非端子的确切性质并不重要，但所有非端子必须相互区别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is adequate for most of the examples in this document (though not in the most general case) for the primary non-terminal for a NamedType to be the identifier of the NamedType, for the primary start non-terminal to be S, for the non-terminals for the instances of ExtensionAddition and ExtensionAdditionAlternative to be E1, E2, E3, and so on, and for the non-terminals for the extension insertion points to be I1, I2, I3, and so on. The secondary non-terminals are labelled by appending a &#34;&#39;&#34; character to the primary non-terminal label, e.g., the primary and secondary start non-terminals are S and S&#39;, respectively.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于本文档中的大多数示例（尽管不是在最一般的情况下），对于NamedType作为NamedType标识符的主要非终端，对于S作为主要起始非终端，对于E1、E2、E3等作为ExtensionAddition和ExtensionAdditionalAlternative实例的非终端，这是足够的，对于非端子，扩展插入点为I1、I2、I3等。通过在主非端子标签上附加“&#39;”字符来标记辅助非端子，例如，主和辅助启动非端子分别为S和S&#39;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Each NamedType and extension insertion point has an associated
   terminal.  There exists a terminal called the general extension
   terminal that is not associated with any specific notation.  The
   general extension terminal and the terminals for the extension
   insertion points are used to represent elements in unknown
   extensions.  The exact nature of the terminals is not important;
   however, the aforementioned terminals MUST be mutually distinct.  The
   terminals are further categorized as either element terminals or
   attribute terminals.  A terminal for a NamedType is an attribute
   terminal if its associated NamedType is an attribute component;
   otherwise, it is an element terminal.  The general extension terminal
   and the terminals for the extension insertion points are categorized
   as element terminals.
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Each NamedType and extension insertion point has an associated
   terminal.  There exists a terminal called the general extension
   terminal that is not associated with any specific notation.  The
   general extension terminal and the terminals for the extension
   insertion points are used to represent elements in unknown
   extensions.  The exact nature of the terminals is not important;
   however, the aforementioned terminals MUST be mutually distinct.  The
   terminals are further categorized as either element terminals or
   attribute terminals.  A terminal for a NamedType is an attribute
   terminal if its associated NamedType is an attribute component;
   otherwise, it is an element terminal.  The general extension terminal
   and the terminals for the extension insertion points are categorized
   as element terminals.
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Terminals for attributes in unknown extensions are not explicitly provided in the grammar. Certain productions in the grammar are categorized as insertion point productions, and their role in accepting unknown attributes is described in Section 25.1.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
语法中未明确提供未知扩展中属性的终端。语法中的某些产品被归类为插入点产品，第25.1.4节描述了它们在接受未知属性方面的作用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the examples in this document, the terminal for a component other than an attribute component will be represented as the local name of the expanded name of the component enclosed in double quotes, and the terminal for an attribute component will be represented as the local name of the expanded name of the component prefixed by the &#39;@&#39; character and enclosed in double quotes. The general extension terminal will be represented as &#34;*&#34; and the terminals for the extension insertion points will be represented as &#34;*1&#34;, &#34;*2&#34;, &#34;*3&#34;, and so on.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本文档中的示例中，属性组件以外的组件的终端将表示为双引号中包含的组件扩展名称的本地名称，属性组件的终端将表示为组件扩展名的本地名，前缀为“@”，并用双引号括起来。通用扩展终端将表示为“*”，扩展插入点的终端将表示为“*1”、“*2”、“*3”等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The productions generated from a NamedType depend on the base type of the type of the NamedType. The productions for the start non-terminals depend on the combining type definition being tested. In either case, the procedure for generating productions takes a primary non-terminal, a secondary non-terminal (sometimes), and a type definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从NamedType生成的产品取决于NamedType类型的基类型。开始非终端的产品取决于正在测试的组合类型定义。在这两种情况下，生成产品的过程都采用主非终结符、次非终结符（有时）和类型定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The grammar is constructed beginning with the start non-terminals and the combining type definition being tested.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
语法是从start非终结符和正在测试的组合类型定义开始构建的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A grammar is constructed after the COMPONENTS OF transformation specified in X.680, Clause 24.4 [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
语法是在X.680第24.4条[X.680]中规定的转换成分之后构造的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a primary non-terminal, N, and a type where the base type is a SEQUENCE or SET type, a production is added to the grammar with N as the left-hand side. The right-hand side is constructed from an initial empty state according to the following cases considered in order:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定一个主非终结符N，以及一个基类型为序列或集合类型的类型，则在语法中添加一个产生式，其中N为左侧。根据以下顺序考虑的情况，从初始空状态构造右侧：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) If an initial RootComponentTypeList is present in the base type, then the sequence of primary non-terminals for the components nested in that RootComponentTypeList are appended to the right-hand side in the order of their definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 如果基类型中存在初始的RootComponentTypeList，则嵌套在该RootComponentTypeList中的组件的主非终结符序列将按照其定义的顺序追加到右侧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) If an ExtensionAdditions instance is present in the base type and not empty, then the non-terminal for the first ExtensionAddition nested in the ExtensionAdditions instance is appended to the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 如果基类型中存在ExtensionAdditions实例且该实例不为空，则将ExtensionAdditions实例中嵌套的第一个ExtensionAddition的非终端追加到右侧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) If an ExtensionAdditions instance is empty or not present in the base type, and the base type is extensible (explicitly or by default), and the base type is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the non-terminal for the extension insertion point of the base type is appended to the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 如果ExtensionAdditions实例为空或在基类型中不存在，并且基类型是可扩展的（显式或默认），并且基类型不受NO-INSERTIONS或HOLLOWL-INSERTIONS编码指令的约束，则基类型的扩展插入点的非终端将追加到右侧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) If a final RootComponentTypeList is present in the base type, then the primary non-terminals for the components nested in that RootComponentTypeList are appended to the right-hand side in the order of their definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 如果基类型中存在最终的RootComponentTypeList，则嵌套在该RootComponentTypeList中的组件的主非终结符将按照其定义的顺序追加到右侧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The production is an insertion point production if an ExtensionAdditions instance is empty or not present in the base type, and the base type is extensible (explicitly or by default), and the base type is not subject to a NO-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果ExtensionAdditions实例为空或在基类型中不存在，并且基类型是可扩展的（显式或默认），并且基类型不受无插入编码指令的约束，则生产是插入点生产。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a component in a ComponentTypeList (in either a RootComponentTypeList or an ExtensionAdditionGroup) is marked OPTIONAL or DEFAULT, then a production with the primary non-terminal of the component as the left-hand side and an empty right-hand side is added to the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果ComponentTypeList（在RootComponentTypeList或ExtensionAdditionGroup中）中的某个组件被标记为可选或默认，则会将该组件的主要非末端作为左侧，右侧为空的产品添加到语法中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a component (regardless of the ASN.1 combining type containing it) is subject to a GROUP encoding instruction, then one or more productions constructed according to the component&#39;s type are added to the grammar. Each of these productions has the primary non-terminal of the component as the left-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果一个组件（不管包含它的ASN.1组合类型如何）受组编码指令的约束，那么根据该组件的类型构造的一个或多个产品将添加到语法中。每个产品的左侧都有组件的主要非末端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a component (regardless of the ASN.1 combining type containing it) is not subject to a GROUP encoding instruction, then a production is added to the grammar with the primary non-terminal of the component as the left-hand side and the terminal of the component as the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果一个组件（不管包含它的ASN.1组合类型如何）不受组编码指令的约束，则会将一个产生式添加到语法中，将该组件的主要非终端作为左侧，将该组件的终端作为右侧。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
考虑下面的ASN . 1类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             -- Start of initial RootComponentTypeList.
             one    [ATTRIBUTE] UTF8String,
             two    BOOLEAN OPTIONAL,
             three  INTEGER
             -- End of initial RootComponentTypeList.
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             -- Start of initial RootComponentTypeList.
             one    [ATTRIBUTE] UTF8String,
             two    BOOLEAN OPTIONAL,
             three  INTEGER
             -- End of initial RootComponentTypeList.
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下是从该类型派生的语法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one two three
         one ::= &#34;@one&#34;
         two ::= &#34;two&#34;
         two ::=
         three ::= &#34;three&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one two three
         one ::= &#34;@one&#34;
         two ::= &#34;two&#34;
         two ::=
         three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each ExtensionAddition (of a SEQUENCE or SET base type), a production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAddition and the right-hand side is initially empty. If the ExtensionAddition is a ComponentType, then the primary non-terminal for the NamedType in the ComponentType is appended to the right-hand side; otherwise (an ExtensionAdditionGroup), the sequence of primary non-terminals for the components nested in the ComponentTypeList in the ExtensionAdditionGroup are appended to the right-hand side in the order of their definition. If the ExtensionAddition is followed by another ExtensionAddition, then the non-terminal for the next ExtensionAddition is appended to the right-hand side; otherwise, if the base type is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the non-terminal for the extension insertion point of the base type is appended to the right-hand side. If the ExtensionAddition is not followed by another ExtensionAddition and the base type is not subject to a NO-INSERTIONS encoding instruction, then the production is an insertion point production. If the empty sequence of terminals cannot be generated from the production (it may be necessary to wait until the grammar is otherwise complete before making this determination), then another production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAddition and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个ExtensionAddition（序列或集合基类型），将向语法中添加一个产品，其中左侧是ExtensionAddition的非终端，右侧最初为空。如果ExtensionAddition是ComponentType，则ComponentType中NamedType的主非终结符将追加到右侧；否则（ExtensionAdditionGroup），嵌套在ExtensionAdditionGroup中ComponentTypeList中的组件的主非端子序列将按照其定义顺序追加到右侧。如果ExtensionAddition后面紧跟着另一个ExtensionAddition，则下一个ExtensionAddition的非终端将附加到右侧；否则，如果基类型不受无插入或空插入编码指令的约束，则基类型的扩展插入点的非端子被附加到右侧。如果ExtensionAddition后面没有另一个ExtensionAddition，并且基类型不受NO-INSERTIONS编码指令的约束，则生成是插入点生成。如果不能从生产中生成终端的空序列（可能需要等到语法完成后再进行此确定），则将另一个生产添加到语法中，其中左侧为扩展添加的非终端，右侧为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: An extension is always effectively optional since a sender may be using an earlier version of the ASN.1 specification where none, or only some, of the extensions have been defined.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：扩展始终是有效的可选的，因为发送方可能正在使用ASN.1规范的早期版本，其中未定义或仅定义了部分扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: The grammar generated for ExtensionAdditions is structured to take account of the condition that an extension can only be used if all the earlier extensions are also used [X.680].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：为ExtensionAdditions生成的语法在结构上考虑了一个条件，即只有在同时使用所有早期扩展时才能使用扩展[X.680]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a SEQUENCE or SET base type is extensible (explicitly or by default) and is not subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果序列或集合基类型是可扩展的（显式或默认），并且不受无插入或空插入编码指令的约束，则：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 向语法中添加了一个结果，其中左侧是基类型的扩展插入点的非端子，右侧是通用扩展端子，后面是扩展插入点的非端子，以及
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 一个结果被添加到语法中，其中左侧是扩展插入点的非端点，右侧为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
考虑下面的ASN . 1类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             -- Start of initial RootComponentTypeList.
             one    BOOLEAN,
             two    INTEGER OPTIONAL,
             -- End of initial RootComponentTypeList.
             ...,
             -- Start of ExtensionAdditions.
             four  INTEGER,  -- First ExtensionAddition (E1).
             five  BOOLEAN OPTIONAL,  -- Second ExtensionAddition (E2).
             [[ -- An ExtensionAdditionGroup.
                 six    UTF8String,
                 seven  INTEGER OPTIONAL
             ]], -- Third ExtensionAddition (E3).
             -- End of ExtensionAdditions.
             -- The extension insertion point is here (I1).
             ...,
             -- Start of final RootComponentTypeList.
             three  INTEGER
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         SEQUENCE {
             -- Start of initial RootComponentTypeList.
             one    BOOLEAN,
             two    INTEGER OPTIONAL,
             -- End of initial RootComponentTypeList.
             ...,
             -- Start of ExtensionAdditions.
             four  INTEGER,  -- First ExtensionAddition (E1).
             five  BOOLEAN OPTIONAL,  -- Second ExtensionAddition (E2).
             [[ -- An ExtensionAdditionGroup.
                 six    UTF8String,
                 seven  INTEGER OPTIONAL
             ]], -- Third ExtensionAddition (E3).
             -- End of ExtensionAdditions.
             -- The extension insertion point is here (I1).
             ...,
             -- Start of final RootComponentTypeList.
             three  INTEGER
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下是从该类型派生的语法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one two E1 three
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one two E1 three
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E1 ::= four E2
         E1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E1 ::= four E2
         E1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E2 ::= five E3
         E3 ::= six seven I1
         E3 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E2 ::= five E3
         E3 ::= six seven I1
         E3 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         two ::= &#34;two&#34;
         two ::=
         three ::= &#34;three&#34;
         four ::= &#34;four&#34;
         five ::= &#34;five&#34;
         five ::=
         six ::= &#34;six&#34;
         seven ::= &#34;seven&#34;
         seven ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         two ::= &#34;two&#34;
         two ::=
         three ::= &#34;three&#34;
         four ::= &#34;four&#34;
         five ::= &#34;five&#34;
         five ::=
         six ::= &#34;six&#34;
         seven ::= &#34;seven&#34;
         seven ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the SEQUENCE type were subject to a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction, then the productions for I1 would not appear, and the first production for E3 would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果序列类型服从无插入或空插入编码指令，则I1的产品将不会出现，E3的第一个产品将是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E3 ::= six seven
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E3 ::= six seven
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a primary non-terminal, N, and a type where the base type is a CHOICE type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定一个主非端子N和一个类型，其中基类型为选择类型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) A production is added to the grammar for each NamedType nested in the RootAlternativeTypeList of the base type, where the left-hand side is N and the right-hand side is the primary non-terminal for the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 对于嵌套在基类型的RootAlternativeTypeList中的每个NamedType，将在语法中添加一个产品，其中左侧为N，右侧为NamedType的主要非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) A production is added to the grammar for each ExtensionAdditionAlternative of the base type, where the left-hand side is N and the right-hand side is the non-terminal for the ExtensionAdditionAlternative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 为基类型的每个ExtensionAdditionalAlternative向语法中添加一个结果，其中左侧为N，右侧为ExtensionAdditionalAlternative的非终端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) If the base type is extensible (explicitly or by default) and the base type is not subject to an insertion encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 如果基类型是可扩展的（显式或默认），并且基类型不受插入编码指令的约束，则：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) A production is added to the grammar where the left-hand side is N and the right-hand side is the non-terminal for the extension insertion point of the base type. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) 生成式被添加到语法中，其中左侧为N，右侧为基类型的扩展插入点的非端点。此产品是插入点产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) 将生成项添加到语法中，其中左侧是基类型的扩展插入点的非端子，右侧是通用扩展端子，后面是扩展插入点的非端子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) 将向语法中添加一个结果，其中左侧是基类型的扩展插入点的非端点，右侧为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) If the base type is subject to a HOLLOW-INSERTIONS encoding instruction, then a production is added to the grammar where the left-hand side is N and the right-hand side is empty. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(4) 如果基类型受空插入编码指令的约束，则会向语法中添加一个结果，其中左侧为N，右侧为空。此产品是插入点产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) If the base type is subject to a SINGULAR-INSERTIONS encoding instruction, then a production is added to the grammar where the left-hand side is N and the right-hand side is the general extension terminal. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(5) 如果基类型服从单数插入编码指令，则向语法中添加一个产生式，其中左侧为N，右侧为通用扩展终端。此产品是插入点产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) If the base type is subject to a UNIFORM-INSERTIONS encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(6) 如果基类型受统一插入编码指令的约束，则：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) A production is added to the grammar where the left-hand side is N and the right-hand side is the general extension terminal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) 生成式被添加到语法中，其中左侧为N，右侧为通用扩展终端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
Aside: This production is used to verify the correctness of an ASN.1 type definition, but would not be used in the implementation of an RXER decoder. The next production takes precedence over it for accepting an unknown element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-14">
旁白：此产品用于验证ASN.1类型定义的正确性，但不会用于RXER解码器的实现。下一个产品优先于它接受未知元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) A production is added to the grammar where the left-hand side is N and the right-hand side is the terminal for the extension insertion point of the base type followed by the non-terminal for the extension insertion point. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) 生成式被添加到语法中，其中左侧是N，右侧是基类型的扩展插入点的端子，后面是扩展插入点的非端子。此产品是插入点产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the terminal for the extension insertion point followed by the non-terminal for the extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) 将生成项添加到语法中，其中左侧是基类型的扩展插入点的非端子，右侧是扩展插入点的端子，后面是扩展插入点的非端子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(d) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(d) 将向语法中添加一个结果，其中左侧是基类型的扩展插入点的非端点，右侧为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) If the base type is subject to a MULTIFORM-INSERTIONS encoding instruction, then:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(7) 如果基类型受多种形式插入编码指令的约束，则：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) A production is added to the grammar where the left-hand side is N and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point of the base type. This production is an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(a) 生成式被添加到语法中，其中左侧是N，右侧是通用扩展终端，后面是基类型的扩展插入点的非终端。此产品是插入点产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is the general extension terminal followed by the non-terminal for the extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(b) 将生成项添加到语法中，其中左侧是基类型的扩展插入点的非端子，右侧是通用扩展端子，后面是扩展插入点的非端子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) A production is added to the grammar where the left-hand side is the non-terminal for the extension insertion point of the base type and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(c) 将向语法中添加一个结果，其中左侧是基类型的扩展插入点的非端点，右侧为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an ExtensionAdditionAlternative is a NamedType, then a production is added to the grammar where the left-hand side is the non-terminal for the ExtensionAdditionAlternative and the right-hand side is the primary non-terminal for the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果extensionAdditionalAlternative是NamedType，则会向语法中添加一个结果，其中左侧是extensionAdditionalAlternative的非终结符，右侧是NamedType的主要非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an ExtensionAdditionAlternative is an ExtensionAdditionAlternativesGroup, then a production is added to the grammar for each NamedType nested in the ExtensionAdditionAlternativesGroup, where the left-hand side is the non-terminal for the ExtensionAdditionAlternative and the right-hand side is the primary non-terminal for the NamedType.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果extensionAdditionalAlternative是extensionAdditionalAlternativeGroup，则会向extensionAdditionalAlternativeGroup中嵌套的每个NamedType的语法中添加一个结果，其中左侧是extensionAdditionalAlternative的非终结符，右侧是NamedType的主要非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
考虑下面的ASN . 1类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         CHOICE {
             -- Start of RootAlternativeTypeList.
             one    BOOLEAN,
             two    INTEGER,
             -- End of RootAlternativeTypeList.
             ...,
             -- Start of ExtensionAdditionAlternatives.
             three  INTEGER, -- First ExtensionAdditionAlternative (E1).
             [[ -- An ExtensionAdditionAlternativesGroup.
                 four  UTF8String,
                 five  INTEGER
             ]] -- Second ExtensionAdditionAlternative (E2).
             -- The extension insertion point is here (I1).
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         CHOICE {
             -- Start of RootAlternativeTypeList.
             one    BOOLEAN,
             two    INTEGER,
             -- End of RootAlternativeTypeList.
             ...,
             -- Start of ExtensionAdditionAlternatives.
             three  INTEGER, -- First ExtensionAdditionAlternative (E1).
             [[ -- An ExtensionAdditionAlternativesGroup.
                 four  UTF8String,
                 five  INTEGER
             ]] -- Second ExtensionAdditionAlternative (E2).
             -- The extension insertion point is here (I1).
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下是从该类型派生的语法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one
         S ::= two
         S ::= E1
         S ::= E2
         S ::= I1
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one
         S ::= two
         S ::= E1
         S ::= E2
         S ::= I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E1 ::= three
         E2 ::= four
         E2 ::= five
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         E1 ::= three
         E2 ::= four
         E2 ::= five
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         two ::= &#34;two&#34;
         three ::= &#34;three&#34;
         four ::= &#34;four&#34;
         five ::= &#34;five&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         two ::= &#34;two&#34;
         three ::= &#34;three&#34;
         four ::= &#34;four&#34;
         five ::= &#34;five&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the CHOICE type were subject to a NO-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be removed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果选择类型受无插入编码指令的约束，则第五、第六和第七个产品将被删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the CHOICE type were subject to a HOLLOW-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果选择类型受空插入编码指令的约束，则第五、第六和第七个产品将替换为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the CHOICE type were subject to a SINGULAR-INSERTIONS encoding instruction, then the fifth, sixth, and seventh productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果选择类型服从单数插入编码指令，则第五、第六和第七个产品将替换为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= &#34;*&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= &#34;*&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the CHOICE type were subject to a UNIFORM-INSERTIONS encoding instruction, then the fifth and sixth productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果选择类型服从统一插入编码指令，则第五和第六个产品将替换为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= &#34;*&#34;
         S ::= &#34;*1&#34; I1
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= &#34;*&#34;
         S ::= &#34;*1&#34; I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*1&#34; I1
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*1&#34; I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the CHOICE type were subject to a MULTIFORM-INSERTIONS encoding instruction, then the fifth production would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果选择类型受多种形式插入编码指令的约束，则第五个产品将替换为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= &#34;*&#34; I1
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= &#34;*&#34; I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constraints on a SEQUENCE, SET, or CHOICE type are ignored. They do not affect the grammar being generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
忽略序列、集合或选择类型上的约束。它们不会影响正在生成的语法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: This avoids an awkward situation where values of a subtype have to be decoded differently from values of the parent type. It also simplifies the verification procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：这避免了一种尴尬的情况，即子类型的值必须与父类型的值进行不同的解码。它还简化了验证程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a primary non-terminal, N, and a type that has a SEQUENCE OF or SET OF base type and that permits a value of size zero (i.e., an empty sequence or set):
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定一个主非端子N和一个具有基类型序列或基类型集且允许大小为零的类型（即，空序列或基类型集）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 将产品添加到语法中，其中产品的左侧为N，右侧为基类型序列或基类型集的组件的NamedType的主要非终结符，后跟N，以及
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 一个产品被添加到语法中，其中产品的左侧为N，右侧为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Given a primary non-terminal, N, a secondary non-terminal, N&#39;, and a type that has a SEQUENCE OF or SET OF base type and that does not permit a value of size zero:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
给定主非端子N、次非端子N’，以及具有基类型序列或基类型集且不允许大小为零的类型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) a production is added to the grammar where the left-hand side of the production is N and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N&#39;, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 对于产生式类型，N是一个非产生式类型，N后面是一个非产生式类型，N后面是非产生式类型的基
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) a production is added to the grammar where the left-hand side of the production is N&#39; and the right-hand side is the primary non-terminal for the NamedType of the component of the SEQUENCE OF or SET OF base type, followed by N&#39;, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 将产品添加到语法中，其中产品的左侧为N&#39;，右侧为基类型序列或基类型集组件的NamedType的主要非终端，后跟N&#39;，和
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a production is added to the grammar where the left-hand side of the production is N&#39; and the right-hand side is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 将一个产品添加到语法中，其中产品的左侧为N&#39;，右侧为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Consider the following ASN.1 type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
考虑下面的ASN . 1类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
SEQUENCE SIZE(1..MAX) OF number INTEGER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
整数的序列大小（1..MAX）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Here is the grammar derived from this type:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下是从该类型派生的语法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= number S&#39;
         S&#39; ::= number S&#39;
         S&#39; ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= number S&#39;
         S&#39; ::= number S&#39;
         S&#39; ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         number ::= &#34;number&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All inner subtyping (InnerTypeContraints) is ignored for the purposes of deciding whether a value of size zero is permitted by a SEQUENCE OF or SET OF type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了决定类型序列或类型集是否允许大小为零的值，将忽略所有内部子类型（InnerTypeContracts）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This completes the description of the transformation of ASN.1 combining type definitions into a grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这就完成了ASN.1将类型定义组合到语法中的转换描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.2. Unique Component Attribution
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.2. 唯一组件属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes conditions that the grammar must satisfy so that each element and attribute in a received RXER encoding can be uniquely associated with an ASN.1 component definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节描述语法必须满足的条件，以便接收到的RXER编码中的每个元素和属性都可以与ASN.1组件定义唯一关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (used by the grammar): A non-terminal, N, is used by the grammar if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（语法使用）：语法使用非终结符N，如果：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) N is the start symbol or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) N是开始符号或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) N appears on the right-hand side of a production where the non-terminal on the left-hand side is used by the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) N出现在产品的右侧，语法使用左侧的非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (multiple derivation paths): A non-terminal, N, has multiple derivation paths if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（多个派生路径）：非终端N具有多个派生路径，如果：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) N appears on the right-hand side of a production where the non-terminal on the left-hand side has multiple derivation paths, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) N出现在产品的右侧，其中左侧的非终端具有多个派生路径，或者
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) N appears on the right-hand side of more than one production where the non-terminal on the left-hand side is used by the grammar, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) N出现在多个产品的右侧，其中语法使用左侧的非终结符，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) N is the start symbol and it appears on the right-hand side of a production where the non-terminal on the left-hand side is used by the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) N是开始符号，它出现在产品的右侧，语法使用左侧的非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For every ASN.1 type with a base type containing components that are subject to a GROUP encoding instruction, the grammar derived by the method described in this document MUST NOT have:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个ASN.1类型，其基类型包含受组编码指令约束的组件，通过本文档中描述的方法派生的语法不得具有：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) two or more primary non-terminals that are used by the grammar and are associated with element components having the same expanded name, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 语法使用的两个或多个主非终结符，它们与具有相同扩展名的元素组件关联，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) two or more primary non-terminals that are used by the grammar and are associated with attribute components having the same expanded name, or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 语法使用的两个或多个主非终结符，它们与具有相同扩展名的属性组件关联，或
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) a primary non-terminal that has multiple derivation paths and is associated with an attribute component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(3) 具有多个派生路径并与属性组件关联的主非终端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: Case (1) is in response to component referencing notations that are evaluated with respect to the XML encoding of an abstract value. Case (1) guarantees, without having to do extensive testing (which would necessarily have to take account of encoding instructions for all other encoding rules), that all sibling elements with the same expanded name will be associated with equivalent type definitions. Such equivalence allows a component referenced by element name to be re-encoded using a different set of ASN.1 encoding rules without ambiguity as to which type definition and encoding instructions apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：案例（1）是对组件引用符号的响应，这些符号是根据抽象值的XML编码进行评估的。案例（1）保证，在不必进行大量测试（必须考虑所有其他编码规则的编码指令）的情况下，具有相同扩展名的所有同级元素都将与等效类型定义相关联。这种等价性允许使用一组不同的ASN.1编码规则对元素名引用的组件进行重新编码，而不会对应用的类型定义和编码指令产生歧义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Cases (2) and (3) ensure that an attribute name is always uniquely associated with one component that can occur at most once and is always nested in the same part of an abstract value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
案例（2）和（3）确保属性名始终与最多出现一次的组件唯一关联，并且始终嵌套在抽象值的同一部分中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The following example types illustrate various uses and misuses of the GROUP encoding instruction with respect to unique component attribution:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
以下示例类型说明了组编码指令在唯一组件属性方面的各种使用和误用：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA ::= SEQUENCE {
             a  [GROUP] TB,
             b  [GROUP] CHOICE {
                 a  [GROUP] TB,
                 b  [NAME AS &#34;c&#34;] [ATTRIBUTE] INTEGER,
                 c  INTEGER,
                 d  TB,
                 e  [GROUP] TD,
                 f  [ATTRIBUTE] UTF8String
             },
             c  [ATTRIBUTE] INTEGER,
             d  [GROUP] SEQUENCE OF
                 a [GROUP] SEQUENCE {
                     a  [ATTRIBUTE] OBJECT IDENTIFIER,
                     b  INTEGER
                 },
             e  [NAME AS &#34;c&#34;] INTEGER,
             COMPONENTS OF TD
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA ::= SEQUENCE {
             a  [GROUP] TB,
             b  [GROUP] CHOICE {
                 a  [GROUP] TB,
                 b  [NAME AS &#34;c&#34;] [ATTRIBUTE] INTEGER,
                 c  INTEGER,
                 d  TB,
                 e  [GROUP] TD,
                 f  [ATTRIBUTE] UTF8String
             },
             c  [ATTRIBUTE] INTEGER,
             d  [GROUP] SEQUENCE OF
                 a [GROUP] SEQUENCE {
                     a  [ATTRIBUTE] OBJECT IDENTIFIER,
                     b  INTEGER
                 },
             e  [NAME AS &#34;c&#34;] INTEGER,
             COMPONENTS OF TD
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TB ::= SEQUENCE {
             a  INTEGER,
             b  [ATTRIBUTE] BOOLEAN,
             COMPONENTS OF TC
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TB ::= SEQUENCE {
             a  INTEGER,
             b  [ATTRIBUTE] BOOLEAN,
             COMPONENTS OF TC
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TC ::= SEQUENCE {
             f  OBJECT IDENTIFIER
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TC ::= SEQUENCE {
             f  OBJECT IDENTIFIER
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TD ::= SEQUENCE {
             g  OBJECT IDENTIFIER
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TD ::= SEQUENCE {
             g  OBJECT IDENTIFIER
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The grammar for TA is constructed after performing the COMPONENTS OF transformation. The result of this transformation is shown next. This example will depart from the usual convention of using just the identifier of a NamedType to represent the primary non-terminal for that NamedType. A label relative to the outermost type will be used instead to better illustrate unique component attribution. The labels used for the non-terminals are shown down the right-hand side.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
TA的语法是在执行转换组件之后构建的。下面显示此转换的结果。本例将偏离通常的惯例，即仅使用NamedType的标识符来表示该NamedType的主要非终端。将使用相对于最外层类型的标签来更好地说明唯一组件属性。用于非端子的标签显示在右侧下方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA ::= SEQUENCE {
             a  [GROUP] TB,                             -- TA.a
             b  [GROUP] CHOICE {                        -- TA.b
                 a  [GROUP] TB,                         -- TA.b.a
                 b  [NAME AS &#34;c&#34;] [ATTRIBUTE] INTEGER,  -- TA.b.b
                 c  INTEGER,                            -- TA.b.c
                 d  TB,                                 -- TA.b.d
                 e  [GROUP] TD,                         -- TA.b.e
                 f  [ATTRIBUTE] UTF8String              -- TA.b.f
             },
             c  [ATTRIBUTE] INTEGER,                    -- TA.c
             d  [GROUP] SEQUENCE OF                     -- TA.d
                 a [GROUP] SEQUENCE {                   -- TA.d.a
                     a  [ATTRIBUTE] OBJECT IDENTIFIER,  -- TA.d.a.a
                     b  INTEGER                         -- TA.d.a.b
                 },
             e  [NAME AS &#34;c&#34;] INTEGER,                  -- TA.e
             g  OBJECT IDENTIFIER                       -- TA.g
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA ::= SEQUENCE {
             a  [GROUP] TB,                             -- TA.a
             b  [GROUP] CHOICE {                        -- TA.b
                 a  [GROUP] TB,                         -- TA.b.a
                 b  [NAME AS &#34;c&#34;] [ATTRIBUTE] INTEGER,  -- TA.b.b
                 c  INTEGER,                            -- TA.b.c
                 d  TB,                                 -- TA.b.d
                 e  [GROUP] TD,                         -- TA.b.e
                 f  [ATTRIBUTE] UTF8String              -- TA.b.f
             },
             c  [ATTRIBUTE] INTEGER,                    -- TA.c
             d  [GROUP] SEQUENCE OF                     -- TA.d
                 a [GROUP] SEQUENCE {                   -- TA.d.a
                     a  [ATTRIBUTE] OBJECT IDENTIFIER,  -- TA.d.a.a
                     b  INTEGER                         -- TA.d.a.b
                 },
             e  [NAME AS &#34;c&#34;] INTEGER,                  -- TA.e
             g  OBJECT IDENTIFIER                       -- TA.g
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TB ::= SEQUENCE {
             a  INTEGER,                                -- TB.a
             b  [ATTRIBUTE] BOOLEAN,                    -- TB.b
             f  OBJECT IDENTIFIER                       -- TB.f
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TB ::= SEQUENCE {
             a  INTEGER,                                -- TB.a
             b  [ATTRIBUTE] BOOLEAN,                    -- TB.b
             f  OBJECT IDENTIFIER                       -- TB.f
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
-- Type TC is no longer of interest. --
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
--类型TC不再感兴趣--
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TD ::= SEQUENCE {
             g  OBJECT IDENTIFIER                       -- TD.g
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TD ::= SEQUENCE {
             g  OBJECT IDENTIFIER                       -- TD.g
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= TA.a TA.b TA.c TA.d TA.e TA.g
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= TA.a TA.b TA.c TA.d TA.e TA.g
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.a ::= TB.a TB.b TB.f
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.a ::= TB.a TB.b TB.f
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TB.a ::= &#34;a&#34;
         TB.b ::= &#34;@b&#34;
         TB.f ::= &#34;f&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TB.a ::= &#34;a&#34;
         TB.b ::= &#34;@b&#34;
         TB.f ::= &#34;f&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.b ::= TA.b.a
         TA.b ::= TA.b.b
         TA.b ::= TA.b.c
         TA.b ::= TA.b.d
         TA.b ::= TA.b.e
         TA.b ::= TA.b.f
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.b ::= TA.b.a
         TA.b ::= TA.b.b
         TA.b ::= TA.b.c
         TA.b ::= TA.b.d
         TA.b ::= TA.b.e
         TA.b ::= TA.b.f
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.b.a ::= TB.a TB.b TB.f
         TA.b.b ::= &#34;@c&#34;
         TA.b.c ::= &#34;c&#34;
         TA.b.d ::= &#34;d&#34;
         TA.b.e ::= TD.g
         TA.b.f ::= &#34;@f&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.b.a ::= TB.a TB.b TB.f
         TA.b.b ::= &#34;@c&#34;
         TA.b.c ::= &#34;c&#34;
         TA.b.d ::= &#34;d&#34;
         TA.b.e ::= TD.g
         TA.b.f ::= &#34;@f&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TD.g ::= &#34;g&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TD.g ::= &#34;g&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.c ::= &#34;@c&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.c ::= &#34;@c&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.d ::= TA.d.a TA.d
         TA.d ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.d ::= TA.d.a TA.d
         TA.d ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.d.a ::= TA.d.a.a TA.d.a.b
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.d.a ::= TA.d.a.a TA.d.a.b
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.d.a.a := &#34;@a&#34;
         TA.d.a.b ::= &#34;b&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.d.a.a := &#34;@a&#34;
         TA.d.a.b ::= &#34;b&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.e ::= &#34;c&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.e ::= &#34;c&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.g ::= &#34;g&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         TA.g ::= &#34;g&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
All the non-terminals are used by the grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
语法使用所有非终结符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The type definition for TA is invalid because there are two instances where two or more primary non-terminals are associated with element components having the same expanded name:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
TA的类型定义无效，因为存在两个实例，其中两个或多个主非端子与具有相同扩展名的元素组件相关联：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) TA.b.c and TA.e (both generate the terminal &#34;c&#34;), and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(1) TA.b.c和TA.e（均生成终端“c”），以及
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) TD.g and TA.g (both generate the terminal &#34;g&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
(2) TD.g和TA.g（都生成终端“g”）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
In case (2), TD.g and TA.g are derived from the same instance of NamedType notation, but become distinct components following the COMPONENTS OF transformation. AUTOMATIC tagging is applied after the COMPONENTS OF transformation, which means that the types of the components corresponding to TD.g and TA.g will end up with different tags, and therefore the types will not be equivalent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在案例（2）中，TD.g和TA.g是从NamedType表示法的同一个实例派生的，但在转换组件之后成为不同的组件。在转换的组件之后应用自动标记，这意味着与TD.g和TA.g相对应的组件类型将以不同的标记结束，因此类型将不相等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The type definition for TA is also invalid because there is one instance where two or more primary non-terminals are associated with attribute components having the same expanded name: TA.b.b and TA.c (both generate the terminal &#34;@c&#34;).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
TA的类型定义也无效，因为存在一个实例，其中两个或多个主要非终端与具有相同扩展名的属性组件关联：TA.b.b和TA.c（两者都生成终端“@c”）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The non-terminals with multiple derivation paths are: TA.d, TA.d.a, TA.d.a.a, TA.d.a.b, TB.a, TB.b, and TB.f. The type definition for TA is also invalid because TA.d.a.a and TB.b are primary non-terminals that are associated with an attribute component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
具有多个派生路径的非终端有：TA.d、TA.d.a、TA.d.a.a、TA.d.a.b、TB.a、TB.b和TB.f。TA的类型定义也无效，因为TA.d.a.a和TB.b是与属性组件关联的主要非终端。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.3. Deterministic Grammars
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.3. 确定性语法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the First Set of a production P, denoted First(P), be the set of all element terminals T where T is the first element terminal in a sequence of terminals that can be generated from the right-hand side of P. There can be any number of leading attribute terminals before T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设生产P的第一组，表示为第一（P），是所有元素端子T的集合，其中T是从P的右侧生成的端子序列中的第一个元素端子。T之前可以有任意数量的前导属性端子。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the Follow Set of a non-terminal N, denoted Follow(N), be the set of all element terminals T where T is the first element terminal following N in a sequence of non-terminals and terminals that can be generated from the grammar. There can be any number of attribute terminals between N and T. If a sequence of non-terminals and terminals can be generated from the grammar where N is not followed by any element terminals, then Follow(N) also contains a special end terminal, denoted by &#34;$&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
设非端子N的跟随集，表示为跟随（N），是所有元素端子T的集合，其中T是非端子和端子序列中N之后的第一个元素端子，可以从语法生成。在N和T之间可以有任意数量的属性终端。如果可以从语法生成非终端和终端的序列，其中N后面没有任何元素终端，那么Follow（N）还包含一个特殊的终端，用“$”表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: If N does not appear on the right-hand side of any production, then Follow(N) will be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：如果N没有出现在任何产品的右侧，则Follow（N）将为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a production P, let the predicate Empty(P) be true if and only if the empty sequence of terminals can be generated from P. Otherwise, Empty(P) is false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于生产P，当且仅当终端的空序列可以从P生成时，让谓词Empty（P）为true。否则，Empty（P）为false。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Definition (base grammar): The base grammar is a rewriting of the grammar in which the non-terminals for every ExtensionAddition and ExtensionAdditionAlternative are removed from the right-hand side of all productions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义（基本语法）：基本语法是对语法的重写，其中每个ExtensionAddition和ExtensionAdditionalAlternative的非终结符都从所有产品的右侧删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a production P, let the predicate Preselected(P) be true if and only if every sequence of terminals that can be generated from the right-hand side of P using only the base grammar contains at least one attribute terminal. Otherwise, Preselected(P) is false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于产品P，当且仅当仅使用基本语法从P的右侧生成的每个端子序列至少包含一个属性端子时，才让谓词预选（P）为真。否则，预选（P）为假。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Select Set of a production P, denoted Select(P), is empty if Preselected(P) is true; otherwise, it contains First(P). Let N be the non-terminal on the left-hand side of P. If Empty(P) is true, then Select(P) also contains Follow(N).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果预选（P）为真，则表示为Select（P）的生产P的选择集为空；否则，它包含第一个（P）。设N为P左侧的非端子。如果为空（P），则选择（P）也包含Follow（N）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: It may appear somewhat dubious to include the attribute components in the grammar because, in reality, attributes appear unordered within the start tag of an element, and not interspersed with the child elements as the grammar would suggest. This is why attribute terminals are ignored in composing the First Sets and Follow Sets. However, the attribute terminals are important in composing the Select Sets because they can preselect a production and can prevent a production from being able to generate an empty sequence of terminals. In real terms, this corresponds to an RXER decoder using the attributes to determine the presence or absence of optional components and to select between the alternatives of a CHOICE, even before considering the child elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：在语法中包含属性组件似乎有点可疑，因为事实上，属性在元素的开始标记中看起来是无序的，而不是像语法所建议的那样散布在子元素中。这就是为什么在组成第一组和后续组时忽略属性端子的原因。但是，属性端子在组成选择集时很重要，因为它们可以预先选择产品，并可以防止产品生成空的端子序列。实际上，这相当于RXER解码器使用属性来确定可选组件的存在或不存在，并在选择的备选方案之间进行选择，甚至在考虑子元素之前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
An attribute appearing in an extension isn&#39;t used to preselect a production since, in general, a decoder using an earlier version of the specification would not be able to associate the attribute with any particular extension insertion point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
扩展中出现的属性不用于预选产品，因为通常情况下，使用早期版本规范的解码器无法将该属性与任何特定扩展插入点关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Let the Reach Set of a non-terminal N, denoted Reach(N), be the set of all element terminals T where T appears in a sequence of terminals that can be generated from N.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
设非端子N的到达集，表示为到达（N），是所有元件端子T的集合，其中T出现在可由N生成的端子序列中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: It can be readily shown that all the optional attribute components and all but one of the mandatory attribute components of a SEQUENCE or SET type can be ignored in constructing the grammar because their omission does not alter the First, Follow, Select, or Reach Sets, or the evaluation of the Preselected and Empty predicates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：可以很容易地证明，在构造语法时，可以忽略序列或集合类型的所有可选属性组件和除一个之外的所有必需属性组件，因为它们的省略不会改变第一个、跟随、选择或到达集合，也不会改变预选和空谓词的计算。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A grammar is deterministic (for the purposes of an RXER decoder) if and only if:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
语法是确定性的（对于RXER解码器而言），当且仅当：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) there do not exist two productions P and Q, with the same non-terminal on the left-hand side, where the intersection of Select(P) and Select(Q) is not empty, and
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 不存在两个产品P和Q，在左侧具有相同的非端子，其中Select（P）和Select（Q）的交点不为空，并且
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) there does not exist a non-terminal E for an ExtensionAddition or ExtensionAdditionAlternative where the intersection of Reach(E) and Follow(E) is not empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 当到达（E）和跟随（E）的交点不为空时，不存在扩展加法或扩展加法替代的非终端E。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: In case (1), if the intersection is not empty, then a decoder would have two or more possible ways to attempt to decode the input into an abstract value. In case (2), if the intersection is not empty, then a decoder using an earlier version of the ASN.1 specification would confuse an element in an unknown (to that decoder) extension with a known component following the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：在案例（1）中，如果交集不是空的，那么解码器将有两种或两种以上可能的方法尝试将输入解码为抽象值。在案例（2）中，如果交集不是空的，那么使用ASN.1规范早期版本的解码器会将未知（该解码器）扩展中的元素与扩展后的已知组件混淆。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: In the absence of any attribute components, case (1) is the test for an LL(1) grammar.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：在没有任何属性组件的情况下，case（1）是对LL（1）语法的测试。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For every ASN.1 type with a base type containing components that are subject to a GROUP encoding instruction, the grammar derived by the method described in this document MUST be deterministic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个ASN.1类型，其基类型包含受组编码指令约束的组件，由本文档中描述的方法派生的语法必须是确定性的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.4. Attributes in Unknown Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
25.1.4. 未知扩展中的属性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An insertion point production is able to accept unknown attributes if the non-terminal on the left-hand side of the production does not have multiple derivation paths.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果产品左侧的非终端没有多个派生路径，则插入点产品能够接受未知属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Aside: If the non-terminal has multiple derivation paths, then any future extension cannot possibly contain an attribute component because that would violate the requirements of Section 25.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
旁白：如果非终端具有多个派生路径，则任何未来扩展都不可能包含属性组件，因为这将违反第25.1.2节的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a deterministic grammar, there is only one possible way to construct a sequence of element terminals matching the element content of an element in a correctly formed RXER encoding. Any unknown attributes of the element are accepted if at least one insertion point production that is able to accept unknown attributes is used in that construction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于确定性语法，只有一种可能的方法来构造元素终端序列，该序列与正确格式的RXER编码中元素的元素内容相匹配。如果在该构造中使用了至少一个能够接受未知属性的插入点产品，则接受该元素的任何未知属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Example
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
考虑这种类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         CHOICE {
             one  UTF8String,
             two  [GROUP] SEQUENCE {
                  three  INTEGER,
                  ...
             }
         }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         CHOICE {
             one  UTF8String,
             two  [GROUP] SEQUENCE {
                  three  INTEGER,
                  ...
             }
         }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one
         S ::= two
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         S ::= one
         S ::= two
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         two ::= three I1
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         two ::= three I1
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         I1 ::= &#34;*&#34; I1
         I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         three ::= &#34;three&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         one ::= &#34;one&#34;
         three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The third production is an insertion point production, and it is able to accept unknown attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
第三个产品是插入点产品，它能够接受未知属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
When decoding a value of this type, if the element content contains a &lt;one&gt; child element, then any unrecognized attribute would be illegal as the insertion point production would not be used to recognize the input (the &#34;one&#34; alternative does not admit an extension insertion point). If the element content contains a &lt;three&gt; element, then an unrecognized attribute would be accepted because the insertion point production would be used to recognize the input (the &#34;two&#34; alternative that generates the &lt;three&gt; element has an extensible type).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
解码此类型的值时，如果元素内容包含&lt;一&gt;子元素，则任何无法识别的属性都将是非法的，因为插入点产品将不用于识别输入（“一”选项不允许扩展插入点）。如果元素内容包含&lt;three&gt;元素，则将接受无法识别的属性，因为插入点产品将用于识别输入（生成&lt;three&gt;元素的“两个”备选方案具有可扩展类型）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the SEQUENCE type were prefixed by a NO-INSERTIONS encoding instruction, then the third, fourth, and fifth productions would be replaced by:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果序列类型的前缀为无插入编码指令，则第三、第四和第五个结果将替换为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         two ::= three
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         two ::= three
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
With this change, any unrecognized attribute would be illegal for the &#34;two&#34; alternative also, since the replacement production is not an insertion point production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
通过此更改，任何无法识别的属性对于“两个”备选方案也是非法的，因为替换产品不是插入点产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If more than one insertion point production that is able to accept unknown attributes is used in constructing a matching sequence of element terminals, then a decoder is free to associate an unrecognized attribute with any one of the extension insertion points corresponding to those insertion point productions. The justification for doing so comes from the following two observations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在构造元素终端的匹配序列时使用了多个能够接受未知属性的插入点产品，则解码器可以自由地将未识别的属性与对应于这些插入点产品的任何一个扩展插入点相关联。这样做的理由来自以下两个观察结果：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) If the encoding of an abstract value contains an extension where the type of the extension is unknown to the receiver, then it is generally impossible to re-encode the value using a different set of encoding rules, including the canonical variant of the received encoding. This is true no matter which encoding rules are being used. It is desirable for a decoder to be able to accept and store the raw encoding of an extension without raising an error, and to re-insert the raw encoding of the extension when re-encoding the abstract value using the same non-canonical encoding rules. However, there is little more that an application can do with an unknown extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(1) 如果抽象值的编码包含接收方不知道扩展类型的扩展，则通常不可能使用不同的编码规则集（包括所接收编码的规范变量）对该值进行重新编码。无论使用哪种编码规则，这都是正确的。解码器希望能够在不引起错误的情况下接受和存储扩展的原始编码，并且在使用相同的非规范编码规则重新编码抽象值时重新插入扩展的原始编码。然而，对于未知的扩展，应用程序只能做很少的事情。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
An application using RXER can successfully accept, store, and re-encode an unrecognized attribute regardless of which extension insertion point it might be ascribed to.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
使用RXER的应用程序可以成功地接受、存储和重新编码无法识别的属性，而不管该属性属于哪个扩展插入点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) Even if there is a single extension insertion point, an unknown extension could still be the encoding of a value of any one of an infinite number of valid type definitions. For example, an attribute or element component could be nested to any arbitrary depth within CHOICEs whose components are subject to GROUP encoding instructions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(2) 即使只有一个扩展插入点，未知扩展仍然可以是无限多个有效类型定义中任意一个的值的编码。例如，属性或元素组件可以嵌套到其组件受组编码指令约束的选项中的任意深度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
Aside: A similar series of nested CHOICEs could describe an unknown extension in a Basic Encoding Rules (BER) encoding [X.690].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
旁白：类似的一系列嵌套选择可以描述基本编码规则（BER）编码[X.690]中的未知扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
26. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
26. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1 compiler implementors should take special care to be thorough in checking that the GROUP encoding instruction has been correctly used; otherwise, ASN.1 specifications with ambiguous RXER encodings could be deployed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ASN.1编译器实现人员应特别注意彻底检查组编码指令是否已正确使用；否则，可以部署带有不明确RXER编码的ASN.1规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ambiguous encodings mean that the abstract value recovered by a decoder may differ from the original abstract value that was encoded. If that is the case, then a digital signature generated with respect to the original abstract value (using a canonical encoding other than CRXER) will not be successfully verified by a receiver using the decoded abstract value. Also, an abstract value may have security-sensitive fields, and in particular, fields used to grant or deny access. If the decoded abstract value differs from the encoded abstract value, then a receiver using the decoded abstract value will be applying different security policy than that embodied in the original abstract value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
模糊编码意味着解码器恢复的抽象值可能不同于编码的原始抽象值。如果是这种情况，则接收器将无法使用解码的抽象值成功验证针对原始抽象值（使用CRXER以外的规范编码）生成的数字签名。此外，抽象值可能具有安全敏感字段，特别是用于授予或拒绝访问的字段。如果解码的抽象值不同于编码的抽象值，则使用解码的抽象值的接收器将应用不同于原始抽象值中体现的安全策略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BCP14] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BCP14]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[URI] Berners-Lee, T., Fielding, R. and L. Masinter, &#34;Uniform Resource Identifiers (URI): Generic Syntax&#34;, STD 66, RFC 3986, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[URI]Berners Lee，T.，Fielding，R.和L.Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RXER] Legg, S. and D. Prager, &#34;Robust XML Encoding Rules (RXER) for Abstract Syntax Notation One (ASN.1)&#34;, RFC 4910, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RXER]Legg，S.和D.Prager，“抽象语法表示法1（ASN.1）的健壮XML编码规则（RXER）”，RFC 4910，2007年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASN.X] Legg, S., &#34;Abstract Syntax Notation X (ASN.X)&#34;, RFC 4912, July 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ASN.X]Legg，S.，“抽象语法符号X（ASN.X）”，RFC 4912，2007年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.680] ITU-T Recommendation X.680 (07/02) | ISO/IEC 8824-1, Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.680]ITU-T建议X.680（07/02）| ISO/IEC 8824-1，信息技术-抽象语法符号一（ASN.1）：基本符号规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.680-1] ITU-T Recommendation X.680 (2002) Amendment 1 (10/03) | ISO/IEC 8824-1:2002/Amd 1:2004, Support for EXTENDED-XER.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.680-1]ITU-T建议X.680（2002）修改件1（10/03）| ISO/IEC 8824-1:2002/Amd 1:2004，对扩展XER的支持。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.683] ITU-T Recommendation X.683 (07/02) | ISO/IEC 8824-4, Information technology - Abstract Syntax Notation One (ASN.1): Parameterization of ASN.1 specifications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.683]ITU-T建议X.683（07/02）| ISO/IEC 8824-4，信息技术-抽象语法符号1（ASN.1）：ASN.1规范的参数化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XML10] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E. and F. Yergeau, &#34;Extensible Markup Language (XML) 1.0 (Fourth Edition)&#34;, W3C Recommendation, http://www.w3.org/TR/2006/REC-xml-20060816, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XML10]Bray，T.，Paoli，J.，Sperberg McQueen，C.，Maler，E.和F.Yergeau，“可扩展标记语言（XML）1.0（第四版）”，W3C建议，http://www.w3.org/TR/2006/REC-xml-20060816，2006年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XMLNS10] Bray, T., Hollander, D., Layman, A., and R. Tobin, &#34;Namespaces in XML 1.0 (Second Edition)&#34;, W3C Recommendation, http://www.w3.org/TR/2006/REC-xml-names-20060816, August 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XMLNS10]Bray，T.，Hollander，D.，Layman，A.，和R.Tobin，“XML 1.0中的名称空间（第二版）”，W3C建议，http://www.w3.org/TR/2006/REC-xml-names-20060816，2006年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XSD1] Thompson, H., Beech, D., Maloney, M. and N. Mendelsohn, &#34;XML Schema Part 1: Structures Second Edition&#34;, W3C Recommendation, http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/, October 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XSD1]Thompson，H.，Beech，D.，Maloney，M.和N.Mendelsohn，“XML模式第1部分：结构第二版”，W3C建议，http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/，2004年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XSD2] Biron, P. and A. Malhotra, &#34;XML Schema Part 2: Datatypes Second Edition&#34;, W3C Recommendation, http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/, October 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[XSD2]Biron，P.和A.Malhotra，“XML模式第2部分：数据类型第二版”，W3C建议，http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/，2004年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RNG] Clark, J. and M. Makoto, &#34;RELAX NG Tutorial&#34;, OASIS Committee Specification, http://www.oasis-open.org/ committees/relax-ng/tutorial-20011203.html, December 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RNG]Clark，J.和M.Makoto，“放松NG教程”，绿洲委员会规范，http://www.oasis-open.org/ committees/relax ng/tutorial-20011203.html，2001年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
27.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INFOSET] Cowan, J. and R. Tobin, &#34;XML Information Set (Second Edition)&#34;, W3C Recommendation, http://www.w3.org/ TR/2004/REC-xml-infoset-20040204, February 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INFOSET]Cowan，J.和R.Tobin，“XML信息集（第二版）”，W3C建议，http://www.w3.org/ TR/2004/REC-xml-infoset-200402042004年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.690] ITU-T Recommendation X.690 (07/02) | ISO/IEC 8825-1, Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[X.690]ITU-T建议X.690（07/02）| ISO/IEC 8825-1，信息技术-ASN.1编码规则：基本编码规则（BER）、规范编码规则（CER）和区分编码规则（DER）规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A. GROUP Encoding Instruction Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录A.分组编码说明示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix is non-normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录为非规范性附录。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix contains examples of both correct and incorrect use of the GROUP encoding instruction, determined with respect to the grammars derived from the example type definitions. The productions of the grammars are labeled for convenience. Sets and predicates for non-terminals with only one production will be omitted from the examples since they never indicate non-determinism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录包含正确和不正确使用分组编码指令的示例，根据示例类型定义派生的语法确定。为了方便起见，这些语法的产物都贴上了标签。示例中将省略仅具有一个结果的非终端的集合和谓词，因为它们从不表示非确定性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirements of Section 25.1.2 (&#34;Unique Component Attribution&#34;) are satisfied by all the examples in this appendix and the appendices that follow it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录及其后续附录中的所有示例均满足第25.1.2节（“独特组件属性”）的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. Example 1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 例1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑这种类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String OPTIONAL
          } OPTIONAL,
          three  INTEGER
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String OPTIONAL
          } OPTIONAL,
          three  INTEGER
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P3:  one ::=
      P4:  two ::= &#34;two&#34;
      P5:  two ::=
      P6:  three ::= &#34;three&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P3:  one ::=
      P4:  two ::= &#34;two&#34;
      P5:  two ::=
      P6:  three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select Sets have to be evaluated to test the validity of the type definition. The grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须评估选择集以测试类型定义的有效性。语法导致以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = false
      Empty(P2) = Empty(P3) = true
      Follow(one) = { &#34;three&#34; }
      Select(P2) = First(P2) + Follow(one) = { &#34;two&#34;, &#34;three&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;three&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = false
      Empty(P2) = Empty(P3) = true
      Follow(one) = { &#34;three&#34; }
      Select(P2) = First(P2) + Follow(one) = { &#34;two&#34;, &#34;three&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;three&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;two&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(two) = { &#34;three&#34; }
      Select(P4) = First(P4) = { &#34;two&#34; }
      Select(P5) = First(P5) + Follow(two) = { &#34;three&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;two&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(two) = { &#34;three&#34; }
      Select(P4) = First(P4) = { &#34;two&#34; }
      Select(P5) = First(P5) + Follow(two) = { &#34;three&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type does not have a child element &lt;two&gt;, then it is not possible to determine whether the &#34;one&#34; component is present or absent in the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P3）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果该类型值的RXER编码没有子元素&lt;two&gt;，则无法确定该值中是否存在“一”组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now consider this type definition with attributes in the &#34;one&#34; component:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在在“一”组件中考虑具有这种属性的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String OPTIONAL,
              four   [ATTRIBUTE] BOOLEAN,
              five   [ATTRIBUTE] BOOLEAN OPTIONAL
          } OPTIONAL,
          three  INTEGER
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String OPTIONAL,
              four   [ATTRIBUTE] BOOLEAN,
              five   [ATTRIBUTE] BOOLEAN OPTIONAL
          } OPTIONAL,
          three  INTEGER
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two four five
      P3:  one ::=
      P4:  two ::= &#34;two&#34;
      P5:  two ::=
      P6:  four ::= &#34;@four&#34;
      P7:  five ::= &#34;@five&#34;
      P8:  five ::=
      P9:  three ::= &#34;three&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two four five
      P3:  one ::=
      P4:  two ::= &#34;two&#34;
      P5:  two ::=
      P6:  four ::= &#34;@four&#34;
      P7:  five ::= &#34;@five&#34;
      P8:  five ::=
      P9:  three ::= &#34;three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { }
      Preselected(P3) = Empty(P2) = false
      Preselected(P2) = Empty(P3) = true
      Follow(one) = { &#34;three&#34; }
      Select(P2) = { }
      Select(P3) = First(P3) + Follow(one) = { &#34;three&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { }
      Preselected(P3) = Empty(P2) = false
      Preselected(P2) = Empty(P3) = true
      Follow(one) = { &#34;three&#34; }
      Select(P2) = { }
      Select(P3) = First(P3) + Follow(one) = { &#34;three&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;two&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(two) = { &#34;three&#34; }
      Select(P4) = First(P4) = { &#34;two&#34; }
      Select(P5) = First(P5) + Follow(two) = { &#34;three&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;two&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(two) = { &#34;three&#34; }
      Select(P4) = First(P4) = { &#34;two&#34; }
      Select(P5) = First(P5) + Follow(two) = { &#34;three&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { }
      First(P8) = { }
      Preselected(P8) = Empty(P7) = false
      Preselected(P7) = Empty(P8) = true
      Follow(five) = { &#34;three&#34; }
      Select(P7) = { }
      Select(P8) = First(P8) + Follow(five) = { &#34;three&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { }
      First(P8) = { }
      Preselected(P8) = Empty(P7) = false
      Preselected(P7) = Empty(P8) = true
      Follow(five) = { &#34;three&#34; }
      Select(P7) = { }
      Select(P8) = First(P8) + Follow(five) = { &#34;three&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P3) is empty, as is the intersection of Select(P4) and Select(P5) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. In a correct RXER encoding, the &#34;one&#34; component will be present if and only if the &#34;four&#34; attribute is present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P3）的交点为空，Select（P4）和Select（P5）的交点为空，Select（P7）和Select（P8）的交点为空；因此，语法是确定性的，类型定义是有效的。在正确的RXER编码中，当且仅当“四”属性存在时，“一”组件才会存在。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. Example 2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. 例2
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑这种类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          one    [GROUP] SEQUENCE {
              two    [ATTRIBUTE] BOOLEAN OPTIONAL
          },
          three  INTEGER,
          four   [GROUP] SEQUENCE {
              five   BOOLEAN OPTIONAL
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          one    [GROUP] SEQUENCE {
              two    [ATTRIBUTE] BOOLEAN OPTIONAL
          },
          three  INTEGER,
          four   [GROUP] SEQUENCE {
              five   BOOLEAN OPTIONAL
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= three
      P3:  S ::= four
      P4:  one ::= two
      P5:  two ::= &#34;@two&#34;
      P6:  two ::=
      P7:  three ::= &#34;three&#34;
      P8:  four ::= five
      P9:  five ::= &#34;five&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= three
      P3:  S ::= four
      P4:  one ::= two
      P5:  two ::= &#34;@two&#34;
      P6:  two ::=
      P7:  three ::= &#34;three&#34;
      P8:  four ::= five
      P9:  five ::= &#34;five&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P10: five ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P10: five ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { }
      First(P2) = { &#34;three&#34; }
      First(P3) = { &#34;five&#34; }
      Preselected(P1) = Preselected(P2) = Preselected(P3) = false
      Empty(P2) = false
      Empty(P1) = Empty(P3) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;three&#34; }
      Select(P3) = First(P3) + Follow(S) = { &#34;five&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { }
      First(P2) = { &#34;three&#34; }
      First(P3) = { &#34;five&#34; }
      Preselected(P1) = Preselected(P2) = Preselected(P3) = false
      Empty(P2) = false
      Empty(P1) = Empty(P3) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;three&#34; }
      Select(P3) = First(P3) + Follow(S) = { &#34;five&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P5) = { }
      First(P6) = { }
      Preselected(P6) = Empty(P5) = false
      Preselected(P5) = Empty(P6) = true
      Follow(two) = { &#34;$&#34; }
      Select(P5) = { }
      Select(P6) = First(P6) + Follow(two) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P5) = { }
      First(P6) = { }
      Preselected(P6) = Empty(P5) = false
      Preselected(P5) = Empty(P6) = true
      Follow(two) = { &#34;$&#34; }
      Select(P5) = { }
      Select(P6) = First(P6) + Follow(two) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P9) = { &#34;five&#34; }
      First(P10) = { }
      Preselected(P9) = Preselected(P10) = Empty(P9) = false
      Empty(P10) = true
      Follow(five) = { &#34;$&#34; }
      Select(P9) = First(P9) = { &#34;five&#34; }
      Select(P10) = First(P10) + Follow(five) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P9) = { &#34;five&#34; }
      First(P10) = { }
      Preselected(P9) = Preselected(P10) = Empty(P9) = false
      Empty(P10) = true
      Follow(five) = { &#34;$&#34; }
      Select(P9) = First(P9) = { &#34;five&#34; }
      Select(P10) = First(P10) + Follow(five) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P1) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type is empty, then it is not possible to determine whether the &#34;one&#34; alternative or the &#34;four&#34; alternative has been chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P1）和Select（P3）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果类型值的RXER编码为空，则无法确定选择了“一”备选方案还是“四”备选方案。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now consider this slightly different type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在考虑一下稍微不同的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          one    [GROUP] SEQUENCE {
              two    [ATTRIBUTE] BOOLEAN
          },
          three  INTEGER,
          four   [GROUP] SEQUENCE {
              five   BOOLEAN OPTIONAL
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          one    [GROUP] SEQUENCE {
              two    [ATTRIBUTE] BOOLEAN
          },
          three  INTEGER,
          four   [GROUP] SEQUENCE {
              five   BOOLEAN OPTIONAL
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= three
      P3:  S ::= four
      P4:  one ::= two
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= &#34;three&#34;
      P7:  four ::= five
      P8:  five ::= &#34;five&#34;
      P9:  five ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= three
      P3:  S ::= four
      P4:  one ::= two
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= &#34;three&#34;
      P7:  four ::= five
      P8:  five ::= &#34;five&#34;
      P9:  five ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { }
      First(P2) = { &#34;three&#34; }
      First(P3) = { &#34;five&#34; }
      Preselected(P2) = Preselected(P3) = false
      Empty(P1) = Empty(P2) = false
      Preselected(P1) = Empty(P3) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = { }
      Select(P2) = First(P2) = { &#34;three&#34; }
      Select(P3) = First(P3) + Follow(S) = { &#34;five&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { }
      First(P2) = { &#34;three&#34; }
      First(P3) = { &#34;five&#34; }
      Preselected(P2) = Preselected(P3) = false
      Empty(P1) = Empty(P2) = false
      Preselected(P1) = Empty(P3) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = { }
      Select(P2) = First(P2) = { &#34;three&#34; }
      Select(P3) = First(P3) + Follow(S) = { &#34;five&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P8) = { &#34;five&#34; }
      First(P9) = { }
      Preselected(P8) = Preselected(P9) = Empty(P8) = false
      Empty(P9) = true
      Follow(five) = { &#34;$&#34; }
      Select(P8) = First(P8) = { &#34;five&#34; }
      Select(P9) = First(P9) + Follow(five) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P8) = { &#34;five&#34; }
      First(P9) = { }
      Preselected(P8) = Preselected(P9) = Empty(P8) = false
      Empty(P9) = true
      Follow(five) = { &#34;$&#34; }
      Select(P8) = First(P8) = { &#34;five&#34; }
      Select(P9) = First(P9) + Follow(five) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P1) and Select(P2) is empty, the intersection of Select(P1) and Select(P3) is empty, the intersection of Select(P2) and Select(P3) is empty, and the intersection of Select(P8) and Select(P9) is empty; hence, the grammar is deterministic, and the type definition is valid. The &#34;one&#34; and &#34;four&#34; alternatives can be distinguished because the &#34;one&#34; alternative has a mandatory attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择（P1）和选择（P2）的交点为空，选择（P1）和选择（P3）的交点为空，选择（P2）和选择（P3）的交点为空，选择（P8）和选择（P9）的交点为空；因此，语法是确定性的，类型定义是有效的。“一”和“四”备选方案可以区分，因为“一”备选方案具有强制性属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. Example 3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. 例3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑这种类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] CHOICE {
              two    [ATTRIBUTE] BOOLEAN,
              three  [GROUP] SEQUENCE OF number INTEGER
          } OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] CHOICE {
              two    [ATTRIBUTE] BOOLEAN,
              three  [GROUP] SEQUENCE OF number INTEGER
          } OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= three
      P4:  one ::=
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= number three
      P7:  three ::=
      P8:  number ::= &#34;number&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= three
      P4:  one ::=
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= number three
      P7:  three ::=
      P8:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { }
      First(P3) = { &#34;number&#34; }
      First(P4) = { }
      Preselected(P3) = Preselected(P4) = Empty(P2) = false
      Preselected(P2) = Empty(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = { }
      Select(P3) = First(P3) + Follow(one) = { &#34;number&#34;, &#34;$&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { }
      First(P3) = { &#34;number&#34; }
      First(P4) = { }
      Preselected(P3) = Preselected(P4) = Empty(P2) = false
      Preselected(P2) = Empty(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = { }
      Select(P3) = First(P3) + Follow(one) = { &#34;number&#34;, &#34;$&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;number&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(three) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;number&#34; }
      Select(P7) = First(P7) + Follow(three) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;number&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(three) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;number&#34; }
      Select(P7) = First(P7) + Follow(three) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type is empty, then it is not possible to determine whether the &#34;one&#34; component is absent or the empty &#34;three&#34; alternative has been chosen.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P3）和Select（P4）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果类型值的RXER编码为空，则无法确定是否缺少“一”组件或是否选择了空的“三”备选方案。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. Example 4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. 例4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑这种类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] CHOICE {
              two    [ATTRIBUTE] BOOLEAN,
              three  [ATTRIBUTE] BOOLEAN
          } OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] CHOICE {
              two    [ATTRIBUTE] BOOLEAN,
              three  [ATTRIBUTE] BOOLEAN
          } OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= three
      P4:  one ::=
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= &#34;@three&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= three
      P4:  one ::=
      P5:  two ::= &#34;@two&#34;
      P6:  three ::= &#34;@three&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { }
      First(P3) = { }
      First(P4) = { }
      Preselected(P4) = Empty(P2) = Empty(P3) = false
      Preselected(P2) = Preselected(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = { }
      Select(P3) = { }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { }
      First(P3) = { }
      First(P4) = { }
      Preselected(P4) = Empty(P2) = Empty(P3) = false
      Preselected(P2) = Preselected(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = { }
      Select(P3) = { }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P3) is empty, the intersection of Select(P2) and Select(P4) is empty, and the intersection of Select(P3) and Select(P4) is empty; hence, the grammar is deterministic, and the type definition is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择（P2）和选择（P3）的交点为空，选择（P2）和选择（P4）的交点为空，选择（P3）和选择（P4）的交点为空；因此，语法是确定性的，类型定义是有效的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. Example 5
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. 例5
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑这种类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] SEQUENCE OF number INTEGER OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] SEQUENCE OF number INTEGER OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= number one
      P3:  one ::=
      P4:  one ::=
      P5:  number ::= &#34;number&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= number one
      P3:  one ::=
      P4:  one ::=
      P5:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P3 is generated during the processing of the SEQUENCE OF type. P4 is generated because the &#34;one&#34; component is optional.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P3在处理类型序列的过程中生成。生成P4是因为“一”组件是可选的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;number&#34; }
      First(P3) = { }
      First(P4) = { }
      Preselected(P2) = Preselected(P3) = Preselected(P4) = false
      Empty(P2) = false
      Empty(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;number&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;$&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;number&#34; }
      First(P3) = { }
      First(P4) = { }
      Preselected(P2) = Preselected(P3) = Preselected(P4) = false
      Empty(P2) = false
      Empty(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;number&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;$&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the RXER encoding of a value of the type does not have any &lt;number&gt; child elements, then it is not possible to determine whether the &#34;one&#34; component is present or absent in the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P3）和Select（P4）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果类型值的RXER编码没有任何&lt;number&gt;子元素，则无法确定值中是否存在“一”组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider this similar type definition with a SIZE constraint:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑具有大小约束的类似类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= number one&#39;
      P3:  one&#39; ::= number one&#39;
      P4:  one&#39; ::=
      P5:  one ::=
      P6:  number ::= &#34;number&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= number one&#39;
      P3:  one&#39; ::= number one&#39;
      P4:  one&#39; ::=
      P5:  one ::=
      P6:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;number&#34; }
      First(P5) = { }
      Preselected(P2) = Preselected(P5) = Empty(P2) = false
      Empty(P5) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;number&#34; }
      Select(P5) = First(P5) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;number&#34; }
      First(P5) = { }
      Preselected(P2) = Preselected(P5) = Empty(P2) = false
      Empty(P5) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;number&#34; }
      Select(P5) = First(P5) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;number&#34; }
      First(P4) = { }
      Preselected(P3) = Preselected(P4) = Empty(P3) = false
      Empty(P4) = true
      Follow(one&#39;) = { &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;number&#34; }
      Select(P4) = First(P4) + Follow(one&#39;) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;number&#34; }
      First(P4) = { }
      Preselected(P3) = Preselected(P4) = Empty(P3) = false
      Empty(P4) = true
      Follow(one&#39;) = { &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;number&#34; }
      Select(P4) = First(P4) + Follow(one&#39;) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P5) is empty, as is the intersection of Select(P3) and Select(P4); hence, the grammar is deterministic, and the type definition is valid. If there are no &lt;number&gt; child elements, then the &#34;one&#34; component is necessarily absent and there is no ambiguity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P5）的交点为空，Select（P3）和Select（P4）的交点也是空的；因此，语法是确定性的，类型定义是有效的。如果没有&lt;number&gt;子元素，则“一”组件必然不存在，并且不存在歧义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.6. Example 6
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.6. 例6
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider this type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑这种类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          beginning  [GROUP] List,
          middle     UTF8String OPTIONAL,
          end        [GROUP] List
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          beginning  [GROUP] List,
          middle     UTF8String OPTIONAL,
          end        [GROUP] List
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= beginning middle end
      P2:  beginning ::= string beginning
      P3:  beginning ::=
      P4:  middle ::= &#34;middle&#34;
      P5:  middle ::=
      P6:  end ::= string end
      P7:  end ::=
      P8:  string ::= &#34;string&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= beginning middle end
      P2:  beginning ::= string beginning
      P3:  beginning ::=
      P4:  middle ::= &#34;middle&#34;
      P5:  middle ::=
      P6:  end ::= string end
      P7:  end ::=
      P8:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;string&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = Empty(P2) = false
      Empty(P3) = true
      Follow(beginning) = { &#34;middle&#34;, &#34;string&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;string&#34; }
      Select(P3) = First(P3) + Follow(beginning)
                 = { &#34;middle&#34;, &#34;string&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;string&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = Empty(P2) = false
      Empty(P3) = true
      Follow(beginning) = { &#34;middle&#34;, &#34;string&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;string&#34; }
      Select(P3) = First(P3) + Follow(beginning)
                 = { &#34;middle&#34;, &#34;string&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;middle&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(middle) = { &#34;string&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;middle&#34; }
      Select(P5) = First(P5) + Follow(middle) = { &#34;string&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;middle&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(middle) = { &#34;string&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;middle&#34; }
      Select(P5) = First(P5) + Follow(middle) = { &#34;string&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;string&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(end) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;string&#34; }
      Select(P7) = First(P7) + Follow(end) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;string&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(end) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;string&#34; }
      Select(P7) = First(P7) + Follow(end) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P3) is not empty; hence, the grammar is not deterministic, and the type definition is not valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P3）的交点不为空；因此，语法是不确定的，类型定义是无效的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          beginning     [GROUP] List,
          middleAndEnd  [GROUP] SEQUENCE {
              middle        UTF8String,
              end           [GROUP] List
          } OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          beginning     [GROUP] List,
          middleAndEnd  [GROUP] SEQUENCE {
              middle        UTF8String,
              end           [GROUP] List
          } OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= beginning middleAndEnd
      P2:  beginning ::= string beginning
      P3:  beginning ::=
      P4:  middleAndEnd ::= middle end
      P5:  middleAndEnd ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= beginning middleAndEnd
      P2:  beginning ::= string beginning
      P3:  beginning ::=
      P4:  middleAndEnd ::= middle end
      P5:  middleAndEnd ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P6:  middle ::= &#34;middle&#34;
      P7:  end ::= string end
      P8:  end ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P6:  middle ::= &#34;middle&#34;
      P7:  end ::= string end
      P8:  end ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;string&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = Empty(P2) = false
      Empty(P3) = true
      Follow(beginning) = { &#34;middle&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;string&#34; }
      Select(P3) = First(P3) + Follow(beginning) = { &#34;middle&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;string&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = Empty(P2) = false
      Empty(P3) = true
      Follow(beginning) = { &#34;middle&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;string&#34; }
      Select(P3) = First(P3) + Follow(beginning) = { &#34;middle&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;middle&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(middleAndEnd) = { &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;middle&#34; }
      Select(P5) = First(P5) + Follow(middleAndEnd) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;middle&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(middleAndEnd) = { &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;middle&#34; }
      Select(P5) = First(P5) + Follow(middleAndEnd) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;string&#34; }
      First(P8) = { }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(end) = { &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;string&#34; }
      Select(P8) = First(P8) + Follow(end) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;string&#34; }
      First(P8) = { }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(end) = { &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;string&#34; }
      Select(P8) = First(P8) + Follow(end) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P3) is empty, as is the intersection of Select(P4) and Select(P5) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P3）的交点为空，Select（P4）和Select（P5）的交点为空，Select（P7）和Select（P8）的交点为空；因此，语法是确定性的，类型定义是有效的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.7. Example 7
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.7. 例7
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE SIZE(1..MAX) OF
          one  [GROUP] SEQUENCE {
              two    INTEGER OPTIONAL
          }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE SIZE(1..MAX) OF
          one  [GROUP] SEQUENCE {
              two    INTEGER OPTIONAL
          }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S&#39;
      P2:  S&#39; ::= one S&#39;
      P3:  S&#39; ::=
      P4:  one ::= two
      P5:  two ::= &#34;two&#34;
      P6:  two ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S&#39;
      P2:  S&#39; ::= one S&#39;
      P3:  S&#39; ::=
      P4:  one ::= two
      P5:  two ::= &#34;two&#34;
      P6:  two ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = false
      Empty(P2) = Empty(P3) = true
      Follow(S&#39;) = { &#34;$&#34; }
      Select(P2) = First(P2) + Follow(S&#39;) = { &#34;two&#34;, &#34;$&#34; }
      Select(P3) = First(P3) + Follow(S&#39;) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { }
      Preselected(P2) = Preselected(P3) = false
      Empty(P2) = Empty(P3) = true
      Follow(S&#39;) = { &#34;$&#34; }
      Select(P2) = First(P2) + Follow(S&#39;) = { &#34;two&#34;, &#34;$&#34; }
      Select(P3) = First(P3) + Follow(S&#39;) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P5) = { &#34;two&#34; }
      First(P6) = { }
      Preselected(P5) = Preselected(P6) = Empty(P5) = false
      Empty(P6) = true
      Follow(two) = { &#34;two&#34;, &#34;$&#34; }
      Select(P5) = First(P5) = { &#34;two&#34; }
      Select(P6) = First(P6) + Follow(two) = { &#34;two&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P5) = { &#34;two&#34; }
      First(P6) = { }
      Preselected(P5) = Preselected(P6) = Empty(P5) = false
      Empty(P6) = true
      Follow(two) = { &#34;two&#34;, &#34;$&#34; }
      Select(P5) = First(P5) = { &#34;two&#34; }
      Select(P6) = First(P6) + Follow(two) = { &#34;two&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P3) is not empty and the intersection of Select(P5) and Select(P6) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. The encoding of a value of the type contains an indeterminate number of empty instances of the component type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P3）的交点不为空，Select（P5）和Select（P6）的交点不为空；因此，语法是不确定的，类型定义是无效的。类型值的编码包含不确定数量的组件类型空实例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.8. Example 8
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.8. 例8
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
SEQUENCE OF list [GROUP] SEQUENCE SIZE(1..MAX) OF number INTEGER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
数字整数的列表[组]序列大小（1..MAX）的序列
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= list S
      P2:  S ::=
      P3:  list ::= number list&#39;
      P4:  list&#39; ::= number list&#39;
      P5:  list&#39; ::=
      P6:  number ::= &#34;number&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= list S
      P2:  S ::=
      P3:  list ::= number list&#39;
      P4:  list&#39; ::= number list&#39;
      P5:  list&#39; ::=
      P6:  number ::= &#34;number&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;number&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;number&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;number&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;number&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;number&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(list&#39;) = { &#34;number&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;number&#34; }
      Select(P5) = First(P5) + Follow(list&#39;) = { &#34;number&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;number&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(list&#39;) = { &#34;number&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;number&#34; }
      Select(P5) = First(P5) + Follow(list&#39;) = { &#34;number&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P4) and Select(P5) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. The type describes a list of lists, but it is not possible for a decoder to determine where the outer lists begin and end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P4）和Select（P5）的交点不为空；因此，语法是不确定的，类型定义是无效的。该类型描述列表列表，但解码器无法确定外部列表的开始和结束位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.9. Example 9
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.9. 例9
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF item [GROUP] SEQUENCE {
          before  [GROUP] OneAndTwo,
          core    UTF8String,
          after   [GROUP] OneAndTwo OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF item [GROUP] SEQUENCE {
          before  [GROUP] OneAndTwo,
          core    UTF8String,
          after   [GROUP] OneAndTwo OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      OneAndTwo ::= SEQUENCE {
          non-core  UTF8String
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      OneAndTwo ::= SEQUENCE {
          non-core  UTF8String
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= item S
      P2:  S ::=
      P3:  item ::= before core after
      P4:  before ::= non-core
      P5:  non-core ::= &#34;non-core&#34;
      P6:  core ::= &#34;core&#34;
      P7:  after ::= non-core
      P8:  after ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= item S
      P2:  S ::=
      P3:  item ::= before core after
      P4:  before ::= non-core
      P5:  non-core ::= &#34;non-core&#34;
      P6:  core ::= &#34;core&#34;
      P7:  after ::= non-core
      P8:  after ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;non-core&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;non-core&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;non-core&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;non-core&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;non-core&#34; }
      First(P8) = { }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(after) = { &#34;non-core&#34;, &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;non-core&#34; }
      Select(P8) = First(P8) + Follow(after) = { &#34;non-core&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;non-core&#34; }
      First(P8) = { }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(after) = { &#34;non-core&#34;, &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;non-core&#34; }
      Select(P8) = First(P8) + Follow(after) = { &#34;non-core&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P7) and Select(P8) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. There is ambiguity between the end of one item and the start of the next. Without looking ahead in an encoding, it is not possible to determine whether a &lt;non-core&gt; element belongs with the preceding or following &lt;core&gt; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P7）和Select（P8）的交点不为空；因此，语法是不确定的，类型定义是无效的。一个项目的结束和下一个项目的开始之间存在模糊性。如果不在编码中向前看，就不可能确定&lt;non-core&gt;元素是属于前面的&lt;core&gt;元素还是后面的&lt;core&gt;元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.10. Example 10
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.10. 例10
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          one   [GROUP] List,
          two   [GROUP] SEQUENCE {
              three  [ATTRIBUTE] UTF8String,
              four   [GROUP] List
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      CHOICE {
          one   [GROUP] List,
          two   [GROUP] SEQUENCE {
              three  [ATTRIBUTE] UTF8String,
              four   [GROUP] List
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= two
      P3:  one ::= string one
      P4:  one ::=
      P5:  two ::= three four
      P6:  three ::= &#34;@three&#34;
      P7:  four ::= string four
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  S ::= two
      P3:  one ::= string one
      P4:  one ::=
      P5:  two ::= three four
      P6:  three ::= &#34;@three&#34;
      P7:  four ::= string four
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P8:  four ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P8:  four ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;string&#34; }
      First(P2) = { &#34;string&#34; }
      Preselected(P1) = Empty(P2) = false
      Preselected(P2) = Empty(P1) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;string&#34;, &#34;$&#34; }
      Select(P2) = { }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;string&#34; }
      First(P2) = { &#34;string&#34; }
      Preselected(P1) = Empty(P2) = false
      Preselected(P2) = Empty(P1) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;string&#34;, &#34;$&#34; }
      Select(P2) = { }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;string&#34; }
      First(P4) = { }
      Preselected(P3) = Preselected(P4) = Empty(P3) = false
      Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;string&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;string&#34; }
      First(P4) = { }
      Preselected(P3) = Preselected(P4) = Empty(P3) = false
      Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;string&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;string&#34; }
      First(P8) = { }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(four) = { &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;string&#34; }
      Select(P8) = First(P8) + Follow(four) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;string&#34; }
      First(P8) = { }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(four) = { &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;string&#34; }
      Select(P8) = First(P8) + Follow(four) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P1) and Select(P2) is empty, as is the intersection of Select(P3) and Select(P4) and the intersection of Select(P7) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. Although both alternatives of the CHOICE can begin with a &lt;string&gt; element, an RXER decoder would use the presence of a &#34;three&#34; attribute to decide whether to select or disregard the &#34;two&#34; alternative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P1）和Select（P2）的交点为空，Select（P3）和Select（P4）的交点为空，Select（P7）和Select（P8）的交点为空；因此，语法是确定性的，类型定义是有效的。尽管选择的两个备选方案都可以从&lt;string&gt;元素开始，但RXER解码器将使用“三”属性的存在来决定是选择还是忽略“两”备选方案。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, an attribute in an extension cannot be used to select between alternatives. Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
但是，扩展中的属性不能用于在备选方案之间进行选择。考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [SINGULAR-INSERTIONS] CHOICE {
          one   [GROUP] List,
          ...,
          two   [GROUP] SEQUENCE {
              three  [ATTRIBUTE] UTF8String,
              four   [GROUP] List
          } -- ExtensionAdditionAlternative (E1).
          -- The extension insertion point is here (I1).
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [SINGULAR-INSERTIONS] CHOICE {
          one   [GROUP] List,
          ...,
          two   [GROUP] SEQUENCE {
              three  [ATTRIBUTE] UTF8String,
              four   [GROUP] List
          } -- ExtensionAdditionAlternative (E1).
          -- The extension insertion point is here (I1).
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      List ::= SEQUENCE OF string UTF8String
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P10: S ::= E1
      P11: S ::= &#34;*&#34;
      P12: E1 ::= two
      P3:  one ::= string one
      P4:  one ::=
      P5:  two ::= three four
      P6:  three ::= &#34;@three&#34;
      P7:  four ::= string four
      P8:  four ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P10: S ::= E1
      P11: S ::= &#34;*&#34;
      P12: E1 ::= two
      P3:  one ::= string one
      P4:  one ::=
      P5:  two ::= three four
      P6:  three ::= &#34;@three&#34;
      P7:  four ::= string four
      P8:  four ::=
      P9:  string ::= &#34;string&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates for P1, P10 and P11:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该语法为P1、P10和P11生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;string&#34; }
      First(P10) = { &#34;string&#34; }
      First(P11) = { &#34;*&#34; }
      Preselected(P1) = Preselected(P10) = Preselected(P11) = false
      Empty(P10) = Empty(P11) = false
      Empty(P1) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;string&#34;, &#34;$&#34; }
      Select(P10) = First(P10) = { &#34;string&#34; }
      Select(P11) = First(P11) = { &#34;*&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;string&#34; }
      First(P10) = { &#34;string&#34; }
      First(P11) = { &#34;*&#34; }
      Preselected(P1) = Preselected(P10) = Preselected(P11) = false
      Empty(P10) = Empty(P11) = false
      Empty(P1) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;string&#34;, &#34;$&#34; }
      Select(P10) = First(P10) = { &#34;string&#34; }
      Select(P11) = First(P11) = { &#34;*&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Preselected(P10) evaluates to false because Preselected(P10) is evaluated on the base grammar, wherein P10 is rewritten as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Preselected（P10）计算结果为false，因为Preselected（P10）是在基本语法上计算的，其中P10被重写为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P10: S ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P10: S ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P1) and Select(P10) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. An RXER decoder using the original, unextended version of the definition would not know that the &#34;three&#34; attribute selects between the &#34;one&#34; alternative and the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P1）和Select（P10）的交点不为空；因此，语法是不确定的，类型定义是无效的。使用原始未扩展版本的定义的RXER解码器将不知道“三”属性在“一”选项和扩展之间进行选择。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix B. Insertion Encoding Instruction Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录B.插入编码指令示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix is non-normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录为非规范性附录。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix contains examples showing the use of insertion encoding instructions to remove extension ambiguity arising from use of the GROUP encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录包含使用插入编码指令消除因使用组编码指令而产生的扩展歧义的示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. Example 1
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. 例1
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  INTEGER OPTIONAL,
          ... -- Extension insertion point (I2).
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  INTEGER OPTIONAL,
          ... -- Extension insertion point (I2).
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three I2
      P2:  one ::= two I1
      P3:  two ::= &#34;two&#34;
      P4:  I1 ::= &#34;*&#34; I1
      P5:  I1 ::=
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
      P8:  I2 ::= &#34;*&#34; I2
      P9:  I2 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three I2
      P2:  one ::= two I1
      P3:  two ::= &#34;two&#34;
      P4:  I1 ::= &#34;*&#34; I1
      P5:  I1 ::=
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
      P8:  I2 ::= &#34;*&#34; I2
      P9:  I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;*&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(I1) = { &#34;three&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;*&#34; }
      Select(P5) = First(P5) + Follow(I1) = { &#34;three&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;*&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(I1) = { &#34;three&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;*&#34; }
      Select(P5) = First(P5) + Follow(I1) = { &#34;three&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;three&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(three) = { &#34;*&#34;, &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;three&#34; }
      Select(P7) = First(P7) + Follow(three) = { &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;three&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(three) = { &#34;*&#34;, &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;three&#34; }
      Select(P7) = First(P7) + Follow(three) = { &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P8) = { &#34;*&#34; }
      First(P9) = { }
      Preselected(P8) = Preselected(P9) = Empty(P8) = false
      Empty(P9) = true
      Follow(I2) = { &#34;$&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
      Select(P9) = First(P9) + Follow(I2) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P8) = { &#34;*&#34; }
      First(P9) = { }
      Preselected(P8) = Preselected(P9) = Empty(P8) = false
      Empty(P9) = true
      Follow(I2) = { &#34;$&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
      Select(P9) = First(P9) + Follow(I2) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P4) and Select(P5) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If an RXER decoder encounters an unrecognized element immediately after a &lt;two&gt; element, then it will not know whether to associate it with extension insertion point I1 or I2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P4）和Select（P5）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果RXER解码器在&lt;two&gt;元素之后立即遇到无法识别的元素，那么它将不知道是否将其与扩展插入点I1或I2关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The non-determinism can be resolved with either a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction. Consider this revised type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非确定性可以通过无插入或空插入编码指令来解决。考虑修改后的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] [HOLLOW-INSERTIONS] SEQUENCE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  INTEGER OPTIONAL,
          ... -- Extension insertion point (I2).
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] [HOLLOW-INSERTIONS] SEQUENCE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  INTEGER OPTIONAL,
          ... -- Extension insertion point (I2).
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three I2
      P10: one ::= two
      P3:  two ::= &#34;two&#34;
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
      P8:  I2 ::= &#34;*&#34; I2
      P9:  I2 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three I2
      P10: one ::= two
      P3:  two ::= &#34;two&#34;
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
      P8:  I2 ::= &#34;*&#34; I2
      P9:  I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the addition of the HOLLOW-INSERTIONS encoding instruction, the P4 and P5 productions are no longer generated, and the conflict between Select(P4) and Select(P5) no longer exists. The Select Sets
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
随着空心插入编码指令的添加，不再生成P4和P5生成，Select（P4）和Select（P5）之间的冲突也不再存在。选择集
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
for P6, P7, P8, and P9 are unchanged. A decoder will now assume that an unrecognized element is to be associated with extension insertion point I2. It is still free to associate an unrecognized attribute with either extension insertion point. If a NO-INSERTIONS encoding instruction had been used, then an unrecognized attribute could only be associated with extension insertion point I2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于P6、P8和P7，它们是不变的。解码器现在将假定未识别的元素与扩展插入点I2相关联。仍然可以将无法识别的属性与任一扩展插入点关联。如果使用了非插入编码指令，则无法识别的属性只能与扩展插入点I2关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The non-determinism could also be resolved by adding a NO-INSERTIONS or HOLLOW-INSERTIONS encoding instruction to the outer SEQUENCE:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非确定性也可以通过向外部序列添加无插入或空插入编码指令来解决：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [HOLLOW-INSERTIONS] SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  INTEGER OPTIONAL,
          ... -- Extension insertion point (I2).
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [HOLLOW-INSERTIONS] SEQUENCE {
          one    [GROUP] SEQUENCE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  INTEGER OPTIONAL,
          ... -- Extension insertion point (I2).
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P11: S ::= one three
      P2:  one ::= two I1
      P3:  two ::= &#34;two&#34;
      P4:  I1 ::= &#34;*&#34; I1
      P5:  I1 ::=
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P11: S ::= one three
      P2:  one ::= two I1
      P3:  two ::= &#34;two&#34;
      P4:  I1 ::= &#34;*&#34; I1
      P5:  I1 ::=
      P6:  three ::= &#34;three&#34;
      P7:  three ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;*&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(I1) = { &#34;three&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;*&#34; }
      Select(P5) = First(P5) + Follow(I1) = { &#34;three&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P4) = { &#34;*&#34; }
      First(P5) = { }
      Preselected(P4) = Preselected(P5) = Empty(P4) = false
      Empty(P5) = true
      Follow(I1) = { &#34;three&#34;, &#34;$&#34; }
      Select(P4) = First(P4) = { &#34;*&#34; }
      Select(P5) = First(P5) + Follow(I1) = { &#34;three&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;three&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(three) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;three&#34; }
      Select(P7) = First(P7) + Follow(three) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;three&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(three) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;three&#34; }
      Select(P7) = First(P7) + Follow(three) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P4) and Select(P5) is empty, as is the intersection of Select(P6) and Select(P7); hence, the grammar is deterministic, and the type definition is valid. A decoder will now assume that an unrecognized element is to be associated with extension insertion point I1. It is still free to associate an unrecognized attribute with either extension insertion point. If a NO-INSERTIONS encoding instruction had been used, then an unrecognized attribute could only be associated with extension insertion point I1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P4）和Select（P5）的交点为空，Select（P6）和Select（P7）的交点也是空的；因此，语法是确定性的，类型定义是有效的。解码器现在将假定未识别的元素与扩展插入点I1相关联。仍然可以将无法识别的属性与任一扩展插入点关联。如果使用了非插入编码指令，则无法识别的属性只能与扩展插入点I1关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. Example 2
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. 例2
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] CHOICE {
              two  UTF8String,
              ... -- Extension insertion point (I1).
          } OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] CHOICE {
              two  UTF8String,
              ... -- Extension insertion point (I1).
          } OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= I1
      P4:  one ::=
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P3:  one ::= I1
      P4:  one ::=
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { &#34;*&#34; }
      First(P4) = { }
      Preselected(P2) = Preselected(P3) = Preselected(P4) = false
      Empty(P2) = false
      Empty(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;*&#34;, &#34;$&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { &#34;*&#34; }
      First(P4) = { }
      Preselected(P2) = Preselected(P3) = Preselected(P4) = false
      Empty(P2) = false
      Empty(P3) = Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;*&#34;, &#34;$&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;*&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;*&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Follow(I1) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;*&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Follow(I1) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;*&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P3) and Select(P4) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the &lt;two&gt; element is not present, then a decoder cannot determine whether the &#34;one&#34; alternative is absent, or present with an unknown extension that generates no elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P3）和Select（P4）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果&lt;two&gt;元素不存在，则解码器无法确定是否缺少“一”备选方案，或者是否存在不生成任何元素的未知扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The non-determinism can be resolved with either a SINGULAR-INSERTIONS, UNIFORM-INSERTIONS, or MULTIFORM-INSERTIONS encoding instruction. The MULTIFORM-INSERTIONS encoding instruction is the least restrictive. Consider this revised type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非确定性可以通过单数插入、均匀插入或多形式插入编码指令来解决。多形式插入编码指令的限制性最小。考虑修改后的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] [MULTIFORM-INSERTIONS] CHOICE {
              two  UTF8String,
              ... -- Extension insertion point (I1).
          } OPTIONAL
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one  [GROUP] [MULTIFORM-INSERTIONS] CHOICE {
              two  UTF8String,
              ... -- Extension insertion point (I1).
          } OPTIONAL
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P8:  one ::= &#34;*&#34; I1
      P4:  one ::=
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one
      P2:  one ::= two
      P8:  one ::= &#34;*&#34; I1
      P4:  one ::=
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P8) = { &#34;*&#34; }
      First(P4) = { }
      Preselected(P2) = Preselected(P8) = Preselected(P4) = false
      Empty(P2) = Empty(P8) = false
      Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P8) = { &#34;*&#34; }
      First(P4) = { }
      Preselected(P2) = Preselected(P8) = Preselected(P4) = false
      Empty(P2) = Empty(P8) = false
      Empty(P4) = true
      Follow(one) = { &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;*&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;*&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Empty(P7) = true
      Follow(I1) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;*&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Empty(P7) = true
      Follow(I1) = { &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;*&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P8) is empty, as is the intersection of Select(P2) and Select(P4), the intersection of Select(P8) and Select(P4), and the intersection of Select(P6) and Select(P7); hence, the grammar is deterministic, and the type definition is valid. A decoder will now assume the &#34;one&#34; alternative is present if it sees at least one unrecognized element, and absent otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P8）的交点为空，Select（P2）和Select（P4）的交点为空，Select（P8）和Select（P4）的交点为空，Select（P6）和Select（P7）的交点为空；因此，语法是确定性的，类型定义是有效的。如果解码器看到至少一个不可识别的元素，则现在将假定存在“一”备选方案，否则将不存在。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.3. Example 3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.3. 例3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] CHOICE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  [GROUP] CHOICE {
              four   UTF8String,
              ... -- Extension insertion point (I2).
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] CHOICE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  [GROUP] CHOICE {
              four   UTF8String,
              ... -- Extension insertion point (I2).
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P3:  one ::= I1
      P4:  two ::= &#34;two&#34;
      P5:  I1 ::= &#34;*&#34; I1
      P6:  I1 ::=
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P3:  one ::= I1
      P4:  two ::= &#34;two&#34;
      P5:  I1 ::= &#34;*&#34; I1
      P6:  I1 ::=
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { &#34;*&#34; }
      Preselected(P2) = Preselected(P3) = Empty(P2) = false
      Empty(P3) = true
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P3) = { &#34;*&#34; }
      Preselected(P2) = Preselected(P3) = Empty(P2) = false
      Empty(P3) = true
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;*&#34;, &#34;four&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P3) = First(P3) + Follow(one) = { &#34;*&#34;, &#34;four&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P5) = { &#34;*&#34; }
      First(P6) = { }
      Preselected(P5) = Preselected(P6) = Empty(P5) = false
      Empty(P6) = true
      Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P5) = First(P5) = { &#34;*&#34; }
      Select(P6) = First(P6) + Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P5) = { &#34;*&#34; }
      First(P6) = { }
      Preselected(P5) = Preselected(P6) = Empty(P5) = false
      Empty(P6) = true
      Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P5) = First(P5) = { &#34;*&#34; }
      Select(P6) = First(P6) + Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;four&#34; }
      First(P8) = { &#34;*&#34; }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(three) = { &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;four&#34; }
      Select(P8) = First(P8) + Follow(three) = { &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P7) = { &#34;four&#34; }
      First(P8) = { &#34;*&#34; }
      Preselected(P7) = Preselected(P8) = Empty(P7) = false
      Empty(P8) = true
      Follow(three) = { &#34;$&#34; }
      Select(P7) = First(P7) = { &#34;four&#34; }
      Select(P8) = First(P8) + Follow(three) = { &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P10) = { &#34;*&#34; }
      First(P11) = { }
      Preselected(P10) = Preselected(P11) = Empty(P10) = false
      Empty(P11) = true
      Follow(I2) = { &#34;$&#34; }
      Select(P10) = First(P10) = { &#34;*&#34; }
      Select(P11) = First(P11) + Follow(I2) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P10) = { &#34;*&#34; }
      First(P11) = { }
      Preselected(P10) = Preselected(P11) = Empty(P10) = false
      Empty(P11) = true
      Follow(I2) = { &#34;$&#34; }
      Select(P10) = First(P10) = { &#34;*&#34; }
      Select(P11) = First(P11) + Follow(I2) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P5) and Select(P6) is not empty; hence, the grammar is not deterministic, and the type definition is not valid. If the first child element is an unrecognized element, then a decoder cannot determine whether to associate it with extension insertion point I1, or to associate it with extension insertion point I2 by assuming that the &#34;one&#34; component has an unknown extension that generates no elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P5）和Select（P6）的交点不为空；因此，语法是不确定的，类型定义是无效的。如果第一个子元素是无法识别的元素，则解码器无法通过假设“一”组件具有不生成元素的未知扩展来确定是将其与扩展插入点I1关联，还是将其与扩展插入点I2关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The non-determinism can be resolved with either a SINGULAR-INSERTIONS or UNIFORM-INSERTIONS encoding instruction. Consider this revised type definition using the SINGULAR-INSERTIONS encoding instruction:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非确定性可以通过单数插入或统一插入编码指令来解决。使用奇数插入编码指令考虑此修订类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] [SINGULAR-INSERTIONS] CHOICE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  [GROUP] CHOICE {
              four   UTF8String,
              ... -- Extension insertion point (I2).
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] [SINGULAR-INSERTIONS] CHOICE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  [GROUP] CHOICE {
              four   UTF8String,
              ... -- Extension insertion point (I2).
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P12: one ::= &#34;*&#34;
      P4:  two ::= &#34;two&#34;
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P12: one ::= &#34;*&#34;
      P4:  two ::= &#34;two&#34;
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
With the addition of the SINGULAR-INSERTIONS encoding instruction, the P5 and P6 productions are no longer generated. The grammar leads to the following sets and predicates for the P2 and P12 productions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过添加SINGULAR-INSERTIONS编码指令，不再生成P5和P6产品。该语法为P2和P12产品提供以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P12) = { &#34;*&#34; }
      Preselected(P2) = Preselected(P12) = false
      Empty(P2) = Empty(P12) = false
      Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P12) = First(P12) = { &#34;*&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P12) = { &#34;*&#34; }
      Preselected(P2) = Preselected(P12) = false
      Empty(P2) = Empty(P12) = false
      Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P12) = First(P12) = { &#34;*&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sets for P5 and P6 are no longer generated, and the remaining sets are unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不再生成P5和P6的集合，其余集合不变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P12) is empty, as is the intersection of Select(P7) and Select(P8) and the intersection of Select(P10) and Select(P11); hence, the grammar is deterministic, and the type definition is valid. If the first child element is an unrecognized element, then a decoder will now assume that it is associated with extension insertion point I1. Whatever follows, possibly including another unrecognized element, will belong to the &#34;three&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P2）和Select（P12）的交点为空，Select（P7）和Select（P8）的交点为空，Select（P10）和Select（P11）的交点为空；因此，语法是确定性的，类型定义是有效的。如果第一个子元素是无法识别的元素，那么解码器现在将假定它与扩展插入点I1关联。接下来的任何内容，可能包括另一个无法识别的元素，都将属于“三”部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Now consider the type definition using the UNIFORM-INSERTIONS encoding instruction instead:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在，使用统一插入编码指令来考虑类型定义，而不是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] [UNIFORM-INSERTIONS] CHOICE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  [GROUP] CHOICE {
              four   UTF8String,
              ... -- Extension insertion point (I2).
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE {
          one    [GROUP] [UNIFORM-INSERTIONS] CHOICE {
              two    UTF8String,
              ... -- Extension insertion point (I1).
          },
          three  [GROUP] CHOICE {
              four   UTF8String,
              ... -- Extension insertion point (I2).
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P13: one ::= &#34;*&#34;
      P14: one ::= &#34;*1&#34; I1
      P4:  two ::= &#34;two&#34;
      P15: I1 ::= &#34;*1&#34; I1
      P6:  I1 ::=
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one three
      P2:  one ::= two
      P13: one ::= &#34;*&#34;
      P14: one ::= &#34;*1&#34; I1
      P4:  two ::= &#34;two&#34;
      P15: I1 ::= &#34;*1&#34; I1
      P6:  I1 ::=
      P7:  three ::= four
      P8:  three ::= I2
      P9:  four ::= &#34;four&#34;
      P10: I2 ::= &#34;*&#34; I2
      P11: I2 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates for the P2, P13, P14, P15, and P6 productions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法为P2、P13、P14、P15和P6产品生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P13) = { &#34;*&#34; }
      First(P14) = { &#34;*1&#34; }
      Preselected(P2) = Preselected(P13) = Preselected(P14) = false
      Empty(P2) = Empty(P13) = Empty(P14) = false
      Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P13) = First(P13) = { &#34;*&#34; }
      Select(P14) = First(P14) = { &#34;*1&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P2) = { &#34;two&#34; }
      First(P13) = { &#34;*&#34; }
      First(P14) = { &#34;*1&#34; }
      Preselected(P2) = Preselected(P13) = Preselected(P14) = false
      Empty(P2) = Empty(P13) = Empty(P14) = false
      Follow(one) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) = { &#34;two&#34; }
      Select(P13) = First(P13) = { &#34;*&#34; }
      Select(P14) = First(P14) = { &#34;*1&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P15) = { &#34;*1&#34; }
      First(P6) = { }
      Preselected(P15) = Preselected(P6) = Empty(P15) = false
      Empty(P6) = true
      Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P15) = First(P15) = { &#34;*1&#34; }
      Select(P6) = First(P6) + Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P15) = { &#34;*1&#34; }
      First(P6) = { }
      Preselected(P15) = Preselected(P6) = Empty(P15) = false
      Empty(P6) = true
      Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P15) = First(P15) = { &#34;*1&#34; }
      Select(P6) = First(P6) + Follow(I1) = { &#34;four&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remaining sets are unchanged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其余的几组没有变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P2) and Select(P13) is empty, as is the intersection of Select(P2) and Select(P14), the intersection of Select(P13) and Select(P14) and the intersection of Select(P15) and Select(P6); hence, the grammar is deterministic, and the type definition is valid. If the first child element is an unrecognized element, then a decoder will now assume that it and every subsequent unrecognized element with the same name are associated with I1. Whatever follows, possibly including another unrecognized element with a different name, will belong to the &#34;three&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择（P2）和选择（P13）的交点为空，选择（P2）和选择（P14）的交点为空，选择（P13）和选择（P14）的交点为空，选择（P15）和选择（P6）的交点为空；因此，语法是确定性的，类型定义是有效的。如果第一个子元素是一个无法识别的元素，那么解码器现在将假定它和每个具有相同名称的后续无法识别的元素都与I1关联。接下来的任何内容，可能包括另一个名称不同的无法识别的元素，都将属于“三”组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A consequence of using the UNIFORM-INSERTIONS encoding instruction is that any future extension to the &#34;three&#34; component will be required to generate elements with names that are different from the names of the elements generated by the &#34;one&#34; component. With the SINGULAR-INSERTIONS encoding instruction, extensions to the &#34;three&#34; component are permitted to generate elements with names that are the same as the names of the elements generated by the &#34;one&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用UNIFORM-INSERTIONS编码指令的结果是，将来对“三”组件的任何扩展都需要生成名称不同于“一”组件生成的元素名称的元素。使用SINGULAR-INSERTIONS编码指令，允许对“三”组件的扩展生成名称与“一”组件生成的元素名称相同的元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.4. Example 4
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.4. 例4
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
考虑下面的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF one [GROUP] CHOICE {
          two    UTF8String,
          ... -- Extension insertion point (I1).
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF one [GROUP] CHOICE {
          two    UTF8String,
          ... -- Extension insertion point (I1).
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P4:  one ::= I1
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P4:  one ::= I1
      P5:  two ::= &#34;two&#34;
      P6:  I1 ::= &#34;*&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;two&#34;, &#34;*&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = false
      Empty(P1) = Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;two&#34;, &#34;*&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = false
      Empty(P1) = Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) + Follow(S) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;two&#34; }
      First(P4) = { &#34;*&#34; }
      Preselected(P3) = Preselected(P4) = Empty(P3) = false
      Empty(P4) = true
      Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;two&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;*&#34;, &#34;two&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;two&#34; }
      First(P4) = { &#34;*&#34; }
      Preselected(P3) = Preselected(P4) = Empty(P3) = false
      Empty(P4) = true
      Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;two&#34; }
      Select(P4) = First(P4) + Follow(one) = { &#34;*&#34;, &#34;two&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;*&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;*&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P6) = { &#34;*&#34; }
      First(P7) = { }
      Preselected(P6) = Preselected(P7) = Empty(P6) = false
      Empty(P7) = true
      Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P6) = First(P6) = { &#34;*&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P1) and Select(P2) is not empty, as is the intersection of Select(P3) and Select(P4) and the intersection of Select(P6) and Select(P7); hence, the grammar is not deterministic, and the type definition is not valid. If a decoder encounters two or more unrecognized elements in a row, then it cannot determine whether this represents one instance or more than one instance of the &#34;one&#34; component. Even without unrecognized elements, there is still a problem that an encoding could contain an indeterminate number of &#34;one&#34; components using an extension that generates no elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P1）和Select（P2）的交点不是空的，Select（P3）和Select（P4）的交点以及Select（P6）和Select（P7）的交点也是空的；因此，语法是不确定的，类型定义是无效的。如果解码器在一行中遇到两个或多个无法识别的元素，则无法确定这是表示“一”组件的一个实例还是多个实例。即使没有无法识别的元素，仍然存在一个问题，即使用不生成元素的扩展，编码可能包含数量不确定的“一”组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The non-determinism cannot be resolved with a UNIFORM-INSERTIONS encoding instruction. Consider this revised type definition using the UNIFORM-INSERTIONS encoding instruction:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非确定性不能用统一插入编码指令来解决。使用统一插入编码指令考虑此修订类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF one [GROUP] [UNIFORM-INSERTIONS] CHOICE {
          two    UTF8String,
          ... -- Extension insertion point (I1).
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF one [GROUP] [UNIFORM-INSERTIONS] CHOICE {
          two    UTF8String,
          ... -- Extension insertion point (I1).
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P8:  one ::= &#34;*&#34;
      P9:  one ::= &#34;*1&#34; I1
      P5:  two ::= &#34;two&#34;
      P10: I1 ::= &#34;*1&#34; I1
      P7:  I1 ::=
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P8:  one ::= &#34;*&#34;
      P9:  one ::= &#34;*1&#34; I1
      P5:  two ::= &#34;two&#34;
      P10: I1 ::= &#34;*1&#34; I1
      P7:  I1 ::=
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;two&#34; }
      First(P8) = { &#34;*&#34; }
      First(P9) = { &#34;*1&#34; }
      Preselected(P3) = Preselected(P8) = Preselected(P9) = false
      Empty(P3) = Empty(P8) = Empty(P9) = false
      Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;two&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
      Select(P9) = First(P9) = { &#34;*1&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;two&#34; }
      First(P8) = { &#34;*&#34; }
      First(P9) = { &#34;*1&#34; }
      Preselected(P3) = Preselected(P8) = Preselected(P9) = false
      Empty(P3) = Empty(P8) = Empty(P9) = false
      Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;two&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
      Select(P9) = First(P9) = { &#34;*1&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P10) = { &#34;*1&#34; }
      First(P7) = { }
      Preselected(P10) = Preselected(P7) = Empty(P10) = false
      Empty(P7) = true
      Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; }
      Select(P10) = First(P10) = { &#34;*1&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P10) = { &#34;*1&#34; }
      First(P7) = { }
      Preselected(P10) = Preselected(P7) = Empty(P10) = false
      Empty(P7) = true
      Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; }
      Select(P10) = First(P10) = { &#34;*1&#34; }
      Select(P7) = First(P7) + Follow(I1) = { &#34;two&#34;, &#34;*&#34;, &#34;*1&#34;, &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P1) and Select(P2) is now empty, but the intersection of Select(P10) and Select(P7) is not; hence, the grammar is not deterministic, and the type definition is not valid. The problem of an indeterminate number of &#34;one&#34; components from an extension that generates no elements has been solved. However, if a decoder encounters a series of elements with the same name, it cannot determine whether this represents one instance or more than one instance of the &#34;one&#34; component.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择（P1）和选择（P2）的交点现在为空，但选择（P10）和选择（P7）的交点不为空；因此，语法是不确定的，类型定义是无效的。从一个不生成任何元素的扩展中得到数量不确定的“一”个组件的问题已经得到解决。但是，如果解码器遇到一系列具有相同名称的元素，则无法确定这是表示“一”组件的一个实例还是多个实例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The non-determinism can be fully resolved with a SINGULAR-INSERTIONS encoding instruction. Consider this revised type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
非确定性可以通过单数插入编码指令完全解决。考虑修改后的类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF one [GROUP] [SINGULAR-INSERTIONS] CHOICE {
          two    UTF8String,
          ... -- Extension insertion point (I1).
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      SEQUENCE OF one [GROUP] [SINGULAR-INSERTIONS] CHOICE {
          two    UTF8String,
          ... -- Extension insertion point (I1).
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The associated grammar is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
相关语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P8:  one ::= &#34;*&#34;
      P5:  two ::= &#34;two&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      P1:  S ::= one S
      P2:  S ::=
      P3:  one ::= two
      P8:  one ::= &#34;*&#34;
      P5:  two ::= &#34;two&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This grammar leads to the following sets and predicates:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此语法将生成以下集合和谓词：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;two&#34;, &#34;*&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;two&#34;, &#34;*&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P1) = { &#34;two&#34;, &#34;*&#34; }
      First(P2) = { }
      Preselected(P1) = Preselected(P2) = Empty(P1) = false
      Empty(P2) = true
      Follow(S) = { &#34;$&#34; }
      Select(P1) = First(P1) = { &#34;two&#34;, &#34;*&#34; }
      Select(P2) = First(P2) + Follow(S) = { &#34;$&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;two&#34; }
      First(P8) = { &#34;*&#34; }
      Preselected(P3) = Preselected(P8) = false
      Empty(P3) = Empty(P8) = false
      Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;two&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      First(P3) = { &#34;two&#34; }
      First(P8) = { &#34;*&#34; }
      Preselected(P3) = Preselected(P8) = false
      Empty(P3) = Empty(P8) = false
      Follow(one) = { &#34;two&#34;, &#34;*&#34;, &#34;$&#34; }
      Select(P3) = First(P3) = { &#34;two&#34; }
      Select(P8) = First(P8) = { &#34;*&#34; }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intersection of Select(P1) and Select(P2) is empty, as is the intersection of Select(P3) and Select(P8); hence, the grammar is deterministic, and the type definition is valid. A decoder now knows that every extension to the &#34;one&#34; component will generate a single element, so the correct number of &#34;one&#34; components will be decoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Select（P1）和Select（P2）的交点为空，Select（P3）和Select（P8）的交点也是空的；因此，语法是确定性的，类型定义是有效的。解码器现在知道“一”组件的每个扩展都将生成一个元素，因此正确数量的“一”组件将被解码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix C. Extension and Versioning Examples
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录C.扩展和版本控制示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix is non-normative.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录为非规范性附录。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.1. Valid Extensions for Insertion Encoding Instructions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.1. 插入编码指令的有效扩展
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first example shows extensions that satisfy the HOLLOW-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第一个示例显示了满足空心插入编码指令的扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [HOLLOW-INSERTIONS] CHOICE {
          one    BOOLEAN,
          ...,
          two    [ATTRIBUTE] INTEGER,
          three  [GROUP] SEQUENCE {
              four  [ATTRIBUTE] UTF8String,
              five  [ATTRIBUTE] INTEGER OPTIONAL,
              ...
          },
          six    [GROUP] CHOICE {
              seven  [ATTRIBUTE] BOOLEAN,
              eight  [ATTRIBUTE] INTEGER
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [HOLLOW-INSERTIONS] CHOICE {
          one    BOOLEAN,
          ...,
          two    [ATTRIBUTE] INTEGER,
          three  [GROUP] SEQUENCE {
              four  [ATTRIBUTE] UTF8String,
              five  [ATTRIBUTE] INTEGER OPTIONAL,
              ...
          },
          six    [GROUP] CHOICE {
              seven  [ATTRIBUTE] BOOLEAN,
              eight  [ATTRIBUTE] INTEGER
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;two&#34; and &#34;six&#34; components generate only attributes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“两个”和“六个”组件仅生成属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;three&#34; component in its current form does not generate elements. Any extension to the &#34;three&#34; component will need to do likewise to avoid breaking forward compatibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当前形式的“三”组件不生成元素。对“三个”组件的任何扩展都需要这样做，以避免破坏前向兼容性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second example shows extensions that satisfy the SINGULAR-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二个示例显示了满足SINGULAR-INSERTIONS编码指令的扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [SINGULAR-INSERTIONS] CHOICE {
          one    BOOLEAN,
          ...,
          two    INTEGER,
          three  [GROUP] SEQUENCE {
              four   [ATTRIBUTE] UTF8String,
              five   INTEGER
          },
          six    [GROUP] CHOICE {
              seven  BOOLEAN,
              eight  INTEGER
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [SINGULAR-INSERTIONS] CHOICE {
          one    BOOLEAN,
          ...,
          two    INTEGER,
          three  [GROUP] SEQUENCE {
              four   [ATTRIBUTE] UTF8String,
              five   INTEGER
          },
          six    [GROUP] CHOICE {
              seven  BOOLEAN,
              eight  INTEGER
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;two&#34; component will always generate a single &lt;two&gt; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“两个”组件将始终生成一个&lt;two&gt;元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;three&#34; component will always generate a single &lt;five&gt; element. It will also generate a &#34;four&#34; attribute, but any number of attributes is allowed by the SINGULAR-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“三”组件将始终生成一个&lt;5&gt;元素。它还将生成一个“四”属性，但SINGULAR-INSERTIONS编码指令允许任何数量的属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;six&#34; component will either generate a single &lt;seven&gt; element or a single &lt;eight&gt; element. Either case will satisfy the requirement that there will be a single element in any given encoding of the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“六”组件将生成单个&lt;seven&gt;元素或单个&lt;seek&gt;元素。任何一种情况都将满足在扩展的任何给定编码中都有一个元素的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third example shows extensions that satisfy the UNIFORM-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第三个示例显示了满足统一插入编码指令的扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [UNIFORM-INSERTIONS] CHOICE {
          one    BOOLEAN,
          ...,
          two    INTEGER,
          three  [GROUP] SEQUENCE SIZE(1..MAX) OF four INTEGER,
          five   [GROUP] SEQUENCE {
              six    [ATTRIBUTE] UTF8String OPTIONAL,
              seven  INTEGER
          },
          eight  [GROUP] CHOICE {
              nine   BOOLEAN,
              ten    [GROUP] SEQUENCE SIZE(1..MAX) OF eleven INTEGER
          }
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      [UNIFORM-INSERTIONS] CHOICE {
          one    BOOLEAN,
          ...,
          two    INTEGER,
          three  [GROUP] SEQUENCE SIZE(1..MAX) OF four INTEGER,
          five   [GROUP] SEQUENCE {
              six    [ATTRIBUTE] UTF8String OPTIONAL,
              seven  INTEGER
          },
          eight  [GROUP] CHOICE {
              nine   BOOLEAN,
              ten    [GROUP] SEQUENCE SIZE(1..MAX) OF eleven INTEGER
          }
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;two&#34; component will always generate a single &lt;two&gt; element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“两个”组件将始终生成一个&lt;two&gt;元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;three&#34; component will always generate one or more &lt;four&gt; elements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“三”组件将始终生成一个或多个&lt;four&gt;元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;five&#34; component will always generate a single &lt;seven&gt; element. It may also generate a &#34;six&#34; attribute, but any number of attributes is allowed by the UNIFORM-INSERTIONS encoding instruction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“五”组件将始终生成一个&lt;seven&gt;元素。它还可以生成一个“六”属性，但统一插入编码指令允许任何数量的属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;eight&#34; component will either generate a single &lt;nine&gt; element or one or more &lt;eleven&gt; elements. Either case will satisfy the requirement that there must be one or more elements with the same name in any given encoding of the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“8”组件将生成单个&lt;9&gt;元素或一个或多个&lt;11&gt;元素。任何一种情况都将满足以下要求：在扩展的任何给定编码中，必须有一个或多个同名元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.2. Versioning Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
C.2. 版本控制示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Making extensions that are not forward compatible is permitted provided that the incompatibility is signalled with a version indicator attribute.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
允许生成不向前兼容的扩展，前提是使用版本指示符属性表示不兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose that version 1.0 of a specification contains the following type definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设规范的1.0版包含以下类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ...) DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two  BOOLEAN,
             ...
         },
         ...
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ...) DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two  BOOLEAN,
             ...
         },
         ...
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An attribute is to be added to the CHOICE for version 1.1. This change is not forward compatible since it does not satisfy the SINGULAR-INSERTIONS encoding instruction. Therefore, the version indicator attribute must be updated at the same time (or added if it wasn&#39;t already present). This results in the following new type definition for version 1.1:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将在版本1.1的选项中添加一个属性。此更改不向前兼容，因为它不满足SINGULAR-INSERTIONS编码指令。因此，版本指示符属性必须同时更新（如果还不存在，则添加）。这将导致版本1.1的以下新类型定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34;) DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two    BOOLEAN,
             ...,
             three  [ATTRIBUTE] INTEGER -- Added in Version 1.1
         },
         ...
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34;) DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two    BOOLEAN,
             ...,
             three  [ATTRIBUTE] INTEGER -- Added in Version 1.1
         },
         ...
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a version 1.1 conformant application hasn&#39;t used the version 1.1 extension in a value of MyMessageType, then it is allowed to set the value of the version attribute to &#34;1.0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果符合版本1.1的应用程序没有在MyMessageType的值中使用版本1.1扩展，则允许将版本属性的值设置为“1.0”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A pair of elements is added to the CHOICE for version 1.2. Again the change does not satisfy the SINGULAR-INSERTIONS encoding instruction. The type definition for version 1.2 is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版本1.2的选项中添加了一对元素。同样，该更改不满足SINGULAR-INSERTIONS编码指令。版本1.2的类型定义为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34; | &#34;1.2&#34;)
                          DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two    BOOLEAN,
             ...,
             three  [ATTRIBUTE] INTEGER, -- Added in Version 1.1
             four   [GROUP] SEQUENCE {
                 five  UTF8String,
                 six   GeneralizedTime
             } -- Added in version 1.2
         },
         ...
      }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      MyMessageType ::= SEQUENCE {
         version  [ATTRIBUTE] [VERSION-INDICATOR]
                      UTF8String (&#34;1.0&#34;, ..., &#34;1.1&#34; | &#34;1.2&#34;)
                          DEFAULT &#34;1.0&#34;,
         one      [GROUP] [SINGULAR-INSERTIONS] CHOICE {
             two    BOOLEAN,
             ...,
             three  [ATTRIBUTE] INTEGER, -- Added in Version 1.1
             four   [GROUP] SEQUENCE {
                 five  UTF8String,
                 six   GeneralizedTime
             } -- Added in version 1.2
         },
         ...
      }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a version 1.2 conformant application hasn&#39;t used the version 1.2 extension in a value of MyMessageType, then it is allowed to set the value of the version attribute to &#34;1.1&#34;. If it hasn&#39;t used either of the extensions, then it is allowed to set the value of the version attribute to &#34;1.0&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果符合版本1.2的应用程序没有在MyMessageType的值中使用版本1.2扩展，则允许将版本属性的值设置为“1.1”。如果未使用任何一个扩展，则允许将version属性的值设置为“1.0”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Author&#39;s Address
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dr. Steven Legg eB2Bcom Suite 3, Woodhouse Corporate Centre 935 Station Street Box Hill North, Victoria 3129 AUSTRALIA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Steven Legg博士eB2Bcom澳大利亚维多利亚州博克斯山北站街935号伍德豪斯企业中心3号套房，邮编：3129
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +61 3 9896 7830
   Fax:   +61 3 9896 7801
   EMail: steven.legg@eb2bcom.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +61 3 9896 7830
   Fax:   +61 3 9896 7801
   EMail: steven.legg@eb2bcom.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）IETF信托基金（2007年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其包含的信息以“原样”为基础提供，贡献者、他/她所代表或赞助的组织（如有）、互联网协会、IETF信托基金和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
确认
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC编辑功能的资金目前由互联网协会提供。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
