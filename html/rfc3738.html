<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 3738:  Wave and Equation Based Rate Control (WEBRC) Building Block 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC3738 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3738</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3738">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 3738:  Wave and Equation Based Rate Control (WEBRC) Building Block  中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc3738">
              https://datatracker.ietf.org/doc/html/rfc3738
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 3738</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                            M. Luby
Request for Comments: 3738                              Digital Fountain
Category: Experimental                                          V. Goyal
                                                                  M.I.T.
                                                              April 2004
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                            M. Luby
Request for Comments: 3738                              Digital Fountain
Category: Experimental                                          V. Goyal
                                                                  M.I.T.
                                                              April 2004
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Wave and Equation Based Rate Control (WEBRC) Building Block
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
基于波动和方程的速率控制（WEBRC）构建块
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of this Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
本备忘录的状况
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这份备忘录为互联网社区定义了一个实验性协议。它没有规定任何类型的互联网标准。要求进行讨论并提出改进建议。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2004). All Rights Reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2004年）。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies Wave and Equation Based Rate Control (WEBRC), which provides rate and congestion control for data delivery. WEBRC is specifically designed to support protocols using IP multicast. It provides multiple-rate, congestion-controlled delivery to receivers, i.e., different receivers joined to the same session may be receiving packets at different rates depending on the bandwidths of their individual connections to the sender and on competing traffic along these connections. WEBRC requires no feedback from receivers to the sender, i.e., it is a completely receiver-driven congestion control protocol. Thus, it is designed to scale to potentially massive numbers of receivers attached to a session from a single sender. Furthermore, because each individual receiver adjusts to the available bandwidth between the sender and that receiver, there is the potential to deliver data to each individual receiver at the fastest possible rate for that receiver, even in a highly heterogeneous network architecture, using a single sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档指定了基于波动和方程的速率控制（WEBRC），它为数据传输提供速率和拥塞控制。WEBRC专门设计用于支持使用IP多播的协议。它向接收机提供多速率、拥塞控制的传送，即，加入同一会话的不同接收机可能以不同速率接收分组，这取决于它们到发送方的各个连接的带宽以及这些连接上的竞争流量。WEBRC不需要从接收者到发送者的反馈，即它是一个完全由接收者驱动的拥塞控制协议。因此，它被设计成从单个发送方扩展到连接到会话的潜在大量接收方。此外，由于每个单独的接收器都会根据发送方和该接收器之间的可用带宽进行调整，因此即使在高度异构的网络体系结构中，也有可能使用单个发送方以该接收器可能的最快速率向每个单独的接收器发送数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction. . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Rationale . . . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  Functionality . . . . . . . . . . . . . . . . . . . . . . . .   6
       3.1. Sender Operation . . . . . . . . . . . . . . . . . . . .   9
            3.1.1. Sender inputs and initialization. . . . . . . . .   9
            3.1.2. Sending packets to the session. . . . . . . . . .  10
       3.2. Receiver Operation . . . . . . . . . . . . . . . . . . .  12
            3.2.1. Receiver inputs and initialization. . . . . . . .  12
            3.2.2. Receiver measurements and calculations. . . . . .  13
                   3.2.2.1. Average loss probability . . . . . . . .  13
                   3.2.2.2. Average round-trip time. . . . . . . . .  16
                   3.2.2.3. Rate Equation. . . . . . . . . . . . . .  16
                   3.2.2.4. Epochs . . . . . . . . . . . . . . . . .  17
                   3.2.2.5. Average reception rate . . . . . . . . .  17
                   3.2.2.6. Slow start . . . . . . . . . . . . . . .  19
                   3.2.2.7. Target rate. . . . . . . . . . . . . . .  20
            3.2.3. Receiver events . . . . . . . . . . . . . . . . .  20
                   3.2.3.1. Packet reception . . . . . . . . . . . .  20
                   3.2.3.2. First packet after join. . . . . . . . .  20
                   3.2.3.3. Time slot change . . . . . . . . . . . .  20
                   3.2.3.4. Loss event . . . . . . . . . . . . . . .  21
                   3.2.3.5. Epoch change . . . . . . . . . . . . . .  21
                   3.2.3.6. Join the next higher layer . . . . . . .  21
                   3.2.3.7. Join timeout . . . . . . . . . . . . . .  23
                   3.2.3.8. Exceptional timeouts . . . . . . . . . .  23
   4.  Applicability Statement . . . . . . . . . . . . . . . . . . .  23
       4.1. Environmental Requirements and Considerations. . . . . .  23
   5.  Packet Header Fields. . . . . . . . . . . . . . . . . . . . .  25
       5.1. Short Format Congestion Control Information. . . . . . .  26
       5.2. Long Format Congestion Control Information . . . . . . .  27
   6.  Requirements From Other Building Blocks . . . . . . . . . . .  28
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  28
   8.  References. . . . . . . . . . . . . . . . . . . . . . . . . .  29
       8.1. Normative References . . . . . . . . . . . . . . . . . .  29
       8.2. Informative References . . . . . . . . . . . . . . . . .  30
   9.  Authors&#39; Addresses. . . . . . . . . . . . . . . . . . . . . .  31
   10. Full Copyright Statement. . . . . . . . . . . . . . . . . . .  32
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction. . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Rationale . . . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  Functionality . . . . . . . . . . . . . . . . . . . . . . . .   6
       3.1. Sender Operation . . . . . . . . . . . . . . . . . . . .   9
            3.1.1. Sender inputs and initialization. . . . . . . . .   9
            3.1.2. Sending packets to the session. . . . . . . . . .  10
       3.2. Receiver Operation . . . . . . . . . . . . . . . . . . .  12
            3.2.1. Receiver inputs and initialization. . . . . . . .  12
            3.2.2. Receiver measurements and calculations. . . . . .  13
                   3.2.2.1. Average loss probability . . . . . . . .  13
                   3.2.2.2. Average round-trip time. . . . . . . . .  16
                   3.2.2.3. Rate Equation. . . . . . . . . . . . . .  16
                   3.2.2.4. Epochs . . . . . . . . . . . . . . . . .  17
                   3.2.2.5. Average reception rate . . . . . . . . .  17
                   3.2.2.6. Slow start . . . . . . . . . . . . . . .  19
                   3.2.2.7. Target rate. . . . . . . . . . . . . . .  20
            3.2.3. Receiver events . . . . . . . . . . . . . . . . .  20
                   3.2.3.1. Packet reception . . . . . . . . . . . .  20
                   3.2.3.2. First packet after join. . . . . . . . .  20
                   3.2.3.3. Time slot change . . . . . . . . . . . .  20
                   3.2.3.4. Loss event . . . . . . . . . . . . . . .  21
                   3.2.3.5. Epoch change . . . . . . . . . . . . . .  21
                   3.2.3.6. Join the next higher layer . . . . . . .  21
                   3.2.3.7. Join timeout . . . . . . . . . . . . . .  23
                   3.2.3.8. Exceptional timeouts . . . . . . . . . .  23
   4.  Applicability Statement . . . . . . . . . . . . . . . . . . .  23
       4.1. Environmental Requirements and Considerations. . . . . .  23
   5.  Packet Header Fields. . . . . . . . . . . . . . . . . . . . .  25
       5.1. Short Format Congestion Control Information. . . . . . .  26
       5.2. Long Format Congestion Control Information . . . . . . .  27
   6.  Requirements From Other Building Blocks . . . . . . . . . . .  28
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  28
   8.  References. . . . . . . . . . . . . . . . . . . . . . . . . .  29
       8.1. Normative References . . . . . . . . . . . . . . . . . .  29
       8.2. Informative References . . . . . . . . . . . . . . . . .  30
   9.  Authors&#39; Addresses. . . . . . . . . . . . . . . . . . . . . .  31
   10. Full Copyright Statement. . . . . . . . . . . . . . . . . . .  32
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies Wave and Equation Based Rate Control (WEBRC). WEBRC is a congestion control building block that is designed to be massively scalable when used with the IP multicast network service. WEBRC is also suitable as the basis for unicast congestion control, but this is outside the scope of this document. WEBRC is designed to compete fairly with TCP and similar congestion-controlled sessions. WEBRC can be used as a congestion control protocol for any type of data delivery, including reliable content delivery and streaming delivery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了基于波动和方程的速率控制（WEBRC）。WEBRC是一个拥塞控制构建块，当与IP多播网络服务一起使用时，它被设计成可大规模扩展的。WEBRC也适合作为单播拥塞控制的基础，但这超出了本文的范围。WEBRC旨在与TCP和类似的拥塞控制会话公平竞争。WEBRC可以用作任何类型数据传输的拥塞控制协议，包括可靠的内容传输和流式传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC is a receiver-driven congestion control protocol in the spirit of [5] and [18]. This means that all measurements and decisions to raise or lower the reception rate are made by each individual receiver, and these decisions are acted upon by sending join and leave messages for channels to the network. A receiver using WEBRC adjusts its reception rate without regard for other concerns such as reliability. This is different from TCP, where the congestion control protocol and the reliability protocol are intricately interwoven.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC是一种接收器驱动的拥塞控制协议，符合[5]和[18]的精神。这意味着提高或降低接收速率的所有测量和决定由每个单独的接收器作出，这些决定通过向网络发送信道的加入和离开消息来执行。使用WEBRC的接收器调整其接收速率，而不考虑可靠性等其他问题。这与TCP不同，TCP的拥塞控制协议和可靠性协议错综复杂地交织在一起。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC takes the same basic equation-based approach as TFRC [9]. In particular, each WEBRC receiver measures parameters that are plugged into a TCP-like equation to compute the receiver target reception rate and adjusts its reception rate up and down to closely approximate the target reception rate. The sender sends packets to multiple channels; one channel is called the base channel and the remaining channels are called wave channels. Each wave channel follows the same pattern of packet rate transmission spread out over equally-spaced intervals of time. The pattern of each wave is that it starts at a high rate and the rate decreases gradually and continually over a long period of time. (Picture an infinite sequence of waves.) The receiver increases its reception rate by joining the next wave channel earlier in the descent of the wave than it joined the previous wave channel, and the receiver decreases its reception rate by joining the next wave channel later in the descent of the wave than it joined the previous wave channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC采用与TFRC相同的基于基本方程的方法[9]。特别是，每个WEBRC接收器测量插入类似TCP的等式中的参数，以计算接收器目标接收速率，并上下调整其接收速率以接近目标接收速率。发送方向多个信道发送数据包；一个通道称为基本通道，其余通道称为波通道。每个波信道遵循相同的分组速率传输模式，在等间隔的时间间隔内传播。每个波的模式是，它以高速率开始，并且在很长一段时间内，速率逐渐和持续地降低。（想象一个无限的波序列。）接收器通过在波下降时比加入前一个波通道更早地加入下一个波通道来增加其接收速率，并且接收器通过在波下降时比加入前一个波通道更晚地加入下一个波通道来降低其接收速率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The wave channels are ordered at each point in time from a lowest layer to a highest layer. At each point in time, the lowest layer is the wave channel that among all active wave channels is nearest to the end of its active period; the highest layer is the wave channel that is furthest from the end of its active period. Because waves are dynamically becoming active and quiescent over time, the designation of which wave channel is at which layer changes dynamically over time. In addition to being joined to the base channel, at each point in time a receiver is joined to a consecutive
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
波通道在每个时间点从最低层到最高层排列。在每个时间点，最底层是所有活动波道中最接近其活动周期结束的波道；最高层是距离其活动周期末端最远的波道。由于波浪随着时间的推移动态地变为活动和静止，因此指定哪个波道位于哪个层随时间动态变化。除了连接到基本信道外，在每个时间点，接收机都连接到连续信道
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
set of layers starting at the lowest layer and proceeding towards the highest.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从最低层开始向最高层前进的一组层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC introduces a natural notion of a multicast round-trip time (MRTT). An MRTT is measured individually by each receiver and averaged as a substitute for conventional unicast round-trip time (RTT). Because the throughput of a TCP session depends strongly on RTT, having some measure of RTT is essential in making the WEBRC equation-based rate control protocol &#34;TCP-friendly&#34;. The use of the MRTT also helps to coordinate and equalize the reception rates of proximate receivers joined to a session behind a bottleneck link. This implies that packets for the session that flow through the bottleneck link are on average sent to almost all downstream receivers, and thus the efficiencies of multicast are realized. Furthermore, WEBRC is designed to be massively scalable in the sense that the sender is insensitive to the number of receivers joined to a multicast session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC引入了多播往返时间（MRTT）的自然概念。MRTT由每个接收机单独测量，并作为传统单播往返时间（RTT）的替代物进行平均。由于TCP会话的吞吐量在很大程度上取决于RTT，因此有一些RTT的度量对于使基于WEBRC等式的速率控制协议“TCP友好”至关重要。MRTT的使用还有助于协调和均衡加入瓶颈链路后会话的近距离接收机的接收速率。这意味着通过瓶颈链路的会话数据包平均发送到几乎所有下游接收器，从而实现了多播的效率。此外，WEBRC被设计为具有大规模可扩展性，因为发送方对加入多播会话的接收方数量不敏感。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC is designed for applications that use a fixed packet size and vary their packet reception rates in response to congestion. WEBRC is designed to be reasonably fair when competing for bandwidth with TCP flows, where a flow is &#34;reasonably fair&#34; if its reception rate is generally within a factor of two of the reception rate of a TCP flow under the same conditions. However WEBRC has a much lower variation of throughput over time compared to TCP, which makes it more suitable for applications such as telephony or streaming media where a relatively smooth rate is of importance. The penalty of having smoother throughput than TCP while competing fairly for bandwidth is that WEBRC responds more slowly than TCP to changes in available bandwidth.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC是为使用固定数据包大小并根据拥塞情况改变数据包接收速率的应用程序而设计的。当与TCP流竞争带宽时，WEBRC的设计是合理公平的，如果在相同条件下，一个流的接收速率通常在TCP流接收速率的两倍以内，则该流是“合理公平的”。然而，与TCP相比，WEBRC的吞吐量随时间的变化要小得多，这使得它更适合于相对平滑的速率非常重要的应用程序，如电话或流媒体。在公平竞争带宽的同时拥有比TCP更平滑的吞吐量的代价是WEBRC对可用带宽变化的响应比TCP慢。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver measures and performs the calculation of congestion control parameters (e.g., the average loss probability, the average MRTT) and makes decisions on how to increase or decrease its rate based on these parameters. The receiver-based approach is well suited to an application where the sender is handling many concurrent connections and therefore WEBRC is suitable as a building block for multicast congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收器测量并计算拥塞控制参数（例如，平均丢失概率、平均MRTT），并根据这些参数决定如何增加或减少其速率。基于接收者的方法非常适合发送者处理多个并发连接的应用，因此WEBRC适合作为多播拥塞控制的构建块。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The paper [16] and technical report [15] provide much of the rationale and intuition for the WEBRC design and describe some preliminary simulations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
论文[16]和技术报告[15]提供了WEBRC设计的许多基本原理和直觉，并描述了一些初步模拟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document describes a building block as defined in RFC 3048 [4]. This document describes a congestion control building block that conforms to RFC 2357 [3]. This document is a product of the IETF RMT WG and follows the general guidelines provided in RFC 3269 [2]. The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件描述了RFC 3048[4]中定义的构建块。本文档描述了符合RFC 2357[3]的拥塞控制构建块。本文件是IETF RMT工作组的产品，遵循RFC 3269[2]中提供的一般指南。关键词“必须”、“不得”、“必需”、“应”、“不得”，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
&#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in BCP 14, RFC 2119 [1].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的“应”、“不应”、“建议”、“可”和“可选”应按照BCP 14、RFC 2119[1]中的说明进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Statement of Intent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
意向书
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo contains part of the definitions necessary to fully specify a Reliable Multicast Transport protocol in accordance with RFC 2357. As per RFC 2357, the use of any reliable multicast protocol in the Internet requires an adequate congestion control scheme. This document specifies an experimental congestion control scheme. While waiting for initial deployment and experience to show this scheme to be effective and scalable, the IETF publishes this scheme in the &#34;Experimental&#34; category.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录包含根据RFC 2357完全指定可靠多播传输协议所需的部分定义。根据RFC2357，在互联网上使用任何可靠的多播协议都需要适当的拥塞控制方案。本文件规定了一个实验性的拥塞控制方案。在等待初始部署和经验证明此方案有效和可扩展时，IETF将此方案发布为“实验”类别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is the intent of the Reliable Multicast Transport (RMT) Working Group to re-submit the specification as an IETF Proposed Standard as soon as the scheme is deemed adequate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可靠多播传输（RMT）工作组的目的是，一旦方案被认为是适当的，就将规范作为IETF建议的标准重新提交。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Rationale
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 根本原因
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC provides congestion control for massively scalable protocols using the IP multicast network service. The congestion control that WEBRC provides is common to a variety of applications, including reliable content delivery and streaming applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC使用IP多播网络服务为大规模可扩展协议提供拥塞控制。WEBRC提供的拥塞控制对于各种应用程序都是通用的，包括可靠的内容交付和流式应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC is designed to provide congestion control for all packets that are sent to a session. A session comprises multiple channels originating at a single sender that are used for some period of time to carry packets pertaining to the transmission of one or more objects that can be of interest to receivers. The logic behind defining a session as originating from a single sender is that this is the right granularity to regulate packet traffic via congestion control. The rationale for providing congestion control that uses multiple channels within the same session is that this allows the data on the channels to be layered, which in turn allows each receiver to control its reception rate by joining and leaving channels during its participation in the session. There are advantages to layered data for streaming, where the most important data can be sent to the lower layers and incrementally valuable data to the higher layers. For reliable content delivery, as described in [13], an application can send in packets encoded data generated from an object in such a way that the arrival of enough packets by a receiver is sufficient to reliably reconstruct the original object. A primary advantage of WEBRC is that each receiver controls it reception rate independent of other receivers. Thus, for example, a receiver with a slow connection to the sender does not slow down the receivers with faster connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC旨在为发送到会话的所有数据包提供拥塞控制。会话包括源自单个发送方的多个信道，这些信道在一段时间内用于承载与一个或多个对象的传输有关的分组，这些对象可能是接收方感兴趣的。将会话定义为源自单个发送方的逻辑是，这是通过拥塞控制调节数据包流量的正确粒度。提供在同一会话中使用多个信道的拥塞控制的基本原理是，这允许对信道上的数据进行分层，从而允许每个接收机通过在其参与会话期间加入和离开信道来控制其接收速率。分层数据流有很多优点，其中最重要的数据可以发送到较低的层，而有价值的数据可以增量发送到较高的层。对于可靠的内容交付，如[13]中所述，应用程序可以以这样的方式发送从对象生成的包编码数据，即接收器到达足够的包足以可靠地重建原始对象。WEBRC的一个主要优点是每个接收器独立于其他接收器控制其接收速率。因此，例如，与发送方连接较慢的接收器不会使连接较快的接收器变慢。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are coding techniques that provide massively scalable reliability and asynchronous delivery which are compatible with WEBRC, e.g., as described in [11]. When combined the result is a massively scalable, reliable, asynchronous content delivery protocol that is network friendly. WEBRC also provides congestion control that is suitable for streaming applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有一些编码技术提供了与WEBRC兼容的大规模可扩展可靠性和异步交付，如[11]所述。当结合起来时，结果是一个大规模可扩展、可靠、异步的内容交付协议，它是网络友好的。WEBRC还提供适用于流应用程序的拥塞控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC avoids using techniques that are not massively scalable. For example, WEBRC does not provide any mechanisms for sending information from receivers to senders, although this does not rule out protocols that both use WEBRC and that send information from receivers to senders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC避免使用不可大规模扩展的技术。例如，WEBRC不提供任何从接收者向发送者发送信息的机制，尽管这并不排除同时使用WEBRC和从接收者向发送者发送信息的协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC provides congestion control that can be tuned for different applications that may have differing application requirements. For example, a content delivery protocol may aggressively strive to use all available bandwidth between receivers and the sender, and thus to maintain fairness it must drastically reduce its rate when there is competing traffic. On the other hand, a streaming delivery protocol may strive to maintain a constant rate instead of trying to use all available bandwidth, and thus it may not reduce its rate as fast when there is competing traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC提供了拥塞控制，可以针对可能具有不同应用程序需求的不同应用程序进行调整。例如，内容交付协议可以积极地努力使用接收方和发送方之间的所有可用带宽，因此，为了保持公平性，当存在竞争流量时，它必须大幅降低其速率。另一方面，流传送协议可能努力保持恒定速率，而不是尝试使用所有可用带宽，因此当存在竞争流量时，它可能不会以同样快的速度降低速率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC does not provide any support beyond congestion control, and thus WEBRC is to be combined with other building blocks to provide a complete protocol instantiation. For example, WEBRC does not provide any means that can be used to identify which session each received packet belongs to. As another example, WEBRC does not provide support for identifying which object each packet is carrying information about.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC不提供拥塞控制以外的任何支持，因此WEBRC将与其他构建块结合，以提供完整的协议实例化。例如，WEBRC不提供任何可用于识别每个接收数据包所属会话的方法。作为另一个例子，WEBRC不支持识别每个数据包携带的信息是关于哪个对象的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Functionality
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 功能
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A WEBRC session comprises a logically related set of channels originating from a single sender that are used for some period of time to carry data packets with a header carrying WEBRC Congestion Control Information. When packets are received, they are first checked to see that they belong to the appropriate session before WEBRC is applied. A session label defined by a protocol instantiation may be carried in each packet to identify to which session the packet belongs. For example, if LCT [12] is being used with the session, then the sender IP address together with the Transport Session Identifier supported by LCT would be used to determine which session a received packet belongs to. The particular details of how this filtering is performed is outside the scope of this document. In the remainder of this document, references to channels are always within the scope of a single session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC会话包括源自单个发送方的逻辑相关的信道集，这些信道在一段时间内用于承载具有承载WEBRC拥塞控制信息的报头的数据分组。当收到数据包时，在应用WEBRC之前，首先检查它们是否属于适当的会话。可以在每个分组中携带由协议实例化定义的会话标签，以标识分组所属的会话。例如，如果LCT[12]与会话一起使用，则发送方IP地址以及LCT支持的传输会话标识符将用于确定接收到的数据包属于哪个会话。如何执行此筛选的具体细节不在本文档的范围内。在本文档的其余部分中，对通道的引用始终在单个会话的范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A channel can be uniquely identified at the network layer by a (sender IP address, multicast group address) pair, and this is the address to which the receiver sends messages to join and leave the channel. The channels used by a WEBRC session are mapped uniquely to consecutive channel numbers. In each packet sent to a channel, the channel number that corresponds to the channel is carried in the WEBRC Congestion Control Information. A WEBRC receiver uses the channel number to determine which channel within a session a packet is received from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
信道可以在网络层通过（发送方IP地址、多播组地址）对进行唯一标识，这是接收方发送消息以加入和离开信道的地址。WEBRC会话使用的通道被唯一地映射到连续的通道号。在发送到某个信道的每个数据包中，与该信道对应的信道号在WEBRC拥塞控制信息中携带。WEBRC接收器使用通道号来确定从会话中的哪个通道接收数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the sender, time is partitioned into time slots, each of duration TSD seconds. There is a fixed number T of time slot indices associated with a session. As time progresses, the current time slot index increases by one modulo T each TSD seconds. The current time slot index CTSI is carried in the WEBRC Congestion Control Information. This allows receivers to perform very coarse-grained synchronization within a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在发送方，时间被划分为时隙，每个时隙的持续时间为TSD秒。与会话相关联的时隙索引有固定数量T。随着时间的推移，当前时隙索引每TSD秒增加一个模T。当前时隙索引CTSI包含在WEBRC拥塞控制信息中。这允许接收方在会话中执行非常粗粒度的同步。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC congestion control is achieved by having the sender send packets associated with a given session to several different channels. Individual receivers dynamically join and leave these channels according to the network congestion they experience. These congestion control adjustments are performed at each receiver independently of all other receivers, without any impact on the sender. A packet sequence number is carried in the WEBRC Congestion Control Information. The packet sequence numbers are consecutively numbered per channel and are used by receivers to measure packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC拥塞控制是通过让发送方将与给定会话相关联的数据包发送到多个不同的信道来实现的。单个接收器根据其经历的网络拥塞动态地加入和离开这些信道。这些拥塞控制调整在每个接收机上独立于所有其他接收机执行，对发送方没有任何影响。在WEBRC拥塞控制信息中携带分组序列号。分组序列号在每个信道上连续编号，并且由接收机用于测量分组丢失。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The channels associated with a session consist of one base channel and T wave channels. The packet rate for each channel varies over time. For the base channel, packets are sent to the channel at a low rate BCR_P at the beginning of a time slot and this rate gradually decreases to P*BCR_P at the end of the time slot, where P &lt; 1 is a constant defined later. This pattern for the base channel repeats over each time slot. For each wave channel i, packets are sent to channel i at a rate that first increases very quickly to a high rate and then decreases over time by a fixed fraction P per time slot until a rate of BCR_P is reached at the end of time slot i. Then, for a period of time called the quiescent period, no packets are sent to wave channel i, and thereafter the whole cycle repeats itself, where the duration of the cycle is T*TSD seconds. Thus, the wave channels are going through the same cyclic pattern of packet rate transmission spaced out evenly by TSD seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与会话相关的信道包括一个基本信道和T波信道。每个信道的分组速率随时间而变化。对于基本信道，分组在时隙开始时以低速率BCR_P发送到信道，并且该速率在时隙结束时逐渐降低到P*BCR_P，其中P&lt;1是稍后定义的常数。基本信道的此模式在每个时隙上重复。对于每个波信道i，分组以一种速率发送到信道i，该速率首先非常快速地增加到高速率，然后随着时间的推移每个时隙以固定的分数P减小，直到在时隙i的末尾达到BCR_P的速率。然后，在一段称为静止期的时间内，没有分组被发送到波信道i，并且此后整个周期自身重复，其中周期的持续时间为T×TSD秒。因此，波信道正在经历相同的分组速率传输循环模式，其间隔为TSD秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before joining a session, the receivers MUST obtain enough of the session description to start the session. This MUST include the relevant session parameters needed by a receiver to participate in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在加入会话之前，接收方必须获得足够的会话描述以启动会话。这必须包括接收方参与所需的相关会话参数
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the session and perform WEBRC congestion control. The session description is determined by the sender and is typically communicated to the receivers out of band. How receivers obtain the session description is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
启动会话并执行WEBRC拥塞控制。会话描述由发送方确定，并且通常在带外与接收方通信。接收者如何获得会话描述超出了本文档的范围。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a receiver initiates a session, it first joins the base channel. The packets in the base channel help the receiver orient itself in terms of what the current time slot index is, which in turn allows the receiver to know the relative rates on the wave channels. The receiver remains joined to the base channel for the duration of its participation in the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收器启动会话时，它首先加入基本通道。基本信道中的数据包有助于接收机根据当前时隙索引来确定自身方向，这反过来又允许接收机知道波信道上的相对速率。接收器在其参与会话期间保持与基本信道的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At each point in time the active (non-quiescent) wave channels are ordered into layers, where the lowest layer is the active wave channel whose wave is nearest to completion and the highest layer is the active wave channel whose wave is furthest from completion. (This is almost the same as saying that the lowest layer has the lowest rate and the highest layer has the highest rate. The possible deviation from this is due to the optional non-exponential beginnings of the waves as described in [8].) Each time a wave channel becomes active, it is the highest layer. At the end of each time slot the lowest-layer wave channel becomes quiescent, and thus all active wave channels move down a layer at this point in time. At each point in time a receiver is joined to the base channel and a consecutive set of layers starting with the lowest. Each time a receiver joins a wave channel it joins the lowest layer not yet joined. A receiver always leaves the lowest layer when it becomes quiescent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在每个时间点，活动（非静态）波通道被分为几层，其中最底层是波最接近完工的活动波通道，最高层是波最远离完工的活动波通道。（这几乎与最低层的速率最低，最高层的速率最高的说法相同。可能的偏差是由于[8]中描述的可选非指数波开始）。每次波通道激活时，它都是最高层。在每个时隙结束时，最底层的波通道变得静止，因此所有活动波通道在此时间点向下移动一层。在每个时间点上，接收器连接到基本信道和从最低层开始的一组连续层。每次接收器加入一个波道时，它都会加入尚未加入的最低层。当接收器处于静止状态时，它总是离开最底层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After joining a session the receiver adjusts its rate upwards by joining wave channels in sequence, starting with the lowest layer and moving towards the highest. The rates on the active wave channels are decreasing with time, so the receiver adjusts its rate downwards simply by refraining from joining additional wave channels. Since the layer ordering among the channels changes dynamically over time depending on the current time slot index, it is important that the receiver continually monitor the current time slot index contained in received packets. The reception rate at the receiver is determined by how early each wave channel is joined by the receiver: the earlier the receiver joins a channel with respect to when its wave started, the higher the reception rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After joining a session the receiver adjusts its rate upwards by joining wave channels in sequence, starting with the lowest layer and moving towards the highest. The rates on the active wave channels are decreasing with time, so the receiver adjusts its rate downwards simply by refraining from joining additional wave channels. Since the layer ordering among the channels changes dynamically over time depending on the current time slot index, it is important that the receiver continually monitor the current time slot index contained in received packets. The reception rate at the receiver is determined by how early each wave channel is joined by the receiver: the earlier the receiver joins a channel with respect to when its wave started, the higher the reception rate.translate error, please retry
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the receiver is joined to a wave channel, the receiver remains joined to the wave channel until the channel goes quiescent, at which point the receiver MUST leave the channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦接收器连接到波通道，接收器将保持连接到波通道，直到通道静止，此时接收器必须离开通道。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The way the receiver adjusts its reception rate is inspired by TFRC [9]. The receiver at all points in time maintains a target reception rate, and the receiver is allowed to join the next wave channel if
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收机调整接收速率的方式受到TFRC[9]的启发。接收机在所有时间点都保持目标接收速率，并且允许接收机在以下情况下加入下一个波信道：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
after joining its anticipated reception rate from all the layers it is joined to would be at most its target reception rate. The target rate is continually updated based on a set of measured parameters. The primary parameters are an estimate LOSSP of the average loss probability and an estimate ARTT of the average multicast round-trip time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在加入它所加入的所有层的预期接收速率之后，它最多将是它的目标接收速率。目标速率根据一组测量参数不断更新。主要参数是平均丢失概率的估计LOSSP和平均组播往返时间的估计ARTT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the remainder of this document, log(X) denotes the natural logarithm of X, i.e., the logarithm base 2.71828459... of X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本文件的其余部分中，对数（X）表示X的自然对数，即对数底2.71828459。。。X。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Sender Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 发送器操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sender operation is by design much simpler than the receiver operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送方操作在设计上比接收方操作简单得多。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Sender inputs and initialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. 发送方输入和初始化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The primary input to the sender for the session is SR_b. SR_b is an upper bound to the sender transmission rate in bits per second at any point in time (with some reasonable granularity) in aggregate to all channels. Naturally, this is then also the maximum rate in bits per second that any receiver could receive data from the session at any point in time. It is RECOMMENDED that the sender transmission rate in aggregate to all channels be made constant as described in [8]. It is also RECOMMENDED that the session description indicate whether the aggregate transmission rate is constant, unless there is no ambiguity.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
会话发送方的主要输入是SR_b。SR_b是所有信道在任何时间点（具有某种合理粒度）的发送方传输速率的上限，单位为比特/秒。当然，这也是任何接收器在任何时间点都可以从会话接收数据的最大速率（以比特/秒为单位）。建议按照[8]中所述，使所有信道的发送方传输速率总和保持恒定。还建议会话描述指示聚合传输速率是否恒定，除非没有歧义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The secondary inputs to the sender are listed below. These inputs are secondary because their values will generally be fixed to default values that will not change, because they will be derived from SR_b, or because they are chosen based on non-WEBRC considerations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送器的辅助输入如下所示。这些输入是次要的，因为它们的值通常固定为不会改变的默认值，因为它们将从SR_b派生，或者因为它们是基于非WEBRC考虑因素选择的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LENP_B is the length of packets in bytes sent to the session. The value of LENP_B depends on the complete protocol, but in general this SHOULD be set to as high a value as possible without exceeding the MTU size for the network that would cause fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o LENP_B是发送到会话的数据包长度（以字节为单位）。LENP_B的值取决于完整的协议，但通常应将其设置为尽可能高的值，而不超过可能导致碎片的网络MTU大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BCR_P is the transmission rate on the base channel at the beginning of a time slot in packets per second. The default value for BCR_P is 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BCR_P是时隙开始时基本信道上的传输速率，单位为每秒数据包。BCR_P的默认值为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TSD is the time slot duration measured in seconds. The RECOMMENDED value for TSD is 10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TSD是以秒为单位测量的时隙持续时间。TSD的建议值为10。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o QD is the minimum quiescent period duration measured in seconds. The RECOMMENDED value for QD is 300.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o QD是以秒为单位测量的最小静止期持续时间。QD的建议值为300。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o P is the multiplicative drop in every channel rate over each time slot. The default value for P is 0.75.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o P是每个时隙中每个信道速率的乘性下降。P的默认值为0.75。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N is the duration in time slots for each wave. N is also the number of wave channels active at any time. (A wave channel is called active when it is not quiescent.) A sender may choose any value that allows it to produce waves that substantially follow the required exponential shape described in Section 3.1.2. A RECOMMENDED mechanism for relating N to SR_b, BCR_P and P is described in [8].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o N是每个波的时隙持续时间。N也是任何时候活动的波道数。（非静止时，波通道称为活动的。）发送方可选择任何值，使其产生基本上符合第3.1.2节所述要求指数形状的波。[8]中描述了将N与SR_b、BCR_P和P关联的推荐机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
From these inputs the following fixed sender parameters can be derived as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据这些输入，可以导出以下固定发送器参数，如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SR_P = SR_b/(8*LENP_B) is the sender transmission rate in packets per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SR_P=SR_b/（8*LENP_b）是发送方的传输速率，以每秒数据包为单位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BCR_b = 8*LENP_B*BCR_P is the rate of the base channel at the beginning of a time slot in bits per second.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o BCR_b=8*LENP_b*BCR_P是时隙开始时的基本信道速率，单位为比特/秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o L = ceil(BCR_P*TSD*(P-1)/log(P)) is the number of base channel packets sent in each time slot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o L=ceil（BCR_P*TSD*（P-1）/log（P））是在每个时隙中发送的基本信道分组数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Q = ceil(QD/TSD) is the number of quiescent time slots per cycle for a wave channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Q=ceil（QD/TSD）是波通道每个周期的静态时隙数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o T = N + Q is the total number of time slots in a cycle. T is also the total number of wave channels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o T=N+Q是一个周期中的时隙总数。T也是波道总数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For the base channel CN = T and for the wave channels CN = 0,1,...,T-1. The sender has the description of the channels assigned to the session and the mapping between the channels and the CNs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于基本通道CN=T，对于波通道CN=0,1，…，T-1。发送方具有分配给会话的信道的描述以及信道与CNs之间的映射。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o C = TSD*T is the total duration of a cycle in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o C=TSD*T是一个循环的总持续时间（以秒为单位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. Sending packets to the session
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. 正在向会话发送数据包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sender keeps track of the current time slot index CTSI. The value of CTSI is incremented by 1 modulo T each TSD seconds. The value of CTSI is placed into each packet in the format described in Section 5. For each packet sent to the session, the sender also places the channel number CN of the channel into the packets in the format described in Section 5. Recall that CN = T for the base channel and CN = 0,1,...,T-1 for the wave channels.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送方跟踪当前时隙索引CTSI。CTSI的值每TSD秒增加1模T。CTSI的值以第5节所述的格式放入每个数据包中。对于发送到会话的每个分组，发送方还以第5节中描述的格式将信道的信道号CN放入分组中。回想一下，对于基本信道，CN=T；对于波信道，CN=0,1，…，T-1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each packet sent to the session, the sender calculates a packet sequence number PSN and places it into the packet. The value of PSN is scoped by CN, and the value of PSN is consecutively increasing within each channel. Furthermore, for each wave channel, the last packet sent before the channel becomes quiescent must have the maximum possible PSN value. When the short format for Congestion Control Information is used (see Section 5.1), this implies that for any wave channel the last PSN value sent to the channel just before the channel becomes quiescent is 2^16-1 = 65,535. Similarly, when the long format for Congestion Control Information is used (see Section 5.2), the PSN for the final packet of any wave is 2^32-1 = 4,294,967,295. The PSN of the initial packet of a wave thus depends on TSD, P, BCR_P and SR_P. For the base channel, the first packet of each time slot has a PSN congruent to zero modulo L. Hence, instead of 2^16 - 1 or 2^32 - 1 being the highest PSN used (depending on the choice of short format or long format Congestion Control Information), the highest PSN is one less than the largest multiple of L that does not exceed 2^16 (short format) or 2^32 (long format). The format for the PSN within packets is described in Section 5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于发送到会话的每个数据包，发送方计算数据包序列号PSN并将其放入数据包中。PSN的值由CN限定，并且PSN的值在每个信道内连续增加。此外，对于每个波信道，在信道静止之前发送的最后一个数据包必须具有最大可能的PSN值。当使用拥塞控制信息的短格式时（见第5.1节），这意味着对于任何波形信道，在信道静止之前发送到信道的最后一个PSN值为2^16-1=65535。类似地，当使用拥塞控制信息的长格式时（参见第5.2节），任何波的最终数据包的PSN为2^32-1=4294967295。因此，波的初始分组的PSN取决于TSD、P、BCR_P和SR_P。对于基本信道，每个时隙的第一个分组具有与零模L一致的PSN。因此，使用的最高PSN不是2^16-1或2^32-1（取决于短格式或长格式拥塞控制信息的选择），最高PSN比不超过2^16（短格式）或2^32（长格式）的L的最大倍数小一倍。包内PSN的格式在第5节中描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rate at which packets are sent to the base channel starts at BCR_P packets per second at the beginning of each time slot and decreases exponentially to P*BCR_P at the end of that time slot.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据包发送到基本信道的速率在每个时隙开始时以每秒BCR_P个数据包开始，并在该时隙结束时以指数形式减小到P*BCR_P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The packet rate for the wave channels is more complicated. Each wave channel carries a sequence of waves separated by quiescent periods. On each wave channel each wave is active during N time slots followed by a quiescent period of Q time slots. The waves on wave channel i end at the ends of time slots with CTSI i. Therefore wave channel i is active during time slots i-N+1 modulo T, i-N+2 modulo T, ..., i and is quiescent for time slots i+1 modulo T, i+2 modulo T, ..., i+Q modulo T. Wave channel i first becomes active within time slot i-N+1 modulo T at a point in time that may depend on the value of SR_b.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
波信道的分组速率更为复杂。每个波通道携带一系列由静止周期分隔的波。在每个波通道上，每个波在N个时隙期间处于活动状态，随后是Q个时隙的静止期。波通道i上的波在带有CTSI i的时隙末端结束。因此，波信道i在时隙i-N+1模T、i-N+2模T、…、i期间是活动的，并且对于时隙i+1模T、i+2模T、…、i+Q模T是静止的。波信道i首先在可能取决于SR_b的值的时间点在时隙i-N+1模T内变为活动的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Except for at most the first two time slots after a wave becomes active, the packet rate of the wave MUST decrease exponentially by a factor of P per TSD seconds, down to a rate of BCR_P at the end of the last active time slot. At the beginning of each wave, i.e., for at most the first two time slots when the wave becomes active, the rate MAY deviate from this exponential form so that the total sending rate in aggregate to all of the channels is constant. A RECOMMENDED design for the beginnings of waves to achieve this goal is described in [8].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除波激活后的前两个时隙外，波的数据包速率必须以每TSD秒P的因数呈指数下降，在最后一个激活时隙结束时下降到BCR_P的速率。在每个波的开始处，即，当波变得活跃时，对于最多前两个时隙，速率可以偏离此指数形式，使得到所有信道的总发送速率是恒定的。[8]中描述了为实现这一目标而推荐的波浪起始设计。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Receiver Operation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 接收机操作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The bulk of the complexity in WEBRC is in the receiver operation. For ease of explanation, suppose for the moment that during the reception there is no packet loss and packets are arriving at exactly the rate at which they were sent. The sender transmission rate to the channels is designed so that the receiver reception rate behaves as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC的大部分复杂性在于接收器操作。为了便于解释，假设在接收过程中没有数据包丢失，并且数据包的到达速率与发送速率完全相同。发送方到信道的传输速率被设计为使接收方接收速率表现如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon entering a session, the receiver immediately joins the base channel. When the receiver wants to increase its rate, it joins consecutive layers starting with the lowest and moving towards the highest. (Recall that the designations of lowest to highest change as waves become active and quiescent.) When the receiver wants to maintain its current reception rate and it is already joined to the lowest NWC layers, if the receiver joins channel i-1+NWC modulo T sometime during time slot i then the receiver joins channel i+NWC modulo T TSD seconds later in time slot i+1. When the lowest layer becomes quiescent the receiver leaves the channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦进入会话，接收器立即加入基本信道。当接收器想要增加其速率时，它加入从最低层开始向最高层移动的连续层。（回想一下，当波变为活动和静止时，从最低到最高的指定会发生变化。）当接收器想要保持其当前接收速率，并且它已经连接到最低的NWC层时，如果接收机在时隙i期间的某个时间加入信道i-1+NWC模T，则接收机在时隙i+1中加入信道i+NWC模T TSD秒之后。当最低层静止时，接收器离开信道。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose the receiver wants to decrease its rate till it is joined to just the base channel. Assume that a receiver is joined to the lowest NWC &lt; N-2 layers at the beginning of time slot i, i.e., wave channels i, i+1 modulo T,..., i+NWC-1 modulo T. Then, the aggregate packet reception rate of the receiver over the next NWC time slots will behave as follows if the receiver does not join any wave channels during this time. At the beginning of time slot i the receiver reception rate is BCR_P*(1 + (1/P) + (1/P)^2 + ... + (1/P)^NWC). Then the receiver reception rate decreases by a factor of P over the duration of each time slot, and at the end of each time slot the reception rate decreases by an additive amount of P*BCR_P. At the end of time slot i+NWC-1 mod T, the receiver reception rate is BCR_P*(1+P), and at the beginning of time slot i+NWC mod T the receiver is joined only to the base channel and its reception rate is BCR_P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设接收器想要降低其速率，直到它只连接到基本信道。假设接收机在时隙i的开始处连接到最低的NWC&lt;N-2层，即波信道i，i+1模T，…，i+NWC-1模T。然后，如果接收机在此期间未连接任何波信道，则接收机在下一个NWC时隙上的总分组接收速率将如下所示。在时隙i开始时，接收机接收速率为BCR_P*（1+（1/P）+（1/P）^2+…+（1/P）^NWC）。然后，在每个时隙的持续时间内，接收机接收速率降低P的因数，并且在每个时隙的末尾，接收速率降低P*BCR_P的相加量。在时隙i+NWC-1 mod T的末尾，接收机接收速率为BCR_P*（1+P），在时隙i+NWC mod T的开始处，接收机仅连接到基本信道，其接收速率为BCR\P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. Receiver inputs and initialization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. 接收机输入和初始化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Before joining a session the receiver MUST know the mapping between the CNs and the channels. Upon joining the session or shortly thereafter, it SHOULD have the values of LENP_B, BCR_P, TSD, P, N, L, Q and T. Some of these values may be computed or measured once the receiver has joined the session. For example, the receiver MAY obtain LENP_B and T from the first packet received from the base channel, and the receiver MAY measure BCR_P once it is joined to the base channel. The values of P, Q and TSD MAY be fixed to default values built into the receiver that do not change from session to session, and the value of N MAY be computed as T-Q. The receiver
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在加入会话之前，接收器必须知道CNs和信道之间的映射。在加入会话时或之后不久，它应该具有LENP_B、BCR_P、TSD、P、N、L、Q和T的值。一旦接收器加入会话，就可以计算或测量其中的一些值。例如，接收机可从从从基本信道接收的第一分组获得LENP_B和T，并且接收机可在其加入到基本信道后测量BCR_P。P、Q和TSD的值可以固定为内置在接收机中的默认值，这些默认值在会话之间不会改变，并且N的值可以计算为T-Q
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHOULD know whether the sender is employing a technique to produce constant aggregate rate as described in [8].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应该知道发送方是否采用了一种技术来产生[8]中所述的恒定聚合速率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a receiver first joins a session, it MUST first join just the base channel and start receiving packets to determine the current time slot index. If during the course of the session the receiver continually loses a high fraction of the packets from the base channel even when the receiver is only joined to the base channel, the receiver SHOULD leave the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收器第一次加入会话时，它必须首先只加入基本通道并开始接收数据包，以确定当前时隙索引。如果在会话过程中，即使当接收机仅加入到基本信道时，接收机仍持续丢失来自基本信道的大部分数据包，则接收机应离开会话。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver MAY also have other individually set parameters that may be used to determine its behavior. One such parameter is MRR_b:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收机还可以具有其他单独设置的参数，这些参数可用于确定其行为。其中一个参数是MRR_b：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MRR_b is the maximum receiver reception rate in bits per second. This may be used to determine the maximum reception rate this receiver is willing to reach. Thus, the maximum reception rate that the receiver can possibly achieve in the session is the minimum of SR_b and MRR_b. A recommended value of MRR_b for a receiver is the bandwidth capacity of the last link to the receiver. MRR_P is the maximum receiver reception rate in packets per second, i.e., MRR_P = MRR_b/(8*LENP_B).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o MRR_b是以比特/秒为单位的最大接收机接收速率。这可用于确定该接收机愿意达到的最大接收速率。因此，接收机在会话中可能实现的最大接收速率是SR_b和MRR_b中的最小值。接收器的建议MRR_b值是到接收器的最后一条链路的带宽容量。MRR_P是以每秒数据包为单位的最大接收机接收速率，即MRR_P=MRR_b/（8*LENP_b）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. Receiver measurements and calculations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. 接收机测量和计算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As outlined in the introduction, the way a receiver adjusts its reception rate is inspired by TFRC [9]. The receiver at all points in time maintains a target reception rate, and the receiver is allowed to join the next wave channel if joining would increase its reception rate to at most its target reception rate. The target rate is continually updated based on a set of measured parameters.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如引言所述，接收机调整其接收速率的方式受TFRC[9]的启发。接收机在所有时间点都保持目标接收速率，如果加入会将其接收速率增加到最大目标接收速率，则允许接收机加入下一个波信道。目标速率根据一组测量参数不断更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two primary parameters are the estimate LOSSP of the average loss probability and the estimate ARTT of the average MRTT. Both LOSSP and ARTT are moving averages of measurements based on discrete events. For many of the other estimates calculated by WEBRC, using an exponentially weighted moving average (EWMA) with a fixed averaging fraction is sufficient. However, the calculations of LOSSP and ARTT require a more general and sophisticated filtering approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
两个主要参数是平均损失概率的估计LOSSP和平均MRTT的估计ARTT。LOSSP和ARTT都是基于离散事件的测量移动平均值。对于WEBRC计算的许多其他估计，使用具有固定平均分数的指数加权移动平均（EWMA）就足够了。然而，LOSSP和ARTT的计算需要更一般和更复杂的过滤方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.1. Average loss probability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.1. 平均损失概率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The design of TFRC [9] reflects that, because the average packet loss probability can vary by orders of magnitude, any estimate of the average loss probability based on either a fixed number of packets or on a fixed period of time with a fixed averaging fraction will be poor. In TFRC the average is estimated from the numbers of packets between beginnings of loss events, and the number of loss events used is fixed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFRC[9]的设计反映出，由于平均分组丢失概率可以按数量级变化，因此基于固定数量的分组或固定时间段（具有固定平均分数）的平均丢失概率的任何估计都将很差。在TFRC中，平均值是根据丢失事件开始之间的数据包数估计的，使用的丢失事件数是固定的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The estimate LOSSP of the average loss probability of the receiver is maintained in a manner somewhat similar to that described in TFRC [9]. The WEBRC receiver estimates the inverse of the average loss probability by applying two EWMA filters to the packet reception measurements, a time-based filter with smoothing constant 0 &lt; Nu &lt; 1 and a loss-based filter with smoothing constant 0 &lt; Delta &lt; 1. The recommended values for the smoothing constants are Nu = 0.3 and Delta = 0.3. The reason for the time-based filter is that the loss events in WEBRC are bursty; they typically occur just after a new wave has been joined. To smooth out this burstiness, the time-based filter is applied to the packet reception measurements at the end of each epoch to smooth out the bursty loss events over a few time slot durations. Intuitively, the time-based filter averages packet reception events such that the events are smoothed out over an interval of time proportional to TSD/Nu seconds. The loss-based filter, similar to what is suggested in TFRC, is applied to the output of the time-based filter to produce the estimate of the inverse of the average loss probability. Intuitively, the loss-based filter averages loss events such that each loss event is averaged in with weight Delta.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收机的平均丢失概率的估计LOSSP以某种类似于TFRC[9]中描述的方式保持。WEBRC接收器通过对分组接收测量应用两个EWMA滤波器来估计平均丢失概率的倒数，一个平滑常数为0&lt;Nu&lt;1的基于时间的滤波器和一个平滑常数为0&lt;Delta&lt;1的基于丢失的滤波器。平滑常数的建议值为Nu=0.3和Delta=0.3。基于时间的过滤器的原因是WEBRC中的丢失事件是突发的；它们通常发生在新浪潮加入之后。为了消除这种突发性，将基于时间的滤波器应用于每个历元结束时的分组接收测量，以消除几个时隙持续时间内的突发性丢失事件。直观地，基于时间的滤波器平均分组接收事件，使得事件在与TSD/Nu秒成比例的时间间隔上平滑。与TFRC中建议的类似，基于损耗的滤波器应用于基于时间的滤波器的输出，以产生平均损耗概率的倒数估计。直观地说，基于损失的过滤器对损失事件进行平均，这样每个损失事件都会以加权增量进行平均。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described later, LOSSP is initialized at the end of slow start and occasionally reset due to other events. Let W and X be counts of packets, let Y be a count of loss events and let Z be the long-term estimate of the inverse of the average loss probability. Whenever the value of LOSSP is initialized or reset, the values of W, X, Y and Z are also initialized or reset.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如后所述，LOSSP在慢速启动结束时初始化，偶尔由于其他事件而重置。设W和X为数据包计数，Y为丢失事件计数，Z为平均丢失概率倒数的长期估计。无论何时初始化或重置LOSSP的值，W、X、Y和Z的值也会初始化或重置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Recall that TSD is the duration of a time slot. The epoch length EL is the duration of time between decisions to adjust the reception rate. Generally EL is much smaller than TSD, and the RECOMMENDED values are EL = 0.5 seconds and TSD = 10 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
回想一下，TSD是一个时间段的持续时间。历元长度EL是调整接收速率的决策之间的持续时间。通常EL比TSD小得多，推荐值为EL=0.5秒，TSD=10秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Define G = Nu*EL/TSD as the amount of time-based smoothing to perform at the end of each epoch. The update rules for W, X, Y, Z, and LOSSP are the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将G=Nu*EL/TSD定义为每个历元结束时要执行的基于时间的平滑量。W、X、Y、Z和LOSSP的更新规则如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At the end of each epoch, adjust X, Y and Z and compute LOSSP as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在每个历元结束时，调整X、Y和Z并计算LOSSP，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z = Z*(1-Delta)^(G*Y) + G*X/(G*Y+1)*(1-(1-Delta)^(G*Y+1))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z = Z*(1-Delta)^(G*Y) + G*X/(G*Y+1)*(1-(1-Delta)^(G*Y+1))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
X = X*(1-G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
X=X*（1-G）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Y = Y*(1-G)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Y=Y*（1-G）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z1 = Z*(1-Delta)^Y + X/(Y+1)*(1-(1-Delta)^(Y+1))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z1 = Z*(1-Delta)^Y + X/(Y+1)*(1-(1-Delta)^(Y+1))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z2 = Z*(1-Delta)^(Y+1) + (X+W+1)/(Y+2)*(1-(1-Delta)^(Y+2))
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z2 = Z*(1-Delta)^(Y+1) + (X+W+1)/(Y+2)*(1-(1-Delta)^(Y+2))
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         LOSSP = 1/max{Z1,Z2,1}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         LOSSP = 1/max{Z1,Z2,1}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For each packet event (whether it is a received packet or a lost packet), W = W + 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于每个数据包事件（无论是接收到的数据包还是丢失的数据包），W=W+1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At the beginning of each loss event, update W, X, and Y as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在每个损失事件开始时，更新W、X和Y，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
X = X + W
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
X=X+W
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         W = 0
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         W = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Y = Y + 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Y=Y+1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The intuition behind these update rules is the following. If just loss-filtering were used to update Z, then Z would be decreased by a multiplicative amount 1 - Delta for each loss event and Z would be increased by an additive amount Delta for each packet. To smooth out loss events over more than one time slot, these adjustments are filtered into Z over time, at the rate of a fraction G at the end of each epoch. Thus, the variables X and Y are counts of the portions of the packets and loss events, respectively, that have not yet been filtered into the long-term memory Z. W is the count of packets since the last loss event started. This explains why W is increased by one for each packet and Y is increased by one for each loss event. At the end of each epoch a fraction G of both X and Y are filtered into Z according to the loss-filter rule described above, and then the same fraction G is removed from both X and Y to account for the fact that this portion has been filtered into Z. The LOSSP calculation combines the short-term history (X,Y) with the long-term history Z and also allows the arrivals since the last loss W to have some influence. The value of Z2 is what Z1 would become were the next packet to be lost.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些更新规则背后的直觉如下。如果只是使用丢失过滤来更新Z，那么对于每个丢失事件，Z将减少1-增量的乘法量，对于每个数据包，Z将增加增量增量增量。为了消除超过一个时隙的损失事件，这些调整会随着时间的推移以分数G的速率过滤到Z中。因此，变量X和Y分别是尚未被过滤到长期存储器Z中的分组和丢失事件的部分的计数。W是自上次丢失事件开始以来的分组计数。这解释了为什么每个数据包的W增加一个，而每个丢失事件的Y增加一个。在每个历元结束时，根据上述损耗过滤规则将X和Y的分数G过滤到Z中，然后从X和Y中删除相同的分数G，以说明该部分已过滤到Z中。损耗SP计算结合了短期历史（X，Y）由于长期的历史Z，也允许自上次损失W以来的到达产生一定的影响。如果下一个数据包丢失，Z2的值就是Z1的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To reset the loss calculation to a value LOSSP = a, the state variables are set as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要将损失计算重置为LOSSP=a的值，状态变量设置如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         W = 0
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         W = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         X = 0
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         X = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Y = 0
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Y = 0
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z = 1/a
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         Z = 1/a
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.2. Average round-trip time
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.2. 平均往返时间
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver maintains an average round-trip time, ARTT, as a measurement-based filter of MRTT measurements using a smoothing constant 0 &lt; Alpha &lt; 1. The RECOMMENDED value for Alpha is 0.25.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收机保持平均往返时间ARTT，作为使用平滑常数0&lt;Alpha&lt;1的基于测量的MRTT测量滤波器。Alpha的建议值为0.25。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each time the receiver joins a channel (either the base channel upon entering a session or wave channels continually), it makes a measurement of the multicast round-trip time MRTT as follows. Let V be an auxiliary variable that is used that keep track of the average of the square of the MRTT measurements. When the receiver sends the join for the channel it records the current time JoinTime and sets a Boolean variable JOINING to true. When the first packet is received from the channel the receiver records the current time FirstTime and resets the value of JOINING to false. If it is the base channel that has been joined, ARTT is set to FirstTime-JoinTime and V is set to ARTT*ARTT. Otherwise, the value of MRTT is set to (FirstTime - JoinTime) - log(1/P)/2/(1-P)/BCR_P * P^NWC. (Note that this value can be negative.) Then, ARTT is updated as follows. Let Omega = Alpha*ARTT*ARTT/V, and at the Kth MRTT measurement let Rho = Omega/(1-(1-Omega)^(K+1)). (Note that as K grows Rho approaches Omega.) Then, V is updated to (1-Rho)*V+Rho*MRTT*MRTT and ARTT is updated to max{P*ARTT,(1-Rho)*ARTT+Rho*MRTT}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每次接收器加入一个信道（进入会话时的基本信道或连续的波信道）时，它对多播往返时间MRTT进行测量，如下所示。设V为辅助变量，用于跟踪MRTT测量值平方的平均值。当接收器为通道发送连接时，它会记录当前时间JoinTime，并将布尔变量JOINING设置为true。当从通道接收到第一个数据包时，接收器第一次记录当前时间，并将加入值重置为false。如果是已加入的基本通道，则ARTT设置为FirstTime JointTime，V设置为ARTT*ARTT。否则，MRTT的值设置为（FirstTime-JoinTime）-log（1/P）/2/（1-P）/BCR_P*P^NWC。（请注意，该值可以为负值。）然后，ARTT更新如下。设ω=α*ARTT*ARTT/V，在第K次MRTT测量时，设ρ=ω/（1-（1-ω）^（K+1））。（注意，随着K的增长，Rho接近ω。）然后，V被更新为（1-Rho）*V+Rho*MRTT*MRTT，ARTT被更新为max{P*ARTT，（1-Rho）*ARTT+Rho*MRTT}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usually ARTT is updated to the second term in the max, and in this case ARTT is the EWMA of the previous value of ARTT and the new MRTT, with a weighting on the new MRTT that as K grows is proportional to the square of the previous ARTT divided by the previous average V of the square of the MRTT. Thus, if there is not much variance in the previous MRTTs relative to the square of their average then the new MRTT will be filtered into ARTT with a high weight, whereas if there is a lot of variance in the previous MRTTs relative to the square of their average then the new MRTT will be filtered into ARTT with a low weight. The intuitive rationale for this is that in general the number of measurements needed to compute a meaningful average for a random variable is proportional to its variance divided by the square of its average; see, e.g., [6]. By making the weight factor depend on previous measurements in this way, the appropriate weight to use to average the new MRTT into the ARTT self-adjusts automatically to the variability in the measurements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常，ARTT更新为最大值中的第二项，在这种情况下，ARTT是ARTT先前值和新MRTT的EWMA，新MRTT上的权重随着K的增长与先前ARTT的平方除以MRTT平方的先前平均值V成正比。因此，如果之前的MRTT相对于其平均值的平方没有太大的差异，则新的MRTT将被过滤到具有高权重的ARTT中，而如果之前的MRTT相对于其平均值的平方存在大量差异，则新的MRTT将被过滤到具有低权重的ARTT中。直观的理由是，一般来说，计算随机变量有意义平均值所需的测量数量与其方差除以平均值的平方成正比；参见，例如[6]。通过以这种方式使权重因子依赖于先前的测量，用于将新MRTT平均到ARTT中的适当权重会自动根据测量中的可变性进行调整。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.3. Rate Equation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.3. 速率方程
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver calculates the reception rate REQN based on the TCP equation as follows: REQN = 1/(ARTT*sqrt{LOSSP}(0.816 + 7.35*LOSSP*(1+32*LOSSP^2))). This equation comes from TFRC [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收机根据TCP方程计算接收速率REQN，如下所示：REQN=1/（ARTT*sqrt{LOSSP}（0.816+7.35*LOSSP*（1+32*LOSSP^2）））。该方程来自TFRC[9]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.4. Epochs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.4. 历元
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The receiver makes decisions on whether or not to join another wave channel at equally-spaced units of time called epochs. The duration of an epoch in seconds, EL, is set to be a small fraction of TSD, so that decisions to join a channel can be made at a much finer granularity than TSD. A standard setting is EL = TSD/20. Thus, with the recommended setting of TSD = 10, it is RECOMMENDED that EL = 0.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收器决定是否以相等间隔的时间单位（称为历元）加入另一个波道。一个历元的持续时间（以秒为单位）EL被设置为TSD的一小部分，因此可以在比TSD更细的粒度上做出加入通道的决定。标准设置为EL=TSD/20。因此，在推荐设置TSD=10的情况下，建议EL=0.5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.5. Average reception rate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.5. 平均接收率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two averaged reception rates maintained by the receiver: TRR_P, the true reception rate, and ARR_P, the anticipated reception rate. These are used for different purposes and thus are calculated quite differently. Recommended values for the filtering weights Beta and Zeta are provided at the end of this subsection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收机保持两个平均接收速率：TRR_P（真实接收速率）和ARR_P（预期接收速率）。它们用于不同的目的，因此计算方式也完全不同。本小节末尾提供了过滤权重β和Zeta的建议值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In start-up mode, the true reception rate TRR_P is used to ensure that the receiver does not increase its reception rate too quickly above its current reception rate. In the transition from start-up mode to normal operation and in normal operation, TRR_P is used in setting the slow start rate. TRR_P is calculated based on the measurement of RR_P, where RR_P is the receiver reception rate in packets per second measured at the beginning of an epoch averaged over the epoch that just ended. TRR_P is initialized to BCR_P + k*log(P)/TSD when the first base channel packet of the session arrives, where k is the PSN of the packet reduced modulo L. TRR_P is updated to (1-Zeta)*TRR_P + Zeta*RR_P at the beginning of each epoch after RR_P is measured for the previous epoch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在启动模式下，真实接收速率TRR_P用于确保接收器不会将其接收速率过快地增加到当前接收速率之上。在从启动模式过渡到正常运行和正常运行时，TRR_P用于设置慢速启动速率。TRR_P基于RR_P的测量来计算，其中RR_P是在刚刚结束的历元上平均的历元开始时测量的接收机接收速率，单位为每秒分组数。当会话的第一个基本信道分组到达时，TRR_P被初始化为BCR_P+k*log（P）/TSD，其中k是分组缩减模L的PSN。在为前一个历元测量RR_P之后，TRR_P在每个历元开始时被更新为（1-Zeta）*TRR_P+Zeta*RR P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The anticipated reception rate ARR_P is the receiver&#39;s estimate of the total instantaneous rate of the currently joined channels. It is used to compare against the target rate to decide whether or not the receiver should increase its reception rate by joining the next higher unjoined layer. ARR_P is calculated based on a measurement IRR_P and on the number of joined wave channels NWC. The ideal reception rate IRR_P is the reception rate in packets per second including both received and lost packets; like RR_P, it is measured at the beginning of the epoch and averaged over the previous epoch. ARR_P, IRR_P and NWC are updated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
预期接收速率ARR_P是接收机对当前加入的信道的总瞬时速率的估计。它用于与目标速率进行比较，以决定接收器是否应通过加入下一个较高的未连接层来提高其接收速率。ARR_P根据测量IRR_P和连接波通道NWC的数量计算。理想接收速率irrp是以每秒分组为单位的接收速率，包括接收到的分组和丢失的分组；与RR_P一样，它在新纪元开始时测量，并在前一个纪元上平均。ARR_P、IRR_P和NWC更新如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NWC is initialized to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o NWC已初始化为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When the first base channel packet arrives, ARR_P is set to BCR_P + k*log(P)/TSD, where k is the PSN of the packet reduced modulo L.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当第一个基本信道分组到达时，ARR_P被设置为BCR_P+k*log（P）/TSD，其中k是分组缩减模L的PSN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o At the beginning of each epoch, IRR_P is measured over the previous epoch and then ARR_P is updated to P^(EL/TSD)*(1-Beta)*ARR_P + Beta*IRR_P. Then if ARR_P exceeds ARR_P_max = ((1/P)^(NWC+1)-1)/((1/P)-1)*BCR_P, ARR_P is updated to ARR_P_max.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在每个历元开始时，在前一历元上测量IRU P，然后将ARR P更新为P^（EL/TSD）*（1-Beta）*ARR P+Beta*IRU P。如果ARR P超过ARR P max=（1/P）^（NWC+1）-1/（1/P）-1）*BCR P，则将ARR P更新为ARR P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o When a join is made to the next higher unjoined layer, NWC is updated to NWC+1 and then ARR_P is multiplicatively increased by the factor ((1/P)^(NWC+1)-1)/((1/P)^NWC-1). (Joins happen at epoch boundaries; this adjustment is in addition to the adjustment above.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 当连接到下一个较高的未连接层时，NWC更新为NWC+1，然后ARR_P乘以系数（（1/P）^（NWC+1）-1）/（（1/P）^NWC-1）。（连接发生在历元边界；此调整是对上述调整的补充。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each time a next time slot index is detected, ARR_P is additively increased by (1-P)*BCR_P to account for the change in rate on the base channel. In addition, the bottom layer in the previous time slot has just gone quiescent and thus a message to leave this layer has been sent, ARR_P is additively decreased by BCR_P and NWC is decremented by 1. Thus, the combination of these effects on ARR_P is that it is additively decreased by P*BCR_P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 每次检测到下一个时隙索引时，ARR_P将增加（1-P）*BCR_P，以考虑基本信道上的速率变化。此外，上一个时隙中的底层刚刚静止，因此发送了离开该层的消息，ARR_P被BCR_P相加减少，NWC被减少1。因此，这些对ARR_P的影响的组合是P*BCR_P使ARR_P增加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Consider for the moment what happens if Beta = 0 and ARR_P is an accurate estimate of the total rate of the joined channels. The adjustments to ARR_P upon joining and leaving wave channels, with the passage of epochs, and with the detection of time slot changes will then cause ARR_P to remain an accurate estimate. In practice, Beta MUST be positive; allowing an influence of IRR_P prevents ARR_P from drifting away from being an accurate estimate of the total joined rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现在考虑一下如果β＝0和ARRYP是加入信道的总速率的准确估计会发生什么。在加入和离开波通道时，随着时间的推移和时隙变化的检测，对ARR_P的调整将使ARR_P保持准确的估计值。实际上，贝塔系数必须为正值；允许IRR_P的影响可以防止ARR_P偏离对总加入率的准确估计。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The motivation for separate estimates TRR_P and ARR_P is as follows. ARR_P is needed for comparison with the TFRC-inspired target rate because there is no lag before it reflects the potential rate increase resulting from joining the next higher layer and because it measures the total possible impact on the network since it also includes lost packets. TRR_P is needed because it reflects the rate of data arriving at the receiver and this is used to ensure that there is not a large gap between the joined rate and the receiving rate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单独估算TRR_P和ARR_P的动机如下。ARR_P需要与TFRC激励的目标速率进行比较，因为在它反映加入下一个更高层所导致的潜在速率增加之前没有延迟，并且因为它还包括丢失的数据包，所以可以测量对网络的总体可能影响。TRR_P是必需的，因为它反映了到达接收器的数据速率，用于确保连接速率和接收速率之间没有太大的差距。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   The recommended values for Beta and Zeta depend on whether the
   receiver is in start-up mode (SSR_P = infinity).  In start-up mode,
   it is RECOMMENDED that Beta = (1 - P^(0.25))/2 and Zeta = sqrt(P)/(1
   + sqrt(P)).  In normal operation, it is RECOMMENDED that Beta = 1 -
   (P/(1+P))^(EL/TSD) and Zeta = 2*EL/(4+TSD).
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   The recommended values for Beta and Zeta depend on whether the
   receiver is in start-up mode (SSR_P = infinity).  In start-up mode,
   it is RECOMMENDED that Beta = (1 - P^(0.25))/2 and Zeta = sqrt(P)/(1
   + sqrt(P)).  In normal operation, it is RECOMMENDED that Beta = 1 -
   (P/(1+P))^(EL/TSD) and Zeta = 2*EL/(4+TSD).
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.6. Slow start
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.6. 慢启动
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC uses a slow start mechanism to quickly ramp up its rate at both the beginning of the session and in the middle of a session when the rate drops precipitously. To enact this, the receiver maintains the following parameters:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WebRC使用慢速启动机制，在会话开始时和会话的中间时，当速率急剧下降时，快速地提高其速率。为了实现这一点，接收器维护以下参数：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSMINR_P is the minimum allowed slow start threshold rate in packets per second. The recommended value for SSMINR_P is BCR_P*(1+1/P+1/P^2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSMINR_P是允许的最小慢速启动阈值速率，以每秒数据包为单位。SSMINR_P的建议值为BCR_P*（1+1/P+1/P^2）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSR_P is the slow start threshold rate in packets per second. It is adjusted at the beginning of loss events as described in Section 3.2.3.4. SSR_P is initialized to infinity and is first set to a finite value when the receiver leaves the initial start-up period as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o SSR_P是以每秒数据包为单位的慢启动阈值速率。如第3.2.3.4节所述，在损失事件开始时进行调整。SSR_P初始化为无穷大，并在接收机离开初始启动周期时首先设置为有限值，如下所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the beginning of a session, the receiver cannot compute a meaningful target rate from its measurements. Thus, it uses SSR_P = infinity until one of the following events causes an end to this start-up mode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在会话开始时，接收器无法根据其测量值计算有意义的目标速率。因此，它使用SSR_P=无穷大，直到下列事件之一导致该启动模式结束：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A packet loss is detected. In this case the value of SSR_P is updated to max{SSMINR_P, P*TRR_P} as with the beginning of any other loss event.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 检测到数据包丢失。在这种情况下，随着任何其他损失事件的开始，SSR_P的值更新为max{SSMINR_P，P*TRR_P}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sharp increase in MRTT is detected. While SSR_P = infinity the receiver MUST compute, in the notation of Section 3.2.2.2, differences in successive measurements of (FirstTime-JoinTime) from successive waves and MUST set SSR_P to max{SSMINR_P, P*TRR_P} when a large increase in (FirstTime-JoinTime) is observed. It is RECOMMENDED that an increase in (FirstTime-JoinTime) be considered large if it exceeds (P^(NWC+1)-1)/(P*log(P)) / ARR_P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 检测到MRTT急剧增加。当SSR_P=无穷大时，按照第3.2.2.2节的表示法，接收器必须计算连续波的连续测量值（首次接合时间）的差异，并且当观察到（首次接合时间）的大幅增加时，必须将SSR_P设置为max{SSMINR_P，P*TRR_P}。如果（首次连接时间）的增加超过（P^（NWC+1）-1）/（P*log（P））/ARR\P，则建议将其视为较大的增加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The maximum reception rate is reached. When SSR_P = infinity, if (P^(-NWC-2)-1)/(P^(-NWC-1)-1)*ARR_P exceeds MRR_P or SR_P, the receiver MUST set SSR_P to max{SSMINR_P, TRR_P}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 达到最大接收速率。当SSR_P=无穷大时，如果（P^（-NWC-2）-1）/（P^（-NWC-1）-1）*ARR_P超过MRR_P或SR_P，则接收器必须将SSR_P设置为max{SSMINR_P，TRR_P}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TRR_P is not increasing consistent with the last join of a wave channel. While SSR_P = infinity, it is RECOMMENDED that the receiver wait at least one full epoch after the first packet of a wave is received before joining the next wave. If the TRR_P after that full epoch is greatly below ARR_P the receiver SHOULD NOT join and SHOULD then set SSR_P to max{SSMINR_P, TRR_P}. It is RECOMMENDED that TRR_P be considered greatly below ARR_P if TRR_P &lt; c * ARR_P - 2/EL, where c = Zeta + (1-Zeta)*(P^(-EL/TSD))*(Zeta + (1-Zeta)*sqrt(P)*(P^(-EL/TSD)))/g with g = (P^(-NWC-1)-1)/(P^(- NWC)-1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TRR_P的增加与波通道的最后一次连接不一致。当SSR_P=无穷大时，建议接收器在接收到第一个波包后至少等待一个完整历元，然后再加入下一个波。如果在该完整历元之后的TRR_P大大低于ARR_P，则接收器不应加入，然后应将SSR_P设置为max{SSMINR_P，TRR_P}。如果TRR_P&lt;c*ARR_P-2/EL，其中c=Zeta+（1-Zeta）*（P^（-EL/TSD））*（Zeta+（1-Zeta）*sqrt（P）*（P^（-EL/TSD））/g和g=（P^（-NWC-1）-1/（P^（-NWC）-1），则建议考虑TRR_P大大低于ARR_P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any of these four cases, the variables associated with LOSSP are reset to make REQN, calculated as in Section 3.2.2.3 with the current value of ARTT, equal TRR_P.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在这四种情况中的任何一种情况下，与LOSSP相关的变量被重置，以使REQN（按照第3.2.2.3节计算）与当前ARTT值相等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.7. Target rate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2.7. 目标利率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In typical operation, SSR_P has a finite value and the target rate TRATE is computed as TRATE = min{max{SSR_P, REQN}, MRR_P}. When SSR_P = infinity, TRATE is computed as TRATE = min{4*TRR_P, MRR_P}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在典型操作中，SSR_P有一个有限值，目标速率TRATE的计算公式为TRATE=min{max{SSR_P，REQN}，MRR_P}。当SSR_P=无穷大时，TRATE计算为TRATE=min{4*TRR_P，MRR_P}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. Receiver events
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. 接收器事件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are various receiver events, some of which are triggered by the passing of time on the receiver, and others by events such as packet reception, detection of packet loss, reception of a first packet from a channel, and exceptional time-outs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在各种接收器事件，其中一些由接收器上的时间流逝触发，而另一些由诸如分组接收、分组丢失检测、从信道接收第一分组和异常超时等事件触发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.1. Packet reception
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.1. 数据包接收
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most packet reception events require the receiver to merely register the reception for later calculation of RR_P and IRR_P (see Section 3.2.2.5) and increment W for later calculation of LOSSP (see Section 3.2.2.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大多数数据包接收事件要求接收器仅注册接收，以便稍后计算RR_P和IRR_P（参见第3.2.2.5节），并注册增量W，以便稍后计算LOSSP（参见第3.2.2.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional actions, described in the following three subsections, are required if the packet is the first packet received in response to a join operation, the CTSI of the packet indicates a time slot change, or the CN and PSN of the packet indicate a packet loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果分组是响应加入操作而接收的第一个分组，分组的CTSI指示时隙改变，或者分组的CN和PSN指示分组丢失，则需要在以下三小节中描述的附加动作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.2. First packet after join
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.2. 加入后的第一个数据包
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When channel i is the most recently joined channel and the Boolean variable JOINING is true, the reception of a packet with PSN = i is a special event because it is the first packet received in response to the most recent join. MRTT is calculated and ARTT and V are updated as described in Section 3.2.2.2, and JOINING is set to false. The first received packet of the session furthermore necessitates initialization of ARR_P and TRR_P as described in Section 3.2.2.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当信道i是最近加入的信道并且布尔变量JOINING为true时，接收PSN＝i的分组是一个特殊事件，因为它是响应最近加入而接收的第一个分组。按照第3.2.2.2节所述，计算MRTT，更新ARTT和V，并将连接设置为false。如第3.2.2.5节所述，会话的第一个接收数据包还需要初始化ARR_P和TRR_P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.3. Time slot change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.3. 时隙变化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an event that is triggered by the reception of a packet with a CTSI value that is one larger modulo T than the previous CTSI value. When a packet with a new CTSI = i is received, a leave is sent for the lowest layer in the previous time slot, i.e., wave channel i-1 modulo T, NWC is updated to NWC-1, and ARR_P is updated
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是通过接收CTSI值比先前CTSI值大一个模T的数据包触发的事件。当接收到具有新CTSI＝i的分组时，在前一时隙中为最低层发送离开，即，波信道i-1模T，NWC被更新为NWC-1，并且ARR_P被更新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
to ARR_P - P*BCR_P as described in Section 3.2.2.5. If the channel for which the leave is sent is also the most recently joined wave channel and JOINING is true, then JOINING is set to false.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第3.2.2.5节所述，发送至ARR_P-P*BCR_P。如果发送离开的通道也是最近连接的波通道，且连接为true，则连接设置为false。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible due to packet reordering for some packets from the previous time slot to be received after packets from the current time slot. It is RECOMMENDED that measures be put into place to handle this situation appropriately, i.e., to not trigger a time slot change in this situation. One simple mechanism for this is as follows: Compute the difference i-j modulo T, where i is the CTSI of the received packet and j is the current CTSI of the receiver. A difference of zero is, of course, not a time slot change. In addition, a very large difference, for example a difference larger than T-Q/2, should also not trigger a time slot change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这可能是由于在当前时隙的数据包之后接收来自前一时隙的一些数据包的数据包重新排序。建议采取措施适当处理这种情况，即在这种情况下不触发时隙变化。一个简单的机制如下：计算差分i-j模T，其中i是接收包的CTSI，j是接收器的当前CTSI。当然，零的差异不是时间段的变化。此外，非常大的差异，例如大于T-Q/2的差异，也不应触发时隙变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.4. Loss event
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.4. 损失事件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each time the receiver detects a lost packet (based on the sequence numbers in the packets scoped by the channel number), the receiver records the start of a new loss event and sets a Boolean variable LOSS_EVENT to true that will automatically reset to false after ARTT seconds. All subsequent packet loss for a period of ARTT seconds is considered as part of the same loss event. When a start of a loss event is detected, the value of SSR_P is updated to max{SSMINR_P, P*TRR_P}.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每次接收器检测到丢失的数据包时（基于信道号范围内的数据包序列号），接收器记录新丢失事件的开始，并将布尔变量loss_事件设置为true，该事件将在ARTT秒后自动重置为false。ARTT秒期间的所有后续数据包丢失被视为同一丢失事件的一部分。当检测到丢失事件的开始时，SSR_P的值更新为max{SSMINR_P，P*TRR_P}。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is RECOMMENDED that the receiver account for simple misordering of packets without inferring a loss.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
建议接收方在不推断丢失的情况下解释数据包的简单错序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.5. Epoch change
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.5. 时代变迁
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an event that is triggered by the passage of time at the receiver, which occurs each EL seconds. When this happens, TRR_P and ARR_P are computed as described in Section 3.2.2.5. Immediately after these updates, a decision is made about whether to join the next higher layer as described in Section 3.2.3.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是一个由接收器处的时间流逝触发的事件，每秒钟发生一次。发生这种情况时，按照第3.2.2.5节中的说明计算TRR_P和ARR_P。在这些更新之后，立即决定是否加入第3.2.3.6节所述的下一个更高层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.6. Join the next higher layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.6. 加入下一个更高层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the beginning of each epoch, after updating the values of ARR_P and TRR_P as described in Section 3.2.2.5, the receiver decides whether or not to join the next higher layer as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在每个历元开始时，如第3.2.2.5节所述更新ARR_P和TRR_P值后，接收器决定是否加入下一个更高的层，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the first base channel packet has not yet arrived the receiver MUST not join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果第一个基本信道数据包尚未到达，则接收器不得加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If there is a loss event in progress (LOSS_EVENT = true) the receiver MUST not join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果有正在进行的丢失事件（loss_event=true），则接收方不得加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If a join of a channel is in progress (JOINING = true) the receiver MUST not join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果正在进行通道连接（连接=true），则接收器不得连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If NWC = N the receiver MUST not join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果NWC=N，则接收器不得加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the receiver is employing the OPTIONAL rule described in Section 3.2.2.6, SSR_P = infinity, and a full epoch has not passed since the first packet arrival on the most recently joined wave channel then the receiver MUST not join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果接收机采用第3.2.2.6节所述的可选规则，SSR_P=无穷大，且自第一个数据包到达最近加入的波信道以来，未经过完整历元，则接收机不得加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the receiver is employing the OPTIONAL rule described in Section 3.2.2.6, SSR_P = infinity, and a full epoch has passed since the first packet arrival on the most recently joined wave channel, then the receiver checks if TRR_P is greatly below ARR_P as described in Section 3.2.2.6. If TRR_P is greatly below ARR_P the receiver MUST not join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果接收机采用第3.2.2.6节所述的可选规则，SSR_P=无穷大，并且自第一个数据包到达最近加入的波信道以来已过一个完整的历元，则接收机检查TRR_P是否大大低于第3.2.2.6节所述的ARR_P。如果TRR\u P大大低于ARR\u P，则接收器不得加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The receiver calculates REQN as described in Section 3.2.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接收器按照第3.2.2.3节中的说明计算REQN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The receiver calculates TRATE as described in Section 3.2.2.7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接收器按照第3.2.2.7节所述计算TRATE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the sender is not sending at constant aggregate rate and TRATE &lt; ARR_P*((1/P)^{NWC+2}-1)/((1/P)^{NWC+1}-1), the receiver MUST not join. If the sender is sending at constant aggregate rate and TRATE &lt; ARR_P*((1/P)^{NWC+2}-1)/((1/P)^{NWC+1}-1) and TRATE &lt; SR_P, the receiver MUST not join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果发送方未以恒定聚合速率发送，且策略&lt;ARR_P*（（1/P）^{NWC+2}-1）/（（1/P）^{NWC+1}-1），则接收方不得加入。如果发送方以恒定聚合速率发送，且TRATE&lt;ARR_P*（（1/P）^{NWC+2}-1）/（（1/P）^{NWC+1}-1）且TRATE&lt;SR_P，则接收方不得加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If SSR_P is finite and the sender is not sending at constant aggregate rate or SSR_P is finite and the sender is sending at constant aggregate rate and TRATE &lt; SR_P then the receiver MAY apply one additional OPTIONAL check before deciding to join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果SSR_P是有限的，发送方不以恒定聚合速率发送，或者SSR_P是有限的，发送方以恒定聚合速率发送，并且TRATE&lt;sru P，那么接收方可以在决定加入之前应用一个额外的可选检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
It is RECOMMENDED that the receiver not join if the value of RR_P is not sufficiently lower than the maximum value of RR_P observed since the last join. It is RECOMMENDED that RR_P is sufficiently low to allow a join if RR_P &lt;= max{RRmax-2/EL,P*RRmax}, where RRmax is the maximum measured RR_P since the last join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果RR_P的值不足以低于自上次连接以来观察到的最大值，则建议接收器不要连接。如果RR_P&lt;=max{RRmax-2/EL，P*RRmax}，建议RR_P足够低以允许连接，其中RRmax是自上次连接以来测量的最大rru P。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If the receiver does not join because RR_P is not sufficiently small then a value of LOSSP is calculated so as to make the value of the REQN equation given in Section 3.2.2.3 evaluate to ARR_P*((1/P)^(NWC+2)-1)/((1/P)^(NWC+1)-1) with respect to the current value of ARR_P. Then, the variables associated with LOSSP are reset based on this calculated value of LOSSP as described at the end of Section 3.2.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果接收机因RR_P不够小而未加入，则计算LOSSP的值，以使第3.2.2.3节中给出的REQN方程的值相对于ARR_P的当前值评估为ARR_P*（（1/P）^（NWC+2）-1）/（（1/P）^（NWC+1）-1），根据第3.2.2.1节末尾所述的LOSSP计算值重置与LOSSP相关的变量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Otherwise, the receiver MAY join the next higher layer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 否则，接收器可加入下一更高层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suppose the receiver has decided to join and CTSI = i. The receiver joins the next higher wave channel, i.e., the wave channel with CN = i+NWC modulo T, increments NWC by 1, and then updates ARR_P to ARR_P*((1/P)^{NWC+1}-1)/((1/P)^NWC-1) as described in Section 3.2.2.5. The time of the join is recorded for use in updating ARTT as described in Section 3.2.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设接收方已决定加入，且CTSI=i。接收器连接下一个较高的波通道，即CN=i+NWC模T的波通道，将NWC增加1，然后将ARR_P更新为ARR_P*（（1/P）^{NWC+1}-1）/（（1/P）^NWC-1），如第3.2.2.5节所述。如第3.2.2.2节所述，记录连接时间以用于更新ARTT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.7. Join timeout
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.7. 加入超时
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When no packet arrives in response to the join of channel for a long period of time, the join times out. The receiver sets JOINING to false, updates ARR_P to ARR_P*((1/P)^NWC-1)/((1/P)^{NWC+1}-1), and then decrements NWC by 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当很长一段时间内没有响应信道连接的数据包到达时，连接超时。接收器将连接设置为false，将ARR_P更新为ARR_P*（（1/P）^NWC-1）/（（1/P）^{NWC+1}-1），然后将NWC减1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RECOMMENDED threshold for a join timeout is max{2*V/ARTT,10*ARTT} seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加入超时的建议阈值最大为{2*V/ARTT，10*ARTT}秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.8. Exceptional timeouts
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3.8. 异常超时
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are timeouts when the packet reception behavior is far from what it should be and these MUST trigger the receiver to leave the session. Exceptional timeouts include
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当数据包接收行为与它应该的状态相差甚远时，这些都是超时，必须触发接收器离开会话。例外超时包括
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o No packets are received for a long period. A RECOMMENDED threshold is max{10,TSD} seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 长时间没有收到数据包。建议的阈值最大为{10，TSD}秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There is no change in time slot index for a long period. A RECOMMENDED threshold is max{20,2*TSD} seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在很长一段时间内，时隙指数没有变化。建议的阈值最大为{20,2*TSD}秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Applicability Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 适用性声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC is intended to be a congestion control scheme that can be used in a complete protocol instantiation that delivers objects and streams (both reliable content delivery and streaming of multimedia information). WEBRC is most applicable for delivery of objects or streams of substantial length, i.e., objects or streams that range in length from hundreds of kilobytes to many gigabytes, and whose transfer time is on the order of tens of seconds or more.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC旨在成为一种拥塞控制方案，可用于交付对象和流（可靠内容交付和多媒体信息流）的完整协议实例化。WEBRC最适用于传输长度相当长的对象或流，即长度从数百KB到数千GB的对象或流，其传输时间大约为数十秒或更长。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Environmental Requirements and Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 环境要求和考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC can be used with both multicast and unicast networks. However, the scope of this document is limited to multicast. WEBRC requires connectivity between a sender and receivers, but does not require connectivity from receivers to the sender.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC可用于多播和单播网络。但是，本文档的范围仅限于多播。WEBRC要求发送方和接收方之间的连接，但不要求接收方与发送方之间的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC inherently works with all types of networks, including LANs, WANs, Intranets, the Internet, asymmetric networks, wireless
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC天生适用于所有类型的网络，包括局域网、广域网、内部网、互联网、非对称网络、无线网络
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
networks, and satellite networks. Thus, the inherent raw scalability of WEBRC is unlimited. However, in some network environments varying reception rates to receivers may not be advantageous. For example, the network may have dedicated a fixed amount of bandwidth to the session or there may be no effective way for receivers to dynamically vary the set of channels they are joined to, as in a satellite network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
网络和卫星网络。因此，WEBRC固有的原始可伸缩性是无限的。然而，在一些网络环境中，改变接收机的接收速率可能不是有利的。例如，网络可能已经将固定数量的带宽专用于会话，或者可能没有有效的方式让接收机动态地改变它们所加入的信道集，如在卫星网络中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Receivers join and leave channels using the appropriate multicast join and leave messages. For IPv4 multicast, IGMP messages are used by receivers to join and leave channels. For IPv6, MLDv2 messages are used by receivers to join and leave channels. This is the only dependency of WEBRC on the IP version.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收者使用适当的多播加入和离开消息加入和离开频道。对于IPv4多播，接收器使用IGMP消息加入和离开通道。对于IPv6，接收器使用MLDv2消息加入和离开通道。这是WEBRC对IP版本的唯一依赖关系。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC requires receivers to be able to uniquely identify and demultiplex packets associated with a session in order to effectively perform congestion control over all packets associated with the session. How receivers achieve this is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC要求接收器能够唯一地识别和解复用与会话相关联的数据包，以便有效地对与会话相关联的所有数据包执行拥塞控制。接收者如何实现这一点超出了本文件的范围。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC is presumed to be used with an underlying network or transport service that is a &#34;best effort&#34; service that does not guarantee packet reception, packet reception order, and which does not have any support for flow or congestion control. For example, the Any-Source Multicast (ASM) model of IP multicast as defined in RFC 1112 [7] is such a best effort network service. While the basic service provided by RFC 1112 is largely scalable, providing congestion control or reliability should be done carefully to avoid severe scalability limitations, especially in the presence of heterogeneous sets of receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC被假定与底层网络或传输服务一起使用，该服务是“尽力而为”的服务，不保证数据包接收、数据包接收顺序，并且不支持流量或拥塞控制。例如，RFC 1112[7]中定义的IP多播的任意源多播（ASM）模型就是这样一种尽力而为的网络服务。虽然RFC 1112提供的基本服务在很大程度上是可伸缩的，但应小心地提供拥塞控制或可靠性，以避免严重的可伸缩性限制，特别是在存在异构接收机集的情况下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are currently two models of multicast delivery, the Any-Source Multicast (ASM) model as defined in RFC 1112 [7] and the Source-Specific Multicast (SSM) model as defined in [10]. WEBRC works with both multicast models, but in a slightly different way with somewhat different environmental concerns. When using ASM, a sender S sends packets to a multicast group G, and the WEBRC channel address consists of the pair (S,G), where S is the IP address of the sender and G is a multicast group address. When using SSM, a sender S sends packets to an SSM channel (S,G), and the WEBRC channel address coincides with the SSM channel address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目前有两种多播交付模型，RFC 1112[7]中定义的任意源多播（ASM）模型和[10]中定义的源特定多播（SSM）模型。WEBRC可用于这两种多播模型，但在环境问题上略有不同。当使用ASM时，发送方S向多播组G发送数据包，WEBRC通道地址由该对（S，G）组成，其中S是发送方的IP地址，G是多播组地址。当使用SSM时，发送方S向SSM通道（S，G）发送数据包，并且WEBRC通道地址与SSM通道地址一致。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender can locally allocate unique SSM channel addresses, and this makes allocation of channel addresses easy with SSM. To allocate channel addresses using ASM, the sender must uniquely chose the ASM multicast group address across the scope of the group, and this makes allocation of WEBRC channel addresses more difficult with ASM. This is an issue for WEBRC because several channels are used per session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送方可以在本地分配唯一的SSM通道地址，这使得SSM可以轻松地分配通道地址。要使用ASM分配通道地址，发送方必须在整个组范围内唯一选择ASM多播组地址，这使得使用ASM分配WEBRC通道地址更加困难。这是WEBRC的一个问题，因为每个会话使用多个通道。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC channels and SSM channels coincide, and thus the receiver will only receive packets sent to the requested WEBRC channel. With ASM, the receiver joins a channel by joining a multicast group G, and all packets sent to G, regardless of the sender, may be received by the receiver. Thus, SSM has compelling security advantages over ASM for prevention of denial of service attacks. In either case, receivers SHOULD use mechanisms to filter out packets from unwanted sources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC通道和SSM通道重合，因此接收器将只接收发送到请求的WEBRC通道的数据包。使用ASM，接收器通过加入多播组G来加入信道，并且发送到G的所有数据包，无论发送者是谁，都可以由接收器接收。因此，与ASM相比，SSM在防止拒绝服务攻击方面具有引人注目的安全优势。在这两种情况下，接收者都应该使用机制从不需要的来源过滤掉数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC assumes that the packet route between the sender and a particular receiver is the same for all channels associated with a session. For SSM this assumption is true because the multicast tree is a shortest path tree from each receiver to the sender and generally this path changes infrequently. For ASM there are some issues that if not properly considered may invalidate this assumption. With ASM, the packet route between the sender and receivers may initially be through the Rendezvous Point (RP) and then switch over to the shortest path to the sender as packets start flowing in a channel. The first issue is that the RP may not be the same for all channels associated with a session, and thus the first packets sent to the channels may follow a route that depends on the RP of the channel. This depends on the RP configuration for the sender. If the sender registers all channels associated with the session with the same RP then the assumption is true, but if the sender registers different channels with different RPs then the assumption may not be true. Thus, it is RECOMMENDED that the sender register all channels associated with a session with the same RP. Another issue is that when the channel switches over from the RP to the sender-based tree then the route to the receivers may vary within a channel. Furthermore, this may cause either the receipt of duplicate packets at receivers or loss of packets depending on the smoothness of the switchover. Thus, it is RECOMMENDED that the RP be placed as close as possible to the sender. The best location for the RP is that it be the first-hop router closest to the sender, in which case the path to the sender and the path to the RP is the same for each receiver and the problems mentioned above are eliminated. The consequences of this assumption not being true are that the receiver reaction to congestion may not be appropriate. Generally, the WEBRC receiver will act conservatively and reduce its reception rate too much if this assumption is not true, but there can be cases where the receivers will act inappropriately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC假设发送方和特定接收方之间的数据包路由对于与会话相关联的所有通道都是相同的。对于SSM，这一假设是正确的，因为多播树是从每个接收方到发送方的最短路径树，并且通常该路径很少改变。对于ASM，有些问题如果考虑不当可能会使该假设无效。使用ASM，发送方和接收方之间的数据包路由最初可能通过集合点（RP），然后在数据包开始在信道中流动时切换到到到发送方的最短路径。第一个问题是，对于与会话相关联的所有信道，RP可能不相同，因此发送到信道的第一分组可能遵循依赖于信道的RP的路由。这取决于发送方的RP配置。如果发送方使用相同的RP注册与会话相关的所有通道，则该假设为真，但如果发送方使用不同的RP注册不同的通道，则该假设可能为假。因此，建议发送方使用相同RP注册与会话相关的所有信道。另一个问题是，当信道从RP切换到基于发送方的树时，到接收机的路由可能在信道内变化。此外，这可能导致在接收器处接收重复的分组或分组丢失，这取决于切换的平滑度。因此，建议将RP放置在尽可能靠近发送器的位置。RP的最佳位置是它是距离发送方最近的第一跳路由器，在这种情况下，对于每个接收机，到发送方的路径和到RP的路径是相同的，并且消除了上述问题。这种假设不成立的后果是，接收者对拥塞的反应可能不恰当。通常，如果该假设不成立，WEBRC接收器将采取保守行动，并过度降低其接收速率，但也可能出现接收器行动不当的情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Packet Header Fields
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 包头字段
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packets sent to a session using WEBRC MUST include Congestion Control Information fields as specified in this section. This document specifies short and long formats for the Congestion Control Information, and it is RECOMMENDED that protocol instantiations use one of these two formats. Other formats for the Congestion Control
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用WEBRC发送到会话的数据包必须包含本节中指定的拥塞控制信息字段。本文档指定了拥塞控制信息的短格式和长格式，建议协议实例化使用这两种格式之一。拥塞控制的其他格式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information fields MAY be used by protocol instantiations, but all protocol instantiations are REQUIRED to use these fields in a format that is compatible with the interpretations of these fields. Thus, if a protocol does use a different format for the fields in the Congestion Control Information then it MUST specify the lengths and positions of these fields within the packet header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
协议实例化可以使用信息字段，但所有协议实例化都需要以与这些字段的解释兼容的格式使用这些字段。因此，如果协议对拥塞控制信息中的字段使用不同的格式，那么它必须指定这些字段在数据包报头中的长度和位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All integer fields are carried in &#34;big-endian&#34; or &#34;network order&#34; format, that is, most significant byte (octet) first. All constants, unless otherwise specified, are expressed in base ten.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有整数字段都以“big-endian”或“network-order”格式携带，也就是说，首先是最高有效字节（octet）。除非另有规定，否则所有常数均以十进制表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Short Format Congestion Control Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 短格式拥塞控制信息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The short format for the Congestion Control Information is shown in Fig. 1. The total length of the short format is 32-bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拥塞控制信息的简短格式如图1所示。短格式的总长度为32位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      CTSI     | Channel Number|    Packet Sequence Number     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      CTSI     | Channel Number|    Packet Sequence Number     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fig. 1 - Short format for Congestion Control Information
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图1-拥塞控制信息的简短格式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The function of each field in the Congestion Control Information is the following.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拥塞控制信息中每个字段的功能如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Current Time Slot Index (CTSI): 8 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
当前时隙索引（CTSI）：8位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CTSI indicates the index of the current time slot. This must be sent in each packet within the session. The Current Time Slot Index increases by one modulo T each TSD seconds at the sender, where T is the number of time slots associated with the session and TSD is the time slot duration. Note that T is also the number of wave channels associated with the session, and thus T MUST be at most 255.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CTSI表示当前时隙的索引。这必须在会话中的每个数据包中发送。当前时隙索引在发送方每TSD秒增加一个模T，其中T是与会话相关联的时隙数，TSD是时隙持续时间。请注意，T也是与会话相关联的波通道数，因此T最多必须为255。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Channel Number (CN): 8 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
通道号（CN）：8位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CN is the channel number that this packet belongs to. CN for the base channel is T, and the CNs for the wave channels are 0 through T-1. Thus, T+1 channels in total are used, and thus T MUST be at most 255.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CN是此数据包所属的通道号。基本通道的CN为T，波通道的CN为0到T-1。因此，总共使用T+1个通道，因此T最多必须为255个。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet Sequence Number (PSN): 16 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
数据包序列号（PSN）：16位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The PSN of each packet is scoped by its CN value. The sequence numbers of consecutive packets sent to the base channel are
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
每个数据包的PSN由其CN值确定范围。发送到基本信道的连续分组的序列号为
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
numbered consecutively modulo 2^16. The same sequence of PSNs are used for each wave channel in each cycle. The sequence numbers of consecutive packets sent to a wave channel are numbered consecutively modulo 2^16 within each cycle, ending with the last packet sent to the channel before the channel goes quiescent with PSN = 2^16-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
按模2^16连续编号。每个周期的每个波道使用相同的PSN序列。发送到波形信道的连续数据包的序列号在每个周期内按2^16的模连续编号，以发送到信道的最后一个数据包结束，然后信道进入静止状态，PSN=2^16-1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Long Format Congestion Control Information
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 长格式拥塞控制信息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The long format for the Congestion Control Information is shown in Fig. 2. The total length of the long format is 64-bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拥塞控制信息的长格式如图2所示。长格式的总长度为64位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             CTSI              |        Channel Number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Packet Sequence Number                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             CTSI              |        Channel Number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Packet Sequence Number                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fig. 2 - Long format for Congestion Control Information
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
图2-拥塞控制信息的长格式
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of each field for the long format is the same as for the short format, the only difference is that each field is twice as long.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长格式的每个字段的含义与短格式相同，唯一的区别是每个字段的长度是短格式的两倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Current Time Slot Index (CTSI): 16 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
当前时隙索引（CTSI）：16位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CTSI indicates the index of the current time slot. This must be sent in each packet within the session. The Current Time Slot Index increases by one modulo T each TSD seconds at the sender, where T is the number of time slots associated with the session and TSD is the time slot duration. Note that T is also the number of wave channels associated with the session, and thus T MUST be at most 65,535.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CTSI表示当前时隙的索引。这必须在会话中的每个数据包中发送。当前时隙索引在发送方每TSD秒增加一个模T，其中T是与会话相关联的时隙数，TSD是时隙持续时间。请注意，T也是与会话相关的波通道数，因此T最多必须为65535。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Channel Number (CN): 16 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
通道号（CN）：16位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CN is the channel number that this packet belongs to. CN for the base channel is T, and the CNs for the wave channels are 0 through T-1. Thus, T+1 channels in total are used, and thus T MUST be at most 65,535.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
CN是此数据包所属的通道号。基本通道的CN为T，波通道的CN为0到T-1。因此，总共使用了T+1通道，因此T最多必须为65535。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Packet Sequence Number (PSN): 32 bits
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
数据包序列号（PSN）：32位
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
The PSN of each packet is scoped by its CN value. The sequence numbers of consecutive packets sent to the base channel are numbered consecutively modulo 2^32. The same sequence of PSNs
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
每个数据包的PSN由其CN值确定范围。发送到基本信道的连续数据包的序列号以2^32的模连续编号。相同序列的PSN
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
are used for each wave channel in each cycle. The sequence numbers of consecutive packets sent to a wave channel are numbered consecutively modulo 2^32 within each cycle, ending with the last packet sent to the channel before the channel goes quiescent with PSN = 2^32-1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
用于每个周期中的每个波道。发送到波形信道的连续数据包的序列号在每个周期内按2^32的模连续编号，以信道静止前发送到信道的最后一个数据包结束，PSN=2^32-1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Requirements From Other Building Blocks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 来自其他构建块的需求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in RFC 3048 [4], WEBRC is a building block that is intended to be used, in conjunction with other building blocks, to help specify a protocol instantiation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如RFC 3048[4]所述，WEBRC是一个构建块，旨在与其他构建块一起使用，以帮助指定协议实例化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC does not provide higher level session support, e.g., how receivers obtain the necessary session description and how the receivers demultiplex received packets based on their session. There is support provided by other building blocks that can be used in conjunction with WEBRC to provide some of this support. For example, LCT [12] can provide some of the higher level in-band session support that may be needed by receivers, and the WEBRC Congestion Control Information (CCI) required in each packet can be carried in the CCI field of the LCT header [12].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC不提供更高级别的会话支持，例如，接收器如何获得必要的会话描述，以及接收器如何基于其会话解复用接收的数据包。其他构建块提供了一些支持，可以与WEBRC结合使用来提供一些这种支持。例如，LCT[12]可以提供接收机可能需要的一些更高级别的带内会话支持，并且每个分组中所需的WEBRC拥塞控制信息（CCI）可以在LCT报头[12]的CCI字段中携带。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC does not provide any type of reliability, and in particular does not provide support for retransmission of loss packets. Reliability can be added by independent means, such as by the use of FEC codes as described in [13] and specified in the FEC building block [14].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC不提供任何类型的可靠性，尤其不支持丢失数据包的重新传输。可靠性可以通过独立的方式增加，如使用[13]中所述的FEC代码和FEC构建块[14]中规定的FEC代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC can be subject to denial-of-service attacks by attackers that try to confuse the congestion control mechanism for receivers by injecting forged packets into the multicast stream. This attack most adversely affects network elements and receivers downstream of the attack, and much less significantly the rest of the network and other receivers. Because of this and because of the potential attacks due to the use of FEC described above, it is RECOMMENDED that Reverse Path Forwarding checks be enabled in all network routers and switches along the path from the sender to receivers to limit the possibility of a bad agent injecting forged packets into the multicast tree data path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC可能受到攻击者的拒绝服务攻击，攻击者试图通过向多播流中注入伪造数据包来混淆接收方的拥塞控制机制。这种攻击对攻击下游的网络元件和接收者的影响最大，对网络其余部分和其他接收者的影响较小。由于这一点以及由于使用上述FEC而导致的潜在攻击，建议在从发送方到接收方的路径上的所有网络路由器和交换机中启用反向路径转发检查，以限制坏代理将伪造数据包注入多播树数据路径的可能性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is also RECOMMENDED that packet authentication be used to authenticate each packet immediately upon receipt before the receiver performs any WEBRC actions based upon its receipt. Unfortunately, there are currently no practical multicast packet authentication schemes that offer instant packet authentication upon receipt. However, TESLA [17] can be used to authenticate each packet a few
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还建议使用数据包身份验证，在接收方根据其接收执行任何WEBRC操作之前，在收到数据包后立即对其进行身份验证。不幸的是，目前还没有实用的多播数据包认证方案能够在收到数据包时提供即时数据包认证。然而，特斯拉[17]可以在几分钟内对每个数据包进行身份验证
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
seconds after receipt. Thus, TESLA could be used in conjunction with WEBRC to authenticate packets and for example terminate the session upon detection of a forged packet. However, it is RECOMMENDED that the normal WEBRC receiver responses to received packets occur immediately -- not delayed by the TESLA authentication process. This is because the overall WEBRC performance would be greatly degraded if the receiver delayed its WEBRC response to packet receipt for several seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
收到后几秒钟。因此，TESLA可与WEBRC结合使用以认证分组，并且例如在检测到伪造分组时终止会话。但是，建议立即对接收到的数据包进行正常的WEBRC接收器响应，而不是被特斯拉认证过程延迟。这是因为，如果接收器将其对数据包接收的WEBRC响应延迟几秒钟，则整个WEBRC性能将大大降低。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A receiver with an incorrect or corrupted implementation of WEBRC may affect health of the network in the path between the sender and the receiver, and may also affect the reception rates of other receivers joined to the session. It is therefore RECOMMENDED that receivers be required to identify themselves as legitimate before they receive the session description needed to join the session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
具有不正确或损坏的WEBRC实现的接收器可能会影响发送方和接收器之间路径中的网络健康，并且还可能会影响加入会话的其他接收器的接收速率。因此，建议要求接收者在接收加入会话所需的会话描述之前将自己标识为合法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another vulnerability of WEBRC is the potential of receivers obtaining an incorrect session description for the session. The consequences of this could be that legitimate receivers with the wrong session description are unable to correctly receive the session content, or that receivers inadvertently try to receive at a much higher rate than they are capable of, thereby disrupting traffic in portions of the network. To avoid these problems, it is RECOMMENDED that measures be taken to prevent receivers from accepting incorrect session descriptions, e.g., by using source authentication to ensure that receivers only accept legitimate session descriptions from authorized senders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
WEBRC的另一个漏洞是接收者可能获得不正确的会话描述。这可能导致具有错误会话描述的合法接收器无法正确接收会话内容，或者接收器无意中尝试以远高于其能力的速率接收，从而中断网络部分中的通信。为了避免这些问题，建议采取措施防止接收者接受不正确的会话描述，例如，通过使用源身份验证确保接收者只接受来自授权发送者的合法会话描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Kermode, R. and L. Vicisano, &#34;Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents&#34;, RFC 3269, April 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Kermode，R.和L.Vicisano，“可靠多播传输（RMT）构建块和协议实例化文档的作者指南”，RFC 3269，2002年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Mankin, A., Romanow, A., Bradner, S. and V. Paxson, &#34;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols&#34;, RFC 2357, June 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Mankin，A.，Romanow，A.，Bradner，S.和V.Paxson，“IETF评估可靠多播传输和应用协议的标准”，RFC 2357，1998年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S. and M. Luby, &#34;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer&#34;, RFC 3048, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Whetten，B.，Vicisano，L.，Kermode，R.，Handley，M.，Floyd，S.和M.Luby，“一对多批量数据传输的可靠多播传输构建块”，RFC 3048，2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Byers, J., Horn, G., Luby, M., Mitzenmacher, M. and W. Shaver. &#34;FLID-DL: Congestion control for layered multicast,&#34; IEEE J. on Selected Areas in Communications, Special Issue on Network Support for Multicast Communication, Vol. 20, No. 8, October 2002, pp. 1558-1570.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] 拜尔斯，J.，霍恩，G.，卢比，M.，米岑马赫，M.和W.剃须刀。“FLID-DL：分层多播的拥塞控制”，《IEEE J.通信中的选定领域》，关于多播通信的网络支持的特刊，第20卷，第8期，2002年10月，第1558-1570页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Dagum, P., Karp, R., Luby, M. and S. Ross, &#34;An optimal algorithm for Monte Carlo estimation,&#34; SIAM J. Comput., 29(5):1484-1496, April 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Dagum，P.，Karp，R.，Luby，M.和S.Ross，“蒙特卡罗估计的最佳算法”，暹罗计算机杂志，29（5）：1484-1496，2000年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Deering, S., &#34;Host Extensions for IP Multicasting&#34;, STD 5, RFC 1112, August 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Deering，S.，“IP多播的主机扩展”，STD 5，RFC 1112，1989年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Goyal, V., &#34;On WEBRC Wave Design and Server Implementation&#34;, Digital Fountain Technical Report no. DF2002-09-001, September 2002, available at http://www.digitalfountain.com/technology/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Goyal，V.，“关于WEBRC Wave设计和服务器实现”，数字喷泉技术报告编号DF2002-09-001，2002年9月，可在http://www.digitalfountain.com/technology/.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Handley, M., Floyd, S., Padhye, J. and J. Widmer, &#34;TCP Friendly Rate Control (TFRC): Protocol Specification&#34;, RFC 3448, January 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] Handley，M.，Floyd，S.，Padhye，J.和J.Widmer，“TCP友好速率控制（TFRC）：协议规范”，RFC 3448，2003年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Holbrook, H., &#34;A Channel Model for Multicast&#34;, Ph.D. Dissertation, Stanford University, Department of Computer Science, Stanford, California, August 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] 霍尔布鲁克，H.，“多播的信道模型”，博士。斯坦福大学计算机科学系博士论文，斯坦福，加利福尼亚，2001年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Luby, M., Gemmell, J., Vicisano, L., Rizzo, L. and J. Crowcroft, &#34;Asynchronous Layered Coding (ALC) Protocol Instantiation&#34;, RFC 3450, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Luby，M.，Gemmell，J.，Vicisano，L.，Rizzo，L.和J.Crowcroft，“异步分层编码（ALC）协议实例化”，RFC 3450，2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Luby, M., Gemmell, J., Vicisano, L., Rizzo, L., Handley, M. and J. Crowcroft, &#34;Layered Coding Transport (LCT) Building Block&#34;, RFC 3451, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Luby，M.，Gemmell，J.，Vicisano，L.，Rizzo，L.，Handley，M.和J.Crowcroft，“分层编码传输（LCT）构建块”，RFC 34512002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M. and J. Crowcroft, &#34;The Use of Forward Error Correction (FEC) in Reliable Multicast&#34;, RFC 3453, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Luby，M.，Vicisano，L.，Gemmell，J.，Rizzo，L.，Handley，M.和J.Crowcroft，“前向纠错（FEC）在可靠多播中的使用”，RFC 3453，2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M. and J. Crowcroft, &#34;Forward Error Correction (FEC) Building Block&#34;, RFC 3452, December 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] 卢比，M.，维西萨诺，L.，杰梅尔，J.，里佐，L.，汉德利，M.和J.克罗夫特，“前向纠错（FEC）构建块”，RFC 3452，2002年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Luby, M. and V. Goyal, &#34;Wave and Equation Based Rate Control Using Multicast Round Trip Time: Extended Report&#34;, Digital Fountain Technical Report no. DF2002-07-001, September 2002, available at http://www.digitalfountain.com/technology/.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Luby，M.和V.Goyal，“使用多播往返时间的基于波动和方程的速率控制：扩展报告”，数字喷泉技术报告编号DF2002-07-001，2002年9月，可在http://www.digitalfountain.com/technology/.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Luby, M., Goyal, V., Skaria, S. and G. Horn, &#34;Wave and Equation Based Rate Control Using Multicast Round Trip Time&#34;, Proc. ACM SIGCOMM 2002, Pittsburgh, PA, August 2002, pp. 191-214.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Luby，M.，Goyal，V.，Skaria，S.和G.Horn，“使用多播往返时间的基于波动和方程的速率控制”，Proc。ACM SIGCOMM 2002，宾夕法尼亚州匹兹堡，2002年8月，第191-214页。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Perrig, A., Canetti, R., Song, D. and J. Tygar, &#34;Efficient and Secure Source Authentication for Multicast&#34;, Network and Distributed System Security Symposium, NDSS 2001, pp. 35-46, February 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Perrig，A.，Canetti，R.，Song，D.和J.Tygar，“多播的高效和安全源认证”，网络和分布式系统安全研讨会，NDSS 2001，第35-46页，2001年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Vicisano, L., Rizzo, L. and J. Crowcroft, &#34;TCP-like Congestion Control for Layered Multicast Data Transfer&#34;, Proc. IEEE Infocom &#39;98, San Francisco, CA, March-April 1998, pp. 996-1003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Vicisano，L.，Rizzo，L.和J.Crowcroft，“分层多播数据传输的类TCP拥塞控制”，Proc。IEEE iFocom 98，旧金山，CA，3月1998年4月，pp.96－1003。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Authors&#39; Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 作者地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Michael Luby Digital Fountain 39141 Civic Center Drive, Suite 300 Fremont, CA, USA, 94538
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
迈克尔·鲁比数字喷泉美国加利福尼亚州弗里蒙特市市民中心大道39141号300室，邮编94538
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: luby@digitalfountain.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: luby@digitalfountain.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vivek K Goyal Massachusetts Institute of Technology Room 36-690 77 Massachusetts Avenue Cambridge, MA, USA, 02139
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Vivek K Goyal麻省理工学院美国马萨诸塞州剑桥市马萨诸塞大道77号36-690室，邮编：02139
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: v.goyal@ieee.org
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: v.goyal@ieee.org
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Full Copyright Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 完整版权声明
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2004). This document is subject to the rights, licenses and restrictions contained in BCP 78 and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2004年）。本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其包含的信息是按“原样”提供的，贡献者、他/她所代表或赞助的组织（如有）、互联网协会和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
确认
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC编辑功能的资金目前由互联网协会提供。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
