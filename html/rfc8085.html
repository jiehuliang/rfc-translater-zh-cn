<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 8085: UDP Usage Guidelines中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC8085 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">8085</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://www.rfc-editor.org/rfc/rfc8085.html">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">原文</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 8085: UDP Usage Guidelines 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc8085" target="_blank">
              https://datatracker.ietf.org/doc/html/rfc8085
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 8085</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         L. Eggert
Request for Comments: 8085                                        NetApp
BCP: 145                                                    G. Fairhurst
Obsoletes: 5405                                   University of Aberdeen
Category: Best Current Practice                              G. Shepherd
ISSN: 2070-1721                                            Cisco Systems
                                                              March 2017
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                         L. Eggert
Request for Comments: 8085                                        NetApp
BCP: 145                                                    G. Fairhurst
Obsoletes: 5405                                   University of Aberdeen
Category: Best Current Practice                              G. Shepherd
ISSN: 2070-1721                                            Cisco Systems
                                                              March 2017
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
UDP Usage Guidelines
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-26">
UDP使用指南
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms. This document provides guidelines on the use of UDP for the designers of applications, tunnels, and other protocols that use UDP. Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, middlebox traversal, the use of Explicit Congestion Notification (ECN), Differentiated Services Code Points (DSCPs), and ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户数据报协议（UDP）提供最小的消息传递传输，没有固有的拥塞控制机制。本文档为使用UDP的应用程序、隧道和其他协议的设计者提供了UDP使用指南。拥塞控制指南是主要关注点，但本文档还提供了其他主题的指南，包括消息大小、可靠性、校验和、中间盒遍历、显式拥塞通知（ECN）、区分服务代码点（DSCP）和端口的使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because congestion control is critical to the stable operation of the Internet, applications and other protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic. They may also need to implement additional mechanisms, depending on how they use UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于拥塞控制对Internet的稳定运行至关重要，因此选择使用UDP作为Internet传输的应用程序和其他协议必须采用各种机制来防止拥塞崩溃，并对并发流量建立一定程度的公平性。他们可能还需要实现额外的机制，这取决于他们如何使用UDP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some guidance is also applicable to the design of other protocols (e.g., protocols layered directly on IP or via IP-based tunnels), especially when these protocols do not themselves provide congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一些指南也适用于其他协议（例如，直接在IP上分层的协议或通过基于IP的隧道分层的协议）的设计，特别是当这些协议本身不提供拥塞控制时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document obsoletes RFC 5405 and adds guidelines for multicast UDP usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档淘汰了RFC 5405，并添加了多播UDP使用指南。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo documents an Internet Best Current Practice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本备忘录记录了互联网最佳实践。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 7841.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。有关BCP的更多信息，请参见RFC 7841第2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc8085.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc8085.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2017 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（c）2017 IETF信托基金和确定为文件作者的人员。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................3
   2. Terminology .....................................................5
   3. UDP Usage Guidelines ............................................5
      3.1. Congestion Control Guidelines ..............................6
      3.2. Message Size Guidelines ...................................19
      3.3. Reliability Guidelines ....................................21
      3.4. Checksum Guidelines .......................................22
      3.5. Middlebox Traversal Guidelines ............................25
      3.6. Limited Applicability and Controlled Environments .........27
   4. Multicast UDP Usage Guidelines .................................28
      4.1. Multicast Congestion Control Guidelines ...................30
      4.2. Message Size Guidelines for Multicast .....................32
   5. Programming Guidelines .........................................32
      5.1. Using UDP Ports ...........................................34
      5.2. ICMP Guidelines ...........................................37
   6. Security Considerations ........................................38
   7. Summary ........................................................40
   8. References .....................................................42
      8.1. Normative References ......................................42
      8.2. Informative References ....................................43
   Appendix A. .......................................................53
   Acknowledgments ...................................................55
   Authors&#39; Addresses ................................................55
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1. Introduction ....................................................3
   2. Terminology .....................................................5
   3. UDP Usage Guidelines ............................................5
      3.1. Congestion Control Guidelines ..............................6
      3.2. Message Size Guidelines ...................................19
      3.3. Reliability Guidelines ....................................21
      3.4. Checksum Guidelines .......................................22
      3.5. Middlebox Traversal Guidelines ............................25
      3.6. Limited Applicability and Controlled Environments .........27
   4. Multicast UDP Usage Guidelines .................................28
      4.1. Multicast Congestion Control Guidelines ...................30
      4.2. Message Size Guidelines for Multicast .....................32
   5. Programming Guidelines .........................................32
      5.1. Using UDP Ports ...........................................34
      5.2. ICMP Guidelines ...........................................37
   6. Security Considerations ........................................38
   7. Summary ........................................................40
   8. References .....................................................42
      8.1. Normative References ......................................42
      8.2. Informative References ....................................43
   Appendix A. .......................................................53
   Acknowledgments ...................................................55
   Authors&#39; Addresses ................................................55
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The User Datagram Protocol (UDP) [RFC768] provides a minimal, unreliable, best-effort, message-passing transport to applications and other protocols (such as tunnels) that wish to operate over IP. Both are simply called &#34;applications&#34; in the remainder of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户数据报协议（UDP）[RFC768]向希望在IP上运行的应用程序和其他协议（如隧道）提供最小、不可靠、尽最大努力的消息传递传输。在本文档的其余部分中，这两种方法都称为“应用程序”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compared to other transport protocols, UDP and its UDP-Lite variant [RFC3828] are unique in that they do not establish end-to-end connections between communicating end systems. UDP communication consequently does not incur connection establishment and teardown overheads, and there is minimal associated end-system state. Because of these characteristics, UDP can offer a very efficient communication transport to some applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与其他传输协议相比，UDP及其UDP Lite变体[RFC3828]的独特之处在于它们不在通信端系统之间建立端到端连接。因此，UDP通信不会产生连接建立和拆卸开销，并且关联的终端系统状态最小。由于这些特性，UDP可以为某些应用程序提供非常高效的通信传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A second unique characteristic of UDP is that it provides no inherent congestion control mechanisms. On many platforms, applications can send UDP datagrams at the line rate of the platform&#39;s link interface, which is often much greater than the available end-to-end path capacity, and doing so contributes to congestion along the path. [RFC2914] describes the best current practice for congestion control
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP的第二个独特特性是它不提供固有的拥塞控制机制。在许多平台上，应用程序可以以平台链路接口的线路速率发送UDP数据报，该速率通常远大于可用的端到端路径容量，这样做会导致路径上的拥塞。[RFC2914]描述了当前拥塞控制的最佳实践
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
in the Internet. It identifies two major reasons why congestion control mechanisms are critical for the stable operation of the Internet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在互联网上。它指出了拥塞控制机制对互联网稳定运行至关重要的两个主要原因：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The prevention of congestion collapse, i.e., a state where an increase in network load results in a decrease in useful work done by the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 防止拥塞崩溃，即网络负载增加导致网络所做有用功减少的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The establishment of a degree of fairness, i.e., allowing multiple flows to share the capacity of a path reasonably equitably.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 建立一定程度的公平性，即允许多个流合理公平地共享路径的容量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because UDP itself provides no congestion control mechanisms, it is up to the applications that use UDP for Internet communication to employ suitable mechanisms to prevent congestion collapse and establish a degree of fairness. [RFC2309] discusses the dangers of congestion-unresponsive flows and states that &#34;all UDP-based streaming applications should incorporate effective congestion avoidance mechanisms.&#34; [RFC7567] reaffirms this statement. This is an important requirement, even for applications that do not use UDP for streaming. In addition, congestion-controlled transmission is of benefit to an application itself, because it can reduce self-induced packet loss, minimize retransmissions, and hence reduce delays. Congestion control is essential even at relatively slow transmission rates. For example, an application that generates five 1500-byte UDP datagrams in one second can already exceed the capacity of a 56 Kb/s path. For applications that can operate at higher, potentially unbounded data rates, congestion control becomes vital to prevent congestion collapse and establish some degree of fairness. Section 3 describes a number of simple guidelines for the designers of such applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于UDP本身不提供拥塞控制机制，因此使用UDP进行Internet通信的应用程序需要采用合适的机制来防止拥塞崩溃并建立一定程度的公平性。[RFC2309]讨论了拥塞无响应流的危险，并指出“所有基于UDP的流应用程序都应包含有效的拥塞避免机制。”[RFC7567]重申了这一说法。这是一个重要的要求，即使对于不使用UDP进行流传输的应用程序也是如此。此外，拥塞控制传输对应用程序本身有利，因为它可以减少自诱导的数据包丢失，最小化重传，从而减少延迟。即使在传输速率相对较慢的情况下，拥塞控制也是必不可少的。例如，在一秒钟内生成五个1500字节UDP数据报的应用程序可能已经超过56 Kb/s路径的容量。对于能够以更高的、可能无限的数据速率运行的应用程序，拥塞控制对于防止拥塞崩溃和建立某种程度的公平性至关重要。第3节为此类应用程序的设计者介绍了一些简单的指南。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP datagram is carried in a single IP packet and is hence limited to a maximum payload of 65,507 bytes for IPv4 and 65,527 bytes for IPv6. The transmission of large IP packets usually requires IP fragmentation. Fragmentation decreases communication reliability and efficiency and should be avoided. IPv6 allows the option of transmitting large packets (&#34;jumbograms&#34;) without fragmentation when all link layers along the path support this [RFC2675]. Some of the guidelines in Section 3 describe how applications should determine appropriate message sizes. Other sections of this document provide guidance on reliability, checksums, middlebox traversal and use of multicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP数据报在单个IP数据包中承载，因此IPv4的最大有效负载限制为65507字节，IPv6的最大有效负载限制为65527字节。大型IP数据包的传输通常需要IP分段。碎片会降低通信的可靠性和效率，应该避免。当路径上的所有链路层都支持此选项时，IPv6允许无碎片地传输大数据包（“巨型程序”）[RFC2675]。第3节中的一些指南描述了应用程序应该如何确定适当的消息大小。本文档的其他部分提供了有关可靠性、校验和、中间盒遍历和多播使用的指导。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document provides guidelines and recommendations. Although most UDP applications are expected to follow these guidelines, there do exist valid reasons why a specific application may decide not to follow a given guideline. In such cases, it is RECOMMENDED that
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件提供了指导方针和建议。尽管大多数UDP应用程序都应该遵循这些准则，但确实存在一些正当的理由说明特定应用程序可能决定不遵循给定的准则。在这种情况下，建议
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
application designers cite the respective section(s) of this document in the technical specification of their application or protocol and explain their rationale for their design choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序设计者在其应用程序或协议的技术规范中引用了本文件的相应章节，并解释了其设计选择的基本原理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] was scoped to provide guidelines for unicast applications only, whereas this document also provides guidelines for UDP flows that use IP anycast, multicast, broadcast, and applications that use UDP tunnels to support IP flows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405]的范围仅限于为单播应用程序提供指南，而本文档还为使用IP选播、多播、广播的UDP流以及使用UDP隧道支持IP流的应用程序提供指南。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, although this document specifically refers to usage of UDP, the spirit of some of its guidelines also applies to other message-passing applications and protocols (specifically on the topics of congestion control, message sizes, and reliability). Examples include signaling, tunnel or control applications that choose to run directly over IP by registering their own IP protocol number with IANA. This document is expected to provide useful background reading to the designers of such applications and protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，尽管本文档特别提到UDP的使用，但其一些指导原则的精神也适用于其他消息传递应用程序和协议（特别是关于拥塞控制、消息大小和可靠性的主题）。例如，通过向IANA注册自己的IP协议号，选择直接在IP上运行的信令、隧道或控制应用程序。本文件有望为此类应用程序和协议的设计者提供有用的背景资料。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 术语
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;NOT RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“建议”、“不建议”、“可”和“可选”应按照[RFC2119]中的说明进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. UDP Usage Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. UDP使用指南
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet paths can have widely varying characteristics, including transmission delays, available bandwidths, congestion levels, reordering probabilities, supported message sizes, or loss rates. Furthermore, the same Internet path can have very different conditions over time. Consequently, applications that may be used on the Internet MUST NOT make assumptions about specific path characteristics. They MUST instead use mechanisms that let them operate safely under very different path conditions. Typically, this requires conservatively probing the current conditions of the Internet path they communicate over to establish a transmission behavior that it can sustain and that is reasonably fair to other traffic sharing the path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet路径可以具有各种各样的特性，包括传输延迟、可用带宽、拥塞级别、重新排序概率、支持的消息大小或丢失率。此外，随着时间的推移，相同的互联网路径可能具有非常不同的条件。因此，可在互联网上使用的应用程序不得对特定路径特征进行假设。相反，它们必须使用能够在完全不同的路径条件下安全运行的机制。通常，这需要保守地探测他们通信的互联网路径的当前状况，以建立一种传输行为，该行为可以维持，并且对共享该路径的其他通信量合理公平。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These mechanisms are difficult to implement correctly. For most applications, the use of one of the existing IETF transport protocols is the simplest method of acquiring the required mechanisms. Doing so also avoids issues that protocols using a new IP protocol number face when being deployed over the Internet, where middleboxes that only support TCP and UDP are sometimes present. Consequently, the RECOMMENDED alternative to the UDP usage described in the remainder of this section is the use of an IETF transport protocol such as TCP
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些机制很难正确实施。对于大多数应用，使用现有的IETF传输协议之一是获取所需机制的最简单方法。这样做还可以避免在Internet上部署使用新IP协议号的协议时遇到的问题，在Internet上，有时会出现仅支持TCP和UDP的中间盒。因此，建议使用IETF传输协议（如TCP）代替本节剩余部分中描述的UDP使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793], Stream Control Transmission Protocol (SCTP) [RFC4960], and SCTP Partial Reliability Extension (SCTP-PR) [RFC3758], or Datagram Congestion Control Protocol (DCCP) [RFC4340] with its different congestion control types [RFC4341][RFC4342][RFC5622], or transport protocols specified by the IETF in the future. (UDP-encapsulated SCTP [RFC6951] and DCCP [RFC6773] can offer support for traversing firewalls and other middleboxes where the native protocols are not supported.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]、流控制传输协议（SCTP）[RFC4960]和SCTP部分可靠性扩展（SCTP-PR）[RFC3758]，或数据报拥塞控制协议（DCCP）[RFC4340]，其不同的拥塞控制类型[RFC4341][RFC4342][RFC5622]，或IETF未来指定的传输协议。（UDP封装的SCTP[RFC6951]和DCCP[RFC6773]可以在不支持本机协议的情况下提供穿越防火墙和其他中间盒的支持。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If used correctly, these more fully featured transport protocols are not as &#34;heavyweight&#34; as often claimed. For example, the TCP algorithms have been continuously improved over decades, and they have reached a level of efficiency and correctness that custom application-layer mechanisms will struggle to easily duplicate. In addition, many TCP implementations allow connections to be tuned by an application to its purposes. For example, TCP&#39;s &#34;Nagle&#34; algorithm [RFC1122] can be disabled, improving communication latency at the expense of more frequent -- but still congestion controlled -- packet transmissions. Another example is the TCP SYN cookie mechanism [RFC4987], which is available on many platforms. TCP with SYN cookies does not require a server to maintain per-connection state until the connection is established. TCP also requires the end that closes a connection to maintain the TIME-WAIT state that prevents delayed segments from one connection instance from interfering with a later one. Applications that are aware of and designed for this behavior can shift maintenance of the TIME-WAIT state to conserve resources by controlling which end closes a TCP connection [FABER]. Finally, TCP&#39;s built-in capacity-probing and awareness of the maximum transmission unit supported by the path (PMTU) results in efficient data transmission that quickly compensates for the initial connection setup delay, in the case of transfers that exchange more than a few segments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果正确使用，这些功能更全面的传输协议就不会像通常所说的那样“重量级”。例如，TCP算法经过几十年的不断改进，已经达到了定制应用层机制难以复制的效率和正确性水平。此外，许多TCP实现允许应用程序根据其目的调整连接。例如，TCP的“Nagle”算法[RFC1122]可以被禁用，从而以更频繁（但仍然是拥塞控制的）数据包传输为代价来改善通信延迟。另一个例子是TCP SYN cookie机制[RFC4987]，它在许多平台上都可用。在建立连接之前，带有SYN cookies的TCP不需要服务器维护每个连接的状态。TCP还需要关闭连接的端来保持TIME-WAIT状态，以防止来自一个连接实例的延迟段干扰后面的连接实例。知道并设计用于此行为的应用程序可以通过控制哪一端关闭TCP连接来改变等待时间状态的维护以节省资源[FABER]。最后，TCP内置的容量探测和对路径（PMTU）支持的最大传输单元的感知可以实现高效的数据传输，在交换超过几个段的传输的情况下，可以快速补偿初始连接设置延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Congestion Control Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 交通挤塞管制指引
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an application or protocol chooses not to use a congestion-controlled transport protocol, it SHOULD control the rate at which it sends UDP datagrams to a destination host, in order to fulfill the requirements of [RFC2914]. It is important to stress that an application SHOULD perform congestion control over all UDP traffic it sends to a destination, independently from how it generates this traffic. For example, an application that forks multiple worker processes or otherwise uses multiple sockets to generate UDP datagrams SHOULD perform congestion control over the aggregate traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果应用程序或协议选择不使用拥塞控制传输协议，则应控制向目标主机发送UDP数据报的速率，以满足[RFC2914]的要求。需要强调的是，应用程序应该对发送到目的地的所有UDP流量执行拥塞控制，这与它如何生成该流量无关。例如，分叉多个工作进程或使用多个套接字生成UDP数据报的应用程序应该对聚合流量执行拥塞控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several approaches to perform congestion control are discussed in the remainder of this section. This section describes generic topics with an intended emphasis on unicast and anycast [RFC1546] usage. Not all approaches discussed below are appropriate for all UDP-transmitting applications. Section 3.1.2 discusses congestion control options for applications that perform bulk transfers over UDP. Such applications can employ schemes that sample the path over several subsequent round-trips during which data is exchanged to determine a sending rate that the path at its current load can support. Other applications only exchange a few UDP datagrams with a destination. Section 3.1.3 discusses congestion control options for such &#34;low data-volume&#34; applications. Because they typically do not transmit enough data to iteratively sample the path to determine a safe sending rate, they need to employ different kinds of congestion control mechanisms. Section 3.1.11 discusses congestion control considerations when UDP is used as a tunneling protocol. Section 4 provides additional recommendations for broadcast and multicast usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节剩余部分将讨论几种执行拥塞控制的方法。本节介绍一般主题，旨在强调单播和选播[RFC1546]的使用。并非下面讨论的所有方法都适用于所有UDP传输应用程序。第3.1.2节讨论了通过UDP执行批量传输的应用程序的拥塞控制选项。此类应用程序可采用在随后的几个往返过程中对路径进行采样的方案，在此期间交换数据以确定路径在其当前负载下可支持的发送速率。其他应用程序仅与目标交换少量UDP数据报。第3.1.3节讨论了此类“低数据量”应用的拥塞控制选项。由于它们通常不传输足够的数据来迭代地对路径进行采样以确定安全发送速率，因此它们需要采用不同类型的拥塞控制机制。第3.1.11节讨论了UDP用作隧道协议时的拥塞控制注意事项。第4节提供了有关广播和多播使用的其他建议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that congestion control should not be viewed as an add-on to a finished application. Many of the mechanisms discussed in the guidelines below require application support to operate correctly. Application designers need to consider congestion control throughout the design of their application, similar to how they consider security aspects throughout the design process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
需要注意的是，不应将拥塞控制视为已完成应用程序的附加组件。以下指南中讨论的许多机制需要应用程序支持才能正确运行。应用设计者需要考虑在他们的应用程序设计中的拥塞控制，类似于他们如何在整个设计过程中考虑安全方面。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the past, the IETF has also investigated integrated congestion control mechanisms that act on the traffic aggregate between two hosts, i.e., a framework such as the Congestion Manager [RFC3124], where active sessions may share current congestion information in a way that is independent of the transport protocol. Such mechanisms have currently failed to see deployment, but would otherwise simplify the design of congestion control mechanisms for UDP sessions, so that they fulfill the requirements in [RFC2914].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在过去，IETF还研究了作用于两台主机之间的流量聚合的集成拥塞控制机制，即，诸如拥塞管理器[RFC3124]之类的框架，其中活动会话可以独立于传输协议的方式共享当前拥塞信息。这种机制目前无法看到部署，但可以简化UDP会话拥塞控制机制的设计，从而满足[RFC2914]中的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. Protocol Timer Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.1. 协议计时器指南
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Understanding the latency between communicating endpoints is usually a crucial part of effective congestion control implementations for protocols and applications. Latency estimation can be used in a number of protocol functions, such as calculating a congestion-controlled transmission rate, triggering retransmission, and detecting packet loss. Additional protocol functions, for example, determining an interval for probing a path, determining an interval between keep-alive messages, determining an interval for measuring the quality of experience, or determining if a remote endpoint has
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
了解通信端点之间的延迟通常是协议和应用程序的有效拥塞控制实现的关键部分。延迟估计可用于许多协议功能，例如计算拥塞控制传输速率、触发重传和检测分组丢失。附加协议功能，例如，确定用于探测路径的间隔、确定保持活动消息之间的间隔、确定用于测量体验质量的间隔或确定远程端点是否具有
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responded to a request to perform an action, typically operate over longer timescales than congestion control and therefore are not covered in this section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
响应执行操作的请求，通常比拥塞控制在更长的时间范围内运行，因此不在本节中介绍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general recommendation in this document is that applications SHOULD leverage existing congestion control techniques and the latency estimators specified therein (see next subsection). The following guidelines are provided for applications that need to design their own latency estimation mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档中的一般建议是，应用程序应利用现有的拥塞控制技术和其中指定的延迟估计器（见下一小节）。以下指南适用于需要设计自己的延迟估计机制的应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The guidelines are framed in terms of &#34;latency&#34; and not &#34;round-trip time&#34; because some situations require characterizing only the network-based latency (e.g., TCP-Friendly Rate Control (TFRC) [RFC5348]), while other cases necessitate inclusion of the time required by the remote endpoint to provide feedback (e.g., developing an understanding of when to retransmit a message).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些指南是根据“延迟”而不是“往返时间”制定的，因为有些情况只需要描述基于网络的延迟（例如TCP友好速率控制（TFRC）[RFC5348]），而其他情况则需要包含远程端点提供反馈所需的时间（例如，了解何时重新传输消息）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The latency between endpoints is generally a dynamic property. Therefore, estimates SHOULD represent some sort of averaging of multiple recent measurement samples to account for variance. Leveraging an Exponentially Weighted Moving Average (EWMA) has proven useful for this purpose (e.g., in TCP [RFC6298] and TFRC [RFC5348]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
端点之间的延迟通常是一个动态属性。因此，估计值应代表多个最近测量样本的某种平均值，以说明方差。事实证明，利用指数加权移动平均（EWMA）在这方面很有用（例如，在TCP[RFC6298]和TFRC[RFC5348]中）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Independent latency estimates SHOULD be maintained for each destination with which an endpoint communicates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应该为端点与之通信的每个目的地维护独立的延迟估计。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Latency samples MUST NOT be derived from ambiguous transactions. The canonical example is in a protocol that retransmits data, but subsequently cannot determine which copy is being acknowledged. This ambiguity makes correct computation of the latency problematic. See the discussion of Karn&#39;s algorithm in [RFC6298]. This requirement ensures a sender establishes a sound estimate of the latency without relying on misleading measurements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
延迟样本不得来自不明确的事务。典型的例子是在一个协议中，该协议重新传输数据，但随后无法确定要确认哪个副本。这种模糊性使延迟的正确计算成为问题。参见[RFC6298]中对Karn算法的讨论。这一要求确保发送方在不依赖误导性测量的情况下对延迟做出合理的估计。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a latency estimate is used to arm a timer that provides loss detection -- with or without retransmission -- expiry of the timer MUST be interpreted as an indication of congestion in the network, causing the sending rate to be adapted to a safe conservative rate (e.g., TCP collapses the congestion window to one segment [RFC5681]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当使用延迟估计来配置提供丢失检测的计时器（无论是否有重传）时，计时器的过期必须被解释为网络拥塞的指示，从而使发送速率适应安全的保守速率（例如，TCP将拥塞窗口压缩为一个段[RFC5681]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications require an initial latency estimate before the latency between endpoints can be empirically sampled. For instance, when arming a retransmission timer, an initial value is needed to protect the messages sent before the endpoints sample the latency. This initial latency estimate SHOULD generally be as conservative (large) as possible for the given application. For instance, in the absence of any knowledge about the latency of a path, TCP requires the initial Retransmission Timeout (RTO) to be set to no less than 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一些应用程序需要在对端点之间的延迟进行经验采样之前进行初始延迟估计。例如，在启用重传计时器时，需要一个初始值来保护在端点采样延迟之前发送的消息。对于给定的应用程序，此初始延迟估计值通常应尽可能保守（大）。例如，在不知道路径延迟的情况下，TCP要求将初始重传超时（RTO）设置为不小于1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
second [RFC6298]. UDP applications SHOULD similarly use an initial latency estimate of 1 second. Values shorter than 1 second can be problematic (see the data analysis in the appendix of [RFC6298]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二个[RFC6298]。UDP应用程序同样应该使用1秒的初始延迟估计值。小于1秒的值可能有问题（参见[RFC6298]附录中的数据分析）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. Bulk-Transfer Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.2. 批量传输应用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that perform bulk transmission of data to a peer over UDP, i.e., applications that exchange more than a few UDP datagrams per RTT, SHOULD implement TFRC [RFC5348], window-based TCP-like congestion control, or otherwise ensure that the application complies with the congestion control principles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过UDP向对等方执行数据大容量传输的应用程序，即每个RTT交换多个UDP数据报的应用程序，应实施TFRC[RFC5348]，基于窗口的TCP类拥塞控制，或以其他方式确保应用程序符合拥塞控制原则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFRC has been designed to provide both congestion control and fairness in a way that is compatible with the IETF&#39;s other transport protocols. If an application implements TFRC, it need not follow the remaining guidelines in Section 3.1.2, because TFRC already addresses them, but it SHOULD still follow the remaining guidelines in the subsequent subsections of Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TFRC旨在以与IETF的其他传输协议兼容的方式提供拥塞控制和公平性。如果应用程序实现了TFRC，则无需遵循第3.1.2节中的其余指南，因为TFRC已经解决了这些问题，但仍应遵循第3节后续小节中的其余指南。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bulk-transfer applications that choose not to implement TFRC or TCP-like windowing SHOULD implement a congestion control scheme that results in bandwidth (capacity) use that competes fairly with TCP within an order of magnitude.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择不实施TFRC或类似TCP的窗口化的大容量传输应用程序应实施拥塞控制方案，该方案将导致带宽（容量）使用在一个数量级内与TCP公平竞争。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2 of [RFC3551] suggests that applications SHOULD monitor the packet-loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an &#34;order-of-magnitude&#34; comparison in timescale and throughput. The recommendations for managing timers specified in Section 3.1.1 also apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551]第2节建议应用程序应监控数据包丢失率，以确保其在可接受的参数范围内。如果在相同的网络条件下，通过相同网络路径的TCP流在合理的时间尺度上达到不低于UDP流的平均吞吐量，则认为丢包是可接受的。无法精确指定与TCP的比较，但其目的是在时间尺度和吞吐量方面进行“数量级”比较。第3.1.1节中规定的计时器管理建议也适用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, some bulk-transfer applications may choose not to implement any congestion control mechanism and instead rely on transmitting across reserved path capacity (see Section 3.1.9). This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation over the wider Internet. When the UDP traffic of such applications leaks out into unprovisioned Internet paths, it can significantly degrade the performance of other traffic sharing the path and even result in congestion collapse. Applications that support an uncontrolled or unadaptive transmission behavior SHOULD NOT do so by default and SHOULD instead require users to explicitly enable this mode of operation, and they SHOULD verify that sufficient path capacity has been reserved for them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，一些批量传输应用程序可能选择不实施任何拥塞控制机制，而是依赖于通过保留路径容量进行传输（见第3.1.9节）。对于受限网络环境的子集来说，这可能是一个可接受的选择，但对于在更广泛的互联网上运行来说，这绝不是一个安全的做法。当这些应用程序的UDP流量泄漏到未设置的Internet路径时，它会显著降低共享该路径的其他流量的性能，甚至导致拥塞崩溃。默认情况下，支持非受控或非自适应传输行为的应用程序不应这样做，而是应要求用户明确启用此操作模式，并且应验证是否为其保留了足够的路径容量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. Low Data-Volume Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.3. 低数据量应用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When applications that at any time exchange only a few UDP datagrams with a destination implement TFRC or one of the other congestion control schemes in Section 3.1.2, the network sees little benefit, because those mechanisms perform congestion control in a way that is only effective for longer transmissions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当在任何时候仅与目的地交换少量UDP数据报的应用程序实施TFRC或第3.1.2节中的其他拥塞控制方案时，网络几乎看不到任何好处，因为这些机制以仅对较长传输有效的方式执行拥塞控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that at any time exchange only a few UDP datagrams with a destination SHOULD still control their transmission behavior by not sending on average more than one UDP datagram per RTT to a destination. Similar to the recommendation in [RFC1536], an application SHOULD maintain an estimate of the RTT for any destination with which it communicates using the methods specified in Section 3.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在任何时候仅与目的地交换少量UDP数据报的应用程序仍应通过平均每个RTT不向目的地发送多个UDP数据报来控制其传输行为。与[RFC1536]中的建议类似，应用程序应使用第3.1.1节中规定的方法维护其与之通信的任何目的地的RTT估计值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications cannot maintain a reliable RTT estimate for a destination. These applications do not need to or are unable to use protocol timers to measure the RTT (Section 3.1.1). Two cases can be identified:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些应用程序无法为目的地维护可靠的RTT估计。这些应用程序不需要或无法使用协议计时器来测量RTT（第3.1.1节）。可以确定两种情况：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The first case is that of applications that exchange too few UDP datagrams with a peer to establish a statistically accurate RTT estimate but that can monitor the reliability of transmission (Section 3.3). Such applications MAY use a predetermined transmission interval that is exponentially backed off when packets are deemed lost. TCP specifies an initial value of 1 second [RFC6298], which is also RECOMMENDED as an initial value for UDP applications. Some low data-volume applications, e.g., SIP [RFC3261] and General Internet Signaling Transport (GIST) [RFC5971] use an interval of 500 ms, and shorter values are likely problematic in many cases. As in the previous case, note that the initial timeout is not the maximum possible timeout, see Section 3.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 第一种情况是，应用程序与对等方交换的UDP数据报太少，无法建立统计上准确的RTT估计，但可以监控传输的可靠性（第3.3节）。这样的应用可以使用当分组被认为丢失时以指数方式退避的预定传输间隔。TCP指定1秒的初始值[RFC6298]，这也是UDP应用程序的建议初始值。一些低数据量应用程序，例如SIP[RFC3261]和通用Internet信令传输（GIST）[RFC5971]使用500 ms的间隔，在许多情况下，较短的值可能会出现问题。与前一种情况一样，请注意初始超时不是最大可能超时，请参见第3.1.1节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A second case of applications cannot maintain an RTT estimate for a destination, because the destination does not send return traffic. Such applications SHOULD NOT send more than one UDP datagram every 3 seconds and SHOULD use an even less aggressive rate when possible. Shorter values are likely problematic in many cases. Note that the sending rate in this case must be more conservative than in the previous cases, because the lack of return traffic prevents the detection of packet loss, i.e., congestion, and the application therefore cannot perform exponential back off to reduce load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 第二种情况是，应用程序无法维护目的地的RTT估计，因为目的地不发送返回流量。此类应用程序不应每3秒发送一个以上的UDP数据报，并应尽可能使用更少的攻击速率。在许多情况下，较短的值可能有问题。请注意，这种情况下的发送速率必须比以前的情况更加保守，因为缺少返回流量会阻止对分组丢失（即拥塞）的检测，因此应用程序无法执行指数退避以减少负载。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. Applications Supporting Bidirectional Communications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.4. 支持双向通信的应用程序
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that communicate bidirectionally SHOULD employ congestion control for both directions of the communication. For example, for a client-server, request-response-style application, clients SHOULD congestion-control their request transmission to a server, and the server SHOULD congestion-control its responses to the clients. Congestion in the forward and reverse directions is uncorrelated, and an application SHOULD either independently detect and respond to congestion along both directions or limit new and retransmitted requests based on acknowledged responses across the entire round-trip path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
双向通信的应用程序应该对通信的两个方向采用拥塞控制。例如，对于客户机-服务器、请求-响应类型的应用程序，客户机应该对其到服务器的请求传输进行拥塞控制，而服务器应该对其到客户机的响应进行拥塞控制。正向和反向的拥塞是不相关的，应用程序应该独立地检测并响应两个方向的拥塞，或者基于整个往返路径上已确认的响应来限制新的和重新传输的请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. Implications of RTT and Loss Measurements on Congestion Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.5. RTT和损耗测量对拥塞控制的影响
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transports such as TCP, SCTP, and DCCP provide timely detection of congestion that results in an immediate reduction of their maximum sending rate when congestion is experienced. This reaction is typically completed 1-2 RTTs after loss/congestion is encountered. Applications using UDP SHOULD implement a congestion control scheme that provides a prompt reaction to signals indicating congestion (e.g., by reducing the rate within the next RTT following a congestion signal).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP、SCTP和DCCP等传输提供了对拥塞的及时检测，从而在遇到拥塞时立即降低其最大发送速率。这种反应通常在遇到丢失/拥塞后1-2次RTT完成。使用UDP的应用程序应实施拥塞控制方案，该方案可对指示拥塞的信号做出快速反应（例如，通过在拥塞信号后的下一个RTT内降低速率）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The operation of a UDP congestion control algorithm can be very different from the way TCP operates. This includes congestion controls that respond on timescales that fit applications that cannot usefully work within the &#34;change rate every RTT&#34; model of TCP. Applications that experience a low or varying RTT are particularly vulnerable to sampling errors (e.g., due to measurement noise or timer accuracy). This suggests the need to average loss/congestion and RTT measurements over a longer interval; however, this also can contribute additional delay in detecting congestion. Some applications may not react by reducing their sending rate immediately for various reasons, including the following: RTT and loss measurements are only made periodically (e.g., using RTCP), additional time is required to filter information, or the application is only able to change its sending rate at predetermined interval (e.g., some video codecs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP拥塞控制算法的操作可能与TCP的操作方式非常不同。这包括拥塞控制，这些控制响应的时间尺度适合那些无法在TCP的“每个RTT的变化率”模型中有效工作的应用程序。RTT低或变化的应用程序特别容易受到采样误差的影响（例如，由于测量噪声或计时器精度）。这表明需要在更长的时间间隔内平均损耗/拥塞和RTT测量；然而，这也会增加检测拥塞的延迟。由于各种原因，一些应用程序可能不会立即降低其发送速率，包括以下原因：RTT和损耗测量仅定期进行（例如，使用RTCP），过滤信息需要额外的时间，或者应用程序只能以预定的间隔更改其发送速率（例如，一些视频编解码器）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When designing a congestion control algorithm, the designer therefore needs to consider the total time taken to reduce the load following a lack of feedback or a congestion event. An application where the most recent RTT measurement is smaller than the actual RTT or the measured loss rate is smaller than the current rate, can result in over estimating the available capacity. Such over-estimation can
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在设计拥塞控制算法时，设计者需要考虑在反馈或拥塞事件之后减少总负载的时间。如果最近的RTT测量值小于实际RTT或测量的损耗率小于当前速率，则可能导致高估可用容量。这种高估可能会导致
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
result in a sending rate that creates congestion to the application or other flows sharing the path capacity, and can contribute to congestion collapse -- both of these need to be avoided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
导致发送速率对共享路径容量的应用程序或其他流造成拥塞，并可能导致拥塞崩溃——这两种情况都需要避免。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A congestion control designed for UDP SHOULD respond as quickly as possible when it experiences congestion, and it SHOULD take into account both the loss rate and the response time when choosing a new rate. The implemented congestion control scheme SHOULD result in bandwidth (capacity) use that is comparable to that of TCP within an order of magnitude, so that it does not starve other flows sharing a common bottleneck.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为UDP设计的拥塞控制在遇到拥塞时应尽快响应，并且在选择新速率时应同时考虑丢失率和响应时间。所实施的拥塞控制方案应在一个数量级内实现与TCP相当的带宽（容量）使用，从而不会使共享一个共同瓶颈的其他流陷入饥饿。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. Burst Mitigation and Pacing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.6. 突发缓解和起搏
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications SHOULD provide mechanisms to regulate the bursts of transmission that the application may send to the network. Many TCP and SCTP implementations provide mechanisms that prevent a sender from generating long bursts at line-rate, since these are known to induce early loss to applications sharing a common network bottleneck. The use of pacing with TCP [ALLMAN] has also been shown to improve the coexistence of TCP flows with other flows. The need to avoid excessive transmission bursts is also noted in specifications for applications (e.g., [RFC7143]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP应用程序应提供调节应用程序可能发送到网络的突发传输的机制。许多TCP和SCTP实现提供了防止发送方以线路速率生成长突发的机制，因为已知这些机制会导致共享公共网络瓶颈的应用程序过早丢失。与TCP[ALLMAN]一起使用起搏也可以改善TCP流与其他流的共存。在应用规范（例如[RFC7143]）中也指出了避免过度传输突发的需要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Even low data-volume UDP flows may benefit from packet pacing, e.g., an application that sends three copies of a packet to improve robustness to loss is RECOMMENDED to pace out those three packets over several RTTs, to reduce the probability that all three packets will be lost due to the same congestion event (or other event, such as burst corruption).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
即使是低数据量UDP流也可能受益于数据包调整，例如，建议发送数据包的三个副本以提高对丢失的鲁棒性的应用程序在几个RTT上调整这三个数据包的速度，以降低由于相同拥塞事件而丢失所有三个数据包的概率（或其他事件，如突发性损坏）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. Explicit Congestion Notification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.7. 显式拥塞通知
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet applications can use Explicit Congestion Notification (ECN) [RFC3168] to gain benefits for the services they support [RFC8087].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
互联网应用程序可以使用显式拥塞通知（ECN）[RFC3168]为其支持的服务获取好处[RFC8087]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet transports, such as TCP, provide a set of mechanisms that are needed to utilize ECN. ECN operates by setting an ECN-capable codepoint (ECT(0) or ECT(1)) in the IP header of packets that are sent. This indicates to ECN-capable network devices (routers and other devices) that they may mark (set the congestion experienced, Congestion Experience (CE) codepoint) rather than drop the IP packet as a signal of incipient congestion.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Internet传输（如TCP）提供了一组利用ECN所需的机制。ECN通过在发送的数据包的IP报头中设置支持ECN的代码点（ECT（0）或ECT（1））来运行。这向支持ECN的网络设备（路由器和其他设备）表明，它们可以标记（设置拥塞体验、拥塞体验（CE）码点），而不是将IP数据包丢弃为初始拥塞的信号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications can also benefit from enabling ECN, providing that the API supports ECN and that they implement the required protocol mechanisms to support ECN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP应用程序还可以从启用ECN中获益，前提是API支持ECN，并且它们实现了支持ECN所需的协议机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set of mechanisms required for an application to use ECN over UDP are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序通过UDP使用ECN所需的一组机制包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender MUST provide a method to determine (e.g., negotiate) that the corresponding application is able to provide ECN feedback using a compatible ECN method.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 发送方必须提供一种方法来确定（例如，协商）相应的应用程序能够使用兼容的ECN方法提供ECN反馈。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A receiver that enables the use of ECN for a UDP port MUST check the ECN field at the receiver for each UDP datagram that it receives on this port.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 为UDP端口启用ECN的接收器必须检查接收器处的ECN字段，以查看其在此端口上接收的每个UDP数据报。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The receiving application needs to provide feedback of congestion information to the sending application. This MUST report the presence of datagrams received with a CE-mark by providing a mechanism to feed this congestion information back to the sending application. The feedback MAY also report the presence of ECT(1) and ECT(0)/Not-ECT packets [RFC7560]. ([RFC3168] and [RFC7560] specify methods for TCP.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接收应用程序需要向发送应用程序提供拥塞信息的反馈。这必须通过提供一种机制将拥塞信息反馈给发送应用程序，来报告接收到的带有CE标记的数据报的存在。反馈还可能报告ECT（1）和ECT（0）/非ECT数据包的存在[RFC7560]。（[RFC3168]和[RFC7560]指定TCP的方法。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An application sending ECN-capable datagrams MUST provide an appropriate congestion reaction when it receives feedback indicating that congestion has been experienced. This ought to result in reduction of the sending rate by the UDP congestion control method (see Section 3.1) that is not less than the reaction of TCP under equivalent conditions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 发送支持ECN的数据报的应用程序在收到指示已经历拥塞的反馈时，必须提供适当的拥塞反应。这将导致UDP拥塞控制方法（见第3.1节）降低发送速率，该方法不低于TCP在同等条件下的反应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender SHOULD detect network paths that do not support the ECN field correctly. When detected, they need to either conservatively react to congestion or even fall back to not using ECN [RFC8087]. This method needs to be robust to changes within the network path that may occur over the lifetime of a session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 发送方应检测不正确支持ECN字段的网络路径。当检测到时，它们需要对拥塞做出保守的反应，甚至退回到不使用ECN的状态[RFC8087]。此方法需要对网络路径内可能在会话生命周期内发生的更改具有鲁棒性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A sender is encouraged to provide a mechanism to detect and react appropriately to misbehaving receivers that fail to report CE-marked packets [RFC8087].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 鼓励发送方提供一种机制，以检测未报告CE标记数据包的行为不端的接收方，并对其作出适当反应[RFC8087]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679] provides guidance and an example of this support, by describing a method to allow ECN to be used for UDP-based applications using the Real-Time Protocol (RTP). Applications that cannot provide this set of mechanisms, but wish to gain the benefits of using ECN, are encouraged to use a transport protocol that already supports ECN (such as TCP).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679]通过描述允许使用实时协议（RTP）将ECN用于基于UDP的应用程序的方法，提供了此支持的指南和示例。如果应用程序不能提供这组机制，但希望获得使用ECN的好处，则鼓励使用已经支持ECN的传输协议（如TCP）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. Differentiated Services Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.8. 区分服务模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application using UDP can use the differentiated services (DiffServ) Quality of Service (QoS) framework. To enable differentiated services processing, a UDP sender sets the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用UDP的应用程序可以使用区分服务（DiffServ）服务质量（QoS）框架。要启用区分服务处理，UDP发送方将
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Differentiated Services Code Point (DSCP) field [RFC2475] in packets sent to the network. Normally, a UDP source/destination port pair will set a single DSCP value for all packets belonging to a flow, but multiple DSCPs can be used as described later in this section. A DSCP may be chosen from a small set of fixed values (the class selector code points), or from a set of recommended values defined in the Per Hop Behavior (PHB) specifications, or from values that have purely local meanings to a specific network that supports DiffServ. In general, packets may be forwarded across multiple networks between source and destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送到网络的数据包中的差异化服务代码点（DSCP）字段[RFC2475]。通常，UDP源/目标端口对将为属于一个流的所有数据包设置一个DSCP值，但如本节后面所述，可以使用多个DSCP。DSCP可以从一小组固定值（类选择器代码点）中选择，或者从每跳行为（PHB）规范中定义的一组推荐值中选择，或者从对支持区分服务的特定网络具有纯本地含义的值中选择。通常，包可以在源和目的地之间跨多个网络转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In setting a non-default DSCP value, an application must be aware that DSCP markings may be changed or removed between the traffic source and destination. This has implications on the design of applications that use DSCPs. Specifically, applications SHOULD be designed not to rely on implementation of a specific network treatment; they need instead to implement congestion control methods to determine if their current sending rate is inducing congestion in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在设置非默认DSCP值时，应用程序必须知道DSCP标记可能会在流量源和目的地之间更改或删除。这对使用DSCP的应用程序的设计有影响。具体而言，应用程序的设计不应依赖于特定网络处理的实现；相反，他们需要实施拥塞控制方法，以确定其当前发送速率是否会导致网络拥塞。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657] describes the implications of using DSCPs and provides recommendations on using multiple DSCPs within a single network five-tuple (source and destination addresses, source and destination ports, and the transport protocol used, in this case, UDP or UDP-Lite), and particularly the expected impact on transport protocol interactions, with congestion control or reliability functionality (e.g., retransmission, reordering). Use of multiple DSCPs can result in reordering by increasing the set of network forwarding resources used by a sender. It can also increase exposure to resource depletion or failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657]描述了使用DSCP的含义，并提供了在单个网络五元组中使用多个DSCP的建议（源地址和目标地址、源端口和目标端口，以及使用的传输协议，在本例中为UDP或UDP Lite），尤其是对传输协议交互的预期影响，具有拥塞控制或可靠性功能（例如，重传、重新排序）。使用多个DSCP会增加发送方使用的网络转发资源集，从而导致重新排序。它还可能增加资源耗竭或失效的风险。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9. QoS, Pre-Provisioned, or Reserved Capacity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.9. QoS、预配置或保留容量
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF usually specifies protocols for use within the Best Effort General Internet. Sometimes it is relevant to specify protocols with a different applicability. An application using UDP can use the integrated services QoS framework. This framework is usually made available within controlled environments (e.g., within a single administrative domain or bilaterally agreed connection between domains). Applications intended for the Internet SHOULD NOT assume that QoS mechanisms are supported by the networks they use, and therefore need to provide congestion control, error recovery, etc., in case the actual network path does not provide provisioned service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF通常指定在尽力而为的通用互联网中使用的协议。有时，指定具有不同适用性的协议是相关的。使用UDP的应用程序可以使用集成服务QoS框架。此框架通常在受控环境中可用（例如，在单个管理域内或域之间双边商定的连接）。用于Internet的应用程序不应假定QoS机制由其使用的网络支持，因此需要提供拥塞控制、错误恢复等，以防实际网络路径不提供已提供的服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some UDP applications are only expected to be deployed over network paths that use pre-provisioned capacity or capacity reserved using dynamic provisioning, e.g., through the Resource Reservation Protocol (RSVP). Multicast applications are also used with pre-provisioned
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些UDP应用程序预计只能部署在使用预调配容量或使用动态调配（例如通过资源预留协议（RSVP））保留容量的网络路径上。多播应用程序也可与预配置一起使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
capacity (e.g., IPTV deployments within access networks). These applications MAY choose not to implement any congestion control mechanism and instead rely on transmitting only on paths where the capacity is provisioned and reserved for this use. This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation over the wider Internet. Applications that choose this option SHOULD carefully and in detail describe the provisioning and management procedures that result in the desired containment.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
容量（例如，接入网络内的IPTV部署）。这些应用程序可以选择不实施任何拥塞控制机制，而是仅依赖于在为该用途提供和保留容量的路径上传输。对于受限网络环境的子集来说，这可能是一个可接受的选择，但对于在更广泛的互联网上运行来说，这绝不是一个安全的做法。选择此选项的应用程序应仔细详细地描述实现所需控制的供应和管理过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that support an uncontrolled or unadaptive transmission behavior SHOULD NOT do so by default and SHOULD instead require users to explicitly enable this mode of operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
默认情况下，支持非受控或非自适应传输行为的应用程序不应这样做，而应要求用户明确启用此操作模式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications designed for use within a controlled environment (see Section 3.6) may be able to exploit network management functions to detect whether they are causing congestion, and react accordingly. If the traffic of such applications leaks out into unprovisioned Internet paths, it can significantly degrade the performance of other traffic sharing the path and even result in congestion collapse. Protocols designed for such networks SHOULD provide mechanisms at the network edge to prevent leakage of traffic into unprovisioned Internet paths (e.g., [RFC7510]). To protect other applications sharing the same path, applications SHOULD also deploy an appropriate circuit breaker, as described in Section 3.1.10.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为在受控环境中使用而设计的应用程序（见第3.6节）可以利用网络管理功能来检测它们是否造成拥塞，并做出相应的反应。如果此类应用程序的流量泄漏到未设置的Internet路径，则会显著降低共享该路径的其他流量的性能，甚至导致拥塞崩溃。为此类网络设计的协议应在网络边缘提供机制，以防止流量泄漏到未设置的互联网路径（例如，[RFC7510]）。为了保护共享相同路径的其他应用程序，应用程序还应部署适当的断路器，如第3.1.10节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An IETF specification targeting a controlled environment is expected to provide an applicability statement that restricts the application to the controlled environment (see Section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
针对受控环境的IETF规范应提供适用性声明，将应用限制在受控环境中（见第3.6节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.10. Circuit Breaker Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.10. 断路器机构
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A transport circuit breaker is an automatic mechanism that is used to estimate the congestion caused by a flow, and to terminate (or significantly reduce the rate of) the flow when excessive congestion is detected [RFC8084]. This is a safety measure to prevent congestion collapse (starvation of resources available to other flows), essential for an Internet that is heterogeneous and for traffic that is hard to predict in advance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
传输断路器是一种自动机制，用于估计流量造成的拥塞，并在检测到过度拥塞时终止（或显著降低）流量[RFC8084]。这是防止拥塞崩溃（其他流可用资源匮乏）的安全措施，对于异构的互联网和难以提前预测的流量至关重要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A circuit breaker is intended as a protection mechanism of last resort. Under normal circumstances, a circuit breaker should not be triggered; it is designed to protect things when there is severe overload. The goal is usually to limit the maximum transmission rate that reflects the available capacity of a network path. Circuit breakers can operate on individual UDP flows or traffic aggregates, e.g., traffic sent using a network tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断路器是作为最后手段的保护机制。在正常情况下，不应触发断路器；设计用于在严重过载时保护物品。目标通常是限制反映网络路径可用容量的最大传输速率。断路器可以对单个UDP流或流量聚合进行操作，例如，使用网络隧道发送的流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084] provides guidance and examples on the use of circuit breakers. The use of a circuit breaker in RTP is specified in [RFC8083].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084]提供了断路器使用指南和示例。[RFC8083]中规定了RTP中断路器的使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications used in the general Internet SHOULD implement a transport circuit breaker if they do not implement congestion control or operate a low data-volume service (see Section 3.6). All applications MAY implement a transport circuit breaker [RFC8084] and are encouraged to consider implementing at least a slow-acting transport circuit breaker to provide a protection of last resort for their network traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果通用互联网中使用的应用程序未实施拥塞控制或运行低数据量服务，则应实施传输断路器（见第3.6节）。所有的应用都可以实现传输断路器[RCF8084]，并鼓励考虑至少实施一个慢动作的传输断路器，以提供对其网络流量的最后保护。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.11. UDP Tunnels
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1.11. UDP隧道
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One increasingly popular use of UDP is as a tunneling protocol [INT-TUNNELS], where a tunnel endpoint encapsulates the packets of another protocol inside UDP datagrams and transmits them to another tunnel endpoint, which decapsulates the UDP datagrams and forwards the original packets contained in the payload. One example of such a protocol is Teredo [RFC4380]. Tunnels establish virtual links that appear to directly connect locations that are distant in the physical Internet topology and can be used to create virtual (private) networks. Using UDP as a tunneling protocol is attractive when the payload protocol is not supported by middleboxes that may exist along the path, because many middleboxes support transmission using UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP的一种日益流行的用途是作为隧道协议[INT-TUNNELS]，其中隧道端点将另一协议的数据包封装在UDP数据报内，并将其传输到另一隧道端点，该隧道端点将UDP数据报解封并转发有效负载中包含的原始数据包。这种协议的一个例子是Teredo[RFC4380]。隧道建立虚拟链接，直接连接物理Internet拓扑中较远的位置，并可用于创建虚拟（专用）网络。当路径上可能存在的中间盒不支持有效负载协议时，使用UDP作为隧道协议很有吸引力，因为许多中间盒支持使用UDP传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Well-implemented tunnels are generally invisible to the endpoints that happen to transmit over a path that includes tunneled links. On the other hand, to the routers along the path of a UDP tunnel, i.e., the routers between the two tunnel endpoints, the traffic that a UDP tunnel generates is a regular UDP flow, and the encapsulator and decapsulator appear as regular UDP-sending and UDP-receiving applications. Because other flows can share the path with one or more UDP tunnels, congestion control needs to be considered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现良好的隧道通常对恰好通过包含隧道链接的路径传输的端点不可见。另一方面，对于沿UDP隧道路径的路由器，即两个隧道端点之间的路由器，UDP隧道生成的流量是常规UDP流，封装器和解封装器显示为常规UDP发送和UDP接收应用程序。因为其他流可以与一个或多个UDP隧道共享路径，所以需要考虑拥塞控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two factors determine whether a UDP tunnel needs to employ specific congestion control mechanisms: first, whether the payload traffic is IP-based; and second, whether the tunneling scheme generates UDP traffic at a volume that corresponds to the volume of payload traffic carried within the tunnel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有两个因素决定UDP隧道是否需要采用特定的拥塞控制机制：第一，有效负载流量是否基于IP；以及第二，隧道方案是否在与隧道内承载的有效负载通信量相对应的量处生成UDP通信量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP-based unicast traffic is generally assumed to be congestion controlled, i.e., it is assumed that the transport protocols generating IP-based unicast traffic at the sender already employ mechanisms that are sufficient to address congestion on the path. Consequently, a tunnel carrying IP-based unicast traffic should
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基于IP的单播业务通常被假定为拥塞控制的，即，假定在发送方处生成基于IP的单播业务的传输协议已经采用足以解决路径上的拥塞的机制。因此，承载基于IP的单播业务的隧道应该
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
already interact appropriately with other traffic sharing the path, and specific congestion control mechanisms for the tunnel are not necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已经与共享路径的其他交通进行了适当的交互，隧道的特定拥塞控制机制是不必要的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, if the IP traffic in the tunnel is known not to be congestion controlled, additional measures are RECOMMENDED to limit the impact of the tunneled traffic on other traffic sharing the path. For the specific case of a tunnel that carries IP multicast traffic, see Section 4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
但是，如果已知隧道中的IP流量未受到拥塞控制，则建议采取其他措施限制隧道流量对共享路径的其他流量的影响。有关承载IP多播流量的隧道的具体情况，请参见第4.1节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following guidelines define these possible cases in more detail:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下指南更详细地定义了这些可能的情况：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is IP based and congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 隧道在与有效负载通信量相对应的卷上生成UDP通信量，并且有效负载通信量基于IP且受拥塞控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This is arguably the most common case for Internet tunnels. In this case, the UDP tunnel SHOULD NOT employ its own congestion control mechanism, because congestion losses of tunneled traffic will already trigger an appropriate congestion response at the original senders of the tunneled traffic. A circuit breaker mechanism may provide benefit by controlling the envelope of the aggregated traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
这可以说是互联网隧道最常见的情况。在这种情况下，UDP隧道不应采用其自身的拥塞控制机制，因为隧道流量的拥塞损失将已经在隧道流量的原始发送方触发适当的拥塞响应。断路器机制可通过控制聚合流量的包络来提供益处。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Note that this guideline is built on the assumption that most IP-based communication is congestion controlled. If a UDP tunnel is used for IP-based traffic that is known to not be congestion controlled, the next set of guidelines applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
请注意，本指南建立在大多数基于IP的通信都是拥塞控制的假设之上。如果UDP隧道用于已知不受拥塞控制的基于IP的流量，则下一组指南适用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is not known to be IP based, or is known to be IP based but not congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 隧道在与有效负载通信量相对应的卷上生成UDP通信量，有效负载通信量不知道是基于IP的，或者已知是基于IP的，但不受拥塞控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
This can be the case, for example, when some link-layer protocols are encapsulated within UDP (but not all link-layer protocols; some are congestion controlled). Because it is not known that congestion losses of tunneled non-IP traffic will trigger an appropriate congestion response at the senders, the UDP tunnel SHOULD employ an appropriate congestion control mechanism or circuit breaker mechanism designed for the traffic it carries. Because tunnels are usually bulk-transfer applications as far as the intermediate routers are concerned, the guidelines in Section 3.1.2 apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
例如，当某些链路层协议封装在UDP中时（但不是所有链路层协议；有些是拥塞控制的），可能会出现这种情况。由于不知道隧道传输的非IP流量的拥塞丢失会在发送方触发适当的拥塞响应，UDP隧道应采用为其承载的流量设计的适当拥塞控制机制或断路器机制。由于就中间路由器而言，隧道通常是批量传输应用，因此第3.1.2节中的指南适用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. A tunnel generates UDP traffic at a volume that does not correspond to the volume of payload traffic, independent of whether the payload traffic is IP based or congestion controlled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 隧道在与有效负载流量量不对应的卷上生成UDP流量，这与有效负载流量是基于IP还是拥塞控制无关。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Examples of this class include UDP tunnels that send at a constant rate, increase their transmission rates under loss, for example, due to increasing redundancy when Forward Error Correction is used, or are otherwise unconstrained in their transmission behavior. These specialized uses of UDP for tunneling go beyond the scope of the general guidelines given in this document. The implementer of such specialized tunnels SHOULD carefully consider congestion control in the design of their tunneling mechanism and SHOULD consider use of a circuit breaker mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
此类示例包括UDP隧道，它们以恒定速率发送，在丢失情况下增加传输速率，例如，由于使用前向纠错时增加冗余，或者在传输行为中不受限制。UDP在隧道中的这些特殊用途超出了本文档中给出的一般指南的范围。这种专用隧道的实施者在设计隧道机制时应仔细考虑拥塞控制，并应考虑使用断路器机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type of encapsulated payload might be identified by a UDP port; identified by an Ethernet Type or IP protocol number. A tunnel SHOULD provide mechanisms to restrict the types of flows that may be carried by the tunnel. For instance, a UDP tunnel designed to carry IP needs to filter out non-IP traffic at the ingress. This is particularly important when a generic tunnel encapsulation is used (e.g., one that encapsulates using an EtherType value). Such tunnels SHOULD provide a mechanism to restrict the types of traffic that are allowed to be encapsulated for a given deployment (see [INT-TUNNELS]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
封装负载的类型可以通过UDP端口识别；由以太网类型或IP协议号标识。隧道应提供限制隧道可能携带的流量类型的机制。例如，设计用于承载IP的UDP隧道需要在入口过滤掉非IP流量。当使用通用隧道封装（例如，使用EtherType值进行封装）时，这一点尤为重要。此类隧道应提供一种机制，以限制允许为给定部署封装的流量类型（请参见[INT-tunnels]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Designing a tunneling mechanism requires significantly more expertise than needed for many other UDP applications, because tunnels are usually intended to be transparent to the endpoints transmitting over them, so they need to correctly emulate the behavior of an IP link [INT-TUNNELS], for example:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与许多其他UDP应用程序相比，设计隧道机制需要更多的专业知识，因为隧道通常对通过隧道传输的端点透明，因此它们需要正确模拟IP链路[INT-tunnels]的行为，例如：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Requirements for tunnels that carry or encapsulate using ECN code points [RFC6040].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用ECN代码点进行运输或封装的隧道要求[RFC6040]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Usage of the IP DSCP field by tunnel endpoints [RFC2983].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 隧道端点对IP DSCP字段的使用[RFC2983]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Encapsulation considerations in the design of tunnels [ENCAP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 隧道设计中的封装考虑[ENCAP]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Usage of ICMP messages [INT-TUNNELS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o ICMP消息的使用[INT-TUNNELS]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Handling of fragmentation and packet size for tunnels [INT-TUNNELS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 隧道碎片和数据包大小的处理[INT-tunnels]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Source port usage for tunnels designed to support equal cost multipath (ECMP) routing (see Section 5.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 设计用于支持等成本多路径（ECMP）路由的隧道的源端口使用情况（见第5.1.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Guidance on the need to protect headers [INT-TUNNELS] and the use of checksums for IPv6 tunnels (see Section 3.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 关于需要保护头[INT-TUNNELS]和IPv6隧道校验和使用的指南（见第3.4.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Support for operations and maintenance [INT-TUNNELS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 支持运营和维护[INT-TUNNES]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
At the same time, the tunneled traffic is application traffic like any other from the perspective of the networks the tunnel transmits over. This document only touches upon the congestion control considerations for implementing UDP tunnels; a discussion of other required tunneling behavior is out of scope.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同时，从隧道传输的网络的角度来看，隧道传输的流量与其他任何流量一样，都是应用程序流量。本文件仅涉及实施UDP隧道的拥塞控制注意事项；对其他所需隧道行为的讨论超出范围。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Message Size Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 邮件大小准则
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP fragmentation lowers the efficiency and reliability of Internet communication. The loss of a single fragment results in the loss of an entire fragmented packet, because even if all other fragments are received correctly, the original packet cannot be reassembled and delivered. This fundamental issue with fragmentation exists for both IPv4 and IPv6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IP碎片化降低了Internet通信的效率和可靠性。单个片段的丢失会导致整个片段数据包的丢失，因为即使正确接收到所有其他片段，原始数据包也无法重新组装和交付。IPv4和IPv6都存在碎片化的基本问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, some network address translators (NATs) and firewalls drop IP fragments. The network address translation performed by a NAT only operates on complete IP packets, and some firewall policies also require inspection of complete IP packets. Even with these being the case, some NATs and firewalls simply do not implement the necessary reassembly functionality; instead, they choose to drop all fragments. Finally, [RFC4963] documents other issues specific to IPv4 fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，一些网络地址转换器（NAT）和防火墙会丢弃IP片段。NAT执行的网络地址转换仅在完整的IP数据包上运行，一些防火墙策略还需要检查完整的IP数据包。即使是这样，一些NAT和防火墙也没有实现必要的重组功能；相反，他们选择删除所有片段。最后，[RFC4963]记录了特定于IPv4碎片的其他问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Due to these issues, an application SHOULD NOT send UDP datagrams that result in IP packets that exceed the Maximum Transmission Unit (MTU) along the path to the destination. Consequently, an application SHOULD either use the path MTU information provided by the IP layer or implement Path MTU Discovery (PMTUD) itself [RFC1191] [RFC1981] [RFC4821] to determine whether the path to a destination will support its desired message size without fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于这些问题，应用程序不应发送UDP数据报，因为这些数据报会导致IP数据包在到达目的地的路径上超过最大传输单位（MTU）。因此，应用程序应该使用IP层提供的路径MTU信息，或者实现路径MTU发现（PMTUD）本身[RFC1191][RFC1981][RFC4821]，以确定到达目的地的路径是否支持其所需的消息大小而不出现碎片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, the ICMP messages that enable path MTU discovery are being increasingly filtered by middleboxes (including Firewalls) [RFC4890]. When the path includes a tunnel, some devices acting as a tunnel ingress discard ICMP messages that originate from network devices over which the tunnel passes, preventing these from reaching the UDP endpoint.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，支持路径MTU发现的ICMP消息正越来越多地通过中间盒（包括防火墙）进行过滤[RFC4890]。当路径包括隧道时，某些充当隧道入口的设备会丢弃源自隧道通过的网络设备的ICMP消息，从而阻止这些消息到达UDP端点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Packetization Layer Path MTU Discovery (PLPMTUD) [RFC4821] does not rely upon network support for ICMP messages and is therefore considered more robust than standard PMTUD. It is not susceptible to &#34;black holing&#34; of ICMP messages. To operate, PLPMTUD requires changes to the way the transport is used: both to transmit probe packets and to account for the loss or success of these probes. This not only updates the PMTU algorithm, it also impacts loss recovery, congestion control, etc. These updated mechanisms can be implemented
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
打包层路径MTU发现（PLPMTUD）[RFC4821]不依赖于ICMP消息的网络支持，因此被认为比标准PMTUD更健壮。它不易受到ICMP消息“黑洞”的影响。为了操作，PLPMTUD需要更改传输的使用方式：传输探测数据包和解释这些探测的丢失或成功。这不仅更新了PMTU算法，还影响了丢失恢复、拥塞控制等。可以实现这些更新机制
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
within a connection-oriented transport (e.g., TCP, SCTP, DCCP), but they are not a part of UDP; this type of feedback is not typically present for unidirectional applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在面向连接的传输中（例如TCP、SCTP、DCCP），但它们不是UDP的一部分；这种类型的反馈通常不适用于单向应用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, PLPMTUD places additional design requirements on a UDP application that wishes to use this method. This is especially true for UDP tunnels, because the overhead of sending probe packets needs to be accounted for and may require adding a congestion control mechanism to the tunnel (see Section 3.1.11) as well as complicating the data path at a tunnel decapsulator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，PLPMTUD对希望使用此方法的UDP应用程序提出了额外的设计要求。这对于UDP隧道尤其如此，因为需要考虑发送探测数据包的开销，并且可能需要向隧道添加拥塞控制机制（参见第3.1.11节），以及使隧道解封装器处的数据路径复杂化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that do not follow the recommendation to do PMTU/PLPMTUD discovery SHOULD still avoid sending UDP datagrams that would result in IP packets that exceed the path MTU. Because the actual path MTU is unknown, such applications SHOULD fall back to sending messages that are shorter than the default effective MTU for sending (EMTU_S in [RFC1122]). For IPv4, EMTU_S is the smaller of 576 bytes and the first-hop MTU [RFC1122]. For IPv6, EMTU_S is 1280 bytes [RFC2460]. The effective PMTU for a directly connected destination (with no routers on the path) is the configured interface MTU, which could be less than the maximum link payload size. Transmission of minimum-sized UDP datagrams is inefficient over paths that support a larger PMTU, which is a second reason to implement PMTU discovery.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不遵循建议进行PMTU/PLPMTUD发现的应用程序仍应避免发送可能导致IP数据包超过路径MTU的UDP数据报。由于实际路径MTU未知，此类应用程序应返回发送短于默认有效发送MTU的消息（参见[RFC1122]）。对于IPv4，EMTU_S是576字节和第一跳MTU[RFC1122]中较小的一个。对于IPv6，EMTU_S是1280字节[RFC2460]。直接连接的目的地（路径上没有路由器）的有效PMTU是配置的接口MTU，它可能小于最大链路有效负载大小。在支持较大PMTU的路径上传输最小大小的UDP数据报效率低下，这是实现PMTU发现的第二个原因。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine an appropriate UDP payload size, applications MUST subtract the size of the IP header (which includes any IPv4 optional headers or IPv6 extension headers) as well as the length of the UDP header (8 bytes) from the PMTU size. This size, known as the Maximum Segment Size (MSS), can be obtained from the TCP/IP stack [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要确定适当的UDP有效负载大小，应用程序必须从PMTU大小中减去IP报头的大小（包括任何IPv4可选报头或IPv6扩展报头）以及UDP报头的长度（8字节）。该大小称为最大段大小（MSS），可以从TCP/IP堆栈[RFC1122]中获得。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that do not send messages that exceed the effective PMTU of IPv4 or IPv6 need not implement any of the above mechanisms. Note that the presence of tunnels can cause an additional reduction of the effective PMTU [INT-TUNNELS], so implementing PMTU discovery may be beneficial.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不发送超过IPv4或IPv6有效PMTU的消息的应用程序不需要实现上述任何机制。请注意，隧道的存在可能会导致有效PMTU[INT-TUNNES]的额外减少，因此实施PMTU发现可能是有益的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that fragment an application-layer message into multiple UDP datagrams SHOULD perform this fragmentation so that each datagram can be received independently, and be independently retransmitted in the case where an application implements its own reliability mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将应用层消息分段为多个UDP数据报的应用程序应执行此分段，以便每个数据报可以独立接收，并在应用程序实现其自身可靠性机制的情况下独立重新传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Reliability Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 可靠性指南
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application designers are generally aware that UDP does not provide any reliability, e.g., it does not retransmit any lost packets. Often, this is a main reason to consider UDP as a transport protocol. Applications that do require reliable message delivery MUST implement an appropriate mechanism themselves.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序设计者通常知道UDP不提供任何可靠性，例如，它不重新传输任何丢失的数据包。通常，这是考虑UDP作为传输协议的一个主要原因。确实需要可靠消息传递的应用程序本身必须实现适当的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP also does not protect against datagram duplication, i.e., an application may receive multiple copies of the same UDP datagram, with some duplicates arriving potentially much later than the first. Application designers SHOULD handle such datagram duplication gracefully, and they may consequently need to implement mechanisms to detect duplicates. Even if UDP datagram reception triggers only idempotent operations, applications may want to suppress duplicate datagrams to reduce load.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP也不能防止数据报重复，即，应用程序可能会收到同一UDP数据报的多个副本，其中一些副本的到达时间可能比第一个副本晚得多。应用程序设计者应该优雅地处理这种数据报复制，因此他们可能需要实现检测重复的机制。即使UDP数据报接收仅触发幂等运算，应用程序也可能希望抑制重复数据报以减少负载。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that require ordered delivery MUST reestablish datagram ordering themselves. The Internet can significantly delay some packets with respect to others, e.g., due to routing transients, intermittent connectivity, or mobility. This can cause reordering, where UDP datagrams arrive at the receiver in an order different from the transmission order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
需要按顺序交付的应用程序必须自行重新建立数据报顺序。例如，由于路由瞬变、间歇连接或移动性，因特网可以显著地延迟一些分组相对于其他分组。这可能导致重新排序，其中UDP数据报以不同于传输顺序的顺序到达接收器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that use multiple transport ports need to be robust to reordering between sessions. Load-balancing techniques within the network, such as Equal Cost Multipath (ECMP) forwarding can also result in a lack of ordering between different transport sessions, even between the same two network endpoints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用多个传输端口的应用程序需要能够在会话之间重新排序。网络内的负载平衡技术，如等成本多路径（ECMP）转发，也可能导致不同传输会话之间缺乏顺序，甚至是在相同的两个网络端点之间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is important to note that the time by which packets are reordered or after which duplicates can still arrive can be very large. Even more importantly, there is no well-defined upper boundary here. [RFC793] defines the maximum delay a TCP segment should experience -- the Maximum Segment Lifetime (MSL) -- as 2 minutes. No other RFC defines an MSL for other transport protocols or IP itself. The MSL value defined for TCP is conservative enough that it SHOULD be used by other protocols, including UDP. Therefore, applications SHOULD be robust to the reception of delayed or duplicate packets that are received within this 2-minute interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
需要注意的是，数据包重新排序或重复数据仍然可以到达的时间可能非常长。更重要的是，这里没有明确的上限。[RFC793]将TCP段应经历的最大延迟（最大段生存期（MSL））定义为2分钟。没有其他RFC为其他传输协议或IP本身定义MSL。为TCP定义的MSL值足够保守，其他协议（包括UDP）应该使用它。因此，应用程序对于在这2分钟间隔内接收到的延迟或重复数据包的接收应该是健壮的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retransmission of lost packets or messages is a common reliability mechanism. Such retransmissions can increase network load in response to congestion, worsening that congestion. Any application that uses retransmission is responsible for congestion control of its retransmissions (as well as the application&#39;s original traffic); hence, it is subject to the Congestion Control guidelines in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
丢失数据包或消息的重新传输是一种常见的可靠性机制。这种重传可以增加网络负载以响应拥塞，从而加剧拥塞。使用重传的任何应用程序负责其重传的拥塞控制（以及应用程序的原始流量）；因此,该路段须遵守&#34;交通挤塞管制指引&#34;
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 3.1. Guidance on the appropriate measurement of RTT in Section 3.1.1 also applies for timers used for retransmission packet-loss detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3.1节。第3.1.1节中关于RTT适当测量的指南也适用于用于重传数据包丢失检测的计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Instead of implementing these relatively complex reliability mechanisms by itself, an application that requires reliable and ordered message delivery SHOULD whenever possible choose an IETF standard transport protocol that provides these features.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
需要可靠和有序消息传递的应用程序应该尽可能选择提供这些功能的IETF标准传输协议，而不是自行实现这些相对复杂的可靠性机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Checksum Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 校验和准则
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UDP header includes an optional, 16-bit one&#39;s complement checksum that provides an integrity check. These checks are not strong from a coding or cryptographic perspective and are not designed to detect physical-layer errors or malicious modification of the datagram [RFC3819]. Application developers SHOULD implement additional checks where data integrity is important, e.g., through a Cyclic Redundancy Check (CRC) or keyed or non-keyed cryptographic hash included with the data to verify the integrity of an entire object/file sent over the UDP service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP报头包括一个可选的16位1的补码校验和，该校验和提供完整性检查。从编码或加密的角度来看，这些检查不是很强，设计用于检测物理层错误或恶意修改数据报[RFC3819]。在数据完整性很重要的情况下，应用程序开发人员应实施额外的检查，例如，通过循环冗余检查（CRC）或数据中包含的密钥或非密钥加密哈希来验证通过UDP服务发送的整个对象/文件的完整性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UDP checksum provides a statistical guarantee that the payload was not corrupted in transit. It also allows the receiver to verify that it was the intended destination of the packet, because it covers the IP addresses, port numbers, and protocol number, and it verifies that the packet is not truncated or padded, because it covers the size field. Therefore, it protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent. More description of the set of checks performed using the checksum field is provided in Section 3.1 of [RFC6396].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP校验和提供了有效负载在传输过程中未损坏的统计保证。它还允许接收方验证它是数据包的预期目的地，因为它包含IP地址、端口号和协议号，并且它验证数据包没有被截断或填充，因为它包含大小字段。因此，它可以防止应用程序接收损坏的有效负载数据来代替或补充发送的数据。[RFC6396]第3.1节提供了使用校验和字段执行的检查集的更多说明。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications SHOULD enable UDP checksums [RFC1122]. For IPv4, [RFC768] permits an option to disable their use, by setting a zero checksum value. An application is permitted to optionally discard UDP datagrams with a zero checksum [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序应启用UDP校验和[RFC1122]。对于IPv4，[RFC768]允许通过设置零校验和值来禁用其使用。允许应用程序选择性地丢弃校验和为零的UDP数据报[RFC1122]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When UDP is used over IPv6, the UDP checksum is relied upon to protect both the IPv6 and UDP headers from corruption (because IPv6 lacks a checksum) and MUST be used as specified in [RFC2460]. Under specific conditions, a UDP application is allowed to use a zero UDP zero-checksum mode with a tunnel protocol (see Section 3.4.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在IPv6上使用UDP时，UDP校验和用于保护IPv6和UDP报头不受损坏（因为IPv6缺少校验和），并且必须按照[RFC2460]中的规定使用。在特定条件下，允许UDP应用程序使用带隧道协议的零UDP零校验和模式（见第3.4.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that choose to disable UDP checksums MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a UDP datagram is received that was originally sent to a different destination or is otherwise corrupted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择禁用UDP校验和的应用程序不得对接收到的数据的正确性进行假设，并且在接收到最初发送到其他目的地或已损坏的UDP数据报时，必须正确操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1. IPv6 Zero UDP Checksum
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.1. IPv6零UDP校验和
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935] defines a method that enables use of a zero UDP zero-checksum mode with a tunnel protocol, providing that the method satisfies the requirements in [RFC6936]. The application MUST implement mechanisms and/or usage restrictions when enabling this mode. This includes defining the scope for usage and measures to prevent leakage of traffic to other UDP applications (see Appendix A and Section 3.6). These additional design requirements for using a zero IPv6 UDP checksum are not present for IPv4, since the IPv4 header validates information that is not protected in an IPv6 packet. Key requirements are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935]定义了一种方法，该方法允许在隧道协议中使用零UDP零校验和模式，前提是该方法满足[RFC6936]中的要求。启用此模式时，应用程序必须实现机制和/或使用限制。这包括定义使用范围和防止流量泄漏到其他UDP应用程序的措施（见附录A和第3.6节）。IPv4不存在使用零IPv6 UDP校验和的这些附加设计要求，因为IPv4报头验证IPv6数据包中未受保护的信息。主要要求是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Use of the UDP checksum with IPv6 MUST be the default configuration for all implementations [RFC6935]. The receiving endpoint MUST only allow the use of UDP zero-checksum mode for IPv6 on a UDP destination port that is specifically enabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在IPv6中使用UDP校验和必须是所有实现的默认配置[RFC6935]。接收端点必须仅允许在特定启用的UDP目标端口上对IPv6使用UDP零校验和模式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An application that supports a checksum different than that in [RFC2460] MUST comply with all implementation requirements specified in Section 4 of [RFC6936] and with the usage requirements specified in Section 5 of [RFC6936].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 支持不同于[RFC2460]的校验和的应用程序必须符合[RFC6936]第4节规定的所有实现要求和[RFC6936]第5节规定的使用要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A UDP application MUST check that the source and destination IPv6 addresses are valid for any packets with a UDP zero-checksum and MUST discard any packet for which this check fails. To protect from misdelivery, new encapsulation designs SHOULD include an integrity check at the transport layer that includes at least the IPv6 header, the UDP header and the shim header for the encapsulation, if any [RFC6936].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o UDP应用程序必须检查源IPv6地址和目标IPv6地址是否对具有UDP零校验和的任何数据包有效，并且必须丢弃此检查失败的任何数据包。为了防止误发，新的封装设计应包括传输层的完整性检查，其中至少包括用于封装的IPv6报头、UDP报头和垫片报头（如果有）[RFC6936]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One way to help satisfy the requirements of [RFC6936] may be to limit the usage of such tunnels, e.g., to constrain traffic to an operator network, as discussed in Section 3.6. The encapsulation defined for MPLS in UDP [RFC7510] chooses this approach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 帮助满足[RFC6936]要求的一种方法可能是限制此类隧道的使用，例如，如第3.6节所述，限制运营商网络的流量。UDP[RFC7510]中为MPLS定义的封装选择了这种方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As in IPv4, IPv6 applications that choose to disable UDP checksums MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a UDP datagram is received that was originally sent to a different destination or is otherwise corrupted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与IPv4中一样，选择禁用UDP校验和的IPv6应用程序不得对接收到的数据的正确性进行假设，并且在接收到最初发送到其他目的地或已损坏的UDP数据报时，其行为必须正确。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6 datagrams with a zero UDP checksum will not be passed by any middlebox that validates the checksum based on [RFC2460] or that updates the UDP checksum field, such as NATs or firewalls. Changing this behavior would require such middleboxes to be updated to correctly handle datagrams with zero UDP checksums. To ensure end-to-end robustness, applications that may be deployed in the general Internet MUST provide a mechanism to safely fall back to using a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP校验和为零的IPv6数据报将不会通过任何基于[RFC2460]验证校验和或更新UDP校验和字段（如NAT或防火墙）的中间盒传递。更改此行为需要更新此类中间盒，以正确处理UDP校验和为零的数据报。为了确保端到端的健壮性，可以部署在通用Internet中的应用程序必须提供一种机制，以安全地退回到使用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
checksum when a path change occurs that redirects a zero UDP checksum flow over a path that includes a middlebox that discards IPv6 datagrams with a zero UDP checksum.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
校验和发生路径更改时，该更改将零UDP校验和流重定向到一条路径上，该路径包含一个丢弃具有零UDP校验和的IPv6数据报的中间盒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2. UDP-Lite
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4.2. UDP精简
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A special class of applications can derive benefit from having partially damaged payloads delivered, rather than discarded, when using paths that include error-prone links. Such applications can tolerate payload corruption and MAY choose to use the Lightweight User Datagram Protocol (UDP-Lite) [RFC3828] variant of UDP instead of basic UDP. Applications that choose to use UDP-Lite instead of UDP should still follow the congestion control and other guidelines described for use with UDP in Section 3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当使用包含易出错链接的路径时，一类特殊的应用程序可以从交付而不是丢弃部分损坏的有效负载中获益。此类应用程序可以容忍有效负载损坏，并且可以选择使用UDP的轻量级用户数据报协议（UDP Lite）[RFC3828]变体，而不是基本UDP。选择使用UDP Lite而不是UDP的应用程序仍应遵循第3节中描述的用于UDP的拥塞控制和其他指南。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Lite changes the semantics of the UDP &#34;payload length&#34; field to that of a &#34;checksum coverage length&#34; field. Otherwise, UDP-Lite is semantically identical to UDP. The interface of UDP-Lite differs from that of UDP by the addition of a single (socket) option that communicates the checksum coverage length: at the sender, this specifies the intended checksum coverage, with the remaining unprotected part of the payload called the &#34;error-insensitive part&#34;. By default, the UDP-Lite checksum coverage extends across the entire datagram. If required, an application may dynamically modify this length value, e.g., to offer greater protection to some messages. UDP-Lite always verifies that a packet was delivered to the intended destination, i.e., always verifies the header fields. Errors in the insensitive part will not cause a UDP datagram to be discarded by the destination. Therefore, applications using UDP-Lite MUST NOT make assumptions regarding the correctness of the data received in the insensitive part of the UDP-Lite payload.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP Lite将UDP“有效负载长度”字段的语义更改为“校验和覆盖长度”字段的语义。否则，UDP Lite在语义上与UDP相同。UDP Lite的接口与UDP的接口不同，它增加了一个（套接字）选项，用于通信校验和覆盖长度：在发送方，这指定了预期的校验和覆盖范围，负载的剩余未受保护部分称为“错误不敏感部分”。默认情况下，UDP Lite校验和覆盖范围扩展到整个数据报。如果需要，应用程序可以动态修改此长度值，例如，为某些消息提供更大的保护。UDP Lite始终验证数据包是否已发送到预期目的地，即始终验证报头字段。不敏感部分中的错误不会导致目标丢弃UDP数据报。因此，使用UDP Lite的应用程序不得对UDP Lite有效负载的不敏感部分中接收的数据的正确性进行假设。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP-Lite sender SHOULD select the minimum checksum coverage to include all sensitive payload information. For example, applications that use the Real-Time Protocol (RTP) [RFC3550] will likely want to protect the RTP header against corruption. Applications, where appropriate, MUST also introduce their own appropriate validity checks for protocol information carried in the insensitive part of the UDP-Lite payload (e.g., internal CRCs).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP Lite发送方应选择包含所有敏感负载信息的最小校验和覆盖率。例如，使用实时协议（RTP）[RFC3550]的应用程序可能希望保护RTP报头免受损坏。在适当的情况下，应用程序还必须对UDP Lite有效负载的不敏感部分（例如，内部CRC）中携带的协议信息引入自己的适当有效性检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP-Lite receiver MUST set a minimum coverage threshold for incoming packets that is not smaller than the smallest coverage used by the sender [RFC3828]. The receiver SHOULD select a threshold that is sufficiently large to block packets with an inappropriately short coverage field. This may be a fixed value, or it may be negotiated by an application. UDP-Lite does not provide mechanisms to negotiate the checksum coverage between the sender and receiver. Therefore, this needs to be performed by the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP Lite接收器必须为传入数据包设置最小覆盖率阈值，该阈值不得小于发送方使用的最小覆盖率[RFC3828]。接收器应选择一个足够大的阈值，以阻止具有不适当短覆盖域的数据包。这可能是一个固定值，也可能由应用程序协商。UDP Lite不提供在发送方和接收方之间协商校验和覆盖率的机制。因此，这需要由应用程序执行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications can still experience packet loss when using UDP-Lite. The enhancements offered by UDP-Lite rely upon a link being able to intercept the UDP-Lite header to correctly identify the partial coverage required. When tunnels and/or encryption are used, this can result in UDP-Lite datagrams being treated the same as UDP datagrams, i.e., result in packet loss. Use of IP fragmentation can also prevent special treatment for UDP-Lite datagrams, and this is another reason why applications SHOULD avoid IP fragmentation (Section 3.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当使用UDP Lite时，应用程序仍然会遇到数据包丢失。UDP Lite提供的增强依赖于能够截获UDP Lite头的链接，以正确识别所需的部分覆盖。当使用隧道和/或加密时，这可能导致UDP Lite数据报与UDP数据报被视为相同，即导致数据包丢失。使用IP碎片还可以防止对UDP Lite数据报进行特殊处理，这也是应用程序应避免IP碎片的另一个原因（第3.2节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP-Lite is supported in some endpoint protocol stacks. Current support for middlebox traversal using UDP-Lite is poor, because UDP-Lite uses a different IPv4 protocol number or IPv6 &#34;next header&#34; value than that used for UDP; therefore, few middleboxes are currently able to interpret UDP-Lite and take appropriate actions when forwarding the packet. This makes UDP-Lite less suited for applications needing general Internet support, until such time as UDP-Lite has achieved better support in middleboxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些端点协议栈支持UDP Lite。当前对使用UDP Lite的中间盒遍历的支持较差，因为UDP Lite使用的IPv4协议号或IPv6“下一个标头”值与UDP使用的不同；因此，目前很少有中间盒能够解释UDP Lite并在转发数据包时采取适当的操作。这使得UDP Lite不太适合需要一般Internet支持的应用程序，直到UDP Lite在中间盒中获得更好的支持。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Middlebox Traversal Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 中间盒遍历指南
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NATs and firewalls are examples of intermediary devices (&#34;middleboxes&#34;) that can exist along an end-to-end path. A middlebox typically performs a function that requires it to maintain per-flow state. For connection-oriented protocols, such as TCP, middleboxes snoop and parse the connection-management information, and create and destroy per-flow state accordingly. For a connectionless protocol such as UDP, this approach is not possible. Consequently, middleboxes can create per-flow state when they see a packet that -- according to some local criteria -- indicates a new flow, and destroy the state after some time during which no packets belonging to the same flow have arrived.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT和防火墙是可以沿端到端路径存在的中间设备（“中间盒”）的示例。中间盒通常执行要求其保持每个流状态的功能。对于面向连接的协议（如TCP），中间件可以窥探和解析连接管理信息，并相应地创建和销毁每个流状态。对于UDP这样的无连接协议，这种方法是不可能的。因此，当中间件看到一个数据包（根据某些本地标准）指示一个新的流时，可以创建每个流的状态，并在一段时间后破坏该状态，在此期间没有属于同一流的数据包到达。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Depending on the specific function that the middlebox performs, this behavior can introduce a time-dependency that restricts the kinds of UDP traffic exchanges that will be successful across the middlebox. For example, NATs and firewalls typically define the partial path on one side of them to be interior to the domain they serve, whereas the partial path on their other side is defined to be exterior to that domain. Per-flow state is typically created when the first packet crosses from the interior to the exterior, and while the state is present, NATs and firewalls will forward return traffic. Return traffic that arrives after the per-flow state has timed out is dropped, as is other traffic that arrives from the exterior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据中间箱执行的特定功能，此行为可能会引入时间依赖性，从而限制将在中间箱中成功进行的UDP流量交换的类型。例如，NAT和防火墙通常将其一侧的部分路径定义为其服务的域的内部，而另一侧的部分路径定义为该域的外部。每流状态通常是在第一个数据包从内部传输到外部时创建的，当该状态存在时，NAT和防火墙将转发返回流量。每流状态超时后到达的返回流量将被丢弃，从外部到达的其他流量也是如此。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many applications that use UDP for communication operate across middleboxes without needing to employ additional mechanisms. One example is the Domain Name System (DNS), which has a strict request-response communication pattern that typically completes within seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
许多使用UDP进行通信的应用程序在不需要使用其他机制的情况下跨中间件运行。一个例子是域名系统（DNS），它具有严格的请求-响应通信模式，通常在几秒钟内完成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other applications may experience communication failures when middleboxes destroy the per-flow state associated with an application session during periods when the application does not exchange any UDP traffic. Applications SHOULD be able to gracefully handle such communication failures and implement mechanisms to re-establish application-layer sessions and state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在应用程序不交换任何UDP流量期间，如果中间盒破坏与应用程序会话相关联的每流状态，则其他应用程序可能会遇到通信故障。应用程序应该能够优雅地处理此类通信故障，并实现重新建立应用程序层会话和状态的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For some applications, such as media transmissions, this re-synchronization is highly undesirable, because it can cause user-perceivable playback artifacts. Such specialized applications MAY send periodic keep-alive messages to attempt to refresh middlebox state (e.g., [RFC7675]). It is important to note that keep-alive messages are not recommended for general use -- they are unnecessary for many applications and can consume significant amounts of system and network resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于某些应用程序（如媒体传输），这种重新同步是非常不可取的，因为它会导致用户可感知的播放瑕疵。此类专用应用程序可能会定期发送保持活动状态的消息，以尝试刷新中间盒状态（例如，[RFC7675]）。需要注意的是，不建议将保持活动状态消息用于一般用途，因为它们对于许多应用程序都是不必要的，并且可能会消耗大量的系统和网络资源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application that needs to employ keep-alive messages to deliver useful service over UDP in the presence of middleboxes SHOULD NOT transmit them more frequently than once every 15 seconds and SHOULD use longer intervals when possible. No common timeout has been specified for per-flow UDP state for arbitrary middleboxes. NATs require a state timeout of 2 minutes or longer [RFC4787]. However, empirical evidence suggests that a significant fraction of currently deployed middleboxes unfortunately use shorter timeouts. The timeout of 15 seconds originates with the Interactive Connectivity Establishment (ICE) protocol [RFC5245]. When an application is deployed in a controlled environment, the deployer SHOULD investigate whether the target environment allows applications to use longer intervals, or whether it offers mechanisms to explicitly control middlebox state timeout durations, for example, using the Port Control Protocol (PCP) [RFC6887], Middlebox Communications (MIDCOM) [RFC3303], Next Steps in Signaling (NSIS) [RFC5973], or Universal Plug and Play (UPnP) [UPnP]. It is RECOMMENDED that applications apply slight random variations (&#34;jitter&#34;) to the timing of keep-alive transmissions, to reduce the potential for persistent synchronization between keep-alive transmissions from different hosts [RFC7675].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果应用程序需要使用保持活动的消息，以便在存在中间盒的情况下通过UDP提供有用的服务，则该应用程序的传输频率不应超过每15秒一次，并且应尽可能使用更长的时间间隔。没有为任意中间盒的每个流UDP状态指定公共超时。NAT需要2分钟或更长的状态超时[RFC4787]。然而，经验证据表明，不幸的是，目前部署的中间盒中有相当一部分使用较短的超时时间。15秒的超时源自交互式连接建立（ICE）协议[RFC5245]。当应用程序部署在受控环境中时，部署人员应调查目标环境是否允许应用程序使用更长的时间间隔，或者是否提供明确控制中间箱状态超时持续时间的机制，例如，使用端口控制协议（PCP）[RFC6887]，中间箱通信（MIDCOM）[RFC3303]，信令的下一步（NSIS）[RFC5973]或通用即插即用（UPnP）[UPnP]。建议应用程序对保持活动传输的定时应用轻微的随机变化（“抖动”），以减少来自不同主机的保持活动传输之间持续同步的可能性[RFC7675]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Sending keep-alive messages is not a substitute for implementing a mechanism to recover from broken sessions. Like all UDP datagrams, keep-alive messages can be delayed or dropped, causing middlebox state to time out. In addition, the congestion control guidelines in Section 3.1 cover all UDP transmissions by an application, including the transmission of middlebox keep-alive messages. Congestion control may thus lead to delays or temporary suspension of keep-alive transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送保持活动状态消息不能替代实现从中断会话中恢复的机制。与所有UDP数据报一样，保持活动状态的消息可能会被延迟或丢弃，从而导致中间盒状态超时。此外，第3.1节中的拥塞控制指南涵盖了应用程序的所有UDP传输，包括中间盒保持活动消息的传输。因此，拥塞控制可能导致持续传输的延迟或临时暂停。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Keep-alive messages are NOT RECOMMENDED for general use. They are unnecessary for many applications and may consume significant resources. For example, on battery-powered devices, if an application needs to maintain connectivity for long periods with little traffic, the frequency at which keep-alive messages are sent can become the determining factor that governs power consumption, depending on the underlying network technology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不建议将保持活动状态消息用于一般用途。它们对于许多应用程序都是不必要的，并且可能会消耗大量资源。例如，在电池供电的设备上，如果应用程序需要在流量很少的情况下长时间保持连接，则发送保持活动消息的频率可能成为控制功耗的决定因素，具体取决于基础网络技术。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because many middleboxes are designed to require keep-alive messages for TCP connections at a frequency that is much lower than that needed for UDP, this difference alone can often be sufficient to prefer TCP over UDP for these deployments. On the other hand, there is anecdotal evidence that suggests that direct communication through middleboxes, e.g., by using ICE [RFC5245], does succeed less often with TCP than with UDP. The trade-offs between different transport protocols -- especially when it comes to middlebox traversal -- deserve careful analysis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于许多中间盒的设计要求TCP连接的保持活动消息的频率远低于UDP所需的频率，因此仅此差异就足以使这些部署更倾向于使用TCP而非UDP。另一方面，有传闻证据表明，通过中间箱（例如，通过使用ICE[RFC5245]）进行的直接通信，使用TCP的成功率低于使用UDP的成功率。不同传输协议之间的权衡——特别是在涉及到中间盒遍历时——值得仔细分析。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications that could be deployed in the Internet need to be designed understanding that there are many variants of middlebox behavior, and although UDP is connectionless, middleboxes often maintain state for each UDP flow. Using multiple UDP flows can consume available state space and also can lead to changes in the way the middlebox handles subsequent packets (either to protect its internal resources, or to prevent perceived misuse). The probability of path failure can increase when applications use multiple UDP flows in parallel (see Section 5.1.2 for recommendations on usage of multiple ports).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可以部署在Internet上的UDP应用程序的设计需要理解中间盒行为的许多变体，并且尽管UDP是无连接的，但中间盒通常维护每个UDP流的状态。使用多个UDP流可能会消耗可用的状态空间，还可能导致中间盒处理后续数据包的方式发生变化（以保护其内部资源，或防止感知到的误用）。当应用程序并行使用多个UDP流时，路径故障的概率会增加（有关使用多个端口的建议，请参阅第5.1.2节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Limited Applicability and Controlled Environments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 有限的适用性和受控环境
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two different types of applicability have been identified for the specification of IETF applications that utilize UDP:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于使用UDP的IETF应用程序规范，已确定了两种不同类型的适用性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
General Internet. By default, IETF specifications target deployment on the general Internet. Experience has shown that successful protocols developed in one specific context or for a particular application tend to become used in a wider range of contexts. For example, a protocol with an initial deployment within a local area
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通用互联网。默认情况下，IETF规范以通用Internet上的部署为目标。经验表明，在一个特定环境或特定应用中开发的成功协议往往会在更广泛的环境中使用。例如，在本地区域内进行初始部署的协议
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
network may subsequently be used over a virtual network that traverses the Internet, or in the Internet in general. Applications designed for general Internet use may experience a range of network device behaviors and, in particular, should consider whether applications need to operate over paths that may include middleboxes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
该网络随后可在穿越因特网的虚拟网络上使用，或在一般因特网中使用。设计用于一般互联网使用的应用程序可能会经历一系列的网络设备行为，特别是，应该考虑应用程序是否需要对可能包括中间框的路径进行操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Controlled Environment. A protocol/encapsulation/tunnel could be designed to be used only within a controlled environment. For example, an application designed for use by a network operator might only be deployed within the network of that single network operator or on networks of an adjacent set of cooperating network operators. The application traffic may then be managed to avoid congestion, rather than relying on built-in mechanisms, which are required when operating over the general Internet. Applications that target a limited applicability use case may be able to take advantage of specific hardware (e.g., carrier-grade equipment) or underlying protocol features of the subnetwork over which they are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
受控环境。协议/封装/隧道可设计为仅在受控环境中使用。例如，为网络运营商使用而设计的应用程序可能仅部署在该单一网络运营商的网络内，或部署在相邻一组合作网络运营商的网络上。然后，可以对应用程序流量进行管理以避免拥塞，而不是依赖于在通用Internet上运行时所需的内置机制。针对有限适用性用例的应用程序可能能够利用其所使用的子网的特定硬件（例如，载波级设备）或底层协议特性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specifications addressing a limited applicability use case or a controlled environment SHOULD identify how, in their restricted deployment, a level of safety is provided that is equivalent to that of a protocol designed for operation over the general Internet (e.g., a design based on extensive experience with deployments of particular methods that provide features that cannot be expected in general Internet equipment and the robustness of the design of MPLS to corruption of headers both helped justify use of an alternate UDP integrity check [RFC7510]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
针对有限适用性用例或受控环境的规范应确定如何在其受限部署中提供与设计用于在通用互联网上运行的协议等效的安全级别（例如，基于部署特定方法的广泛经验的设计，提供了一般互联网设备无法预期的功能，以及MPLS设计对报头损坏的鲁棒性，这两者都有助于证明使用备用UDP完整性检查[RFC7510]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An IETF specification targeting a controlled environment is expected to provide an applicability statement that restricts the application traffic to the controlled environment, and it would be expected to describe how methods can be provided to discourage or prevent escape of corrupted packets from the environment (for example, Section 5 of [RFC7510]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
针对受控环境的IETF规范应提供适用性声明，将应用程序通信量限制在受控环境中，并应说明如何提供方法阻止或防止损坏的数据包从环境中逃逸（例如，本规范第5节）[RFC7510]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Multicast UDP Usage Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 多播UDP使用指南
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section complements Section 3 by providing additional guidelines that are applicable to multicast and broadcast usage of UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节补充了第3节，提供了适用于UDP的多播和广播使用的附加指南。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast and broadcast transmission [RFC1112] usually employ the UDP transport protocol, although they may be used with other transport protocols (e.g., UDP-Lite).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播和广播传输[RFC1112]通常使用UDP传输协议，尽管它们可能与其他传输协议（例如UDP Lite）一起使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are currently two models of multicast delivery: the Any-Source Multicast (ASM) model as defined in [RFC1112] and the Source-Specific Multicast (SSM) model as defined in [RFC4607]. ASM group members will receive all data sent to the group by any source, while SSM constrains the distribution tree to only one single source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目前有两种多播交付模型：[RFC1112]中定义的任意源多播（ASM）模型和[RFC4607]中定义的源特定多播（SSM）模型。ASM组成员将接收任何源发送到组的所有数据，而SSM将分发树限制为仅一个源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Specialized classes of applications also use UDP for IP multicast or broadcast [RFC919]. The design of such specialized applications requires expertise that goes beyond simple, unicast-specific guidelines, since these senders may transmit to potentially very many receivers across potentially very heterogeneous paths at the same time, which significantly complicates congestion control, flow control, and reliability mechanisms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
特殊类别的应用程序也使用UDP进行IP多播或广播[RFC919]。这种专用应用程序的设计需要超越简单的单播特定准则的专业知识，因为这些发送方可能同时跨潜在的非常异构的路径向潜在的非常多的接收方发送数据，这大大复杂了拥塞控制、流控制和可靠性机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides guidance on multicast and broadcast UDP usage. Use of broadcast by an application is normally constrained by routers to the local subnetwork. However, use of tunneling techniques and proxies can and does result in some broadcast traffic traversing Internet paths. These guidelines therefore also apply to broadcast traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节提供有关多播和广播UDP使用的指导。应用程序对广播的使用通常受到本地子网路由器的限制。然而，使用隧道技术和代理可以并且确实会导致一些广播流量穿越互联网路径。因此，这些指南也适用于广播流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF has defined a reliable multicast framework [RFC3048] and several building blocks to aid the designers of multicast applications, such as [RFC3738] or [RFC4654].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF定义了一个可靠的多播框架[RFC3048]和几个构建块，以帮助多播应用程序的设计者，如[RFC3738]或[RFC4654]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Senders to anycast destinations must be aware that successive messages sent to the same anycast IP address may be delivered to different anycast nodes, i.e., arrive at different locations in the topology.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选播目的地的发送者必须知道，发送到同一选播IP地址的连续消息可能会传递到不同的选播节点，即到达拓扑中的不同位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Most UDP tunnels that carry IP multicast traffic use a tunnel encapsulation with a unicast destination address, such as Automatic Multicast Tunneling [RFC7450]. These MUST follow the same requirements as a tunnel carrying unicast data (see Section 3.1.11). There are deployment cases and solutions where the outer header of a UDP tunnel contains a multicast destination address, such as [RFC6513]. These cases are primarily deployed in controlled environments over reserved capacity, often operating within a single administrative domain, or between two domains over a bilaterally agreed upon path with reserved capacity, and so congestion control is OPTIONAL, but circuit breaker techniques are still RECOMMENDED in order to restore some degree of service should the offered load exceed the reserved capacity (e.g., due to misconfiguration).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大多数承载IP多播流量的UDP隧道都使用带有单播目标地址的隧道封装，例如自动多播隧道[RFC7450]。这些必须遵循与承载单播数据的隧道相同的要求（见第3.1.11节）。有些部署案例和解决方案中，UDP隧道的外部标头包含多播目标地址，例如[RFC6513]。这些案例主要部署在保留容量的受控环境中，通常在单个管理域内运行，或在具有保留容量的双边商定路径上的两个域之间运行，因此拥塞控制是可选的，但仍然建议使用断路器技术，以便在提供的负载超过保留容量（例如，由于配置错误）时恢复一定程度的服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Multicast Congestion Control Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 多播拥塞控制指南
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicast congestion-controlled transport mechanisms are often not applicable to multicast distribution services, or simply do not scale to large multicast trees, since they require bidirectional communication and adapt the sending rate to accommodate the network conditions to a single receiver. In contrast, multicast distribution trees may fan out to massive numbers of receivers, which limits the scalability of an in-band return channel to control the sending rate, and the one-to-many nature of multicast distribution trees prevents adapting the rate to the requirements of an individual receiver. For this reason, generating TCP-compatible aggregate flow rates for Internet multicast data, either native or tunneled, is the responsibility of the application implementing the congestion control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单播拥塞控制传输机制通常不适用于多播分发服务，或者根本不适用于大型多播树，因为它们需要双向通信并调整发送速率以适应单个接收器的网络条件。相比之下，多播分发树可能散开到大量的接收器，这限制了带内返回信道控制发送速率的可伸缩性，并且多播分发树的一对多性质阻止了速率适应单个接收器的要求。因此，实现拥塞控制的应用程序负责为Internet多播数据（本机或隧道）生成与TCP兼容的聚合流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications using multicast SHOULD provide appropriate congestion control. Multicast congestion control needs to be designed using mechanisms that are robust to the potential heterogeneity of both the multicast distribution tree and the receivers belonging to a group. Heterogeneity may manifest itself in some receivers experiencing more loss that others, higher delay, and/or less ability to respond to network conditions. Congestion control is particularly important for any multicast session where all or part of the multicast distribution tree spans an access network (e.g., a home gateway). Two styles of congestion control have been defined in the RFC Series:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用多播的应用程序应该提供适当的拥塞控制。多播拥塞控制需要使用对多播分布树和属于组的接收器的潜在异构性都具有鲁棒性的机制来设计。异质性可能表现在一些接收机比其他接收机遭受更多的丢失、更高的延迟和/或更少的网络条件响应能力。对于所有或部分多播分发树跨越接入网络（例如，家庭网关）的任何多播会话，拥塞控制尤其重要。RFC系列中定义了两种类型的拥塞控制：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Feedback-based congestion control, in which the sender receives multicast or unicast UDP messages from the receivers allowing it to assess the level of congestion and then adjust the sender rate(s) (e.g., [RFC5740],[RFC4654]). Multicast methods may operate on longer timescales than for unicast (e.g., due to the higher group RTT of a heterogeneous group). A control method could decide not to reduce the rate of the entire multicast group in response to a control message received from a single receiver (e.g., a sender could set a minimum rate and decide to request a congested receiver to leave the multicast group and could also decide to distribute content to these congested receivers at a lower rate using unicast congestion control).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 基于反馈的拥塞控制，其中发送方从接收方接收多播或单播UDP消息，允许其评估拥塞水平，然后调整发送方速率（例如，[RFC5740]、[RFC4654]）。与单播相比，多播方法可以在更长的时间尺度上运行（例如，由于异构组的组RTT更高）。控制方法可以决定不降低整个多播组响应于从单个接收器接收的控制消息的速率（例如，发送方可以设置最小速率并决定请求拥塞的接收方离开多播组，还可以决定使用单播拥塞控制以较低速率将内容分发给这些拥塞的接收方）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receiver-driven congestion control, which does not require a receiver to send explicit UDP control messages for congestion control (e.g., [RFC3738], [RFC5775]). Instead, the sender distributes the data across multiple IP multicast groups (e.g., using a set of {S,G} channels). Each receiver determines its own level of congestion and controls its reception rate using only multicast join/leave messages sent in the network control plane. This method scales to arbitrary large groups of receivers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接收器驱动的拥塞控制，不需要接收器发送显式UDP控制消息进行拥塞控制（例如，[RFC3738]、[RFC5775]）。相反，发送方在多个IP多播组之间分发数据（例如，使用一组{S，g}通道）。每个接收器确定其自身的拥塞级别，并仅使用在网络控制平面中发送的多播加入/离开消息来控制其接收速率。该方法可扩展到任意大的接收机组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any multicast-enabled receiver may attempt to join and receive traffic from any group. This may imply the need for rate limits on individual receivers or the aggregate multicast service. Note, at the transport layer, there is no way to prevent a join message propagating to the next-hop router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任何启用多播的接收器都可以尝试加入并接收来自任何组的流量。这可能意味着需要对单个接收器或聚合多播服务进行速率限制。注意，在传输层，无法阻止连接消息传播到下一跳路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some classes of multicast applications support applications that can monitor the user-level quality of the transfer at the receiver. Applications that can detect a significant reduction in user quality SHOULD regard this as a congestion signal (e.g., to leave a group using layered multicast encoding); if not, they SHOULD use this signal to provide a circuit breaker to terminate the flow by leaving the multicast group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些类别的多播应用程序支持可以在接收器处监控用户级传输质量的应用程序。能够检测到用户质量显著降低的应用程序应将其视为拥塞信号（例如，使用分层多播编码离开组）；如果没有，他们应该使用该信号提供断路器，通过离开多播组来终止流。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Bulk-Transfer Multicast Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 批量传输多播应用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that perform bulk transmission of data over a multicast distribution tree, i.e., applications that exchange more than a few UDP datagrams per RTT, SHOULD implement a method for congestion control. The currently RECOMMENDED IETF methods are as follows: Asynchronous Layered Coding (ALC) [RFC5775], TCP-Friendly Multicast Congestion Control (TFMCC) [RFC4654], Wave and Equation Based Rate Control (WEBRC) [RFC3738], NACK-Oriented Reliable Multicast (NORM) transport protocol [RFC5740], File Delivery over Unidirectional Transport (FLUTE) [RFC6726], Real Time Protocol/Control Protocol (RTP/RTCP) [RFC3550].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过多播分发树执行数据大容量传输的应用程序，即每个RTT交换多个UDP数据报的应用程序，应实现拥塞控制方法。目前推荐的IETF方法如下：异步分层编码（ALC）[RFC5775]、TCP友好多播拥塞控制（TFMCC）[RFC4654]、基于波形和方程的速率控制（WEBRC）[RFC3738]、面向NACK的可靠多播（NORM）传输协议[RFC5740]、单向传输上的文件传递（FLUTE）[RFC6726]，实时协议/控制协议（RTP/RTCP）[RFC3550]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An application can alternatively implement another congestion control scheme following the guidelines of [RFC2887] and utilizing the framework of [RFC3048]. Bulk-transfer applications that choose not to implement [RFC4654], [RFC5775], [RFC3738], [RFC5740], [RFC6726], or [RFC3550] SHOULD implement a congestion control scheme that results in bandwidth use that competes fairly with TCP within an order of magnitude.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序也可以按照[RFC2887]的指导方针并利用[RFC3048]的框架实施另一种拥塞控制方案。选择不实施[RFC4654]、[RFC5775]、[RFC3738]、[RFC5740]、[RFC6726]或[RFC3550]的大容量传输应用程序应实施拥塞控制方案，该方案将导致带宽使用在一个数量级内与TCP公平竞争。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 2 of [RFC3551] states that multimedia applications SHOULD monitor the packet-loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an &#34;order-of-magnitude&#34; comparison in timescale and throughput.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551]第2节规定，多媒体应用程序应监控数据包丢失率，以确保其在可接受的参数范围内。如果在相同的网络条件下，通过相同网络路径的TCP流在合理的时间尺度上达到不低于UDP流的平均吞吐量，则认为丢包是可接受的。无法精确指定与TCP的比较，但其目的是在时间尺度和吞吐量方面进行“数量级”比较。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. Low Data-Volume Multicast Applications
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. 低数据量多播应用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All the recommendations in Section 3.1.3 are also applicable to low data-volume multicast applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3.1.3节中的所有建议也适用于低数据量多播应用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Message Size Guidelines for Multicast
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 多播的消息大小准则
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A multicast application SHOULD NOT send UDP datagrams that result in IP packets that exceed the effective MTU as described in Section 3 of [RFC6807]. Consequently, an application SHOULD either use the effective MTU information provided by the &#34;Population Count Extensions to Protocol Independent Multicast (PIM)&#34; [RFC6807] or implement path MTU discovery itself (see Section 3.2) to determine whether the path to each destination will support its desired message size without fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播应用程序不应发送导致IP数据包超过[RFC6807]第3节所述有效MTU的UDP数据报。因此，应用程序应使用“协议独立多播（PIM）的人口计数扩展”[RFC6807]提供的有效MTU信息，或自行实现路径MTU发现（见第3.2节），以确定到达每个目的地的路径是否支持其所需的消息大小而不出现碎片。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Programming Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 规划准则
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The de facto standard application programming interface (API) for TCP/IP applications is the &#34;sockets&#34; interface [POSIX]. Some platforms also offer applications the ability to directly assemble and transmit IP packets through &#34;raw sockets&#34; or similar facilities. This is a second, more cumbersome method of using UDP. The guidelines in this document cover all such methods through which an application may use UDP. Because the sockets API is by far the most common method, the remainder of this section discusses it in more detail.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TCP/IP应用程序事实上的标准应用程序编程接口（API）是“套接字”接口[POSIX]。一些平台还为应用程序提供了通过“原始套接字”或类似设施直接组装和传输IP数据包的能力。这是第二种更麻烦的使用UDP的方法。本文档中的指南涵盖了应用程序使用UDP的所有此类方法。由于套接字API是目前为止最常用的方法，因此本节的其余部分将对其进行更详细的讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the sockets API was developed for UNIX in the early 1980s, a wide variety of non-UNIX operating systems also implement it. The sockets API supports both IPv4 and IPv6 [RFC3493]. The UDP sockets API differs from that for TCP in several key ways. Because application programmers are typically more familiar with the TCP sockets API, this section discusses these differences. [STEVENS] provides usage examples of the UDP sockets API.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管SocketsAPI是在20世纪80年代早期为UNIX开发的，但各种各样的非UNIX操作系统也实现了它。套接字API同时支持IPv4和IPv6[RFC3493]。UDP套接字API在几个关键方面与TCP不同。由于应用程序程序员通常更熟悉TCP套接字API，因此本节将讨论这些差异。[STEVENS]提供了UDP套接字API的使用示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP datagrams may be directly sent and received, without any connection setup. Using the sockets API, applications can receive packets from more than one IP source address on a single UDP socket. Some servers use this to exchange data with more than one remote host through a single UDP socket at the same time. Many applications need to ensure that they receive packets from a particular source address; these applications MUST implement corresponding checks at the application layer or explicitly request that the operating system filter the received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP数据报可以直接发送和接收，无需任何连接设置。使用套接字API，应用程序可以在单个UDP套接字上从多个IP源地址接收数据包。一些服务器使用此功能同时通过单个UDP套接字与多个远程主机交换数据。许多应用程序需要确保它们从特定的源地址接收数据包；这些应用程序必须在应用程序层执行相应的检查，或者明确请求操作系统过滤接收到的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many operating systems also allow a UDP socket to be connected, i.e., to bind a UDP socket to a specific pair of addresses and ports. This is similar to the corresponding TCP sockets API functionality. However, for UDP, this is only a local operation that serves to simplify the local send/receive functions and to filter the traffic for the specified addresses and ports. Binding a UDP socket does not establish a connection -- UDP does not notify the remote end when a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
许多操作系统还允许连接UDP套接字，即将UDP套接字绑定到特定的地址和端口对。这类似于相应的TCP套接字API功能。但是，对于UDP，这只是一个本地操作，用于简化本地发送/接收功能并过滤指定地址和端口的通信量。绑定UDP套接字不会建立连接——UDP不会在发生连接时通知远程端
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
local UDP socket is bound. Binding a socket also allows configuring options that affect the UDP or IP layers, for example, use of the UDP checksum or the IP Timestamp option. On some stacks, a bound socket also allows an application to be notified when ICMP error messages are received for its transmissions [RFC1122].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本地UDP套接字已绑定。绑定套接字还允许配置影响UDP或IP层的选项，例如，使用UDP校验和或IP时间戳选项。在某些堆栈上，绑定套接字还允许在收到ICMP错误消息进行传输时通知应用程序[RFC1122]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a client/server application executes on a host with more than one IP interface, the application SHOULD send any UDP responses with an IP source address that matches the IP destination address of the UDP datagram that carried the request (see [RFC1122], Section 4.1.3.5). Many middleboxes expect this transmission behavior and drop replies that are sent from a different IP address, as explained in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果客户机/服务器应用程序在具有多个IP接口的主机上执行，则应用程序应发送任何UDP响应，其IP源地址应与承载请求的UDP数据报的IP目标地址匹配（请参阅[RFC1122]，第4.1.3.5节）。如第3.5节所述，许多中间盒期望这种传输行为，并丢弃从不同IP地址发送的回复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP receiver can receive a valid UDP datagram with a zero-length payload. Note that this is different from a return value of zero from a read() socket call, which for TCP indicates the end of the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP接收器可以接收长度为零的有效UDP数据报。请注意，这与read（）套接字调用的返回值零不同，后者对于TCP表示连接结束。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP provides no flow-control, i.e., the sender at any given time does not know whether the receiver is able to handle incoming transmissions. This is another reason why UDP-based applications need to be robust in the presence of packet loss. This loss can also occur within the sending host, when an application sends data faster than the line rate of the outbound network interface. It can also occur at the destination, where receive calls fail to return all the data that was sent when the application issues them too infrequently (i.e., such that the receive buffer overflows). Robust flow control mechanisms are difficult to implement, which is why applications that need this functionality SHOULD consider using a full-featured transport protocol such as TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP不提供流量控制，即发送方在任何给定时间都不知道接收方是否能够处理传入的传输。这是基于UDP的应用程序在出现数据包丢失时需要健壮的另一个原因。当应用程序发送数据的速度快于出站网络接口的线路速率时，这种丢失也可能发生在发送主机内。它也可能发生在目的地，当应用程序太不频繁地发出接收调用时（例如，接收缓冲区溢出），接收调用无法返回发送的所有数据。鲁棒的流量控制机制很难实现，这就是为什么需要这种功能的应用程序应该考虑使用诸如TCP之类的全功能传输协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When an application closes a TCP, SCTP, or DCCP socket, the transport protocol on the receiving host is required to maintain TIME-WAIT state. This prevents delayed packets from the closed connection instance from being mistakenly associated with a later connection instance that happens to reuse the same IP address and port pairs. The UDP protocol does not implement such a mechanism. Therefore, UDP-based applications need to be robust to reordering and delay. One application may close a socket or terminate, followed in time by another application receiving on the same port. This later application may then receive packets intended for the first application that were delayed in the network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当应用程序关闭TCP、SCTP或DCCP套接字时，需要接收主机上的传输协议来保持时间等待状态。这可以防止来自关闭连接实例的延迟数据包错误地与稍后的连接实例关联，后者恰好重用相同的IP地址和端口对。UDP协议没有实现这种机制。因此，基于UDP的应用程序需要对重新排序和延迟具有鲁棒性。一个应用程序可能会关闭套接字或终止，然后另一个应用程序会在同一端口上及时接收。随后，该稍后的应用可接收在网络中延迟的针对第一应用的分组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Using UDP Ports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 使用UDP端口
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rules and procedures for the management of the &#34;Service Name and Transport Protocol Port Number Registry&#34; are specified in [RFC6335]. Recommendations for use of UDP ports are provided in [RFC7605].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6335]中规定了管理“服务名称和传输协议端口号注册表”的规则和程序。[RFC7605]中提供了使用UDP端口的建议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP sender SHOULD NOT use a source port value of zero. A source port number that cannot be easily determined from the address or payload type provides protection at the receiver from data injection attacks by off-path devices. A UDP receiver SHOULD NOT bind to port zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP发送方不应使用零的源端口值。无法根据地址或有效负载类型轻松确定的源端口号可在接收器处提供保护，以防非路径设备的数据注入攻击。UDP接收器不应绑定到端口零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications SHOULD implement receiver port and address checks at the application layer or explicitly request that the operating system filter the received packets to prevent receiving packets with an arbitrary port. This measure is designed to provide additional protection from data injection attacks from an off-path source (where the port values may not be known).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序应在应用程序层执行接收器端口和地址检查，或明确请求操作系统过滤接收到的数据包，以防止接收到具有任意端口的数据包。此措施旨在提供额外的保护，防止来自非路径源（端口值可能未知）的数据注入攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications SHOULD provide a check that protects from off-path data injection, avoiding an application receiving packets that were created by an unauthorized third party. TCP stacks commonly use a randomized source port to provide this protection [RFC6056]; UDP applications should follow the same technique. Middleboxes and end systems often make assumptions about the system ports or user ports; hence, it is recommended to use randomized ports in the Dynamic and/ or Private Port range. Setting a &#34;randomized&#34; source port also provides greater assurance that reported ICMP errors originate from network systems on the path used by a particular flow. Some UDP applications choose to use a predetermined value for the source port (including some multicast applications), these applications need to therefore employ a different technique. Protection from off-path data attacks can also be provided by randomizing the initial value of another protocol field within the datagram payload, and checking the validity of this field at the receiver (e.g., RTP has random initial sequence number and random media timestamp offsets [RFC3550]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序应提供一种检查，防止路径外数据注入，避免应用程序接收由未经授权的第三方创建的数据包。TCP堆栈通常使用随机源端口来提供这种保护[RFC6056]；UDP应用程序应遵循相同的技术。中间盒和终端系统通常对系统端口或用户端口进行假设；因此，建议在动态和/或专用端口范围内使用随机端口。设置“随机”源端口还可以更好地确保报告的ICMP错误源自特定流所使用路径上的网络系统。一些UDP应用程序选择使用源端口的预定值（包括一些多播应用程序），因此这些应用程序需要采用不同的技术。还可以通过随机化数据报有效载荷内另一协议字段的初始值，并在接收器处检查该字段的有效性（例如，RTP具有随机初始序列号和随机媒体时间戳偏移[RFC3550]），来提供对非路径数据攻击的保护。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When using multicast, IP routers perform a reverse-path forwarding (RPF) check for each multicast packet. This provides protection from off-path data injection, restricting opportunities to forge a packet&#39;s source address. When a receiver joins a multicast group and filters based on the source address the filter verifies the sender&#39;s IP address. This is always the case when using an SSM {S,G} channel.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用多播时，IP路由器对每个多播数据包执行反向路径转发（RPF）检查。这提供了对非路径数据注入的保护，限制了伪造数据包源地址的机会。当接收方加入多播组并根据源地址进行筛选时，筛选器将验证发送方的IP地址。使用SSM{S，G}通道时总是这样。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. Usage of UDP for Source Port Entropy and the IPv6 Flow Label
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. UDP用于源端口熵和IPv6流标签
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some applications use the UDP datagram header as a source of entropy for network devices that implement ECMP [RFC6438]. A UDP tunnel application targeting this usage encapsulates an inner packet using UDP, where the UDP source port value forms a part of the entropy that can be used to balance forwarding of network traffic by the devices that use ECMP. A sending tunnel endpoint selects a source port value in the UDP datagram header that is computed from the inner flow information (e.g., the encapsulated packet headers). To provide sufficient entropy, the sending tunnel endpoint maps the encapsulated traffic to one of a range of UDP source values. The value SHOULD be within the ephemeral port range, i.e., 49152 to 65535, where the high order two bits of the port are set to one. The available source port entropy of 14 bits (using the ephemeral port range) plus the outer IP addresses seems sufficient for entropy for most ECMP applications [ENCAP].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一些应用程序使用UDP数据报报头作为实现ECMP[RFC6438]的网络设备的熵源。针对此用途的UDP隧道应用程序使用UDP封装内部数据包，其中UDP源端口值构成熵的一部分，可用于平衡使用ECMP的设备对网络流量的转发。发送隧道端点选择UDP数据报报头中的源端口值，该值是根据内部流信息（例如，封装的数据包报头）计算的。为了提供足够的熵，发送隧道端点将封装的流量映射到UDP源值范围之一。该值应在临时端口范围内，即49152到65535，其中端口的高阶两位设置为1。14位的可用源端口熵（使用临时端口范围）加上外部IP地址似乎足以满足大多数ECMP应用程序的熵[ENCAP]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To avoid reordering within an IP flow, the same UDP source port value SHOULD be used for all packets assigned to an encapsulated flow (e.g., using a hash of the relevant headers). The entropy mapping for a flow MAY change over the lifetime of the encapsulated flow [ENCAP]. For instance, this could be changed as a Denial of Service (DOS) mitigation, or as a means to effect routing through the ECMP network. However, the source port selected for a flow SHOULD NOT change more than once in every thirty seconds (e.g., as in [RFC8086]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了避免在IP流中重新排序，应将相同的UDP源端口值用于分配给封装流的所有数据包（例如，使用相关头的散列）。流的熵映射可能在封装流[ENCAP]的生命周期内发生变化。例如，可以将其更改为拒绝服务（DOS）缓解措施，或作为通过ECMP网络实现路由的方法。但是，为流选择的源端口不应每30秒更改一次以上（例如，如[RFC8086]中所述）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of the source port field for entropy has several side effects that need to be considered, including:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将源端口字段用于熵有几个需要考虑的副作用，包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It can increase the probability of misdelivery of corrupted packets, which increases the need for checksum computation or an equivalent mechanism to protect other UDP applications from misdelivery errors Section 3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它会增加损坏数据包的误发概率，从而增加校验和计算或等效机制的需要，以保护其他UDP应用程序免受误发错误的影响（第3.4节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is expected to reduce the probability of successful middlebox traversal Section 3.5. This use of the source port field will often not be suitable for applications targeting deployment in the general Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 预计将降低第3.5节中成功穿越中间箱的概率。源端口字段的这种使用通常不适合于在通用Internet中部署的应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It can prevent the field being usable to protect from off-path attacks (described in Section 5.1). Designers therefore need to consider other mechanisms to provide equivalent protection (e.g., to restrict use to a controlled environment [RFC7510] Section 3.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它可以防止字段可用于防止路径外攻击（如第5.1节所述）。因此，设计者需要考虑其他机制来提供等效的保护（例如，限制使用到受控环境[RCFC710]节3.6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The UDP source port number field has also been leveraged to produce entropy with IPv6. However, in the case of IPv6, the &#34;flow label&#34; [RFC6437] may also alternatively be used to provide entropy for load balancing [RFC6438]. This use of the flow label for load balancing is consistent with the definition of the field, although further clarity was needed to ensure the field can be consistently used for this purpose. Therefore, an updated IPv6 flow label [RFC6437] and ECMP routing [RFC6438] usage was specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP源端口号字段也被用于在IPv6中生成熵。然而，在IPv6的情况下，“流标签”[RFC6437]也可替代地用于为负载平衡[RFC6438]提供熵。使用流标签进行负载平衡与字段的定义一致，尽管需要进一步澄清，以确保字段可以一致地用于此目的。因此，指定了更新的IPv6流标签[RFC6437]和ECMP路由[RFC6438]用法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To ensure future opportunities to use the flow label, UDP applications SHOULD set the flow label field, even when an entropy value is also set in the source port field (e.g., An IPv6 tunnel endpoint could copy the source port flow entropy value to the IPv6 flow label field [RFC8086]). Router vendors are encouraged to start using the IPv6 flow label as a part of the flow hash, providing support for IP-level ECMP without requiring use of UDP. The end-to-end use of flow labels for load balancing is a long-term solution. Even if the usage of the flow label has been clarified, there will be a transition time before a significant proportion of endpoints start to assign a good quality flow label to the flows that they originate. The use of load balancing using the transport header fields will likely continue until widespread deployment is finally achieved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为确保将来有机会使用流标签，UDP应用程序应设置流标签字段，即使源端口字段中也设置了熵值（例如，IPv6隧道端点可以将源端口流熵值复制到IPv6流标签字段[RFC8086]）。鼓励路由器供应商开始使用IPv6流标签作为流哈希的一部分，提供对IP级ECMP的支持，而无需使用UDP。端到端使用流标签进行负载平衡是一个长期的解决方案。即使已经澄清了流标签的使用，在相当大比例的端点开始为其发起的流分配高质量的流标签之前，也会有一段过渡时间。在最终实现广泛部署之前，可能会继续使用使用传输头字段的负载平衡。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. Applications Using Multiple UDP Ports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. 使用多个UDP端口的应用程序
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single application may exchange several types of data. In some cases, this may require multiple UDP flows (e.g., multiple sets of flows, identified by different five-tuples). [RFC6335] recommends application developers not to apply to IANA to be assigned multiple well-known ports (user or system). It does not discuss the implications of using multiple flows with the same well-known port or pairs of dynamic ports (e.g., identified by a service name or signaling protocol).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单个应用程序可以交换多种类型的数据。在某些情况下，这可能需要多个UDP流（例如，多组流，由不同的五个元组标识）。[RFC6335]建议应用程序开发人员不要向IANA申请分配多个已知端口（用户或系统）。本节未讨论使用具有相同已知端口或成对动态端口（例如，由服务名称或信令协议标识）的多个流的含义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of multiple flows can affect the network in several ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用多个流可能会以多种方式影响网络：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Starting a series of successive connections can increase the number of state bindings in middleboxes (e.g., NAPT or Firewall) along the network path. UDP-based middlebox traversal usually relies on timeouts to remove old state, since middleboxes are unaware when a particular flow ceases to be used by an application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 启动一系列连续连接可以增加网络路径上中间盒（如NAPT或防火墙）中的状态绑定数量。基于UDP的中间盒遍历通常依赖超时来删除旧状态，因为当应用程序停止使用特定流时，中间盒不知道。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Using several flows at the same time may result in seeing different network characteristics for each flow. It cannot be assumed both follow the same path (e.g., when ECMP is used, traffic is intentionally hashed onto different parallel paths based on the port numbers).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 同时使用多个流可能会导致看到每个流的不同网络特性。不能假设两者都遵循相同的路径（例如，当使用ECMP时，流量会根据端口号故意散列到不同的并行路径上）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Using several flows can also increase the occupancy of a binding or lookup table in a middlebox (e.g., NAPT or Firewall), which may cause the device to change the way it manages the flow state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 使用多个流还可以增加中间盒（例如NAPT或防火墙）中绑定或查找表的占用率，这可能会导致设备更改其管理流状态的方式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Further, using excessive numbers of flows can degrade the ability of a unicast congestion control to react to congestion events, unless the congestion state is shared between all flows in a session. A receiver-driven multicast congestion control requires the sending application to distribute its data over a set of IP multicast groups, each receiver is therefore expected to receive data from a modest number of simultaneously active UDP ports.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 此外，使用过多的流可能会降低单播拥塞控制对拥塞事件作出反应的能力，除非在会话中的所有流之间共享拥塞状态。接收器驱动的多播拥塞控制要求发送应用程序将其数据分布在一组IP多播组上，因此每个接收器都希望从少量同时活动的UDP端口接收数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Therefore, applications MUST NOT assume consistent behavior of middleboxes when multiple UDP flows are used; many devices respond differently as the number of used ports increases. Using multiple flows with different QoS requirements requires applications to verify that the expected performance is achieved using each individual flow (five-tuple), see Section 3.1.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因此，当使用多个UDP流时，应用程序不得假设中间盒的行为一致；随着所用端口数量的增加，许多设备的响应也不同。使用具有不同QoS要求的多个流需要应用程序验证使用每个流（五元组）是否达到预期性能，请参见第3.1.9节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ICMP Guidelines
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. ICMP指南
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications can utilize information about ICMP error messages that the UDP layer passes up for a variety of purposes [RFC1122]. Applications SHOULD appropriately validate the payload of ICMP messages to ensure these are received in response to transmitted traffic (i.e., a reported error condition that corresponds to a UDP datagram actually sent by the application). This requires context, such as local state about communication instances to each destination, that although readily available in connection-oriented transport protocols is not always maintained by UDP-based applications. Note that not all platforms have the necessary APIs to support this validation, and some platforms already perform this validation internally before passing ICMP information to the application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序可以利用UDP层出于各种目的向上传递的有关ICMP错误消息的信息[RFC1122]。应用程序应适当验证ICMP消息的有效负载，以确保这些消息是响应传输的流量而接收的（即，与应用程序实际发送的UDP数据报相对应的报告错误情况）。这需要上下文，例如关于到每个目的地的通信实例的本地状态，尽管在面向连接的传输协议中随时可用，但基于UDP的应用程序并不总是维护这些上下文。请注意，并非所有平台都有必要的API来支持此验证，而且一些平台在将ICMP信息传递给应用程序之前已经在内部执行此验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any application response to ICMP error messages SHOULD be robust to temporary routing failures (sometimes called &#34;soft errors&#34;), e.g., transient ICMP &#34;unreachable&#34; messages ought to not normally cause a communication abort.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对ICMP错误消息的任何应用程序响应都应该对临时路由故障（有时称为“软错误”）具有鲁棒性，例如，瞬态ICMP“不可访问”消息通常不会导致通信中断。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMP messages are being increasingly filtered by middleboxes. A UDP application therefore SHOULD NOT rely on their delivery for correct and safe operation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICMP消息正越来越多地通过中间盒进行过滤。因此，UDP应用程序不应依赖它们的传递来实现正确和安全的操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP does not provide communications security. Applications that need to protect their communications against eavesdropping, tampering, or message forgery SHOULD employ end-to-end security services provided by other IETF protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP不提供通信安全。需要保护其通信免受窃听、篡改或消息伪造的应用程序应采用其他IETF协议提供的端到端安全服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP applications SHOULD provide protection from off-path data injection attacks using a randomized source port or equivalent technique (see Section 5.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP应用程序应使用随机源端口或等效技术（见第5.1节）提供保护，以防止非路径数据注入攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that respond to short requests with potentially large responses are a potential vector for amplification attacks, and SHOULD take steps to minimize their potential for being abused as part of a DoS attack. That could mean authenticating the sender before responding; noting that the source IP address of a request is not a useful authenticator, because it can easily be spoofed. Or it may mean otherwise limiting the cases where short unauthenticated requests produce large responses. Applications MAY also want to offer ways to limit the number of requests they respond to in a time interval, in order to cap the bandwidth they consume.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
响应短请求且响应可能较大的应用程序是放大攻击的潜在载体，应采取措施将其作为DoS攻击的一部分被滥用的可能性降至最低。这可能意味着在响应之前对发送者进行身份验证；请注意，请求的源IP地址不是有用的身份验证器，因为它很容易被欺骗。或者它可能意味着以其他方式限制未经验证的短请求产生大响应的情况。应用程序可能还希望提供一些方法来限制它们在一个时间间隔内响应的请求数量，以限制它们所消耗的带宽。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One option for securing UDP communications is with IPsec [RFC4301], which can provide authentication for flows of IP packets through the Authentication Header (AH) [RFC4302] and encryption and/or authentication through the Encapsulating Security Payload (ESP) [RFC4303]. Applications use the Internet Key Exchange (IKE) [RFC7296] to configure IPsec for their sessions. Depending on how IPsec is configured for a flow, it can authenticate or encrypt the UDP headers as well as UDP payloads. If an application only requires authentication, ESP with no encryption but with authentication is often a better option than AH, because ESP can operate across middleboxes. An application that uses IPsec requires the support of an operating system that implements the IPsec protocol suite, and the network path must permit IKE and IPsec traffic. This may become more common with IPv6 deployments [RFC6092].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保护UDP通信安全的一个选项是IPsec[RFC4301]，它可以通过身份验证头（AH）[RFC4302]为IP数据包流提供身份验证，并通过封装安全负载（ESP）[RFC4303]提供加密和/或身份验证。应用程序使用Internet密钥交换（IKE）[RFC7296]为其会话配置IPsec。根据为流配置IPsec的方式，它可以对UDP报头以及UDP有效负载进行身份验证或加密。如果一个应用程序只需要身份验证，ESP不需要加密但需要身份验证通常是比AH更好的选择，因为ESP可以跨中间盒运行。使用IPsec的应用程序需要实现IPsec协议套件的操作系统的支持，并且网络路径必须允许IKE和IPsec通信。这可能在IPv6部署中变得更常见[RFC6092]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although it is possible to use IPsec to secure UDP communications, not all operating systems support IPsec or allow applications to easily configure it for their flows. A second option for securing UDP communications is through Datagram Transport Layer Security (DTLS) [RFC6347][RFC7525]. DTLS provides communication privacy by encrypting UDP payloads. It does not protect the UDP headers. Applications can implement DTLS without relying on support from the operating system.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管可以使用IPsec来保护UDP通信，但并非所有操作系统都支持IPsec或允许应用程序轻松地为其流配置IPsec。保护UDP通信的第二个选项是通过数据报传输层安全性（DTLS）[RFC6347][RFC7525]。DTLS通过加密UDP有效负载提供通信隐私。它不保护UDP报头。应用程序可以在不依赖操作系统支持的情况下实现DTL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many other options for authenticating or encrypting UDP payloads exist. For example, the GSS-API security framework [RFC2743] or Cryptographic Message Syntax (CMS) [RFC5652] could be used to protect UDP payloads. There exist a number of security options for RTP [RFC3550] over UDP, especially to accomplish key-management, see [RFC7201]. These options covers many usages, including point-to-point, centralized group communication as well as multicast. In some applications, a better solution is to protect larger stand-alone objects, such as files or messages, instead of individual UDP payloads. In these situations, CMS [RFC5652], S/MIME [RFC5751] or OpenPGP [RFC4880] could be used. In addition, there are many non-IETF protocols in this area.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在许多其他用于验证或加密UDP有效负载的选项。例如，GSS-API安全框架[RFC2743]或加密消息语法（CMS）[RFC5652]可用于保护UDP有效负载。UDP上的RTP[RFC3550]有许多安全选项，特别是要完成密钥管理，请参阅[RFC7201]。这些选项涵盖了许多用途，包括点对点、集中组通信以及多播。在某些应用程序中，更好的解决方案是保护较大的独立对象，例如文件或消息，而不是单个UDP有效负载。在这些情况下，可以使用CMS[RFC5652]、S/MIME[RFC5751]或OpenPGP[RFC4880]。此外，在这一领域还有许多非IETF协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like congestion control mechanisms, security mechanisms are difficult to design and implement correctly. It is hence RECOMMENDED that applications employ well-known standard security mechanisms such as DTLS or IPsec, rather than inventing their own.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与拥塞控制机制一样，安全机制也难以正确设计和实现。因此，建议应用程序采用众所周知的标准安全机制，如DTL或IPsec，而不是发明自己的安全机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Generalized TTL Security Mechanism (GTSM) [RFC5082] may be used with UDP applications when the intended endpoint is on the same link as the sender. This lightweight mechanism allows a receiver to filter unwanted packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通用TTL安全机制（GTSM）[RFC5082]可在目标端点与发送方位于同一链路上时与UDP应用程序一起使用。这种轻量级机制允许接收器过滤不需要的数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In terms of congestion control, [RFC2309] and [RFC2914] discuss the dangers of congestion-unresponsive flows to the Internet. [RFC8084] describes methods that can be used to set a performance envelope that can assist in preventing congestion collapse in the absence of congestion control or when the congestion control fails to react to congestion events. This document provides guidelines to designers of UDP-based applications to congestion-control their transmissions, and does not raise any additional security concerns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在拥塞控制方面，[RFC2309]和[RFC2914]讨论了拥塞对互联网无响应流的危险。[RFC8084]描述了可用于设置性能包络线的方法，该性能包络线有助于在没有拥塞控制或拥塞控制无法对拥塞事件做出反应时防止拥塞崩溃。本文档为基于UDP的应用程序的设计者提供了拥塞控制传输的指南，并且不会引起任何额外的安全问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some network operators have experienced surges of UDP attack traffic that are multiple orders of magnitude above the baseline traffic rate for UDP. This can motivate operators to limit the data rate or packet rate of UDP traffic. This may in turn limit the throughput that an application can achieve using UDP and could also result in higher packet loss for UDP traffic that would not be experienced if other transport protocols had been used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一些网络运营商经历了UDP攻击流量的激增，比UDP的基线流量率高出多个数量级。这可以激励运营商限制UDP通信的数据速率或数据包速率。这反过来可能会限制应用程序使用UDP可以实现的吞吐量，并且还可能导致UDP流量的更高数据包丢失，这在使用其他传输协议时是不会发生的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP application with a long-lived association between the sender and receiver, ought to be designed so that the sender periodically checks that the receiver still wants (&#34;consents&#34;) to receive traffic and need to be designed to stop if there is no explicit confirmation of this [RFC7675]. Applications that require communications in two directions to implement protocol functions (such as reliability or
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送方和接收方之间存在长期关联的UDP应用程序的设计应确保发送方定期检查接收方是否仍希望（“同意”）接收流量，并且如果没有明确确认，则需要设计为停止[RFC7675]。需要在两个方向上进行通信以实现协议功能的应用程序（如可靠性或可靠性）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
congestion control) will need to independently check both directions of communication, and may have to exchange keep-alive messages to traverse middleboxes (see Section 3.5).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拥塞控制）将需要独立地检查通信的两个方向，并且可能必须交换保持活动的消息以穿越中间盒（参见第3.5节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Summary
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 总结
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section summarizes the key guidelines made in Sections 3 - 6 in a tabular format (Table 1) for easy referencing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节以表格形式（表1）总结了第3-6节中制定的主要指南，以便于参考。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +---------------------------------------------------------+---------+
   | Recommendation                                          | Section |
   +---------------------------------------------------------+---------+
   | MUST tolerate a wide range of Internet path conditions  | 3       |
   | SHOULD use a full-featured transport (e.g., TCP)        |         |
   |                                                         |         |
   | SHOULD control rate of transmission                     | 3.1     |
   | SHOULD perform congestion control over all traffic      |         |
   |                                                         |         |
   | for bulk transfers,                                     | 3.1.2   |
   | SHOULD consider implementing TFRC                       |         |
   | else, SHOULD in other ways use bandwidth similar to TCP |         |
   |                                                         |         |
   | for non-bulk transfers,                                 | 3.1.3   |
   | SHOULD measure RTT and transmit max. 1 datagram/RTT     | 3.1.1   |
   | else, SHOULD send at most 1 datagram every 3 seconds    |         |
   | SHOULD back-off retransmission timers following loss    |         |
   |                                                         |         |
   | SHOULD provide mechanisms to regulate the bursts of     | 3.1.6   |
   | transmission                                            |         |
   |                                                         |         |
   | MAY implement ECN; a specific set of application        | 3.1.7   |
   | mechanisms are REQUIRED if ECN is used.                 |         |
   |                                                         |         |
   | for DiffServ, SHOULD NOT rely on implementation of PHBs | 3.1.8   |
   |                                                         |         |
   | for QoS-enabled paths, MAY choose not to use CC         | 3.1.9   |
   |                                                         |         |
   | SHOULD NOT rely solely on QoS for their capacity        | 3.1.10  |
   | non-CC controlled flows SHOULD implement a transport    |         |
   | circuit breaker                                         |         |
   | MAY implement a circuit breaker for other applications  |         |
   |                                                         |         |
   | for tunnels carrying IP traffic,                        | 3.1.11  |
   | SHOULD NOT perform congestion control                   |         |
   | MUST correctly process the IP ECN field                 |         |
   |                                                         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +---------------------------------------------------------+---------+
   | Recommendation                                          | Section |
   +---------------------------------------------------------+---------+
   | MUST tolerate a wide range of Internet path conditions  | 3       |
   | SHOULD use a full-featured transport (e.g., TCP)        |         |
   |                                                         |         |
   | SHOULD control rate of transmission                     | 3.1     |
   | SHOULD perform congestion control over all traffic      |         |
   |                                                         |         |
   | for bulk transfers,                                     | 3.1.2   |
   | SHOULD consider implementing TFRC                       |         |
   | else, SHOULD in other ways use bandwidth similar to TCP |         |
   |                                                         |         |
   | for non-bulk transfers,                                 | 3.1.3   |
   | SHOULD measure RTT and transmit max. 1 datagram/RTT     | 3.1.1   |
   | else, SHOULD send at most 1 datagram every 3 seconds    |         |
   | SHOULD back-off retransmission timers following loss    |         |
   |                                                         |         |
   | SHOULD provide mechanisms to regulate the bursts of     | 3.1.6   |
   | transmission                                            |         |
   |                                                         |         |
   | MAY implement ECN; a specific set of application        | 3.1.7   |
   | mechanisms are REQUIRED if ECN is used.                 |         |
   |                                                         |         |
   | for DiffServ, SHOULD NOT rely on implementation of PHBs | 3.1.8   |
   |                                                         |         |
   | for QoS-enabled paths, MAY choose not to use CC         | 3.1.9   |
   |                                                         |         |
   | SHOULD NOT rely solely on QoS for their capacity        | 3.1.10  |
   | non-CC controlled flows SHOULD implement a transport    |         |
   | circuit breaker                                         |         |
   | MAY implement a circuit breaker for other applications  |         |
   |                                                         |         |
   | for tunnels carrying IP traffic,                        | 3.1.11  |
   | SHOULD NOT perform congestion control                   |         |
   | MUST correctly process the IP ECN field                 |         |
   |                                                         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | for non-IP tunnels or rate not determined by traffic,   |         |
   | SHOULD perform CC or use circuit breaker                | 3.1.11  |
   | SHOULD restrict types of traffic transported by the     |         |
   | tunnel                                                  |         |
   |                                                         |         |
   | SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |
   | SHOULD discover PMTU or send datagrams &lt; minimum PMTU;  |         |
   | Specific application mechanisms are REQUIRED if PLPMTUD |         |
   | is used.                                                |         |
   |                                                         |         |
   | SHOULD handle datagram loss, duplication, reordering    | 3.3     |
   | SHOULD be robust to delivery delays up to 2 minutes     |         |
   |                                                         |         |
   | SHOULD enable IPv4 UDP checksum                         | 3.4     |
   | SHOULD enable IPv6 UDP checksum; Specific application   | 3.4.1   |
   | mechanisms are REQUIRED if a zero IPv6 UDP checksum is  |         |
   | used.                                                   |         |
   |                                                         |         |
   | SHOULD provide protection from off-path attacks         | 5.1     |
   | else, MAY use UDP-Lite with suitable checksum coverage  | 3.4.2   |
   |                                                         |         |
   | SHOULD NOT always send middlebox keep-alive messages    | 3.5     |
   | MAY use keep-alives when needed (min. interval 15 sec)  |         |
   |                                                         |         |
   | Applications specified for use in limited use (or       | 3.6     |
   | controlled environments) SHOULD identify equivalent     |         |
   | mechanisms and describe their use case.                 |         |
   |                                                         |         |
   | Bulk-multicast apps SHOULD implement congestion control | 4.1.1   |
   |                                                         |         |
   | Low volume multicast apps SHOULD implement congestion   | 4.1.2   |
   | control                                                 |         |
   |                                                         |         |
   | Multicast apps SHOULD use a safe PMTU                   | 4.2     |
   |                                                         |         |
   | SHOULD avoid using multiple ports                       | 5.1.2   |
   | MUST check received IP source address                   |         |
   |                                                         |         |
   | SHOULD validate payload in ICMP messages                | 5.2     |
   |                                                         |         |
   | SHOULD use a randomized source port or equivalent       | 6       |
   | technique, and, for client/server applications, SHOULD  |         |
   | send responses from source address matching request     |         |
   | 5.1                                                     |         |
   | SHOULD use standard IETF security protocols when needed | 6       |
   +---------------------------------------------------------+---------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   | for non-IP tunnels or rate not determined by traffic,   |         |
   | SHOULD perform CC or use circuit breaker                | 3.1.11  |
   | SHOULD restrict types of traffic transported by the     |         |
   | tunnel                                                  |         |
   |                                                         |         |
   | SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |
   | SHOULD discover PMTU or send datagrams &lt; minimum PMTU;  |         |
   | Specific application mechanisms are REQUIRED if PLPMTUD |         |
   | is used.                                                |         |
   |                                                         |         |
   | SHOULD handle datagram loss, duplication, reordering    | 3.3     |
   | SHOULD be robust to delivery delays up to 2 minutes     |         |
   |                                                         |         |
   | SHOULD enable IPv4 UDP checksum                         | 3.4     |
   | SHOULD enable IPv6 UDP checksum; Specific application   | 3.4.1   |
   | mechanisms are REQUIRED if a zero IPv6 UDP checksum is  |         |
   | used.                                                   |         |
   |                                                         |         |
   | SHOULD provide protection from off-path attacks         | 5.1     |
   | else, MAY use UDP-Lite with suitable checksum coverage  | 3.4.2   |
   |                                                         |         |
   | SHOULD NOT always send middlebox keep-alive messages    | 3.5     |
   | MAY use keep-alives when needed (min. interval 15 sec)  |         |
   |                                                         |         |
   | Applications specified for use in limited use (or       | 3.6     |
   | controlled environments) SHOULD identify equivalent     |         |
   | mechanisms and describe their use case.                 |         |
   |                                                         |         |
   | Bulk-multicast apps SHOULD implement congestion control | 4.1.1   |
   |                                                         |         |
   | Low volume multicast apps SHOULD implement congestion   | 4.1.2   |
   | control                                                 |         |
   |                                                         |         |
   | Multicast apps SHOULD use a safe PMTU                   | 4.2     |
   |                                                         |         |
   | SHOULD avoid using multiple ports                       | 5.1.2   |
   | MUST check received IP source address                   |         |
   |                                                         |         |
   | SHOULD validate payload in ICMP messages                | 5.2     |
   |                                                         |         |
   | SHOULD use a randomized source port or equivalent       | 6       |
   | technique, and, for client/server applications, SHOULD  |         |
   | send responses from source address matching request     |         |
   | 5.1                                                     |         |
   | SHOULD use standard IETF security protocols when needed | 6       |
   +---------------------------------------------------------+---------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
Table 1: Summary of Recommendations
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-20">
表1：建议摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC768] Postel, J., &#34;User Datagram Protocol&#34;, STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, &lt;http://www.rfc-editor.org/info/rfc768&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC768]Postel，J.，“用户数据报协议”，STD 6，RFC 768，DOI 10.17487/RFC0768，1980年8月&lt;http://www.rfc-editor.org/info/rfc768&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793] Postel, J., &#34;Transmission Control Protocol&#34;, STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, &lt;http://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC793]Postel，J.，“传输控制协议”，标准7，RFC 793，DOI 10.17487/RFC0793，1981年9月&lt;http://www.rfc-editor.org/info/rfc793&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., Ed., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, &lt;http://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]Braden，R.，Ed.“互联网主机的要求-通信层”，STD 3，RFC 1122，DOI 10.17487/RFC1122，1989年10月&lt;http://www.rfc-editor.org/info/rfc1122&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191] Mogul, J. and S. Deering, &#34;Path MTU discovery&#34;, RFC 1191, DOI 10.17487/RFC1191, November 1990, &lt;http://www.rfc-editor.org/info/rfc1191&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1191]Mogul，J.和S.Deering，“MTU发现路径”，RFC 1191，DOI 10.17487/RFC1191，1990年11月&lt;http://www.rfc-editor.org/info/rfc1191&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1981] McCann, J., Deering, S., and J. Mogul, &#34;Path MTU Discovery for IP version 6&#34;, RFC 1981, DOI 10.17487/RFC1981, August 1996, &lt;http://www.rfc-editor.org/info/rfc1981&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1981]McCann，J.，Deering，S.，和J.Mogul，“IP版本6的路径MTU发现”，RFC 1981，DOI 10.17487/RFC19811996年8月&lt;http://www.rfc-editor.org/info/rfc1981&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, &lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，DOI 10.17487/RFC2119，1997年3月&lt;http://www.rfc-editor.org/info/rfc2119&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, DOI 10.17487/RFC2460, December 1998, &lt;http://www.rfc-editor.org/info/rfc2460&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2460]Deering，S.和R.Hinden，“互联网协议，第6版（IPv6）规范”，RFC 2460，DOI 10.17487/RFC2460，1998年12月&lt;http://www.rfc-editor.org/info/rfc2460&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914] Floyd, S., &#34;Congestion Control Principles&#34;, BCP 41, RFC 2914, DOI 10.17487/RFC2914, September 2000, &lt;http://www.rfc-editor.org/info/rfc2914&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2914]Floyd，S.，“拥塞控制原则”，BCP 41，RFC 2914，DOI 10.17487/RFC2914，2000年9月&lt;http://www.rfc-editor.org/info/rfc2914&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., Ed., and G. Fairhurst, Ed., &#34;The Lightweight User Datagram Protocol (UDP-Lite)&#34;, RFC 3828, DOI 10.17487/RFC3828, July 2004, &lt;http://www.rfc-editor.org/info/rfc3828&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3828]Larzon，L-A.，Degermark，M.，Pink，S.，Jonsson，L-E.，Ed.，和G.Fairhurst，Ed.，“轻量级用户数据报协议（UDP Lite）”，RFC 3828，DOI 10.17487/RFC3828，2004年7月&lt;http://www.rfc-editor.org/info/rfc3828&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787] Audet, F., Ed. and C. Jennings, &#34;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP&#34;, BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007, &lt;http://www.rfc-editor.org/info/rfc4787&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787]Audet，F.，Ed.和C.Jennings，“单播UDP的网络地址转换（NAT）行为要求”，BCP 127，RFC 4787，DOI 10.17487/RFC4787，2007年1月&lt;http://www.rfc-editor.org/info/rfc4787&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821] Mathis, M. and J. Heffner, &#34;Packetization Layer Path MTU Discovery&#34;, RFC 4821, DOI 10.17487/RFC4821, March 2007, &lt;http://www.rfc-editor.org/info/rfc4821&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4821]Mathis，M.和J.Heffner，“打包层路径MTU发现”，RFC 4821，DOI 10.17487/RFC4821，2007年3月&lt;http://www.rfc-editor.org/info/rfc4821&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, &#34;TCP Friendly Rate Control (TFRC): Protocol Specification&#34;, RFC 5348, DOI 10.17487/RFC5348, September 2008, &lt;http://www.rfc-editor.org/info/rfc5348&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5348]Floyd，S.，Handley，M.，Padhye，J.，和J.Widmer，“TCP友好速率控制（TFRC）：协议规范”，RFC 5348，DOI 10.17487/RFC5348，2008年9月&lt;http://www.rfc-editor.org/info/rfc5348&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] Eggert, L. and G. Fairhurst, &#34;Unicast UDP Usage Guidelines for Application Designers&#34;, BCP 145, RFC 5405, DOI 10.17487/RFC5405, November 2008, &lt;http://www.rfc-editor.org/info/rfc5405&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405]Eggert，L.和G.Fairhurst，“应用程序设计者的单播UDP使用指南”，BCP 145，RFC 5405，DOI 10.17487/RFC5405，2008年11月&lt;http://www.rfc-editor.org/info/rfc5405&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6040] Briscoe, B., &#34;Tunnelling of Explicit Congestion Notification&#34;, RFC 6040, DOI 10.17487/RFC6040, November 2010, &lt;http://www.rfc-editor.org/info/rfc6040&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6040]Briscoe，B.，“明确拥塞通知的隧道挖掘”，RFC 6040，DOI 10.17487/RFC6040，2010年11月&lt;http://www.rfc-editor.org/info/rfc6040&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, DOI 10.17487/RFC6298, June 2011, &lt;http://www.rfc-editor.org/info/rfc6298&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298]Paxson，V.，Allman，M.，Chu，J.，和M.Sargent，“计算TCP的重传计时器”，RFC 6298，DOI 10.17487/RFC62982011年6月&lt;http://www.rfc-editor.org/info/rfc6298&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084] Fairhurst, G., &#34;Network Transport Circuit Breakers&#34;, BCP 208, RFC 8084, DOI 10.17487/RFC8084, March 2017, &lt;http://www.rfc-editor.org/info/rfc8084&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8084]Fairhurst，G.，“网络传输断路器”，BCP 208，RFC 8084，DOI 10.17487/RFC8084，2017年3月&lt;http://www.rfc-editor.org/info/rfc8084&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALLMAN] Allman, M. and E. Blanton, &#34;Notes on burst mitigation for transport protocols&#34;, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ALLMAN]ALLMAN，M.和E.Blanton，“关于传输协议突发缓解的说明”，2005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BEHAVE-APP] Ford, B., &#34;Application Design Guidelines for Traversal through Network Address Translators&#34;, Work in Progress, draft-ford-behave-app-05, March 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[BEHAVE-APP]Ford，B.，“通过网络地址转换器进行遍历的应用程序设计指南”，正在进行的工作，草稿-Ford-BEHAVE-APP-05，2007年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ENCAP] Nordmark, E., Ed., Tian, A., Gross, J., Hudson, J., Kreeger, L., Garg, P., Thaler, P., and T. Herbert, &#34;Encapsulation Considerations&#34;, Work in Progress, draft-ietf-rtgwg-dt-encap-02, October 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ENCAP]Nordmark，E.，Ed.，Tian，A.，Gross，J.，Hudson，J.，Kreeger，L.，Garg，P.，Thaler，P.，和T.Herbert，“封装注意事项”，在建工程，草案-ietf-rtgwg-dt-ENCAP-02，2016年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FABER] Faber, T., Touch, J., and W. Yue, &#34;The TIME-WAIT State in TCP and Its Effect on Busy Servers&#34;, Proc. IEEE Infocom, March 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[FABER]FABER，T.，Touch，J.，和W.Yue，“TCP中的时间等待状态及其对繁忙服务器的影响”，Proc。IEEE信息网，1999年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INT-TUNNELS] Touch, J. and W. Townsley, &#34;IP Tunnels in the Internet Architecture&#34;, Work in Progress, draft-ietf-intarea-tunnels-03, July 2016.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[INT-TUNNELS]Touch，J.和W.Townsley，“互联网架构中的IP隧道”，正在进行的工作，草案-ietf-intarea-TUNNELS-032016年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POSIX] IEEE Std. 1003.1-2001, , &#34;Standard for Information Technology - Portable Operating System Interface (POSIX)&#34;, Open Group Technical Standard: Base Specifications Issue 6, ISO/IEC 9945:2002, December 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[POSIX]IEEE标准1003.1-2001，“信息技术标准-便携式操作系统接口（POSIX）”，开放组技术标准：基本规范第6版，ISO/IEC 9945:2002，2001年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC919] Mogul, J., &#34;Broadcasting Internet Datagrams&#34;, STD 5, RFC 919, DOI 10.17487/RFC0919, October 1984, &lt;http://www.rfc-editor.org/info/rfc919&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC919]Mogul，J.，“广播互联网数据报”，STD 5，RFC 919，DOI 10.17487/RFC0919，1984年10月&lt;http://www.rfc-editor.org/info/rfc919&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1112] Deering, S., &#34;Host extensions for IP multicasting&#34;, STD 5, RFC 1112, DOI 10.17487/RFC1112, August 1989, &lt;http://www.rfc-editor.org/info/rfc1112&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1112]Deering，S.，“IP多播的主机扩展”，STD 5，RFC 1112，DOI 10.17487/RFC1112，1989年8月&lt;http://www.rfc-editor.org/info/rfc1112&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1536] Kumar, A., Postel, J., Neuman, C., Danzig, P., and S. Miller, &#34;Common DNS Implementation Errors and Suggested Fixes&#34;, RFC 1536, DOI 10.17487/RFC1536, October 1993, &lt;http://www.rfc-editor.org/info/rfc1536&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1536]Kumar，A.，Postel，J.，Neuman，C.，Danzig，P.，和S.Miller，“常见DNS实现错误和建议修复”，RFC 1536，DOI 10.17487/RFC1536，1993年10月&lt;http://www.rfc-editor.org/info/rfc1536&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1546] Partridge, C., Mendez, T., and W. Milliken, &#34;Host Anycasting Service&#34;, RFC 1546, DOI 10.17487/RFC1546, November 1993, &lt;http://www.rfc-editor.org/info/rfc1546&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1546]帕特里奇，C.，门德斯，T.，和W.米利肯，“主持任意广播服务”，RFC 1546，DOI 10.17487/RFC1546，1993年11月&lt;http://www.rfc-editor.org/info/rfc1546&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, &#34;Recommendations on Queue Management and Congestion Avoidance in the Internet&#34;, RFC 2309, DOI 10.17487/RFC2309, April 1998, &lt;http://www.rfc-editor.org/info/rfc2309&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2309]Braden，B.，Clark，D.，Crowcroft，J.，Davie，B.，Deering，S.，Estrin，D.，Floyd，S.，Jacobson，V.，Minshall，G.，Partridge，C.，Peterson，L.，Ramakrishnan，K.，Shenker，S.，Wroclawski，J.，and L.Zhang，“关于互联网中队列管理和拥塞避免的建议”，RFC 2309，DOI 10.17487/RFC2309，1998年4月， &lt;http://www.rfc-editor.org/info/rfc2309&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2475] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, &#34;An Architecture for Differentiated Services&#34;, RFC 2475, DOI 10.17487/RFC2475, December 1998, &lt;http://www.rfc-editor.org/info/rfc2475&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2475]Blake，S.，Black，D.，Carlson，M.，Davies，E.，Wang，Z.，和W.Weiss，“差异化服务架构”，RFC 2475，DOI 10.17487/RFC2475，1998年12月&lt;http://www.rfc-editor.org/info/rfc2475&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2675] Borman, D., Deering, S., and R. Hinden, &#34;IPv6 Jumbograms&#34;, RFC 2675, DOI 10.17487/RFC2675, August 1999, &lt;http://www.rfc-editor.org/info/rfc2675&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2675]Borman，D.，Deering，S.和R.Hinden，“IPv6巨型程序”，RFC 2675，DOI 10.17487/RFC2675，1999年8月&lt;http://www.rfc-editor.org/info/rfc2675&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743] Linn, J., &#34;Generic Security Service Application Program Interface Version 2, Update 1&#34;, RFC 2743, DOI 10.17487/RFC2743, January 2000, &lt;http://www.rfc-editor.org/info/rfc2743&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2743]Linn，J.，“通用安全服务应用程序接口版本2，更新1”，RFC 2743，DOI 10.17487/RFC2743，2000年1月&lt;http://www.rfc-editor.org/info/rfc2743&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2887] Handley, M., Floyd, S., Whetten, B., Kermode, R., Vicisano, L., and M. Luby, &#34;The Reliable Multicast Design Space for Bulk Data Transfer&#34;, RFC 2887, DOI 10.17487/RFC2887, August 2000, &lt;http://www.rfc-editor.org/info/rfc2887&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2887]Handley，M.，Floyd，S.，Whetten，B.，Kermode，R.，Vicisano，L.，和M.Luby，“批量数据传输的可靠多播设计空间”，RFC 2887，DOI 10.17487/RFC2887，2000年8月&lt;http://www.rfc-editor.org/info/rfc2887&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2983] Black, D., &#34;Differentiated Services and Tunnels&#34;, RFC 2983, DOI 10.17487/RFC2983, October 2000, &lt;http://www.rfc-editor.org/info/rfc2983&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2983]Black，D.，“差异化服务和隧道”，RFC 2983，DOI 10.17487/RFC2983，2000年10月&lt;http://www.rfc-editor.org/info/rfc2983&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3048] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &#34;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer&#34;, RFC 3048, DOI 10.17487/RFC3048, January 2001, &lt;http://www.rfc-editor.org/info/rfc3048&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3048]Whetten，B.，Vicisano，L.，Kermode，R.，Handley，M.，Floyd，S.，和M.Luby，“一对多批量数据传输的可靠多播传输构建块”，RFC 3048，DOI 10.17487/RFC3048，2001年1月&lt;http://www.rfc-editor.org/info/rfc3048&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124] Balakrishnan, H. and S. Seshan, &#34;The Congestion Manager&#34;, RFC 3124, DOI 10.17487/RFC3124, June 2001, &lt;http://www.rfc-editor.org/info/rfc3124&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3124]Balakrishnan，H.和S.Seshan，“拥堵管理者”，RFC 3124，DOI 10.17487/RFC3124，2001年6月&lt;http://www.rfc-editor.org/info/rfc3124&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, &#34;The Addition of Explicit Congestion Notification (ECN) to IP&#34;, RFC 3168, DOI 10.17487/RFC3168, September 2001, &lt;http://www.rfc-editor.org/info/rfc3168&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3168]Ramakrishnan，K.，Floyd，S.，和D.Black，“向IP添加显式拥塞通知（ECN）”，RFC 3168，DOI 10.17487/RFC3168，2001年9月&lt;http://www.rfc-editor.org/info/rfc3168&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &#34;SIP: Session Initiation Protocol&#34;, RFC 3261, DOI 10.17487/RFC3261, June 2002, &lt;http://www.rfc-editor.org/info/rfc3261&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3261]Rosenberg，J.，Schulzrinne，H.，Camarillo，G.，Johnston，A.，Peterson，J.，Sparks，R.，Handley，M.，和E.Schooler，“SIP：会话启动协议”，RFC 3261，DOI 10.17487/RFC3261，2002年6月&lt;http://www.rfc-editor.org/info/rfc3261&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3303] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and A. Rayhan, &#34;Middlebox communication architecture and framework&#34;, RFC 3303, DOI 10.17487/RFC3303, August 2002, &lt;http://www.rfc-editor.org/info/rfc3303&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3303]Srisuresh，P.，Kuthan，J.，Rosenberg，J.，Molitor，A.，和A.Rayhan，“中间箱通信架构和框架”，RFC 3303，DOI 10.17487/RFC3303，2002年8月&lt;http://www.rfc-editor.org/info/rfc3303&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &#34;Basic Socket Interface Extensions for IPv6&#34;, RFC 3493, DOI 10.17487/RFC3493, February 2003, &lt;http://www.rfc-editor.org/info/rfc3493&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3493]Gilligan，R.，Thomson，S.，Bound，J.，McCann，J.，和W.Stevens，“IPv6的基本套接字接口扩展”，RFC 3493，DOI 10.17487/RFC3493，2003年2月&lt;http://www.rfc-editor.org/info/rfc3493&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &#34;RTP: A Transport Protocol for Real-Time Applications&#34;, STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, &lt;http://www.rfc-editor.org/info/rfc3550&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3550]Schulzrinne，H.，Casner，S.，Frederick，R.，和V.Jacobson，“RTP：实时应用的传输协议”，STD 64，RFC 3550，DOI 10.17487/RFC3550，2003年7月&lt;http://www.rfc-editor.org/info/rfc3550&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551] Schulzrinne, H. and S. Casner, &#34;RTP Profile for Audio and Video Conferences with Minimal Control&#34;, STD 65, RFC 3551, DOI 10.17487/RFC3551, July 2003, &lt;http://www.rfc-editor.org/info/rfc3551&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3551]Schulzrinne，H.和S.Casner，“具有最小控制的音频和视频会议的RTP配置文件”，STD 65，RFC 3551，DOI 10.17487/RFC3551，2003年7月&lt;http://www.rfc-editor.org/info/rfc3551&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3738] Luby, M. and V. Goyal, &#34;Wave and Equation Based Rate Control (WEBRC) Building Block&#34;, RFC 3738, DOI 10.17487/RFC3738, April 2004, &lt;http://www.rfc-editor.org/info/rfc3738&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3738]Luby，M.和V.Goyal，“基于波动和方程的速率控制（WEBRC）构造块”，RFC 3738，DOI 10.17487/RFC3738，2004年4月&lt;http://www.rfc-editor.org/info/rfc3738&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3758] Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P. Conrad, &#34;Stream Control Transmission Protocol (SCTP) Partial Reliability Extension&#34;, RFC 3758, DOI 10.17487/RFC3758, May 2004, &lt;http://www.rfc-editor.org/info/rfc3758&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3758]Stewart，R.，Ramalho，M.，Xie，Q.，Tuexen，M.，和P.Conrad，“流控制传输协议（SCTP）部分可靠性扩展”，RFC 3758，DOI 10.17487/RFC3758，2004年5月&lt;http://www.rfc-editor.org/info/rfc3758&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3819] Karn, P., Ed., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, &#34;Advice for Internet Subnetwork Designers&#34;, BCP 89, RFC 3819, DOI 10.17487/RFC3819, July 2004, &lt;http://www.rfc-editor.org/info/rfc3819&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3819]Karn，P.，Ed.，Bormann，C.，Fairhurst，G.，Grossman，D.，Ludwig，R.，Mahdavi，J.，黑山，G.，Touch，J.，和L.Wood，“互联网子网络设计师的建议”，BCP 89，RFC 3819，DOI 10.17487/RFC3819，2004年7月&lt;http://www.rfc-editor.org/info/rfc3819&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301] Kent, S. and K. Seo, &#34;Security Architecture for the Internet Protocol&#34;, RFC 4301, DOI 10.17487/RFC4301, December 2005, &lt;http://www.rfc-editor.org/info/rfc4301&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4301]Kent，S.和K.Seo，“互联网协议的安全架构”，RFC 4301，DOI 10.17487/RFC4301，2005年12月&lt;http://www.rfc-editor.org/info/rfc4301&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302] Kent, S., &#34;IP Authentication Header&#34;, RFC 4302, DOI 10.17487/RFC4302, December 2005, &lt;http://www.rfc-editor.org/info/rfc4302&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4302]Kent，S.，“IP认证头”，RFC 4302，DOI 10.17487/RFC4302，2005年12月&lt;http://www.rfc-editor.org/info/rfc4302&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303] Kent, S., &#34;IP Encapsulating Security Payload (ESP)&#34;, RFC 4303, DOI 10.17487/RFC4303, December 2005, &lt;http://www.rfc-editor.org/info/rfc4303&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4303]Kent，S.，“IP封装安全有效载荷（ESP）”，RFC 4303，DOI 10.17487/RFC4303，2005年12月&lt;http://www.rfc-editor.org/info/rfc4303&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340] Kohler, E., Handley, M., and S. Floyd, &#34;Datagram Congestion Control Protocol (DCCP)&#34;, RFC 4340, DOI 10.17487/RFC4340, March 2006, &lt;http://www.rfc-editor.org/info/rfc4340&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340]Kohler，E.，Handley，M.和S.Floyd，“数据报拥塞控制协议（DCCP）”，RFC 4340，DOI 10.17487/RFC4340，2006年3月&lt;http://www.rfc-editor.org/info/rfc4340&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4341] Floyd, S. and E. Kohler, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control&#34;, RFC 4341, DOI 10.17487/RFC4341, March 2006, &lt;http://www.rfc-editor.org/info/rfc4341&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4341]Floyd，S.和E.Kohler，“数据报拥塞控制协议（DCCP）拥塞控制ID 2的配置文件：类似TCP的拥塞控制”，RFC 4341，DOI 10.17487/RFC4341，2006年3月&lt;http://www.rfc-editor.org/info/rfc4341&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4342] Floyd, S., Kohler, E., and J. Padhye, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)&#34;, RFC 4342, DOI 10.17487/RFC4342, March 2006, &lt;http://www.rfc-editor.org/info/rfc4342&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4342]Floyd，S.，Kohler，E.，和J.Padhye，“数据报拥塞控制协议（DCCP）拥塞控制ID 3的配置文件：TCP友好速率控制（TFRC）”，RFC 4342，DOI 10.17487/RFC4342，2006年3月&lt;http://www.rfc-editor.org/info/rfc4342&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4380] Huitema, C., &#34;Teredo: Tunneling IPv6 over UDP through Network Address Translations (NATs)&#34;, RFC 4380, DOI 10.17487/RFC4380, February 2006, &lt;http://www.rfc-editor.org/info/rfc4380&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4380]Huitema，C.，“Teredo：通过网络地址转换（NAT）通过UDP传输IPv6”，RFC 4380，DOI 10.17487/RFC4380，2006年2月&lt;http://www.rfc-editor.org/info/rfc4380&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4607] Holbrook, H. and B. Cain, &#34;Source-Specific Multicast for IP&#34;, RFC 4607, DOI 10.17487/RFC4607, August 2006, &lt;http://www.rfc-editor.org/info/rfc4607&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4607]Holbrook，H.和B.Cain，“IP的源特定多播”，RFC 4607，DOI 10.17487/RFC4607，2006年8月&lt;http://www.rfc-editor.org/info/rfc4607&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4654] Widmer, J. and M. Handley, &#34;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification&#34;, RFC 4654, DOI 10.17487/RFC4654, August 2006, &lt;http://www.rfc-editor.org/info/rfc4654&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4654]Widmer，J.和M.Handley，“TCP友好多播拥塞控制（TFMCC）：协议规范”，RFC 4654，DOI 10.17487/RFC4654，2006年8月&lt;http://www.rfc-editor.org/info/rfc4654&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4880] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &#34;OpenPGP Message Format&#34;, RFC 4880, DOI 10.17487/RFC4880, November 2007, &lt;http://www.rfc-editor.org/info/rfc4880&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4880]Callas，J.，Donnerhacke，L.，Finney，H.，Shaw，D.，和R.Thayer，“OpenPGP消息格式”，RFC 4880，DOI 10.17487/RFC4880，2007年11月&lt;http://www.rfc-editor.org/info/rfc4880&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4890] Davies, E. and J. Mohacsi, &#34;Recommendations for Filtering ICMPv6 Messages in Firewalls&#34;, RFC 4890, DOI 10.17487/RFC4890, May 2007, &lt;http://www.rfc-editor.org/info/rfc4890&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4890]Davies，E.和J.Mohacsi，“防火墙中过滤ICMPv6消息的建议”，RFC 4890，DOI 10.17487/RFC4890，2007年5月&lt;http://www.rfc-editor.org/info/rfc4890&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960] Stewart, R., Ed., &#34;Stream Control Transmission Protocol&#34;, RFC 4960, DOI 10.17487/RFC4960, September 2007, &lt;http://www.rfc-editor.org/info/rfc4960&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960]Stewart，R.，Ed.“流控制传输协议”，RFC 4960，DOI 10.17487/RFC4960，2007年9月&lt;http://www.rfc-editor.org/info/rfc4960&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4963] Heffner, J., Mathis, M., and B. Chandler, &#34;IPv4 Reassembly Errors at High Data Rates&#34;, RFC 4963, DOI 10.17487/RFC4963, July 2007, &lt;http://www.rfc-editor.org/info/rfc4963&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4963]Heffner，J.，Mathis，M.，和B.Chandler，“高数据速率下的IPv4重组错误”，RFC 4963，DOI 10.17487/RFC4963，2007年7月&lt;http://www.rfc-editor.org/info/rfc4963&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987] Eddy, W., &#34;TCP SYN Flooding Attacks and Common Mitigations&#34;, RFC 4987, DOI 10.17487/RFC4987, August 2007, &lt;http://www.rfc-editor.org/info/rfc4987&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4987]Eddy，W.“TCP SYN洪泛攻击和常见缓解措施”，RFC 4987，DOI 10.17487/RFC4987，2007年8月&lt;http://www.rfc-editor.org/info/rfc4987&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5082] Gill, V., Heasley, J., Meyer, D., Savola, P., Ed., and C. Pignataro, &#34;The Generalized TTL Security Mechanism (GTSM)&#34;, RFC 5082, DOI 10.17487/RFC5082, October 2007, &lt;http://www.rfc-editor.org/info/rfc5082&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5082]Gill，V.，Heasley，J.，Meyer，D.，Savola，P.，Ed.，和C.Pignataro，“广义TTL安全机制（GTSM）”，RFC 5082，DOI 10.17487/RFC5082，2007年10月&lt;http://www.rfc-editor.org/info/rfc5082&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245] Rosenberg, J., &#34;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols&#34;, RFC 5245, DOI 10.17487/RFC5245, April 2010, &lt;http://www.rfc-editor.org/info/rfc5245&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245]Rosenberg，J.，“交互式连接建立（ICE）：提供/应答协议的网络地址转换器（NAT）遍历协议”，RFC 5245，DOI 10.17487/RFC5245，2010年4月&lt;http://www.rfc-editor.org/info/rfc5245&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5622] Floyd, S. and E. Kohler, &#34;Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)&#34;, RFC 5622, DOI 10.17487/RFC5622, August 2009, &lt;http://www.rfc-editor.org/info/rfc5622&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5622]Floyd，S.和E.Kohler，“数据报拥塞控制协议（DCCP）拥塞ID 4的配置文件：小数据包的TCP友好速率控制（TFRC-SP）”，RFC 5622，DOI 10.17487/RFC5622，2009年8月&lt;http://www.rfc-editor.org/info/rfc5622&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5652] Housley, R., &#34;Cryptographic Message Syntax (CMS)&#34;, STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009, &lt;http://www.rfc-editor.org/info/rfc5652&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5652]Housley，R.，“加密消息语法（CMS）”，STD 70，RFC 5652，DOI 10.17487/RFC5652，2009年9月&lt;http://www.rfc-editor.org/info/rfc5652&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681] Allman, M., Paxson, V., and E. Blanton, &#34;TCP Congestion Control&#34;, RFC 5681, DOI 10.17487/RFC5681, September 2009, &lt;http://www.rfc-editor.org/info/rfc5681&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5681]Allman，M.，Paxson，V.和E.Blanton，“TCP拥塞控制”，RFC 5681，DOI 10.17487/RFC56812009年9月&lt;http://www.rfc-editor.org/info/rfc5681&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5740] Adamson, B., Bormann, C., Handley, M., and J. Macker, &#34;NACK-Oriented Reliable Multicast (NORM) Transport Protocol&#34;, RFC 5740, DOI 10.17487/RFC5740, November 2009, &lt;http://www.rfc-editor.org/info/rfc5740&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5740]Adamson，B.，Bormann，C.，Handley，M.，和J.Macker，“面向NACK的可靠多播（NORM）传输协议”，RFC 5740，DOI 10.17487/RFC5740，2009年11月&lt;http://www.rfc-editor.org/info/rfc5740&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5751] Ramsdell, B. and S. Turner, &#34;Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification&#34;, RFC 5751, DOI 10.17487/RFC5751, January 2010, &lt;http://www.rfc-editor.org/info/rfc5751&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5751]Ramsdell，B.和S.Turner，“安全/多用途Internet邮件扩展（S/MIME）版本3.2消息规范”，RFC 5751，DOI 10.17487/RFC5751，2010年1月&lt;http://www.rfc-editor.org/info/rfc5751&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5775] Luby, M., Watson, M., and L. Vicisano, &#34;Asynchronous Layered Coding (ALC) Protocol Instantiation&#34;, RFC 5775, DOI 10.17487/RFC5775, April 2010, &lt;http://www.rfc-editor.org/info/rfc5775&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5775]Luby，M.，Watson，M.，和L.Vicisano，“异步分层编码（ALC）协议实例化”，RFC 5775，DOI 10.17487/RFC5775，2010年4月&lt;http://www.rfc-editor.org/info/rfc5775&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5971] Schulzrinne, H. and R. Hancock, &#34;GIST: General Internet Signalling Transport&#34;, RFC 5971, DOI 10.17487/RFC5971, October 2010, &lt;http://www.rfc-editor.org/info/rfc5971&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5971]Schulzrinne，H.和R.Hancock，“要点：通用互联网信号传输”，RFC 5971，DOI 10.17487/RFC597119010年10月&lt;http://www.rfc-editor.org/info/rfc5971&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5973] Stiemerling, M., Tschofenig, H., Aoun, C., and E. Davies, &#34;NAT/Firewall NSIS Signaling Layer Protocol (NSLP)&#34;, RFC 5973, DOI 10.17487/RFC5973, October 2010, &lt;http://www.rfc-editor.org/info/rfc5973&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5973]Stieemerling，M.，Tschofenig，H.，Aoun，C.，和E.Davies，“NAT/防火墙NSIS信令层协议（NSLP）”，RFC 5973，DOI 10.17487/RFC5973，2010年10月&lt;http://www.rfc-editor.org/info/rfc5973&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6056] Larsen, M. and F. Gont, &#34;Recommendations for Transport-Protocol Port Randomization&#34;, BCP 156, RFC 6056, DOI 10.17487/RFC6056, January 2011, &lt;http://www.rfc-editor.org/info/rfc6056&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6056]Larsen，M.和F.Gont，“运输协议端口随机化建议”，BCP 156，RFC 6056，DOI 10.17487/RFC6056，2011年1月&lt;http://www.rfc-editor.org/info/rfc6056&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6092] Woodyatt, J., Ed., &#34;Recommended Simple Security Capabilities in Customer Premises Equipment (CPE) for Providing Residential IPv6 Internet Service&#34;, RFC 6092, DOI 10.17487/RFC6092, January 2011, &lt;http://www.rfc-editor.org/info/rfc6092&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6092]Woodyatt，J.，Ed.，“提供住宅IPv6互联网服务的客户场所设备（CPE）中推荐的简单安全功能”，RFC 6092，DOI 10.17487/RFC6092，2011年1月&lt;http://www.rfc-editor.org/info/rfc6092&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6335] Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S. Cheshire, &#34;Internet Assigned Numbers Authority (IANA) Procedures for the Management of the Service Name and Transport Protocol Port Number Registry&#34;, BCP 165, RFC 6335, DOI 10.17487/RFC6335, August 2011, &lt;http://www.rfc-editor.org/info/rfc6335&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6335]Cotton，M.，Eggert，L.，Touch，J.，Westerlund，M.，和S.Cheshire，“互联网分配号码管理局（IANA）服务名称和传输协议端口号注册管理程序”，BCP 165，RFC 6335，DOI 10.17487/RFC6335，2011年8月&lt;http://www.rfc-editor.org/info/rfc6335&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, DOI 10.17487/RFC6347, January 2012, &lt;http://www.rfc-editor.org/info/rfc6347&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347]Rescorla，E.和N.Modadugu，“数据报传输层安全版本1.2”，RFC 6347，DOI 10.17487/RFC6347，2012年1月&lt;http://www.rfc-editor.org/info/rfc6347&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6396] Blunk, L., Karir, M., and C. Labovitz, &#34;Multi-Threaded Routing Toolkit (MRT) Routing Information Export Format&#34;, RFC 6396, DOI 10.17487/RFC6396, October 2011, &lt;http://www.rfc-editor.org/info/rfc6396&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6396]Blunk，L.，Karir，M.，和C.Labovitz，“多线程路由工具包（MRT）路由信息导出格式”，RFC 6396，DOI 10.17487/RFC6396，2011年10月&lt;http://www.rfc-editor.org/info/rfc6396&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6437] Amante, S., Carpenter, B., Jiang, S., and J. Rajahalme, &#34;IPv6 Flow Label Specification&#34;, RFC 6437, DOI 10.17487/RFC6437, November 2011, &lt;http://www.rfc-editor.org/info/rfc6437&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6437]Amante，S.，Carpenter，B.，Jiang，S.，和J.Rajahalme，“IPv6流标签规范”，RFC 6437，DOI 10.17487/RFC6437，2011年11月&lt;http://www.rfc-editor.org/info/rfc6437&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6438] Carpenter, B. and S. Amante, &#34;Using the IPv6 Flow Label for Equal Cost Multipath Routing and Link Aggregation in Tunnels&#34;, RFC 6438, DOI 10.17487/RFC6438, November 2011, &lt;http://www.rfc-editor.org/info/rfc6438&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6438]Carpenter，B.和S.Amante，“在隧道中使用IPv6流标签进行等成本多路径路由和链路聚合”，RFC 6438，DOI 10.17487/RFC6438，2011年11月&lt;http://www.rfc-editor.org/info/rfc6438&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6513] Rosen, E., Ed. and R. Aggarwal, Ed., &#34;Multicast in MPLS/ BGP IP VPNs&#34;, RFC 6513, DOI 10.17487/RFC6513, February 2012, &lt;http://www.rfc-editor.org/info/rfc6513&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6513]Rosen，E.，Ed.和R.Aggarwal，Ed.，“MPLS/BGP IP VPN中的多播”，RFC 6513，DOI 10.17487/RFC6513，2012年2月&lt;http://www.rfc-editor.org/info/rfc6513&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679] Westerlund, M., Johansson, I., Perkins, C., O&#39;Hanlon, P., and K. Carlberg, &#34;Explicit Congestion Notification (ECN) for RTP over UDP&#34;, RFC 6679, DOI 10.17487/RFC6679, August 2012, &lt;http://www.rfc-editor.org/info/rfc6679&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6679]Westerlund，M.，Johansson，I.，Perkins，C.，O&#39;Hanlon，P.，和K.Carlberg，“UDP上RTP的显式拥塞通知（ECN）”，RFC 6679，DOI 10.17487/RFC66792012年8月&lt;http://www.rfc-editor.org/info/rfc6679&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6726] Paila, T., Walsh, R., Luby, M., Roca, V., and R. Lehtonen, &#34;FLUTE - File Delivery over Unidirectional Transport&#34;, RFC 6726, DOI 10.17487/RFC6726, November 2012, &lt;http://www.rfc-editor.org/info/rfc6726&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6726]Paila，T.，Walsh，R.，Luby，M.，Roca，V.，和R.Lehtonen，“长笛-单向传输上的文件交付”，RFC 6726，DOI 10.17487/RFC6726，2012年11月&lt;http://www.rfc-editor.org/info/rfc6726&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6773] Phelan, T., Fairhurst, G., and C. Perkins, &#34;DCCP-UDP: A Datagram Congestion Control Protocol UDP Encapsulation for NAT Traversal&#34;, RFC 6773, DOI 10.17487/RFC6773, November 2012, &lt;http://www.rfc-editor.org/info/rfc6773&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6773]Phelan，T.，Fairhurst，G.，和C.Perkins，“DCCP-UDP：NAT穿越的数据报拥塞控制协议UDP封装”，RFC 6773，DOI 10.17487/RFC6773，2012年11月&lt;http://www.rfc-editor.org/info/rfc6773&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6807] Farinacci, D., Shepherd, G., Venaas, S., and Y. Cai, &#34;Population Count Extensions to Protocol Independent Multicast (PIM)&#34;, RFC 6807, DOI 10.17487/RFC6807, December 2012, &lt;http://www.rfc-editor.org/info/rfc6807&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6807]Farinaci，D.，Shepherd，G.，Venaas，S.，和Y.Cai，“协议独立多播（PIM）的人口计数扩展”，RFC 6807，DOI 10.17487/RFC6807，2012年12月&lt;http://www.rfc-editor.org/info/rfc6807&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6887] Wing, D., Ed., Cheshire, S., Boucadair, M., Penno, R., and P. Selkirk, &#34;Port Control Protocol (PCP)&#34;, RFC 6887, DOI 10.17487/RFC6887, April 2013, &lt;http://www.rfc-editor.org/info/rfc6887&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6887]Wing，D.，Ed.，Cheshire，S.，Boucadair，M.，Penno，R.，和P.Selkirk，“港口控制协议（PCP）”，RFC 6887，DOI 10.17487/RFC6887，2013年4月&lt;http://www.rfc-editor.org/info/rfc6887&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935] Eubanks, M., Chimento, P., and M. Westerlund, &#34;IPv6 and UDP Checksums for Tunneled Packets&#34;, RFC 6935, DOI 10.17487/RFC6935, April 2013, &lt;http://www.rfc-editor.org/info/rfc6935&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6935]Eubanks，M.，Chimento，P.，和M.Westerlund，“隧道数据包的IPv6和UDP校验和”，RFC 6935，DOI 10.17487/RFC6935，2013年4月&lt;http://www.rfc-editor.org/info/rfc6935&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6936] Fairhurst, G. and M. Westerlund, &#34;Applicability Statement for the Use of IPv6 UDP Datagrams with Zero Checksums&#34;, RFC 6936, DOI 10.17487/RFC6936, April 2013, &lt;http://www.rfc-editor.org/info/rfc6936&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6936]Fairhurst，G.和M.Westerlund，“使用具有零校验和的IPv6 UDP数据报的适用性声明”，RFC 6936，DOI 10.17487/RFC6936，2013年4月&lt;http://www.rfc-editor.org/info/rfc6936&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6951] Tuexen, M. and R. Stewart, &#34;UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication&#34;, RFC 6951, DOI 10.17487/RFC6951, May 2013, &lt;http://www.rfc-editor.org/info/rfc6951&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6951]Tuexen，M.和R.Stewart，“用于端主机到端主机通信的流控制传输协议（SCTP）数据包的UDP封装”，RFC 6951，DOI 10.17487/RFC6951，2013年5月&lt;http://www.rfc-editor.org/info/rfc6951&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7143] Chadalapaka, M., Satran, J., Meth, K., and D. Black, &#34;Internet Small Computer System Interface (iSCSI) Protocol (Consolidated)&#34;, RFC 7143, DOI 10.17487/RFC7143, April 2014, &lt;http://www.rfc-editor.org/info/rfc7143&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7143]Chadalapaka，M.，Satran，J.，Meth，K.，和D.Black，“互联网小型计算机系统接口（iSCSI）协议（整合）”，RFC 7143，DOI 10.17487/RFC7143，2014年4月&lt;http://www.rfc-editor.org/info/rfc7143&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7201] Westerlund, M. and C. Perkins, &#34;Options for Securing RTP Sessions&#34;, RFC 7201, DOI 10.17487/RFC7201, April 2014, &lt;http://www.rfc-editor.org/info/rfc7201&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7201]Westerlund，M.和C.Perkins，“保护RTP会话的选项”，RFC 7201，DOI 10.17487/RFC7201，2014年4月&lt;http://www.rfc-editor.org/info/rfc7201&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, &#34;Internet Key Exchange Protocol Version 2 (IKEv2)&#34;, STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, &lt;http://www.rfc-editor.org/info/rfc7296&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7296]Kaufman，C.，Hoffman，P.，Nir，Y.，Eronen，P.，和T.Kivinen，“互联网密钥交换协议版本2（IKEv2）”，STD 79，RFC 7296，DOI 10.17487/RFC72962014年10月&lt;http://www.rfc-editor.org/info/rfc7296&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7450] Bumgardner, G., &#34;Automatic Multicast Tunneling&#34;, RFC 7450, DOI 10.17487/RFC7450, February 2015, &lt;http://www.rfc-editor.org/info/rfc7450&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7450]Bumgardner，G.，“自动多播隧道”，RFC 7450，DOI 10.17487/RFC7450，2015年2月&lt;http://www.rfc-editor.org/info/rfc7450&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7510] Xu, X., Sheth, N., Yong, L., Callon, R., and D. Black, &#34;Encapsulating MPLS in UDP&#34;, RFC 7510, DOI 10.17487/RFC7510, April 2015, &lt;http://www.rfc-editor.org/info/rfc7510&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7510]Xu，X.，Sheth，N.，Yong，L.，Callon，R.，和D.Black，“用UDP封装MPLS”，RFC 7510，DOI 10.17487/RFC7510，2015年4月&lt;http://www.rfc-editor.org/info/rfc7510&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, &#34;Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)&#34;, BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, &lt;http://www.rfc-editor.org/info/rfc7525&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7525]Sheffer，Y.，Holz，R.，和P.Saint Andre，“安全使用传输层安全性（TLS）和数据报传输层安全性（DTLS）的建议”，BCP 195，RFC 7525，DOI 10.17487/RFC7525，2015年5月&lt;http://www.rfc-editor.org/info/rfc7525&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7560] Kuehlewind, M., Ed., Scheffenegger, R., and B. Briscoe, &#34;Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback&#34;, RFC 7560, DOI 10.17487/RFC7560, August 2015, &lt;http://www.rfc-editor.org/info/rfc7560&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7560]Kuehlewind，M.，Ed.，Scheffenegger，R.，和B.Briscoe，“明确拥塞通知（ECN）反馈中提高准确性的问题陈述和要求”，RFC 7560，DOI 10.17487/RFC7560，2015年8月&lt;http://www.rfc-editor.org/info/rfc7560&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., &#34;IETF Recommendations Regarding Active Queue Management&#34;, BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, &lt;http://www.rfc-editor.org/info/rfc7567&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7567]Baker，F.，Ed.和G.Fairhurst，Ed.，“IETF关于主动队列管理的建议”，BCP 197，RFC 7567，DOI 10.17487/RFC7567，2015年7月&lt;http://www.rfc-editor.org/info/rfc7567&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7605] Touch, J., &#34;Recommendations on Using Assigned Transport Port Numbers&#34;, BCP 165, RFC 7605, DOI 10.17487/RFC7605, August 2015, &lt;http://www.rfc-editor.org/info/rfc7605&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7605]Touch，J.，“使用指定运输端口号的建议”，BCP 165，RFC 7605，DOI 10.17487/RFC7605，2015年8月&lt;http://www.rfc-editor.org/info/rfc7605&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657] Black, D., Ed. and P. Jones, &#34;Differentiated Services (Diffserv) and Real-Time Communication&#34;, RFC 7657, DOI 10.17487/RFC7657, November 2015, &lt;http://www.rfc-editor.org/info/rfc7657&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7657]Black，D.，Ed.和P.Jones，“区分服务（Diffserv）和实时通信”，RFC 7657，DOI 10.17487/RFC7657，2015年11月&lt;http://www.rfc-editor.org/info/rfc7657&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7675] Perumal, M., Wing, D., Ravindranath, R., Reddy, T., and M. Thomson, &#34;Session Traversal Utilities for NAT (STUN) Usage for Consent Freshness&#34;, RFC 7675, DOI 10.17487/RFC7675, October 2015, &lt;http://www.rfc-editor.org/info/rfc7675&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7675]Perumal，M.，Wing，D.，Ravindranath，R.，Reddy，T.，和M.Thomson，“NAT（STUN）用于同意新鲜度的会话遍历实用程序”，RFC 7675，DOI 10.17487/RFC7675，2015年10月&lt;http://www.rfc-editor.org/info/rfc7675&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8083] Perkins, C. and V. Singh, &#34;Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions&#34;, RFC 8083, DOI 10.17487/RFC8083, March 2017, &lt;http://www.rfc-editor.org/info/rfc8083&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8083]Perkins，C.和V.Singh，“多媒体拥塞控制：单播RTP会话的断路器”，RFC 8083，DOI 10.17487/RFC8083，2017年3月&lt;http://www.rfc-editor.org/info/rfc8083&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8086] Yong, L., Ed., Crabbe, E., Xu, X., and T. Herbert, &#34;GRE-in-UDP Encapsulation&#34;, RFC 8086, DOI 10.17487/RFC8086, March 2017, &lt;http://www.rfc-editor.org/info/rfc8086&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8086]Yong，L.，Ed.，Crabbe，E.，Xu，X.，和T.Herbert，“UDP封装中的GRE”，RFC 8086，DOI 10.17487/RFC8086，2017年3月&lt;http://www.rfc-editor.org/info/rfc8086&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087] Fairhurst, G. and M. Welzl, &#34;The Benefits of Using Explicit Congestion Notification (ECN)&#34;, RFC 8087, DOI 10.17487/RFC8087, March 2017, &lt;http://www.rfc-editor.org/info/rfc8087&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC8087]Fairhurst，G.和M.Welzl，“使用显式拥塞通知（ECN）的好处”，RFC 8087，DOI 10.17487/RFC8087，2017年3月&lt;http://www.rfc-editor.org/info/rfc8087&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[STEVENS] Stevens, W., Fenner, B., and A. Rudoff, &#34;UNIX Network Programming, The sockets Networking API&#34;, Addison-Wesley, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[STEVENS]STEVENS，W.，Fenner，B.，和A.Rudoff，“UNIX网络编程，套接字网络API”，Addison Wesley，2004年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UPnP] UPnP Forum, , &#34;Internet Gateway Device (IGD) Standardized Device Control Protocol V 1.0&#34;, November 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UPnP]UPnP论坛，“互联网网关设备（IGD）标准化设备控制协议V1.0”，2001年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A. Case Study of the Use of IPv6 UDP Zero-Checksum Mode
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录A.使用IPv6 UDP零校验和模式的案例研究
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This appendix provides a brief review of MPLS-in-UDP as an example of a UDP Tunnel Encapsulation that defines a UDP encapsulation. The purpose of the appendix is to provide a concrete example of which mechanisms were required in order to safely use UDP zero-checksum mode for MPLS-in-UDP tunnels over IPv6. By default, UDP requires a checksum for use with IPv6. An option has been specified that permits a zero IPv6 UDP checksum when used in specific environments, specified in [RFC7510], and defines a set of operational constraints for use of this mode. These are summarized below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本附录简要回顾了UDP中的MPLS，作为定义UDP封装的UDP隧道封装示例。本附录的目的是提供一个具体示例，说明在IPv6上的UDP隧道中为MPLS安全使用UDP零校验和模式需要哪些机制。默认情况下，UDP需要用于IPv6的校验和。[RFC7510]中指定了一个选项，该选项允许在特定环境中使用零IPv6 UDP校验和，并定义了使用此模式的一组操作约束。总结如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A UDP tunnel or encapsulation using a zero-checksum mode with IPv6 must only be deployed within a single network (with a single network operator) or networks of an adjacent set of cooperating network operators where traffic is managed to avoid congestion, rather than over the Internet where congestion control is required. MPLS-in-UDP has been specified for networks under single administrative control (such as within a single operator&#39;s network) where it is known (perhaps through knowledge of equipment types and lower-layer checks) that packet corruption is exceptionally unlikely and where the operator is willing to take the risk of undetected packet corruption.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用带IPv6的零校验和模式的UDP隧道或封装必须仅部署在单个网络（具有单个网络运营商）或相邻一组合作网络运营商的网络中，在这些网络中管理流量以避免拥塞，而不是通过需要拥塞控制的Internet。UDP中的MPLS已指定用于单一管理控制下的网络（例如在单一运营商的网络内），其中已知（可能通过了解设备类型和较低层检查）数据包损坏的可能性极低，并且运营商愿意承担未检测到的数据包损坏的风险。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The tunnel encapsulator SHOULD use different IPv6 addresses for each UDP tunnel that uses the UDP zero-checksum mode, regardless of the decapsulator, to strengthen the decapsulator&#39;s check of the IPv6 source address (i.e., the same IPv6 source address SHOULD NOT be used with more than one IPv6 destination address, independent of whether that destination address is a unicast or multicast address). Use of MPLS-in-UDP may be extended to networks within a set of closely cooperating network administrations (such as network operators who have agreed to work together to jointly provide specific services) [RFC7510].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
隧道封装器应为每个使用UDP零校验和模式的UDP隧道使用不同的IPv6地址，而不考虑解封装器，以加强解封装器对IPv6源地址的检查（即，同一IPv6源地址不应与多个IPv6目标地址一起使用，这与该目标地址是单播地址还是多播地址无关）。UDP中MPLS的使用可以扩展到一组密切合作的网络管理中的网络（如同意共同提供特定服务的网络运营商）[RFC7510]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The requirement for MPLS-in-UDP endpoints to check the source IPv6 address in addition to the destination IPv6 address, plus the strong recommendation against reuse of source IPv6 addresses among MPLS-in-UDP tunnels collectively provide some mitigation for the absence of UDP checksum coverage of the IPv6 header. In addition, the MPLS data plane only forwards packets with valid labels (i.e., labels that have been distributed by the tunnel egress Label Switched Router, LSR), providing some additional opportunity to detect MPLS-in-UDP packet misdelivery when the misdelivered packet contains a label that is not valid for forwarding at the receiving LSR. The expected result for IPv6 UDP zero-checksum mode for MPLS-in-UDP is that corruption of the destination IPv6 address will usually cause packet discard, as offsetting corruptions to the source IPv6 and/or MPLS top label are unlikely.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP端点中的MPLS除了检查目标IPv6地址外，还需要检查源IPv6地址，加上强烈建议在UDP隧道中的MPLS之间重新使用源IPv6地址，这共同为IPv6报头缺少UDP校验和覆盖提供了一些缓解措施。此外，MPLS数据平面仅转发具有有效标签的分组（即，已由隧道出口标签交换路由器LSR分发的标签），当误发分组包含在接收LSR处无效转发的标签时，提供一些额外的机会来检测UDP分组误发中的MPLS。UDP中MPLS的IPv6 UDP零校验和模式的预期结果是，目标IPv6地址的损坏通常会导致数据包丢弃，因为不太可能抵消对源IPv6和/或MPLS顶部标签的损坏。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional assurance is provided by the restrictions in the above exceptions that limit usage of IPv6 UDP zero-checksum mode to well-managed networks for which MPLS packet corruption has not been a problem in practice. Hence, MPLS-in-UDP is suitable for transmission over lower layers in well-managed networks that are allowed by the exceptions stated above and the rate of corruption of the inner IP packet on such networks is not expected to increase by comparison to MPLS traffic that is not encapsulated in UDP. For these reasons, MPLS-in-UDP does not provide an additional integrity check when UDP zero-checksum mode is used with IPv6, and this design is in accordance with requirements 2, 3, and 5 specified in Section 5 of [RFC6936].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述例外情况中的限制提供了额外的保证，这些限制将IPv6 UDP零校验和模式的使用限制在管理良好的网络上，对于这些网络，MPLS数据包损坏在实践中并不成问题。因此，UDP中的MPLS适合在上述例外情况允许的管理良好的网络中的较低层上传输，并且与未封装在UDP中的MPLS通信量相比，此类网络上的内部IP数据包的损坏率预计不会增加。由于这些原因，当IPv6使用UDP零校验和模式时，UDP中的MPLS不提供额外的完整性检查，并且该设计符合[RFC6936]第5节中规定的要求2、3和5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The MPLS-in-UDP encapsulation does not provide a mechanism to safely fall back to using a checksum when a path change occurs that redirects a tunnel over a path that includes a middlebox that discards IPv6 datagrams with a zero UDP checksum. In this case, the MPLS-in-UDP tunnel will be black-holed by that middlebox. Recommended changes to allow firewalls, NATs and other middleboxes to support use of an IPv6 zero UDP checksum are described in Section 5 of [RFC6936]. MPLS does not accumulate incorrect state as a consequence of label-stack corruption. A corrupt MPLS label results in either packet discard or forwarding (and forgetting) of the packet without accumulation of MPLS protocol state. Active monitoring of MPLS-in-UDP traffic for errors is REQUIRED because the occurrence of errors will result in some accumulation of error information outside the MPLS protocol for operational and management purposes. This design is in accordance with requirement 4 specified in Section 5 of [RFC6936]. In addition, IPv6 traffic with a zero UDP checksum MUST be actively monitored for errors by the network operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UDP封装中的MPLS没有提供一种机制，在发生路径更改时安全地退回到使用校验和，该路径更改将隧道重定向到包含丢弃具有零UDP校验和的IPv6数据报的中间盒的路径上。在这种情况下，UDP隧道中的MPLS将被该中间盒屏蔽。[RFC6936]第5节介绍了允许防火墙、NAT和其他中间盒支持使用IPv6零UDP校验和的建议更改。MPLS不会由于标签堆栈损坏而累积错误状态。损坏的MPLS标签会导致数据包丢弃或转发（和遗忘），而不会累积MPLS协议状态。需要主动监控UDP通信中的MPLS是否存在错误，因为错误的发生将导致在MPLS协议之外积累一些错误信息，用于操作和管理目的。该设计符合[RFC6936]第5节规定的要求4。此外，网络运营商必须主动监控UDP校验和为零的IPv6流量是否存在错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Operators SHOULD also deploy packet filters to prevent IPv6 packets with a zero UDP checksum from escaping from the network due to misconfiguration or packet errors. In addition, IPv6 traffic with a zero UDP checksum MUST be actively monitored for errors by the network operator.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
运营商还应部署数据包过滤器，以防止UDP校验和为零的IPv6数据包由于配置错误或数据包错误而从网络中逃逸。此外，网络运营商必须主动监控UDP校验和为零的IPv6流量是否存在错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgments
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
致谢
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The middlebox traversal guidelines in Section 3.5 incorporate ideas from Section 5 of [BEHAVE-APP] by Bryan Ford, Pyda Srisuresh, and Dan Kegel. The protocol timer guidelines in Section 3.1.1 were largely contributed by Mark Allman.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第3.5节中的中间箱穿越指南包含了Bryan Ford、Pyda Srisuresh和Dan Kegel在[BEHAVE-APP]第5节中的观点。第3.1.1节中的协议计时器指南主要由Mark Allman提供。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
G. Fairhurst received funding from the European Union&#39;s Horizon 2020 research and innovation program 2014-2018 under grant agreement No. 644334 (NEAT). Lars Eggert has received funding from the European Union&#39;s Horizon 2020 research and innovation program 2014-2018 under grant agreement No. 644866 (SSICLOPS). This document reflects only the authors&#39; views and the European Commission is not responsible for any use that may be made of the information it contains.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
G.Fairhurst根据第644334（NEAT）号赠款协议获得了欧盟地平线2020研究与创新计划2014-2018的资助。Lars Eggert已收到欧盟地平线2020研究与创新计划2014-2018的资助，资助协议编号为644866（SSICLOPS）。本文件仅反映了作者的观点，欧盟委员会不对其所含信息的任何使用负责。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Lars Eggert NetApp Sonnenallee 1 Kirchheim 85551 Germany
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
德国基尔希海姆1号拉尔斯·埃格特·内塔普·索内纳利85551
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +49 151 120 55791
   Email: lars@netapp.com
   URI:   https://eggert.org/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +49 151 120 55791
   Email: lars@netapp.com
   URI:   https://eggert.org/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Godred Fairhurst University of Aberdeen Department of Engineering Fraser Noble Building Aberdeen AB24 3UE Scotland
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
GoRead FelHurt阿伯丁大学工程系弗雷泽贵族大厦阿伯丁A24 24苏格兰
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: gorry@erg.abdn.ac.uk
   URI:   http://www.erg.abdn.ac.uk/
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: gorry@erg.abdn.ac.uk
   URI:   http://www.erg.abdn.ac.uk/
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Greg Shepherd Cisco Systems Tasman Drive San Jose United States of America
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
格雷格·谢泼德思科系统公司美国圣何塞塔斯曼大道
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: gjshep@gmail.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Email: gjshep@gmail.com
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
