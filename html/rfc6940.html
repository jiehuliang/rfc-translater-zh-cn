<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 6940: REsource LOcation And Discovery (RELOAD) Base Protocol中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC 6940: REsource LOcation And Discovery (RELOAD) Base Protocol中文翻译</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">6940</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc6940">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 6940: REsource LOcation And Discovery (RELOAD) Base Protocol 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc6940">
              https://datatracker.ietf.org/doc/html/rfc6940
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 6940</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       C. Jennings
Request for Comments: 6940                                         Cisco
Category: Standards Track                               B. Lowekamp, Ed.
ISSN: 2070-1721                                                    Skype
                                                             E. Rescorla
                                                              RTFM, Inc.
                                                                S. Baset
                                                          H. Schulzrinne
                                                     Columbia University
                                                            January 2014
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Internet Engineering Task Force (IETF)                       C. Jennings
Request for Comments: 6940                                         Cisco
Category: Standards Track                               B. Lowekamp, Ed.
ISSN: 2070-1721                                                    Skype
                                                             E. Rescorla
                                                              RTFM, Inc.
                                                                S. Baset
                                                          H. Schulzrinne
                                                     Columbia University
                                                            January 2014
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
REsource LOcation And Discovery (RELOAD) Base Protocol
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
资源位置和发现（重新加载）基本协议
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. A P2P signaling protocol provides its clients with an abstract storage and messaging service between a set of cooperating peers that form the overlay network. RELOAD is designed to support a P2P Session Initiation Protocol (P2PSIP) network, but can be utilized by other applications with similar requirements by defining new usages that specify the Kinds of data that need to be stored for a particular application. RELOAD defines a security model based on a certificate enrollment service that provides unique identities. NAT traversal is a fundamental service of the protocol. RELOAD also allows access from &#34;client&#34; nodes that do not need to route traffic or store data for others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本规范定义了资源定位和发现（RELOAD），这是一种用于Internet的对等（P2P）信令协议。P2P信令协议为其客户机提供了一个抽象的存储和消息传递服务，该服务位于形成覆盖网络的一组协作对等点之间。RELOAD旨在支持P2P会话启动协议（P2PSIP）网络，但也可由具有类似需求的其他应用程序使用，方法是定义新的用法，指定特定应用程序需要存储的数据类型。RELOAD基于提供唯一标识的证书注册服务定义安全模型。NAT穿越是协议的一项基本服务。重新加载还允许从“客户端”节点进行访问，这些节点不需要路由流量或为其他节点存储数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This is an Internet Standards Track document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是一份互联网标准跟踪文件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。有关互联网标准的更多信息，请参见RFC 5741第2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc6940.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（c）2014 IETF信托基金和确定为文件作者的人员。版权所有。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to BCP 78 and the IETF Trust&#39;s Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件可能包含2008年11月10日之前发布或公开的IETF文件或IETF贡献中的材料。控制某些材料版权的人员可能未授予IETF信托允许在IETF标准流程之外修改此类材料的权利。在未从控制此类材料版权的人员处获得充分许可的情况下，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其衍生作品，除了将其格式化以RFC形式发布或将其翻译成英语以外的其他语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   7
     1.1.  Basic Setting . . . . . . . . . . . . . . . . . . . . . .   8
     1.2.  Architecture  . . . . . . . . . . . . . . . . . . . . . .  10
       1.2.1.  Usage Layer . . . . . . . . . . . . . . . . . . . . .  13
       1.2.2.  Message Transport . . . . . . . . . . . . . . . . . .  13
       1.2.3.  Storage . . . . . . . . . . . . . . . . . . . . . . .  14
       1.2.4.  Topology Plug-in  . . . . . . . . . . . . . . . . . .  15
       1.2.5.  Forwarding and Link Management Layer  . . . . . . . .  16
     1.3.  Security  . . . . . . . . . . . . . . . . . . . . . . . .  16
     1.4.  Structure of This Document  . . . . . . . . . . . . . . .  17
   2.  Requirements Language . . . . . . . . . . . . . . . . . . . .  18
   3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  18
   4.  Overlay Management Overview . . . . . . . . . . . . . . . . .  21
     4.1.  Security and Identification . . . . . . . . . . . . . . .  21
       4.1.1.  Shared-Key Security . . . . . . . . . . . . . . . . .  23
     4.2.  Clients . . . . . . . . . . . . . . . . . . . . . . . . .  23
       4.2.1.  Client Routing  . . . . . . . . . . . . . . . . . . .  24
       4.2.2.  Minimum Functionality Requirements for Clients  . . .  25
     4.3.  Routing . . . . . . . . . . . . . . . . . . . . . . . . .  25
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   7
     1.1.  Basic Setting . . . . . . . . . . . . . . . . . . . . . .   8
     1.2.  Architecture  . . . . . . . . . . . . . . . . . . . . . .  10
       1.2.1.  Usage Layer . . . . . . . . . . . . . . . . . . . . .  13
       1.2.2.  Message Transport . . . . . . . . . . . . . . . . . .  13
       1.2.3.  Storage . . . . . . . . . . . . . . . . . . . . . . .  14
       1.2.4.  Topology Plug-in  . . . . . . . . . . . . . . . . . .  15
       1.2.5.  Forwarding and Link Management Layer  . . . . . . . .  16
     1.3.  Security  . . . . . . . . . . . . . . . . . . . . . . . .  16
     1.4.  Structure of This Document  . . . . . . . . . . . . . . .  17
   2.  Requirements Language . . . . . . . . . . . . . . . . . . . .  18
   3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  18
   4.  Overlay Management Overview . . . . . . . . . . . . . . . . .  21
     4.1.  Security and Identification . . . . . . . . . . . . . . .  21
       4.1.1.  Shared-Key Security . . . . . . . . . . . . . . . . .  23
     4.2.  Clients . . . . . . . . . . . . . . . . . . . . . . . . .  23
       4.2.1.  Client Routing  . . . . . . . . . . . . . . . . . . .  24
       4.2.2.  Minimum Functionality Requirements for Clients  . . .  25
     4.3.  Routing . . . . . . . . . . . . . . . . . . . . . . . . .  25
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
     4.4.  Connectivity Management . . . . . . . . . . . . . . . . .  29
     4.5.  Overlay Algorithm Support . . . . . . . . . . . . . . . .  30
       4.5.1.  Support for Pluggable Overlay Algorithms  . . . . . .  30
       4.5.2.  Joining, Leaving, and Maintenance Overview  . . . . .  30
     4.6.  First-Time Setup  . . . . . . . . . . . . . . . . . . . .  32
       4.6.1.  Initial Configuration . . . . . . . . . . . . . . . .  32
       4.6.2.  Enrollment  . . . . . . . . . . . . . . . . . . . . .  32
       4.6.3.  Diagnostics . . . . . . . . . . . . . . . . . . . . .  33
   5.  Application Support Overview  . . . . . . . . . . . . . . . .  33
     5.1.  Data Storage  . . . . . . . . . . . . . . . . . . . . . .  33
       5.1.1.  Storage Permissions . . . . . . . . . . . . . . . . .  34
       5.1.2.  Replication . . . . . . . . . . . . . . . . . . . . .  35
     5.2.  Usages  . . . . . . . . . . . . . . . . . . . . . . . . .  36
     5.3.  Service Discovery . . . . . . . . . . . . . . . . . . . .  36
     5.4.  Application Connectivity  . . . . . . . . . . . . . . . .  36
   6.  Overlay Management Protocol . . . . . . . . . . . . . . . . .  37
     6.1.  Message Receipt and Forwarding  . . . . . . . . . . . . .  37
       6.1.1.  Responsible ID  . . . . . . . . . . . . . . . . . . .  38
       6.1.2.  Other ID  . . . . . . . . . . . . . . . . . . . . . .  38
       6.1.3.  Opaque ID . . . . . . . . . . . . . . . . . . . . . .  40
     6.2.  Symmetric Recursive Routing . . . . . . . . . . . . . . .  41
       6.2.1.  Request Origination . . . . . . . . . . . . . . . . .  41
       6.2.2.  Response Origination  . . . . . . . . . . . . . . . .  42
     6.3.  Message Structure . . . . . . . . . . . . . . . . . . . .  42
       6.3.1.  Presentation Language . . . . . . . . . . . . . . . .  43
         6.3.1.1.  Common Definitions  . . . . . . . . . . . . . . .  44
       6.3.2.  Forwarding Header . . . . . . . . . . . . . . . . . .  46
         6.3.2.1.  Processing Configuration Sequence Numbers . . . .  49
         6.3.2.2.  Destination and Via Lists . . . . . . . . . . . .  50
         6.3.2.3.  Forwarding Option . . . . . . . . . . . . . . . .  52
       6.3.3.  Message Contents Format . . . . . . . . . . . . . . .  53
         6.3.3.1.  Response Codes and Response Errors  . . . . . . .  54
       6.3.4.  Security Block  . . . . . . . . . . . . . . . . . . .  57
     6.4.  Overlay Topology  . . . . . . . . . . . . . . . . . . . .  60
       6.4.1.  Topology Plug-in Requirements . . . . . . . . . . . .  60
       6.4.2.  Methods and Types for Use by Topology Plug-ins  . . .  61
         6.4.2.1.  Join  . . . . . . . . . . . . . . . . . . . . . .  61
         6.4.2.2.  Leave . . . . . . . . . . . . . . . . . . . . . .  62
         6.4.2.3.  Update  . . . . . . . . . . . . . . . . . . . . .  63
         6.4.2.4.  RouteQuery  . . . . . . . . . . . . . . . . . . .  63
         6.4.2.5.  Probe . . . . . . . . . . . . . . . . . . . . . .  65
     6.5.  Forwarding and Link Management Layer  . . . . . . . . . .  67
       6.5.1.  Attach  . . . . . . . . . . . . . . . . . . . . . . .  67
         6.5.1.1.  Request Definition  . . . . . . . . . . . . . . .  68
         6.5.1.2.  Response Definition . . . . . . . . . . . . . . .  70
         6.5.1.3.  Using ICE with RELOAD . . . . . . . . . . . . . .  71
         6.5.1.4.  Collecting STUN Servers . . . . . . . . . . . . .  71
         6.5.1.5.  Gathering Candidates  . . . . . . . . . . . . . .  72
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
     4.4.  Connectivity Management . . . . . . . . . . . . . . . . .  29
     4.5.  Overlay Algorithm Support . . . . . . . . . . . . . . . .  30
       4.5.1.  Support for Pluggable Overlay Algorithms  . . . . . .  30
       4.5.2.  Joining, Leaving, and Maintenance Overview  . . . . .  30
     4.6.  First-Time Setup  . . . . . . . . . . . . . . . . . . . .  32
       4.6.1.  Initial Configuration . . . . . . . . . . . . . . . .  32
       4.6.2.  Enrollment  . . . . . . . . . . . . . . . . . . . . .  32
       4.6.3.  Diagnostics . . . . . . . . . . . . . . . . . . . . .  33
   5.  Application Support Overview  . . . . . . . . . . . . . . . .  33
     5.1.  Data Storage  . . . . . . . . . . . . . . . . . . . . . .  33
       5.1.1.  Storage Permissions . . . . . . . . . . . . . . . . .  34
       5.1.2.  Replication . . . . . . . . . . . . . . . . . . . . .  35
     5.2.  Usages  . . . . . . . . . . . . . . . . . . . . . . . . .  36
     5.3.  Service Discovery . . . . . . . . . . . . . . . . . . . .  36
     5.4.  Application Connectivity  . . . . . . . . . . . . . . . .  36
   6.  Overlay Management Protocol . . . . . . . . . . . . . . . . .  37
     6.1.  Message Receipt and Forwarding  . . . . . . . . . . . . .  37
       6.1.1.  Responsible ID  . . . . . . . . . . . . . . . . . . .  38
       6.1.2.  Other ID  . . . . . . . . . . . . . . . . . . . . . .  38
       6.1.3.  Opaque ID . . . . . . . . . . . . . . . . . . . . . .  40
     6.2.  Symmetric Recursive Routing . . . . . . . . . . . . . . .  41
       6.2.1.  Request Origination . . . . . . . . . . . . . . . . .  41
       6.2.2.  Response Origination  . . . . . . . . . . . . . . . .  42
     6.3.  Message Structure . . . . . . . . . . . . . . . . . . . .  42
       6.3.1.  Presentation Language . . . . . . . . . . . . . . . .  43
         6.3.1.1.  Common Definitions  . . . . . . . . . . . . . . .  44
       6.3.2.  Forwarding Header . . . . . . . . . . . . . . . . . .  46
         6.3.2.1.  Processing Configuration Sequence Numbers . . . .  49
         6.3.2.2.  Destination and Via Lists . . . . . . . . . . . .  50
         6.3.2.3.  Forwarding Option . . . . . . . . . . . . . . . .  52
       6.3.3.  Message Contents Format . . . . . . . . . . . . . . .  53
         6.3.3.1.  Response Codes and Response Errors  . . . . . . .  54
       6.3.4.  Security Block  . . . . . . . . . . . . . . . . . . .  57
     6.4.  Overlay Topology  . . . . . . . . . . . . . . . . . . . .  60
       6.4.1.  Topology Plug-in Requirements . . . . . . . . . . . .  60
       6.4.2.  Methods and Types for Use by Topology Plug-ins  . . .  61
         6.4.2.1.  Join  . . . . . . . . . . . . . . . . . . . . . .  61
         6.4.2.2.  Leave . . . . . . . . . . . . . . . . . . . . . .  62
         6.4.2.3.  Update  . . . . . . . . . . . . . . . . . . . . .  63
         6.4.2.4.  RouteQuery  . . . . . . . . . . . . . . . . . . .  63
         6.4.2.5.  Probe . . . . . . . . . . . . . . . . . . . . . .  65
     6.5.  Forwarding and Link Management Layer  . . . . . . . . . .  67
       6.5.1.  Attach  . . . . . . . . . . . . . . . . . . . . . . .  67
         6.5.1.1.  Request Definition  . . . . . . . . . . . . . . .  68
         6.5.1.2.  Response Definition . . . . . . . . . . . . . . .  70
         6.5.1.3.  Using ICE with RELOAD . . . . . . . . . . . . . .  71
         6.5.1.4.  Collecting STUN Servers . . . . . . . . . . . . .  71
         6.5.1.5.  Gathering Candidates  . . . . . . . . . . . . . .  72
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
         6.5.1.6.  Prioritizing Candidates . . . . . . . . . . . . .  72
         6.5.1.7.  Encoding the Attach Message . . . . . . . . . . .  73
         6.5.1.8.  Verifying ICE Support . . . . . . . . . . . . . .  74
         6.5.1.9.  Role Determination  . . . . . . . . . . . . . . .  74
         6.5.1.10. Full ICE  . . . . . . . . . . . . . . . . . . . .  74
         6.5.1.11. No-ICE  . . . . . . . . . . . . . . . . . . . . .  75
         6.5.1.12. Subsequent Offers and Answers . . . . . . . . . .  75
         6.5.1.13. Sending Media . . . . . . . . . . . . . . . . . .  75
         6.5.1.14. Receiving Media . . . . . . . . . . . . . . . . .  75
       6.5.2.  AppAttach . . . . . . . . . . . . . . . . . . . . . .  75
         6.5.2.1.  Request Definition  . . . . . . . . . . . . . . .  76
         6.5.2.2.  Response Definition . . . . . . . . . . . . . . .  77
       6.5.3.  Ping  . . . . . . . . . . . . . . . . . . . . . . . .  77
         6.5.3.1.  Request Definition  . . . . . . . . . . . . . . .  77
         6.5.3.2.  Response Definition . . . . . . . . . . . . . . .  77
       6.5.4.  ConfigUpdate  . . . . . . . . . . . . . . . . . . . .  78
         6.5.4.1.  Request Definition  . . . . . . . . . . . . . . .  78
         6.5.4.2.  Response Definition . . . . . . . . . . . . . . .  79
     6.6.  Overlay Link Layer  . . . . . . . . . . . . . . . . . . .  80
       6.6.1.  Future Overlay Link Protocols . . . . . . . . . . . .  81
         6.6.1.1.  HIP . . . . . . . . . . . . . . . . . . . . . . .  82
         6.6.1.2.  ICE-TCP . . . . . . . . . . . . . . . . . . . . .  82
         6.6.1.3.  Message-Oriented Transports . . . . . . . . . . .  82
         6.6.1.4.  Tunneled Transports . . . . . . . . . . . . . . .  82
       6.6.2.  Framing Header  . . . . . . . . . . . . . . . . . . .  83
       6.6.3.  Simple Reliability  . . . . . . . . . . . . . . . . .  84
         6.6.3.1.  Stop and Wait Sender Algorithm  . . . . . . . . .  85
       6.6.4.  DTLS/UDP with SR  . . . . . . . . . . . . . . . . . .  86
       6.6.5.  TLS/TCP with FH, No-ICE . . . . . . . . . . . . . . .  86
       6.6.6.  DTLS/UDP with SR, No-ICE  . . . . . . . . . . . . . .  87
     6.7.  Fragmentation and Reassembly  . . . . . . . . . . . . . .  87
   7.  Data Storage Protocol . . . . . . . . . . . . . . . . . . . .  88
     7.1.  Data Signature Computation  . . . . . . . . . . . . . . .  90
     7.2.  Data Models . . . . . . . . . . . . . . . . . . . . . . .  91
       7.2.1.  Single Value  . . . . . . . . . . . . . . . . . . . .  91
       7.2.2.  Array . . . . . . . . . . . . . . . . . . . . . . . .  92
       7.2.3.  Dictionary  . . . . . . . . . . . . . . . . . . . . .  92
     7.3.  Access Control Policies . . . . . . . . . . . . . . . . .  93
       7.3.1.  USER-MATCH  . . . . . . . . . . . . . . . . . . . . .  93
       7.3.2.  NODE-MATCH  . . . . . . . . . . . . . . . . . . . . .  93
       7.3.3.  USER-NODE-MATCH . . . . . . . . . . . . . . . . . . .  93
       7.3.4.  NODE-MULTIPLE . . . . . . . . . . . . . . . . . . . .  94
     7.4.  Data Storage Methods  . . . . . . . . . . . . . . . . . .  94
       7.4.1.  Store . . . . . . . . . . . . . . . . . . . . . . . .  94
         7.4.1.1.  Request Definition  . . . . . . . . . . . . . . .  94
         7.4.1.2.  Response Definition . . . . . . . . . . . . . . . 100
         7.4.1.3.  Removing Values . . . . . . . . . . . . . . . . . 101
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
         6.5.1.6.  Prioritizing Candidates . . . . . . . . . . . . .  72
         6.5.1.7.  Encoding the Attach Message . . . . . . . . . . .  73
         6.5.1.8.  Verifying ICE Support . . . . . . . . . . . . . .  74
         6.5.1.9.  Role Determination  . . . . . . . . . . . . . . .  74
         6.5.1.10. Full ICE  . . . . . . . . . . . . . . . . . . . .  74
         6.5.1.11. No-ICE  . . . . . . . . . . . . . . . . . . . . .  75
         6.5.1.12. Subsequent Offers and Answers . . . . . . . . . .  75
         6.5.1.13. Sending Media . . . . . . . . . . . . . . . . . .  75
         6.5.1.14. Receiving Media . . . . . . . . . . . . . . . . .  75
       6.5.2.  AppAttach . . . . . . . . . . . . . . . . . . . . . .  75
         6.5.2.1.  Request Definition  . . . . . . . . . . . . . . .  76
         6.5.2.2.  Response Definition . . . . . . . . . . . . . . .  77
       6.5.3.  Ping  . . . . . . . . . . . . . . . . . . . . . . . .  77
         6.5.3.1.  Request Definition  . . . . . . . . . . . . . . .  77
         6.5.3.2.  Response Definition . . . . . . . . . . . . . . .  77
       6.5.4.  ConfigUpdate  . . . . . . . . . . . . . . . . . . . .  78
         6.5.4.1.  Request Definition  . . . . . . . . . . . . . . .  78
         6.5.4.2.  Response Definition . . . . . . . . . . . . . . .  79
     6.6.  Overlay Link Layer  . . . . . . . . . . . . . . . . . . .  80
       6.6.1.  Future Overlay Link Protocols . . . . . . . . . . . .  81
         6.6.1.1.  HIP . . . . . . . . . . . . . . . . . . . . . . .  82
         6.6.1.2.  ICE-TCP . . . . . . . . . . . . . . . . . . . . .  82
         6.6.1.3.  Message-Oriented Transports . . . . . . . . . . .  82
         6.6.1.4.  Tunneled Transports . . . . . . . . . . . . . . .  82
       6.6.2.  Framing Header  . . . . . . . . . . . . . . . . . . .  83
       6.6.3.  Simple Reliability  . . . . . . . . . . . . . . . . .  84
         6.6.3.1.  Stop and Wait Sender Algorithm  . . . . . . . . .  85
       6.6.4.  DTLS/UDP with SR  . . . . . . . . . . . . . . . . . .  86
       6.6.5.  TLS/TCP with FH, No-ICE . . . . . . . . . . . . . . .  86
       6.6.6.  DTLS/UDP with SR, No-ICE  . . . . . . . . . . . . . .  87
     6.7.  Fragmentation and Reassembly  . . . . . . . . . . . . . .  87
   7.  Data Storage Protocol . . . . . . . . . . . . . . . . . . . .  88
     7.1.  Data Signature Computation  . . . . . . . . . . . . . . .  90
     7.2.  Data Models . . . . . . . . . . . . . . . . . . . . . . .  91
       7.2.1.  Single Value  . . . . . . . . . . . . . . . . . . . .  91
       7.2.2.  Array . . . . . . . . . . . . . . . . . . . . . . . .  92
       7.2.3.  Dictionary  . . . . . . . . . . . . . . . . . . . . .  92
     7.3.  Access Control Policies . . . . . . . . . . . . . . . . .  93
       7.3.1.  USER-MATCH  . . . . . . . . . . . . . . . . . . . . .  93
       7.3.2.  NODE-MATCH  . . . . . . . . . . . . . . . . . . . . .  93
       7.3.3.  USER-NODE-MATCH . . . . . . . . . . . . . . . . . . .  93
       7.3.4.  NODE-MULTIPLE . . . . . . . . . . . . . . . . . . . .  94
     7.4.  Data Storage Methods  . . . . . . . . . . . . . . . . . .  94
       7.4.1.  Store . . . . . . . . . . . . . . . . . . . . . . . .  94
         7.4.1.1.  Request Definition  . . . . . . . . . . . . . . .  94
         7.4.1.2.  Response Definition . . . . . . . . . . . . . . . 100
         7.4.1.3.  Removing Values . . . . . . . . . . . . . . . . . 101
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       7.4.2.  Fetch . . . . . . . . . . . . . . . . . . . . . . . . 102
         7.4.2.1.  Request Definition  . . . . . . . . . . . . . . . 102
         7.4.2.2.  Response Definition . . . . . . . . . . . . . . . 104
       7.4.3.  Stat  . . . . . . . . . . . . . . . . . . . . . . . . 105
         7.4.3.1.  Request Definition  . . . . . . . . . . . . . . . 105
         7.4.3.2.  Response Definition . . . . . . . . . . . . . . . 106
       7.4.4.  Find  . . . . . . . . . . . . . . . . . . . . . . . . 107
         7.4.4.1.  Request Definition  . . . . . . . . . . . . . . . 108
         7.4.4.2.  Response Definition . . . . . . . . . . . . . . . 108
       7.4.5.  Defining New Kinds  . . . . . . . . . . . . . . . . . 109
   8.  Certificate Store Usage . . . . . . . . . . . . . . . . . . . 110
   9.  TURN Server Usage . . . . . . . . . . . . . . . . . . . . . . 110
   10. Chord Algorithm . . . . . . . . . . . . . . . . . . . . . . . 112
     10.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 113
     10.2.  Hash Function  . . . . . . . . . . . . . . . . . . . . . 114
     10.3.  Routing  . . . . . . . . . . . . . . . . . . . . . . . . 114
     10.4.  Redundancy . . . . . . . . . . . . . . . . . . . . . . . 114
     10.5.  Joining  . . . . . . . . . . . . . . . . . . . . . . . . 115
     10.6.  Routing Attaches . . . . . . . . . . . . . . . . . . . . 116
     10.7.  Updates  . . . . . . . . . . . . . . . . . . . . . . . . 117
       10.7.1.  Handling Neighbor Failures . . . . . . . . . . . . . 118
       10.7.2.  Handling Finger Table Entry Failure  . . . . . . . . 119
       10.7.3.  Receiving Updates  . . . . . . . . . . . . . . . . . 119
       10.7.4.  Stabilization  . . . . . . . . . . . . . . . . . . . 120
         10.7.4.1.  Updating the Neighbor Table  . . . . . . . . . . 120
         10.7.4.2.  Refreshing the Finger Table  . . . . . . . . . . 121
         10.7.4.3.  Adjusting Finger Table Size  . . . . . . . . . . 122
         10.7.4.4.  Detecting Partitioning . . . . . . . . . . . . . 122
     10.8.  Route Query  . . . . . . . . . . . . . . . . . . . . . . 123
     10.9.  Leaving  . . . . . . . . . . . . . . . . . . . . . . . . 123
   11. Enrollment and Bootstrap  . . . . . . . . . . . . . . . . . . 124
     11.1.  Overlay Configuration  . . . . . . . . . . . . . . . . . 124
       11.1.1.  RELAX NG Grammar . . . . . . . . . . . . . . . . . . 132
     11.2.  Discovery through Configuration Server . . . . . . . . . 134
     11.3.  Credentials  . . . . . . . . . . . . . . . . . . . . . . 135
       11.3.1.  Self-Generated Credentials . . . . . . . . . . . . . 137
     11.4.  Contacting a Bootstrap Node  . . . . . . . . . . . . . . 138
   12. Message Flow Example  . . . . . . . . . . . . . . . . . . . . 138
   13. Security Considerations . . . . . . . . . . . . . . . . . . . 144
     13.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 144
     13.2.  Attacks on P2P Overlays  . . . . . . . . . . . . . . . . 145
     13.3.  Certificate-Based Security . . . . . . . . . . . . . . . 145
     13.4.  Shared-Secret Security . . . . . . . . . . . . . . . . . 147
     13.5.  Storage Security . . . . . . . . . . . . . . . . . . . . 147
       13.5.1.  Authorization  . . . . . . . . . . . . . . . . . . . 147
       13.5.2.  Distributed Quota  . . . . . . . . . . . . . . . . . 148
       13.5.3.  Correctness  . . . . . . . . . . . . . . . . . . . . 148
       13.5.4.  Residual Attacks . . . . . . . . . . . . . . . . . . 149
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       7.4.2.  Fetch . . . . . . . . . . . . . . . . . . . . . . . . 102
         7.4.2.1.  Request Definition  . . . . . . . . . . . . . . . 102
         7.4.2.2.  Response Definition . . . . . . . . . . . . . . . 104
       7.4.3.  Stat  . . . . . . . . . . . . . . . . . . . . . . . . 105
         7.4.3.1.  Request Definition  . . . . . . . . . . . . . . . 105
         7.4.3.2.  Response Definition . . . . . . . . . . . . . . . 106
       7.4.4.  Find  . . . . . . . . . . . . . . . . . . . . . . . . 107
         7.4.4.1.  Request Definition  . . . . . . . . . . . . . . . 108
         7.4.4.2.  Response Definition . . . . . . . . . . . . . . . 108
       7.4.5.  Defining New Kinds  . . . . . . . . . . . . . . . . . 109
   8.  Certificate Store Usage . . . . . . . . . . . . . . . . . . . 110
   9.  TURN Server Usage . . . . . . . . . . . . . . . . . . . . . . 110
   10. Chord Algorithm . . . . . . . . . . . . . . . . . . . . . . . 112
     10.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 113
     10.2.  Hash Function  . . . . . . . . . . . . . . . . . . . . . 114
     10.3.  Routing  . . . . . . . . . . . . . . . . . . . . . . . . 114
     10.4.  Redundancy . . . . . . . . . . . . . . . . . . . . . . . 114
     10.5.  Joining  . . . . . . . . . . . . . . . . . . . . . . . . 115
     10.6.  Routing Attaches . . . . . . . . . . . . . . . . . . . . 116
     10.7.  Updates  . . . . . . . . . . . . . . . . . . . . . . . . 117
       10.7.1.  Handling Neighbor Failures . . . . . . . . . . . . . 118
       10.7.2.  Handling Finger Table Entry Failure  . . . . . . . . 119
       10.7.3.  Receiving Updates  . . . . . . . . . . . . . . . . . 119
       10.7.4.  Stabilization  . . . . . . . . . . . . . . . . . . . 120
         10.7.4.1.  Updating the Neighbor Table  . . . . . . . . . . 120
         10.7.4.2.  Refreshing the Finger Table  . . . . . . . . . . 121
         10.7.4.3.  Adjusting Finger Table Size  . . . . . . . . . . 122
         10.7.4.4.  Detecting Partitioning . . . . . . . . . . . . . 122
     10.8.  Route Query  . . . . . . . . . . . . . . . . . . . . . . 123
     10.9.  Leaving  . . . . . . . . . . . . . . . . . . . . . . . . 123
   11. Enrollment and Bootstrap  . . . . . . . . . . . . . . . . . . 124
     11.1.  Overlay Configuration  . . . . . . . . . . . . . . . . . 124
       11.1.1.  RELAX NG Grammar . . . . . . . . . . . . . . . . . . 132
     11.2.  Discovery through Configuration Server . . . . . . . . . 134
     11.3.  Credentials  . . . . . . . . . . . . . . . . . . . . . . 135
       11.3.1.  Self-Generated Credentials . . . . . . . . . . . . . 137
     11.4.  Contacting a Bootstrap Node  . . . . . . . . . . . . . . 138
   12. Message Flow Example  . . . . . . . . . . . . . . . . . . . . 138
   13. Security Considerations . . . . . . . . . . . . . . . . . . . 144
     13.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . 144
     13.2.  Attacks on P2P Overlays  . . . . . . . . . . . . . . . . 145
     13.3.  Certificate-Based Security . . . . . . . . . . . . . . . 145
     13.4.  Shared-Secret Security . . . . . . . . . . . . . . . . . 147
     13.5.  Storage Security . . . . . . . . . . . . . . . . . . . . 147
       13.5.1.  Authorization  . . . . . . . . . . . . . . . . . . . 147
       13.5.2.  Distributed Quota  . . . . . . . . . . . . . . . . . 148
       13.5.3.  Correctness  . . . . . . . . . . . . . . . . . . . . 148
       13.5.4.  Residual Attacks . . . . . . . . . . . . . . . . . . 149
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
     13.6.  Routing Security . . . . . . . . . . . . . . . . . . . . 149
       13.6.1.  Background . . . . . . . . . . . . . . . . . . . . . 150
       13.6.2.  Admissions Control . . . . . . . . . . . . . . . . . 150
       13.6.3.  Peer Identification and Authentication . . . . . . . 151
       13.6.4.  Protecting the Signaling . . . . . . . . . . . . . . 151
       13.6.5.  Routing Loops and DoS Attacks  . . . . . . . . . . . 152
       13.6.6.  Residual Attacks . . . . . . . . . . . . . . . . . . 152
   14. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 153
     14.1.  Well-Known URI Registration  . . . . . . . . . . . . . . 153
     14.2.  Port Registrations . . . . . . . . . . . . . . . . . . . 153
     14.3.  Overlay Algorithm Types  . . . . . . . . . . . . . . . . 154
     14.4.  Access Control Policies  . . . . . . . . . . . . . . . . 154
     14.5.  Application-ID . . . . . . . . . . . . . . . . . . . . . 155
     14.6.  Data Kind-ID . . . . . . . . . . . . . . . . . . . . . . 155
     14.7.  Data Model . . . . . . . . . . . . . . . . . . . . . . . 156
     14.8.  Message Codes  . . . . . . . . . . . . . . . . . . . . . 156
     14.9.  Error Codes  . . . . . . . . . . . . . . . . . . . . . . 158
     14.10. Overlay Link Types . . . . . . . . . . . . . . . . . . . 159
     14.11. Overlay Link Protocols . . . . . . . . . . . . . . . . . 159
     14.12. Forwarding Options . . . . . . . . . . . . . . . . . . . 160
     14.13. Probe Information Types  . . . . . . . . . . . . . . . . 160
     14.14. Message Extensions . . . . . . . . . . . . . . . . . . . 161
     14.15. Reload URI Scheme  . . . . . . . . . . . . . . . . . . . 161
       14.15.1.  URI Registration  . . . . . . . . . . . . . . . . . 162
     14.16. Media Type Registration  . . . . . . . . . . . . . . . . 162
     14.17. XML Namespace Registration . . . . . . . . . . . . . . . 163
       14.17.1.  Config URL  . . . . . . . . . . . . . . . . . . . . 164
       14.17.2.  Config Chord URL  . . . . . . . . . . . . . . . . . 164
   15. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . 164
   16. References  . . . . . . . . . . . . . . . . . . . . . . . . . 165
     16.1.  Normative References . . . . . . . . . . . . . . . . . . 165
     16.2.  Informative References . . . . . . . . . . . . . . . . . 167
   Appendix A.  Routing Alternatives . . . . . . . . . . . . . . . . 171
     A.1.  Iterative vs. Recursive . . . . . . . . . . . . . . . . . 171
     A.2.  Symmetric vs. Forward Response  . . . . . . . . . . . . . 171
     A.3.  Direct Response . . . . . . . . . . . . . . . . . . . . . 172
     A.4.  Relay Peers . . . . . . . . . . . . . . . . . . . . . . . 173
     A.5.  Symmetric Route Stability . . . . . . . . . . . . . . . . 173
   Appendix B.  Why Clients? . . . . . . . . . . . . . . . . . . . . 174
     B.1.  Why Not Only Peers? . . . . . . . . . . . . . . . . . . . 174
     B.2.  Clients as Application-Level Agents . . . . . . . . . . . 175
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
     13.6.  Routing Security . . . . . . . . . . . . . . . . . . . . 149
       13.6.1.  Background . . . . . . . . . . . . . . . . . . . . . 150
       13.6.2.  Admissions Control . . . . . . . . . . . . . . . . . 150
       13.6.3.  Peer Identification and Authentication . . . . . . . 151
       13.6.4.  Protecting the Signaling . . . . . . . . . . . . . . 151
       13.6.5.  Routing Loops and DoS Attacks  . . . . . . . . . . . 152
       13.6.6.  Residual Attacks . . . . . . . . . . . . . . . . . . 152
   14. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 153
     14.1.  Well-Known URI Registration  . . . . . . . . . . . . . . 153
     14.2.  Port Registrations . . . . . . . . . . . . . . . . . . . 153
     14.3.  Overlay Algorithm Types  . . . . . . . . . . . . . . . . 154
     14.4.  Access Control Policies  . . . . . . . . . . . . . . . . 154
     14.5.  Application-ID . . . . . . . . . . . . . . . . . . . . . 155
     14.6.  Data Kind-ID . . . . . . . . . . . . . . . . . . . . . . 155
     14.7.  Data Model . . . . . . . . . . . . . . . . . . . . . . . 156
     14.8.  Message Codes  . . . . . . . . . . . . . . . . . . . . . 156
     14.9.  Error Codes  . . . . . . . . . . . . . . . . . . . . . . 158
     14.10. Overlay Link Types . . . . . . . . . . . . . . . . . . . 159
     14.11. Overlay Link Protocols . . . . . . . . . . . . . . . . . 159
     14.12. Forwarding Options . . . . . . . . . . . . . . . . . . . 160
     14.13. Probe Information Types  . . . . . . . . . . . . . . . . 160
     14.14. Message Extensions . . . . . . . . . . . . . . . . . . . 161
     14.15. Reload URI Scheme  . . . . . . . . . . . . . . . . . . . 161
       14.15.1.  URI Registration  . . . . . . . . . . . . . . . . . 162
     14.16. Media Type Registration  . . . . . . . . . . . . . . . . 162
     14.17. XML Namespace Registration . . . . . . . . . . . . . . . 163
       14.17.1.  Config URL  . . . . . . . . . . . . . . . . . . . . 164
       14.17.2.  Config Chord URL  . . . . . . . . . . . . . . . . . 164
   15. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . 164
   16. References  . . . . . . . . . . . . . . . . . . . . . . . . . 165
     16.1.  Normative References . . . . . . . . . . . . . . . . . . 165
     16.2.  Informative References . . . . . . . . . . . . . . . . . 167
   Appendix A.  Routing Alternatives . . . . . . . . . . . . . . . . 171
     A.1.  Iterative vs. Recursive . . . . . . . . . . . . . . . . . 171
     A.2.  Symmetric vs. Forward Response  . . . . . . . . . . . . . 171
     A.3.  Direct Response . . . . . . . . . . . . . . . . . . . . . 172
     A.4.  Relay Peers . . . . . . . . . . . . . . . . . . . . . . . 173
     A.5.  Symmetric Route Stability . . . . . . . . . . . . . . . . 173
   Appendix B.  Why Clients? . . . . . . . . . . . . . . . . . . . . 174
     B.1.  Why Not Only Peers? . . . . . . . . . . . . . . . . . . . 174
     B.2.  Clients as Application-Level Agents . . . . . . . . . . . 175
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document defines REsource LOcation And Discovery (RELOAD), a peer-to-peer (P2P) signaling protocol for use on the Internet. RELOAD provides a generic, self-organizing overlay network service, allowing nodes to route messages to other nodes and to store and retrieve data in the overlay. RELOAD provides several features that are critical for a successful P2P protocol for the Internet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档定义了资源定位和发现（RELOAD），这是一种用于Internet的对等（P2P）信令协议。RELOAD提供了一种通用的自组织覆盖网络服务，允许节点将消息路由到其他节点，并在覆盖中存储和检索数据。RELOAD提供了几个功能，这些功能对于成功实现Internet P2P协议至关重要：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Framework: A P2P network will often be established among a set of peers that do not trust each other. RELOAD leverages a central enrollment server to provide credentials for each peer, which can then be used to authenticate each operation. This greatly reduces the possible attack surface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全框架：P2P网络通常在一组互不信任的对等点之间建立。RELOAD利用中央注册服务器为每个对等方提供凭据，然后可以使用凭据对每个操作进行身份验证。这大大减少了可能的攻击面。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage Model: RELOAD is designed to support a variety of applications, including P2P multimedia communications with the Session Initiation Protocol (SIP) [SIP-RELOAD]. RELOAD allows the definition of new application usages, each of which can define its own data types, along with the rules for their use. This allows RELOAD to be used with new applications through a simple documentation process that supplies the details for each application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用模型：RELOAD设计用于支持各种应用程序，包括使用会话启动协议（SIP）[SIP-RELOAD]的P2P多媒体通信。RELOAD允许定义新的应用程序用法，每个应用程序都可以定义自己的数据类型及其使用规则。这允许通过提供每个应用程序详细信息的简单文档过程，将重新加载用于新应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT Traversal: RELOAD is designed to function in environments where many, if not most, of the nodes are behind NATs or firewalls. Operations for NAT traversal are part of the base design, including using Interactive Connectivity Establishment (ICE) [RFC5245] to establish new RELOAD or application protocol connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT遍历：重载设计用于许多（如果不是大多数的话）节点位于NAT或防火墙后面的环境中。NAT穿越操作是基本设计的一部分，包括使用交互式连接建立（ICE）[RFC5245]建立新的重新加载或应用程序协议连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optimized Routing: The very nature of overlay algorithms introduces a requirement that peers participating in the P2P network route requests on behalf of other peers in the network. This introduces a load on those other peers in the form of bandwidth and processing power. RELOAD has been defined with a simple, lightweight forwarding header, thus minimizing the amount of effort for intermediate peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
优化路由：覆盖算法的本质要求参与P2P网络的节点代表网络中的其他节点路由请求。这将以带宽和处理能力的形式给其他对等方带来负载。RELOAD定义了一个简单、轻量级的转发头，从而最大限度地减少了中间对等方的工作量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Pluggable Overlay Algorithms: RELOAD has been designed with an abstract interface to the overlay layer to simplify implementing a variety of structured (e.g., distributed hash tables (DHTs)) and unstructured overlay algorithms. The idea here is that RELOAD provides a generic structure that can fit most types of overlay topologies (ring, hyperspace, etc.). To instantiate an actual network, you combine RELOAD with a specific overlay algorithm, which defines how to construct the overlay topology and route messages efficiently within it. This specification also defines
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可插拔覆盖算法：RELOAD设计了覆盖层的抽象接口，以简化各种结构化（如分布式哈希表（DHT））和非结构化覆盖算法的实现。这里的想法是，重载提供了一种通用结构，可以适合大多数类型的覆盖拓扑（环形、超空间等）。要实例化实际网络，可以将重新加载与特定的覆盖算法相结合，该算法定义了如何构造覆盖拓扑并在其中高效地路由消息。本规范还定义了
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
how RELOAD is used with the Chord-based [Chord] DHT algorithm, which is mandatory to implement. Specifying a default &#34;mandatory-to-implement&#34; overlay algorithm promotes interoperability, while extensibility allows selection of overlay algorithms optimized for a particular application.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
重载是如何与基于Chord的[Chord]DHT算法一起使用的，这是必须实现的。指定默认的“强制实现”覆盖算法可促进互操作性，而可扩展性允许选择针对特定应用程序优化的覆盖算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Support for Clients: RELOAD clients differ from RELOAD peers primarily in that they do not store information on behalf of other nodes in the overlay. Rather, they use the overlay only to locate users and resources, as well as to store information and to contact other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对客户机的支持：重新加载客户机与重新加载对等机的主要区别在于，它们不代表覆盖中的其他节点存储信息。相反，它们只使用覆盖来定位用户和资源，以及存储信息和联系其他节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These properties were designed specifically to meet the requirements for a P2P protocol to support SIP. This document defines the base protocol for the distributed storage and location service, as well as critical usage for NAT traversal. The SIP Usage itself is described separately in [SIP-RELOAD]. RELOAD is not limited to usage by SIP and could serve as a tool for supporting other P2P applications with similar needs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些属性是专门为满足支持SIP的P2P协议的要求而设计的。本文档定义了分布式存储和位置服务的基本协议，以及NAT遍历的关键用法。SIP使用本身在[SIP-RELOAD]中单独描述。RELOAD不仅限于SIP的使用，还可以作为支持其他具有类似需求的P2P应用程序的工具。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Basic Setting
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 基本设置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In this section, we provide a brief overview of the operational setting for RELOAD. A RELOAD Overlay Instance consists of a set of nodes arranged in a partly connected graph. Each node in the overlay is assigned a numeric Node-ID for the lifetime of the node, which, together with the specific overlay algorithm in use, determines its position in the graph and the set of nodes it connects to. The Node-ID is also tightly coupled to the certificate (see Section 13.3). The figure below shows a trivial example which isn&#39;t drawn from any particular overlay algorithm, but was chosen for convenience of representation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本节中，我们简要概述了重新加载的操作设置。重载覆盖实例由一组节点组成，这些节点排列在一个部分连接的图中。覆盖中的每个节点在节点的生存期内都分配了一个数字节点ID，该ID与使用的特定覆盖算法一起确定其在图形中的位置及其连接到的节点集。节点ID也与证书紧密耦合（参见第13.3节）。下图显示了一个简单的示例，它不是从任何特定的覆盖算法中提取的，而是为了便于表示而选择的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      +--------+              +--------+              +--------+
      | Node 10|--------------| Node 20|--------------| Node 30|
      +--------+              +--------+              +--------+
          |                       |                       |
          |                       |                       |
      +--------+              +--------+              +--------+
      | Node 40|--------------| Node 50|--------------| Node 60|
      +--------+              +--------+              +--------+
          |                       |                       |
          |                       |                       |
      +--------+              +--------+              +--------+
      | Node 70|--------------| Node 80|--------------| Node 90|
      +--------+              +--------+              +--------+
                                  |
                                  |
                              +--------+
                              | Node 85|
                              |(Client)|
                              +--------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      +--------+              +--------+              +--------+
      | Node 10|--------------| Node 20|--------------| Node 30|
      +--------+              +--------+              +--------+
          |                       |                       |
          |                       |                       |
      +--------+              +--------+              +--------+
      | Node 40|--------------| Node 50|--------------| Node 60|
      +--------+              +--------+              +--------+
          |                       |                       |
          |                       |                       |
      +--------+              +--------+              +--------+
      | Node 70|--------------| Node 80|--------------| Node 90|
      +--------+              +--------+              +--------+
                                  |
                                  |
                              +--------+
                              | Node 85|
                              |(Client)|
                              +--------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the graph is not fully connected, when a node wants to send a message to another node, it may need to route it through the network. For instance, Node 10 can talk directly to nodes 20 and 40, but not to Node 70. In order to send a message to Node 70, it would first send it to Node 40, with instructions to pass it along to Node 70. Different overlay algorithms will have different connectivity graphs, but the general idea behind all of them is to allow any node in the graph to efficiently reach every other node within a small number of hops.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于图形未完全连接，当一个节点想要向另一个节点发送消息时，它可能需要通过网络路由消息。例如，节点10可以直接与节点20和40通话，但不能与节点70通话。为了将消息发送到节点70，它将首先将其发送到节点40，并指示将其传递到节点70。不同的覆盖算法将具有不同的连通图，但所有这些算法背后的总体思想是允许图中的任何节点在少量的跳数内有效地到达每个其他节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RELOAD network is not only a messaging network. It is also a storage network, albeit one designed for small-scale transient storage rather than for bulk storage of large objects. Records are stored under numeric addresses, called Resource-IDs, which occupy the same space as node identifiers. Peers are responsible for storing the data associated with some set of addresses, as determined by their Node-ID. For instance, we might say that every peer is responsible for storing any data value which has an address less than or equal to its own Node-ID, but greater than the next lowest Node-ID. Thus, Node 20 would be responsible for storing values 11-20.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载网络不仅仅是一个消息传递网络。它也是一个存储网络，尽管它是为小规模瞬态存储而设计的，而不是为大对象的大容量存储而设计的。记录存储在称为资源ID的数字地址下，这些地址与节点标识符占用相同的空间。对等方负责存储由其节点ID确定的与某组地址相关联的数据。例如，我们可以说，每个对等方负责存储地址小于或等于其自身节点ID但大于下一个最低节点ID的任何数据值。因此，节点20将负责存储值11-20。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also supports clients. These are nodes which have Node-IDs but do not participate in routing or storage. For instance, in the figure above, Node 85 is a client. It can route to the rest of the RELOAD network via Node 80, but no other node will route through it, and Node 90 is still responsible for addresses in the range [81..90]. We refer to non-client nodes as peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载还支持客户端。这些节点具有节点ID，但不参与路由或存储。例如，在上图中，节点85是客户端。它可以通过节点80路由到重新加载网络的其余部分，但没有其他节点将通过它路由，并且节点90仍然负责范围[81..90]内的地址。我们将非客户端节点称为对等节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Other applications (for instance, SIP) can be defined on top of RELOAD and can use these two basic RELOAD services to provide their own services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其他应用程序（例如，SIP）可以在重新加载之上定义，并可以使用这两个基本的重新加载服务来提供自己的服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Architecture
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 建筑学
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is fundamentally an overlay network. The following figure shows the layered RELOAD architecture.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载基本上是一个覆盖网络。下图显示了分层重新加载体系结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
Application
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
应用
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        +-------+  +-------+
        | SIP   |  | XMPP  |  ...
        | Usage |  | Usage |
        +-------+  +-------+
    ------------------------------------ Messaging Service Boundary
    +------------------+     +---------+
    |     Message      |&lt;---&gt;| Storage |
    |    Transport     |     +---------+
    +------------------+           ^
           ^       ^               |
           |       v               v
           |     +-------------------+
           |     |    Topology       |
           |     |    Plug-in        |
           |     +-------------------+
           |         ^
           v         v
        +------------------+
        |  Forwarding &amp;    |
        | Link Management  |
        +------------------+
    ------------------------------------ Overlay Link Service Boundary
         +-------+  +-------+
         |TLS    |  |DTLS   |  ...
         |Overlay|  |Overlay|
         |Link   |  |Link   |
         +-------+  +-------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        +-------+  +-------+
        | SIP   |  | XMPP  |  ...
        | Usage |  | Usage |
        +-------+  +-------+
    ------------------------------------ Messaging Service Boundary
    +------------------+     +---------+
    |     Message      |&lt;---&gt;| Storage |
    |    Transport     |     +---------+
    +------------------+           ^
           ^       ^               |
           |       v               v
           |     +-------------------+
           |     |    Topology       |
           |     |    Plug-in        |
           |     +-------------------+
           |         ^
           v         v
        +------------------+
        |  Forwarding &amp;    |
        | Link Management  |
        +------------------+
    ------------------------------------ Overlay Link Service Boundary
         +-------+  +-------+
         |TLS    |  |DTLS   |  ...
         |Overlay|  |Overlay|
         |Link   |  |Link   |
         +-------+  +-------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major components of RELOAD are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载的主要组成部分包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage Layer: Each application defines a RELOAD Usage, which is a set of data Kinds and behaviors which describe how to use the services provided by RELOAD. These usages all talk to RELOAD through a common Message Transport Service.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用层：每个应用程序定义一个重载使用，这是一组描述如何使用重载提供的服务的数据类型和行为。这些用法都是通过一个公共消息传输服务来重新加载的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message Transport: Handles end-to-end reliability, manages request state for the usages, and forwards Store and Fetch operations to the Storage component. It delivers message responses to the component initiating the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息传输：处理端到端的可靠性，管理使用的请求状态，并将存储和获取操作转发到存储组件。它向发起请求的组件发送消息响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Storage: The Storage component is responsible for processing messages relating to the storage and retrieval of data. It talks directly to the Topology Plug-in to manage data replication and migration, and it talks to the Message Transport component to send and receive messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储：存储组件负责处理与数据存储和检索相关的消息。它直接与拓扑插件对话以管理数据复制和迁移，并与消息传输组件对话以发送和接收消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Topology Plug-in: The Topology Plug-in is responsible for implementing the specific overlay algorithm being used. It uses the Message Transport component to send and receive overlay management messages, the Storage component to manage data replication, and the Forwarding Layer to control hop-by-hop message forwarding. This component superficially parallels conventional routing algorithms, but is more tightly coupled to the Forwarding Layer, because there is no single &#34;Routing Table&#34; equivalent used by all overlay algorithms. The Topology Plug-in has two functions: constructing the local forwarding instructions and selecting the operational topology (i.e., creating links by sending overlay management messages).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拓扑插件：拓扑插件负责实现所使用的特定覆盖算法。它使用消息传输组件发送和接收覆盖管理消息，使用存储组件管理数据复制，使用转发层控制逐跳消息转发。该组件表面上与传统路由算法并行，但与转发层的耦合更紧密，因为所有覆盖算法都不使用单一的“路由表”。拓扑插件有两个功能：构造本地转发指令和选择操作拓扑（即，通过发送覆盖管理消息创建链接）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forwarding and Link Management Layer: Stores and implements the Routing Table by providing packet forwarding services between nodes. It also handles establishing new links between nodes, including setting up connections for overlay links across NATs using ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发和链路管理层：通过提供节点间的数据包转发服务来存储和实现路由表。它还负责在节点之间建立新的链接，包括使用ICE为NAT之间的覆盖链接建立连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Link Layer: Responsible for actually transporting traffic directly between nodes. Transport Layer Security (TLS) [RFC5246] and Datagram Transport Layer Security (DTLS) [RFC6347] are the currently defined &#34;overlay link layer&#34; protocols used by RELOAD for hop-by-hop communication. Each such protocol includes the appropriate provisions for per-hop framing and hop-by-hop ACKs needed by unreliable underlying transports. New protocols can be defined, as described in Sections 6.6.1 and 11.1. As this document defines only TLS and DTLS, we use those terms throughout the remainder of the document with the understanding that some future specification may add new overlay link layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖链路层：负责直接在节点之间传输通信量。传输层安全性（TLS）[RFC5246]和数据报传输层安全性（DTLS）[RFC6347]是当前定义的“覆盖链路层”协议，RELOAD用于逐跳通信。每个这样的协议都包括不可靠的底层传输所需的每跳帧和逐跳ack的适当规定。如第6.6.1节和第11.1节所述，可以定义新的协议。由于本文档仅定义TLS和DTL，因此我们在本文档的其余部分使用这些术语，并理解未来的一些规范可能会添加新的覆盖链接层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To further clarify the roles of the various layers, the following figure parallels the architecture with each layer&#39;s role from an overlay perspective and implementation layer in the Internet:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了进一步阐明各层的角色，下图从覆盖层和Internet中的实现层的角度将架构与各层的角色进行了对比：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    Internet    | Internet Model  |
    Model       |   Equivalent    |          Reload
                |   in Overlay    |       Architecture
   -------------+-----------------+------------------------------------
                |                 |    +-------+  +-------+
                |  Application    |    | SIP   |  | XMPP  |  ...
                |                 |    | Usage |  | Usage |
                |                 |    +-------+  +-------+
                |                 |  ----------------------------------
                |                 |+------------------+     +---------+
                |   Transport     ||     Message      |&lt;---&gt;| Storage |
                |                 ||    Transport     |     +---------+
                |                 |+------------------+           ^
                |                 |       ^       ^               |
                |                 |       |       v               v
   Application  |                 |       |     +-------------------+
                |   (Routing)     |       |     |     Topology      |
                |                 |       |     |     Plug-in       |
                |                 |       |     +-------------------+
                |                 |       |         ^
                |                 |       v         v
                |    Network      |    +------------------+
                |                 |    |  Forwarding &amp;    |
                |                 |    | Link Management  |
                |                 |    +------------------+
                |                 |  ----------------------------------
   Transport    |      Link       |     +-------+  +------+
                |                 |     |TLS    |  |DTLS  |  ...
                |                 |     +-------+  +------+
   -------------+-----------------+------------------------------------
     Network    |
                |
       Link     |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    Internet    | Internet Model  |
    Model       |   Equivalent    |          Reload
                |   in Overlay    |       Architecture
   -------------+-----------------+------------------------------------
                |                 |    +-------+  +-------+
                |  Application    |    | SIP   |  | XMPP  |  ...
                |                 |    | Usage |  | Usage |
                |                 |    +-------+  +-------+
                |                 |  ----------------------------------
                |                 |+------------------+     +---------+
                |   Transport     ||     Message      |&lt;---&gt;| Storage |
                |                 ||    Transport     |     +---------+
                |                 |+------------------+           ^
                |                 |       ^       ^               |
                |                 |       |       v               v
   Application  |                 |       |     +-------------------+
                |   (Routing)     |       |     |     Topology      |
                |                 |       |     |     Plug-in       |
                |                 |       |     +-------------------+
                |                 |       |         ^
                |                 |       v         v
                |    Network      |    +------------------+
                |                 |    |  Forwarding &amp;    |
                |                 |    | Link Management  |
                |                 |    +------------------+
                |                 |  ----------------------------------
   Transport    |      Link       |     +-------+  +------+
                |                 |     |TLS    |  |DTLS  |  ...
                |                 |     +-------+  +------+
   -------------+-----------------+------------------------------------
     Network    |
                |
       Link     |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition to the above components, nodes may communicate with a central provisioning infrastructure (not shown) to get configuration information, authentication credentials, and the initial set of nodes to communicate with to join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除了上述组件之外，节点还可以与中央供应基础设施（未显示）通信，以获取配置信息、身份验证凭据以及与之通信以加入覆盖的初始节点集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.1. Usage Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.1. 使用层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The top layer, called the Usage Layer, has application usages, such as the SIP Registration Usage [SIP-RELOAD], that use the abstract Message Transport Service provided by RELOAD. The goal of this layer is to implement application-specific usages of the generic overlay services provided by RELOAD. The Usage defines how a specific application maps its data into something that can be stored in the overlay, where to store the data, how to secure the data, and finally how applications can retrieve and use the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
顶层称为使用层，具有应用程序使用，例如SIP注册使用[SIP-RELOAD]，使用RELOAD提供的抽象消息传输服务。这一层的目标是实现由RELOAD提供的通用覆盖服务的特定于应用程序的用法。用法定义了特定应用程序如何将其数据映射到可存储在覆盖中的内容、数据存储的位置、数据的安全性，以及应用程序如何检索和使用数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The architecture diagram shows both a SIP Usage and an XMPP Usage. A single application may require multiple usages; for example, a voicemail feature in a softphone application that stores links to the messages in the overlay would require a different usage than the type of rendezvous service of XMPP or SIP. A usage may define multiple Kinds of data that are stored in the overlay and may also rely on Kinds originally defined by other usages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
架构图显示了SIP使用情况和XMPP使用情况。单个应用可能需要多次使用；例如，软电话应用程序中存储到覆盖中消息的链接的语音邮件功能需要不同于XMPP或SIP的会合服务类型的使用。一种用法可以定义存储在覆盖中的多种类型的数据，也可以依赖于最初由其他用法定义的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the security and storage policies for each Kind are dictated by the usage defining the Kind, the usages may be coupled with the Storage component to provide security policy enforcement and to implement appropriate storage strategies according to the needs of the usage. The exact implementation of such an interface is outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于每种类型的安全和存储策略由定义该类型的使用情况决定，因此这些使用情况可以与存储组件耦合以提供安全策略实施，并根据使用情况的需要实施适当的存储策略。此类接口的确切实现不在本规范的范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.2. Message Transport
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.2. 消息传输
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Message Transport component provides a generic message routing service for the overlay. The Message Transport layer is responsible for end-to-end message transactions. Each peer is identified by its location in the overlay, as determined by its Node-ID. A component that is a client of the Message Transport can perform two basic functions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息传输组件为覆盖提供通用消息路由服务。消息传输层负责端到端消息事务。每个对等点都由其在覆盖中的位置标识，由其节点ID确定。作为消息传输客户端的组件可以执行两个基本功能：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Send a message to a given peer specified by Node-ID or to the peer responsible for a particular Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 向节点ID指定的给定对等方或负责特定资源ID的对等方发送消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Receive messages that other peers sent to a Node-ID or Resource-ID for which the receiving peer is responsible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 接收其他对等方发送给接收对等方负责的节点ID或资源ID的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All usages rely on the Message Transport component to send and receive messages from peers. For instance, when a usage wants to store data, it does so by sending Store requests. Note that the Storage component and the Topology Plug-in are themselves clients of the Message Transport, because they need to send and receive messages from other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有用法都依赖于消息传输组件从对等方发送和接收消息。例如，当用户希望存储数据时，它通过发送存储请求来实现。请注意，存储组件和拓扑插件本身就是消息传输的客户端，因为它们需要从其他对等方发送和接收消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Message Transport Service is responsible for end-to-end reliability, which is accomplished by timer-based retransmissions. Unlike the Internet transport layer, however, this layer does not provide congestion control. RELOAD is a request-response protocol, with no more than two pairs of request-response messages used in typical transactions between pairs of nodes; therefore, there are no opportunities to observe and react to end-to-end congestion. As with all Internet applications, implementers are strongly discouraged from writing applications that react to loss by immediately retrying the transaction.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息传输服务负责端到端的可靠性，这是通过基于计时器的重新传输实现的。但是，与Internet传输层不同，该层不提供拥塞控制。RELOAD是一种请求-响应协议，在节点对之间的典型事务中使用的请求-响应消息不超过两对；因此，没有机会观察和应对端到端拥塞。与所有Internet应用程序一样，强烈建议实现者不要编写通过立即重试事务来应对丢失的应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Message Transport Service is similar to those described as providing &#34;key-based routing&#34; (KBR) [wikiKBR], although as RELOAD supports different overlay algorithms (including non-DHT overlay algorithms) that calculate keys (storage indices, not encryption keys) in different ways, the actual interface needs to accept Resource Names rather than actual keys.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息传输服务与被描述为提供“基于密钥的路由”（KBR）[wikiKBR]的服务类似，尽管as RELOAD支持以不同方式计算密钥（存储索引，而非加密密钥）的不同覆盖算法（包括非DHT覆盖算法），实际接口需要接受资源名称而不是实际键。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Link Management layers are responsible for maintaining the overlay in the face of changes in the available nodes and underlying network supporting the overlay (the Internet). They also handle congestion control between overlay neighbors, and exchange routing updates and data replicas in addition to forwarding end-to-end messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发和链路管理层负责在可用节点和支持覆盖的底层网络（Internet）发生变化时维护覆盖。除了转发端到端消息外，它们还处理覆盖邻居之间的拥塞控制，以及交换路由更新和数据副本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Real-world experience has shown that a fixed timeout for the end-to-end retransmission timer is sufficient for practical overlay networks. This timer is adjustable via the overlay configuration. As the overlay configuration can be rapidly updated, this value could be dynamically adjusted at coarse time scales, although algorithms for determining how to accomplish this are beyond the scope of this specification. In many cases, however, other means of improving network performance, such as having the Topology Plug-in remove lossy links from use in overlay routing or reducing the overall hop count of end-to-end paths, will be more effective than simply increasing the retransmission timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现实世界的经验表明，对于实际的覆盖网络，端到端重传计时器的固定超时就足够了。该定时器可通过叠加配置进行调整。由于覆盖配置可以快速更新，因此可以在粗略的时间尺度上动态调整该值，尽管用于确定如何实现这一点的算法超出了本规范的范围。然而，在许多情况下，提高网络性能的其他方法，例如让拓扑插件移除覆盖路由中使用的有损链路或减少端到端路径的总跳数，将比简单地增加重传计时器更有效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.3. Storage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.3. 存储
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the major functions of RELOAD is storage of data, that is, allowing nodes to store data in the overlay and to retrieve data stored by other nodes or by themselves. The Storage component is responsible for processing data storage and retrieval messages. For instance, the Storage component might receive a Store request for a given resource from the Message Transport. It would then query the appropriate usage before storing the data value(s) in its local data store and sending a response to the Message Transport for delivery to the requesting node. Typically, these messages will come from other
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载的主要功能之一是存储数据，即允许节点在覆盖中存储数据，并检索由其他节点或自身存储的数据。存储组件负责处理数据存储和检索消息。例如，存储组件可能会从消息传输接收对给定资源的存储请求。然后，在将数据值存储在其本地数据存储中并向消息传输发送响应以交付给请求节点之前，它将查询适当的使用情况。通常，这些消息将来自其他用户
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
nodes, but depending on the overlay topology, a node might be responsible for storing data for itself as well, especially if the overlay is small.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点，但取决于覆盖拓扑，节点可能也负责为自己存储数据，尤其是覆盖较小时。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer&#39;s Node-ID determines the set of resources that it will be responsible for storing. However, the exact mapping between these is determined by the overlay algorithm in use. The Storage component will only receive a Store request from the Message Transport if this peer is responsible for that Resource-ID. The Storage component is notified by the Topology Plug-in when the Resource-IDs for which it is responsible change, and the Storage component is then responsible for migrating resources to other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方的节点ID确定其将负责存储的资源集。但是，它们之间的精确映射由使用的覆盖算法确定。如果该对等方负责该资源ID，则存储组件将仅从消息传输接收存储请求。当其负责的资源ID更改时，拓扑插件会通知存储组件，然后存储组件负责将资源迁移到其他对等方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.4. Topology Plug-in
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.4. 拓扑插件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is explicitly designed to work with a variety of overlay algorithms. In order to facilitate this, the overlay algorithm implementation is provided by a Topology Plug-in so that each overlay can select an appropriate overlay algorithm that relies on the common RELOAD core protocols and code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD被明确设计为与各种覆盖算法一起工作。为了促进这一点，覆盖算法实现由拓扑插件提供，以便每个覆盖可以选择依赖于公共重新加载核心协议和代码的适当覆盖算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Topology Plug-in is responsible for maintaining the overlay algorithm Routing Table, which is consulted by the Forwarding and Link Management Layer before routing a message. When connections are made or broken, the Forwarding and Link Management Layer notifies the Topology Plug-in, which adjusts the Routing Table as appropriate. The Topology Plug-in will also instruct the Forwarding and Link Management Layer to form new connections as dictated by the requirements of the overlay algorithm Topology. The Topology Plug-in issues periodic update requests through Message Transport to maintain and update its Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拓扑插件负责维护覆盖算法路由表，转发和链路管理层在路由消息之前查阅该表。当连接建立或断开时，转发和链路管理层会通知拓扑插件，拓扑插件会根据需要调整路由表。拓扑插件还将指示转发和链路管理层根据覆盖算法拓扑的要求形成新的连接。拓扑插件通过消息传输定期发出更新请求，以维护和更新其路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As peers enter and leave, resources may be stored on different peers, so the Topology Plug-in also keeps track of which peers are responsible for which resources. As peers join and leave, the Topology Plug-in instructs the Storage component to issue resource migration requests as appropriate, in order to ensure that other peers have whatever resources they are now responsible for. The Topology Plug-in is also responsible for providing for redundant data storage to protect against loss of information in the event of a peer failure and to protect against compromised or subversive peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点进入和离开时，资源可能存储在不同的节点上，因此拓扑插件还可以跟踪哪些节点负责哪些资源。当对等点加入和离开时，拓扑插件会指示存储组件根据需要发出资源迁移请求，以确保其他对等点拥有他们现在负责的任何资源。拓扑插件还负责提供冗余数据存储，以防止对等故障时信息丢失，并防止受损或破坏性对等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.5. Forwarding and Link Management Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2.5. 转发和链路管理层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Link Management Layer is responsible for getting a message to the next peer, as determined by the Topology Plug-in. This layer establishes and maintains the network connections as needed by the Topology Plug-in. This layer is also responsible for setting up connections to other peers through NATs and firewalls using ICE, and it can elect to forward traffic using relays for NAT and firewall traversal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发和链路管理层负责将消息发送到下一个对等方，这由拓扑插件决定。该层根据拓扑插件的需要建立和维护网络连接。该层还负责通过NAT和使用ICE的防火墙建立与其他对等方的连接，并且它可以选择使用NAT和防火墙穿越的中继转发流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Congestion control is implemented at this layer to protect the Internet paths used to form the link in the overlay. Additionally, retransmission is performed to improve the reliability of end-to-end transactions. The relation of this layer to the Message Transport Layer can be likened to the relation of the link-level congestion control and retransmission in modern wireless networks ` to Internet transport protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在这一层实施拥塞控制，以保护用于在覆盖层中形成链路的Internet路径。此外，执行重传以提高端到端事务的可靠性。该层与消息传输层的关系可以比作现代无线网络中链路级拥塞控制和重传与因特网传输协议的关系。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This layer provides a generic interface that allows the Topology Plug-in to control the overlay and resource operations and messages. Because each overlay algorithm is defined and functions differently, we generically refer to the table of other peers that the overlay algorithm maintains and uses to route requests as a Routing Table. The Topology Plug-in actually owns the Routing Table, and forwarding decisions are made by querying the Topology Plug-in for the next hop for a particular Node-ID or Resource-ID. If this node is the destination of the message, the message is delivered to the Message Transport.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该层提供一个通用接口，允许拓扑插件控制覆盖和资源操作以及消息。由于每个覆盖算法的定义和功能不同，我们通常将覆盖算法维护并用于路由请求的其他对等方的表作为路由表。拓扑插件实际上拥有路由表，转发决策是通过查询拓扑插件以获得下一跳的特定节点ID或资源ID来做出的。如果此节点是消息的目的地，则消息将传递到消息传输。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This layer also utilizes a framing header to encapsulate messages as they are forwarded along each hop. This header aids reliability congestion control, flow control, etc. It has meaning only in the context of that individual link.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该层还利用帧报头来封装消息，因为消息沿着每个跃点转发。此标头有助于可靠性、拥塞控制、流量控制等。它仅在单个链路的上下文中具有意义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding and Link Management Layer sits on top of the Overlay Link Layer protocols that carry the actual traffic. This specification defines how to use DTLS and TLS protocols to carry RELOAD messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发和链路管理层位于承载实际流量的覆盖链路层协议之上。本规范定义了如何使用DTLS和TLS协议来传输重新加载消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.3. 安全
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s security model is based on each node having one or more public key certificates. In general, these certificates will be assigned by a central server, which also assigns Node-IDs, although self-signed certificates can be used in closed networks. These credentials can be leveraged to provide communications security for RELOAD messages. RELOAD provides communications security at three levels:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD的安全模型基于具有一个或多个公钥证书的每个节点。通常，这些证书将由中央服务器分配，中央服务器也分配节点ID，尽管自签名证书可以在封闭网络中使用。可以利用这些凭据为重新加载消息提供通信安全性。重新加载在三个级别提供通信安全：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connection level: Connections between nodes are secured with TLS, DTLS, or potentially some to-be-defined future protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
连接级别：节点之间的连接由TLS、DTL或将来可能定义的协议保护。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message level: Each RELOAD message is signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息级别：每个重新加载消息都经过签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Object Level: Stored objects are signed by the creating node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对象级别：存储的对象由创建节点签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These three levels of security work together to allow nodes to verify the origin and correctness of data they receive from other nodes, even in the face of malicious activity by other nodes in the overlay. RELOAD also provides access control built on top of these communications security features. Because the peer responsible for storing a piece of data can validate the signature on the data being stored, it can determine whether or not a given operation is permitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这三个安全级别协同工作，允许节点验证从其他节点接收的数据的来源和正确性，即使在覆盖中的其他节点进行恶意活动时也是如此。RELOAD还提供了建立在这些通信安全功能之上的访问控制。因为负责存储一段数据的对等方可以验证所存储数据上的签名，所以它可以确定是否允许给定的操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also provides an optional shared-secret-based admission control feature using shared secrets and TLS pre-shared keys (PSK) or TLS Secure Remote Password (SRP). In order to form a TLS connection to any node in the overlay, a new node needs to know the shared overlay key, thus restricting access to authorized users only. This feature is used together with certificate-based access control, not as a replacement for it. It is typically used when self-signed certificates are being used but would generally not be used when the certificates were all signed by an enrollment server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD还使用共享机密和TLS预共享密钥（PSK）或TLS安全远程密码（SRP）提供可选的基于共享机密的准入控制功能。为了与覆盖中的任何节点形成TLS连接，新节点需要知道共享覆盖密钥，从而仅限制授权用户的访问。此功能与基于证书的访问控制一起使用，而不是替代它。它通常在使用自签名证书时使用，但在证书全部由注册服务器签名时通常不使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. Structure of This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.4. 本文件的结构
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The remainder of this document is structured as follows.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件其余部分的结构如下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 3 provides definitions of terms used in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第3节提供了本文件中所用术语的定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 4 provides an overview of the mechanisms used to establish and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第4节概述了用于建立和维护覆盖的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 5 provides an overview of the mechanism RELOAD provides to support other applications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第5节概述了重载提供的支持其他应用程序的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 6 defines the protocol messages that RELOAD uses to establish and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第6节定义了RELOAD用于建立和维护覆盖的协议消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 7 defines the protocol messages that are used to store and retrieve data using RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第7节定义了用于使用重载存储和检索数据的协议消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 8 defines the Certificate Store Usages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第8节定义了证书存储的用法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 9 defines the TURN Server Usage needed to locate TURN (Traversal Using Relays around NAT) servers for NAT traversal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第9节定义了查找用于NAT遍历的TURN（使用NAT周围的中继进行遍历）服务器所需的TURN服务器使用情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 10 defines a specific Topology Plug-in using a Chord-based algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第10节使用基于Chord的算法定义了特定的拓扑插件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 11 defines the mechanisms that new RELOAD nodes use to join the overlay for the first time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第11节定义了新的重新加载节点用于首次加入覆盖的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Section 12 provides an extended example.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第12节提供了一个扩展示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Requirements Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 需求语言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in RFC 2119 [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照RFC 2119[RFC2119]中所述进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 术语
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Terms in this document are defined in-line when used and are also defined below for reference. The definitions in this section use terminology and concepts that are not explained until later in the specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的术语在使用时是以直线形式定义的，以下定义仅供参考。本节中的定义使用术语和概念，这些术语和概念在本规范后面部分才会解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Admitting Peer (AP): A peer in the overlay which helps the Joining Node join the Overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接纳对等方（AP）：覆盖中的对等方，帮助加入节点加入覆盖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bootstrap Node: A network node used by Joining Nodes to help locate the Admitting Peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引导节点：一种网络节点，用于连接节点以帮助定位接纳的对等方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Client: A host that is able to store data in and retrieve data from the overlay, but does not participate in routing or data storage for the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端：能够在覆盖中存储数据和从覆盖中检索数据，但不参与覆盖的路由或数据存储的主机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Configuration Document: An XML document containing all the Overlay Parameters for one overlay instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置文档：包含一个覆盖实例的所有覆盖参数的XML文档。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Connection Table: Contains connection information for the set of nodes to which a node is directly connected, which include nodes that are not yet available for routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
连接表：包含节点直接连接到的一组节点的连接信息，其中包括尚未用于路由的节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Destination List: A list of Node-IDs, Resource-IDs, and Opaque IDs through which a message is to be routed, in strict order. A single Node-ID, Resource-ID, or Opaque ID is a trivial form of Destination List. When multiple Node-IDs are specified, a Destination List is a loose source route. The list is reduced hop by hop, and does not include the source but does include the destination.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目的地列表：节点ID、资源ID和不透明ID的列表，消息将通过这些ID按严格顺序路由。单个节点ID、资源ID或不透明ID是目标列表的一种简单形式。指定多个节点ID时，目标列表是松散源路由。列表逐跳减少，不包括源，但包括目标。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHT: A distributed hash table. A DHT is an abstract storage service realized by storing the contents of the hash table across a set of peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DHT：分布式哈希表。DHT是一种抽象存储服务，通过跨一组对等存储哈希表的内容来实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID: A generic term for any kind of identifiers in an Overlay. This document specifies an ID as being an Application-ID, a Kind-ID, a Node-ID, a transaction ID, a component ID, a response ID, a Resource-ID, or an Opaque ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ID：覆盖中任何类型标识符的通用术语。此文档将ID指定为应用程序ID、种类ID、节点ID、事务ID、组件ID、响应ID、资源ID或不透明ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joining Node (JN): A node that is attempting to become a peer in a particular Overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加入节点（JN）：试图成为特定覆盖中的对等节点的节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kind: A Kind defines a particular type of data that can be stored in the overlay. Applications define new Kinds to store the data they use. Each Kind is identified with a unique integer called a Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类：种类定义可以存储在覆盖中的特定类型的数据。应用程序定义新的类型来存储它们使用的数据。每种类型都用一个称为Kind-ID的唯一整数标识。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Kind-ID: A unique 32-bit value identifying a Kind. Kind-IDs are either private or allocated by IANA (see Section 14.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类ID：标识种类的唯一32位值。种类ID为私有或由IANA分配（见第14.6节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Maximum Request Lifetime: The maximum time a request will wait for a response. This value is equal to the value of the overlay reliability value (defined in Section 11.1) multiplied by the number of transmissions (defined in Section 6.2.1), and so defaults to 15 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大请求生存期：请求等待响应的最长时间。该值等于叠加可靠性值（定义见第11.1节）乘以传输次数（定义见第6.2.1节），因此默认为15秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node: The term &#34;node&#34; refers to a host that may be either a peer or a client. Because RELOAD uses the same protocol for both clients and peers, much of the text applies equally to both. Therefore, we use &#34;node&#34; when the text applies to both clients and peers, and we use the more specific term (i.e., &#34;client&#34; or &#34;peer&#34;) when the text applies only to clients or only to peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点：术语“节点”指的是主机，它可以是对等机或客户端。因为RELOAD对客户端和对等方使用相同的协议，所以大部分文本对这两个应用相同。因此，当文本同时适用于客户端和对等方时，我们使用“节点”，当文本仅适用于客户端或对等方时，我们使用更具体的术语（即“客户端”或“对等方”）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node-ID: A value of fixed but configurable length that uniquely identifies a node. Node-IDs of all 0s and all 1s are reserved. A value of 0 is not used in the wire protocol, but can be used to indicate an invalid node in implementations and APIs. The Node-ID of all 1s is used on the wire protocol as a wildcard.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点ID：一个固定但可配置的长度值，用于唯一标识节点。保留所有0和1的节点ID。wire协议中未使用值0，但可用于指示实现和API中的无效节点。所有1的节点ID在wire协议上用作通配符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Algorithm: An overlay algorithm defines the rules for determining which peers in an overlay store a particular piece of data and for determining a topology of interconnections amongst peers in order to find a piece of data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖算法：覆盖算法定义规则，用于确定覆盖中的哪些对等方存储特定数据段，以及确定对等方之间的互连拓扑以查找数据段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Instance: A specific overlay algorithm and the collection of peers that are collaborating to provide read and write access to it. Any number of overlay instances can be running in an IP network at a time, and each operates in isolation of the others.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖实例：一种特定的覆盖算法，以及为提供对它的读写访问而协作的对等方集合。一次可以在一个IP网络中运行任意数量的覆盖实例，并且每个实例都独立于其他实例运行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Overlay Parameters: A set of values that are shared among all nodes in an overlay. The overlay parameters are distributed in an XML document called the Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖参数：覆盖中所有节点共享的一组值。覆盖参数分布在称为配置文档的XML文档中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer: A host that is participating in the overlay. Peers are responsible for holding some portion of the data that has been stored in the overlay, and they are responsible for routing messages on behalf of other hosts as needed by the Overlay Algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等：参与覆盖的主机。对等机负责保存已存储在覆盖中的部分数据，并负责根据覆盖算法的需要代表其他主机路由消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peer Admission: The act of admitting a node (the Joining Node) into an Overlay. After the admission process is over, the Joining Node is a fully functional peer of the overlay. During the admission process, the Joining Node may need to present credentials to prove that it has sufficient authority to join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等接纳：允许节点（加入节点）进入覆盖的行为。在接纳过程结束后，加入节点是覆盖的全功能对等节点。在接纳过程期间，加入节点可能需要出示凭证以证明其具有加入覆盖的足够权限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource: An object or group of objects stored in a P2P network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
资源：存储在P2P网络中的对象或对象组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource-ID: A value that identifies some resources and which is used as a key for storing and retrieving the resource. Often this is not human friendly/readable. One way to generate a Resource-ID is by applying a mapping function to some other unique name (e.g., user name or service name) for the resource. The Resource-ID is used by the distributed database algorithm to determine the peer or peers that are responsible for storing the data for the overlay. In structured P2P networks, Resource-IDs are generally fixed length and are formed by hashing the Resource Name. In unstructured networks, Resource Names may be used directly as Resource-IDs and may be of variable length.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
资源ID：标识某些资源的值，用作存储和检索资源的键。这通常不是人性化的/可读的。生成资源ID的一种方法是将映射函数应用于资源的其他唯一名称（例如，用户名或服务名）。分布式数据库算法使用资源ID来确定负责存储覆盖数据的对等点。在结构化P2P网络中，资源ID通常是固定长度的，并通过对资源名称进行散列形成。在非结构化网络中，资源名称可以直接用作资源ID，并且可以是可变长度的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource Name: The name by which a resource is identified. In unstructured P2P networks, the Resource Name is sometimes used directly as a Resource-ID. In structured P2P networks, the Resource Name is typically mapped into a Resource-ID by using the string as the input to hash function. Structured and unstructured P2P networks are described in [RFC5694]. A SIP resource, for example, is often identified by its AOR (address-of-record), which is an example of a Resource Name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
资源名称：用于标识资源的名称。在非结构化P2P网络中，资源名称有时直接用作资源ID。在结构化P2P网络中，资源名称通常通过使用字符串作为哈希函数的输入映射到资源ID。[RFC5694]中描述了结构化和非结构化P2P网络。例如，SIP资源通常由其AOR（记录地址）标识，AOR是资源名称的一个示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Responsible Peer: The peer that is responsible for a specific resource, as defined by the Topology Plug-in algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
负责对等方：负责特定资源的对等方，由拓扑插件算法定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routing Table: The set of directly connected peers which a node can use to forward overlay messages. In normal operation, these peers will all be in the Connection Table, but not vice versa, because some peers may not yet be available for routing. Peers may send
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由表：节点可用于转发覆盖消息的一组直接连接的对等点。在正常操作中，这些对等点都将在连接表中，但反之亦然，因为有些对等点可能还不能用于路由。同行可以发送
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
messages directly to peers that are in their Connection Tables, but may forward messages to peers that are not in their Connection Table only through peers that are in the Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
消息直接发送给其连接表中的对等方，但可能仅通过路由表中的对等方将消息转发给不在其连接表中的对等方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Successor Replacement Hold-Down Time: The amount of time to wait before starting replication when a new successor is found; it defaults to 30 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
继任者替换保留时间：找到新的继任者时，在开始复制之前等待的时间量；默认为30秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Transaction ID: A randomly chosen identifier selected by the originator of a request that is used to correlate requests and responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事务ID：由请求的发起人随机选择的标识符，用于关联请求和响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Usage: The definition of a set of data structures (data Kinds) that an application wants to store in the overlay. A usage may also define a set of network protocols (Application IDs) that can be tunneled over TLS or DTLS direct connections between nodes. For example, the SIP Usage defines a SIP registration data Kind, which contains information on how to reach a SIP endpoint, and two Application IDs corresponding to the SIP and SIPS protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用法：应用程序希望存储在覆盖中的一组数据结构（数据类型）的定义。用法还可以定义一组网络协议（应用程序ID），这些协议可以通过节点之间的TLS或DTL直接连接进行隧道传输。例如，SIP用法定义了SIP注册数据类型，其中包含关于如何到达SIP端点的信息，以及与SIP和SIPS协议相对应的两个应用程序ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
User: A physical person identified by the certificates assigned to them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户：由分配给他们的证书标识的自然人。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
User Name: A name identifying a user of the overlay, typically used as a Resource Name or as a label on a resource that identifies the user owning the resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户名：标识覆盖用户的名称，通常用作资源名称或资源上标识拥有资源的用户的标签。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Overlay Management Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 覆盖管理概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most basic function of RELOAD is as a generic overlay network. Nodes need to be able to join the overlay, form connections to other nodes, and route messages through the overlay to nodes to which they are not directly connected. This section provides an overview of the mechanisms that perform these functions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载的最基本功能是作为通用覆盖网络。节点需要能够加入覆盖，形成与其他节点的连接，并通过覆盖将消息路由到它们未直接连接的节点。本节概述了执行这些功能的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. Security and Identification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. 安全和识别
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The overlay parameters are specified in a Configuration Document. Because the parameters include security-critical information, such as the certificate signing trust anchors, the Configuration Document needs to be retrieved securely. The initial Configuration Document is either initially fetched over HTTPS or manually provisioned. Subsequent Configuration Document updates are received either as a result of being refreshed periodically by the configuration server, or, more commonly, by being flood-filled through the overlay, which allows for fast propagation once an update is pushed. In the latter case, updates are via digital signatures that trace back to the initial Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖参数在配置文档中指定。由于参数包括安全关键信息，例如证书签名信任锚，因此需要安全地检索配置文档。初始配置文档最初通过HTTPS获取或手动配置。随后的配置文档更新要么是由于配置服务器定期刷新而接收到的，要么更常见的是，通过覆盖进行洪水填充，这允许在推送更新后快速传播。在后一种情况下，通过可追溯到初始配置文档的数字签名进行更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every node in the RELOAD overlay is identified by a Node-ID. The Node-ID is used for three major purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载覆盖中的每个节点都由节点ID标识。节点ID用于三个主要目的：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To address the node itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 以寻址节点本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To determine the node&#39;s position in the overlay topology (if the overlay is structured; overlays do not need to be structured).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 确定节点在覆盖拓扑中的位置（如果覆盖是结构化的，则覆盖不需要结构化）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To determine the set of resources for which the node is responsible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 确定节点负责的资源集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each node has a certificate [RFC5280] containing its Node-ID in a subjectAltName extension, which is unique within an overlay instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个节点都有一个证书[RFC5280]，其中包含subjectAltName扩展名中的节点ID，该扩展名在覆盖实例中是唯一的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate serves multiple purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该证书有多种用途：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It entitles the user to store data at specific locations in the Overlay Instance. Each data Kind defines the specific rules for determining which certificates can access each Resource-ID/Kind-ID pair. For instance, some Kinds might allow anyone to write at a given location, whereas others might restrict writes to the owner of a single certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它允许用户在覆盖实例中的特定位置存储数据。每个数据类型定义了确定哪些证书可以访问每个资源ID/类型ID对的特定规则。例如，某些类型可能允许任何人在给定位置写入，而其他类型可能限制对单个证书所有者的写入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It entitles the user to operate a node that has a Node-ID found in the certificate. When the node forms a connection to another peer, it uses this certificate so that a node connecting to it knows it is connected to the correct node. (Technically, a TLS or DTLS association with client authentication is formed.) In addition, the node can sign messages, thus providing integrity and authentication for messages which are sent from the node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它允许用户操作在证书中具有节点ID的节点。当节点与另一个对等节点建立连接时，它将使用此证书，以便连接到它的节点知道它已连接到正确的节点。（从技术上讲，与客户端身份验证建立TLS或DTLS关联。）此外，节点可以对消息进行签名，从而为从节点发送的消息提供完整性和身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It entitles the user to use the user name found in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它授权用户使用证书中的用户名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a user has more than one device, typically they would get one certificate for each device. This allows each device to act as a separate peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果用户有多个设备，通常他们会为每个设备获得一个证书。这允许每个设备充当单独的对等设备。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD supports multiple certificate issuance models. The first is based on a central enrollment process, which allocates a unique name and Node-ID and puts them in a certificate for the user. All peers in a particular Overlay Instance have the enrollment server as a trust anchor and so can verify any other peer&#39;s certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD支持多个证书颁发模型。第一种是基于中心注册过程，该过程分配唯一的名称和节点ID，并将它们放入用户的证书中。特定覆盖实例中的所有对等方都将注册服务器作为信任锚点，因此可以验证任何其他对等方的证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second model is useful in settings, when a group of users want to set up an overlay network but are not concerned about attack by other users in the network. For instance, users on a LAN might want to set up a short-term ad hoc network without going to the trouble of
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当一组用户想要建立一个覆盖网络，但不关心网络中其他用户的攻击时，第二个模型在设置中很有用。例如，局域网上的用户可能希望建立一个短期的自组织网络，而不必费事
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
setting up an enrollment server. RELOAD supports the use of self-generated, self-signed certificates. When self-signed certificates are used, the node also generates its own Node-ID and user name. The Node-ID is computed as a digest of the public key, to prevent Node-ID theft. Note that the relevant cryptographic property for the digest is partial preimage resistance. Collision resistance is not needed, because an attacker who can create two nodes with the same Node-ID but a different public key obtains no advantage. This model is still subject to a number of known attacks (most notably, Sybil attacks [Sybil]) and can be safely used only in closed networks where users are mutually trusting. Another drawback of this approach is that the user&#39;s data is then tied to their key, so if a key is changed, any data stored under their Node-ID needs to be re-stored. This is not an issue for centrally issued Node-IDs provided that the Certification Authority (CA) reissues the same Node-ID when a new certificate is generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正在设置注册服务器。重新加载支持使用自生成、自签名的证书。使用自签名证书时，节点还生成自己的节点ID和用户名。节点ID作为公钥摘要计算，以防止节点ID被盗。请注意，摘要的相关加密属性是部分前映像阻力。不需要抗冲突，因为攻击者可以创建具有相同节点ID但具有不同公钥的两个节点，因此不会获得任何优势。该模型仍然受到许多已知攻击（最显著的是Sybil攻击[Sybil]），并且只能在用户相互信任的封闭网络中安全使用。这种方法的另一个缺点是，用户的数据随后被绑定到他们的密钥上，因此如果密钥被更改，则需要重新存储在其节点ID下的任何数据。如果证书颁发机构（CA）在生成新证书时重新颁发相同的节点ID，则这不是集中颁发的节点ID的问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The general principle here is that the security mechanisms (TLS or DTLS at the data link layer and message signatures at the message transport layer) are always used, even if the certificates are self-signed. This allows for a single set of code paths in the systems, with the only difference being whether certificate verification is used to chain to a single root of trust.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里的一般原则是始终使用安全机制（数据链路层的TLS或DTL以及消息传输层的消息签名），即使证书是自签名的。这允许在系统中使用一组代码路径，唯一的区别是是否使用证书验证链接到单个信任根。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. Shared-Key Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 共享密钥安全
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also provides an admission control system based on shared keys. In this model, the peers all share a single key which is used to authenticate the peer-to-peer connections via TLS-PSK [RFC4279] or TLS-SRP [RFC5054].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD还提供了基于共享密钥的准入控制系统。在该模型中，所有对等方共享一个密钥，该密钥用于通过TLS-PSK[RFC4279]或TLS-SRP[RFC5054]对对等连接进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 客户
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD defines a single protocol that is used both as the peer protocol and as the client protocol for the overlay. Having a single protocol simplifies implementation, particularly for devices that may act in either role, and allows clients to inject messages directly into the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD定义一个协议，该协议既用作对等协议，也用作覆盖的客户端协议。使用单一协议简化了实现，特别是对于可能扮演任何角色的设备，并允许客户端将消息直接注入覆盖层。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We use the term &#34;peer&#34; to identify a node in the overlay that routes messages for nodes other than those to which it is directly connected. Peers also have storage responsibilities. We use the term &#34;client&#34; to refer to nodes that do not have routing or storage responsibilities. When text applies to both peers and clients, we will simply refer to such devices as &#34;nodes&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们使用术语“对等体”来标识覆盖中的节点，该节点为其直接连接的节点以外的节点路由消息。对等方也有存储职责。我们使用术语“客户端”来指代没有路由或存储职责的节点。当文本同时适用于对等方和客户端时，我们将简单地将此类设备称为“节点”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s client support allows nodes that are not participating in the overlay as peers to utilize the same implementation and to benefit from the same security mechanisms as the peers. Clients possess and use certificates that authorize the user to store data at certain locations in the overlay. The Node-ID in the certificate is used to identify the particular client as a member of the overlay and to authenticate its messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD的客户端支持允许不作为对等方参与覆盖的节点使用相同的实现，并从与对等方相同的安全机制中获益。客户端拥有并使用授权用户在覆盖中的特定位置存储数据的证书。证书中的节点ID用于将特定客户端标识为覆盖的成员，并对其消息进行身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In RELOAD, unlike some other designs, clients are not first-class entities. From the perspective of a peer, a client is a node that has connected to the overlay, but that has not yet taken steps to insert itself into the overlay topology. It might never do so (if it&#39;s a client), or it might eventually do so (if it&#39;s just a node that is taking a long time to join). The routing and storage rules for RELOAD provide for correct behavior by peers regardless of whether other nodes attached to them are clients or peers. Of course, a client implementation needs to know that it intends to be a client, but this localizes complexity only to that node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在重新加载中，与其他一些设计不同，客户端不是一流的实体。从对等方的角度来看，客户端是已连接到覆盖的节点，但尚未采取步骤将自身插入覆盖拓扑中。它可能永远不会这样做（如果它是一个客户端），或者它可能最终会这样做（如果它只是一个需要很长时间才能加入的节点）。重新加载的路由和存储规则为对等方提供了正确的行为，而不管连接到它们的其他节点是客户端还是对等方。当然，客户机实现需要知道它打算成为客户机，但这只会将复杂性局限于该节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more discussion about the motivation for RELOAD&#39;s client support, see Appendix B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有关RELOAD客户支持动机的更多讨论，请参见附录B。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. Client Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.1. 客户端路由
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients may insert themselves in the overlay in two ways:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端可以通过两种方式将自己插入覆盖：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Establish a connection to the peer responsible for the client&#39;s Node-ID in the overlay. Then, requests may be sent from/to the client using its Node-ID in the same manner as if it were a peer, because the responsible peer in the overlay will handle the final step of routing to the client. This may require a TURN [RFC5766] relay in cases where NATs or firewalls prevent a client from forming a direct connection with its responsible peer. Note that clients that choose this option need to process Update messages from the peer (Section 6.4.2.3). These updates can indicate that the peer is no longer responsible for the client&#39;s Node-ID. The client would then need to form a connection to the appropriate peer. Failure to do so will result in the client no longer receiving messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 建立与覆盖中负责客户端节点ID的对等方的连接。然后，可以使用客户端的节点ID以与对等体相同的方式从客户端发送请求/向客户端发送请求，因为覆盖中的负责对等体将处理路由到客户端的最后一步。在NAT或防火墙阻止客户机与其负责的对等机形成直接连接的情况下，这可能需要TURN[RFC5766]中继。请注意，选择此选项的客户端需要处理来自对等方的更新消息（第6.4.2.3节）。这些更新可能表明对等方不再负责客户端的节点ID。然后客户端需要与相应的对等方建立连接。否则将导致客户端不再接收消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Establish a connection with an arbitrary peer in the overlay (perhaps based on network proximity or an inability to establish a direct connection with the responsible peer). In this case, the client will rely on RELOAD&#39;s Destination List feature (Section 6.3.2.2) to ensure reachability. The client can initiate requests, and any node in the overlay that knows the Destination List to its current location can reach it, but the client is not directly reachable using only its Node-ID. If the client is to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 与覆盖中的任意对等方建立连接（可能基于网络接近程度或无法与负责对等方建立直接连接）。在这种情况下，客户将依靠重新加载的目的地列表功能（第6.3.2.2节）确保可达性。客户端可以发起请求，覆盖中知道目标列表到其当前位置的任何节点都可以到达该请求，但仅使用其节点ID无法直接访问客户端。如果客户端要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
receive incoming requests from other members of the overlay, the Destination List needed to reach the client needs to be learnable via other mechanisms, such as being stored in the overlay by a usage. A client connected this way using a certificate with only a single Node-ID can proceed to use the connection without performing an Attach (Section 6.5.1). A client wishing to connect using this mechanism with a certificate with multiple Node-IDs can use a Ping (Section 6.5.3) to probe the Node-ID of the node to which it is connected before performing the Attach.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
接收来自覆盖层其他成员的传入请求时，到达客户端所需的目标列表需要通过其他机制进行学习，例如通过用户存储在覆盖层中。通过这种方式连接的客户端使用仅具有单个节点ID的证书，可以继续使用连接，而无需执行附加（第6.5.1节）。希望使用此机制连接具有多个节点ID的证书的客户端可以在执行附加之前使用Ping（第6.5.3节）探测其连接的节点的节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. Minimum Functionality Requirements for Clients
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2.2. 客户的最低功能要求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node may act as a client simply because it does not have the capacity or need to act as a peer in the overlay, or because it does not even have an implementation of the Topology Plug-in defined in Section 6.4.1, needed to act as a peer in the overlay. In order to exchange RELOAD messages with a peer, a client needs to meet a minimum level of functionality. Such a client will:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个节点可以充当客户端，这仅仅是因为它没有能力或不需要充当覆盖中的对等方，或者因为它甚至没有第6.4.1节中定义的拓扑插件的实现，而该拓扑插件需要充当覆盖中的对等方。为了与对等方交换重新加载消息，客户端需要满足最低级别的功能。该客户将：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Implement RELOAD&#39;s connection-management operations that are used to establish the connection with the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 实现RELOAD的连接管理操作，这些操作用于建立与对等方的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Implement RELOAD&#39;s data retrieval methods (with client functionality).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 实现RELOAD的数据检索方法（具有客户端功能）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Be able to calculate Resource-IDs used by the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 能够计算覆盖使用的资源ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Possess security credentials needed by the overlay that it is implementing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 拥有它正在实现的覆盖所需的安全凭据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A client speaks the same protocol as the peers, knows how to calculate Resource-IDs, and signs its requests in the same manner as peers. While a client does not necessarily require a full implementation of the overlay algorithm, calculating the Resource-ID requires an implementation of an appropriate algorithm for the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户机与对等机使用相同的协议，知道如何计算资源ID，并以与对等机相同的方式对其请求进行签名。虽然客户端不一定需要覆盖算法的完整实现，但计算资源ID需要覆盖算法的适当实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 路由
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses the capabilities of RELOAD&#39;s routing layer and the protocol features used to implement the capabilities, and provides a brief overview of how they are used. Appendix A discusses some alternative designs and the trade-offs that would be necessary to support them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节讨论了RELOAD路由层的功能和用于实现这些功能的协议功能，并简要概述了如何使用这些功能。附录A讨论了一些替代设计以及支持这些设计所需的权衡。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s routing provides the following capabilities:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载的路由提供以下功能：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Resource-based Routing: RELOAD supports routing messages based solely on the name of the resource. Such messages are delivered to a node that is responsible for that resource. Both structured and unstructured overlays are supported, so the route may not be deterministic for all Topology Plug-ins.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基于资源的路由：重新加载仅支持基于资源名称的路由消息。这些消息被传递到负责该资源的节点。同时支持结构化和非结构化覆盖，因此对于所有拓扑插件，路由可能不是确定性的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node-based Routing: RELOAD supports routing messages to a specific node in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基于节点的路由：重载支持将消息路由到覆盖中的特定节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Clients: RELOAD supports requests from and to clients that do not participate in overlay routing. The clients are located via either of the mechanisms described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端：重新加载支持来自和到不参与覆盖路由的客户端的请求。客户机通过上述任一机制定位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT Traversal: RELOAD supports establishing and using connections between nodes separated by one or more NATs, including locating peers behind NATs for those overlays allowing/requiring it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NAT遍历：RELOAD支持在由一个或多个NAT分隔的节点之间建立和使用连接，包括为允许/需要它的覆盖在NAT后面定位对等点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Low State: RELOAD&#39;s routing algorithms do not require significant state (i.e., state linear or greater in the number of outstanding messages that have passed through it) to be stored on intermediate peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
低状态：RELOAD的路由算法不需要在中间对等点上存储重要状态（即，状态线性或通过它的未完成消息数量更大）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Routability in Unstable Topologies: Overlay topology changes constantly in an overlay of moderate size due to the failure of individual nodes and links in the system. RELOAD&#39;s routing allows peers to reroute messages when a failure is detected, and replies can be returned to the requesting node as long as the peers that originally forwarded the successful request do not fail before the response is returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不稳定拓扑中的可路由性：由于系统中单个节点和链路的故障，覆盖拓扑在中等大小的覆盖中不断变化。RELOAD的路由允许对等方在检测到故障时重新路由消息，并且只要最初转发成功请求的对等方在返回响应之前没有失败，就可以将响应返回到请求节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD&#39;s routing utilizes three basic mechanisms:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载的路由使用三种基本机制：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Destination Lists: While, in principle, it is possible to just inject a message into the overlay with a single Node-ID as the destination, RELOAD provides a source-routing capability in the form of &#34;Destination Lists&#34;. A Destination List provides a list of the nodes through which a message flows in order (i.e., it is loose source routed). The minimal Destination List contains just a single value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目的地列表：原则上，只需将一个节点ID作为目的地向覆盖中注入消息是可能的，而重载以“目的地列表”的形式提供了源路由功能。目的地列表提供了一个节点列表，消息按顺序流经这些节点（即，它是松散源路由的）。最小目标列表只包含一个值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Via Lists: In order to allow responses to follow the same path as requests, each message also contains a &#34;Via List&#34;, which is appended to by each node a message traverses. This Via List can then be inverted and used as a Destination List for the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Via列表：为了允许响应遵循与请求相同的路径，每条消息还包含一个“Via列表”，该列表由消息所经过的每个节点追加。然后，该Via列表可以反转，并用作响应的目的地列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery: The RouteQuery method allows a node to query a peer for the next hop it will use to route a message. This method is useful for diagnostics and for iterative routing (see Section 6.4.2.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery：RouteQuery方法允许节点查询对等节点，以查找它将用于路由消息的下一个跃点。该方法对于诊断和迭代布线非常有用（见第6.4.2.4节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic routing mechanism that RELOAD uses is symmetric recursive. We will first describe symmetric recursive routing and then discuss its advantages in terms of the requirements discussed above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载使用的基本路由机制是对称递归的。我们将首先描述对称递归路由，然后根据上面讨论的需求讨论它的优势。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Symmetric recursive routing requires that a request message follow a path through the overlay to the destination: each peer forwards the message closer to its destination. The return path of the response goes through the same nodes as the request (though it may also go through some new intermediate nodes due to topology changes). Note that a failure on the reverse path caused by a topology change after the request was sent will be handled by the end-to-end retransmission of the response as described in Section 6.2.1. For example, the following figure shows a message following a route from A to Z through B and X:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对称递归路由要求请求消息沿着覆盖到目的地的路径：每个对等方将消息转发到更接近其目的地的位置。响应的返回路径通过与请求相同的节点（尽管由于拓扑更改，它也可能通过一些新的中间节点）。请注意，在发送请求后，由拓扑更改引起的反向路径故障将通过第6.2.1节所述的端到端重新传输响应来处理。例如，下图显示了一条从a到Z再到B和X的路由消息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A         B         X         Z
   -------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A         B         X         Z
   -------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ----------&gt;
   Dest=Z
            ----------&gt;
            Via=A
            Dest=Z
                      ----------&gt;
                      Via=A,B
                      Dest=Z
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ----------&gt;
   Dest=Z
            ----------&gt;
            Via=A
            Dest=Z
                      ----------&gt;
                      Via=A,B
                      Dest=Z
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      &lt;----------
                       Dest=X,B,A
            &lt;----------
               Dest=B,A
   &lt;----------
        Dest=A
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      &lt;----------
                       Dest=X,B,A
            &lt;----------
               Dest=B,A
   &lt;----------
        Dest=A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this figure does not indicate whether A is a client or peer. A forwards its request to B, and the response is returned to A in the same manner regardless of A&#39;s role in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，此图并不表示是客户机还是对等机。A将其请求转发给B，响应将以相同的方式返回给A，而不管A在覆盖中扮演什么角色。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This figure shows use of full Via Lists by intermediate peers B and X. However, if B and/or X are willing to store state, then they may elect to truncate the lists and save the truncated information internally using the transaction ID as a key to allow it to be retrieved later. Later, when the response message arrives, the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此图显示中间对等方B和X使用完整的Via列表。但是，如果B和/或X愿意存储状态，则它们可以选择截断列表，并使用事务ID作为密钥在内部保存截断的信息，以便稍后检索。稍后，当响应消息到达时
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
transaction ID would be used to recover the truncated information and return the response message along the path from which the request arrived. This option requires a greater amount of state to be stored on intermediate peers, but saves a small amount of bandwidth and reduces the need for modifying the message en route. Selection of this mode of operation is a choice for the individual peer; the techniques are interoperable even on a single message. The figure below shows B using full Via Lists, but X truncating them to X1 and saving the state internally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事务ID将用于恢复被截断的信息，并沿请求到达的路径返回响应消息。此选项要求在中间对等方上存储更多的状态，但节省了少量带宽，并减少了在路由过程中修改消息的需要。这种操作模式的选择是个人同行的选择；这些技术甚至可以在单个消息上进行互操作。下图显示B使用完整的过孔列表，但X将其截断为X1并在内部保存状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A         B         X         Z
   -------------------------------
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   A         B         X         Z
   -------------------------------
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ----------&gt;
   Dest=Z
            ----------&gt;
            Via=A
            Dest=Z
                      ----------&gt;
                      Via=X1
                      Dest=Z
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ----------&gt;
   Dest=Z
            ----------&gt;
            Via=A
            Dest=Z
                      ----------&gt;
                      Via=X1
                      Dest=Z
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      &lt;----------
                        Dest=X,X1
              &lt;----------
                 Dest=B,A
   &lt;----------
        Dest=A
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      &lt;----------
                        Dest=X,X1
              &lt;----------
                 Dest=B,A
   &lt;----------
        Dest=A
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As before, when B receives the message, B creates a Via List consisting of [A]. However, instead of sending [A, B], X creates an opaque ID X1 which maps internally to [A, B] (perhaps by being an encryption of [A, B]) and then forwards to Z with only X1 as the Via List. When the response arrives at X, it maps X1 back to [A, B], then inverts it to produce the new Destination List [B, A], and finally routes it to B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如前所述，当B接收到消息时，B创建一个由[a]组成的Via列表。但是，X没有发送[A，B]，而是创建一个不透明ID X1，该ID X1在内部映射到[A，B]（可能是[A，B]的加密），然后转发到Z，其中只有X1作为过孔列表。当响应到达X时，它将X1映射回[A，B]，然后将其反转以生成新的目的地列表[B，A]，最后将其路由到B。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also supports a basic iterative &#34;routing&#34; mode, in which the intermediate peers merely return a response indicating the next hop, but do not actually forward the message to that next hop themselves. Iterative routing is implemented using the RouteQuery method (see Section 6.4.2.4), which requests this behavior. Note that iterative routing is selected only by the initiating node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD还支持一种基本的迭代“路由”模式，在这种模式下，中间对等方只返回一个指示下一跳的响应，但实际上并不将消息转发到下一跳。使用RouteQuery方法（见第6.4.2.4节）实现迭代路由，该方法要求这种行为。请注意，迭代路由仅由发起节点选择。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. Connectivity Management
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. 连接管理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to provide efficient routing, a peer needs to maintain a set of direct connections to other peers in the Overlay Instance. Due to the presence of NATs, these connections often cannot be formed directly. Instead, we use the Attach request to establish a connection. Attach uses Interactive Connectivity Establishment (ICE) [RFC5245] to establish the connection. It is assumed that the reader is familiar with ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了提供有效的路由，对等方需要维护一组到覆盖实例中其他对等方的直接连接。由于NAT的存在，这些连接通常无法直接形成。相反，我们使用附加请求来建立连接。Attach使用交互式连接建立（ICE）[RFC5245]来建立连接。假定读者熟悉ICE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Say that peer A wishes to form a direct connection to peer B, either to join the overlay or to add more connections in its Routing Table. It gathers ICE candidates and packages them up in an Attach request, which it sends to B through usual overlay routing procedures. B does its own candidate gathering and sends back a response with its candidates. A and B then do ICE connectivity checks on the candidate pairs. The result is a connection between A and B. At this point, A and B MAY send messages directly between themselves without going through other overlay peers. In other words, A and B are in each other&#39;s Connection Tables. They MAY then execute an Update process, resulting in additions to each other&#39;s Routing Tables, and may then become able to route messages through each other to other overlay nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
假设对等点A希望与对等点B形成直接连接，以加入覆盖层或在其路由表中添加更多连接。它收集ICE候选者并将其打包成一个附加请求，通过通常的覆盖路由程序发送给B。B自行收集候选人，并与候选人一起回复。然后A和B对候选对进行ICE连接检查。结果是a和B之间建立了连接。此时，a和B可以直接在它们之间发送消息，而无需通过其他覆盖对等点。换句话说，A和B在彼此的连接表中。然后，它们可以执行更新过程，从而增加彼此的路由表，然后可以将消息通过彼此路由到其他覆盖节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two cases where Attach is not used. The first is when a peer is joining the overlay and is not connected to any peers. In order to support this case, a small number of bootstrap nodes typically need to be publicly accessible so that new peers can directly connect to them. Section 11 contains more detail on this. The second case is when a client connects to a peer at an arbitrary IP address, rather than to its responsible peer, as described in the second bullet point of Section 4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有两种情况下不使用Attach。第一种是当一个对等方加入覆盖层并且没有连接到任何对等方时。为了支持这种情况，通常需要公开访问少量引导节点，以便新的对等方可以直接连接到它们。第11节包含了关于这方面的更多细节。第二种情况是，客户机连接到任意IP地址的对等机，而不是连接到其负责的对等机，如第4.2.1节第二点所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, a peer needs to maintain connections to all of the peers near it in the Overlay Instance and to enough other peers to have efficient routing (the details on what &#34;enough&#34; and &#34;near&#34; mean depend on the specific overlay). If a peer cannot form a connection to some other peer, this is not necessarily a disaster; overlays can route correctly even without fully connected links. However, a peer needs to try to maintain the specified Routing Table defined by the Topology Plug-in algorithm and needs to form new connections if it detects that it has fewer direct connections than specified by the algorithm. This also implies that peers, in accordance with the Topology Plug-in algorithm, need to periodically verify that the connected peers are still alive and, if not, need to try to re-form the connections or form alternate ones. See Section 10.7.4.3 for an example on how a specific overlay algorithm implements these constraints.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般来说，一个对等方需要保持与覆盖实例中与其相邻的所有对等方的连接，以及与足够多的其他对等方的连接，以实现高效路由（关于“足够”和“接近”的含义的详细信息取决于特定覆盖）。如果一个对等点不能与其他对等点建立连接，这不一定是一场灾难；即使没有完全连接的链接，覆盖也可以正确路由。但是，对等方需要尝试维护拓扑插件算法定义的指定路由表，并且如果检测到其直接连接少于算法指定的连接，则需要形成新的连接。这还意味着，根据拓扑插件算法，对等方需要定期验证连接的对等方是否仍处于活动状态，如果没有，则需要尝试重新形成连接或形成备用连接。有关特定覆盖算法如何实现这些约束的示例，请参见第10.7.4.3节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. Overlay Algorithm Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 覆盖算法支持
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Topology Plug-in allows RELOAD to support a variety of overlay algorithms. This specification defines a DHT based on Chord, which is mandatory to implement, but the base RELOAD protocol is designed to support a variety of overlay algorithms. The information needed to implement this DHT is fully contained in this specification, but it is easier to understand if you are familiar with Chord-based [Chord] DHTs. A nice tutorial can be found at [wikiChord].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
拓扑插件允许重新加载以支持各种覆盖算法。本规范定义了基于Chord的DHT，这是必须实现的，但基本重载协议设计用于支持各种覆盖算法。实现此DHT所需的信息完全包含在本规范中，但如果您熟悉基于Chord的[Chord]DHT，则更容易理解。在[wikiChord]上可以找到一个不错的教程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. Support for Pluggable Overlay Algorithms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. 支持可插拔覆盖算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD defines three methods for overlay maintenance: Join, Update, and Leave. However, the contents of these messages, when they are sent, and their precise semantics are specified by the actual overlay algorithm, which is specified by configuration for all nodes in the overlay and thus is known to nodes before they attempt to join the overlay. RELOAD merely provides a framework of commonly needed methods that provide uniformity of notation (and ease of debugging) for a variety of overlay algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载定义了三种覆盖维护方法：加入、更新和离开。但是，这些消息在发送时的内容及其精确语义由实际覆盖算法指定，该算法由覆盖中所有节点的配置指定，因此节点在尝试加入覆盖之前就知道了。RELOAD仅仅提供了一个常用方法的框架，这些方法为各种覆盖算法提供了统一的表示法（以及易于调试）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. Joining, Leaving, and Maintenance Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. 加入、退出和维护概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a new peer wishes to join the Overlay Instance, it will need a Node-ID that it is allowed to use and a set of credentials which match that Node-ID. When an enrollment server is used, the Node-ID used is the one found in the certificate received from the enrollment server. The details of the joining procedure are defined by the overlay algorithm, but the general steps for joining an Overlay Instance are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当新对等方希望加入覆盖实例时，它将需要允许使用的节点ID和一组与该节点ID匹配的凭据。当使用注册服务器时，使用的节点ID是从注册服务器接收的证书中找到的节点ID。连接过程的详细信息由覆盖算法定义，但连接覆盖实例的一般步骤如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Form connections to some other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形成与其他对等方的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Acquire the data values this peer is responsible for storing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取该对等方负责存储的数据值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Inform the other peers which were previously responsible for that data that this peer has taken over responsibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 通知之前负责该数据的其他对等方，该对等方已接管该责任。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first thing the peer needs to do is to form a connection to some bootstrap node. Because this is the first connection the peer makes, these nodes will need public IP addresses so that they can be connected to directly. Once a peer has connected to one or more bootstrap nodes, it can form connections in the usual way, by routing Attach messages through the overlay to other nodes. After a peer has connected to the overlay for the first time, it can cache the set of past adjacencies which have public IP addresses and can attempt to use them as future bootstrap nodes. Note that this requires some
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方需要做的第一件事是建立到某个引导节点的连接。因为这是对等节点进行的第一次连接，所以这些节点将需要公共IP地址，以便可以直接连接。一旦一个对等节点连接到一个或多个引导节点，它就可以以通常的方式形成连接，通过覆盖将附加消息路由到其他节点。对等机第一次连接到覆盖后，它可以缓存具有公共IP地址的过去邻接集，并尝试将它们用作将来的引导节点。请注意，这需要一些
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
notion of which addresses are likely to be public as discussed in Section 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第9节讨论了哪些地址可能是公共地址的概念。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a peer has connected to a bootstrap node, it then needs to take up its appropriate place in the overlay. This requires two major operations:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等节点连接到引导节点后，需要在覆盖中占据适当的位置。这需要两个主要操作：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Form connections to other peers in the overlay to populate its Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形成与覆盖中其他对等方的连接，以填充其路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Get a copy of the data it is now responsible for storing, and assume responsibility for that data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 获取它现在负责存储的数据的副本，并对该数据负责。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second operation is performed by contacting the Admitting Peer (AP), the node which is currently responsible for the relevant section of the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二个操作通过联系接纳对等方（AP）来执行，该节点当前负责覆盖的相关部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The details of this operation depend mostly on the overlay algorithm involved, but a typical case would be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此操作的细节主要取决于所涉及的覆盖算法，但典型情况是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. JN sends a Join request to AP announcing its intention to join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. JN向AP发送加入请求，宣布其加入的意图。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. AP sends a Join response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. AP发送加入响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. AP does a sequence of Stores to JN to give it the data it will need.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. AP向JN执行一系列存储，以提供它所需的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. AP does Updates to JN and to other peers to tell them about its own Routing Table. At this point, both JN and AP consider JN responsible for some section of the Overlay Instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. AP向JN和其他对等方进行更新，以告知他们自己的路由表。在这一点上，JN和AP都认为JN负责覆盖实例的某个部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JN makes its own connections to the appropriate peers in the Overlay Instance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JN与覆盖实例中的相应对等方建立自己的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After this process completes, JN is a full member of the Overlay Instance and can process Store/Fetch requests.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此过程完成后，JN是覆盖实例的完整成员，可以处理存储/获取请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the first node is a special case. When ordinary nodes cannot form connections to the bootstrap nodes, then they are not part of the overlay. However, the first node in the overlay can obviously not connect to other nodes. In order to support this case, potential first nodes (which can also initially serve as bootstrap nodes) need to somehow be instructed that they are the entire overlay, rather than part of an existing overlay (e.g., by comparing their IP address to the bootstrap IP addresses in the configuration file).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，第一个节点是一种特殊情况。当普通节点无法形成到引导节点的连接时，它们就不是覆盖的一部分。但是，覆盖中的第一个节点显然无法连接到其他节点。为了支持这种情况，需要以某种方式指示潜在的第一个节点（最初也可以用作引导节点）它们是整个覆盖，而不是现有覆盖的一部分（例如，通过将它们的IP地址与配置文件中的引导IP地址进行比较）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that clients do not perform either of these operations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，客户端不执行这两个操作中的任何一个。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. First-Time Setup
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. 首次设置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Previous sections addressed how RELOAD works after a node has connected. This section provides an overview of how users get connected to the overlay for the first time. RELOAD is designed so that users can start with the name of the overlay they wish to join and perhaps an account name and password, and can leverage these into having a working peer with minimal user intervention. This helps avoid the problems that have been experienced with conventional SIP clients in which users need to manually configure a large number of settings.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前几节讨论了节点连接后重新加载的工作方式。本节概述了用户如何首次连接到覆盖。重新加载的设计目的是，用户可以从他们希望加入的覆盖的名称开始，也许还有一个帐户名和密码，并且可以利用这些名称和密码在用户干预最少的情况下拥有一个工作对等方。这有助于避免用户需要手动配置大量设置的传统SIP客户端遇到的问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Initial Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. 初始配置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the first phase of the setup process, the user starts with the name of the overlay and uses it to download an initial set of overlay configuration parameters. The node does a DNS SRV [RFC2782] lookup on the overlay name to get the address of a configuration server. It can then connect to this server with HTTPS [RFC2818] to download a Configuration Document which contains the basic overlay configuration parameters as well as a set of bootstrap nodes which can be used to join the overlay. The details of the relationships between names in the HTTPS certificates and the overlay names are described in Section 11.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在设置过程的第一阶段，用户从覆盖的名称开始，并使用它下载覆盖配置参数的初始集。节点对覆盖名称执行DNS SRV[RFC2782]查找，以获取配置服务器的地址。然后，它可以使用HTTPS[RFC2818]连接到此服务器，以下载包含基本覆盖配置参数以及一组可用于加入覆盖的引导节点的配置文档。第11.2节详细介绍了HTTPS证书中的名称与覆盖名称之间的关系。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a node already has the valid Configuration Document that it received by an out-of-band method, this step can be skipped. Note that this out-of-band method needs to provide authentication and integrity, because the Configuration Document contains the trust anchors used by the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果节点已经具有由带外方法接收的有效配置文档，则可以跳过此步骤。请注意，此带外方法需要提供身份验证和完整性，因为配置文档包含覆盖使用的信任锚。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. Enrollment
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. 注册
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the overlay is using centralized enrollment, then a user needs to acquire a certificate before joining the overlay. The certificate attests both to the user&#39;s name within the overlay and to the Node-IDs which they are permitted to operate. In this case, the Configuration Document will contain the address of an enrollment server which can be used to obtain such a certificate and will also contain the trust anchor, so this document must be retrieved securely (see Section 11.2). The enrollment server may (and probably will) require some sort of account name for the user and a password before issuing the certificate. The enrollment server&#39;s ability to ensure attackers cannot get a large number of certificates for the overlay is one of the cornerstones of RELOAD&#39;s security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果覆盖使用集中注册，则用户需要在加入覆盖之前获取证书。该证书证明覆盖中的用户名以及允许其操作的节点ID。在这种情况下，配置文档将包含可用于获取此类证书的注册服务器的地址，并且还将包含信任锚，因此必须安全地检索此文档（请参阅第11.2节）。在颁发证书之前，注册服务器可能（也可能会）需要用户的某种帐户名和密码。注册服务器能够确保攻击者无法为覆盖获取大量证书，这是RELOAD安全的基石之一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. Diagnostics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. 诊断学
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Significant advice around managing a RELOAD overlay and extensions for diagnostics are described in [P2P-DIAGNOSTICS].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2P-diagnostics]中介绍了有关管理重新加载覆盖和诊断扩展的重要建议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Application Support Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 应用程序支持概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is not intended to be used alone, but rather as a substrate for other applications. These applications can use RELOAD for a variety of purposes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载不打算单独使用，而是作为其他应用的基板。这些应用程序可以将重新加载用于多种用途：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To store data in the overlay and to retrieve data stored by other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 将数据存储在覆盖中并检索由其他节点存储的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a discovery mechanism for services such as TURN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 作为TURN等服务的发现机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o To form direct connections which can be used to transmit application-level messages without using the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 形成直接连接，可用于在不使用覆盖的情况下传输应用程序级消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an overview of these services.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节概述了这些服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. Data Storage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. 数据存储
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides operations to Store and Fetch data. Each location in the Overlay Instance is referenced by a Resource-ID. However, each location may contain data elements corresponding to multiple Kinds (e.g., certificate and SIP registration). Similarly, there may be multiple elements of a given Kind, as shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载提供存储和获取数据的操作。覆盖实例中的每个位置都由资源ID引用。但是，每个位置可能包含对应于多种类型的数据元素（例如，证书和SIP注册）。类似地，可能存在给定类型的多个元素，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      +--------------------------------+
                      |            Resource-ID         |
                      |                                |
                      | +------------+  +------------+ |
                      | |   Kind 1   |  |   Kind 2   | |
                      | |            |  |            | |
                      | | +--------+ |  | +--------+ | |
                      | | | Value  | |  | | Value  | | |
                      | | +--------+ |  | +--------+ | |
                      | |            |  |            | |
                      | | +--------+ |  | +--------+ | |
                      | | | Value  | |  | | Value  | | |
                      | | +--------+ |  | +--------+ | |
                      | |            |  +------------+ |
                      | | +--------+ |                 |
                      | | | Value  | |                 |
                      | | +--------+ |                 |
                      | +------------+                 |
                      +--------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      +--------------------------------+
                      |            Resource-ID         |
                      |                                |
                      | +------------+  +------------+ |
                      | |   Kind 1   |  |   Kind 2   | |
                      | |            |  |            | |
                      | | +--------+ |  | +--------+ | |
                      | | | Value  | |  | | Value  | | |
                      | | +--------+ |  | +--------+ | |
                      | |            |  |            | |
                      | | +--------+ |  | +--------+ | |
                      | | | Value  | |  | | Value  | | |
                      | | +--------+ |  | +--------+ | |
                      | |            |  +------------+ |
                      | | +--------+ |                 |
                      | | | Value  | |                 |
                      | | +--------+ |                 |
                      | +------------+                 |
                      +--------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each Kind is identified by a Kind-ID, which is a code point either assigned by IANA or allocated out of a private range. As part of the Kind definition, protocol designers may define constraints (such as limits on size) on the values which may be stored. For many Kinds, the set may be restricted to a single value, while some sets may be allowed to contain multiple identical items, and others may have only unique items. Note that a Kind may be employed by multiple usages, and new usages are encouraged to use previously defined Kinds where possible. We define the following data models in this document, although other usages can define their own structures:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个种类都由一个种类ID标识，该ID是由IANA分配或分配到专用范围之外的代码点。作为种类定义的一部分，协议设计者可以对可能存储的值定义约束（例如大小限制）。对于许多类型，集合可能仅限于一个值，而某些集合可能允许包含多个相同的项，而其他集合可能只有唯一的项。请注意，一个种类可能被多种用途所使用，并且鼓励新用途尽可能使用先前定义的种类。我们在本文档中定义了以下数据模型，尽管其他用法可以定义它们自己的结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
single value: There can be at most one item in the set, and any value overwrites the previous item.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单值：集合中最多可以有一项，任何值都会覆盖上一项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
array: Many values can be stored and addressed by a numeric index.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数组：许多值可以通过数字索引存储和寻址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dictionary: The values stored are indexed by a key. Often, this key is one of the values from the certificate of the peer sending the Store request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字典：存储的值由键索引。通常，此密钥是发送存储请求的对等方证书中的值之一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to protect stored data from tampering by other nodes, each stored value is individually digitally signed by the node which created it. When a value is retrieved, the digital signature can be verified to detect tampering. If the certificate used to verify the stored value signature expires, the value can no longer be retrieved (although it may not be immediately garbage collected by the storing node), and the creating node will need to store the value again if it desires that the stored value continue to be available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了保护存储的数据不被其他节点篡改，每个存储值都由创建它的节点进行单独的数字签名。检索值时，可以验证数字签名以检测篡改。如果用于验证存储值签名的证书过期，则无法再检索该值（尽管存储节点可能不会立即对其进行垃圾收集），并且如果创建节点希望存储值继续可用，则需要再次存储该值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. Storage Permissions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.1. 存储权限
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A major issue in peer-to-peer storage networks is minimizing the burden of becoming a peer and, in particular, minimizing the amount of data which any peer needs to store for other nodes. RELOAD addresses this issue by allowing any given node to store data only at a small number of locations in the overlay, with those locations being determined by the node&#39;s certificate. When a peer uses a Store request to place data at a location authorized by its certificate, it signs that data with the private key that corresponds to its certificate. Then the peer responsible for storing the data is able to verify that the peer issuing the request is authorized to make that request. Each data Kind defines the exact rules for determining what certificate is appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等存储网络中的一个主要问题是最小化成为对等节点的负担，特别是最小化任何对等节点需要为其他节点存储的数据量。重载通过允许任何给定节点仅在覆盖中的少量位置存储数据来解决此问题，这些位置由节点的证书确定。当对等方使用存储请求将数据放置在其证书授权的位置时，它会使用与其证书对应的私钥对该数据进行签名。然后，负责存储数据的对等方能够验证发出请求的对等方是否有权发出该请求。每种数据类型都定义了确定哪种证书合适的确切规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most natural rule is that a certificate authorizes a user to store data keyed with their user name X. Thus, only a user with a certificate for &#34;alice@example.org&#34; could write to that location in
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最自然的规则是，证书授权用户存储以其用户名X为密钥的数据。因此，只有拥有证书的用户才能alice@example.org“可以在中写入该位置
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the overlay (see Section 11.3). However, other usages can define any rules they choose, including publicly writable values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖层（见第11.3节）。但是，其他用法可以定义他们选择的任何规则，包括可公开写入的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The digital signature over the data serves two purposes. First, it allows the peer responsible for storing the data to verify that this Store is authorized. Second, it provides integrity for the data. The signature is saved along with the data value (or values) so that any reader can verify the integrity of the data. Of course, the responsible peer can &#34;lose&#34; the value, but it cannot undetectably modify it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据上的数字签名有两个目的。首先，它允许负责存储数据的对等方验证此存储是否经过授权。其次，它提供了数据的完整性。签名与数据值一起保存，以便任何读取器都可以验证数据的完整性。当然，负责任的对等方可以“丢失”该值，但它不能不被察觉地修改它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The size requirements of the data being stored in the overlay are variable. For instance, a SIP AOR and voicemail differ widely in the storage size. RELOAD leaves it to the usage and overlay configuration to limit size imbalances of various Kinds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖中存储的数据的大小要求是可变的。例如，SIP AOR和语音邮件在存储大小上差别很大。重载将其留给使用和覆盖配置来限制各种大小的不平衡。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. Replication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1.2. 复制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Replication in P2P overlays can be used to provide:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2P覆盖中的复制可用于提供：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
persistence: if the responsible peer crashes and/or if the storing peer leaves the overlay
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
持久性：如果负责的对等方崩溃和/或存储对等方离开覆盖层
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
security: to guard against DoS attacks by the responsible peer or routing attacks to that responsible peer
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全性：防止责任对等方的DoS攻击或将攻击路由到该责任对等方
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
load balancing: to balance the load of queries for popular resources
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
负载平衡：平衡常用资源的查询负载
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A variety of schemes are used in P2P overlays to achieve some of these goals. Common techniques include replicating on neighbors of the responsible peer, randomly locating replicas around the overlay, and replicating along the path to the responsible peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2P覆盖中使用了多种方案来实现其中一些目标。常见的技术包括在负责对等方的邻居上进行复制、在覆盖层周围随机定位复制副本以及沿到负责对等方的路径进行复制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The core RELOAD specification does not specify a particular replication strategy. Instead, the first level of replication strategies is determined by the overlay algorithm, which can base the replication strategy on its particular topology. For example, Chord places replicas on successor peers, which will take over responsibility if the responsible peer fails [Chord].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
核心重新加载规范没有指定特定的复制策略。相反，复制策略的第一级由覆盖算法确定，覆盖算法可以根据其特定拓扑确定复制策略。例如，Chord将副本放置在后续对等体上，如果负责对等体出现故障，后续对等体将接管责任[Chord]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If additional replication is needed, for example, if data persistence is particularly important for a particular usage, then that usage may specify additional replication, such as implementing random replications by inserting a different well-known constant into the Resource Name used to store each replicated copy of the resource. Such replication strategies can be added independently of the underlying algorithm, and their usage can be determined based on the needs of the particular usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果需要额外的复制，例如，如果数据持久性对于特定用途特别重要，则该用途可以指定额外的复制，例如通过在用于存储资源的每个复制副本的资源名称中插入不同的已知常量来实现随机复制。这样的复制策略可以独立于底层算法添加，并且可以根据特定用法的需要确定它们的用法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. Usages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. 用法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By itself, the distributed storage layer provides only the infrastructure on which applications are built. In order to do anything useful, a usage needs to be defined. Each usage needs to specify several things:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
分布式存储层本身只提供构建应用程序的基础结构。为了做任何有用的事情，需要定义用法。每次使用都需要指定几项内容：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Register Kind-ID code points for any Kinds that the usage defines (Section 14.6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 为使用定义的任何种类注册种类ID代码点（第14.6节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Define the data structure for each of the Kinds (the value member in Section 7.2). If the data structure contains character strings, conversion rules between characters and the binary storage need to be specified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 定义每种类型的数据结构（第7.2节中的值成员）。如果数据结构包含字符串，则需要指定字符和二进制存储之间的转换规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Define access control rules for each of the Kinds (Section 7.3).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 为每种类型定义访问控制规则（第7.3节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Define how the Resource Name is used to form the Resource-ID where each Kind is stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 定义如何使用资源名称来形成存储每种资源的资源ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Describe how values will be merged when a network partition is being healed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 描述在修复网络分区时如何合并值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Kinds defined by a usage may also be applied to other usages. However, a need for different parameters, such as a different access control model, would imply the need to create a new Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由用法定义的种类也可以应用于其他用法。然而，需要不同的参数，例如不同的访问控制模型，这意味着需要创建一种新的访问控制模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Service Discovery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 服务发现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD does not currently define a generic service discovery algorithm as part of the base protocol, although a simplistic TURN-specific discovery mechanism is provided. A variety of service discovery algorithms can be implemented as extensions to the base protocol, such as the service discovery algorithm ReDIR [opendht-sigcomm05] and [REDIR-RELOAD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD目前没有将通用服务发现算法定义为基本协议的一部分，尽管提供了一种简化的特定于回合的发现机制。各种服务发现算法可以作为基本协议的扩展来实现，例如服务发现算法ReDIR[opendht-sigcomm05]和[ReDIR-RELOAD]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Application Connectivity
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 应用程序连接
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no requirement that a RELOAD Usage needs to use RELOAD&#39;s primitives for establishing its own communication if it already possesses its own means of establishing connections. For example, one could design a RELOAD-based resource discovery protocol which used HTTP to retrieve the actual data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果重新加载使用已经拥有自己的建立连接的方法，则不要求重新加载使用需要使用重新加载的原语来建立自己的通信。例如，可以设计一个基于重载的资源发现协议，该协议使用HTTP检索实际数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For more common situations, however, it is the overlay itself -- rather than an external authority such as DNS -- which is used to establish a connection. RELOAD provides connectivity to applications using the AppAttach method. For example, if a P2PSIP node wishes to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，对于更常见的情况，用于建立连接的是覆盖层本身，而不是DNS等外部机构。重新加载使用AppAttach方法提供与应用程序的连接。例如，如果P2PSIP节点希望
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
establish a SIP dialog with another P2PSIP node, it will use AppAttach to establish a direct connection with the other node. This new connection is separate from the peer protocol connection. It is a dedicated DTLS or TLS flow used only for the SIP dialog.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与另一个P2PSIP节点建立SIP对话，它将使用AppAttach与另一个节点建立直接连接。此新连接与对等协议连接分离。它是仅用于SIP对话的专用DTL或TLS流。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Overlay Management Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 覆盖管理协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines the basic protocols used to create, maintain, and use the RELOAD overlay network. We start by defining the basic concept of how message destinations are interpreted when routing messages. We then describe the symmetric recursive routing model, which is RELOAD&#39;s default routing algorithm. Finally, we define the message structure and the messages used to join and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节定义了用于创建、维护和使用重新加载覆盖网络的基本协议。我们首先定义路由消息时如何解释消息目的地的基本概念。然后我们描述了对称递归路由模型，这是RELOAD的默认路由算法。最后，我们定义了消息结构以及用于连接和维护覆盖的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. Message Receipt and Forwarding
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. 消息接收和转发
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node receives a message, it first examines the overlay, version, and other header fields to determine whether the message is one it can process. If any of these are incorrect, as defined in Section 6.3.2, it is an error and the message MUST be discarded. The peer SHOULD generate an appropriate error, but local policy can override this and cause the message to be silently dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点接收到消息时，它首先检查覆盖、版本和其他头字段，以确定该消息是否是它可以处理的消息。如第6.3.2节所述，如果其中任何一项不正确，则为错误，必须丢弃该消息。对等方应生成适当的错误，但本地策略可以覆盖该错误，并导致消息被静默删除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the peer has determined that the message is correctly formatted (note that this does not include signature-checking on intermediate nodes as the message may be fragmented), it examines the first entry on the Destination List. There are three possible cases here:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦对等方确定消息的格式正确（注意，这不包括中间节点上的签名检查，因为消息可能会被分段），它将检查目标列表上的第一个条目。这里有三种可能的情况：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first entry on the Destination List is an ID for which the peer is responsible. A peer is always responsible for the wildcard Node-ID. Handling of this case is described in Section 6.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 目的地列表上的第一个条目是对等方负责的ID。对等方始终负责通配符节点ID。第6.1.1节描述了这种情况的处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first entry on the Destination List is an ID for which another peer is responsible. Handling of this case is described in Section 6.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 目标列表上的第一个条目是另一个对等方负责的ID。第6.1.2节描述了该情况的处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The first entry on the Destination List is an opaque ID that is being used for Destination List compression. Handling of this case is described in Section 6.1.3. Note that opaque IDs can be distinguished from Node-IDs and Resource-IDs on the wire as described in Section 6.3.2.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 目标列表上的第一个条目是用于目标列表压缩的不透明ID。第6.1.3节描述了该情况的处理。请注意，如第6.3.2.2节所述，不透明ID可以与网络上的节点ID和资源ID区分开来。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These cases are handled as discussed below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些案件的处理如下所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. Responsible ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.1. 责任ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the first entry on the Destination List is an ID for which the peer is responsible, there are several (mutually exclusive) subcases to consider.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果目的地列表上的第一个条目是对等体负责的ID，则有几个（互斥的）子实例需要考虑。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is a Resource-ID, then it MUST be the only entry on the Destination List. If there are other entries, the message MUST be silently dropped. Otherwise, the message is destined for this node, so the node MUST verify the signature as described in Section 7.1 and MUST pass it to the upper layers. &#34;Upper layers&#34; is used here to mean the components above the &#34;Overlay Link Service Boundary&#34; line in the figure in Section 1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果条目是资源ID，则它必须是目标列表上的唯一条目。如果还有其他条目，则必须以静默方式删除该消息。否则，消息将发送到此节点，因此节点必须按照第7.1节所述验证签名，并且必须将其传递给上层。“上层”是指第1.2节图中“覆盖链路服务边界”线上方的组件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is a Node-ID which equals this node&#39;s Node-ID, then the message is destined for this node. If it is the only entry on the Destination List, the message is destined for this node and so the node passes it to the upper layers. Otherwise, the node removes the entry from the Destination List and repeats the routing process with the next entry on the Destination List. If the message is a response and list compression was used, then the node first modifies the Destination List to reinsert the saved state, e.g., by unpacking any opaque IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果条目是与此节点的节点ID相等的节点ID，则消息将发送到此节点。如果它是目的地列表上的唯一条目，则消息将发送到此节点，因此节点将其传递到上层。否则，节点将从目标列表中删除该条目，并使用目标列表中的下一个条目重复路由过程。如果消息是响应并且使用了列表压缩，则节点首先修改目标列表以重新插入保存的状态，例如，通过解压缩任何不透明ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is the wildcard Node-ID (all &#34;1&#34;s), the message is destined for this node, and the node passes the message to the upper layers. A message with a wildcard Node-ID as its first entry is never forwarded; it is consumed locally.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果条目是通配符节点ID（全部为“1”），则消息将发送到此节点，并且节点将消息传递给上层。以通配符节点ID作为其第一个条目的消息永远不会被转发；它是本地消费的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the entry is a Node-ID which is not equal to this node, then the node MUST drop the message silently unless the Node-ID corresponds to a node which is directly connected to this node (i.e., a client). In the latter case, the node MUST attempt to forward the message to the destination node as described in the next section (though this may fail for connectivity reasons, because the TTL has expired, or because of some other error.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果条目是不等于此节点的节点ID，则该节点必须以静默方式删除消息，除非该节点ID对应于直接连接到此节点的节点（即客户端）。在后一种情况下，节点必须按照下一节所述尝试将消息转发到目标节点（尽管这可能由于连接原因、TTL已过期或其他错误而失败）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this process implies that in order to address a message to &#34;the peer that controls region X&#34;, a sender sends to Resource-ID X, not Node-ID X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，此过程意味着，为了将消息寻址到“控制区域X的对等方”，发送方将发送到资源ID X，而不是节点ID X。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. Other ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.2. 其他ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the first entry on the Destination List is neither an opaque ID nor an ID the peer is responsible for, then the peer MUST forward the message towards that entry. This means that it MUST select one of the peers to which it is connected and which is most likely to be responsible (according to the Topology Plug-in) for the first entry
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果目标列表上的第一个条目既不是不透明ID，也不是对等方负责的ID，则对等方必须将消息转发给该条目。这意味着它必须选择一个与之连接的对等点，该对等点最有可能负责（根据拓扑插件）第一个条目
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
on the Destination List. For the CHORD-RELOAD topology, the routing to the most likely responsible node is explained in Section 10.3. If the first entry on the Destination List is in the peer&#39;s Connection Table, the peer MUST forward the message to that peer directly. Otherwise, the peer consults the Routing Table to forward the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在目的地列表上。对于CHORD-RELOAD拓扑，第10.3节解释了到最可能负责节点的路由。如果目标列表上的第一个条目位于对等方的连接表中，则对等方必须直接将消息转发给该对等方。否则，对等方将参考路由表来转发消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any intermediate peer which forwards a RELOAD request MUST ensure that if it receives a response to that message, the response can be routed back through the set of nodes through which the request passed. The peer selects one of these approaches:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发重新加载请求的任何中间对等方必须确保，如果它接收到对该消息的响应，则该响应可以通过请求通过的节点集路由回。对等方选择以下方法之一：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The peer can add an entry to the Via List in the forwarding header that will enable it to determine the correct node. This is done by appending to the Via List the Node-ID of the node from which the request was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对等方可以在转发头的Via列表中添加一个条目，使其能够确定正确的节点。这是通过将接收请求的节点的节点ID附加到Via列表中来完成的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The peer can keep per-transaction state which will allow it to determine the correct node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对等方可以保持每个事务的状态，这将允许它确定正确的节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example of the first strategy, consider an example with nodes A, B, C, D, and E. If node D receives a message from node C with Via List [A, B], then D would forward to the next node E with Via List [A, B, C]. Now, if E wants to respond to the message, it reverses the Via List to produce the Destination List, resulting in [D, C, B, A]. When D forwards the response to C, the Destination List will contain [C, B, A].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为第一策略的示例，考虑节点A、B、C、D和E的示例。如果节点D通过Vista列表[A，B]从节点C接收消息，则D将通过Vista表[A，B，C]转发到下一个节点E。现在，如果E想要响应消息，它会反转Via列表以生成目的地列表，结果是[D，C，B，A]。当D将响应转发给C时，目的地列表将包含[C，B，A]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an example of the second strategy, if node D receives a message from node C with transaction ID X (as assigned by A) and Via List [A, B], it could store [X, C] in its state database and forward the message with the Via List unchanged. When D receives the response, it consults its state database for transaction ID X, determines that the request came from C, and forwards the response to C.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为第二种策略的示例，如果节点D从节点C接收到事务ID为X（由a分配）且通过列表[a，B]的消息，则它可以将[X，C]存储在其状态数据库中，并在通过列表不变的情况下转发该消息。当D接收到响应时，它查阅其状态数据库中的事务ID X，确定请求来自C，并将响应转发给C。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intermediate peers which modify the Via List are not required to simply add entries. The only requirement is that the peer MUST be able to reconstruct the correct Destination List on the return route. RELOAD provides explicit support for this functionality in the form of opaque IDs, which can replace any number of Via List entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
修改Via列表的中间对等方不需要简单地添加条目。唯一的要求是对等方必须能够在返回路线上重建正确的目的地列表。重载以不透明ID的形式为该功能提供了明确的支持，可以替换任意数量的Via列表条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For instance, in the above example, Node D might send E a Via List containing only the opaque ID I. E would then use the Destination List [D, I] to send its return message. When D processes this Destination List, it would detect that I is an opaque ID, recover the Via List [A, B, C], and reverse that to produce the correct Destination List [C, B, A] before sending it to C. This feature is called &#34;list compression&#34;. Possibilities for an opaque ID include a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如，在上面的示例中，节点D可以通过仅包含不透明ID的列表向E发送消息，即E随后将使用目的地列表[D，I]来发送其返回消息。当D处理这个目的地列表时，它将检测到I是一个不透明的ID，恢复Via列表[A，B，C]，并在将其发送到C之前将其反转以生成正确的目的地列表[C，B，A]。此功能称为“列表压缩”。不透明ID的可能性包括
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
compressed and/or encrypted version of the original Via List and an index into a state database containing the original Via List, but the details are a local matter.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
原始Via列表的压缩和/或加密版本，以及包含原始Via列表的状态数据库的索引，但细节是本地事务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No matter what mechanism for storing Via List state is used, if an intermediate peer exits the overlay, then on the return trip the message cannot be forwarded and will be dropped. The ordinary timeout and retransmission mechanisms provide stability over this type of failure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论使用何种机制来存储Via List状态，如果中间对等方退出覆盖，那么在回程中消息将无法转发，并将被丢弃。普通的超时和重传机制提供了这种故障的稳定性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that if an intermediate peer retains per-transaction state instead of modifying the Via List, it needs some mechanism for timing out that state; otherwise, its state database will grow without bound. Whatever algorithm is used, unless a FORWARD_CRITICAL forwarding option (Section 6.3.2.3) or an overlay configuration option explicitly indicates this state is not needed, the state MUST be maintained for at least the value of the overlay-reliability-timer configuration parameter and MAY be kept longer. Future extensions, such as [P2PSIP-RELAY], may define mechanisms for determining when this state does not need to be retained.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，如果中间对等方保留每个事务状态而不是修改Via列表，则需要某种机制来超时该状态；否则，其状态数据库将不受限制地增长。无论使用何种算法，除非转发关键转发选项（第6.3.2.3节）或覆盖配置选项明确指出不需要该状态，否则该状态必须至少保持覆盖可靠性定时器配置参数的值，并且可以保持更长时间。将来的扩展，如[P2PSIP-RELAY]，可以定义确定何时不需要保留此状态的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is no requirement to ensure that a request issued after the receipt of a response follows the same path as the response. As a consequence, there is no requirement to use either of the mechanisms described above (Via List or state retention) when processing a response message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
没有要求确保在收到响应后发出的请求遵循与响应相同的路径。因此，在处理响应消息时，不需要使用上述任何一种机制（通过列表或状态保留）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node receiving a request from another node MUST ensure that any response to that request exits that node with a Destination List equal to the concatenation of the Node-ID of the node from which the request was received with the Via List in the original request. The intermediate node normally learns the Node-ID that the other node is using via an Attach, but a node using a certificate with a single Node-ID MAY elect not to send an Attach (see Section 4.2.1, bullet 2). If a node with a certificate with multiple Node-IDs attempts to route a message other than a Ping or Attach through a node without performing an Attach, the receiving node MUST reject the request with an Error_Forbidden error. The node MUST implement support for returning responses to a Ping or Attach request made by a Joining Node Attaching to its responsible peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从另一个节点接收请求的节点必须确保对该请求的任何响应退出该节点，且目标列表等于从中接收请求的节点的节点ID与原始请求中的通过列表的连接。中间节点通常通过附加来学习另一个节点正在使用的节点ID，但是使用具有单个节点ID的证书的节点可以选择不发送附加（参见第4.2.1节，项目符号2）。如果具有多个节点ID的证书的节点试图通过节点路由除Ping或Attach之外的消息，而不执行Attach，则接收节点必须拒绝带有错误的请求。节点必须实现对连接到其负责对等方的加入节点发出的Ping或Attach请求的响应的返回支持。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. Opaque ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1.3. 不透明ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the first entry on the Destination List is an opaque ID (e.g., a compressed Via List), the peer MUST replace the entry with the original Via List that it replaced and then re-examine the Destination List to determine which of the three cases in Section 6.1 now applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果目的地列表上的第一个条目是不透明ID（例如，压缩过孔列表），则对等方必须用其替换的原始过孔列表替换该条目，然后重新检查目的地列表，以确定第6.1节中的三种情况中的哪一种现在适用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. Symmetric Recursive Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. 对称递归路由
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section defines RELOAD&#39;s Symmetric Recursive Routing algorithm, which is the default algorithm used by nodes to route messages through the overlay. All implementations MUST implement this routing algorithm. An overlay MAY be configured to use alternative routing algorithms, and alternative routing algorithms MAY be selected on a per-message basis. That is, a node in an overlay which supports Symmetric Recursive Routing and some other routing algorithm called XXX might use Symmetric Recursive Routing some of the time and XXX at other times.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节定义了RELOAD的对称递归路由算法，这是节点用于通过覆盖路由消息的默认算法。所有实现都必须实现此路由算法。覆盖可被配置为使用替代路由算法，并且可基于每条消息选择替代路由算法。也就是说，覆盖中支持对称递归路由和其他称为XXX的路由算法的节点可能在某些时间使用对称递归路由，而在其他时间使用XXX。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. Request Origination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.1. 请求发起
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to originate a message to a given Node-ID or Resource-ID, a node MUST construct an appropriate Destination List. The simplest such Destination List is a single entry containing the Node-ID or Resource-ID. The resulting message MUST be forwarded to its destination via the normal overlay routing mechanisms. The node MAY also construct a more complicated Destination List for source routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了向给定的节点ID或资源ID发起消息，节点必须构造适当的目的地列表。最简单的目的地列表是包含节点ID或资源ID的单个条目。生成的消息必须通过正常的覆盖路由机制转发到其目的地。该节点还可以为源路由构造更复杂的目的地列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the message is constructed, the node sends the message to an adjacent peer. If the first entry on the Destination List is directly connected, then the message MUST be routed down that connection. Otherwise, the Topology Plug-in MUST be consulted to determine the appropriate next hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息构造完成后，节点将消息发送给相邻的对等方。如果目标列表上的第一个条目是直接连接的，则消息必须沿该连接路由。否则，必须参考拓扑插件以确定适当的下一跳。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Parallel requests for a resource are a common solution to improve reliability in the face of churn or subversive peers. Parallel searches for usage-specified replicas are managed by the usage layer, for instance, by having the usage store data at multiple Resource-IDs, with the requesting node sending requests to each of those Resource-IDs. However, a single request MAY also be routed through multiple adjacent peers, even when they are known to be suboptimal, to improve reliability [vulnerabilities-acsac04]. Such parallel searches MAY be specified by the Topology Plug-in, in which case it would return multiple next hops and the request would be routed to all of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对资源的并行请求是一种常见的解决方案，可以在面临客户流失或颠覆性对等时提高可靠性。使用层管理对使用率指定副本的并行搜索，例如，使用率存储数据位于多个资源ID，请求节点向每个资源ID发送请求。然而，一个请求也可以通过多个相邻的对等点路由，即使已知它们是次优的，以提高可靠性[VULNERATIES-acsac04]。这种并行搜索可以由拓扑插件指定，在这种情况下，它将返回多个下一跳，并且请求将路由到所有下一跳。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because messages can be lost in transit through the overlay, RELOAD incorporates an end-to-end reliability mechanism. When an originating node transmits a request, it MUST set a timer to the current overlay-reliability-timer. If a response has not been received when the timer fires, the request MUST be retransmitted with the same transaction identifier. The request MAY be retransmitted up to 4 times, for a total of 5 messages. After the timer for the fifth transmission fires, the message MUST be considered to have failed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于消息可能在通过覆盖层的传输过程中丢失，因此重新加载包含了端到端的可靠性机制。当发起节点发送请求时，它必须将计时器设置为当前覆盖可靠性计时器。如果计时器触发时未收到响应，则必须使用相同的事务标识符重新传输请求。请求最多可重传4次，总共5条消息。在第五次传输的计时器触发后，必须认为消息已失败。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although the originating node will be doing both end-to-end and hop-by-hop retransmissions, the end-by-end retransmission procedure is not followed by intermediate nodes. They follow the hop-by-hop reliability procedure described in Section 6.6.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管发起节点将同时进行端到端和逐跳重传，但中间节点不遵循端到端重传过程。它们遵循第6.6.3节中描述的逐跳可靠性程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The above algorithm can result in multiple requests being delivered to a node. Receiving nodes MUST generate semantically equivalent responses to retransmissions of the same request (this can be determined by the transaction ID) if the request is received within the maximum request lifetime (15 seconds). For some requests (e.g., Fetch), this can be accomplished merely by processing the request again. For other requests (e.g., Store), it may be necessary to maintain state for the duration of the request lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述算法可能导致多个请求被传递到一个节点。如果在最大请求生存期（15秒）内收到请求，则接收节点必须对相同请求的重传生成语义等效的响应（这可以由事务ID确定）。对于某些请求（例如Fetch），仅需再次处理该请求即可完成此操作。对于其他请求（例如存储），可能需要在请求生存期内保持状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. Response Origination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2.2. 反应起源
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer sends a response to a request using this routing algorithm, it MUST construct the Destination List by reversing the order of the entries on the Via List. This has the result that the response traverses the same peers as the request traversed, except in reverse order (symmetric routing) and possibly with extra nodes (loose routing).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等方使用此路由算法发送对请求的响应时，它必须通过颠倒Via列表中条目的顺序来构造目标列表。这会导致响应与所遍历的请求遍历相同的对等方，除了以相反的顺序（对称路由）和可能的额外节点（松散路由）之外。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. Message Structure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3. 消息结构
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD is a message-oriented request/response protocol. The messages are encoded using binary fields. All integers are represented in network byte order. The general philosophy behind the design was to use Type, Length, Value (TLV) fields to allow for extensibility. However, for the parts of a structure that were required in all messages, we just define these in a fixed position, as adding a type and length for them is unnecessary and would only increase bandwidth and introduce new potential interoperability issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载是一种面向消息的请求/响应协议。这些消息使用二进制字段进行编码。所有整数都以网络字节顺序表示。设计背后的一般理念是使用类型、长度、值（TLV）字段来实现可扩展性。但是，对于所有消息中需要的结构部分，我们只是在固定位置定义它们，因为为它们添加类型和长度是不必要的，并且只会增加带宽并引入新的潜在互操作性问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each message has three parts, which are concatenated, as shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每条消息有三个部分，它们被连接在一起，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     +-------------------------+
     |    Forwarding Header    |
     +-------------------------+
     |    Message Contents     |
     +-------------------------+
     |     Security Block      |
     +-------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     +-------------------------+
     |    Forwarding Header    |
     +-------------------------+
     |    Message Contents     |
     +-------------------------+
     |     Security Block      |
     +-------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of these parts are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些部分的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Forwarding Header: Each message has a generic header which is used to forward the message between peers and to its final destination. This header is the only information that an intermediate peer (i.e., one that is not the target of a message) needs to examine. Section 6.3.2 describes the format of this part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发标头：每个消息都有一个通用标头，用于在对等方之间转发消息并将其转发到最终目的地。此标头是中间对等方（即，不是消息目标的对等方）需要检查的唯一信息。第6.3.2节描述了本部分的格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Message Contents: The message being delivered between the peers. From the perspective of the forwarding layer, the contents are opaque; however, they are interpreted by the higher layers. Section 6.3.3 describes the format of this part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息内容：在对等方之间传递的消息。从转发层的角度来看，内容是不透明的；但是，它们是由更高的层来解释的。第6.3.3节描述了本部分的格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Block: A security block containing certificates and a digital signature over the &#34;Message Contents&#34; section. Note that this signature can be computed without parsing the message contents. All messages MUST be signed by their originator. Section 6.3.4 describes the format of this part.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全块：在“消息内容”部分包含证书和数字签名的安全块。请注意，可以在不解析消息内容的情况下计算此签名。所有邮件必须由其原始发件人签名。第6.3.4节描述了本部分的格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. Presentation Language
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1. 表示语言
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structures defined in this document are defined using a C-like syntax based on the presentation language used to define TLS [RFC5246]. Advantages of this style include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档中定义的结构使用基于用于定义TLS的表示语言[RFC5246]的类C语法进行定义。这种风格的优点包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is familiar enough that most readers can grasp it quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 这本书很熟悉，大多数读者都能很快理解。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The ability to define nested structures allows a separation between high-level and low-level message structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 定义嵌套结构的能力允许在高级和低级消息结构之间进行分离。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It has a straightforward wire encoding that allows quick implementation, but the structures can be comprehended without knowing the encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它有一个简单的有线编码，允许快速实现，但是可以在不知道编码的情况下理解结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It is possible to mechanically compile encoders and decoders.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 可以机械地编译编码器和解码器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Several idiosyncrasies of this language are worth noting:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这种语言的几个特点值得注意：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o All lengths are denoted in bytes, not objects.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 所有长度均以字节表示，而不是以对象表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Variable-length values are denoted like arrays, with angle brackets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 可变长度值用尖括号表示，类似于数组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o &#34;select&#34; is used to indicate variant structures.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o “选择”用于表示变体结构。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For instance, &#34;uint16 array&lt;0..2^8-2&gt;;&#34; represents up to 254 bytes, which corresponds to up to 127 values of two bytes (16 bits) each.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如，“uint16数组&lt;0..2^8-2&gt;；”最多表示254个字节，对应于每个字节最多127个值（16位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A repetitive structure member shares a common notation with a member containing a variable-length block of data. The latter always starts with &#34;opaque&#34;, whereas the former does not. For instance, the following denotes a variable block of data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重复结构成员与包含可变长度数据块的成员共享公共符号。后者总是以“不透明”开头，而前者不是。例如，以下表示可变数据块：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                     opaque data&lt;0..2^32-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                     opaque data&lt;0..2^32-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
whereas the following denotes a list of 0, 1, or more instances of the Name element:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
鉴于以下内容表示Name元素的0、1或更多实例的列表：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                     Name names&lt;0..2^32-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                     Name names&lt;0..2^32-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1. Common Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.1.1. 共同定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an introduction to the presentation language used throughout RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍整个重新加载过程中使用的表示语言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An enum represents an enumerated type. The values associated with each possibility are represented in parentheses, and the maximum value is represented as a nameless value, for purposes of describing the width of the containing integral type. For instance, Boolean represents a true or false:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
枚举表示枚举类型。与每个可能性相关的值用括号表示，最大值用无名值表示，用于描述包含整数类型的宽度。例如，布尔值表示真或假：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         enum { false(0), true(1), (255) } Boolean;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         enum { false(0), true(1), (255) } Boolean;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A boolean value is either a 1 or a 0. The max value of 255 indicates that this is represented as a single byte on the wire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
布尔值为1或0。最大值255表示这在导线上表示为单个字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The NodeId, shown below, represents a single Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如下所示，NodeId表示一个节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
typedef opaque NodeId[NodeIdLength];
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
typedef不透明NodeId[NodeIdLength]；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A NodeId is a fixed-length structure represented as a series of bytes, with the most significant byte first. The length is set on a per-overlay basis within the range of 16-20 bytes (128 to 160 bits). (See Section 11.1 for how NodeIdLength is set.) Note that the use of &#34;typedef&#34; here is an extension to the TLS language, but its meaning should be relatively obvious. Also note that the [ size ] syntax defines a fixed-length element that does not include the length of the element in the on-the-wire encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NodeId是一个固定长度的结构，表示为一系列字节，最重要的字节排在第一位。长度在16-20字节（128到160位）的范围内以每个覆盖为基础设置。（关于如何设置NodeIdLength，请参见第11.1节。）注意，此处使用的“typedef”是TLS语言的扩展，但其含义应该相对明显。还要注意，[size]语法定义了一个固定长度的元素，该元素不包括在线编码中元素的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ResourceId, shown below, represents a single Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ResourceId（如下所示）表示单个Resource-ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             typedef opaque       ResourceId&lt;0..2^8-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             typedef opaque       ResourceId&lt;0..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Like a NodeId, a ResourceId is an opaque string of bytes, but unlike NodeIds, ResourceIds are variable length, up to 254 bytes (2040 bits) in length. On the wire, each ResourceId is preceded by a single
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与NodeId一样，ResourceId是一个不透明的字节字符串，但与NodeId不同，ResourceId的长度是可变的，最多为254字节（2040位）。在连线上，每个ResourceId前面都有一个
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length byte (allowing lengths up to 255 bytes). Thus, the 3-byte value &#34;FOO&#34; would be encoded as: 03 46 4f 4f. Note the &lt; range &gt; syntax defines a variable length element that includes the length of the element in the on-the-wire encoding. The number of bytes to encode the length on the wire is derived by range; i.e., it is the minimum number of bytes which can encode the largest range value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度字节（允许最大长度为255字节）。因此，3字节值“FOO”将被编码为：03 46 4f 4f。注意&lt;range&gt;语法定义了一个可变长度元素，该元素包含在线编码中元素的长度。编码导线长度的字节数由范围导出；i、 例如，它是可以编码最大范围值的最小字节数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more complicated example is IpAddressPort, which represents a network address and can be used to carry either an IPv6 or IPv4 address:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更复杂的示例是IpAddressPort，它表示网络地址，可用于承载IPv6或IPv4地址：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidAddressType(0), ipv4_address(1), ipv6_address(2),
             (255) } AddressType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidAddressType(0), ipv4_address(1), ipv6_address(2),
             (255) } AddressType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                  addr;
          uint16                  port;
        } IPv4AddrPort;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                  addr;
          uint16                  port;
        } IPv4AddrPort;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint128                 addr;
          uint16                  port;
        } IPv6AddrPort;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint128                 addr;
          uint16                  port;
        } IPv6AddrPort;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          AddressType             type;
          uint8                   length;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          AddressType             type;
          uint8                   length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (type) {
            case ipv4_address:
               IPv4AddrPort       v4addr_port;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (type) {
            case ipv4_address:
               IPv4AddrPort       v4addr_port;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case ipv6_address: IPv6AddrPort v6addr_port;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
案例ipv6_地址：IPv6AddrPort v6addr_port；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure can be extended */
          };
        } IpAddressPort;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure can be extended */
          };
        } IpAddressPort;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first two fields in the structure are the same no matter what kind of address is being represented:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论代表哪种地址，结构中的前两个字段都是相同的：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type: The type of address (IPv4 or IPv6).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型：地址的类型（IPv4或IPv6）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length: The length of the rest of the structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度：结构其余部分的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
By having the type and the length appear at the beginning of the structure regardless of the kind of address being represented, an implementation which does not understand new address type X can still parse the IpAddressPort field and then discard it if it is not needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过让类型和长度显示在结构的开头，而不管所表示的地址类型如何，不理解新地址类型X的实现仍然可以解析IpAddressPort字段，然后在不需要时丢弃它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The rest of the IpAddressPort structure is either an IPv4AddrPort or an IPv6AddrPort. Both of these simply consist of an address represented as an integer and a 16-bit port. As an example, here is the wire representation of the IPv4 address &#34;192.0.2.1&#34; with port &#34;6084&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IpAddressPort结构的其余部分是IPv4AddrPort或IPv6AddrPort。这两个都只是由一个表示为整数的地址和一个16位端口组成。例如，以下是IPv4地址“192.0.2.1”和端口“6084”的有线表示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             01           ; type    = IPv4
             06           ; length  = 6
             c0 00 02 01  ; address = 192.0.2.1
             17 c4        ; port    = 6084
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             01           ; type    = IPv4
             06           ; length  = 6
             c0 00 02 01  ; address = 192.0.2.1
             17 c4        ; port    = 6084
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless a given structure that uses a select explicitly allows for unknown types in the select, any unknown type SHOULD be treated as a parsing error, and the whole message SHOULD be discarded with no response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除非使用select的给定结构显式允许select中的未知类型，否则任何未知类型都应被视为解析错误，并且应丢弃整个消息而不响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. Forwarding Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2. 转发头
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The forwarding header is defined as a ForwardingHeader structure, as shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发头定义为转发头结构，如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32             relo_token;
          uint32             overlay;
          uint16             configuration_sequence;
          uint8              version;
          uint8              ttl;
          uint32             fragment;
          uint32             length;
          uint64             transaction_id;
          uint32             max_response_length;
          uint16             via_list_length;
          uint16             destination_list_length;
          uint16             options_length;
          Destination        via_list[via_list_length];
          Destination        destination_list
                               [destination_list_length];
          ForwardingOption   options[options_length];
        } ForwardingHeader;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32             relo_token;
          uint32             overlay;
          uint16             configuration_sequence;
          uint8              version;
          uint8              ttl;
          uint32             fragment;
          uint32             length;
          uint64             transaction_id;
          uint32             max_response_length;
          uint16             via_list_length;
          uint16             destination_list_length;
          uint16             options_length;
          Destination        via_list[via_list_length];
          Destination        destination_list
                               [destination_list_length];
          ForwardingOption   options[options_length];
        } ForwardingHeader;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
结构的内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
relo_token: The first four bytes identify this message as a RELOAD message. This field MUST contain the value 0xd2454c4f (the string &#34;RELO&#34; with the high bit of the first byte set).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
relo_令牌：前四个字节将此消息标识为重新加载消息。此字段必须包含值0xd2454c4f（具有第一个字节集高位的字符串“RELO”）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay: The 32-bit checksum/hash of the overlay being used. This MUST be formed by taking the lower 32 bits of the SHA-1 [RFC3174] hash of the overlay name. The purpose of this field is to allow nodes to participate in multiple overlays and to detect accidental misconfiguration. This is not a security-critical function. The overlay name MUST consist of a sequence of characters that would be allowable as a DNS name. Specifically, as it is used in a DNS lookup, it will need to be compliant with the grammar for the domain as specified in Section 2.3.1 of [RFC1035].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖：正在使用的覆盖的32位校验和/哈希。这必须通过获取覆盖名称的SHA-1[RFC3174]散列的较低32位来形成。此字段的目的是允许节点参与多个覆盖，并检测意外的错误配置。这不是一个安全关键功能。覆盖名称必须由允许作为DNS名称的字符序列组成。具体而言，由于它用于DNS查找，因此需要符合[RFC1035]第2.3.1节中规定的域语法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
configuration_sequence: The sequence number of the configuration file. See Section 6.3.2.1 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置顺序：配置文件的顺序号。详见第6.3.2.1节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
version: The version of the RELOAD protocol being used times 10. RELOAD version numbers are fixed-point decimal numbers between fixed-point integer between 0.1 and 25.4. This document describes version 1.0, with a value of 0x0a. (Note that versions used prior to the publication of this RFC used version number 0.1.) Nodes MUST reject messages with other versions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版本：正在使用的重新加载协议的版本乘以10。重新加载版本号是介于0.1和25.4之间的定点整数之间的定点十进制数。本文档描述了1.0版，其值为0x0a。（请注意，在发布此RFC之前使用的版本使用的版本号为0.1。）节点必须拒绝具有其他版本的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ttl: An 8-bit field indicating the number of iterations, or hops, a message can experience before it is discarded. The TTL (time-to-live) value MUST be decremented by one at every hop along the route the message traverses just before transmission. If a received message has a TTL of 0 and the message is not destined for the receiving node, then the message MUST NOT be propagated further, and an Error_TTL_Exceeded error should be generated. The initial value of the TTL SHOULD be 100 and MUST NOT exceed 100 unless defined otherwise by the overlay configuration. Implementations which receive messages with a TTL greater than the current value of initial-ttl (or the default of 100) MUST discard the message and send an Error_TTL_Exceeded error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ttl：一个8位字段，指示消息在被丢弃之前可以经历的迭代次数或跳数。TTL（生存时间）值必须在传输前沿消息所经过的路由的每个跃点递减一。如果接收到的消息的TTL为0，且该消息的目的地不是接收节点，则不得进一步传播该消息，并应生成错误\u TTL\u EXCENDED Error。TTL的初始值应为100，且不得超过100，除非覆盖配置另有规定。接收TTL大于当前初始TTL值（或默认值100）的消息的实现必须丢弃该消息并发送错误\u TTL\u EXCENDED Error。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fragment: This field is used to handle fragmentation. The high bit (0x80000000) MUST be set for historical reasons. If the next bit (0x40000000) is set to 1, it indicates that this is the last (or only) fragment. The next six bits (0x20000000 through 0x01000000) are reserved and SHOULD be set to zero. The remainder of the field is used to indicate the fragment offset; see Section 6.7 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
片段：此字段用于处理片段。出于历史原因，必须设置高位（0x8000000）。如果下一位（0x40000000）设置为1，则表示这是最后（或唯一）一个片段。接下来的六位（0x20000000到0x01000000）是保留的，应设置为零。该字段的其余部分用于指示碎片偏移量；详见第6.7节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length: The count in bytes of the size of the message, including the header, after the eventual fragmentation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度：最终分段后消息大小（包括标头）的字节数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
transaction_id: A unique 64-bit number that identifies this transaction and also allows receivers to disambiguate transactions which are otherwise identical. In order to provide a high probability that transaction IDs are unique, they MUST be randomly generated. Responses use the same transaction ID as the request to which they correspond. Transaction IDs are also used for fragment reassembly. See Section 6.7 for details.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
事务id：一个唯一的64位数字，用于标识此事务，并允许接收方消除其他相同事务的歧义。为了提供事务ID唯一的高概率，必须随机生成它们。响应使用与其对应的请求相同的事务ID。事务ID也用于片段重组。详见第6.7节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max_response_length: The maximum size in bytes of a response. This is used by requesting nodes to avoid receiving (unexpected) very large responses. If this value is non-zero, responding peers MUST check that any response would not exceed it and if so generate an Error_Incompatible_with_Overlay value. This value SHOULD be set to zero for responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大响应长度：响应的最大大小（以字节为单位）。请求节点使用此选项来避免接收（意外的）非常大的响应。如果该值不为零，则响应的对等方必须检查任何响应是否不会超过该值，如果是，则生成一个错误\u与\u重叠值不兼容\u。对于响应，此值应设置为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_list_length: The length of the Via List in bytes. Note that in this field and the following two length fields, we depart from the usual variable-length convention of having the length immediately precede the value, in order to make it easier for hardware decoding engines to quickly determine the length of the header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_list_length：以字节为单位的via列表长度。请注意，在这个字段和下面两个长度字段中，我们偏离了通常的可变长度约定，即长度紧跟在值之前，以便硬件解码引擎更容易快速确定报头的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_list_length: The length of the Destination List in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目标列表长度：目标列表的长度（字节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options_length: The length of the header options in bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项长度：标题选项的长度，以字节为单位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_list: The via_list contains the sequence of destinations through which the message has passed. The via_list starts out empty and grows as the message traverses each peer. In stateless cases, the previous hop that the message is from is appended to the Via List as specified in Section 6.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
via_列表：via_列表包含消息通过的目的地序列。via_列表开始时为空，并随着消息遍历每个对等方而增长。在无状态情况下，根据第6.1.2节的规定，将消息来自的前一个跃点附加到Via列表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_list: The destination_list contains a sequence of destinations through which the message should pass. The Destination List is constructed by the message originator. The first element on the Destination List is where the message goes next. Generally, the list shrinks as the message traverses each listed peer, though if list compression is used, this may not be true.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目的地列表：目的地列表包含消息应该通过的目的地序列。目的地列表由消息发起人构建。目的地列表上的第一个元素是消息的下一步去向。通常，当消息遍历每个列出的对等方时，列表会收缩，但如果使用列表压缩，则可能不是这样。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
options: Contains a series of ForwardingOption entries. See Section 6.3.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项：包含一系列ForwardingOption条目。见第6.3.2.3节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. Processing Configuration Sequence Numbers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.1. 处理配置序列号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to be part of the overlay, a node MUST have a copy of the overlay Configuration Document. In order to allow for configuration document changes, each version of the Configuration Document MUST contain a sequence number which MUST be monotonically increasing mod 65535. Because the sequence number may, in principle, wrap, greater than or less than are interpreted by modulo arithmetic as in TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了成为覆盖的一部分，节点必须具有覆盖配置文档的副本。为了允许配置文件更改，每个版本的配置文件必须包含一个序列号，该序列号必须单调递增mod 65535。因为序列号原则上可以是wrap，大于或小于都可以像在TCP中一样通过模运算来解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a destination node receives a request, it MUST check that the configuration_sequence field is equal to its own configuration sequence number. If they do not match, the node MUST generate an error, either Error_Config_Too_Old or Error_Config_Too_New. In addition, if the configuration file in the request is too old, the node MUST generate a ConfigUpdate message to update the requesting node. This allows new Configuration Documents to propagate quickly throughout the system. The one exception to this rule is that if the configuration_sequence field is equal to 65535 and the message type is ConfigUpdate, then the message MUST be accepted regardless of the receiving node&#39;s configuration sequence number. Since 65535 is a special value, peers sending a new configuration when the configuration sequence is currently 65534 MUST set the configuration sequence number to 0 when they send a new configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当目标节点收到请求时，它必须检查配置序列字段是否等于其自身的配置序列号。如果它们不匹配，则节点必须生成一个错误，要么是error\u Config\u Too\u Old，要么是error\u Config\u Too\u New。此外，如果请求中的配置文件太旧，则节点必须生成ConfigUpdate消息以更新请求节点。这允许新的配置文档在整个系统中快速传播。此规则的一个例外是，如果configuration_sequence字段等于65535且消息类型为ConfigUpdate，则无论接收节点的配置序列号如何，都必须接受消息。由于65535是一个特殊值，因此当配置序列当前为65534时发送新配置的对等方在发送新配置时必须将配置序列号设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.2. Destination and Via Lists
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.2. 目的地和途径列表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Destination List and Via List are sequences of Destination values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目的地列表和通孔列表是目的地值的序列：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     enum { invalidDestinationType(0), node(1), resource(2),
            opaque_id_type(3), /* 128-255 not allowed */ (255) }
          DestinationType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     enum { invalidDestinationType(0), node(1), resource(2),
            opaque_id_type(3), /* 128-255 not allowed */ (255) }
          DestinationType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     select (destination_type) {
      case node:
             NodeId               node_id;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     select (destination_type) {
      case node:
             NodeId               node_id;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
case resource: ResourceId resource_id;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
案例资源：ResourceId resource\u id；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      case opaque_id_type:
             opaque               opaque_id&lt;0..2^8-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      case opaque_id_type:
             opaque               opaque_id&lt;0..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          /* This structure may be extended with new types */
     } DestinationData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          /* This structure may be extended with new types */
     } DestinationData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
        DestinationType         type;
        uint8                   length;
        DestinationData         destination_data;
     } Destination;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
        DestinationType         type;
        uint8                   length;
        DestinationData         destination_data;
     } Destination;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
        uint16               opaque_id; /* Top bit MUST be 1 */
     } Destination;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
        uint16               opaque_id; /* Top bit MUST be 1 */
     } Destination;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the destination structure is a 16-bit integer, then the first bit MUST be set to 1, and it MUST be treated as if it were a full structure with a DestinationType of opaque_id_type and an opaque_id that was 2 bytes long with the value of the 16-bit integer. If the destination structure starts with DestinationType, then the first bit MUST be set to 0, and the destination structure must use a TLV structure with the following contents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果目标结构是16位整数，则必须将第一位设置为1，并且必须将其视为DestinationType为不透明\u id \u type的完整结构和长度为2字节且值为16位整数的不透明\u id。如果目标结构以DestinationType开头，则第一位必须设置为0，并且目标结构必须使用具有以下内容的TLV结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the DestinationData Payload Data Unit (PDU). It may be one of &#34;node&#34;, &#34;resource&#34;, or &#34;opaque_id_type&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入目标数据有效负载数据单元（PDU）的类型。它可以是“节点”、“资源”或“不透明的\u id\u类型”之一。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the destination_data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度目标_数据的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_data The destination value itself, which is an encoded DestinationData structure that depends on the value of &#34;type&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination_data目标值本身，它是一个编码的DestinationData结构，取决于“type”的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the destination structure encodes a Type, Length, Value. The Length field specifies the length of the DestinationData values, which allows the addition of new DestinationTypes. It also allows an implementation which does not understand a given DestinationType to skip over it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，目标结构编码类型、长度和值。长度字段指定DestinationData值的长度，允许添加新的DestinationTypes。它还允许不理解给定DestinationType的实现跳过它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A DestinationData can be one of three types:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DestinationData可以是以下三种类型之一：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
node A Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点A节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
opaque A compressed list of Node-IDs and an eventual Resource-ID. Because this value has been compressed by one of the peers, it is meaningful only to that peer and cannot be decoded by other peers. Thus, it is represented as an opaque string.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不透明节点ID和最终资源ID的压缩列表。由于此值已由其中一个对等方压缩，因此它仅对该对等方有意义，并且不能由其他对等方解码。因此，它被表示为不透明字符串。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The Resource-ID of the resource which is desired. This type MUST appear only in the final location of a Destination List and MUST NOT appear in a Via List. It is meaningless to try to route through a resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
资源所需资源的资源ID。此类型必须仅出现在目的地列表的最终位置，不得出现在通过列表中。尝试通过资源进行路由是没有意义的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One possible encoding of the 16-bit integer version as an opaque identifier is to encode an index into a Connection Table. To avoid misrouting responses in the event a response is delayed and the Connection Table entry has changed, the identifier SHOULD be split between an index and a generation counter for that index. When a Node first joins the overlay, the generation counters SHOULD be initialized to random values. An implementation MAY use 12 bits for the Connection Table index and 3 bits for the generation counter. (Note that this does not suggest a 4096-entry Connection Table for every peer, only the ability to encode for a larger Connection Table.) When a Connection Table slot is used for a new connection, the generation counter is incremented (with wrapping). Connection Table slots are used on a rotating basis to maximize the time interval between uses of the same slot for different connections. When routing a message to an entry in the Destination List encoding a Connection Table entry, the peer MUST confirm that the generation counter matches the current generation counter of that index before forwarding the message. If it does not match, the message MUST be silently dropped.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
16位整数版本作为不透明标识符的一种可能编码是将索引编码到连接表中。为避免在响应延迟且连接表项已更改的情况下错误路由响应，应在索引和该索引的生成计数器之间拆分标识符。当节点首次加入覆盖时，生成计数器应初始化为随机值。一个实现可以使用12位作为连接表索引，使用3位作为生成计数器。（请注意，这并不意味着每个对等方都有4096个条目的连接表，只是能够为更大的连接表编码。）当连接表插槽用于新连接时，生成计数器将递增（使用换行）。连接表插槽在旋转的基础上使用，以最大化不同连接使用相同插槽之间的时间间隔。将消息路由到目标列表中编码连接表条目的条目时，对等方必须在转发消息之前确认生成计数器与该索引的当前生成计数器匹配。如果不匹配，则必须以静默方式删除消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.3. Forwarding Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.2.3. 转发选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Forwarding header can be extended with forwarding header options, which are a series of ForwardingOption structures:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发标头可以使用转发标头选项进行扩展，转发标头选项是一系列转发选项结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { invalidForwardingOptionType(0), (255) }
      ForwardingOptionType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    enum { invalidForwardingOptionType(0), (255) }
      ForwardingOptionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
      ForwardingOptionType      type;
      uint8                     flags;
      uint16                    length;
      select (type) {
            /* This type may be extended */
      };
    } ForwardingOption;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
      ForwardingOptionType      type;
      uint8                     flags;
      uint16                    length;
      select (type) {
            /* This type may be extended */
      };
    } ForwardingOption;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ForwardingOption consists of the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个ForwardingOption由以下值组成：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the option. This structure allows for unknown options types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入选项的类型。此结构允许使用未知的选项类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
flags Three flags are defined: FORWARD_CRITICAL(0x01), DESTINATION_CRITICAL(0x02), and RESPONSE_COPY(0x04). These flags MUST NOT be set in a response. If the FORWARD_CRITICAL flag is set, any peer that would forward the message but does not understand this option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the DESTINATION_CRITICAL flag is set, any node that generates a response to the message but does not understand the forwarding option MUST reject the request with an Error_Unsupported_Forwarding_Option error response. If the RESPONSE_COPY flag is set, any node generating a response MUST copy the option from the request to the response except that the RESPONSE_COPY, FORWARD_CRITICAL, and DESTINATION_CRITICAL flags MUST be cleared.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
标志定义了三个标志：转发关键（0x01）、目标关键（0x02）和响应拷贝（0x04）。不得在响应中设置这些标志。如果设置了FORWARD_CRITICAL标志，任何将转发消息但不理解此选项的对等方都必须拒绝带有错误_Unsupported_Forwarding_option错误响应的请求。如果设置了DESTINATION_CRITICAL标志，则生成对消息的响应但不了解转发选项的任何节点都必须拒绝带有错误\u Unsupported_forwarding_option错误响应的请求。如果设置了RESPONSE\u COPY标志，则生成响应的任何节点都必须将选项从请求复制到响应，除非必须清除RESPONSE\u COPY、FORWARD\u CRITICAL和DESTINATION\u CRITICAL标志。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the rest of the structure. Note that a 0 length may be reasonable if the mere presence of the option is meaningful and no value is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度结构其余部分的长度。请注意，如果仅存在该选项是有意义的，并且不需要任何值，则0长度可能是合理的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
option The option value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项选择选项值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. Message Contents Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3. 消息内容格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second major part of a RELOAD message is the contents part, which is defined by MessageContents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载消息的第二个主要部分是内容部分，由MessageContents定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum { invalidMessageExtensionType(0),
          (2^16-1) } MessageExtensionType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   enum { invalidMessageExtensionType(0),
          (2^16-1) } MessageExtensionType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
     MessageExtensionType  type;
     Boolean               critical;
     opaque                extension_contents&lt;0..2^32-1&gt;;
   } MessageExtension;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
     MessageExtensionType  type;
     Boolean               critical;
     opaque                extension_contents&lt;0..2^32-1&gt;;
   } MessageExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
     uint16                 message_code;
     opaque                 message_body&lt;0..2^32-1&gt;;
     MessageExtension       extensions&lt;0..2^32-1&gt;;
   } MessageContents;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
     uint16                 message_code;
     opaque                 message_body&lt;0..2^32-1&gt;;
     MessageExtension       extensions&lt;0..2^32-1&gt;;
   } MessageContents;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message_code This indicates the message that is being sent. The code space is broken up as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息\代码表示正在发送的消息。代码空间分为以下几部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x0 Invalid Message Code. This code will never be assigned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x0无效的消息代码。永远不会分配此代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x1 .. 0x7FFF Requests and responses. These code points are always paired, with requests being an odd value and the corresponding response being the request code plus 1. Thus, &#34;probe_request&#34; (the Probe request) has the value 1 and &#34;probe_answer&#34; (the Probe response) has the value 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x1。。0x7FFF请求和响应。这些代码点总是成对的，请求是奇数，相应的响应是请求代码加1。因此，“探测请求”（探测请求）的值为1，“探测应答”（探测响应）的值为2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x8000 .. 0xFFFE Reserved
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0x8000。。0xFFFE保留
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0xFFFF Error
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
0xFFFF错误
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
The message codes are defined in Section 14.8.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
第14.8节定义了信息代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message_body The message body itself, represented as a variable-length string of bytes. The bytes themselves are dependent on the code value. See the sections describing the various RELOAD methods (Join, Update, Attach, Store, Fetch, etc.) for the definitions of the payload contents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息体消息体本身，表示为可变长度的字节字符串。字节本身取决于代码值。有关有效负载内容的定义，请参阅描述各种重新加载方法（联接、更新、附加、存储、获取等）的章节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extensions Extensions to the message. Currently no extensions are defined, but new extensions can be defined by the process described in Section 14.14.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息的扩展。目前没有定义任何扩展，但是可以通过第14.14节中描述的过程定义新的扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All extensions have the following form:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有扩展都具有以下形式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The extension type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入扩展类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
critical Whether this extension needs to be understood in order to process the message. If critical = True and the recipient does not understand the message, it MUST generate an Error_Unknown_Extension error. If critical = False, the recipient MAY choose to process the message even if it does not understand the extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
是否需要理解此扩展以处理消息至关重要。如果critical=True且收件人不理解邮件，则必须生成错误\未知\扩展名错误。如果critical=False，则即使收件人不理解扩展名，也可以选择处理邮件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extension_contents The contents of the extension (which are extension dependent).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extension_contents扩展的内容（依赖于扩展）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The subsections 6.4.2, 6.5, and 7 describe structures that are inserted inside the message_body member, depending on the value of the message_code value. For example, a message_code value of join_req means that the structure named JoinReq is inserted inside message_body. This document does not contain a mapping between message_code values and structure names, as the conversion between the two is obvious.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第6.4.2、6.5和7小节描述了插入消息体成员内部的结构，具体取决于消息代码值的值。例如，join_req的message_code值意味着名为JoinReq的结构插入到message_body中。本文档不包含消息代码值和结构名称之间的映射，因为两者之间的转换是显而易见的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Similarly, this document uses the name of the structure without the &#34;Req&#34; or &#34;Ans&#34; suffix to mean the execution of a transaction consisting of the matching request and answer. For example, when the text says &#34;perform an Attach&#34;, it must be understood as performing a transaction composed of an AttachReq and an AttachAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
同样，本文档使用不带“Req”或“Ans”后缀的结构名称来表示由匹配请求和应答组成的事务的执行。例如，当文本显示“执行附加”时，必须将其理解为执行由AttachReq和AttachAns组成的事务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3.1. Response Codes and Response Errors
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.3.1. 响应代码和响应错误
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node processing a request MUST return its status in the message_code field. If the request was a success, then the message code MUST be set to the response code that matches the request (i.e., the next code up). The response payload is then as defined in the request/response descriptions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
处理请求的节点必须在message_code字段中返回其状态。如果请求成功，则必须将消息代码设置为与请求匹配的响应代码（即，下一个代码）。然后，响应有效负载在请求/响应描述中定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request has failed, then the message code MUST be set to 0xffff (error) and the payload MUST be an error_response message, as shown below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果请求失败，则消息代码必须设置为0xffff（错误），有效负载必须是错误响应消息，如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the message code is 0xFFFF, the payload MUST be an ErrorResponse:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当消息代码为0xFFFF时，有效负载必须为ErrorResponse：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         public struct {
           uint16             error_code;
           opaque             error_info&lt;0..2^16-1&gt;;
         } ErrorResponse;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         public struct {
           uint16             error_code;
           opaque             error_info&lt;0..2^16-1&gt;;
         } ErrorResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
error_code A numeric error code indicating the error that occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\一个数字错误代码，指示发生的错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
error_info An optional arbitrary byte string. Unless otherwise specified, this will be a UTF-8 text string that provides further information about what went wrong. Developers are encouraged to include enough diagnostic information to be useful in error_info. The specific text to be used and any relevant language or encoding thereof is left to the implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u输入可选的任意字节字符串。除非另有规定，否则这将是一个UTF-8文本字符串，提供有关出错原因的更多信息。鼓励开发人员在错误信息中包含足够有用的诊断信息。要使用的特定文本及其任何相关语言或编码留待实现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following error code values are defined. The numeric values for these are defined in Section 14.9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
定义了以下错误代码值。第14.9节定义了这些数值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Forbidden The requesting node does not have permission to make this request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\请求节点没有发出此请求的权限。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Not_Found The resource or node cannot be found or does not exist.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u找不到\u找不到资源或节点或节点不存在。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Request_Timeout A response to the request has not been received in a suitable amount of time. The requesting node MAY resend the request at a later time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u请求\u超时在适当的时间内未收到对请求的响应。请求节点可以稍后重新发送请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Data_Too_Old A store cannot be completed because the storage_time precedes the existing value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u数据\u太旧\u无法完成存储，因为存储时间早于现有值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Data_Too_Large A store cannot be completed because the requested object exceeds the size limits for that Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u数据\u太大\u无法完成存储，因为请求的对象超出了该类型的大小限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Generation_Counter_Too_Low A store cannot be completed because the generation counter precedes the existing value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u生成\u计数器\u过低\u无法完成存储，因为生成计数器位于现有值之前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Incompatible_with_Overlay A peer receiving the request is using a different overlay, overlay algorithm, or hash algorithm, or some other parameter that is inconsistent with the overlay configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u与\u覆盖不兼容\u接收请求的对等方正在使用不同的覆盖、覆盖算法或哈希算法，或者使用与覆盖配置不一致的某些其他参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unsupported_Forwarding_Option A node received the request with a forwarding options flagged as critical, but the node does not support this option. See Section 6.3.2.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\不支持\转发\选项节点收到转发选项标记为关键的请求，但该节点不支持此选项。见第6.3.2.3节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_TTL_Exceeded A peer received the request in which the TTL was decremented to zero. See Section 6.3.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u TTL\u超出了对等方收到的TTL减为零的请求。见第6.3.2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Message_Too_Large A peer received a request that was too large. See Section 6.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u消息\u太大\u对等方收到的请求太大。见第6.6节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Response_Too_Large A node would have generated a response that is too large per the max_response_length field.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u响应\u太大节点将生成一个响应，该响应相对于max\u Response\u length字段而言太大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Config_Too_Old A destination node received a request with a configuration sequence that is too old. See Section 6.3.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u配置\u太旧\u目标节点收到配置序列太旧的请求。见第6.3.2.1节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Config_Too_New A destination node received a request with a configuration sequence that is too new. See Section 6.3.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\配置\太新\目标节点收到配置序列太新的请求。见第6.3.2.1节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unknown_Kind A destination peer received a request with an unknown Kind-ID. See Section 7.4.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u未知\u种类目标对等方收到一个具有未知种类ID的请求。请参阅第7.4.1.2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_In_Progress An Attach to this peer is already in progress. See Section 6.5.1.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u正在\u正在附加到此对等方。见第6.5.1.2节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Unknown_Extension A destination node received a request with an unknown extension.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\u未知\u扩展目标节点接收到具有未知扩展名的请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Invalid_Message Something about this message is invalid, but it does not fit the other error codes. When this message is sent, implementations SHOULD provide some meaningful description in error_info to aid in debugging.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
错误\无效\消息有关此消息的某些内容无效，但不符合其他错误代码。发送此消息时，实现应在错误信息中提供一些有意义的描述，以帮助调试。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Exp_A For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了实验的目的，出现了错误。它不适用于任何类型的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Error_Exp_B For the purposes of experimentation. It is not meant for vendor-specific use of any sort and MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出于实验目的，出现错误。它不适用于任何类型的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. Security Block
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.3.4. 安全块
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The third part of a RELOAD message is the security block. The security block is represented by a SecurityBlock structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载消息的第三部分是安全块。安全块由SecurityBlock结构表示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
      CertificateType     type;   // From RFC 6091
      opaque              certificate&lt;0..2^16-1&gt;;
   } GenericCertificate;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
      CertificateType     type;   // From RFC 6091
      opaque              certificate&lt;0..2^16-1&gt;;
   } GenericCertificate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
      GenericCertificate certificates&lt;0..2^16-1&gt;;
      Signature          signature;
   } SecurityBlock;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct {
      GenericCertificate certificates&lt;0..2^16-1&gt;;
      Signature          signature;
   } SecurityBlock;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificates A bucket of certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书一桶证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature A signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
签名签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificates bucket SHOULD contain all the certificates necessary to verify every signature in both the message and the internal message objects, except for those certificates in a root-cert element of the current configuration file. This is the only location in the message which contains certificates, thus allowing only a single copy of each certificate to be sent. In systems that have an alternative certificate distribution mechanism, some certificates MAY be omitted. However, unless an alternative mechanism for immediately generating certificates, such as shared secret security (Section 13.4) is used, implementers MUST include all referenced certificates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书存储桶应包含验证消息和内部消息对象中的每个签名所需的所有证书，但当前配置文件的根证书元素中的证书除外。这是消息中唯一包含证书的位置，因此只允许发送每个证书的单个副本。在具有替代证书分发机制的系统中，可以省略某些证书。但是，除非使用另一种立即生成证书的机制，如共享秘密安全（第13.4节），否则实现者必须包括所有引用的证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NOTE TO IMPLEMENTERS: This requirement implies that a peer storing data is obligated to retain certificates for the data that it holds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现者注意：此要求意味着存储数据的对等方有义务保留其持有的数据的证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each certificate is represented by a GenericCertificate structure, which has the following contents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个证书由一个GenericCertificate结构表示，该结构具有以下内容：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the certificate, as defined in [RFC6091]. Only the use of X.509 certificates is defined in this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入[RFC6091]中定义的证书类型。本文档中仅定义了X.509证书的使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
certificate The encoded version of the certificate. For X.509 certificates, it is the Distinguished Encoding Rules (DER) form.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书证书证书的编码版本。对于X.509证书，它是可分辨编码规则（DER）表单。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The signature is computed over the payload and parts of the forwarding header. In case of a Store, the payload MUST contain an additional signature computed as described in Section 7.1. All signatures MUST be formatted using the Signature element. This element is also used in other contexts where signatures are needed. The input structure to the signature computation MAY vary depending on the data element being signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
签名是在有效载荷和转发报头的部分上计算的。对于存储，有效载荷必须包含按照第7.1节所述计算的附加签名。必须使用Signature元素格式化所有签名。此元素也用于需要签名的其他上下文中。签名计算的输入结构可能因被签名的数据元素而异。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     enum { invalidSignerIdentityType(0),
            cert_hash(1), cert_hash_node_id(2),
            none(3)
            (255) } SignerIdentityType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     enum { invalidSignerIdentityType(0),
            cert_hash(1), cert_hash_node_id(2),
            none(3)
            (255) } SignerIdentityType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
       select (identity_type) {
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
       select (identity_type) {
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         case cert_hash;
           HashAlgorithm      hash_alg;              // From TLS
           opaque             certificate_hash&lt;0..2^8-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         case cert_hash;
           HashAlgorithm      hash_alg;              // From TLS
           opaque             certificate_hash&lt;0..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         case cert_hash_node_id:
           HashAlgorithm      hash_alg;              // From TLS
           opaque             certificate_node_id_hash&lt;0..2^8-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         case cert_hash_node_id:
           HashAlgorithm      hash_alg;              // From TLS
           opaque             certificate_node_id_hash&lt;0..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         case none:
           /* empty */
         /* This structure may be extended with new types if necessary*/
       };
     } SignerIdentityValue;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         case none:
           /* empty */
         /* This structure may be extended with new types if necessary*/
       };
     } SignerIdentityValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
       SignerIdentityType     identity_type;
       uint16                 length;
       SignerIdentityValue    identity[SignerIdentity.length];
     } SignerIdentity;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
       SignerIdentityType     identity_type;
       uint16                 length;
       SignerIdentityValue    identity[SignerIdentity.length];
     } SignerIdentity;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
        SignatureAndHashAlgorithm     algorithm;   // From TLS
        SignerIdentity                identity;
        opaque                        signature_value&lt;0..2^16-1&gt;;
     } Signature;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
        SignatureAndHashAlgorithm     algorithm;   // From TLS
        SignerIdentity                identity;
        opaque                        signature_value&lt;0..2^16-1&gt;;
     } Signature;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Signature construct contains the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
签名构造包含以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
algorithm The signature algorithm in use. The algorithm definitions are found in the IANA TLS SignatureAlgorithm and HashAlgorithm registries. All implementations MUST support RSASSA-PKCS1-v1_5 [RFC3447] signatures with SHA-256 hashes [RFC6234].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
算法签名算法在使用中。算法定义可在IANA TLS SignatureAlgorithm和HashAlgorithm注册表中找到。所有实现必须支持带有SHA-256哈希[RFC6234]的RSASSA-PKCS1-v1_5[RFC3447]签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
identity The identity, as defined in the two paragraphs following this list, used to form the signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
标识本清单后面两段中定义的用于构成签名的标识。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature_value The value of the signature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
签名\u值签名的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Note that storage operations allow for special values of algorithm and identity. See the Store Request definition (Section 7.4.1.1) and the Fetch Response definition (Section 7.4.2.2).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
注意，存储操作允许算法和标识的特殊值。请参阅存储请求定义（第7.4.1.1节）和获取响应定义（第7.4.2.2节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two permitted identity formats, one for a certificate with only one Node-ID and one for a certificate with multiple Node-IDs. In the first case, the cert_hash type MUST be used. The hash_alg field is used to indicate the algorithm used to produce the hash. The certificate_hash contains the hash of the certificate object (i.e., the DER-encoded certificate).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有两种允许的标识格式，一种用于仅具有一个节点ID的证书，另一种用于具有多个节点ID的证书。在第一种情况下，必须使用cert_散列类型。hash_alg字段用于指示用于生成哈希的算法。证书散列包含证书对象（即，DER编码的证书）的散列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the second case, the cert_hash_node_id type MUST be used. The hash_alg is as in cert_hash, but the cert_hash_node_id is computed over the NodeId used to sign concatenated with the certificate; i.e., H(NodeId || certificate). The NodeId is represented without any framing or length fields, as simple raw bytes. This is safe because NodeIds are a fixed length for a given overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第二种情况下，必须使用cert\u hash\u node\u id类型。hash_alg与cert_hash中的一样，但是cert_hash_node_id是在用于与证书连接的签名的NodeId上计算的；i、 e.，H（NodeId | |证书）。NodeId表示为简单的原始字节，没有任何帧或长度字段。这是安全的，因为节点ID是给定覆盖的固定长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For signatures over messages, the input to the signature is computed over:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于消息上的签名，签名的输入通过以下方式计算：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
overlay || transaction_id || MessageContents || SignerIdentity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
覆盖| |事务| id | |消息内容| |签名身份
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where overlay and transaction_id come from the forwarding header and || indicates concatenation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中overlay和transaction_id来自转发头，| |表示连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The input to signatures over data values is different and is described in Section 7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据值上的签名输入不同，第7.1节对此进行了描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All RELOAD messages MUST be signed. Intermediate nodes do not verify signatures. Upon receipt (and fragment reassembly, if needed), the destination node MUST verify the signature and the authorizing certificate. If the signature fails, the implementation SHOULD simply drop the message and MUST NOT process it. This check provides a minimal level of assurance that the sending node is a valid part of the overlay, and it provides cryptographic authentication of the sending node. In addition, responses MUST be checked as follows by the requesting node:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有重新加载消息都必须签名。中间节点不验证签名。接收后（以及片段重组，如果需要），目标节点必须验证签名和授权证书。如果签名失败，实现应该简单地删除消息，并且不能处理它。此检查提供了发送节点是覆盖的有效部分的最低级别保证，并提供了发送节点的加密身份验证。此外，请求节点必须按如下方式检查响应：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The response to a message sent to a Node-ID MUST have been sent by that Node-ID unless the response has been sent to the wildcard Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 对发送到节点ID的消息的响应必须由该节点ID发送，除非该响应已发送到通配符Node-ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. The response to a message sent to a Resource-ID MUST have been sent by a Node-ID which is at least as close to the target Resource-ID as any node in the requesting node&#39;s Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 对发送到资源ID的消息的响应必须由至少与请求节点的邻居表中的任何节点一样接近目标资源ID的节点ID发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The second condition serves as a primitive check for responses from wildly wrong nodes but is not a complete check. Note that in periods of churn, it is possible for the requesting node to obtain a closer neighbor while the request is outstanding. This will cause the response to be rejected and the request to be retransmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第二个条件用作对来自错误节点的响应的基本检查，但不是完全检查。请注意，在搅动期间，请求节点可能在请求未完成时获得较近的邻居。这将导致拒绝响应并重新传输请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, some methods (especially Store) have additional authentication requirements, which are described in the sections covering those methods.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，一些方法（尤其是存储）具有附加的身份验证要求，这些要求在介绍这些方法的章节中进行了描述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. Overlay Topology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4. 覆盖拓扑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As discussed in previous sections, RELOAD defines a default overlay topology (CHORD-RELOAD) but allows for other topologies through the use of Topology Plug-ins. This section describes the requirements for new Topology Plug-ins and the methods that RELOAD provides for overlay topology maintenance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如前几节所述，重载定义了默认的覆盖拓扑（CHORD-RELOAD），但通过使用拓扑插件允许使用其他拓扑。本节介绍新拓扑插件的要求以及重载为覆盖拓扑维护提供的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. Topology Plug-in Requirements
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.1. 拓扑插件需求
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When specifying a new overlay algorithm, at least the following MUST be described:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指定新覆盖算法时，必须至少说明以下内容：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Joining procedures, including the contents of the Join message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 加入过程，包括加入消息的内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stabilization procedures, including the contents of the Update message, the frequency of topology probes and keepalives, and the mechanism used to detect when peers have disconnected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 稳定过程，包括更新消息的内容、拓扑探测和保留的频率，以及用于检测对等点何时断开连接的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Exit procedures, including the contents of the Leave message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 退出程序，包括离开消息的内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The length of the Resource-IDs and for DHTs the hash algorithm to compute the hash of an identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 资源ID的长度，对于DHTs，使用哈希算法计算标识符的哈希。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The procedures that peers use to route messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对等方用来路由消息的过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The replication strategy used to ensure data redundancy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 用于确保数据冗余的复制策略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All overlay algorithms MUST specify maintenance procedures that send Updates to clients and peers that have established connections to the peer responsible for a particular ID when the responsibility for that ID changes. Because tracking this information is difficult, overlay algorithms MAY simply specify that an Update is sent to all members of the Connection Table whenever the range of IDs for which the peer is responsible changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有覆盖算法都必须指定维护程序，当负责特定ID的对等方的责任发生变化时，这些程序将更新发送给已与负责该ID的对等方建立连接的客户端和对等方。由于跟踪此信息很困难，覆盖算法可能只指定只要对等方负责的ID范围发生变化，就会向连接表的所有成员发送更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. Methods and Types for Use by Topology Plug-ins
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2. 拓扑插件使用的方法和类型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the methods that Topology Plug-ins use to join, leave, and maintain the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节描述拓扑插件用于加入、离开和维护覆盖的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.1. Join
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.1. 参加
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A new peer (which already has credentials) uses the JoinReq message to join the overlay. The JoinReq is sent to the responsible peer depending on the routing mechanism described in the Topology Plug-in. This message notifies the responsible peer that the new peer is taking over some of the overlay and that it needs to synchronize its state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新的对等方（已具有凭据）使用JoinReq消息加入覆盖。根据拓扑插件中描述的路由机制，JoinReq被发送到负责的对等方。此消息通知负责的对等方，新对等方正在接管部分覆盖，并且需要同步其状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
            NodeId                joining_peer_id;
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } JoinReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
            NodeId                joining_peer_id;
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } JoinReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The minimal JoinReq contains only the Node-ID which the sending peer wishes to assume. Overlay algorithms MAY specify other data to appear in this request. Receivers of the JoinReq MUST verify that the joining_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最小JoinReq仅包含发送对等方希望采用的节点ID。覆盖算法可以指定此请求中出现的其他数据。JoinReq的接收者必须验证joining_peer_id字段是否与用于签署消息的节点id匹配，如果不匹配，则必须以错误拒绝消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because joins may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any JoinReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the Joining Node. Implementations MUST use DTLS anti-replay mechanisms, thus preventing replay attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于连接只能在直接相邻的节点之间执行，因此接收对等方必须验证其接收的任何JoinReq是否来自绑定到连接节点将采用的节点ID的传输信道。实现必须使用DTLS反重放机制，从而防止重放攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request succeeds, the responding peer responds with a JoinAns message, as defined below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果请求成功，响应的对等方将响应JoinAns消息，定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } JoinAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } JoinAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the request succeeds, the responding peer MUST follow up by executing the right sequence of Stores and Updates to transfer the appropriate section of the overlay space to the Joining Node. In addition, overlay algorithms MAY define data to appear in the response payload that provides additional information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果请求成功，响应的对等方必须执行正确的存储和更新顺序，将覆盖空间的适当部分转移到加入节点。此外，覆盖算法可定义出现在提供附加信息的响应有效载荷中的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Joining Nodes MUST verify that the signature on the JoinAns message matches the expected target (i.e., the adjacency over which they are joining). If not, they MUST discard the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加入节点必须验证JoinAns消息上的签名是否与预期目标匹配（即，它们加入的邻接）。如果没有，则必须丢弃该消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, nodes which cannot form connections SHOULD report an error to the user. However, implementations MUST provide some mechanism whereby nodes can determine that they are potentially the first node and can take responsibility for the overlay. (The idea is to avoid having ordinary nodes try to become responsible for the entire overlay during a partition.) This specification does not mandate any particular mechanism, but a configuration flag or setting seems appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常，无法形成连接的节点应向用户报告错误。但是，实现必须提供某种机制，节点可以据此确定自己可能是第一个节点，并负责覆盖。（这样做的目的是避免普通节点在分区期间试图对整个覆盖负责。）本规范不强制要求任何特定的机制，但配置标志或设置似乎是合适的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.2. Leave
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.2. 离开
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LeaveReq message is used to indicate that a node is exiting the overlay. A node SHOULD send this message to each peer with which it is directly connected prior to exiting the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveReq消息用于指示节点正在退出覆盖。在退出覆盖之前，节点应将此消息发送给与其直接连接的每个对等方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
            NodeId                leaving_peer_id;
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } LeaveReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
            NodeId                leaving_peer_id;
            opaque                overlay_specific_data&lt;0..2^16-1&gt;;
         } LeaveReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveReq contains only the Node-ID of the leaving peer. Overlay algorithms MAY specify other data to appear in this request. Receivers of the LeaveReq MUST verify that the leaving_peer_id field matches the Node-ID used to sign the message and, if not, the message MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveReq仅包含离开对等方的节点ID。覆盖算法可以指定此请求中出现的其他数据。LeaveReq的接收者必须验证leaving_peer_id字段是否与用于签署消息的节点id匹配，如果不匹配，则必须以错误拒绝消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because leaves may be executed only between nodes which are directly adjacent, receiving peers MUST verify that any LeaveReq they receive arrives from a transport channel that is bound to the Node-ID to be assumed by the leaving peer. This also prevents replay attacks, provided that DTLS anti-replay is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于leave只能在直接相邻的节点之间执行，因此接收对等方必须验证其接收到的任何LeaveReq是否来自传输信道，该传输信道绑定到将由离开对等方假定的节点ID。这还可以防止重播攻击，前提是使用DTLS anti-replay。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receiving a Leave request, a peer MUST update its own Routing Table and send the appropriate Store/Update sequences to re-stabilize the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
收到请假请求后，对等方必须更新自己的路由表，并发送适当的存储/更新序列以重新稳定覆盖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LeaveAns is an empty message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Leavans是一条空消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.3. Update
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.3. 使现代化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Update is the primary overlay-specific maintenance message. It is used by the sender to notify the recipient of the sender&#39;s view of the current state of the overlay (that is, its routing state), and it is up to the recipient to take whatever actions are appropriate to deal with the state change. In general, peers send Update messages to all their adjacencies whenever they detect a topology shift.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更新是主要的覆盖特定维护消息。发送方使用它来通知接收方发送方对覆盖当前状态（即其路由状态）的看法，接收方可以采取任何适当的措施来处理状态更改。通常，当节点检测到拓扑变化时，节点会向其所有相邻节点发送更新消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer receives an Attach request with the send_update flag set to True (Section 6.4.2.4.1), it MUST send an Update message back to the sender of the Attach request after completion of the corresponding ICE check and TLS connection. Note that the sender of such an Attach request may not have joined the overlay yet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等方收到附加请求且发送更新标志设置为True（第6.4.2.4.1节）时，它必须在完成相应的ICE检查和TLS连接后向附加请求的发送方发送更新消息。请注意，此类附加请求的发送方可能尚未加入覆盖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer detects through an Update that it is no longer responsible for any data value it is storing, it MUST attempt to Store a copy to the correct node unless it knows the newly responsible node already has a copy of the data. This prevents data loss during large-scale topology shifts, such as the merging of partitioned overlays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等方通过更新检测到它不再负责它正在存储的任何数据值时，它必须尝试将副本存储到正确的节点，除非它知道新负责的节点已经拥有数据的副本。这可以防止在大规模拓扑变换（例如合并分区覆盖）期间发生数据丢失。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the UpdateReq message are completely overlay specific. The UpdateAns response is expected to be either success or an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpdateReq消息的内容完全是覆盖特定的。UpdateAns响应预期为成功或错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4. RouteQuery
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4. 路线
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RouteQuery request allows the sender to ask a peer where they would route a message directed to a given destination. In other words, a RouteQuery for a destination X requests the Node-ID for the node that the receiving peer would next route to in order to get to X. A RouteQuery can also request that the receiving peer initiate an Update request to transfer the receiving peer&#39;s Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery请求允许发送方向对等方询问将消息路由到指定目的地的位置。换句话说，目的地X的RouteQuery请求接收对等方下一个路由到的节点的节点ID以到达X。RouteQuery还可以请求接收对等方发起更新请求以传输接收对等方的路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One important use of the RouteQuery request is to support iterative routing. The sender selects one of the peers in its Routing Table and sends it a RouteQuery message with the destination field set to the Node-ID or Resource-ID to which it wishes to route. The receiving peer responds with information about the peers to which the request would be routed. The sending peer MAY then use the Attach method to attach to that peer(s) and repeat the RouteQuery. Eventually, the sender gets a response from a peer that is closest to the identifier in the destination field as determined by the Topology Plug-in. At that point, the sender can send messages directly to that peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQuery请求的一个重要用途是支持迭代路由。发送方选择其路由表中的一个对等方，并向其发送一条RouteQuery消息，其中destination字段设置为其希望路由到的节点ID或资源ID。接收对等方用请求将路由到的对等方的信息进行响应。然后，发送对等方可以使用附加方法附加到该对等方并重复路由。最终，发送方从与拓扑插件确定的目标字段中的标识符最接近的对等方获得响应。此时，发送方可以直接向该对等方发送消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A RouteQueryReq message indicates the peer or resource that the requesting node is interested in. It also contains a &#34;send_update&#34; option that allows the requesting node to request a full copy of the other peer&#39;s Routing Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQueryReq消息表示请求节点感兴趣的对等方或资源。它还包含一个“send_update”选项，允许请求节点请求另一个对等方路由表的完整副本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           Boolean                send_update;
           Destination            destination;
           opaque                 overlay_specific_data&lt;0..2^16-1&gt;;
         } RouteQueryReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           Boolean                send_update;
           Destination            destination;
           opaque                 overlay_specific_data&lt;0..2^16-1&gt;;
         } RouteQueryReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the RouteQueryReq message are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RouteQueryReq消息的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send_update A single byte. This may be set to True to indicate that the requester wishes the responder to initiate an Update request immediately. Otherwise, this value MUST be set to False.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送并更新单个字节。这可以设置为True，以指示请求者希望响应者立即发起更新请求。否则，此值必须设置为False。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination The destination which the requester is interested in. This may be any valid destination object, including a Node-ID, opaque ID, or Resource-ID. Note: If implementations are using opaque IDs for privacy purposes, answering RouteQueryReqs for opaque IDs will allow the requester to translate an opaque ID. Implementations MAY wish to consider limiting the use of RouteQuery for opaque IDs in such cases.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目的地请求者感兴趣的目的地。这可能是任何有效的目的地对象，包括节点ID、不透明ID或资源ID。注意：如果实现为隐私目的使用不透明的IDS，则回答不透明ID的RouthQueQueQs将允许请求者翻译不透明ID。实现可能希望考虑在这种情况下限制使用RoutQu疑问用于不透明ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay_specific_data Other data as appropriate for the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖图\u特定\u数据适用于覆盖图的其他数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.4.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A response to a successful RouteQueryReq request is a RouteQueryAns message. This message is completely overlay specific.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对成功的RouteQueryReq请求的响应是RouteQueryAns消息。此消息完全是覆盖特定的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5. Probe
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5. 探查
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Probe provides primitive &#34;exploration&#34; services: it allows a node to determine which resources another node is responsible for. A probe can be addressed to a specific Node-ID or to the peer controlling a given location (by using a Resource-ID). In either case, the target node responds with a simple response containing some status information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Probe提供基本的“探索”服务：它允许一个节点确定另一个节点负责哪些资源。探测可以寻址到特定节点ID或控制给定位置的对等方（通过使用资源ID）。在这两种情况下，目标节点都会以包含一些状态信息的简单响应进行响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ProbeReq message contains a list (potentially empty) of the pieces of status information that the requester would like the responder to provide.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ProbeReq消息包含请求者希望响应者提供的状态信息的列表（可能为空）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidProbeInformationType(0), responsible_set(1),
               num_resources(2), uptime(3), (255) }
             ProbeInformationType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidProbeInformationType(0), responsible_set(1),
               num_resources(2), uptime(3), (255) }
             ProbeInformationType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ProbeInformationType     requested_info&lt;0..2^8-1&gt;;
        } ProbeReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ProbeInformationType     requested_info&lt;0..2^8-1&gt;;
        } ProbeReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The currently defined values for ProbeInformationType are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ProbeInformation Type当前定义的值为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responsible_set Indicates that the peer should Respond with the fraction of the overlay for which the responding peer is responsible.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
responsible_set表示对等方应使用响应对等方负责的覆盖部分进行响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
num_resources Indicates that the peer should Respond with the number of resources currently being stored by the peer. Note that multiple values under the same Resource-ID are counted only once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
num_resources表示对等方应响应对等方当前存储的资源数量。请注意，同一资源ID下的多个值仅计数一次。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
uptime Indicates that the peer should Respond with how long the peer has been up, in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
正常运行时间表示对等机应响应对等机已运行的时间，以秒为单位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.4.2.5.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A successful ProbeAns response contains the information elements requested by the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功的ProbeAns响应包含对等方请求的信息元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           select (type) {
             case responsible_set:
               uint32             responsible_ppb;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           select (type) {
             case responsible_set:
               uint32             responsible_ppb;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
case num_resources: uint32 num_resources;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
案例数量资源：uint32数量资源；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
case uptime: uint32 uptime;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-13">
案例正常运行时间：uint32正常运行时间；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             /* This type may be extended */
           };
         } ProbeInformationData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             /* This type may be extended */
           };
         } ProbeInformationData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           ProbeInformationType    type;
           uint8                   length;
           ProbeInformationData    value;
         } ProbeInformation;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           ProbeInformationType    type;
           uint8                   length;
           ProbeInformationData    value;
         } ProbeInformation;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           ProbeInformation        probe_info&lt;0..2^16-1&gt;;
         } ProbeAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           ProbeInformation        probe_info&lt;0..2^16-1&gt;;
         } ProbeAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A ProbeAns message contains a sequence of ProbeInformation structures. Each has a &#34;length&#34; indicating the length of the following value field. This structure allows for unknown option types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ProbeAns消息包含一系列ProbeInformation结构。每个字段都有一个“长度”，表示以下值字段的长度。此结构允许未知的选项类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each of the current possible Probe information types is a 32-bit unsigned integer. For type &#34;responsible_ppb&#34;, it is the fraction of the overlay for which the peer is responsible, in parts per billion. For type &#34;num_resources&#34;, it is the number of resources the peer is storing. For the type &#34;uptime&#34;, it is the number of seconds the peer has been up.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个当前可能的探测信息类型都是32位无符号整数。对于类型“responsible_ppb”，它是对等方负责的覆盖部分，单位为十亿分之一。对于类型“num_resources”，它是对等方存储的资源数量。对于“正常运行时间”类型，它是对等机已运行的秒数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The responding peer SHOULD include any values that the requesting node requested and that it recognizes. They SHOULD be returned in the requested order. Any other values MUST NOT be returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
响应的对等方应包括请求节点请求并识别的任何值。它们应按要求的顺序返回。不得返回任何其他值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. Forwarding and Link Management Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5. 转发和链路管理层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each node maintains connections to a set of other nodes defined by the Topology Plug-in. This section defines the methods RELOAD uses to form and maintain connections between nodes in the overlay. Three methods are defined:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个节点维护与拓扑插件定义的一组其他节点的连接。本节定义重载用于形成和维护覆盖中节点之间的连接的方法。定义了三种方法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Attach Used to form RELOAD connections between nodes using ICE for NAT traversal. When node A wants to connect to node B, it sends an Attach message to node B through the overlay. The Attach contains A&#39;s ICE parameters. B responds with its ICE parameters, and the two nodes perform ICE to form connection. Attach also allows two nodes to connect via No-ICE instead of full ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附加用于使用ICE在节点之间形成重新加载连接以进行NAT遍历。当节点A想要连接到节点B时，它通过覆盖向节点B发送附加消息。“附加”包含一个用户的ICE参数。B以其ICE参数响应，两个节点执行ICE以形成连接。“附加”还允许两个节点通过无冰而不是完全冰进行连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttach Used to form application-layer connections between nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttach用于在节点之间形成应用层连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping A simple request/response which is used to verify connectivity of the target peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping一个简单的请求/响应，用于验证目标对等方的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1. Attach
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1. 贴上
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node sends an Attach request when it wishes to establish a direct Overlay Link connection to another node for the purpose of sending RELOAD messages. A client that can establish a connection directly need not send an Attach, as described in the second bullet of Section 4.2.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点希望建立到另一个节点的直接覆盖链路连接以发送重新加载消息时，会发送附加请求。可以直接建立连接的客户端无需发送附件，如第4.2.1节第二个项目符号所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As described in Section 6.1, an Attach may be routed to either a Node-ID or a Resource-ID. An Attach routed to a specific Node-ID will fail if that node is not reached. An Attach routed to a Resource-ID will establish a connection with the peer currently responsible for that Resource-ID, which may be useful in establishing a direct connection to the responsible peer for use with frequent or large resource updates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如第6.1节所述，连接可以路由到节点ID或资源ID。如果未到达该节点，则路由到特定节点ID的连接将失败。路由到资源ID的连接将与当前负责该资源ID的对等方建立连接，这可能有助于建立到负责对等方的直接连接，以用于频繁或大规模的资源更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Attach, in and of itself, does not result in updating the Routing Table of either node. That function is performed by Updates. If node A has Attached to node B, but has not received any Updates from B, it MAY route messages which are directly addressed to B through that channel, but it MUST NOT route messages through B to other peers via that channel. The process of Attaching is separate from the process of becoming a peer (using Join and Update), to prevent half-open states where a node has started to form connections but is not really ready to act as a peer. Thus, clients (unlike peers) can simply Attach without sending Join or Update.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附加本身不会导致更新任一节点的路由表。该功能由更新执行。如果节点A已连接到节点B，但未收到来自B的任何更新，则它可以通过该通道将直接寻址到B的消息路由，但它不得通过该通道将消息通过B路由到其他对等方。连接过程与成为对等体的过程（使用连接和更新）是分开的，以防止节点已开始形成连接但尚未真正准备好充当对等体的半开放状态。因此，客户机（与对等机不同）可以简单地连接，而无需发送Join或Update。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Attach request message contains the requesting node ICE connection parameters formatted into a binary structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附加请求消息包含格式化为二进制结构的请求节点ICE连接参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidOverlayLinkType(0), DTLS-UDP-SR(1),
               DTLS-UDP-SR-NO-ICE(3), TLS-TCP-FH-NO-ICE(4),
               (255) } OverlayLinkType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidOverlayLinkType(0), DTLS-UDP-SR(1),
               DTLS-UDP-SR-NO-ICE(3), TLS-TCP-FH-NO-ICE(4),
               (255) } OverlayLinkType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidCandType(0),
               host(1), srflx(2), /* RESERVED(3), */ relay(4),
               (255) } CandType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidCandType(0),
               host(1), srflx(2), /* RESERVED(3), */ relay(4),
               (255) } CandType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                name&lt;0..2^16-1&gt;;
          opaque                value&lt;0..2^16-1&gt;;
        } IceExtension;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                name&lt;0..2^16-1&gt;;
          opaque                value&lt;0..2^16-1&gt;;
        } IceExtension;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          IpAddressPort         addr_port;
          OverlayLinkType       overlay_link;
          opaque                foundation&lt;0..255&gt;;
          uint32                priority;
          CandType              type;
          select (type) {
            case host:
              ;          /* Empty */
            case srflx:
            case relay:
              IpAddressPort     rel_addr_port;
          };
          IceExtension          extensions&lt;0..2^16-1&gt;;
        } IceCandidate;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          IpAddressPort         addr_port;
          OverlayLinkType       overlay_link;
          opaque                foundation&lt;0..255&gt;;
          uint32                priority;
          CandType              type;
          select (type) {
            case host:
              ;          /* Empty */
            case srflx:
            case relay:
              IpAddressPort     rel_addr_port;
          };
          IceExtension          extensions&lt;0..2^16-1&gt;;
        } IceCandidate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                ufrag&lt;0..2^8-1&gt;;
          opaque                password&lt;0..2^8-1&gt;;
          opaque                role&lt;0..2^8-1&gt;;
          IceCandidate          candidates&lt;0..2^16-1&gt;;
          Boolean               send_update;
        } AttachReqAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                ufrag&lt;0..2^8-1&gt;;
          opaque                password&lt;0..2^8-1&gt;;
          opaque                role&lt;0..2^8-1&gt;;
          IceCandidate          candidates&lt;0..2^16-1&gt;;
          Boolean               send_update;
        } AttachReqAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values contained in AttachReqAns are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附件中包含的值为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ufrag The username fragment (from ICE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ufrag用户名片段（来自ICE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
password The ICE password.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
输入ICE密码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
role An active/passive/actpass attribute from RFC 4145 [RFC4145]. This value MUST be &#34;passive&#34; for the offerer (the peer sending the Attach request) and &#34;active&#34; for the answerer (the peer sending the Attach response).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
角色：来自RFC 4145[RFC4145]的主动/被动/actpass属性。此值对于提供方（发送附加请求的对等方）必须为“被动”，对于应答方（发送附加响应的对等方）必须为“主动”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
candidates One or more ICE candidate values, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
候选一个或多个ICE候选值，如下所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
send_update Has the same meaning as the send_update field in RouteQueryReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送更新与RouteQueryReq中的发送更新字段具有相同的含义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each ICE candidate is represented as an IceCandidate structure, which is a direct translation of the information from the ICE string structures, with the exception of the component ID. Since there is only one component, it is always 1, and thus left out of the structure. The remaining values are specified as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个ICE候选者都表示为ICE候选者结构，它是ICE字符串结构信息的直接翻译，但组件ID除外。由于只有一个组件，因此它始终为1，因此被排除在结构之外。其余的值指定如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
addr_port Corresponds to the ICE connection-address and port productions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
addr_端口对应于ICE连接地址和端口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay_link Corresponds to the ICE transport production. Overlay Link protocols used with No-ICE MUST specify &#34;No-ICE&#34; in their description. Future overlay link values can be added by defining new OverlayLinkType values in the IANA registry as described in Section 14.10. Future extensions to the encapsulation or framing that provide for backward compatibility with the previously specified encapsulation or framing values MUST use the same OverlayLinkType value that was previously defined. OverlayLinkType protocols are defined in Section 6.6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重叠_链路对应于冰输送生产。在无ICE的情况下使用的覆盖链路协议必须在其描述中指定“无ICE”。如第14.10节所述，可以通过在IANA注册表中定义新的OverlayLinkType值来添加未来的覆盖链接值。为封装或框架提供向后兼容性的封装或框架的未来扩展必须使用先前定义的相同OverlayLinkType值。第6.6节定义了OverlyLink类型协议
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
A single AttachReqAns MUST NOT include both candidates whose OverlayLinkType protocols use ICE (the default) and candidates that specify &#34;No-ICE&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
单个附件不能同时包含其OverlyLink类型协议使用ICE（默认）的候选者和指定“无ICE”的候选者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
foundation Corresponds to the ICE foundation production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
地基对应于冰基础的生产。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
priority Corresponds to the ICE priority production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
优先级对应于ICE优先级生产。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type Corresponds to the ICE cand-type production.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型对应于ICE cand类型产品。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rel_addr_port Corresponds to the ICE rel-addr and rel-port productions. It is present only for types &#34;relay&#34;, &#34;prfix&#34;, and &#34;srflx&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
rel_addr_port对应于ICE rel addr和rel port产品。它仅适用于“继电器”、“prfix”和“srflx”类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
extensions ICE extensions. The name and value fields correspond to binary translations of the equivalent fields in the ICE extensions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
扩展冰扩展。名称和值字段对应于ICE扩展中等效字段的二进制翻译。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These values should be generated using the procedures described in Section 6.5.1.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应使用第6.5.1.3节所述程序生成这些值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer receives an Attach request, it MUST determine how to process the request as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果对等方收到附加请求，它必须按照以下方式确定如何处理该请求：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer has not initiated an Attach request to the originating peer of this Attach request, it MUST process this request and SHOULD generate its own response with an AttachReqAns. It should then begin ICE checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果该对等方尚未向该附加请求的发起对等方发起附加请求，则该对等方必须处理该请求，并应使用AttachReqAns生成自己的响应。然后开始冰上检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer has already sent an Attach request to and received the response from the originating peer of this Attach request and, as a result, an ICE check and TLS connection are in progress, then it SHOULD generate an Error_In_Progress error instead of an AttachReqAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果该对等方已经向该附加请求的发起对等方发送了附加请求，并从该附加请求的发起对等方收到了响应，因此ICE检查和TLS连接正在进行中，则该对等方应生成错误而不是附加错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer has already sent an Attach request to but not yet received the response from the originating peer of this Attach request, it SHOULD apply the following tie-breaker heuristic to determine how to handle this Attach request and the incomplete Attach request it has sent out:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果该对等方已经向该附加请求的发起对等方发送了附加请求，但尚未收到来自该附加请求的发起对等方的响应，则该对等方应应用以下联系断路器启发式方法来确定如何处理该附加请求及其发送的不完整附加请求：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If the peer&#39;s own Node-ID is smaller when compared as big-endian unsigned integers, it MUST cancel retransmission of its own incomplete Attach request. It MUST then process this Attach request, generate an AttachReqAns response, and proceed with the corresponding ICE check.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 如果对等方自身的节点ID与big-endian无符号整数相比更小，则必须取消自身未完成附加请求的重新传输。然后，它必须处理该附加请求，生成一个AttachReqAns响应，并进行相应的ICE检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* If the peer&#39;s own Node-ID is larger when compared as big-endian unsigned integers, it MUST generate an Error_In_Progress error to this Attach request, and then proceed to wait for and complete the Attach and the corresponding ICE check it has originated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
* 如果对等方自身的节点ID与big-endian无符号整数相比更大，则它必须为此附加请求生成一个Error_In_Progress Error，然后继续等待并完成附加及其发起的相应ICE检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the peer is overloaded or detects some other kind of error, it MAY generate an error instead of an AttachReqAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果对等方过载或检测到其他类型的错误，它可能会生成一个错误而不是AttachReqAns。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer receives an Attach response, it SHOULD parse the response and begin its own ICE checks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等方收到附加响应时，它应该解析响应并开始自己的ICE检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.3. Using ICE with RELOAD
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.3. 使用冰进行重新装载
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the profile of ICE that is used with RELOAD. RELOAD implementations MUST implement full ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节描述了用于重新加载的冰的轮廓。重新加载实现必须实现完全ICE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In ICE, as defined by [RFC5245], the Session Description Protocol (SDP) is used to carry the ICE parameters. In RELOAD, this function is performed by a binary encoding in the Attach method. This encoding is more restricted than the SDP encoding because the RELOAD environment is simpler:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在ICE中，如[RFC5245]所定义，会话描述协议（SDP）用于承载ICE参数。在RELOAD中，此功能通过Attach方法中的二进制编码执行。此编码比SDP编码更受限制，因为重新加载环境更简单：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Only a single media stream is supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 仅支持单个媒体流。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o In this case, the &#34;stream&#34; refers not to RTP or other types of media, but rather to a connection for RELOAD itself or other application-layer protocols, such as SIP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在这种情况下，“流”不是指RTP或其他类型的媒体，而是指用于重新加载自身的连接或其他应用层协议，例如SIP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELOAD allows only for a single offer/answer exchange. Unlike the usage of ICE within SIP, there is never a need to send a subsequent offer to update the default candidates to match the ones selected by ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 重新加载仅允许一次提供/应答交换。与SIP中ICE的使用不同，无需发送后续报价来更新默认候选项以匹配ICE选择的候选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent follows the ICE specification as described in [RFC5245] with the changes and additional procedures described in the subsections below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代理商遵循[RFC5245]中所述的ICE规范，并进行以下小节中所述的变更和附加程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.4. Collecting STUN Servers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.4. 收集STUN服务器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE relies on the node having one or more Session Traversal Utilities for NAT (STUN) servers to use. In conventional ICE, it is assumed that nodes are configured with one or more STUN servers through some out-of-band mechanism. This is still possible in RELOAD, but RELOAD also learns STUN servers as it connects to other peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE依赖于节点有一个或多个会话遍历实用程序供NAT（STUN）服务器使用。在传统ICE中，假设节点通过一些带外机制配置一个或多个STUN服务器。这在重新加载中仍然是可能的，但重新加载还可以在连接到其他对等服务器时学习STUN服务器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer on a well-provisioned wide-area overlay will be configured with one or more bootstrap nodes. These nodes make an initial list of STUN servers. However, as the peer forms connections with additional peers, it builds more peers that it can use like STUN servers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置良好的广域覆盖上的对等节点将配置一个或多个引导节点。这些节点构成STUN服务器的初始列表。然而，随着对等机与其他对等机形成连接，它会构建更多的对等机，可以像STUN服务器一样使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because complicated NAT topologies are possible, a peer may need more than one STUN server. Specifically, a peer that is behind a single NAT will typically observe only two IP addresses in its STUN checks: its local address and its server reflexive address from a STUN server outside its NAT. However, if more NATs are involved, a peer may
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因为复杂的NAT拓扑是可能的，所以对等方可能需要多个STUN服务器。具体来说，一个NAT后面的对等方在其STUN检查中通常只观察到两个IP地址：其本地地址和来自NAT之外的STUN服务器的服务器自反地址。但是，如果涉及更多NAT，则对等方可能会
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
learn additional server reflexive addresses (which vary based on where in the topology the STUN server is). To maximize the chance of achieving a direct connection, a peer SHOULD group other peers by the peer-reflexive addresses it discovers through them. It SHOULD then select one peer from each group to use as a STUN server for future connections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
了解其他服务器自反地址（根据STUN服务器在拓扑中的位置而有所不同）。为了最大化实现直接连接的机会，对等方应根据通过其发现的对等方反射地址对其他对等方进行分组。然后，它应该从每个组中选择一个对等方，用作将来连接的STUN服务器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Only peers to which the peer currently has connections may be used. If the connection to that host is lost, it MUST be removed from the list of STUN servers, and a new server from the same group MUST be selected unless there are no others servers in the group, in which case some other peer MAY be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
只能使用对等方当前具有连接的对等方。如果与该主机的连接丢失，则必须将其从STUN服务器列表中删除，并且必须选择同一组中的新服务器，除非该组中没有其他服务器，在这种情况下，可能会使用其他对等服务器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.5. Gathering Candidates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.5. 召集候选人
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node wishes to establish a connection for the purposes of RELOAD signaling or application signaling, it follows the process of gathering candidates as described in Section 4 of ICE [RFC5245]. RELOAD utilizes a single component. Consequently, gathering for these &#34;streams&#34; requires a single component. In the case where a node has not yet found a TURN server, the agent would not include a relayed candidate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点希望为重新加载信令或应用信令目的建立连接时，它遵循ICE[RFC5245]第4节中描述的收集候选节点的过程。重新加载使用单个组件。因此，收集这些“流”需要单个组件。在节点尚未找到回合服务器的情况下，代理将不包括中继候选。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ICE specification assumes that an ICE agent is configured with, or somehow knows of, TURN and STUN servers. RELOAD provides a way for an agent to learn these by querying the overlay, as described in Sections 6.5.1.4 and 9.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE规范假设ICE代理配置了TURN和STUN服务器，或者以某种方式知道这些服务器。如第6.5.1.4节和第9节所述，重载为代理提供了一种通过查询覆盖来了解这些信息的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The default candidate selection described in Section 4.1.4 of ICE is ignored; defaults are not signaled or utilized by RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
忽略ICE第4.1.4节中描述的默认候选选择；默认值不会被重新加载通知或使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative to using the full ICE supported by the Attach request is to use the No-ICE mechanism by providing candidates with &#34;No-ICE&#34; Overlay Link protocols. Configuration for the overlay indicates whether or not these Overlay Link protocols can be used. An overlay MUST be either all ICE or all No-ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用附加请求支持的完整ICE的另一种替代方法是使用无ICE机制，为候选对象提供“无ICE”覆盖链路协议。覆盖配置指示是否可以使用这些覆盖链路协议。覆盖层必须为全冰或全无冰。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No-ICE will not work in all the scenarios where ICE would work, but in some cases, particularly those with no NATs or firewalls, it will work.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
没有ICE不会在ICE可以工作的所有场景中工作，但在某些情况下，特别是在没有NAT或防火墙的情况下，它会工作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.6. Prioritizing Candidates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.6. 优先考虑候选人
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Standardization of additional protocols for use with ICE is expected, including TCP [RFC6544] and protocols such as the Stream Control Transmission Protocol (SCTP) [RFC4960] and Datagram Congestion Control Protocol (DCCP) [RFC4340]. UDP encapsulations for SCTP and DCCP would expand the Overlay Link protocols available for RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
预计将对ICE使用的附加协议进行标准化，包括TCP[RFC6544]和诸如流控制传输协议（SCTP）[RFC4960]和数据报拥塞控制协议（DCCP）[RFC4340]等协议。SCTP和DCCP的UDP封装将扩展可用于重新加载的覆盖链路协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When additional protocols are available, the following prioritization is RECOMMENDED:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当有其他协议可用时，建议采用以下优先顺序：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Highest priority is assigned to protocols that offer well-understood congestion and flow control without head-of-line blocking, for example, SCTP without message ordering, DCCP, and those protocols encapsulated using UDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 最高优先级被分配给那些提供众所周知的拥塞和流量控制而不存在线路头阻塞的协议，例如，没有消息排序的SCTP、DCCP以及使用UDP封装的协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Second highest priority is assigned to protocols that offer well-understood congestion and flow control, but that have head-of-line blocking, such as TCP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 第二高优先级被分配给协议，这些协议提供了众所周知的拥塞和流量控制，但具有行首阻塞，如TCP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Lowest priority is assigned to protocols encapsulated over UDP that do not implement well-established congestion control algorithms. The DTLS/UDP with Simple Reliability (SR) overlay link protocol is an example of such a protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 将最低优先级分配给通过UDP封装的协议，这些协议未实现完善的拥塞控制算法。具有简单可靠性（SR）的DTLS/UDP覆盖链路协议就是此类协议的一个示例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Head-of-line blocking is undesirable in an Overlay Link protocol, because the messages carried on a RELOAD link are independent, rather than stream-oriented. Therefore, if message N on a link is lost, delaying message N+1 on that same link until N is successfully retransmitted does nothing other than increase the latency for the transaction of message N+1, as they are unrelated to each other. Therefore, while the high quality, performance, and availability of modern TCP implementations makes them very attractive, their performance as Overlay Link protocols is not optimal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在覆盖链路协议中，行首阻塞是不可取的，因为在重新加载链路上承载的消息是独立的，而不是面向流的。因此，如果链路上的消息N丢失，则延迟同一链路上的消息N+1直到N成功重新传输，除了增加消息N+1的事务的延迟外，没有其他作用，因为它们彼此无关。因此，尽管现代TCP实现的高质量、高性能和高可用性使它们非常有吸引力，但它们作为覆盖链路协议的性能并不是最优的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that none of the protocols defined in this document meets these conditions, but it is expected that new Overlay Link protocols defined in the future will fill this gap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，本文档中定义的协议均不满足这些条件，但预计未来定义的新覆盖链路协议将填补这一空白。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.7. Encoding the Attach Message
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.7. 对附加消息进行编码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Section 4.3 of ICE describes procedures for encoding the SDP for conveying RELOAD candidates. Instead of actually encoding an SDP message, the candidate information (IP address and port and transport protocol, priority, foundation, type, and related address) is carried within the attributes of the Attach request or its response. Similarly, the username fragment and password are carried in the Attach message or its response. Section 6.5.1 describes the detailed attribute encoding for Attach. The Attach request and its response do not contain any default candidates or the ice-lite attribute, as these features of ICE are not used by RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE的第4.3节描述了对SDP进行编码以传输重新加载候选者的程序。代替实际编码SDP消息，在附加请求或其响应的属性内携带候选信息（IP地址和端口和传输协议、优先级、基础、类型和相关地址）。类似地，用户名片段和密码也包含在附加消息或其响应中。第6.5.1节描述了附件的详细属性编码。附加请求及其响应不包含任何默认候选项或ice lite属性，因为重新加载不使用ice的这些功能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the Attach request contains the candidate information and short term credentials, it is considered as an offer for a single media stream that happens to be encoded in a format different than SDP, but is otherwise considered a valid offer for the purposes of following
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于附加请求包含候选信息和短期凭证，因此它被视为对碰巧以不同于SDP的格式编码的单个媒体流的提供，但出于以下目的，它被视为有效提供
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the ICE specification. Similarly, the Attach response is considered a valid answer for the purposes of following the ICE specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE规范。同样，出于遵循ICE规范的目的，附加响应被视为有效答案。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.8. Verifying ICE Support
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.8. 验证冰支撑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent MUST skip the verification procedures in Sections 5.1 and 6.1 of ICE. Since RELOAD requires full ICE from all agents, this check is not required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代理商必须跳过ICE第5.1节和第6.1节中的验证程序。由于重新装载需要所有代理的完全冰，因此不需要进行此检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.9. Role Determination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.9. 角色确定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The roles of controlling and controlled, as described in Section 5.2 of ICE, are still utilized with RELOAD. However, the offerer (the entity sending the Attach request) will always be controlling, and the answerer (the entity sending the Attach response) will always be controlled. The connectivity checks MUST still contain the ICE-CONTROLLED and ICE-CONTROLLING attributes, however, even though the role reversal capability for which they are defined will never be needed with RELOAD. This is to allow for a common codebase between ICE for RELOAD and ICE for SDP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如ICE第5.2节所述，控制和控制的作用仍用于重新加载。但是，报价人（发送附加请求的实体）将始终处于控制状态，而应答人（发送附加响应的实体）将始终处于控制状态。然而，连接检查必须仍然包含ICE控制和ICE控制属性，即使重新加载时永远不需要定义它们的角色转换功能。这是为了在用于重新加载的ICE和用于SDP的ICE之间允许一个公共代码基。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10. Full ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10. 全冰
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the overlay uses ICE, connectivity checks and nominations are used as in regular ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当覆盖层使用ICE时，连接检查和指定将与常规ICE中一样使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.1. Connectivity Checks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.1. 连通性检查
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The processes of forming check lists in Section 5.7 of ICE, scheduling checks in Section 5.8, and checking connectivity checks in Section 7 are used with RELOAD without change.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE第5.7节中形成检查表、第5.8节中安排检查以及第7节中检查连通性检查的过程与重新加载一起使用，无需更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.2. Concluding ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.2. 结冰
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures in Section 8 of ICE are followed to conclude ICE, with the following exceptions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据ICE第8节中的程序得出ICE，但以下例外情况除外：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The controlling agent MUST NOT attempt to send an updated offer once the state of its single media stream reaches Completed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一旦控制代理的单个媒体流达到完成状态，则控制代理不得尝试发送更新的报价。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Once the state of ICE reaches Completed, the agent can immediately free all unused candidates. This is because RELOAD does not have the concept of forking, and thus the three-second delay in Section 8.3 of ICE does not apply.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一旦ICE状态达到完成状态，代理可以立即释放所有未使用的候选者。这是因为重新加载没有分叉的概念，因此ICE第8.3节中的三秒延迟不适用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.3. Media Keepalives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.10.3. 媒体禁区
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
STUN MUST be utilized for the keepalives described in Section 10 of ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须对ICE第10节中所述的keepalives使用眩晕。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.11. No-ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.11. 不加冰
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
No-ICE is selected when either side has provided &#34;no ICE&#34; Overlay Link candidates. STUN is not used for connectivity checks when doing No-ICE; instead, the DTLS or TLS handshake (or similar security layer of future overlay link protocols) forms the connectivity check. The certificate exchanged during the TLS or DTLS handshake MUST match the node which sent the AttachReqAns, and if it does not, the connection MUST be closed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当任何一方提供了“无ICE”覆盖链接候选时，将不选择ICE。在不执行ICE时，STUN不用于连接检查；相反，DTLS或TLS握手（或未来覆盖链路协议的类似安全层）形成连接检查。TLS或DTLS握手期间交换的证书必须与发送附件的节点匹配，如果不匹配，则必须关闭连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.12. Subsequent Offers and Answers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.12. 后续报价和答复
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent MUST NOT send a subsequent offer or answer. Thus, the procedures in Section 9 of ICE MUST be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代理人不得发送后续报价或答复。因此，必须忽略ICE第9节中的程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.13. Sending Media
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.13. 发送媒体
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The procedures of Section 11 of ICE apply to RELOAD as well. However, in this case, the &#34;media&#34; takes the form of application-layer protocols (e.g., RELOAD) over TLS or DTLS. Consequently, once ICE processing completes, the agent will begin TLS or DTLS procedures to establish a secure connection. The node that sent the Attach request MUST be the TLS server. The other node MUST be the TLS client. The server MUST request TLS client authentication. The nodes MUST verify that the certificate presented in the handshake matches the identity of the other peer as found in the Attach message. Once the TLS or DTLS signaling is complete, the application protocol is free to use the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE第11节的程序也适用于重新装载。然而，在这种情况下，“媒体”采用TLS或DTL上的应用层协议（例如，重新加载）的形式。因此，一旦ICE处理完成，代理将开始TLS或DTLS程序以建立安全连接。发送附加请求的节点必须是TLS服务器。另一个节点必须是TLS客户端。服务器必须请求TLS客户端身份验证。节点必须验证握手中提供的证书是否与附加消息中发现的其他对等方的身份匹配。一旦TLS或DTLS信令完成，应用程序协议就可以自由使用连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The concept of a previous selected pair for a component does not apply to RELOAD, since ICE restarts are not possible with RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组件的上一个选定对的概念不适用于重新加载，因为重新加载时不可能重新启动ICE。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.14. Receiving Media
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.1.14. 接收媒体
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An agent MUST be prepared to receive packets for the application protocol (TLS or DTLS carrying RELOAD) at any time. The jitter and RTP considerations in Section 11 of ICE do not apply to RELOAD.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
代理必须准备好随时接收应用程序协议（TLS或DTL）的数据包。ICE第11节中的抖动和RTP考虑不适用于重新加载。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2. AppAttach
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2. 阿帕塔奇
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node sends an AppAttach request when it wishes to establish a direct connection to another node for the purposes of sending application-layer messages. AppAttach is nearly identical to Attach,
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点希望建立到另一个节点的直接连接以发送应用层消息时，会发送AppAttach请求。AppAttach与Attach几乎相同，
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
except for the purpose of the connection: it is used to transport non-RELOAD &#34;media&#34;. A separate request is used to avoid implementer confusion between the two methods (this was found to be a real problem with initial implementations). The AppAttach request and its response contain an application attribute, which indicates what protocol is to be run over the connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
连接目的除外：用于传输非重新加载的“介质”。使用一个单独的请求来避免实现者混淆这两种方法（这被发现是初始实现的一个实际问题）。AppAttach请求及其响应包含一个应用程序属性，该属性指示要在连接上运行的协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An AppAttachReq message contains the requesting node&#39;s ICE connection parameters formatted into a binary structure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttachReq消息包含格式化为二进制结构的请求节点的ICE连接参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                  ufrag&lt;0..2^8-1&gt;;
          opaque                  password&lt;0..2^8-1&gt;;
          uint16                  application;
          opaque                  role&lt;0..2^8-1&gt;;
          IceCandidate            candidates&lt;0..2^16-1&gt;;
        } AppAttachReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                  ufrag&lt;0..2^8-1&gt;;
          opaque                  password&lt;0..2^8-1&gt;;
          uint16                  application;
          opaque                  role&lt;0..2^8-1&gt;;
          IceCandidate            candidates&lt;0..2^16-1&gt;;
        } AppAttachReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values contained in AppAttachReq and AppAttachAns are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AppAttachReq和AppAttachAns中包含的值为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ufrag The username fragment (from ICE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ufrag用户名片段（来自ICE）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
password The ICE password.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
输入ICE密码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
application A 16-bit Application-ID, as defined in the Section 14.5. This number represents the IANA-registered application that is going to send data on this connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应用程序一个16位应用程序ID，如第14.5节所定义。此数字表示将在此连接上发送数据的IANA注册应用程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
role An active/passive/actpass attribute from RFC 4145 [RFC4145].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
角色：来自RFC 4145[RFC4145]的主动/被动/actpass属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
candidates One or more ICE candidate values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
候选一个或多个ICE候选值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The application using the connection that is set up with this request is responsible for providing traffic of sufficient frequency to keep the NAT and Firewall binding alive. Applications will often send traffic every 25 seconds to ensure this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用此请求建立的连接的应用程序负责提供足够频率的通信量，以保持NAT和防火墙绑定处于活动状态。应用程序通常每25秒发送一次流量，以确保这一点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.2.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer receives an AppAttach request, it SHOULD process the request and generate its own response with a AppAttachAns. It should then begin ICE checks. When a peer receives an AppAttach response, it SHOULD parse the response and begin its own ICE checks. If the Application ID is not supported, the peer MUST reply with an Error_Not_Found error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果对等方收到AppAttach请求，它应该处理该请求并使用AppAttachAns生成自己的响应。然后开始冰上检查。当对等方收到AppAttach响应时，它应该解析响应并开始自己的ICE检查。如果应用程序ID不受支持，对等方必须回复错误\u not \u Found错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                  ufrag&lt;0..2^8-1&gt;;
          opaque                  password&lt;0..2^8-1&gt;;
          uint16                  application;
          opaque                  role&lt;0..2^8-1&gt;;
          IceCandidate            candidates&lt;0..2^16-1&gt;;
        } AppAttachAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque                  ufrag&lt;0..2^8-1&gt;;
          opaque                  password&lt;0..2^8-1&gt;;
          uint16                  application;
          opaque                  role&lt;0..2^8-1&gt;;
          IceCandidate            candidates&lt;0..2^16-1&gt;;
        } AppAttachAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The meaning of the fields is the same as in the AppAttachReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字段的含义与AppAttachReq中的相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3. Ping
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3. 发出砰的声响
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping is used to test connectivity along a path. A ping can be addressed to a specific Node-ID, to the peer controlling a given location (by using a Resource-ID), or to the wildcard Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping用于测试沿路径的连接。ping可以寻址到特定节点ID、控制给定位置的对等方（通过使用资源ID）或通配符Node-ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PingReq structure is used to make a Ping request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PingReq结构用于发出Ping请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque&lt;0..2^16-1&gt; padding;
        } PingReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          opaque&lt;0..2^16-1&gt; padding;
        } PingReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Ping request is empty of meaningful contents. However, it may contain up to 65535 bytes of padding to facilitate the discovery of overlay maximum packet sizes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ping请求没有有意义的内容。但是，它可能包含多达65535字节的填充，以便于发现覆盖的最大数据包大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.3.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A successful PingAns response contains the information elements requested by the peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功的PingAns响应包含对等方请求的信息元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           uint64                 response_id;
           uint64                 time;
         } PingAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           uint64                 response_id;
           uint64                 time;
         } PingAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PingAns message contains the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PingAns消息包含以下元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
response_id A randomly generated 64-bit response ID. This is used to distinguish Ping responses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
response_id随机生成的64位响应id。用于区分Ping响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
time The time when the Ping response was created, represented in the same way as storage_time, defined in Section 7.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
时间创建Ping响应的时间，表示方式与第7节中定义的存储时间相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4. ConfigUpdate
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4. 配置更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdate method is used to push updated configuration data across the overlay. Whenever a node detects that another node has old configuration data, it MUST generate a ConfigUpdate request. The ConfigUpdate request allows updating of two kinds of data: the configuration data (Section 6.3.2.1) and the Kind information (Section 7.4.1.1).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdate方法用于在覆盖中推送更新的配置数据。每当一个节点检测到另一个节点有旧的配置数据时，它必须生成ConfigUpdate请求。ConfigUpdate请求允许更新两种数据：配置数据（第6.3.2.1节）和种类信息（第7.4.1.1节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdateReq structure is used to provide updated configuration information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdateReq结构用于提供更新的配置信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidConfigUpdateType(0), config(1), kind(2), (255) }
             ConfigUpdateType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidConfigUpdateType(0), config(1), kind(2), (255) }
             ConfigUpdateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        typedef uint32           KindId;
        typedef opaque           KindDescription&lt;0..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        typedef uint32           KindId;
        typedef opaque           KindDescription&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ConfigUpdateType       type;
          uint32                 length;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ConfigUpdateType       type;
          uint32                 length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (type) {
            case config:
                        opaque             config_data&lt;0..2^24-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (type) {
            case config:
                        opaque             config_data&lt;0..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case kind:
                        KindDescription    kinds&lt;0..2^24-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case kind:
                        KindDescription    kinds&lt;0..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended with new types */
          };
        } ConfigUpdateReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended with new types */
          };
        } ConfigUpdateReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdateReq message contains the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdateReq消息包含以下元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
type The type of the contents of the message. This structure allows for unknown content types.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入消息内容的类型。此结构允许未知的内容类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the remainder of the message. This is included to preserve backward compatibility and is 32 bits instead of 24 to facilitate easy conversion between network and host byte order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length消息其余部分的长度。这是为了保持向后兼容性，是32位而不是24位，以便于网络和主机字节顺序之间的轻松转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
config_data (type==config) The contents of the Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
config_data（type==config）配置文档的内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kinds (type==kind) One or more XML kind-block productions (see Section 11.1). These MUST be encoded with UTF-8 and assume a default namespace of &#34;urn:ietf:params:xml:ns:p2p:config-base&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类（type==kind）一个或多个XML种类块产品（参见第11.1节）。这些必须使用UTF-8编码，并假定默认名称空间为“urn:ietf:params:xml:ns:p2p:config base”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.5.4.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ConfigUpdateAns structure is used to respond to a ConfigUpdateReq request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdatens结构用于响应ConfigUpdateReq请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
        } ConfigUpdateAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
        } ConfigUpdateAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ConfigUpdateReq is of type &#34;config&#34;, it MUST be processed only if all the following are true:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果ConfigUpdateReq的类型为“config”，则仅当以下所有条件均为真时，才必须对其进行处理：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The sequence number in the document is greater than the current configuration sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 文档中的序列号大于当前配置序列号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Configuration Document is correctly digitally signed (see Section 11 for details on signatures).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 配置文件的数字签名正确（有关签名的详细信息，请参阅第11节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Otherwise, appropriate errors MUST be generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
否则，必须生成相应的错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the ConfigUpdateReq is of type &#34;kind&#34;, it MUST be processed only if it is correctly digitally signed by an acceptable Kind signer (i.e., one listed in the current configuration file). Details on the kind-signer field in the configuration file are described in Section 11.1. In addition, if the Kind update conflicts with an existing known Kind (i.e., it is signed by a different signer), then it should be rejected with an Error_Forbidden error. This should not happen in correctly functioning overlays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果ConfigUpdateReq的类型为“种类”，则只有在由可接受的种类签名者（即当前配置文件中列出的签名者）对其进行了正确的数字签名后，才能对其进行处理。第11.1节介绍了配置文件中“种类签名者”字段的详细信息。此外，如果种类更新与现有已知种类冲突（即，由不同的签名者签名），则应拒绝该种类更新，并出现错误。这不应该发生在功能正常的覆盖层中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the update is acceptable, then the node MUST reconfigure itself to match the new information. This may include adding permissions for new Kinds, deleting old Kinds, or even, in extreme circumstances, exiting and re-entering the overlay, if, for instance, the DHT algorithm has changed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果更新是可接受的，则节点必须重新配置自身以匹配新信息。这可能包括添加新种类的权限、删除旧种类，甚至在极端情况下，如果DHT算法发生更改，则退出并重新进入覆盖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If an implementation misses enough ConfigUpdates that include key changes, it is possible that it will no longer be able to verify new valid ConfigUpdates. In this case, the only available recovery mechanism is to attempt to retrieve a new Configuration Document, typically by the mechanisms used for initial bootstrapping. It is up to implementers whether or how to decide to employ this sort of recovery mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果一个实现错过了足够多的包含关键更改的ConfigUpdates，则可能无法再验证新的有效ConfigUpdates。在这种情况下，唯一可用的恢复机制是尝试检索新的配置文档，通常是通过用于初始引导的机制。是否或如何使用这种恢复机制取决于实现者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response for ConfigUpdate is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ConfigUpdate的响应为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. Overlay Link Layer
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6. 覆盖链接层
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD can use multiple Overlay Link protocols to send its messages. Because ICE is used to establish connections (see Section 6.5.1.3), RELOAD nodes are able to detect which Overlay Link protocols are offered by other nodes and establish connections between them. Any link protocol needs to be able to establish a secure, authenticated connection and to provide data origin authentication and message integrity for individual data elements. RELOAD currently supports three Overlay Link protocols:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD可以使用多个覆盖链路协议发送其消息。由于ICE用于建立连接（见第6.5.1.3节），重新加载节点能够检测其他节点提供的覆盖链路协议，并在它们之间建立连接。任何链路协议都需要能够建立安全、经过身份验证的连接，并为各个数据元素提供数据源身份验证和消息完整性。RELOAD目前支持三种覆盖链路协议：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DTLS [RFC6347] over UDP with Simple Reliability (SR) (OverlayLinkType=DTLS-UDP-SR)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o UDP上的DTLS[RFC6347]具有简单可靠性（SR）（OverlayLinkType=DTLS-UDP-SR）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TLS [RFC5246] over TCP with Framing Header, No-ICE (OverlayLinkType=TLS-TCP-FH-NO-ICE)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o TCP上的TLS[RFC5246]，带帧头，无ICE（OverlayLinkType=TLS-TCP-FH-No-ICE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o DTLS [RFC6347] over UDP with SR, No-ICE (OverlayLinkType=DTLS-UDP-SR-NO-ICE)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o UDP上的DTLS[RFC6347]带SR，无ICE（OverlayLinkType=DTLS-UDP-SR-No-ICE）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that although UDP does not properly have &#34;connections&#34;, both TLS and DTLS have a handshake that establishes a similar, stateful association. We refer to these as &#34;connections&#34; for the purposes of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，尽管UDP没有正确的“连接”，但TLS和DTL都有一个建立类似有状态关联的握手。在本文件中，我们将其称为“连接”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer receives a message that is larger than the value of max-message-size defined in the overlay configuration, the peer SHOULD send an Error_Message_Too_Large error and then close the TLS or DTLS session from which the message was received. Note that this error can be sent and the session closed before the peer receives the complete message. If the forwarding header is larger than the max-
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果对等方接收到的消息大于覆盖配置中定义的最大消息大小值，则对等方应发送错误消息，然后关闭接收消息的TLS或DTLS会话。请注意，可以在对等方收到完整消息之前发送此错误并关闭会话。如果转发标头大于最大值-
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message-size, the receiver SHOULD close the TLS or DTLS session without sending an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息大小时，接收方应关闭TLS或DTLS会话而不发送错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RELOAD mechanism requires that failed links be quickly removed from the Routing Table so end-to-end retransmission can handle lost messages. Overlay Link protocols MUST be designed with a mechanism that quickly signals a likely failure, and implementations SHOULD quickly act to remove a failed link from the Routing Table when receiving this signal. The entry can be restored if it proves to resume functioning, or it can be replaced at some point in the future if necessary. Section 10.7.2 contains more details specific to the CHORD-RELOAD Topology Plug-in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载机制要求快速从路由表中删除失败的链接，以便端到端重新传输可以处理丢失的消息。覆盖链路协议的设计必须具有一种机制，该机制可以快速发出可能出现故障的信号，并且实现应该在接收到该信号时快速采取行动，从路由表中删除故障链路。如果证明该条目可以恢复功能，则可以恢复该条目；如果必要，也可以在将来的某个时间更换该条目。第10.7.2节包含特定于CHORD-RELOAD拓扑插件的更多详细信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Framing Header (FH) is used to frame messages and provide timing when used on a reliable stream-based transport protocol. Simple Reliability (SR) uses the FH to provide congestion control and partial reliability when using unreliable message-oriented transport protocols. We will first define each of these algorithms in Sections 6.6.2 and 6.6.3, and then define Overlay Link protocols that use them in Sections 6.6.4, 6.6.5, and 6.6.6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当在可靠的基于流的传输协议上使用时，帧报头（FH）用于帧消息和提供定时。简单可靠性（SR）使用FH在使用不可靠的面向消息的传输协议时提供拥塞控制和部分可靠性。我们将首先在第6.6.2节和第6.6.3节中定义这些算法，然后在第6.6.4节、第6.6.5节和第6.6.6节中定义使用它们的覆盖链路协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: We expect future Overlay Link protocols to define replacements for all components of these protocols, including the Framing Header. The three protocols that we will discuss have been chosen for simplicity of implementation and reasonable performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：我们期望未来的覆盖链路协议定义这些协议的所有组件的替换，包括帧头。我们将要讨论的三个协议的选择是为了实现的简单性和合理的性能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1. Future Overlay Link Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1. 未来的覆盖链路协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
It is possible to define new link-layer protocols and apply them to a new overlay using the &#34;overlay-link-protocol&#34; configuration directive (see Section 11.1.). However, any new protocols MUST meet the following requirements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可以使用“overlay link protocol”（覆盖链路协议）配置指令定义新的链路层协议并将其应用于新的覆盖（见第11.1节）。但是，任何新协议必须满足以下要求：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Endpoint authentication: When a node forms an association with another endpoint, it MUST be possible to cryptographically verify that the endpoint has a given Node-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
端点身份验证：当一个节点与另一个端点形成关联时，必须能够以加密方式验证该端点是否具有给定的节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traffic origin authentication and integrity: When a node receives traffic from another endpoint, it MUST be possible to cryptographically verify that the traffic came from a given association and that it has not been modified in transit from the other endpoint in the association. The overlay link protocol MUST also provide replay prevention/detection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
流量源身份验证和完整性：当节点从另一个端点接收流量时，必须能够以加密方式验证流量是否来自给定的关联，以及是否在传输过程中未从关联中的另一个端点对其进行修改。覆盖链路协议还必须提供重播预防/检测。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Traffic confidentiality: When a node sends traffic to another endpoint, it MUST NOT be possible for a third party that is not involved in the association to determine the contents of that traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
流量机密性：当节点向另一个端点发送流量时，不参与关联的第三方不能确定该流量的内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any new overlay protocol MUST be defined via Standards Action [RFC5226]. See Section 14.11.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任何新的覆盖协议必须通过标准行动[RFC5226]定义。见第14.11节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.1. HIP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.1. 臀部
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In a Host Identity Protocol Based Overlay Networking Environment (HIP BONE) [RFC6079], HIP [RFC5201] provides connection management (e.g., NAT traversal and mobility) and security for the overlay network. The P2PSIP Working Group has expressed interest in supporting a HIP-based link protocol. Such support would require specifying such details as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在基于主机身份协议的覆盖网络环境（HIP-BONE）[RFC6079]中，HIP[RFC5201]为覆盖网络提供连接管理（例如NAT穿越和移动性）和安全性。P2PSIP工作组表示有兴趣支持基于HIP的链路协议。此类支持需要指定以下详细信息：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o How to issue certificates which provide identities meaningful to the HIP base exchange. We anticipate that this would require a mapping between Overlay Routable Cryptographic Hash Identifiers (ORCHIDs) and NodeIds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如何颁发证书，以提供对HIP base exchange有意义的身份。我们预计，这将需要覆盖可路由加密哈希标识符（RAYCs）和节点ID之间的映射。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o How to carry the HIP I1 and I2 messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如何携带HIP I1和I2信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o How to carry RELOAD messages over HIP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如何在臀部携带重新加载信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HIP-RELOAD] documents work in progress on using RELOAD with the HIP BONE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[HIP-RELOAD]文档正在对髋骨使用RELOAD。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.2. ICE-TCP
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.2. ICE-TCP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ICE-TCP RFC [RFC6544] allows TCP to be supported as an Overlay Link protocol that can be added using ICE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ICE-TCP RFC[RFC6544]允许TCP作为覆盖链路协议得到支持，该协议可以使用ICE添加。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.3. Message-Oriented Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.3. 面向消息的传输
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Modern message-oriented transports offer high performance and good congestion control, and they avoid head-of-line blocking in case of lost data. These characteristics make them preferable as underlying transport protocols for RELOAD links. SCTP without message ordering and DCCP are two examples of such protocols. However, currently they are not well-supported by commonly available NATs, and specifications for ICE session establishment are not available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
现代面向消息的传输提供了高性能和良好的拥塞控制，并且在数据丢失的情况下避免了行首阻塞。这些特性使它们更适合作为重新加载链路的底层传输协议。无消息排序的SCTP和DCCP是此类协议的两个示例。然而，目前通用的NAT并不能很好地支持它们，并且ICE会话建立的规范也不可用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.4. Tunneled Transports
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.1.4. 隧道运输
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As of the time of this writing, there is significant interest in the IETF community in tunneling other transports over UDP, which is motivated by the situation that UDP is well-supported by modern NAT hardware and by the fact that performance similar to a native implementation can be achieved. Currently, SCTP, DCCP, and a generic tunneling extension are being proposed for message-oriented protocols. Once ICE traversal has been specified for these tunneled
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在撰写本文时，IETF社区对通过UDP隧道传输其他传输有着浓厚的兴趣，这是因为现代NAT硬件很好地支持UDP，并且可以实现与本机实现类似的性能。目前，正在为面向消息的协议提出SCTP、DCCP和通用隧道扩展。一旦为这些隧道指定了冰的穿越
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
protocols, they should be straightforward to support as overlay link protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
协议，它们应该作为覆盖链路协议直接支持。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.2. Framing Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.2. 框架标题
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to support unreliable links and to allow for quick detection of link failures when using reliable end-to-end transports, each message is wrapped in a very simple framing layer (FramedMessage), which is used only for each hop. This layer contains a sequence number which can then be used for ACKs. The same header is used for both reliable and unreliable transports for simplicity of implementation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了支持不可靠的链路，并允许在使用可靠的端到端传输时快速检测链路故障，每个消息都包装在一个非常简单的帧层（FramedMessage）中，该层仅用于每个跃点。该层包含一个序列号，可用于ACK。为简化实现，可靠和不可靠传输都使用相同的报头。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definition of FramedMessage is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FramedMessage的定义是：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { data(128), ack(129), (255) } FramedMessageType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { data(128), ack(129), (255) } FramedMessageType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          FramedMessageType       type;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          FramedMessageType       type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (type) {
            case data:
              uint32              sequence;
              opaque              message&lt;0..2^24-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (type) {
            case data:
              uint32              sequence;
              opaque              message&lt;0..2^24-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case ack:
              uint32              ack_sequence;
              uint32              received;
          };
        } FramedMessage;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case ack:
              uint32              ack_sequence;
              uint32              received;
          };
        } FramedMessage;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The type field of the PDU is set to indicate whether the message is data or an acknowledgement.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PDU的类型字段设置为指示消息是数据还是确认。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is of type &#34;data&#34;, then the remainder of the PDU is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果消息类型为“data”，则PDU的其余部分如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence The sequence number. This increments by one for each framed message sent over this transport session.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对序列号进行排序。对于通过此传输会话发送的每个帧消息，该值将增加1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
message The message that is being transmitted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息正在传输的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each connection has it own sequence number space. Initially, the value is zero, and it increments by exactly one for each message sent over that connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个连接都有自己的序列号空间。最初，该值为零，通过该连接发送的每条消息的增量正好为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the receiver receives a message, it SHOULD immediately send an ACK message. The receiver MUST keep track of the 32 most recent sequence numbers received on this association in order to generate the appropriate ACK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当接收方收到消息时，应立即发送ACK消息。接收器必须跟踪此关联上接收到的32个最新序列号，以便生成适当的ACK。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the PDU is of type &#34;ack&#34;, the contents are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果PDU类型为“ack”，则内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ack_sequence The sequence number of the message being acknowledged.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
确认序列被确认的消息的序列号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
received A bitmask indicating if each of the previous 32 sequence numbers before this packet has been among the 32 packets most recently received on this connection. When a packet is received with a sequence number N, the receiver looks at the sequence number of the 32 previously received packets on this connection. We call the previously received packet number M. For each of the previous 32 packets, if the sequence number M is less than N but greater than N-32, the N-M bit of the received bitmask is set to one; otherwise, it is set to zero. Note that a bit being set to one indicates positively that a particular packet was received, but a bit being set to zero means only that it is unknown whether or not the packet has been received, because it might have been received before the 32 most recently received packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收到一个位掩码，指示此数据包之前的32个序列号中的每一个是否属于此连接上最近接收到的32个数据包。当接收到序列号为N的数据包时，接收器查看该连接上先前接收的32个数据包的序列号。我们调用先前接收的分组号M。对于先前32个分组中的每一个，如果序列号M小于N但大于N-32，则接收的位掩码的N-M位被设置为1；否则，它将设置为零。注意，设置为1的位肯定地表示接收到特定分组，但是设置为0的位仅意味着不知道分组是否已被接收，因为它可能在最近接收的32个分组之前被接收。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The received field bits in the ACK provide a high degree of redundancy so that the sender can figure out which packets the receiver has received and can then estimate packet loss rates. If the sender also keeps track of the time at which recent sequence numbers have been sent, the RTT (round-trip time) can be estimated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
ACK中的接收字段位提供高度冗余，以便发送方能够确定接收方已经接收到哪些分组，然后能够估计分组丢失率。如果发送方还跟踪最近序列号的发送时间，则可以估计RTT（往返时间）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that because retransmissions receive new sequence numbers, multiple ACKs may be received for the same message. This approach provides more information than traditional TCP sequence numbers, but care must be taken when applying algorithms designed based on TCP&#39;s stream-oriented sequence number.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，由于重新传输接收新的序列号，因此可能会为同一消息接收多个ack。这种方法比传统的TCP序列号提供更多的信息，但在应用基于TCP面向流的序列号设计的算法时必须小心。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3. Simple Reliability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3. 简单可靠性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When RELOAD is carried over DTLS or another unreliable link protocol, it needs to be used with a reliability and congestion control mechanism, which is provided on a hop-by-hop basis. The basic principle is that each message, regardless of whether or not it carries a request or response, will get an ACK and be reliably retransmitted. The receiver&#39;s job is very simple, and is limited to just sending ACKs. All the complexity is at the sender side. This allows the sending implementation to trade off performance versus implementation complexity without affecting the wire protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当通过DTLS或其他不可靠链路协议进行重新加载时，需要使用一种基于逐跳的可靠性和拥塞控制机制。基本原则是，无论每条消息是否包含请求或响应，都将获得ACK并可靠地重新传输。接收器的工作非常简单，仅限于发送确认。所有的复杂性都在发送方。这允许发送实现在不影响有线协议的情况下权衡性能和实现复杂性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the receiver&#39;s role is limited to providing packet acknowledgements, a wide variety of congestion control algorithms can be implemented on the sender side while using the same basic wire protocol. The sender algorithm used MUST meet the requirements of [RFC5405].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于接收方的角色仅限于提供数据包确认，因此在使用相同的基本有线协议的同时，可以在发送方实现多种拥塞控制算法。使用的发送方算法必须满足[RFC5405]的要求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3.1. Stop and Wait Sender Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.3.1. 停止等待发送算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes one possible implementation of a sender algorithm for Simple Reliability. It is adequate for overlays running on underlying networks with low latency and loss (LANs) or low-traffic overlays on the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节描述了一种简单可靠的发送方算法的可能实现。它适用于在具有低延迟和丢失（LAN）的基础网络上运行的覆盖或Internet上的低流量覆盖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A node MUST NOT have more than one unacknowledged message on the DTLS connection at a time. Note that because retransmissions of the same message are given new sequence numbers, there may be multiple unacknowledged sequence numbers in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个节点在DTLS连接上一次不能有多条未确认的消息。请注意，由于同一消息的重传被赋予了新的序列号，因此可能会有多个未确认的序列号在使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The RTO (Retransmission TimeOut) is based on an estimate of the RTT. The value for RTO is calculated separately for each DTLS session. Implementations can use a static value for RTO or a dynamic estimate, which will result in better performance. For implementations that use a static value, the default value for RTO is 500 ms. Nodes MAY use smaller values of RTO if it is known that all nodes are within the local network. The default RTO MAY be set to a larger value, which is RECOMMENDED if it is known in advance (such as on high-latency access links) that the RTT is larger.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RTO（重传超时）基于对RTT的估计。RTO的值是为每个DTLS会话单独计算的。实现可以使用RTO的静态值或动态估计值，这将导致更好的性能。对于使用静态值的实现，RTO的默认值为500 ms。如果已知所有节点都在本地网络内，则节点可以使用较小的RTO值。默认RTO可以设置为更大的值，如果事先知道（例如在高延迟访问链路上）RTT更大，则建议将其设置为更大的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Implementations that use a dynamic estimate to compute the RTO MUST use the algorithm described in RFC 6298 [RFC6298], with the exception that the value of RTO SHOULD NOT be rounded up to the nearest second, but instead rounded up to the nearest millisecond. The RTT of a successful STUN transaction from the ICE stage is used as the initial measurement for formula 2.2 of RFC 6298. The sender keeps track of the time each message was sent for all recently sent messages. Any time an ACK is received, the sender can compute the RTT for that message by looking at the time the ACK was received and the time when the message was sent. This is used as a subsequent RTT measurement for formula 2.3 of RFC 6298 to update the RTO estimate. (Note that because retransmissions receive new sequence numbers, all received ACKs are used.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用动态估计来计算RTO的实现必须使用RFC 6298[RFC6298]中描述的算法，但RTO的值不应向上舍入到最接近的秒，而应向上舍入到最接近的毫秒。ICE阶段成功的STUN交易的RTT用作RFC 6298公式2.2的初始测量。发件人跟踪最近发送的所有邮件的发送时间。无论何时收到ACK，发送方都可以通过查看收到ACK的时间和发送消息的时间来计算该消息的RTT。这用作RFC 6298公式2.3的后续RTT测量，以更新RTO估算值。（请注意，由于重新传输接收新的序列号，因此将使用所有接收到的ACK。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An initiating node SHOULD retransmit a message if it has not received an ACK after an interval of RTO (transit nodes do not retransmit at this layer). The node MUST double the time to wait after each retransmission. For each retransmission, the sequence number MUST be incremented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果发起节点在RTO间隔后未收到ACK，则应重新传输消息（传输节点不在此层重新传输）。节点必须在每次重新传输后将等待时间延长一倍。对于每次重传，序列号必须递增。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Retransmissions continue until a response is received, until a total of 5 requests have been sent, until there has been a hard ICMP error [RFC1122], or until a TLS alert indicating the end of the connection has been sent or received. The sender knows a response was received when it receives an ACK with a sequence number that indicates it is a response to one of the transmissions of this message. For example, assuming an RTO of 500 ms, requests would be sent at times 0 ms, 500 ms, 1500 ms, 3500 ms, and 7500 ms. If all retransmissions for a message fail, then the sending node SHOULD close the connection routing the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新传输将继续，直到收到响应、总共发送了5个请求、出现硬ICMP错误[RFC1122]或发送或接收到指示连接结束的TLS警报。发送方在接收到带有序列号的ACK时知道收到了响应，该序列号指示它是对该消息的一次传输的响应。例如，假设RTO为500毫秒，请求将在0毫秒、500毫秒、1500毫秒、3500毫秒和7500毫秒时发送。如果消息的所有重新传输失败，则发送节点应关闭路由消息的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To determine when a link might be failing without waiting for the final timeout, observe when no ACKs have been received for an entire RTO interval, and then wait for three retransmissions to occur beyond that point. If no ACKs have been received by the time the third retransmission occurs, it is RECOMMENDED that the link be removed from the Routing Table. The link MAY be restored to the Routing Table if ACKs resume before the connection is closed, as described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要在不等待最后超时的情况下确定链路何时可能出现故障，请观察在整个RTO间隔内没有收到ACK的情况，然后等待超过该点的三次重新传输。如果在第三次重传发生时没有收到ACK，建议从路由表中删除链路。如上所述，如果ACK在连接关闭之前恢复，则链路可以恢复到路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A sender MUST wait 10 ms between receipt of an ACK and transmission of the next message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发送方必须在收到ACK和传输下一条消息之间等待10毫秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.4. DTLS/UDP with SR
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.4. 带SR的DTLS/UDP
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This overlay link protocol consists of DTLS over UDP while implementing the SR protocol. STUN connectivity checks and keepalives are used. Any compliant sender algorithm may be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此覆盖链路协议由UDP上的DTL组成，同时实现SR协议。将使用眩晕连接检查和保留选项。可以使用任何兼容的发送方算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.5. TLS/TCP with FH, No-ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.5. 带FH的TLS/TCP，无冰
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This overlay link protocol consists of TLS over TCP with the framing header. Because ICE is not used, STUN connectivity checks are not used upon establishing the TCP connection, nor are they used for keepalives.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该覆盖链路协议由TCP上的TLS和帧报头组成。由于未使用ICE，因此在建立TCP连接时不会使用STUN连接检查，也不会将其用于keepalives。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the TCP layer&#39;s application-level timeout is too slow to be useful for overlay routing, the Overlay Link implementation MUST use the framing header to measure the RTT of the connection and calculate an RTO as specified in Section 2 of [RFC6298]. The resulting RTO is not used for retransmissions, but rather as a timeout to indicate when the link SHOULD be removed from the Routing Table. It is RECOMMENDED that such a connection be retained for 30 seconds to determine if the failure was transient before concluding the link has failed permanently.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于TCP层的应用程序级超时太慢，无法用于覆盖路由，因此覆盖链路实现必须使用帧报头测量连接的RTT，并按照[RFC6298]第2节的规定计算RTO。生成的RTO不用于重新传输，而是作为超时来指示何时应从路由表中删除链路。建议将这种连接保持30秒，以确定故障是否为暂时性故障，然后再确定链路是否永久性故障。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When sending candidates for TLS/TCP with FH, No-ICE, a passive candidate MUST be provided.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当发送带有FH的TLS/TCP候选时，无ICE，必须提供被动候选。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.6. DTLS/UDP with SR, No-ICE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.6.6. 带SR的DTLS/UDP，无ICE
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This overlay link protocol consists of DTLS over UDP while implementing the Simple Reliability protocol. Because ICE is not used, no STUN connectivity checks or keepalives are used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此覆盖链路协议由UDP上的DTL组成，同时实现简单可靠性协议。由于未使用ICE，因此未使用眩晕连接检查或保持活动。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. Fragmentation and Reassembly
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.7. 分裂与重组
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to allow transmission over datagram protocols such as DTLS, RELOAD messages may be fragmented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了允许通过数据报协议（如DTL）进行传输，可以对重新加载消息进行分段。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any node along the path can fragment the message, but only the final destination reassembles the fragments. When a node takes a packet and fragments it, each fragment has a full copy of the forwarding header, but the data after the forwarding header is broken up into appropriately sized chunks. The size of the payload chunks needs to take into account space to allow the Via and Destination Lists to grow. Each fragment MUST contain a full copy of the Via List, Destination List, and ForwardingOptions and MUST contain at least 256 bytes of the message body. If these elements cannot fit within the MTU of the underlying datagram protocol, RELOAD fragmentation is not performed, and IP-layer fragmentation is allowed to occur. The length field MUST contain the size of the message after fragmentation. When a message MUST be fragmented, it SHOULD be split into equal-sized fragments that are no larger than the Path MTU (PMTU) of the next overlay link minus 32 bytes. This is to allow the Via List to grow before further fragmentation is required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路径上的任何节点都可以对消息进行分段，但只有最终目的地才能重新组装这些分段。当一个节点获取一个数据包并对其进行分段时，每个分段都有一个转发头的完整副本，但转发头之后的数据会被分成大小适当的数据块。有效负载块的大小需要考虑空间，以允许Via和目的地列表增长。每个片段必须包含Via列表、目的地列表和转发选项的完整副本，并且必须包含至少256字节的消息正文。如果这些元素不能放入底层数据报协议的MTU中，则不会执行重新加载碎片，并且允许发生IP层碎片。长度字段必须包含分段后消息的大小。当消息必须分段时，应将其拆分为大小相等的片段，这些片段不大于下一个覆盖链接的路径MTU（PMTU）减去32字节。这是为了在需要进一步碎片化之前，允许过孔列表增长。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this fragmentation is not optimal for the end-to-end path -- a message may be refragmented multiple times as it traverses the overlay, but it is assembled only at the final destination. This option has been chosen as it is far easier to implement than end-to-end (e2e) PMTU discovery across an ever-changing overlay and it effectively addresses the reliability issues of relying on IP-layer fragmentation. However, Ping can be used to allow e2e PMTU discovery to be implemented if desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，对于端到端路径，这种分段不是最佳的——消息在穿越覆盖层时可能会多次重新打包，但它仅在最终目的地组装。之所以选择此选项，是因为它比在不断变化的覆盖上实现端到端（e2e）PMTU发现要容易得多，而且它有效地解决了依赖IP层碎片的可靠性问题。但是，如果需要，可以使用Ping来实现e2e PMTU发现。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt of a fragmented message by the intended peer, the peer holds the fragments in a holding buffer until the entire message has been received. The message is then reassembled into a single message and processed. In order to mitigate denial-of-service (DoS) attacks, receivers SHOULD time out incomplete fragments after the maximum request lifetime (15 seconds). This time was derived from looking at the end-to-end retransmission time and saving fragments long enough for the full end-to-end retransmissions to take place. Ideally, the receiver would have enough buffer space to deal with as many fragments as can arrive in the maximum request lifetime. However, if
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当目标对等方接收到碎片消息时，对等方将碎片保存在保留缓冲区中，直到接收到整个消息。然后将该消息重新组合为单个消息并进行处理。为了减轻拒绝服务（DoS）攻击，接收器应在最大请求生存期（15秒）后超时不完整的片段。这一时间来源于查看端到端重传时间，并保存足够长的片段，以便进行完整的端到端重传。理想情况下，接收器将有足够的缓冲空间来处理在最大请求生存期内可能到达的尽可能多的片段。然而，如果
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
the receiver runs out of buffer space to reassemble a message, it MUST drop the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接收器的缓冲区空间不足，无法重新组装消息，因此必须删除消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The fragment field of the forwarding header is used to encode fragmentation information. The offset is the number of bytes between the end of the forwarding header and the start of the data. The first fragment therefore has an offset of 0. The last fragment indicator MUST be appropriately set. If the message is not fragmented, it is simply treated as if it is the only fragment: the last fragment bit is set and the offset is 0, resulting in a fragment value of 0xC0000000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转发头的片段字段用于编码片段信息。偏移量是转发头的结尾和数据的开头之间的字节数。因此，第一个片段的偏移量为0。必须适当设置最后一个片段指示符。如果消息没有分段，则只将其视为唯一的片段：设置最后一个片段位，偏移量为0，从而产生0xC0000000的片段值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: The reason for this definition of the fragment field is that originally, the high bit was defined in part of the specification as &#34;is fragmented&#34;, so there was some specification ambiguity about how to encode messages with only one fragment. This ambiguity was resolved in favor of always encoding as the &#34;last&#34; fragment with offset 0, thus simplifying the receiver code path, but resulting in the high bit being redundant. Because messages MUST be set with the high bit set to 1, implementations SHOULD discard any message with it set to 0. Implementations (presumably legacy ones) which choose to accept such messages MUST either ignore the remaining bits or ensure that they are 0. They MUST NOT try to interpret as fragmented messages with the high bit set low.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意：片段字段的这种定义的原因是，最初，规范的一部分将高位定义为“is fragmented”，因此对于如何仅使用一个片段对消息进行编码存在一些规范歧义。这种模糊性得到了解决，有利于始终编码为偏移量为0的“最后”片段，从而简化了接收器代码路径，但导致高位冗余。因为必须将消息的高位设置为1，所以实现应该丢弃任何设置为0的消息。选择接受此类消息的实现（可能是传统的实现）必须忽略剩余的位或确保它们为0。他们不能试图将高位设置为低位的零碎消息进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Data Storage Protocol
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 数据存储协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides a set of generic mechanisms for storing and retrieving data in the Overlay Instance. These mechanisms can be used for new applications simply by defining new code points and a small set of rules. No new protocol mechanisms are required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD提供了一组通用机制，用于在Overlay实例中存储和检索数据。这些机制只需定义新的代码点和一小部分规则，就可以用于新的应用程序。不需要新的协议机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The basic unit of stored data is a single StoredData structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储数据的基本单位是单存储数据结构：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                  length;
          uint64                  storage_time;
          uint32                  lifetime;
          StoredDataValue         value;
          Signature               signature;
        } StoredData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                  length;
          uint64                  storage_time;
          uint32                  lifetime;
          StoredDataValue         value;
          Signature               signature;
        } StoredData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The size of the StoredData structure, in bytes, excluding the size of length itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度StoredData结构的大小，以字节为单位，不包括长度本身的大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage_time The time when the data was stored, represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC, not counting leap seconds. This will have the same values for seconds as standard UNIX or POSIX time. More information can be found at [UnixTime]. Any attempt to store a data value with a storage time before that of a value already stored at this location MUST generate an Error_Data_Too_Old error. This prevents rollback attacks. The node SHOULD make a best-effort attempt to use a correct clock to determine this number. However, the protocol does not require synchronized clocks: the receiving peer uses the storage time in the previous store, not its own clock. Clock values are used so that when clocks are generally synchronized, data may be stored in a single transaction, rather than querying for the value of a counter before the actual store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储时间存储数据的时间，表示为UTC 1970年1月1日午夜以来经过的毫秒数，不包括闰秒。这将具有与标准UNIX或POSIX时间相同的秒值。有关更多信息，请访问[UnixTime]。任何存储时间早于已存储在此位置的值的存储时间的数据值存储尝试都必须生成错误\u data\u Too\u Old Error。这可以防止回滚攻击。节点应尽最大努力使用正确的时钟来确定该数字。但是，该协议不需要同步时钟：接收端使用前一存储中的存储时间，而不是自己的时钟。使用时钟值是为了在时钟通常同步时，数据可以存储在单个事务中，而不是在实际存储之前查询计数器的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
If a node attempting to store new data in response to a user request (rather than as an overlay maintenance operation such as occurs when healing the overlay from a partition) is rejected with an Error_Data_Too_Old error, the node MAY elect to perform its store using a storage_time that increments the value used with the previous store (this may be obtained by doing a Fetch). This situation may occur when the clocks of nodes storing to this location are not properly synchronized.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
如果试图存储新数据以响应用户请求（而不是作为覆盖维护操作，如从分区修复覆盖时发生的操作）的节点因错误_data _Too _Old错误而被拒绝，则该节点可以选择使用存储时间来执行其存储，该存储时间增加与前一存储一起使用的值（这可以通过提取来获得）。当存储到此位置的节点的时钟未正确同步时，可能会出现这种情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
lifetime The validity period for the data, in seconds, starting from the time the peer receives the StoreReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生存期—数据的有效期，以秒为单位，从对等方收到StoreReq时开始。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The data value itself, as described in Section 7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值数据值本身，如第7.2节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
signature A signature, as defined in Section 7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
签名第7.1节中定义的签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each Resource-ID specifies a single location in the Overlay Instance. However, each location may contain multiple StoredData values, distinguished by Kind-ID. The definition of a Kind describes both the data values which may be stored and the data model of the data. Some data models allow multiple values to be stored under the same Kind-ID. Section 7.2 describes the available data models. Thus, for instance, a given Resource-ID might contain a single-value element stored under Kind-ID X and an array containing multiple values stored under Kind-ID Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个资源ID在覆盖实例中指定一个位置。但是，每个位置可能包含多个StoredData值，以种类ID区分。种类的定义描述了可能存储的数据值和数据的数据模型。一些数据模型允许在同一种类ID下存储多个值。第7.2节描述了可用的数据模型。因此，例如，给定的资源ID可能包含存储在种类ID X下的单个值元素和存储在种类ID Y下的包含多个值的数组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Data Signature Computation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 数据签名计算
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each StoredData element is individually signed. However, the signature also must be self-contained and must cover the Kind-ID and Resource-ID, even though they are not present in the StoredData structure. The input to the signature algorithm is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个StoredData元素都单独签名。但是，签名也必须是自包含的，并且必须包含种类ID和资源ID，即使它们不在StoredData结构中。签名算法的输入为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
resource_id || kind || storage_time || StoredDataValue || SignerIdentity
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
资源| id |种类|存储|时间| |存储数据值| |签名身份
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
where || indicates concatenation and where these values are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中| |表示串联，其中这些值为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource_id The Resource-ID where this data is stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource_id存储此数据的资源id。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID for this data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类此数据的种类ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
storage_time The contents of the storage_time data value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储时间存储时间数据值的内容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoredDataValue The contents of the stored data value, as described in the previous sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoredDataValue存储数据值的内容，如前几节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SignerIdentity The signer identity, as defined in Section 6.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
签名身份第6.3.4节中定义的签名者身份。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the signature has been computed, the signature is represented using a signature element, as described in Section 6.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
计算签名后，使用签名元素表示签名，如第6.3.4节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there is no necessary relationship between the validity window of a certificate and the expiry of the data it is authenticating. When signatures are verified, the current time MUST be compared to the certificate validity period. Stored data MAY be set to expire after the signing certificate&#39;s validity period. Such signatures are not considered valid after the signing certificate expires. Implementations may &#34;garbage collect&#34; such data at their convenience, either by purging it automatically (perhaps by setting the upper bound on data storage to the lifetime of the signing certificate) or by simply leaving it in place until it expires naturally and relying on users of that data to notice the expired signing certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，证书的有效期窗口与其正在验证的数据的有效期之间没有必要的关系。验证签名时，必须将当前时间与证书有效期进行比较。存储的数据可能设置为在签名证书的有效期之后过期。签名证书过期后，此类签名将被视为无效。实现可以在方便的时候“垃圾收集”此类数据，方法是自动清除（可能是将数据存储的上限设置为签名证书的生存期），或者简单地将其保留在原位，直到其自然过期，并依靠该数据的用户来通知过期的签名证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Data Models
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 数据模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The protocol currently defines the following data models:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该协议目前定义了以下数据模型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o single value
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 单值
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o array
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 大堆
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o dictionary
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 词典
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These are represented with the StoredDataValue structure. The actual data model is known from the Kind being stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
它们用StoredDataValue结构表示。实际的数据模型是从存储的类型中知道的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          Boolean                exists;
          opaque                 value&lt;0..2^32-1&gt;;
        } DataValue;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          Boolean                exists;
          opaque                 value&lt;0..2^32-1&gt;;
        } DataValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          select (DataModel) {
            case single_value:
              DataValue             single_value_entry;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          select (DataModel) {
            case single_value:
              DataValue             single_value_entry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case array: ArrayEntry array_entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
案例数组：ArrayEntry数组\ u条目；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case dictionary: DictionaryEntry dictionary_entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
案例字典：字典输入字典输入；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended */
          };
        } StoredDataValue;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended */
          };
        } StoredDataValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following sections discuss the properties of each data model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下各节讨论每个数据模型的属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. Single Value
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.1. 单值
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single-value element is a simple sequence of bytes. There may be only one single-value element for each Resource-ID, Kind-ID pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单值元素是一个简单的字节序列。每个资源ID、种类ID对可能只有一个值元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single value element is represented as a DataValue, which contains the following two elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单个值元素表示为DataValue，其中包含以下两个元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exists This value indicates whether the value exists at all. If it is set to False, it means that no value is present. If it is True, this means that a value is present. This gives the protocol a mechanism for indicating nonexistence as opposed to emptiness.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存在此值指示该值是否存在。如果设置为False，则表示不存在任何值。如果为True，则表示存在一个值。这为协议提供了一种表示不存在而不是空的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The stored data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对存储的数据进行赋值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. Array
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.2. 大堆
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An array is a set of opaque values addressed by an integer index. Arrays are zero based. Note that arrays can be sparse. For instance, a Store of &#34;X&#34; at index 2 in an empty array produces an array with the values [ NA, NA, &#34;X&#34;]. Future attempts to fetch elements at index 0 or 1 will return values with &#34;exists&#34; set to False.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数组是由整数索引寻址的一组不透明值。数组是基于零的。请注意，数组可以是稀疏的。例如，在空数组中的索引2处存储“X”将生成一个值为[NA，NA，“X”]的数组。将来尝试获取索引0或1处的元素时，将返回“exists”设置为False的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An array element is represented as an ArrayEntry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数组元素表示为ArrayEntry：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           uint32                  index;
           DataValue               value;
         } ArrayEntry;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           uint32                  index;
           DataValue               value;
         } ArrayEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
index The index of the data element in the array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
索引数组中数据元素的索引。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The stored data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对存储的数据进行赋值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3. Dictionary
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2.3. 词典
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A dictionary is a set of opaque values indexed by an opaque key, with one value for each key. A single dictionary entry is represented as a DictionaryEntry:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字典是一组由不透明键索引的不透明值，每个键有一个值。单个字典条目表示为字典条目：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         typedef opaque           DictionaryKey&lt;0..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         typedef opaque           DictionaryKey&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           DictionaryKey          key;
           DataValue              value;
         } DictionaryEntry;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           DictionaryKey          key;
           DataValue              value;
         } DictionaryEntry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
key The dictionary key for this value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入此值的字典键。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value The stored data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对存储的数据进行赋值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Access Control Policies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 访问控制策略
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every Kind which is storable in an overlay MUST be associated with an access control policy. This policy defines whether a request from a given node to operate on a given value should succeed or fail. It is anticipated that only a small number of generic access control policies are required. To that end, this section describes a small set of such policies, and Section 14.4 establishes a registry for new policies, if required. Each policy has a short string identifier which is used to reference it in the Configuration Document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖中可存储的每种类型都必须与访问控制策略相关联。此策略定义来自给定节点的对给定值进行操作的请求是成功还是失败。预计只需要少量的通用访问控制策略。为此，本节介绍了一小部分此类策略，第14.4节为新策略建立了注册表（如果需要）。每个策略都有一个短字符串标识符，用于在配置文档中引用它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following policies, the term &#34;signer&#34; refers to the signer of the StoredValue object and, in the case of non-replica stores, to the signer of the StoreReq message. That is, in a non-replica store, both the signer of the StoredValue and the signer of the StoreReq MUST conform to the policy. In the case of a replica store, the signer of the StoredValue MUST conform to the policy, and the StoreReq itself MUST be checked as described in Section 7.4.1.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在以下策略中，术语“签名者”指StoredValue对象的签名者，在非副本存储的情况下，指StoreReq消息的签名者。也就是说，在非副本存储中，StoredValue的签名者和StoreReq的签名者都必须符合策略。对于副本存储，StoredValue的签名者必须遵守策略，并且必须按照第7.4.1.1节的说明检查StoreReq本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.1. USER-MATCH
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.1. 用户匹配
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the USER-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. Recall that the certificate may, depending on the overlay configuration, be self-signed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在USER-MATCH策略中，当且仅当签名者的证书具有将（使用覆盖的哈希函数）哈希到资源ID的用户名时，必须写入（或覆盖）给定值。回想一下，根据覆盖配置，证书可能是自签名的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.2. NODE-MATCH
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.2. 节点匹配
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate has a specified Node-ID which hashes (using the hash function for the overlay) to the Resource-ID for the resource and that Node-ID is the one indicated in the SignerIdentity value cert_hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在NODE-MATCH策略中，当且仅当签名者的证书具有指定的节点ID（使用用于覆盖的哈希函数）哈希到资源的资源ID，并且该节点ID是SignerIdentity值证书哈希中指示的节点ID时，必须写入（或覆盖）给定的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.3. USER-NODE-MATCH
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.3. 用户节点匹配
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The USER-NODE-MATCH policy may be used only with dictionary types. In the USER-NODE-MATCH policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate has a user name which hashes (using the hash function for the overlay) to the Resource-ID for the resource. In addition, the dictionary key MUST be equal to the Node-ID in the certificate, and that Node-ID MUST be the one indicated in the SignerIdentity value cert_hash.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户节点匹配策略只能用于字典类型。在USER-NODE-MATCH策略中，当且仅当签名者的证书具有将（使用覆盖的哈希函数）哈希到资源的资源ID的用户名时，必须写入（或覆盖）给定值。此外，字典密钥必须等于证书中的节点ID，并且该节点ID必须是SignerIdentity值cert_哈希中指示的节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.4. NODE-MULTIPLE
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3.4. 多节点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NODE-MULTIPLE policy, a given value MUST be written (or overwritten) if and only if the signer&#39;s certificate contains a Node-ID such that H(Node-ID || i) is equal to the Resource-ID for some small integer value of i and that Node-ID is the one indicated in the SignerIdentity value cert_hash. When this policy is in use, the maximum value of i MUST be specified in the Kind definition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在多节点策略中，当且仅当签名者的证书包含节点ID，使得H（节点ID | | i）等于某个小整数值i的资源ID，并且该节点ID是签名者身份值cert|u散列中指示的节点ID时，必须写入（或覆盖）给定值。使用此策略时，必须在种类定义中指定i的最大值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that because i is not carried on the wire, the verifier MUST iterate through potential i values, up to the maximum value, to determine whether a store is acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，因为i不是在线路上携带的，所以验证器必须迭代潜在i值，直到最大值，以确定存储是否可接受。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Data Storage Methods
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 数据存储方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides several methods for storing and retrieving data:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD提供了几种存储和检索数据的方法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Store values in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 在覆盖中存储值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Fetch values from the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 从覆盖中获取值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stat: Get metadata about values in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Stat：获取覆盖中值的元数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Find the values stored at an individual peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 查找存储在单个对等点上的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
These methods are described in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些方法将在以下章节中介绍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. Store
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1. 百货商店
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Store method is used to store data in the overlay. The format of the Store request depends on the data model, which is determined by the Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储方法用于在覆盖中存储数据。存储请求的格式取决于数据模型，数据模型由类型决定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A StoreReq message is a sequence of StoreKindData values, each of which represents a sequence of stored values for a given Kind. The same Kind-ID MUST NOT be used twice in a given store request. Each value is then processed in turn. These operations MUST be atomic. If any operation fails, the state MUST be rolled back to what it was before the request was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoreReq消息是StoreKindData值的序列，每个值表示给定类型的存储值序列。同一种类的ID在给定的存储请求中不得使用两次。然后依次处理每个值。这些操作必须是原子操作。如果任何操作失败，则必须将状态回滚到收到请求之前的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The store request is defined by the StoreReq structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储请求由StoreReq结构定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           KindId                 kind;
           uint64                 generation_counter;
           StoredData             values&lt;0..2^32-1&gt;;
       } StoreKindData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           KindId                 kind;
           uint64                 generation_counter;
           StoredData             values&lt;0..2^32-1&gt;;
       } StoreKindData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ResourceId             resource;
           uint8                  replica_number;
           StoreKindData          kind_data&lt;0..2^32-1&gt;;
       } StoreReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       struct {
           ResourceId             resource;
           uint8                  replica_number;
           StoreKindData          kind_data&lt;0..2^32-1&gt;;
       } StoreReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A single Store request stores data of a number of Kinds to a single resource location. The contents of the structure are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单个存储请求将多种类型的数据存储到单个资源位置。结构的内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The resource at which to store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
资源要存储的资源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replica_number The number of this replica. When a storing peer saves replicas to other peers, each peer is assigned a replica number, starting from 1, that is sent in the Store message. This field is set to 0 when a node is storing its own data. This allows peers to distinguish replica writes from original writes. Different topologies may choose to allocate or interpret the replica number differently (see Section 10.4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
副本\此副本的编号。当存储对等方将副本保存到其他对等方时，将为每个对等方分配一个副本编号，从1开始，该编号在存储消息中发送。当节点存储自己的数据时，此字段设置为0。这允许对等方区分副本写入和原始写入。不同的拓扑可以选择以不同的方式分配或解释副本编号（参见第10.4节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind_data A series of elements, one for each Kind of data to be stored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类\数据一系列元素，每种类型的数据存储一个元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The peer MUST check that it is responsible for the resource if the replica number is zero; if it is not, the peer must reject the request. The peer MUST check that it expects to be a replica for the resource and that the request sender is consistent with being the responsible node (i.e., that the receiving peer does not know of a better node) if the replica number is nonzero; if the request sender is not consistent, it should reject the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果副本号为零，对等方必须检查其是否负责资源；如果不是，对等方必须拒绝请求。如果副本编号为非零，则对等方必须检查其预期为资源的副本，并且请求发送方与责任节点一致（即，接收对等方不知道有更好的节点）；如果请求发送方不一致，则应拒绝该请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each StoreKindData element represents the data to be stored for a single Kind-ID. The contents of the element are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个StoreKindData元素表示要为单个Kind-ID存储的数据。元素的内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID. Implementations MUST reject requests corresponding to unknown Kinds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-ID。实现必须拒绝与未知种类对应的请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation_counter The expected current state of the generation counter (approximately the number of times that this object has been written; see below for details).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成计数器生成计数器的预期当前状态（大约此对象已写入的次数；有关详细信息，请参阅下文）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
values The value or values to be stored. This may contain one or more stored_data values, depending on the data model associated with each Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值要存储的一个或多个值。这可能包含一个或多个存储的_数据值，具体取决于与每种类型关联的数据模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The peer MUST perform the following checks:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方必须执行以下检查：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Kind-ID is known and supported.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 已知并支持种类ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The signatures over each individual data element, if any, are valid. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 每个数据元素上的签名（如果有）都是有效的。如果此检查失败，则必须拒绝请求，并出现错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Each element is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 每个元素都由一个凭证签名，该凭证被授权在此资源ID处写入此类内容。如果此检查失败，则该请求必须被拒绝，并出现错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For original (non-replica) stores, the StoreReq is signed by a credential which is authorized to write this Kind at this Resource-ID. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于原始（非副本）存储，StoreReq由授权在此资源ID处写入此类内容的凭据签名。如果此检查失败，则必须以错误拒绝请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For replica stores, the StoreReq is signed by a Node-ID which is a plausible node to either have originally stored the value or have been in the replica set. What this means is overlay specific, but in the case of the Chord-based DHT defined in this specification, replica StoreReqs MUST come from nodes which are either in the known replica set for a given resource or which are closer than some node in the replica set. If this check fails, the request MUST be rejected with an Error_Forbidden error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于副本存储，StoreReq由一个节点ID签名，该节点ID可能是最初存储该值或已在副本集中的节点。这意味着覆盖是特定的，但在本规范中定义的基于Chord的DHT的情况下，副本storereq必须来自给定资源的已知副本集中的节点或比副本集中的某个节点更近的节点。如果此检查失败，则必须拒绝请求，并出现错误。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For original (non-replica) stores, the peer MUST check that if the generation counter is nonzero, it equals the current value of the generation counter for this Kind. This feature allows the generation counter to be used in a way similar to the HTTP ETag feature.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于原始（非副本）存储，对等方必须检查生成计数器是否为非零，是否等于此类生成计数器的当前值。此功能允许以类似于HTTP ETag功能的方式使用生成计数器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o For replica Stores, the peer MUST set the generation counter to match the generation counter in the message and MUST NOT check the generation counter against the current value. Replica Stores MUST NOT use a generation counter of 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对于副本存储，对等方必须将生成计数器设置为与消息中的生成计数器匹配，并且不得根据当前值检查生成计数器。副本存储不能使用0的生成计数器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The storage time values are greater than that of any values which would be replaced by this Store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 存储时间值大于将被此存储替换的任何值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The size and number of the stored values are consistent with the limits specified in the overlay configuration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 存储值的大小和数量与覆盖配置中指定的限制一致。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data is signed with identity_type set to &#34;none&#34; and/or SignatureAndHashAlgorithm values set to {0, 0} (&#34;anonymous&#34; and &#34;none&#34;), the StoreReq MUST be rejected with an Error_forbidden error. Only synthesized data returned by the storage can use these values (see Section 7.4.2.2)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果数据签名时标识类型设置为“无”和/或SignatureAndhalGorithm值设置为{0,0}（“匿名”和“无”），则必须以错误拒绝StoreReq。只有存储器返回的合成数据才能使用这些值（见第7.4.2.2节）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If all these checks succeed, the peer MUST attempt to store the data values. For non-replica stores, if the store succeeds and the data is changed, then the peer MUST increase the generation counter by at least 1. If there are multiple stored values in a single StoreKindData, it is permissible for the peer to increase the generation counter by only 1 for the entire Kind-ID or by 1 or more than 1 for each value. Accordingly, all stored data values MUST have a generation counter of 1 or greater. 0 is used in the Store request to indicate that the generation counter should be ignored for processing this request. However, the responsible peer should increase the stored generation counter and should return the correct generation counter in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果所有这些检查都成功，对等方必须尝试存储数据值。对于非副本存储，如果存储成功且数据发生更改，则对等方必须将生成计数器至少增加1。如果单个StoreKindData中有多个存储值，则允许对等方对整个种类ID仅将生成计数器增加1，或对每个值增加1或超过1。因此，所有存储的数据值必须具有1或更大的生成计数器。在存储请求中使用0表示处理此请求时应忽略生成计数器。但是，负责的对等方应增加存储的生成计数器，并在响应中返回正确的生成计数器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer stores data previously stored by another node (e.g., for replicas or topology shifts), it MUST adjust the lifetime value downward to reflect the amount of time the value was stored at the peer. The adjustment SHOULD be implemented by an algorithm equivalent to the following: at the time the peer initially receives the StoreReq, it notes the local time T. When it then attempts to do a StoreReq to another node, it should decrement the lifetime value by the difference between the current local time and T.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当一个对等节点存储另一个节点先前存储的数据（例如，用于副本或拓扑变换）时，它必须向下调整生存期值，以反映该值存储在对等节点上的时间量。该调整应通过与以下等效的算法实现：对等方最初接收到StoreReq时，它记录本地时间T。当它随后尝试对另一个节点执行StoreReq时，它应通过当前本地时间和T之间的差值来减少生存期值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unless otherwise specified by the usage, if a peer attempts to store data previously stored by another node (e.g., for replicas or topology shifts) and that store fails with either an Error_Generation_Counter_Too_Low or an Error_Data_Too_Old error, the peer MUST fetch the newer data from the peer generating the error and use that to replace its own copy. This rule allows resynchronization after partitions heal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除非用法另有规定，否则如果对等方试图存储另一个节点先前存储的数据（例如，用于副本或拓扑变换），并且该存储失败，并出现错误\生成\计数器\过低或错误\数据\旧错误，对等方必须从生成错误的对等方获取较新的数据，并使用该数据替换自己的副本。此规则允许在分区恢复后重新同步。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a network partition is being healed and unless otherwise specified, the default merging rule is to act as if all the values that need to be merged were stored and as if the order they were stored in corresponds to the stored time values associated with (and carried in) their values. Because the stored time values are those associated with the peer which did the writing, clock skew is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在修复网络分区时，除非另有规定，否则默认合并规则的作用是，将需要合并的所有值都存储起来，并且它们存储的顺序对应于与它们的值关联（并带入）的存储时间值。因为存储的时间值与进行写入的对等方相关，所以时钟偏移是
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generally not an issue. If two nodes are on different partitions, write to the same location, and have clock skew, this can create merge conflicts. However, because RELOAD deliberately segregates storage so that data from different users and peers is stored in different locations, and a single peer will typically only be in a single network partition, this case will generally not arise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般来说，这不是一个问题。如果两个节点位于不同的分区上，写入到相同的位置，并且存在时钟偏移，则可能会产生合并冲突。但是，由于重新加载故意隔离存储，因此来自不同用户和对等方的数据存储在不同的位置，并且单个对等方通常仅位于单个网络分区中，因此通常不会出现这种情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The properties of stores for each data model are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个数据模型的存储属性如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
single-value: A store of a new single-value element creates the element if it does not exist and overwrites any existing value with the new value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单值：如果新的单值元素不存在，则新的单值元素的存储将创建该元素，并用新值覆盖任何现有值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
array: A store of an array entry replaces (or inserts) the given value at the location specified by the index. Because arrays are sparse, a store past the end of the array extends it with nonexistent values (exists = False) as required. A store at index 0xffffffff places the new value at the end of the array, regardless of the length of the array. The resulting StoredData has the correct index value when it is subsequently fetched.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数组：数组项的存储在索引指定的位置替换（或插入）给定值。因为数组是稀疏的，所以超过数组末尾的存储会根据需要使用不存在的值（exists=False）对其进行扩展。索引0xFFFFFF处的存储将新值放置在数组的末尾，而与数组的长度无关。随后获取结果StoredData时，它具有正确的索引值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
dictionary: A store of a dictionary entry replaces (or inserts) the given value at the location specified by the dictionary key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
字典：字典项的存储在字典键指定的位置替换（或插入）给定值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following figure shows the relationship between these structures for an example store which stores the following values at resource &#34;1234&#34;:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下图显示了在资源“1234”中存储以下值的示例存储的这些结构之间的关系：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value &#34;abc&#34; is in the single-value location for Kind X.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 值“abc”位于X类的单值位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value &#34;foo&#34; at index 0 is in the array for Kind Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 索引0处的值“foo”位于Y类的数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The value &#34;bar&#34; at index 1 is in the array for Kind Y.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 索引1处的值“bar”位于Y类的数组中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                     Store
                                resource=1234
                              replica_number = 0
                                   /      \
                                  /        \
                      StoreKindData        StoreKindData
                  kind=X (Single-Value)    kind=Y (Array)
                generation_counter = 99    generation_counter = 107
                           |                    /\
                           |                   /  \
                       StoredData             /    \
             storage_time = xxxxxxx          /      \
                   lifetime = 86400         /        \
                   signature = XXXX        /          \
                           |               |           |
                           |        StoredData       StoredData
                           |    storage_time =       storage_time =
                           |          yyyyyyyy       zzzzzzz
                           |  lifetime = 86400       lifetime = 33200
                           |  signature = YYYY       signature = ZZZZ
                           |               |           |
                    StoredDataValue        |           |
                     value=&#34;abc&#34;           |           |
                                           |           |
                                  StoredDataValue  StoredDataValue
                                        index=0      index=1
                                     value=&#34;foo&#34;    value=&#34;bar&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                                     Store
                                resource=1234
                              replica_number = 0
                                   /      \
                                  /        \
                      StoreKindData        StoreKindData
                  kind=X (Single-Value)    kind=Y (Array)
                generation_counter = 99    generation_counter = 107
                           |                    /\
                           |                   /  \
                       StoredData             /    \
             storage_time = xxxxxxx          /      \
                   lifetime = 86400         /        \
                   signature = XXXX        /          \
                           |               |           |
                           |        StoredData       StoredData
                           |    storage_time =       storage_time =
                           |          yyyyyyyy       zzzzzzz
                           |  lifetime = 86400       lifetime = 33200
                           |  signature = YYYY       signature = ZZZZ
                           |               |           |
                    StoredDataValue        |           |
                     value=&#34;abc&#34;           |           |
                                           |           |
                                  StoredDataValue  StoredDataValue
                                        index=0      index=1
                                     value=&#34;foo&#34;    value=&#34;bar&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In response to a successful Store request, the peer MUST return a StoreAns message containing a series of StoreKindResponse elements, which contains the current value of the generation counter for each Kind-ID, as well as a list of the peers where the data will be replicated by the node processing the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了响应成功的存储请求，对等方必须返回一条StoreAns消息，其中包含一系列StoreKindResponse元素，其中包含每个种类ID的生成计数器的当前值，以及处理请求的节点将在其中复制数据的对等方列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          KindId                  kind;
          uint64                  generation_counter;
          NodeId                  replicas&lt;0..2^16-1&gt;;
        } StoreKindResponse;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          KindId                  kind;
          uint64                  generation_counter;
          NodeId                  replicas&lt;0..2^16-1&gt;;
        } StoreKindResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          StoreKindResponse       kind_responses&lt;0..2^16-1&gt;;
        } StoreAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          StoreKindResponse       kind_responses&lt;0..2^16-1&gt;;
        } StoreAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of each StoreKindResponse are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个StoreKindResponse的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID being represented.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类表示的种类ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation_counter The current value of the generation counter for that Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成\计数器该种类ID的生成计数器的当前值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
replicas The list of other peers at which the data was/will be replicated. In overlays and applications where the responsible peer is intended to store redundant copies, this allows the storing node to independently verify that the replicas have in fact been stored. It does this verification by using the Stat method (see Section 7.4.3). Note that the storing node is not required to perform this verification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
复制已复制/将复制数据的其他对等方的列表。在责任对等方打算存储冗余副本的覆盖和应用程序中，这允许存储节点独立验证副本是否已实际存储。通过使用Stat方法进行验证（见第7.4.3节）。请注意，存储节点不需要执行此验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response itself is just StoreKindResponse values packed end to end.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
响应本身就是端到端打包的StoreKindResponse值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any of the generation counters in the request precede the corresponding stored generation counter, then the peer MUST fail the entire request and respond with an Error_Generation_Counter_Too_Low error. The error_info in the ErrorResponse MUST be a StoreAns response containing the correct generation counter for each Kind and the replica list, which will be empty. For original (non-replica) stores, a node which receives such an error SHOULD attempt to fetch the data and, if the storage_time value is newer, replace its own data with that newer data. This rule improves data consistency in the case of partitions and merges.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果请求中的任何生成计数器位于相应存储的生成计数器之前，则对等方必须使整个请求失败，并以错误\u生成\u计数器\u过低错误进行响应。ErrorResponse中的错误信息必须是StoreAns响应，其中包含每种类型的正确生成计数器和副本列表，副本列表将为空。对于原始（非副本）存储，接收到此类错误的节点应尝试获取数据，如果存储时间值较新，则应使用较新的数据替换其自身的数据。此规则提高了分区和合并情况下的数据一致性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the data being stored is too large for the allowed limit by the given usage, then the peer MUST fail the request and generate an Error_Data_Too_Large error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果所存储的数据太大，超出了给定使用所允许的限制，则对等方必须使请求失败，并生成错误\u data\u too\u large Error。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If any type of request tries to access a data Kind that the peer does not know about, the peer MUST fail the request and generate an Error_Unknown_Kind error. The error_info in the Error_Response is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果任何类型的请求试图访问对等方不知道的数据类型，则对等方必须使请求失败并生成错误\未知\类型错误。错误响应中的错误信息为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              KindId        unknown_kinds&lt;0..2^8-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              KindId        unknown_kinds&lt;0..2^8-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
which lists all the Kinds that were unrecognized. A node which receives this error MUST generate a ConfigUpdate message which contains the appropriate Kind definition (assuming which, in fact, a Kind which was defined in the configuration document was used).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
其中列出了所有无法识别的类型。接收此错误的节点必须生成包含适当种类定义的ConfigUpdate消息（假设使用了配置文档中定义的种类）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. Removing Values
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.1.3. 删除值
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD does not have an explicit Remove operation. Rather, values are Removed by storing &#34;nonexistent&#34; values in their place. Each DataValue contains a boolean value called &#34;exists&#34; which indicates whether a value is present at that location. In order to effectively remove a value, the owner stores a new DataValue with &#34;exists&#34; set to False:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重新加载没有显式的删除操作。相反，通过将“不存在”的值存储在它们的位置来删除这些值。每个数据值都包含一个名为“exists”的布尔值，该值指示该位置是否存在值。为了有效地删除一个值，所有者存储一个新的数据值，并将“exists”设置为False：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      exists = False
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      exists = False
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      value = {} (0 length)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      value = {} (0 length)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The owner SHOULD use a lifetime for the nonexistent value that is at least as long as the remainder of the lifetime of the value it is replacing. Otherwise, it is possible for the original value to be accidentally or maliciously re-stored after the storing node has expired it. Note that a window of vulnerability for replay attack still exists after the original lifetime has expired (as with any store). This attack can be mitigated by doing a nonexistent store with a very long lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有者应该为不存在的值使用一个生存期，该生存期至少与它要替换的值的剩余生存期一样长。否则，在存储节点过期后，可能会意外或恶意地重新存储原始值。请注意，在原始生存期到期后（与任何存储一样），重播攻击的漏洞窗口仍然存在。通过使用很长的生命周期进行不存在的存储，可以减轻此攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Storing nodes MUST treat these nonexistent values the same way they treat any other stored value, including overwriting the existing value, replicating them, and aging them out as necessary when the lifetime expires. When a stored nonexistent value&#39;s lifetime expires, it is simply removed from the storing node, as happens when any other stored value expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
存储节点必须像对待任何其他存储值一样对待这些不存在的值，包括覆盖现有值、复制它们，以及在生存期到期时根据需要对它们进行老化。当存储的不存在值的生存期到期时，它将从存储节点中删除，就像任何其他存储值到期时一样。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in the case of arrays and dictionaries, expiration may create an implicit, unsigned &#34;nonexistent&#34; value to represent a gap in the data structure, as might happen when any value is aged out.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，在数组和字典的情况下，过期可能会创建一个隐式的、无符号的“不存在”值来表示数据结构中的间隙，当任何值过期时可能会发生这种情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However, this value isn&#39;t persistent, nor is it replicated. It is simply synthesized by the storing node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
但是，该值不是持久的，也不是复制的。它由存储节点简单地合成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. Fetch
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2. 取来
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Fetch request retrieves one or more data elements stored at a given Resource-ID. A single Fetch request can retrieve multiple different Kinds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fetch请求检索存储在给定资源ID中的一个或多个数据元素。单个Fetch请求可以检索多个不同类型的数据元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Fetch requests are defined by the FetchReq structure:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
获取请求由FetchReq结构定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          int32            first;
          int32            last;
        } ArrayRange;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          int32            first;
          int32            last;
        } ArrayRange;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          KindId                  kind;
          uint64                  generation;
          uint16                  length;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          KindId                  kind;
          uint64                  generation;
          uint16                  length;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (DataModel) {
            case single_value: ;    /* Empty */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          select (DataModel) {
            case single_value: ;    /* Empty */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case array:
                 ArrayRange       indices&lt;0..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case array:
                 ArrayRange       indices&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case dictionary:
                 DictionaryKey    keys&lt;0..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case dictionary:
                 DictionaryKey    keys&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          } model_specifier;
        } StoredDataSpecifier;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          } model_specifier;
        } StoredDataSpecifier;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ResourceId              resource;
          StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
        } FetchReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ResourceId              resource;
          StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
        } FetchReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the Fetch requests are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
获取请求的内容如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The Resource-ID to fetch from.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource要从中获取的资源ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specifiers A sequence of StoredDataSpecifier values, each specifying some of the data values to retrieve.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
说明符一系列StoredDataSpecifier值，每个值指定要检索的一些数据值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each StoredDataSpecifier specifies a single Kind of data to retrieve and, if appropriate, the subset of values that are to be retrieved. The contents of the StoredDataSpecifier structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个StoredDataSpecifier指定一种要检索的数据，如果合适，还指定要检索的值的子集。StoredDataSpecifier结构的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID of the data being fetched. Implementations SHOULD reject requests corresponding to unknown Kinds unless specifically configured otherwise.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类正在提取的数据的种类ID。除非另有特别配置，否则实现应该拒绝与未知类型对应的请求。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DataModel The data model of the data. This is not transmitted on the wire, but comes from the definition of the Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据模型数据的数据模型。这不是通过电线传输的，而是根据种类的定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation The last generation counter that the requesting node saw. This may be used to avoid unnecessary fetches, or it may be set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成请求节点看到的最后一个生成计数器。这可以用来避免不必要的抓取，也可以设置为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
length The length of the rest of the structure, thus allowing extensibility.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
长度结构其余部分的长度，因此允许扩展性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
model_specifier A reference to the data value being requested within the data model specified for the Kind. For instance, if the data model is &#34;array&#34;, it might specify some subset of the values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
model_说明符在为该类指定的数据模型中请求的数据值的引用。例如，如果数据模型是“array”，它可能会指定一些值的子集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The model_specifier is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
model_说明符如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data model is single value, the specifier is empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果数据模型为单值，则说明符为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data model is array, the specifier contains a list of ArrayRange elements, each of which contains two integers. The first integer is the beginning of the range, and the second is the end of the range. 0 is used to indicate the first element, and 0xffffffff is used to indicate the final element. The first integer MUST be less than or equal to the second. While multiple ranges MAY be specified, they MUST NOT overlap.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果数据模型是array，则说明符包含ArrayRange元素的列表，每个元素包含两个整数。第一个整数是范围的开始，第二个整数是范围的结束。0用于指示第一个元素，0xffffffff用于指示最后一个元素。第一个整数必须小于或等于第二个整数。虽然可以指定多个范围，但它们不得重叠。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If the data model is dictionary, then the specifier contains a list of the dictionary keys being requested. If no keys are specified, then this is a wildcard fetch and all key-value pairs are returned.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果数据模型是dictionary，那么说明符包含所请求的dictionary键的列表。如果未指定任何键，则这是通配符获取，并返回所有键-值对。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The generation counter is used to indicate the requester&#39;s expected state of the storing peer. If the generation counter in the request matches the stored counter, then the storing peer returns a response with no StoredData values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成计数器用于指示请求者存储对等方的预期状态。如果请求中的生成计数器与存储的计数器匹配，则存储对等方将返回一个没有存储数据值的响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.2.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response to a successful Fetch request is a FetchAns message containing the data requested by the requester.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
成功获取请求的响应是包含请求者请求的数据的FetchAns消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           KindId                 kind;
           uint64                 generation;
           StoredData             values&lt;0..2^32-1&gt;;
         } FetchKindResponse;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           KindId                 kind;
           uint64                 generation;
           StoredData             values&lt;0..2^32-1&gt;;
         } FetchKindResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           FetchKindResponse      kind_responses&lt;0..2^32-1&gt;;
         } FetchAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         struct {
           FetchKindResponse      kind_responses&lt;0..2^32-1&gt;;
         } FetchAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FetchAns structure contains a series of FetchKindResponse structures. There MUST be one FetchKindResponse element for each Kind-ID in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FetchAns结构包含一系列FetchKindResponse结构。请求中的每个种类ID必须有一个FetchKindResponse元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the FetchKindResponse structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FetchKindResponse结构的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind that this structure is for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这种结构的用途。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
generation The generation counter for this Kind.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
生成此类型的生成计数器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
values The relevant values. If the generation counter in the request matches the generation counter in the stored data, then no StoredData values are returned. Otherwise, all relevant data values MUST be returned. A nonexistent value (i.e., one which the node has no knowledge of) is represented by a synthetic value with &#34;exists&#34; set to False and has an empty signature. Specifically, the identity_type is set to &#34;none&#34;, the SignatureAndHashAlgorithm values are set to {0, 0} (&#34;anonymous&#34; and &#34;none&#34;, respectively), and the signature value is of zero length. This removes the need for the responding node to do signatures for values which do not exist. These signatures are unnecessary, as the entire response is signed by that node. Note that entries which have been removed by the procedure given in Section 7.4.1.3 and which have not yet expired also have exists = False, but have valid signatures from the node which did the store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
计算相关值。如果请求中的生成计数器与存储数据中的生成计数器匹配，则不会返回任何StoredData值。否则，必须返回所有相关数据值。不存在的值（即，节点不知道的值）由“exists”设置为False且具有空签名的合成值表示。具体地说，将identity_type设置为“none”，将SignatureAndhalGorithm值设置为{0,0}（“匿名”和“无”），并且签名值的长度为零。这样就不需要响应节点对不存在的值进行签名。这些签名是不必要的，因为整个响应都是由该节点签名的。请注意，已通过第7.4.1.3节中给出的程序删除且尚未过期的条目也存在=False，但具有进行存储的节点的有效签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt of a FetchAns message, nodes MUST verify the signatures on all the received values. Any values with invalid signatures (including expired certificates) MUST be discarded. Note that this implies that implementations which wish to store data for long periods of time must have certificates with appropriate expiration dates or must re-store periodically. Implementations MAY return the subset of values with valid signatures, but in that case, they SHOULD somehow signal to the application that a partial response was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
收到FetchAns消息后，节点必须验证所有接收值上的签名。必须丢弃具有无效签名（包括过期证书）的任何值。请注意，这意味着希望长时间存储数据的实现必须具有具有适当过期日期的证书，或者必须定期重新存储。实现可能返回具有有效签名的值子集，但在这种情况下，它们应该以某种方式向应用程序发出信号，表明已收到部分响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There is one subtle point about signature computation on arrays. If the storing node uses the append feature (where the index=0xffffffff), then the index in the StoredData that is returned will not match that used by the storing node, which would break the signature. In order to avoid this issue, the index value in the array is set to zero before the signature is computed. This implies that malicious storing nodes can reorder array entries without being detected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数组上的签名计算有一个微妙之处。如果存储节点使用追加功能（其中索引=0xffffffff），则返回的StoredData中的索引将与存储节点使用的索引不匹配，这将破坏签名。为了避免此问题，在计算签名之前，将数组中的索引值设置为零。这意味着恶意存储节点可以在不被检测的情况下对数组项重新排序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. Stat
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3. 斯达
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Stat request is used to get metadata (length, generation counter, digest, etc.) for a stored element without retrieving the element itself. The name is from the UNIX stat(2) system call, which performs a similar function for files in a file system. It also allows the requesting node to get a list of matching elements without requesting the entire element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stat请求用于获取存储元素的元数据（长度、生成计数器、摘要等），而无需检索元素本身。该名称来自UNIX stat（2）系统调用，它对文件系统中的文件执行类似的功能。它还允许请求节点获得匹配元素的列表，而无需请求整个元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Stat request is identical to the Fetch request. It simply specifies the elements to get metadata about.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stat请求与Fetch请求相同。它只是指定要获取元数据的元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ResourceId              resource;
          StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
        } StatReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          ResourceId              resource;
          StoredDataSpecifier     specifiers&lt;0..2^16-1&gt;;
        } StatReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.3.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Stat response contains the same sort of entries that a Fetch response would contain. However, instead of containing the element data, it contains metadata.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stat响应包含与Fetch响应相同的条目类型。但是，它不包含元素数据，而是包含元数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          Boolean                exists;
          uint32                 value_length;
          HashAlgorithm          hash_algorithm;
          opaque                 hash_value&lt;0..255&gt;;
        } MetaData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          Boolean                exists;
          uint32                 value_length;
          HashAlgorithm          hash_algorithm;
          opaque                 hash_value&lt;0..255&gt;;
        } MetaData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                 index;
          MetaData               value;
        } ArrayEntryMeta;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                 index;
          MetaData               value;
        } ArrayEntryMeta;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          DictionaryKey          key;
          MetaData               value;
        } DictionaryEntryMeta;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          DictionaryKey          key;
          MetaData               value;
        } DictionaryEntryMeta;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          select (DataModel) {
            case single_value:
              MetaData              single_value_entry;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          select (DataModel) {
            case single_value:
              MetaData              single_value_entry;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case array: ArrayEntryMeta array_entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
案例数组：ArrayEntryMeta数组\ u条目；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
case dictionary: DictionaryEntryMeta dictionary_entry;
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-12">
案例词典：DictionaryEntryMeta dictionary\u条目；
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended */
          };
        } MetaDataValue;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            /* This structure may be extended */
          };
        } MetaDataValue;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                  value_length;
          uint64                  storage_time;
          uint32                  lifetime;
          MetaDataValue           metadata;
        } StoredMetaData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint32                  value_length;
          uint64                  storage_time;
          uint32                  lifetime;
          MetaDataValue           metadata;
        } StoredMetaData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          KindId                 kind;
          uint64                 generation;
          StoredMetaData         values&lt;0..2^32-1&gt;;
        } StatKindResponse;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          KindId                 kind;
          uint64                 generation;
          StoredMetaData         values&lt;0..2^32-1&gt;;
        } StatKindResponse;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          StatKindResponse      kind_responses&lt;0..2^32-1&gt;;
        } StatAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          StatKindResponse      kind_responses&lt;0..2^32-1&gt;;
        } StatAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The structures used in StatAns parallel those used in FetchAns: a response consists of multiple StatKindResponse values, one for each Kind that was in the request. The contents of the StatKindResponse are the same as those in the FetchKindResponse, except that the values list contains StoredMetaData entries instead of StoredData entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
statan中使用的结构与fetchan中使用的结构类似：响应由多个StatKindResponse值组成，请求中的每种类型对应一个。StatKindResponse的内容与FetchKindResponse中的内容相同，只是值列表包含StoredMetaData条目而不是StoredData条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of the StoredMetaData structure are the same as the corresponding fields in StoredData, except that there is no signature field and the value is a MetaDataValue rather than a StoredDataValue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StoredMetaData结构的内容与StoredData中的相应字段相同，只是没有签名字段，并且该值是MetaDataValue而不是StoredDataValue。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A MetaDataValue is a variant structure, like a StoredDataValue, except for the types of each arm, which replace DataValue with MetaData.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MetaDataValue是一种变体结构，与StoredDataValue类似，但每个arm的类型除外，它们用元数据替换DataValue。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The only new structure is MetaData, which has the following contents:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
唯一的新结构是元数据，它具有以下内容：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exists Same as in DataValue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与DataValue中的存在相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value_length The length of the stored value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
value\u length存储值的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash_algorithm The hash algorithm used to perform the digest of the value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
哈希算法用于执行值摘要的哈希算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash_value A digest using hash_algorithm on the value field of the DataValue, including its 4 leading length bytes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
hash_值在DataValue的value字段上使用hash_算法的摘要，包括其4个前导长度字节。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. Find
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4. 发现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Find request can be used to explore the Overlay Instance. A Find request for a Resource-ID R and a Kind-ID T retrieves the Resource-ID, if any, of the resource of Kind T known to the target peer which is closest to R. This method can be used to walk the Overlay Instance by iteratively fetching R_n+1=nearest(1 + R_n).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Find请求可用于浏览覆盖实例。对资源ID R和种类ID T的查找请求检索目标对等方已知的、距离R最近的T类资源的资源ID（如果有）。此方法可通过迭代获取R_n+1=最近（1+R_n）来遍历覆盖实例。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.1. Request Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.1. 请求定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The FindReq message contains a Resource-ID and a series of Kind-IDs identifying the resource the peer is interested in.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
FindReq消息包含一个资源ID和一系列种类ID，标识对等方感兴趣的资源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
       ResourceId                 resource;
       KindId                     kinds&lt;0..2^8-1&gt;;
     } FindReq;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     struct {
       ResourceId                 resource;
       KindId                     kinds&lt;0..2^8-1&gt;;
     } FindReq;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The request contains a list of Kind-IDs which the Find is for, as indicated below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请求包含查找所针对的种类ID列表，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource The desired Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
resource指定所需的resource-ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kinds The desired Kind-IDs. Each value MUST appear only once. Otherwise, the request MUST be rejected with an error.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对所需的种类ID进行分类。每个值只能出现一次。否则，请求必须被错误地拒绝。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.2. Response Definition
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.4.2. 响应定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A response to a successful Find request is a FindAns message containing the closest Resource-ID on the peer for each Kind specified in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对成功查找请求的响应是一条FindAns消息，其中包含请求中指定的每种类型的对等方上最接近的资源ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
      KindId                      kind;
      ResourceId                  closest;
    } FindKindData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
      KindId                      kind;
      ResourceId                  closest;
    } FindKindData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
      FindKindData                results&lt;0..2^16-1&gt;;
    } FindAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    struct {
      FindKindData                results&lt;0..2^16-1&gt;;
    } FindAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the processing peer is not responsible for the specified Resource-ID, it SHOULD return an Error_Not_Found error code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果处理对等方不负责指定的资源ID，则应返回错误\u not \u Found错误代码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each Kind-ID in the request, the response MUST contain a FindKindData indicating the closest Resource-ID for that Kind-ID, unless the Kind is not allowed to be used with Find, in which case a FindKindData for that Kind-ID MUST NOT be included in the response. If a Kind-ID is not known, then the corresponding Resource-ID MUST be 0. Note that different Kind-IDs may have different closest Resource-IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于请求中的每个种类ID，响应必须包含一个FindKindData，指示该种类ID最近的资源ID，除非该种类不允许与Find一起使用，在这种情况下，该种类ID的FindKindData不能包含在响应中。如果种类ID未知，则相应的资源ID必须为0。请注意，不同种类的ID可能具有不同的最近资源ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The response is simply a series of FindKindData elements, one per Kind, concatenated end to end. The contents of each element are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
响应只是一系列FindKindData元素，每种元素一个，端到端连接。每个元素的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind The Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
好样的，好样的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
closest The closest Resource-ID to the specified Resource-ID. It is 0 if no Resource-ID is known.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最接近指定资源ID的最近资源ID。如果不知道资源ID，则为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that the response does not contain the contents of the data stored at these Resource-IDs. If the requester wants this, it must retrieve it using Fetch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，响应不包含存储在这些资源ID上的数据内容。如果请求者需要它，它必须使用Fetch检索它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. Defining New Kinds
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4.5. 定义新种类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two ways to define a new Kind. The first is by writing a document and registering the Kind-ID with IANA. This is the preferred method for Kinds which may be widely used and reused. The second method is to simply define the Kind and its parameters in the Configuration Document using the section of Kind-ID space set aside for private use. This method MAY be used to define ad hoc Kinds in new overlays.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有两种方法可以定义一种新类型。第一种方法是编写文档并向IANA注册种类ID。对于可能广泛使用和重复使用的类型，这是首选方法。第二种方法是使用为私人使用而预留的种类ID空间部分，在配置文档中简单地定义种类及其参数。此方法可用于定义新覆盖中的特殊类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
However a Kind is defined, the definition MUST include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论种类如何定义，定义必须包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The meaning of the data to be stored (in some textual form).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 要存储的数据的含义（以某种文本形式）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Kind-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 善良的ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The data model (single value, array, dictionary, etc.).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 数据模型（单值、数组、字典等）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The access control model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 访问控制模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, when Kinds are registered with IANA, each Kind is assigned a short string name which is used to refer to it in Configuration Documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，当向IANA注册种类时，每个种类都会被分配一个短字符串名称，用于在配置文档中引用它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While each Kind needs to define what data model is used for its data, this does not mean that it must define new data models. Where practical, Kinds should use the existing data models. The intention is that the basic data model set be sufficient for most applications/ usages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然每种类型都需要定义用于其数据的数据模型，但这并不意味着必须定义新的数据模型。在可行的情况下，种类应使用现有的数据模型。其目的是基本数据模型集足以满足大多数应用/用途。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Certificate Store Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 证书存储使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Certificate Store Usage allows a node to store its certificate in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书存储使用允许节点在覆盖中存储其证书。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A user/node MUST store its certificate at Resource-IDs derived from two Resource Names:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户/节点必须将其证书存储在源于两个资源名称的资源ID中：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The user name in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 证书中的用户名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Node-ID in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 证书中的节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that in the second case, the certificate for a peer is not stored at its Node-ID but rather at a hash of its Node-ID. The intention here (as is common throughout RELOAD) is to avoid making a peer responsible for its own data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，在第二种情况下，对等方的证书不是存储在其节点ID上，而是存储在其节点ID的散列中。此处的目的（在重新加载过程中很常见）是避免让对等方对其自己的数据负责。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
New certificates are stored at the end of the list. This structure allows users to store an old and a new certificate that both have the same Node-ID, which allows for migration of certificates when they are renewed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
新证书存储在列表的末尾。此结构允许用户存储具有相同节点ID的旧证书和新证书，这允许证书在续订时进行迁移。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This usage defines the following Kinds:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此用法定义了以下类型：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: CERTIFICATE_BY_NODE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名称：证书\u BY\u节点
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Model: The data model for CERTIFICATE_BY_NODE data is array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据模型：证书按节点数据的数据模型为数组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control: NODE-MATCH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
访问控制：节点匹配
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: CERTIFICATE_BY_USER
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
名称：证书由用户颁发
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Model: The data model for CERTIFICATE_BY_USER data is array.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据模型：证书用户数据的数据模型为数组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control: USER-MATCH
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
访问控制：用户匹配
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. TURN Server Usage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 转换服务器使用率
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The TURN Server Usage allows a RELOAD peer to advertise that it is prepared to be a TURN server, as defined in [RFC5766]. When a node starts up, it joins the overlay network and forms several connections in the process. If the ICE stage in any of these connections returns a reflexive address that is not the same as the peer&#39;s perceived address, then the peer is behind a NAT and SHOULD NOT be a candidate for a TURN server. Additionally, if the peer&#39;s IP address is in the private address space range as defined by [RFC1918], then it is also
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
按照[RFC5766]中的定义，TURN服务器的使用允许重新加载对等机通告其准备成为TURN服务器。当一个节点启动时，它将加入覆盖网络，并在此过程中形成多个连接。如果这些连接中的ICE阶段返回的自反地址与对等方的感知地址不同，则对等方位于NAT后面，不应成为TURN服务器的候选。此外，如果对等方的IP地址在[RFC1918]定义的专用地址空间范围内，则它也是
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHOULD NOT be a candidate for a TURN server. Otherwise, the peer SHOULD assume that it is a potential TURN server and follow the procedures below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
不应该是回合服务器的候选。否则，对等方应假定它是一个潜在的TURN服务器，并遵循以下步骤。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the node is a candidate for a TURN server, it will insert some pointers in the overlay so that other peers can find it. The overlay configuration file specifies a turn-density parameter that indicates how many times each TURN server SHOULD record itself in the overlay. Typically, this should be set to the reciprocal of the estimate of what percentage of peers will act as TURN servers. If the turn-density is not set to zero, for each value, called d, between 1 and turn-density, the peer forms a Resource Name by concatenating its Node-ID and the value d. This Resource Name is hashed to form a Resource-ID. The address of the peer is stored at that Resource-ID using type TURN-SERVICE and the TurnServer object:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果节点是TURN服务器的候选节点，它将在覆盖中插入一些指针，以便其他对等方可以找到它。覆盖配置文件指定一个转弯密度参数，该参数指示每个转弯服务器应在覆盖中记录自身的次数。通常，这应该设置为估计将充当TURN服务器的对等方百分比的倒数。如果转弯密度未设置为零，则对于1和转弯密度之间的每个称为d的值，对等节点通过连接其节点ID和值d来形成资源名称。将此资源名称散列以形成资源ID。使用类型TURN-SERVICE和TurnServer对象，对等方的地址存储在该资源ID处：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint8                   iteration;
          IpAddressPort           server_address;
        } TurnServer;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
          uint8                   iteration;
          IpAddressPort           server_address;
        } TurnServer;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iteration The d value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
迭代d值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server_address The address at which the TURN server can be contacted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
server\ U address可联系TURN服务器的地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note: Correct functioning of this algorithm depends on having turn-density be a reasonable estimate of the reciprocal of the proportion of nodes in the overlay that can act as TURN servers. If the turn-density value in the configuration file is too low, the process of finding TURN servers becomes more expensive, as multiple candidate Resource-IDs must be probed to find a TURN server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注：该算法的正确运行取决于转弯密度是覆盖中可用作转弯服务器的节点比例倒数的合理估计。如果配置文件中的回合密度值过低，则查找回合服务器的过程将变得更加昂贵，因为必须探测多个候选资源ID才能找到回合服务器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peers that provide this service need to support the TURN extensions to STUN for media relay, as defined in [RFC5766].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据[RFC5766]中的定义，提供此服务的对等方需要支持媒体中继的STUN回合扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This usage defines the following Kind to indicate that a peer is willing to act as a TURN server:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此用法定义了以下类型，以表示对等方愿意充当TURN服务器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Name: TURN-SERVICE
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
姓名：转乘服务
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Data Model: The TURN-SERVICE Kind stores a single value for each Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据模型：TURN-SERVICE类为每个资源ID存储一个值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Access Control: NODE-MULTIPLE, with a maximum iteration of counter 20.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
访问控制：多个节点，最多迭代计数器20。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Peers MAY find other servers by selecting a random Resource-ID and then doing a Find request for the appropriate Kind-ID with that Resource-ID. The Find request gets routed to a random peer based on the Resource-ID. If that peer knows of any servers, they will be returned. The returned response may be empty if the peer does not know of any servers, in which case the process gets repeated with some other random Resource-ID. As long as the ratio of servers relative to peers is not too low, this approach will result in finding a server relatively quickly.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方可以通过选择一个随机资源ID，然后使用该资源ID对相应的种类ID执行查找请求来查找其他服务器。查找请求将根据资源ID路由到一个随机对等方。如果该对等方知道任何服务器，将返回它们。如果对等方不知道任何服务器，则返回的响应可能为空，在这种情况下，该过程将使用其他一些随机资源ID重复。只要服务器与对等方的比率不太低，这种方法将导致相对较快地找到服务器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note to implementers: The certificates used by TurnServer entries need to be retained, as described in Section 6.3.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实施者注意：TurnServer条目使用的证书需要保留，如第6.3.4节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. Chord Algorithm
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 弦算法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm is assigned the name CHORD-RELOAD to indicate that it is an adaptation of the basic Chord-based DHT algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法被命名为CHORD-RELOAD，以表明它是对基于CHORD的基本DHT算法的一种改编。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This algorithm differs from the Chord algorithm that was originally presented in [Chord]. It has been updated based on more recent research results and implementation experiences, and to adapt it to the RELOAD protocol. Here is a short list of differences:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此算法不同于最初在[Chord]中提出的Chord算法。它已经根据最近的研究结果和实现经验进行了更新，并使其适应重新加载协议。以下是一个简短的差异列表：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The original Chord algorithm specified that a single predecessor and a successor list be stored. The CHORD-RELOAD algorithm attempts to have more than one predecessor and successor. The predecessor sets help other neighbors learn their successor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 原始Chord算法指定存储单个前置和后续列表。CHORD-RELOAD算法尝试有多个前置和后继。前置集合帮助其他邻居学习其后续列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The original Chord specification and analysis called for iterative routing. RELOAD specifies recursive routing. In addition to the performance implications, the cost of NAT traversal dictates recursive routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 最初的Chord规范和分析要求迭代路由。重载指定递归路由。除了性能影响之外，NAT遍历的成本还决定了递归路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Finger Table entries are indexed in the opposite order. Original Chord specifies finger[0] as the immediate successor of the peer. CHORD-RELOAD specifies finger[0] as the peer 180 degrees around the ring from the peer. This change was made to simplify discussion and implementation of variable-sized Finger Tables. However, with either approach, no more than O(log N) entries should typically be stored in a Finger Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 索引表条目的索引顺序相反。原始和弦将finger[0]指定为对等方的直接后续项。CHORD-RELOAD将finger[0]指定为与对等方环成180度角的对等方。进行此更改是为了简化可变大小手指表的讨论和实现。但是，无论采用哪种方法，Finger表中通常存储的条目不应超过O（logn）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The stabilize() and fix_fingers() algorithms in the original Chord algorithm are merged into a single periodic process. Stabilization is implemented slightly differently because of the larger neighborhood, and fix_fingers is not as aggressive to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 原始Chord算法中的stabilize（）和fix_fingers（）算法合并为一个周期过程。由于邻域较大，所以实现稳定的方式略有不同，而且fix_fingers对用户的攻击性也较小
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
reduce load, nor does it search for optimal matches of the Finger Table entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
减少负载，也不会搜索Finger表项的最佳匹配。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELOAD allows for a 128-bit hash instead of a 160-bit hash, as RELOAD is not designed to be used in networks with close to or more than 2^128 nodes or objects (and it is hard to see how one would assemble such a network).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELOAD允许使用128位哈希而不是160位哈希，因为RELOAD的设计不适用于具有接近或超过2^128个节点或对象的网络（很难看出如何组装这样的网络）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o RELOAD uses randomized finger entries, as described in Section 10.7.4.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 重新加载使用随机手指条目，如第10.7.4.2节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The CHORD-RELOAD algorithm allows the use of either reactive or periodic recovery. The original Chord paper used periodic recovery. Reactive recovery provides better performance in small overlays, but is believed to be unstable in large overlays (greater than 1000) with high levels of churn [handling-churn-usenix04]. The overlay configuration file specifies a &#34;chord-reactive&#34; element that indicates whether reactive recovery should be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o CHORD-RELOAD算法允许使用反应式或周期性恢复。原始和弦纸采用周期性恢复。反应式恢复在小覆盖层中提供了更好的性能，但据信在高流失率的大覆盖层（大于1000）中性能不稳定[handling-Chorn-Usenix 04]。覆盖配置文件指定了一个“chord reactive”元素，用于指示是否应使用反应恢复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm described here, CHORD-RELOAD, is a modified version of the Chord algorithm. In Chord (and in the algorithm described here), nodes are arranged in a ring, with node n being adjacent to nodes n-1 and n+1 and with all arithmetic being done modulo 2^{k}, where k is the length of the Node-ID in bits, so that node 2^{k} - 1 is directly before node 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里描述的算法CHORD-RELOAD是CHORD算法的修改版本。在Chord中（以及在这里描述的算法中），节点被安排在一个环中，节点n与节点n-1和n+1相邻，并且所有的算法都是以模2^{k}进行的，其中k是以位为单位的节点ID的长度，因此节点2^{k}-1直接位于节点0之前。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each peer keeps track of a Finger Table and a Neighbor Table. The Neighbor Table contains at least the three peers before and after this peer in the DHT ring. There may not be three entries in all cases, such as small rings or while the ring topology is changing. The first entry in the Finger Table contains the peer halfway around the ring from this peer, the second entry contains the peer that is 1/4th of the way around, the third entry contains the peer that is 1/8th of the way around, and so on. Fundamentally, the Chord DHT can be thought of as a doubly linked list formed by knowing the successors and predecessor peers in the Neighbor Table, sorted by the Node-ID. As long as the successor peers are correct, the DHT will return the correct result. The pointers to the prior peers are kept to enable the insertion of new peers into the list structure. Keeping multiple predecessor and successor pointers makes it possible to maintain the integrity of the data structure even when consecutive peers simultaneously fail. The Finger Table forms a skip list [wikiSkiplist] so that entries in the linked list can be found in O(log(N)) time instead of the typical O(N) time that a linked list would provide, where N represents the number of nodes in the DHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个对等点跟踪一个手指表和一个邻居表。邻居表至少包含DHT环中该对等点前后的三个对等点。并非所有情况下都有三个条目，例如小环或环拓扑发生变化时。Finger表中的第一个条目包含环的中间位置，第二个条目包含环的四分之一，第三个条目包含环的八分之一，依此类推。从根本上说，Chord DHT可以被认为是一个双链表，由邻居表中的后继和前继对等点组成，按节点ID排序。只要后继对等点正确，DHT将返回正确的结果。保留指向先前对等点的指针，以便将新对等点插入列表结构。保留多个前置指针和后续指针，即使在连续的对等点同时发生故障时，也可以保持数据结构的完整性。Finger表形成一个跳过列表[wikiSkiplist]，因此可以在O（log（N））时间内找到链表中的条目，而不是链表提供的典型O（N）时间，其中N表示DHT中的节点数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Neighbor Table and Finger Table entries contain logical Node-IDs as values, but the actual mapping of an IP level addressing information to reach that Node-ID is kept in the Connection Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居表和手指表条目包含逻辑节点ID作为值，但IP级别寻址信息到该节点ID的实际映射保留在连接表中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer, x, is responsible for a particular Resource-ID, k, if k is less than or equal to x and k is greater than p, where p is the Node-ID of the previous peer in the Neighbor Table. Care must be taken when computing to note that all math is modulo 2^128.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果k小于或等于x且k大于p，则对等方x负责特定资源ID k，其中p是邻居表中前一个对等方的节点ID。计算时必须注意，所有数学都是模2^128。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Hash Function
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 散列函数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For this Chord-based Topology Plug-in, the size of the Resource-ID is 128 bits. The hash of a Resource-ID MUST be computed using SHA-1 [RFC3174], and then the SHA-1 result MUST be truncated to the most significant 128 bits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于此基于Chord的拓扑插件，资源ID的大小为128位。必须使用SHA-1[RFC3174]计算资源ID的哈希，然后必须将SHA-1结果截断为最高有效128位。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. Routing
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.3. 路由
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Routing Table is conceptually the union of the Neighbor Table and the Finger Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由表在概念上是相邻表和手指表的并集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a peer is not responsible for a Resource-ID k, but is directly connected to a node with Node-ID k, then it MUST route the message to that node. Otherwise, it MUST route the request to the peer in the Routing Table that has the largest Node-ID that is in the interval between the peer and k. If no such node is found, the peer finds the smallest Node-ID that is greater than k and MUST route the message to that node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果对等方不负责资源ID k，而是直接连接到具有节点ID k的节点，则它必须将消息路由到该节点。否则，它必须将请求路由到路由表中具有最大节点ID的对等方，该节点ID在对等方和k之间的间隔内。如果没有找到这样的节点，则对等方会找到大于k的最小节点ID，并且必须将消息路由到该节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. Redundancy
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.4. 冗余
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer receives a Store request for Resource-ID k and it is responsible for Resource-ID k, it MUST store the data and return a success response. It MUST then send a Store request to its successor in the Neighbor Table and to that peer&#39;s successor, incrementing the replica number for each successor. Note that these Store requests are addressed to those specific peers, even though the Resource-ID they are being asked to store is outside the range that they are responsible for. The peers receiving these SHOULD check that they came from an appropriate predecessor in their Neighbor Table and that they are in a range that this predecessor is responsible for. Then, they MUST store the data. They do not themselves perform further Stores, because they can determine that they are not responsible for the Resource-ID.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等方收到资源ID k的存储请求并负责资源ID k时，它必须存储数据并返回成功响应。然后，它必须将存储请求发送给邻居表中的其后继者和该对等方的后继者，并增加每个后继者的副本号。请注意，这些存储请求是针对那些特定的对等方的，即使请求它们存储的资源ID超出了它们负责的范围。接收这些信息的对等方应该检查它们是否来自其邻居表中的适当前置，并且它们是否在该前置负责的范围内。然后，他们必须存储数据。它们自己不执行进一步的存储，因为它们可以确定它们不负责资源ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that this Topology Plug-in does not use the replica number for purposes other than knowing the difference between a replica and a non-replica.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，此拓扑插件不将副本编号用于了解副本和非副本之间的差异之外的目的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Managing replicas as the overlay changes is described in Section 10.7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第10.7.3节描述了在覆盖更改时管理副本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The sequential replicas used in this overlay algorithm protect against peer failure but not against malicious peers. Additional replication from the Usage is required to protect resources from such attacks, as discussed in Section 13.5.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此覆盖算法中使用的顺序副本可防止对等失败，但不能防止恶意对等。如第13.5.4节所述，需要使用额外的复制来保护资源免受此类攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. Joining
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.5. 连接
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The join process for a Joining Node (JN) with Node-ID n is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点ID为n的加入节点（JN）的加入过程如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. JN MUST connect to its chosen bootstrap node, as specified in Section 11.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. JN必须连接到其选择的引导节点，如第11.4节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. JN SHOULD send an Attach request to the Admitting Peer (AP) for Resource-ID n+1. The &#34;send_update&#34; flag can be used to acquire the Routing Table of AP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. JN应该向资源ID为n+1的接纳对等方（AP）发送附加请求。“发送\更新”标志可用于获取AP的路由表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. JN SHOULD send Attach requests to initiate connections to each of the peers in the Neighbor Table as well as to the desired peers in the Finger Table. Note that this does not populate their Routing Tables, but only their Connection Tables, so JN will not get messages that it is expected to route to other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. JN应该发送附加请求，以启动到邻居表中每个对等方以及Finger表中所需对等方的连接。请注意，这不会填充它们的路由表，而只填充它们的连接表，因此JN不会获得预期路由到其他节点的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. JN MUST enter into its Routing Table all the peers that it has successfully contacted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. JN必须在其路由表中输入它已成功联系的所有对等方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JN MUST send a Join to AP. The AP MUST send the response to the Join.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. JN必须向AP发送加入。AP必须向加入发送响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. AP MUST do a series of Store requests to JN to store the data that JN will be responsible for.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. AP必须向JN发出一系列存储请求，以存储JN将负责的数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. AP MUST send JN an Update explicitly labeling JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP MAY now forget any data which is assigned to JN and not AP. AP SHOULD NOT forget any data where AP is the replica set for the data.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. AP必须向JN发送一个明确标记JN为其前身的更新。此时，JN是环的一部分，负责覆盖的一部分。AP现在可能会忘记分配给JN而不是AP的任何数据。AP不应忘记AP是数据副本集的任何数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. The AP MUST send an Update to all of its neighbors (including JN) with the new values of its neighbor set (including JN).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. AP必须使用其邻居集（包括JN）的新值向其所有邻居（包括JN）发送更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. JN MUST send Updates to all of the peers in its Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. JN必须向其邻居表中的所有对等方发送更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If JN sends an Attach to AP with send_update, it immediately knows most of its expected neighbors from AP&#39;s Routing Table update and MAY directly connect to them. This is the RECOMMENDED procedure.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果JN使用send_update向AP发送一个Attach，它会立即从AP的路由表更新中知道它的大多数预期邻居，并可以直接连接到它们。这是推荐的程序。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If for some reason JN does not get AP&#39;s Routing Table, it MAY still populate its Neighbor Table incrementally. It SHOULD send a Ping directed at Resource-ID n+1 (directly after its own Resource-ID). This allows JN to discover its own successor. Call that node p0. JN then SHOULD send a Ping to p0+1 to discover its successor (p1). This process MAY be repeated to discover as many successors as desired. The values for the two peers before p will be found at a later stage, when n receives an Update. An alternate procedure is to send Attaches to those nodes rather than Pings, which form the connections immediately, but may be slower if the nodes need to collect ICE candidates.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
若由于某种原因JN并没有得到AP的路由表，它仍然可以增量地填充它的邻居表。它应该发送一个指向资源ID n+1的Ping（直接在它自己的资源ID之后）。这允许JN发现自己的继承者。称那个节点为p0。然后JN应该向p0+1发送一个Ping以发现它的后继者（p1）。可以重复此过程，以根据需要发现尽可能多的继任者。p之前的两个对等方的值将在稍后阶段，当n收到更新时找到。另一种方法是向这些节点发送连接，而不是ping，ping会立即形成连接，但如果节点需要收集候选ICE，则可能会较慢。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to set up its i&#39;th Finger Table entry, JN MUST send an Attach to peer n+2^(128-i). This will be routed to a peer in approximately the right location around the ring. (Note that the first entry in the Finger Table has i=1 and not i=0 in this formulation.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了设置其第i个Finger表条目，JN必须向对等方n+2^（128-i）发送附加。这将路由到环周围大约正确位置的对等方。（请注意，在此公式中，Finger表中的第一个条目的i=1，而不是i=0。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Joining Node MUST NOT send any Update message placing itself in the overlay until it has successfully completed an Attach with each peer that should be in its Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加入节点必须在成功完成与应位于其邻居表中的每个对等节点的连接后，才能发送任何将自身置于覆盖中的更新消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. Routing Attaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.6. 路由连接
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer needs to Attach to a new peer in its Neighbor Table, it MUST source-route the Attach request through the peer from which it learned the new peer&#39;s Node-ID. Source-routing these requests allows the overlay to recover from instability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当一个对等方需要连接到其邻居表中的新对等方时，它必须通过从中了解新对等方的节点ID的对等方对连接请求进行源路由。源路由这些请求允许覆盖从不稳定状态中恢复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All other Attach requests, such as those for new Finger Table entries, are routed conventionally through the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有其他附加请求，例如新的手指表条目的附加请求，按照惯例通过覆盖路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7. 更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Update for this DHT is defined as:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此DHT的更新定义为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidChordUpdateType(0),
               peer_ready(1), neighbors(2), full(3), (255) }
             ChordUpdateType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        enum { invalidChordUpdateType(0),
               peer_ready(1), neighbors(2), full(3), (255) }
             ChordUpdateType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
           uint32                 uptime;
           ChordUpdateType        type;
           select (type){
            case peer_ready:                   /* Empty */
              ;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        struct {
           uint32                 uptime;
           ChordUpdateType        type;
           select (type){
            case peer_ready:                   /* Empty */
              ;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case neighbors:
              NodeId              predecessors&lt;0..2^16-1&gt;;
              NodeId              successors&lt;0..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case neighbors:
              NodeId              predecessors&lt;0..2^16-1&gt;;
              NodeId              successors&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case full:
              NodeId              predecessors&lt;0..2^16-1&gt;;
              NodeId              successors&lt;0..2^16-1&gt;;
              NodeId              fingers&lt;0..2^16-1&gt;;
          };
        } ChordUpdate;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            case full:
              NodeId              predecessors&lt;0..2^16-1&gt;;
              NodeId              successors&lt;0..2^16-1&gt;;
              NodeId              fingers&lt;0..2^16-1&gt;;
          };
        } ChordUpdate;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;uptime&#34; field contains the time this peer has been up in seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“正常运行时间”字段包含该对等机已启动的时间（以秒为单位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;type&#34; field contains the type of the update, which depends on the reason the update was sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“类型”字段包含更新的类型，这取决于发送更新的原因。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer_ready This peer is ready to receive messages. This message is used to indicate that a node which has Attached is a peer and can be routed through. It is also used as a connectivity check to non-neighbor peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
peer\u ready此对等方已准备好接收消息。此消息用于指示已连接的节点是对等节点，可以通过该节点进行路由。它还用作对非邻居对等点的连接检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
neighbors This version is sent to members of the Chord Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
邻居此版本发送给Chord Neighbor表的成员。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
full This version is sent to peers which request an Update with a RouteQueryReq.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
完整此版本发送给请求使用RouteQueryReq更新的对等方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is of type &#34;neighbors&#34;, then the contents of the message will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果消息类型为“邻居”，则消息内容将为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
predecessors The predecessor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前置机更新对等机的前置机集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
successors The successor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
继任者更新对等方的继任者集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the message is of type &#34;full&#34;, then the contents of the message will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果信息类型为“full”，则信息内容为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
predecessors The predecessor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前置机更新对等机的前置机集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
successors The successor set of the Updating peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
继任者更新对等方的继任者集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
fingers The Finger Table of the Updating peer, in numerically ascending order.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
按数字升序指向更新对等方的手指表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST maintain an association (via Attach) to every member of its neighbor set. A peer MUST attempt to maintain at least three predecessors and three successors, even though this will not be possible if the ring is very small. It is RECOMMENDED that O(log(N)) predecessors and successors be maintained in the neighbor set. There are many ways to estimate N, some of which are discussed in [DHT-RELOAD].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方必须维护与其相邻集的每个成员的关联（通过附加）。一个对等方必须尝试保持至少三个前辈和三个后辈，即使这在环非常小的情况下是不可能的。建议在相邻集合中维护O（log（N））前辈和后辈。估算N有很多方法，其中一些方法在[DHT-RELOAD]中讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.1. Handling Neighbor Failures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.1. 处理邻居故障
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Every time a connection to a peer in the Neighbor Table is lost (as determined by connectivity pings or the failure of some request), the peer MUST remove the entry from its Neighbor Table and replace it with the best match it has from the other peers in its Routing Table. If using reactive recovery, the peer MUST send an immediate Update to all nodes in its Neighbor Table. The update will contain all the Node-IDs of the current entries of the table (after the failed one has been removed). Note that when replacing a successor, the peer SHOULD delay the creation of new replicas for the successor replacement hold-down time (30 seconds) after removing the failed entry from its Neighbor Table in order to allow a triggered update to inform it of a better match for its Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每当与邻居表中的对等方的连接丢失时（由连接ping或某个请求的失败确定），该对等方必须从其邻居表中删除该项，并将其替换为其路由表中其他对等方的最佳匹配项。如果使用反应式恢复，对等方必须立即向其邻居表中的所有节点发送更新。更新将包含表的当前条目的所有节点ID（在删除失败的条目之后）。请注意，在替换后继表时，对等方应在从其相邻表中删除失败条目后，延迟为后继表替换保留时间（30秒）创建新副本，以便允许触发的更新通知其更好地匹配其相邻表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the neighbor failure affects the peer&#39;s range of responsible IDs, then the Update MUST be sent to all nodes in its Connection Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果邻居故障影响对等方的责任ID范围，则必须将更新发送到其连接表中的所有节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MAY attempt to reestablish connectivity with a lost neighbor either by waiting additional time to see if connectivity returns or by actively routing a new Attach to the lost peer. Details for these procedures are beyond the scope of this document. In the case of an attempt to reestablish connectivity with a lost neighbor, the peer MUST be removed from the Neighbor Table. Such a peer is returned to the Neighbor Table once connectivity is reestablished.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方可以尝试通过等待额外的时间来查看连接是否恢复，或者通过主动将新连接路由到丢失的对等方，来重新建立与丢失的邻居的连接。这些程序的详细信息超出了本文件的范围。在尝试与丢失的邻居重新建立连接的情况下，必须从邻居表中删除对等方。一旦重新建立连接，这样的对等点将返回到邻居表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If connectivity is lost to all successor peers in the Neighbor Table, then this peer SHOULD behave as if it is joining the network and MUST use Pings to find a peer and send it a Join. If connectivity is lost to all the peers in the Finger Table, this peer SHOULD assume that it has been disconnected from the rest of the network, and it SHOULD periodically try to join the DHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果与邻居表中所有后续对等方的连接丢失，则该对等方的行为应与加入网络一样，并且必须使用ping来查找对等方并向其发送加入。如果Finger表中的所有对等方都失去了连接，则该对等方应假定已断开与网络其余部分的连接，并应定期尝试加入DHT。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.2. Handling Finger Table Entry Failure
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.2. 处理手指表条目失败
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a Finger Table entry is found to have failed (as determined by connectivity pings or the failure of some request), all references to the failed peer MUST be removed from the Finger Table and replaced with the closest preceding peer from the Finger Table or Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果发现Finger表条目失败（由连接ping或某些请求失败确定），则必须从Finger表中删除对失败对等方的所有引用，并用Finger表或邻居表中最近的前一个对等方替换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If using reactive recovery, the peer MUST initiate a search for a new Finger Table entry, as described below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用反应式恢复，对等方必须开始搜索新的Finger表条目，如下所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.3. Receiving Updates
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.3. 接收更新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer x receives an Update request, it examines the Node-IDs in the UpdateReq and at its Neighbor Table and decides if this UpdateReq would change its Neighbor Table. This is done by taking the set of peers currently in the Neighbor Table and comparing them to the peers in the Update request. There are two major cases:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等x收到更新请求时，它会检查UpdateReq及其邻居表中的节点ID，并决定此UpdateReq是否会更改其邻居表。这是通过获取邻居表中当前的对等点集并将其与更新请求中的对等点进行比较来实现的。主要有两种情况：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The UpdateReq contains peers that match x&#39;s Neighbor Table, so no change is needed to the neighbor set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o UpdateReq包含与x的邻居表匹配的对等点，因此不需要更改邻居集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The UpdateReq contains peers that x does not know about that should be in x&#39;s Neighbor Table; i.e., they are closer than entries in the Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o UpdateReq包含x不知道的对等点，这些对等点应该在x的邻居表中；i、 例如，它们比邻居表中的条目更接近。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the first case, no change is needed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第一种情况下，不需要改变。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the second case, x MUST attempt to Attach to the new peers, and if it is successful, it MUST adjust its neighbor set accordingly. Note that x can maintain the now inferior peers as neighbors, but it MUST remember the closer ones.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在第二种情况下，x必须尝试连接到新的对等点，如果成功，它必须相应地调整其邻居集。请注意，x可以将现在较差的对等点保持为邻居，但它必须记住较近的对等点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After any Pings and Attaches are done, if the Neighbor Table changes and the peer is using reactive recovery, the peer MUST send an Update request to each member of its Connection Table. These Update requests are what end up filling in the predecessor/successor tables of peers that this peer is a neighbor to. A peer MUST NOT enter itself in its successor or predecessor table and instead should leave the entries empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在完成任何ping和连接后，如果邻居表发生更改并且对等方正在使用反应式恢复，则对等方必须向其连接表的每个成员发送更新请求。这些更新请求最终会填充该对等方是其邻居的对等方的前置/后续表。对等方不能在其后继表或前置表中输入自己，而应将条目留空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If peer x is responsible for a Resource-ID R and x discovers that the replica set for R (the next two nodes in its successor set) has changed, it MUST send a Store for any data associated with R to any new node in the replica set. It SHOULD NOT delete data from peers which have left the replica set.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果对等方x负责资源ID R，并且x发现R的副本集（其后续集中的下两个节点）已更改，则它必须将与R关联的任何数据的存储发送到副本集中的任何新节点。它不应从离开复制集的对等方删除数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When peer x detects that it is no longer in the replica set for a resource R (i.e., there are three predecessors between x and R), it SHOULD delete all data associated with R from its local store.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等方x检测到它不再位于资源R的副本集中时（即，x和R之间有三个前辈），它应该从其本地存储中删除与R关联的所有数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a peer discovers that its range of responsible IDs has changed, it MUST send an Update to all entries in its Connection Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当对等方发现其负责ID的范围已更改时，它必须向其连接表中的所有条目发送更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4. Stabilization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4. 稳定
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are four components to stabilization:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
稳定有四个组成部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Exchange Updates with all peers in its Neighbor Table to exchange state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Exchange将其邻居表中的所有对等方更新为Exchange状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Search for better peers to place in its Finger Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 寻找更好的同伴，将其放在手指桌上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Search to determine if the current Finger Table size is sufficiently large.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 搜索以确定当前手指表大小是否足够大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Search to determine if the overlay has partitioned and needs to recover.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 搜索以确定覆盖是否已分区并需要恢复。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.1. Updating the Neighbor Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.1. 更新邻居表
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST periodically send an Update request to every peer in its Neighbor Table. The purpose of this is to keep the predecessor and successor lists up to date and to detect failed peers. The default time is about every ten minutes, but the configuration server SHOULD set this in the Configuration Document using the &#34;chord-update-interval&#34; element (denominated in seconds). A peer SHOULD randomly offset these Update requests so they do not occur all at once.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方必须定期向其邻居表中的每个对等方发送更新请求。这样做的目的是使前置机和后续机列表保持最新，并检测失败的对等机。默认时间大约为每十分钟一次，但配置服务器应在配置文档中使用“chord update interval”元素（以秒为单位）设置此时间。对等方应随机抵消这些更新请求，以便它们不会同时发生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.2. Refreshing the Finger Table
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.2. 刷新手指桌
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MUST periodically search for new peers to replace invalid entries in the Finger Table. For peer x, the i&#39;th Finger Table entry is valid if it is in the range [ x+2^( 128-i ), x+2^( 128-(i-1) )-1 ]. Invalid entries occur in the Finger Table when a previous Finger Table entry has failed or when no peer has been found in that range.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方必须定期搜索新的对等方以替换Finger表中的无效条目。对于对等x，如果第i个Finger表条目在[x+2^（128-i）、x+2^（128-i））-1]范围内，则该条目有效。当上一个Finger表条目失败或在该范围内未找到对等项时，Finger表中会出现无效条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Two possible methods for searching for new peers for the Finger Table entries are presented:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
提供了两种可能的方法来搜索手指表条目的新对等点：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternative 1: A peer selects one entry in the Finger Table from among the invalid entries. It pings for a new peer for that Finger Table entry. The selection SHOULD be exponentially weighted to attempt to replace earlier (lower i) entries in the Finger Table. A simple way to implement this selection is to search through the Finger Table entries from i=1, and each time an invalid entry is encountered, send a Ping to replace that entry with probability 0.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
备选方案1：对等方从无效条目中选择Finger表中的一个条目。它为该Finger表条目ping一个新的对等方。选择应按指数加权，以尝试替换Finger表中较早的（较低的i）项。实现此选择的一种简单方法是从i=1搜索Finger表条目，每次遇到无效条目时，发送Ping以概率0.5替换该条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Alternative 2: A peer monitors the Update messages received from its connections to observe when an Update indicates a peer that would be used to replace an invalid Finger Table entry, i, and flags that entry in the Finger Table. Every &#34;chord-ping-interval&#34; seconds, the peer selects from among those flagged candidates using an exponentially weighted probability, as above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
备选方案2：对等方监视从其连接接收的更新消息，以观察更新何时指示将用于替换无效Finger表条目i的对等方，并在Finger表中标记该条目。每“和弦ping间隔”秒，对等方使用指数加权概率从这些标记的候选对象中进行选择，如上所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When searching for a better entry, the peer SHOULD send the Ping to a Node-ID selected randomly from that range. Random selection is preferred over a search for strictly spaced entries to minimize the effect of churn on overlay routing [minimizing-churn-sigcomm06]. An implementation or subsequent specification MAY choose a method for selecting Finger Table entries other than choosing randomly within the range. Any such alternate methods SHOULD be employed only on Finger Table stabilization and not for the selection of initial Finger Table entries unless the alternative method is faster and imposes less overhead on the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当搜索更好的条目时，对等方应该向从该范围随机选择的节点ID发送Ping。随机选择优先于搜索严格间隔的条目，以最大限度地减少搅动对覆盖路由的影响[minimination-chorn-sigcomm06]。实现或后续规范可以选择用于选择手指表条目的方法，而不是在范围内随机选择。任何此类替代方法应仅用于手指表稳定，而不用于选择初始手指表条目，除非替代方法速度更快且对覆盖施加的开销更少。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer SHOULD NOT send Ping requests looking for new finger table entries more often than the configuration element &#34;chord-ping-interval&#34;, which defaults to 3600 seconds (one per hour).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方发送Ping请求寻找新的finger表条目的频率不应超过配置元素“chord Ping interval”，该元素默认为3600秒（每小时一次）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A peer MAY choose to keep connections to multiple peers that can act for a given Finger Table entry.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对等方可以选择保持与多个对等方的连接，这些对等方可以为给定的手指表条目执行操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.3. Adjusting Finger Table Size
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.3. 调整手指表大小
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Finger Table has fewer than 16 entries, the node SHOULD attempt to discover more fingers to grow the size of the table to 16. The value 16 was chosen to ensure high odds of a node maintaining connectivity to the overlay even with strange network partitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果Finger表的条目少于16个，则节点应尝试发现更多的Finger以将表的大小增加到16个。选择值16是为了确保即使使用奇怪的网络分区，节点仍很有可能保持与覆盖的连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For many overlays, 16 Finger Table entries will be enough, but as an overlay grows very large, more than 16 entries may be required in the Finger Table for efficient routing. An implementation SHOULD be capable of increasing the number of entries in the Finger Table to 128 entries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于许多覆盖，16个Finger表条目就足够了，但是随着覆盖变得非常大，Finger表中可能需要超过16个条目才能进行高效路由。一个实现应该能够将Finger表中的条目数增加到128个条目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although log(N) entries are all that are required for optimal performance, careful implementation of stabilization will result in no additional traffic being generated when maintaining a Finger Table larger than log(N) entries. Implementers are encouraged to make use of RouteQuery and algorithms for determining where new Finger Table entries may be found. Complete details of possible implementations are outside the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管日志（N）项是实现最佳性能所需的全部，但在维护大于日志（N）项的指形表时，小心地实施稳定化将不会产生额外的通信量。鼓励实现者使用RouteQuery和算法来确定在何处可以找到新的手指表条目。可能实现的完整细节不在本规范的范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A simple approach to sizing the Finger Table is to ensure that the Finger Table is large enough to contain at least the final successor in the peer&#39;s Neighbor Table.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
调整Finger表大小的一种简单方法是确保Finger表足够大，以便在对等方的邻居表中至少包含最后一个后续表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.4. Detecting Partitioning
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.7.4.4. 检测分区
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To detect that a partitioning has occurred and to heal the overlay, a peer P MUST periodically repeat the discovery process used in the initial join for the overlay to locate an appropriate bootstrap node, B. P SHOULD then send a Ping for its own Node-ID routed through B. If a response is received from peer S&#39;, which is not P&#39;s successor, then the overlay is partitioned and P SHOULD send an Attach to S&#39; routed through B, followed by an Update sent to S&#39;. (Note that S&#39; may not be in P&#39;s Neighbor Table once the overlay is healed, but the connection will allow S&#39; to discover appropriate neighbor entries for itself via its own stabilization.)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了检测已发生分区并修复覆盖，对等P必须定期重复覆盖的初始连接中使用的发现过程，以定位适当的引导节点，B.P然后应发送通过B路由的其自身节点ID的Ping。如果从不是P的后续节点的对等S&#39;收到响应，然后对覆盖进行分区，P应通过B向S&#39;发送附加，然后向S&#39;发送更新。（请注意，一旦覆盖修复，S&#39;可能不在P的邻居表中，但连接将允许S&#39;通过其自身的稳定性为自己发现适当的邻居条目。）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Future specifications may describe alternative mechanisms for determining when to repeat the discovery process.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未来的规范可能描述用于确定何时重复发现过程的替代机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. Route Query f.in 3
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.8. 路由查询f.in 3
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
For CHORD-RELOAD, the RouteQueryReq contains no additional information. The RouteQueryAns contains the single Node-ID of the next peer to which the responding peer would have routed the request message in recursive routing:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
对于CHORD-RELOAD，RouteQueryReq不包含其他信息。RouteQueryAns包含下一个对等方的单个节点ID，响应对等方将在递归路由中将请求消息路由到该对等方：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      struct {
         NodeId                  next_peer;
      } ChordRouteQueryAns;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      struct {
         NodeId                  next_peer;
      } ChordRouteQueryAns;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The contents of this structure are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该结构的内容如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
next_peer The peer to which the responding peer would route the message in order to deliver it to the destination listed in the request.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下一个\u peer响应对等方将消息路由到的对等方，以便将消息传递到请求中列出的目的地。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the requester has set the send_update flag, the responder SHOULD initiate an Update immediately after sending the RouteQueryAns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果请求者设置了send_update标志，响应者应在发送RouteQueryAns后立即启动更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. Leaving
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.9. 离开
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To support extensions, such as [DHT-RELOAD], peers SHOULD send a Leave request to all members of their Neighbor Table before exiting the Overlay Instance. The overlay_specific_data field MUST contain the ChordLeaveData structure, defined below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了支持扩展，例如[DHT-RELOAD]，对等方应该在退出覆盖实例之前向其邻居表的所有成员发送一个离开请求。覆盖特定数据字段必须包含ChordLeaveData结构，定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              enum { invalidChordLeaveType(0),
                      from_succ(1), from_pred(2), (255) }
                    ChordLeaveType;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              enum { invalidChordLeaveType(0),
                      from_succ(1), from_pred(2), (255) }
                    ChordLeaveType;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               struct {
                 ChordLeaveType         type;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
               struct {
                 ChordLeaveType         type;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  select (type) {
                    case from_succ:
                      NodeId            successors&lt;0..2^16-1&gt;;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  select (type) {
                    case from_succ:
                      NodeId            successors&lt;0..2^16-1&gt;;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                    case from_pred:
                      NodeId           predecessors&lt;0..2^16-1&gt;;
                  };
               } ChordLeaveData;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                    case from_pred:
                      NodeId           predecessors&lt;0..2^16-1&gt;;
                  };
               } ChordLeaveData;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The &#34;type&#34; field indicates whether the Leave request was sent by a predecessor or a successor of the recipient:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
“类型”字段表示休假请求是由收件人的前任还是继任者发送的：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
from_succ The Leave request was sent by a successor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从_succ，请假请求由继任者发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
from_pred The Leave request was sent by a predecessor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
从_pred，请假请求由前任发送。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the type of the request is &#34;from_succ&#34;, the contents will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果请求类型为“from_succ”，则内容将为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
successors The sender&#39;s successor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
继任者发件人的继任者列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the type of the request is &#34;from_pred&#34;, the contents will be:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果请求类型为“from_pred”，则内容将为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
predecessors The sender&#39;s predecessor list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
前置发件人的前置发件人列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Any peer which receives a Leave for a peer n in its neighbor set MUST follow procedures as if it had detected a peer failure as described in Section 10.7.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
任何为其邻居集中的对等方n获得许可的对等方必须按照第10.7.1节中所述的检测到对等方故障的程序进行操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. Enrollment and Bootstrap
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11. 注册和引导
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The section defines the format of the configuration data as well the process to join a new overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节定义了配置数据的格式以及加入新覆盖的过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. Overlay Configuration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1. 覆盖配置
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a new content type &#34;application/p2p-overlay+xml&#34; for a MIME entity that contains overlay information. An example document is shown below:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该规范为包含覆盖信息的MIME实体定义了一个新的内容类型“application/p2p overlay+xml”。示例文档如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
   &lt;overlay xmlns=&#34;urn:ietf:params:xml:ns:p2p:config-base&#34;
      xmlns:ext=&#34;urn:ietf:params:xml:ns:p2p:config-ext1&#34;
      xmlns:chord=&#34;urn:ietf:params:xml:ns:p2p:config-chord&#34;&gt;
      &lt;configuration instance-name=&#34;overlay.example.org&#34; sequence=&#34;22&#34;
          expiration=&#34;2002-10-10T07:00:00Z&#34; ext:ext-example=&#34;stuff&#34; &gt;
          &lt;topology-plugin&gt; CHORD-RELOAD &lt;/topology-plugin&gt;
          &lt;node-id-length&gt;16&lt;/node-id-length&gt;
          &lt;root-cert&gt;
   MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET
   MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT
   BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0
   eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT
   MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   &lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
   &lt;overlay xmlns=&#34;urn:ietf:params:xml:ns:p2p:config-base&#34;
      xmlns:ext=&#34;urn:ietf:params:xml:ns:p2p:config-ext1&#34;
      xmlns:chord=&#34;urn:ietf:params:xml:ns:p2p:config-chord&#34;&gt;
      &lt;configuration instance-name=&#34;overlay.example.org&#34; sequence=&#34;22&#34;
          expiration=&#34;2002-10-10T07:00:00Z&#34; ext:ext-example=&#34;stuff&#34; &gt;
          &lt;topology-plugin&gt; CHORD-RELOAD &lt;/topology-plugin&gt;
          &lt;node-id-length&gt;16&lt;/node-id-length&gt;
          &lt;root-cert&gt;
   MIIDJDCCAo2gAwIBAgIBADANBgkqhkiG9w0BAQUFADBwMQswCQYDVQQGEwJVUzET
   MBEGA1UECBMKQ2FsaWZvcm5pYTERMA8GA1UEBxMIU2FuIEpvc2UxDjAMBgNVBAoT
   BXNpcGl0MSkwJwYDVQQLEyBTaXBpdCBUZXN0IENlcnRpZmljYXRlIEF1dGhvcml0
   eTAeFw0wMzA3MTgxMjIxNTJaFw0xMzA3MTUxMjIxNTJaMHAxCzAJBgNVBAYTAlVT
   MRMwEQYDVQQIEwpDYWxpZm9ybmlhMREwDwYDVQQHEwhTYW4gSm9zZTEOMAwGA1UE
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y
   aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud
   +nJ4xrCVGKfgjHm6XaSuHiEtnfELHM+9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4
   N3viCicwcN35LgP/KnbN34cavXHr4ZlqxH+OdKB3hQTpQa38A7YXdaoz6goW2ft5
   Mi74z03GNKP/G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU
   bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0
   pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT
   CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD
   ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B
   AQUFAAOBgQCWbRvv1ZGTRXxbH8/EqkdSCzSoUPrs+rQqR0xdQac9wNY/nlZbkR3O
   qAezG6Sfmklvf+DOg5RxQq/+Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ
   QgUf4cKBiF+65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg==
          &lt;/root-cert&gt;
          &lt;root-cert&gt; YmFkIGNlcnQK &lt;/root-cert&gt;
          &lt;enrollment-server&gt;https://example.org&lt;/enrollment-server&gt;
          &lt;enrollment-server&gt;https://example.net&lt;/enrollment-server&gt;
          &lt;self-signed-permitted
                    digest=&#34;sha1&#34;&gt;false&lt;/self-signed-permitted&gt;
          &lt;bootstrap-node address=&#34;192.0.0.1&#34; port=&#34;6084&#34; /&gt;
          &lt;bootstrap-node address=&#34;192.0.2.2&#34; port=&#34;6084&#34; /&gt;
          &lt;bootstrap-node address=&#34;2001:DB8::1&#34; port=&#34;6084&#34; /&gt;
          &lt;turn-density&gt; 20 &lt;/turn-density&gt;
          &lt;clients-permitted&gt; false &lt;/clients-permitted&gt;
          &lt;no-ice&gt; false &lt;/no-ice&gt;
          &lt;chord:chord-update-interval&gt;
              400&lt;/chord:chord-update-interval&gt;
          &lt;chord:chord-ping-interval&gt;30&lt;/chord:chord-ping-interval&gt;
          &lt;chord:chord-reactive&gt; true &lt;/chord:chord-reactive&gt;
          &lt;shared-secret&gt; password &lt;/shared-secret&gt;
          &lt;max-message-size&gt;4000&lt;/max-message-size&gt;
          &lt;initial-ttl&gt; 30 &lt;/initial-ttl&gt;
          &lt;overlay-reliability-timer&gt; 3000 &lt;/overlay-reliability-timer&gt;
          &lt;overlay-link-protocol&gt;TLS&lt;/overlay-link-protocol&gt;
          &lt;configuration-signer&gt;47112162e84c69ba&lt;/configuration-signer&gt;
          &lt;kind-signer&gt; 47112162e84c69ba &lt;/kind-signer&gt;
          &lt;kind-signer&gt; 6eba45d31a900c06 &lt;/kind-signer&gt;
          &lt;bad-node&gt; 6ebc45d31a900c06 &lt;/bad-node&gt;
          &lt;bad-node&gt; 6ebc45d31a900ca6 &lt;/bad-node&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   ChMFc2lwaXQxKTAnBgNVBAsTIFNpcGl0IFRlc3QgQ2VydGlmaWNhdGUgQXV0aG9y
   aXR5MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDIh6DkcUDLDyK9BEUxkud
   +nJ4xrCVGKfgjHm6XaSuHiEtnfELHM+9WymzkBNzZpJu30yzsxwfKoIKugdNUrD4
   N3viCicwcN35LgP/KnbN34cavXHr4ZlqxH+OdKB3hQTpQa38A7YXdaoz6goW2ft5
   Mi74z03GNKP/G9BoKOGd5QIDAQABo4HNMIHKMB0GA1UdDgQWBBRrRhcU6pR2JYBU
   bhNU2qHjVBShtjCBmgYDVR0jBIGSMIGPgBRrRhcU6pR2JYBUbhNU2qHjVBShtqF0
   pHIwcDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExETAPBgNVBAcT
   CFNhbiBKb3NlMQ4wDAYDVQQKEwVzaXBpdDEpMCcGA1UECxMgU2lwaXQgVGVzdCBD
   ZXJ0aWZpY2F0ZSBBdXRob3JpdHmCAQAwDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0B
   AQUFAAOBgQCWbRvv1ZGTRXxbH8/EqkdSCzSoUPrs+rQqR0xdQac9wNY/nlZbkR3O
   qAezG6Sfmklvf+DOg5RxQq/+Y6I03LRepc7KeVDpaplMFGnpfKsibETMipwzayNQ
   QgUf4cKBiF+65Ue7hZuDJa2EMv8qW4twEhGDYclpFU9YozyS1OhvUg==
          &lt;/root-cert&gt;
          &lt;root-cert&gt; YmFkIGNlcnQK &lt;/root-cert&gt;
          &lt;enrollment-server&gt;https://example.org&lt;/enrollment-server&gt;
          &lt;enrollment-server&gt;https://example.net&lt;/enrollment-server&gt;
          &lt;self-signed-permitted
                    digest=&#34;sha1&#34;&gt;false&lt;/self-signed-permitted&gt;
          &lt;bootstrap-node address=&#34;192.0.0.1&#34; port=&#34;6084&#34; /&gt;
          &lt;bootstrap-node address=&#34;192.0.2.2&#34; port=&#34;6084&#34; /&gt;
          &lt;bootstrap-node address=&#34;2001:DB8::1&#34; port=&#34;6084&#34; /&gt;
          &lt;turn-density&gt; 20 &lt;/turn-density&gt;
          &lt;clients-permitted&gt; false &lt;/clients-permitted&gt;
          &lt;no-ice&gt; false &lt;/no-ice&gt;
          &lt;chord:chord-update-interval&gt;
              400&lt;/chord:chord-update-interval&gt;
          &lt;chord:chord-ping-interval&gt;30&lt;/chord:chord-ping-interval&gt;
          &lt;chord:chord-reactive&gt; true &lt;/chord:chord-reactive&gt;
          &lt;shared-secret&gt; password &lt;/shared-secret&gt;
          &lt;max-message-size&gt;4000&lt;/max-message-size&gt;
          &lt;initial-ttl&gt; 30 &lt;/initial-ttl&gt;
          &lt;overlay-reliability-timer&gt; 3000 &lt;/overlay-reliability-timer&gt;
          &lt;overlay-link-protocol&gt;TLS&lt;/overlay-link-protocol&gt;
          &lt;configuration-signer&gt;47112162e84c69ba&lt;/configuration-signer&gt;
          &lt;kind-signer&gt; 47112162e84c69ba &lt;/kind-signer&gt;
          &lt;kind-signer&gt; 6eba45d31a900c06 &lt;/kind-signer&gt;
          &lt;bad-node&gt; 6ebc45d31a900c06 &lt;/bad-node&gt;
          &lt;bad-node&gt; 6ebc45d31a900ca6 &lt;/bad-node&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          &lt;ext:example-extension&gt; foo &lt;/ext:example-extension&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          &lt;ext:example-extension&gt; foo &lt;/ext:example-extension&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          &lt;mandatory-extension&gt;
              urn:ietf:params:xml:ns:p2p:config-ext1
          &lt;/mandatory-extension&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          &lt;mandatory-extension&gt;
              urn:ietf:params:xml:ns:p2p:config-ext1
          &lt;/mandatory-extension&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          &lt;required-kinds&gt;
            &lt;kind-block&gt;
              &lt;kind name=&#34;SIP-REGISTRATION&#34;&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          &lt;required-kinds&gt;
            &lt;kind-block&gt;
              &lt;kind name=&#34;SIP-REGISTRATION&#34;&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  &lt;data-model&gt;SINGLE&lt;/data-model&gt;
                  &lt;access-control&gt;USER-MATCH&lt;/access-control&gt;
                  &lt;max-count&gt;1&lt;/max-count&gt;
                  &lt;max-size&gt;100&lt;/max-size&gt;
              &lt;/kind&gt;
              &lt;kind-signature&gt;
                   VGhpcyBpcyBub3QgcmlnaHQhCg==
              &lt;/kind-signature&gt;
            &lt;/kind-block&gt;
            &lt;kind-block&gt;
              &lt;kind id=&#34;2000&#34;&gt;
                  &lt;data-model&gt;ARRAY&lt;/data-model&gt;
                  &lt;access-control&gt;NODE-MULTIPLE&lt;/access-control&gt;
                  &lt;max-node-multiple&gt;3&lt;/max-node-multiple&gt;
                  &lt;max-count&gt;22&lt;/max-count&gt;
                  &lt;max-size&gt;4&lt;/max-size&gt;
                  &lt;ext:example-kind-extension&gt; 1
                          &lt;/ext:example-kind-extension&gt;
              &lt;/kind&gt;
              &lt;kind-signature&gt;
                 VGhpcyBpcyBub3QgcmlnaHQhCg==
              &lt;/kind-signature&gt;
            &lt;/kind-block&gt;
          &lt;/required-kinds&gt;
      &lt;/configuration&gt;
      &lt;signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/signature&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                  &lt;data-model&gt;SINGLE&lt;/data-model&gt;
                  &lt;access-control&gt;USER-MATCH&lt;/access-control&gt;
                  &lt;max-count&gt;1&lt;/max-count&gt;
                  &lt;max-size&gt;100&lt;/max-size&gt;
              &lt;/kind&gt;
              &lt;kind-signature&gt;
                   VGhpcyBpcyBub3QgcmlnaHQhCg==
              &lt;/kind-signature&gt;
            &lt;/kind-block&gt;
            &lt;kind-block&gt;
              &lt;kind id=&#34;2000&#34;&gt;
                  &lt;data-model&gt;ARRAY&lt;/data-model&gt;
                  &lt;access-control&gt;NODE-MULTIPLE&lt;/access-control&gt;
                  &lt;max-node-multiple&gt;3&lt;/max-node-multiple&gt;
                  &lt;max-count&gt;22&lt;/max-count&gt;
                  &lt;max-size&gt;4&lt;/max-size&gt;
                  &lt;ext:example-kind-extension&gt; 1
                          &lt;/ext:example-kind-extension&gt;
              &lt;/kind&gt;
              &lt;kind-signature&gt;
                 VGhpcyBpcyBub3QgcmlnaHQhCg==
              &lt;/kind-signature&gt;
            &lt;/kind-block&gt;
          &lt;/required-kinds&gt;
      &lt;/configuration&gt;
      &lt;signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/signature&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      &lt;configuration instance-name=&#34;other.example.net&#34;&gt;
      &lt;/configuration&gt;
      &lt;signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/signature&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      &lt;configuration instance-name=&#34;other.example.net&#34;&gt;
      &lt;/configuration&gt;
      &lt;signature&gt; VGhpcyBpcyBub3QgcmlnaHQhCg== &lt;/signature&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    &lt;/overlay&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    &lt;/overlay&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file MUST be a well-formed XML document, and it SHOULD contain an encoding declaration in the XML declaration. The file MUST use the UTF-8 character encoding. The namespaces for the elements defined in this specification are urn:ietf:params:xml:ns:p2p:config-base and urn:ietf:params:xml:ns:p2p:config-chord.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该文件必须是格式良好的XML文档，并且应该在XML声明中包含编码声明。文件必须使用UTF-8字符编码。本规范中定义的元素的名称空间是urn:ietf:params:xml:ns:p2p:config base和urn:ietf:params:xml:ns:p2p:config chord。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that elements or attributes that are defined as type xsd:boolean in the RELAX NG schema (Section 11.1.1) have two lexical representations, &#34;1&#34; or &#34;true&#34; for the concept true, and &#34;0&#34; or &#34;false&#34; for the concept false. Whitespace and case processing follows the rules of [OASIS.relax_ng] and XML Schema Datatypes [W3C.REC-xmlschema-2-20041028].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，在RELAXNG模式（第11.1.1节）中定义为xsd:boolean类型的元素或属性有两种词汇表示形式，概念true为“1”或“true”，概念false为“0”或“false”。空格和大小写处理遵循[OASIS.RELAXNG]和XML模式数据类型[W3C.REC-xmlschema-2-20041028]的规则。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The file MAY contain multiple &#34;configuration&#34; elements, where each one contains the configuration information for a different overlay. Each configuration element MAY be followed by signature elements that provide a signature over the preceding configuration element. Each configuration element has the following attributes:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该文件可能包含多个“配置”元素，其中每个元素都包含不同覆盖的配置信息。每个配置元素后面都可以有签名元素，这些元素在前面的配置元素上提供签名。每个配置元素都具有以下属性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
instance-name The name of the overlay (referred to as &#34;overlay name&#34; in this specification)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实例名称覆盖的名称（在本规范中称为“覆盖名称”）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
expiration Time in the future at which this overlay configuration is no longer valid. The node SHOULD retrieve a new copy of the configuration at a randomly selected time that is before the expiration time. Note that if the certificates expire before a new configuration is retried, the node will not be able to validate the configuration file. All times MUST conform to the Internet date/time format defined in [RFC3339] and be specified using UTC.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将来此覆盖配置不再有效的过期时间。节点应在到期时间之前随机选择的时间检索配置的新副本。请注意，如果证书在重试新配置之前过期，则节点将无法验证配置文件。所有时间必须符合[RFC3339]中定义的互联网日期/时间格式，并使用UTC指定。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
sequence A monotonically increasing sequence number between 0 and 2^16-2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
序列在0和2^16-2之间单调递增的序列号。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inside each overlay element, the following elements can occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在每个叠加元素内，可以出现以下元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
topology-plug-in This element defines the overlay algorithm being used. If missing, the default is &#34;CHORD-RELOAD&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此元素中的拓扑插件定义所使用的覆盖算法。如果缺少，默认值为“CHORD-RELOAD”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
node-id-length This element contains the length of a NodeId (NodeIdLength), in bytes. This value MUST be between 16 (128 bits) and 20 (160 bits). If this element is not present, the default of 16 is used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点id长度此元素包含节点id（节点id长度）的长度，以字节为单位。此值必须介于16（128位）和20（160位）之间。如果此元素不存在，则使用默认值16。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
root-cert This element contains a base-64-encoded X.509v3 certificate that is a root trust anchor used to sign all certificates in this overlay. There can be more than one root-cert element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根证书此元素包含一个base-64编码的X.509v3证书，它是一个根信任锚，用于对此覆盖中的所有证书进行签名。可以有多个根证书元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
enrollment-server This element contains the URL at which the enrollment server can be reached in a &#34;url&#34; element. This URL MUST be of type &#34;https:&#34;. More than one enrollment-server element MAY be present. Note that there is no necessary relationship between the overlay name/ configuration server name and the enrollment server name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注册服务器此元素包含可在“URL”元素中访问注册服务器的URL。此URL的类型必须为“https:”。可能存在多个注册服务器元素。请注意，覆盖名称/配置服务器名称与注册服务器名称之间没有必要的关系。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
self-signed-permitted This element indicates whether self-signed certificates are permitted. If it is set to &#34;true&#34;, then self-signed certificates are allowed, in which case the enrollment-server and root-cert elements MAY be absent. Otherwise, it SHOULD be absent, but MAY be set to &#34;false&#34;. This element also contains an attribute &#34;digest&#34;, which indicates the digest to be used to compute the Node-ID. Valid values for this parameter are &#34;sha1&#34; and &#34;sha256&#34;, representing SHA-1 [RFC3174] and SHA-256 [RFC6234], respectively. Implementations MUST support both of these algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
允许自签名此元素指示是否允许自签名证书。如果设置为“true”，则允许使用自签名证书，在这种情况下，注册服务器和根证书元素可能不存在。否则，它应该不存在，但可以设置为“false”。此元素还包含一个属性“摘要”，该属性指示用于计算节点ID的摘要。此参数的有效值为“sha1”和“sha256”，分别表示SHA-1[RFC3174]和SHA-256[RFC6234]。实现必须支持这两种算法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bootstrap-node This element represents the address of one of the bootstrap nodes. It has an attribute called &#34;address&#34; that represents the IP address (either IPv4 or IPv6, since they can be distinguished) and an optional attribute called &#34;port&#34; that represents the port and defaults to 6084. The IPv6 address is in typical hexadecimal form using standard period and colon separators as specified in [RFC5952]. More than one bootstrap-node element MAY be present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
引导节点此元素表示其中一个引导节点的地址。它有一个名为“address”的属性，表示IP地址（IPv4或IPv6，因为它们可以区分），还有一个名为“port”的可选属性，表示端口，默认值为6084。IPv6地址是典型的十六进制格式，使用[RFC5952]中指定的标准句点和冒号分隔符。可能存在多个引导节点元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
turn-density This element is a positive integer that represents the approximate reciprocal of density of nodes that can act as TURN servers. For example, if 5% of the nodes can act as TURN servers, this element would be set to 20. If it is not present, the default value is 1. If there are no TURN servers in the overlay, it is set to zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转弯密度此元素是一个正整数，表示可以用作转弯服务器的节点密度的近似倒数。例如，如果5%的节点可以充当TURN服务器，则该元素将设置为20。如果不存在，则默认值为1。如果覆盖中没有回合服务器，则将其设置为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
clients-permitted This element represents whether clients are permitted or whether all nodes must be peers. If clients are permitted, the element MUST be set to &#34;true&#34; or be absent. If the nodes are not allowed to remain clients after the initial join, the element MUST be set to &#34;false&#34;. There is currently no way for the overlay to enforce this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
允许的客户端此元素表示是否允许客户端，或者是否所有节点都必须是对等节点。如果允许客户端，则元素必须设置为“true”或不存在。如果不允许节点在初始联接后保留为客户端，则必须将元素设置为“false”。目前，覆盖层无法强制执行此操作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
no-ice This element represents whether nodes are REQUIRED to use the &#34;No-ICE&#34; Overlay Link protocols in this overlay. If it is absent, it is treated as if it were set to &#34;false&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无ice此元素表示节点是否需要在此覆盖中使用“无ice”覆盖链路协议。如果不存在，则将其视为设置为“false”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord-update-interval The update frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord update interval chord-RELOAD拓扑插件的更新频率（请参见第10节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord-ping-interval The Ping frequency for the CHORD-RELOAD Topology Plug-in (see Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord ping interval chord-RELOAD拓扑插件的ping频率（请参见第10节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord-reactive Whether reactive recovery SHOULD be used for this overlay. It is set to &#34;true&#34; or &#34;false&#34;. If missing, the default is &#34;true&#34; (see Section 10).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
chord reactive是否应对此覆盖使用反应恢复。它被设置为“真”或“假”。如果缺少，默认值为“true”（参见第10节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
shared-secret If shared secret mode is used, this element contains the shared secret. The security guarantee here is that any agent which is able to access the Configuration Document (presumably protected by some sort of HTTP access control or network topology) is able to recover the shared secret and hence join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共享机密如果使用共享机密模式，则此元素包含共享机密。这里的安全保证是，任何能够访问配置文档（可能受某种HTTP访问控制或网络拓扑保护）的代理都能够恢复共享机密，从而加入覆盖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-message-size Maximum size, in bytes, of any message in the overlay. If this value is not present, the default is 5000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大消息大小覆盖中任何消息的最大大小（以字节为单位）。如果此值不存在，则默认值为5000。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
initial-ttl Initial default TTL for messages (see Section 6.3.2). If this value is not present, the default is 100.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
初始ttl消息的初始默认ttl（见第6.3.2节）。如果此值不存在，则默认值为100。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay-reliability-timer Default value for the end-to-end retransmission timer for messages, in milliseconds. If not present, the default value is 3000. The value MUST be at least 200 milliseconds, which means the minimum time delay before dropping a link is 1000 milliseconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖可靠性计时器消息的端到端重传计时器的默认值，以毫秒为单位。如果不存在，则默认值为3000。该值必须至少为200毫秒，这意味着断开链接之前的最小时间延迟为1000毫秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay-link-protocol Indicates a permissible overlay link protocol (see Section 6.6.1 for requirements for such protocols). An arbitrary number of these elements may appear. If none appear, then this implies the default value, &#34;TLS&#34;, which refers to the use of TLS and DTLS. If one or more elements appear, then no default value applies.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖链路协议表示允许的覆盖链路协议（此类协议的要求见第6.6.1节）。可能会出现任意数量的这些元素。如果没有显示，则表示默认值“TLS”，它表示TLS和DTL的使用。如果出现一个或多个元素，则不应用默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign Kinds. Identifying kind-signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类签名者它包含一个十六进制的节点ID，并表示允许具有此节点ID的证书对种类进行签名。通过节点ID而不是证书标识种类签名者，可以使用短期证书，而无需不断提供更新的配置文件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
configuration-signer This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID is allowed to sign configurations for this instance-name. Identifying the signer by Node-ID instead of certificate allows the use of short-lived certificates without constantly having to provide an updated configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置签名者它包含一个十六进制的节点ID，并表示允许具有此节点ID的证书对此实例名称的配置进行签名。通过节点ID而不是证书来标识签名者允许使用短期证书，而无需不断提供更新的配置文件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad-node This contains a single Node-ID in hexadecimal and indicates that the certificate with this Node-ID MUST NOT be considered valid. This allows certificate revocation. An arbitrary number of these elements can be provided. Note that because certificates may expire, bad-node entries need be present only for the lifetime of the certificate. Technically speaking, bad Node-IDs may be reused after their certificates have expired. The requirement for Node-IDs to be pseudorandomly generated gives this event a vanishing probability.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
坏节点此包含一个十六进制的节点ID，表示具有此节点ID的证书不能被视为有效。这允许证书撤销。可以提供任意数量的这些元素。请注意，由于证书可能会过期，因此坏节点条目只需要在证书的生存期内出现。从技术上讲，坏节点ID可以在其证书过期后重新使用。伪随机生成节点ID的要求为该事件提供了消失概率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
mandatory-extension This element contains the name of an XML namespace that a node joining the overlay MUST support. The presence of a mandatory-extension element does not require the extension to be used in the current configuration file, but can indicate that it may be used in the future. Note that the namespace is case-sensitive, as specified in Section 2.3 of [w3c-xml-namespaces]. More than one mandatory-extension element MAY be present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
强制扩展此元素包含加入覆盖的节点必须支持的XML命名空间的名称。强制扩展元素的存在不要求在当前配置文件中使用该扩展，但可以指示将来可能会使用该扩展。请注意，名称空间区分大小写，如[w3c xml名称空间]第2.3节所述。可能存在多个必需的扩展元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Inside each configuration element, the required-kinds element MAY also occur. This element indicates the Kinds that members MUST support and contains multiple kind-block elements that each define a single Kind that MUST be supported by nodes in the overlay. Each kind-block consists of a single kind element and a kind-signature. The kind element defines the Kind. The kind-signature is the signature computed over the kind element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在每个配置元素中，还可能出现所需的种类元素。此元素表示成员必须支持的种类，并包含多个种类块元素，每个元素定义覆盖中节点必须支持的单个种类。每个种类块由单个种类元素和种类签名组成。种类元素定义了种类。种类签名是在种类元素上计算的签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each kind element has either an id attribute or a name attribute. The name attribute is a string representing the Kind (the name registered to IANA), while the id is an integer Kind-ID allocated out of private space.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个种类元素都有id属性或name属性。name属性是一个表示种类（注册到IANA的名称）的字符串，而id是一个从私有空间中分配的整数种类id。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, the kind element MUST contain the following elements:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，种类元素必须包含以下元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-count The maximum number of values which members of the overlay must support.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max count覆盖的成员必须支持的最大值数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
data-model The data model to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据模型要使用的数据模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-size The maximum size of individual values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大大小单个值的最大大小。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
access-control The access control model to be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
访问控制要使用的访问控制模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kind element MAY also contain the following element:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类元素还可以包含以下元素：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
max-node-multiple If the access control is NODE-MULTIPLE, this element MUST be included. This indicates the maximum value for the i counter. It MUST be an integer greater than 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大节点数如果访问控制为节点数，则必须包含此元素。这表示i计数器的最大值。它必须是大于0的整数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All of the non-optional values MUST be provided. If the Kind is registered with IANA, the data-model and access-control elements MUST match those in the Kind registration, and clients MUST ignore them in favor of the IANA versions. Multiple kind-block elements MAY be present.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须提供所有非可选值。如果种类已向IANA注册，则数据模型和访问控制元素必须与种类注册中的元素相匹配，并且客户端必须忽略它们以支持IANA版本。可能存在多种类型的块元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The kind-block element also MUST contain a &#34;kind-signature&#34; element. This signature is computed across the kind element from the beginning of the first &lt; of the kind element to the end of the last &gt; of the kind element in the same way as the signature element described later in this section. kind-block elements MUST be signed by a node listed in the kind-signers block of the current configuration. Receivers MUST verify the signature prior to accepting a kind-block.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类块元素还必须包含“种类签名”元素。该签名是从kind元素的第一个&lt;开始到最后一个&gt;结束，在kind元素中计算的，计算方式与本节后面描述的签名元素相同。种类块元素必须由当前配置的种类签名者块中列出的节点签名。接收者必须在接受kind块之前验证签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The configuration element MUST be treated as a binary blob that cannot be changed -- including any whitespace changes -- or the signature will break. The signature MUST be computed by taking each configuration element and starting from, and including, the first &lt; at the start of &lt;configuration&gt; up to and including the &gt; in &lt;/ configuration&gt; and treating this as a binary blob that MUST be signed using the standard SecurityBlock defined in Section 6.3.4. The SecurityBlock MUST be base-64 encoded using the base64 alphabet from [RFC4648] and MUST be put in the signature element following the configuration object in the configuration file. Any configuration file MUST be signed by one of the configuration-signer elements from the previous extant configuration. Recipients MUST verify the signature prior to accepting the configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
必须将配置元素视为无法更改的二进制blob（包括任何空格更改），否则签名将中断。签名必须通过以下方式计算：取每个配置元素，从第一个&lt;在&lt;配置&gt;开始时&gt;到&lt;配置&gt;中&gt;并包括该元素，并将其视为二进制blob，必须使用第6.3.4节中定义的标准SecurityBlock签名。SecurityBlock必须使用[RFC4648]中的base64字母表进行base-64编码，并且必须放在配置文件中配置对象后面的签名元素中。任何配置文件都必须由先前现有配置中的一个配置签名者元素签名。收件人必须在接受配置文件之前验证签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node receives a new configuration file, it MUST change its configuration to meet the new requirements. This may require the node to exit the DHT and rejoin. If a node is not capable of supporting the new requirements, it MUST exit the overlay. If some information about a particular Kind changes from what the node previously knew about the Kind (for example, the max size), the new information in the configuration files overrides any previously learned information. If any Kind data was signed by a node that is no longer allowed to sign Kinds, that Kind MUST be discarded along with any stored information of that Kind. Note that forcing an avalanche restart of the overlay with a configuration change that requires rejoining the overlay may result in serious performance problems, including total collapse of the network if configuration
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点收到新的配置文件时，它必须更改其配置以满足新的要求。这可能需要节点退出DHT并重新加入。如果一个节点不能支持新的需求，它必须退出覆盖。如果某个特定种类的某些信息与节点以前了解的种类（例如，最大大小）不同，则配置文件中的新信息将覆盖任何以前了解到的信息。如果任何种类数据由不再允许对种类进行签名的节点进行签名，则必须将该种类数据与该种类的任何存储信息一起丢弃。请注意，强制雪崩式重新启动覆盖并更改配置（需要重新加入覆盖）可能会导致严重的性能问题，包括配置失败时网络完全崩溃
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
parameters are not properly considered. Such an event may be necessary in case of a compromised CA or similar problem, but for large overlays, it should be avoided in almost all circumstances.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
未正确考虑参数。在CA受损或类似问题的情况下，此类事件可能是必要的，但对于大型覆盖，几乎在所有情况下都应避免此类事件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. RELAX NG Grammar
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.1.1. 放松语法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The grammar for the configuration data is:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
配置数据的语法为：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   namespace chord = &#34;urn:ietf:params:xml:ns:p2p:config-chord&#34;
   namespace local = &#34;&#34;
   default namespace p2pcf = &#34;urn:ietf:params:xml:ns:p2p:config-base&#34;
   namespace rng = &#34;http://relaxng.org/ns/structure/1.0&#34;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   namespace chord = &#34;urn:ietf:params:xml:ns:p2p:config-chord&#34;
   namespace local = &#34;&#34;
   default namespace p2pcf = &#34;urn:ietf:params:xml:ns:p2p:config-base&#34;
   namespace rng = &#34;http://relaxng.org/ns/structure/1.0&#34;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   anything =
       (element * { anything }
        | attribute * { text }
        | text)*
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   anything =
       (element * { anything }
        | attribute * { text }
        | text)*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   foreign-elements = element * - (p2pcf:* | local:* | chord:*)
                      { anything }*
   foreign-attributes = attribute * - (p2pcf:*|local:*|chord:*)
                        { text }*
   foreign-nodes = (foreign-attributes | foreign-elements)*
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   foreign-elements = element * - (p2pcf:* | local:* | chord:*)
                      { anything }*
   foreign-attributes = attribute * - (p2pcf:*|local:*|chord:*)
                        { text }*
   foreign-nodes = (foreign-attributes | foreign-elements)*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   start =  element p2pcf:overlay {
         overlay-element
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   start =  element p2pcf:overlay {
         overlay-element
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   overlay-element &amp;=  element configuration {
               attribute instance-name { xsd:string },
               attribute expiration { xsd:dateTime }?,
               attribute sequence { xsd:long }?,
               foreign-attributes*,
               parameter
           }+
   overlay-element &amp;= element signature {
               attribute algorithm { signature-algorithm-type }?,
               xsd:base64Binary
           }*
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   overlay-element &amp;=  element configuration {
               attribute instance-name { xsd:string },
               attribute expiration { xsd:dateTime }?,
               attribute sequence { xsd:long }?,
               foreign-attributes*,
               parameter
           }+
   overlay-element &amp;= element signature {
               attribute algorithm { signature-algorithm-type }?,
               xsd:base64Binary
           }*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   signature-algorithm-type |= &#34;rsa-sha1&#34;
   signature-algorithm-type |=  xsd:string # signature alg extensions
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   signature-algorithm-type |= &#34;rsa-sha1&#34;
   signature-algorithm-type |=  xsd:string # signature alg extensions
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;= element topology-plugin { topology-plugin-type }?
   topology-plugin-type |= xsd:string # topo plugin extensions
   parameter &amp;= element max-message-size { xsd:unsignedInt }?
   parameter &amp;= element initial-ttl { xsd:int }?
   parameter &amp;= element root-cert { xsd:base64Binary }*
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;= element topology-plugin { topology-plugin-type }?
   topology-plugin-type |= xsd:string # topo plugin extensions
   parameter &amp;= element max-message-size { xsd:unsignedInt }?
   parameter &amp;= element initial-ttl { xsd:int }?
   parameter &amp;= element root-cert { xsd:base64Binary }*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;= element required-kinds { kind-block* }?
   parameter &amp;= element enrollment-server { xsd:anyURI }*
   parameter &amp;= element kind-signer {  xsd:string }*
   parameter &amp;= element configuration-signer {  xsd:string }*
   parameter &amp;= element bad-node {  xsd:string }*
   parameter &amp;= element no-ice { xsd:boolean }?
   parameter &amp;= element shared-secret { xsd:string }?
   parameter &amp;= element overlay-link-protocol { xsd:string }*
   parameter &amp;= element clients-permitted { xsd:boolean }?
   parameter &amp;= element turn-density { xsd:unsignedByte }?
   parameter &amp;= element node-id-length { xsd:int }?
   parameter &amp;= element mandatory-extension { xsd:string }*
   parameter &amp;= foreign-elements*
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;= element required-kinds { kind-block* }?
   parameter &amp;= element enrollment-server { xsd:anyURI }*
   parameter &amp;= element kind-signer {  xsd:string }*
   parameter &amp;= element configuration-signer {  xsd:string }*
   parameter &amp;= element bad-node {  xsd:string }*
   parameter &amp;= element no-ice { xsd:boolean }?
   parameter &amp;= element shared-secret { xsd:string }?
   parameter &amp;= element overlay-link-protocol { xsd:string }*
   parameter &amp;= element clients-permitted { xsd:boolean }?
   parameter &amp;= element turn-density { xsd:unsignedByte }?
   parameter &amp;= element node-id-length { xsd:int }?
   parameter &amp;= element mandatory-extension { xsd:string }*
   parameter &amp;= foreign-elements*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;=
       element self-signed-permitted {
           attribute digest { self-signed-digest-type },
           xsd:boolean
       }?
   self-signed-digest-type |= &#34;sha1&#34;
   self-signed-digest-type |=  xsd:string # signature digest extensions
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;=
       element self-signed-permitted {
           attribute digest { self-signed-digest-type },
           xsd:boolean
       }?
   self-signed-digest-type |= &#34;sha1&#34;
   self-signed-digest-type |=  xsd:string # signature digest extensions
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;= element bootstrap-node {
                   attribute address { xsd:string },
                   attribute port { xsd:int }?
                }*
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   parameter &amp;= element bootstrap-node {
                   attribute address { xsd:string },
                   attribute port { xsd:int }?
                }*
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-block = element kind-block {
       element kind {
           (  attribute name { kind-names }
              | attribute id { xsd:unsignedInt } ),
           kind-parameter
       } &amp;
       element kind-signature  {
           attribute algorithm { signature-algorithm-type }?,
           xsd:base64Binary
       }?
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-block = element kind-block {
       element kind {
           (  attribute name { kind-names }
              | attribute id { xsd:unsignedInt } ),
           kind-parameter
       } &amp;
       element kind-signature  {
           attribute algorithm { signature-algorithm-type }?,
           xsd:base64Binary
       }?
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-parameter &amp;= element max-count { xsd:int }
   kind-parameter &amp;= element max-size { xsd:int }
   kind-parameter &amp;= element max-node-multiple { xsd:int }?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-parameter &amp;= element max-count { xsd:int }
   kind-parameter &amp;= element max-size { xsd:int }
   kind-parameter &amp;= element max-node-multiple { xsd:int }?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-parameter &amp;= element data-model { data-model-type }
   data-model-type |= &#34;SINGLE&#34;
   data-model-type |= &#34;ARRAY&#34;
   data-model-type |= &#34;DICTIONARY&#34;
   data-model-type |=  xsd:string # data model extensions
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-parameter &amp;= element data-model { data-model-type }
   data-model-type |= &#34;SINGLE&#34;
   data-model-type |= &#34;ARRAY&#34;
   data-model-type |= &#34;DICTIONARY&#34;
   data-model-type |=  xsd:string # data model extensions
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-parameter &amp;= element access-control { access-control-type }
   access-control-type |= &#34;USER-MATCH&#34;
   access-control-type |= &#34;NODE-MATCH&#34;
   access-control-type |= &#34;USER-NODE-MATCH&#34;
   access-control-type |= &#34;NODE-MULTIPLE&#34;
   access-control-type |= xsd:string # access control extensions
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-parameter &amp;= element access-control { access-control-type }
   access-control-type |= &#34;USER-MATCH&#34;
   access-control-type |= &#34;NODE-MATCH&#34;
   access-control-type |= &#34;USER-NODE-MATCH&#34;
   access-control-type |= &#34;NODE-MULTIPLE&#34;
   access-control-type |= xsd:string # access control extensions
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
kind-parameter &amp;= foreign-elements*
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
种类参数&amp;=外来元素*
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-names |= &#34;TURN-SERVICE&#34;
   kind-names |= &#34;CERTIFICATE_BY_NODE&#34;
   kind-names |= &#34;CERTIFICATE_BY_USER&#34;
   kind-names |= xsd:string # kind extensions
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   kind-names |= &#34;TURN-SERVICE&#34;
   kind-names |= &#34;CERTIFICATE_BY_NODE&#34;
   kind-names |= &#34;CERTIFICATE_BY_USER&#34;
   kind-names |= xsd:string # kind extensions
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   # Chord specific parameters
   topology-plugin-type |= &#34;CHORD-RELOAD&#34;
   parameter &amp;= element chord:chord-ping-interval { xsd:int }?
   parameter &amp;= element chord:chord-update-interval { xsd:int }?
   parameter &amp;= element chord:chord-reactive { xsd:boolean }?
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   # Chord specific parameters
   topology-plugin-type |= &#34;CHORD-RELOAD&#34;
   parameter &amp;= element chord:chord-ping-interval { xsd:int }?
   parameter &amp;= element chord:chord-update-interval { xsd:int }?
   parameter &amp;= element chord:chord-reactive { xsd:boolean }?
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. Discovery through Configuration Server
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.2. 通过配置服务器发现
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node first enrolls in a new overlay, it starts with a discovery process to find a configuration server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当一个节点第一次注册到一个新的覆盖中时，它将开始一个查找配置服务器的发现过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The node MAY start by determining the overlay name. This value MUST be provided by the user or some other out-of-band provisioning mechanism. The out-of-band mechanism MAY also provide an optional URL for the configuration server. If a URL for the configuration server is not provided, the node MUST do a DNS SRV query using a Service name of &#34;reload-config&#34; and a protocol of TCP to find a configuration server and form the URL by appending a path of &#34;/.well-known/reload-config&#34; to the overlay name. This uses the &#34;well-known URI&#34; framework defined in [RFC5785]. For example, if the overlay name was example.com, the URL would be &#34;https://example.com/.well-known/reload-config&#34;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点可以通过确定覆盖名称开始。此值必须由用户或其他带外资源调配机制提供。带外机制还可以为配置服务器提供可选的URL。如果未提供配置服务器的URL，则节点必须使用服务名称“reload config”和TCP协议执行DNS SRV查询，以查找配置服务器，并通过在覆盖名称后面附加“/.well-known/reload-config”路径来形成URL。这使用了[RFC5785]中定义的“众所周知的URI”框架。例如，如果覆盖名称为example.com，则URL将为“https://example.com/.well-known/reload-config&#34;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once an address and URL for the configuration server are determined, the peer MUST form an HTTPS connection to that IP address. If an optional URL for the configuration server was provided, the certificate MUST match the domain name from the URL as described in [RFC2818]; otherwise, the certificate MUST match the overlay name as described in [RFC2818]. If the HTTPS certificates pass the name matching, the node MUST fetch a new copy of the configuration file. To do this, the peer performs a GET to the URL. The result of the HTTP GET is an XML configuration file described above. If the XML is not valid or the instance-name attribute of the overlay-element in the XML does not match the overlay name, this configurations file
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦确定了配置服务器的地址和URL，对等方必须与该IP地址建立HTTPS连接。如果提供了配置服务器的可选URL，则证书必须与[RFC2818]中所述URL中的域名匹配；否则，证书必须与[RFC2818]中描述的覆盖名称匹配。如果HTTPS证书通过名称匹配，则节点必须获取配置文件的新副本。要做到这一点，对等方执行一个到URL的GET。HTTP GET的结果是上面描述的XML配置文件。如果XML无效或XML中覆盖元素的实例名称属性与覆盖名称不匹配，则此配置文件
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SHOULD be discarded. Otherwise, the new configuration MUST replace any previously learned configuration file for this overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应该放弃。否则，新配置必须替换此覆盖的任何先前学习的配置文件。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For overlays that do not use a configuration server, nodes MUST obtain the configuration information needed to join the overlay through some out-of-band approach, such as an XML configuration file sent over email.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于不使用配置服务器的覆盖，节点必须通过一些带外方法（例如通过电子邮件发送的XML配置文件）获取加入覆盖所需的配置信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. Credentials
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3. 资格证书
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Configuration Document contains an enrollment-server element, credentials are REQUIRED to join the Overlay Instance. A peer which does not yet have credentials MUST contact the enrollment server to acquire them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果配置文档包含注册服务器元素，则需要凭据才能加入覆盖实例。尚未具有凭据的对等方必须联系注册服务器以获取凭据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD defines its own trivial certificate request protocol. We would have liked to have used an existing protocol, but were concerned about the implementation burden of even the simplest of those protocols, such as [RFC5272] and [RFC5273]. The objective was to have a protocol which could be easily implemented in a Web server which the operator did not control (e.g., in a hosted service) and which was compatible with the existing certificate-handling tooling as used with the Web certificate infrastructure. This means accepting bare PKCS#10 requests and returning a single bare X.509 certificate. Although the MIME types for these objects are defined, none of the existing protocols support exactly this model.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载定义了它自己的普通证书请求协议。我们本希望使用现有协议，但担心即使是最简单的协议，如[RFC5272]和[RFC5273]的实现负担。目标是要有一个协议，该协议可以在运营商不控制的Web服务器（例如，在托管服务中）中轻松实现，并且与Web证书基础设施中使用的现有证书处理工具兼容。这意味着接受裸PKCS#10请求并返回单个裸X.509证书。尽管定义了这些对象的MIME类型，但现有的协议都不完全支持此模型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate request protocol MUST be performed over HTTPS. The server certificate MUST match the overlay name as described in [RFC2818]. The request MUST be an HTTP POST with the parameters encoded as described in [RFC2388] and with the following properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书请求协议必须通过HTTPS执行。服务器证书必须与[RFC2818]中描述的覆盖名称匹配。请求必须是HTTP POST，参数编码如[RFC2388]所述，并具有以下属性：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If authentication is required, there MUST be form parameters of &#34;password&#34; and &#34;username&#34; containing the user&#39;s account name and password in the clear (hence the need for HTTPS). The username and password strings MUST be UTF-8 strings compared as binary objects. Applications using RELOAD SHOULD define any needed string preparation as per [RFC4013] or its successor documents.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果需要身份验证，则必须有“password”和“username”的表单参数，其中包含用户的帐户名和密码（因此需要HTTPS）。与二进制对象相比，用户名和密码字符串必须是UTF-8字符串。使用重新加载的应用程序应根据[RFC4013]或其后续文档定义任何需要的字符串准备。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If more than one Node-ID is required, there MUST be a form parameter of &#34;nodeids&#34; containing the number of Node-IDs required.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果需要多个节点ID，则必须有一个包含所需节点ID数量的“nodeids”表单参数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o There MUST be a form parameter of &#34;csr&#34; with a content type of &#34;application/pkcs10&#34;, as defined in [RFC2311], that contains the certificate signing request (CSR).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 必须有一个包含证书签名请求（csr）的表单参数“csr”，其内容类型为[RFC2311]中定义的“application/pkcs10”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The Accept header MUST contain the type &#34;application/pkix-cert&#34;, indicating the type that is expected in the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Accept标头必须包含类型“application/pkix cert”，指示响应中预期的类型。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The enrollment server MUST authenticate the request using the provided account name and password. The reason for using the RFC 2388 &#34;multipart/form-data&#34; encoding is so that the password parameter will not be encoded in the URL, to reduce the chance of accidental leakage of the password. If the authentication succeeds and the requested user name in the CSR is acceptable, the server MUST generate and return a certificate for the CSR in the &#34;csr&#34; parameter of the request. The SubjectAltName field in the certificate MUST contain the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注册服务器必须使用提供的帐户名和密码对请求进行身份验证。使用RFC 2388“多部分/表单数据”编码的原因是，不会在URL中对密码参数进行编码，以减少密码意外泄漏的可能性。如果身份验证成功并且CSR中请求的用户名可接受，则服务器必须在请求的“CSR”参数中为CSR生成并返回证书。证书中的SubjectAltName字段必须包含以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One or more Node-IDs which MUST be cryptographically random [RFC4086]. Each MUST be chosen by the enrollment server in such a way that it is unpredictable to the requesting user. For example, the user MUST NOT be informed of potential (random) Node-IDs prior to authenticating. Each is placed in the subjectAltName using the uniformResourceIdentifier type, each MUST contain RELOAD URI, as described in Section 14.15, and each MUST contain a Destination List with a single entry of type &#34;node_id&#34;. The enrollment server SHOULD maintain a mapping of users to Node-IDs and if the same user returns (e.g., to have their certificate re-issued), the enrollment server should return the same Node-IDs, thus avoiding the need for implementations to re-store all their data when their certificates expire.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 一个或多个节点ID必须是加密随机的[RFC4086]。注册服务器必须以对请求用户不可预测的方式选择每个注册服务器。例如，在进行身份验证之前，不得通知用户潜在（随机）节点ID。每个都使用uniformResourceIdentifier类型放置在subjectAltName中，每个都必须包含重载URI，如第14.15节所述，并且每个都必须包含一个目标列表，其中有一个类型为“node_id”的条目。注册服务器应维护用户到节点ID的映射，如果相同的用户返回（例如，重新颁发证书），注册服务器应返回相同的节点ID，从而避免在证书过期时实现重新存储所有数据的需要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A single name (the &#34;user name&#34;) that this user is allowed to use in the overlay, using type rfc822Name. Enrollment servers SHOULD take care to allow only legal characters in the name (e.g., no embedded NULs), rather than simply accepting any name provided by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 允许该用户在覆盖中使用的单个名称（“用户名”），类型为rfc822Name。注册服务器应注意只允许名称中的合法字符（例如，不允许嵌入NUL），而不是简单地接受注册服务器提供的任何名称
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
the user. In some usages, the right side of the user name will match the overlay name, but there is no requirement for this match in this specification. Applications using this specification MAY define such a requirement or MAY otherwise limit the allowed range of allowed user names.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
用户。在某些用法中，用户名的右侧将与覆盖名称匹配，但本规范中不要求此匹配。使用本规范的应用程序可能会定义此类要求，或者可能会限制允许用户名的允许范围。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The SubjectAltName field in the certificate MUST NOT contain any identities other than those listed above. The subject distinguished name in the certificate MUST be empty.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书中的SubjectAltName字段不得包含除上面列出的标识以外的任何标识。证书中的使用者可分辨名称必须为空。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate MUST be returned as type &#34;application/pkix-cert&#34;, as defined in [RFC2585], with an HTTP status code of 200 OK.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书必须以[RFC2585]中定义的“应用程序/pkix证书”类型返回，HTTP状态代码为200 OK。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Certificate processing errors SHOULD result in an HTTP return code of 403 Forbidden, along with a body of type &#34;text/plain&#34; and body that consists of one of the tokens defined in the following list:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
证书处理错误应导致HTTP返回码403禁止，以及类型为“text/plain”的正文和由以下列表中定义的令牌之一组成的正文：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
failed_authentication The account name and password combination used in the HTTPS request was not valid.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
身份验证失败HTTPS请求中使用的帐户名和密码组合无效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
username_not_available The requested user name in the CSR was not acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
用户名\u不可用\u CSR中请求的用户名不可接受。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node-IDs_not_available The number of Node-IDs requested was not acceptable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Node-IDs\u not\u可用请求的节点ID数不可接受。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
bad_CSR There was some other problem with the CSR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
糟糕的企业社会责任企业社会责任还有其他一些问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the client receives an unknown token in the body, it SHOULD treat it as a failure for an unknown reason.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果客户端在主体中接收到未知令牌，则应将其视为未知原因的故障。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The client MUST check that the returned certificate chains back to one of the certificates received in the &#34;root-cert&#34; list of the overlay configuration data (including PKIX BasicConstraints checks). The node then reads the certificate to find the Node-ID it can use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
客户端必须检查返回的证书是否链接回覆盖配置数据的“根证书”列表中接收的证书之一（包括PKIX基本约束检查）。然后，节点读取证书以查找它可以使用的节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. Self-Generated Credentials
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.3.1. 自生凭证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the &#34;self-signed-permitted&#34; element is present in the configuration and is set to &#34;true&#34;, then a node MUST generate its own self-signed certificate to join the overlay. The self-signed certificate MAY contain any user name of the user&#39;s choice.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果配置中存在“允许自签名”元素并将其设置为“true”，则节点必须生成自己的自签名证书才能加入覆盖。自签名证书可以包含用户选择的任何用户名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For self-signed certificates containing only one Node-ID, the Node-ID MUST be computed by applying the digest specified in the self-signed-permitted element to the DER representation of the user&#39;s public key (more specifically, the subjectPublicKeyInfo) and taking the high-order bits. For self-signed certificates containing multiple Node-IDs, the index of the Node-ID (from 1 to the number of Node-IDs needed) must be prepended as a 4-byte big-endian integer to the DER representation of the user&#39;s public key and taking the high-order bits. When accepting a self-signed certificate, nodes MUST check that the Node-ID and public keys match. This prevents Node-ID theft.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于仅包含一个节点ID的自签名证书，必须通过将自签名允许元素中指定的摘要应用于用户公钥（更具体地说，subjectPublicKeyInfo）的DER表示并获取高阶位来计算节点ID。对于包含多个节点ID的自签名证书，节点ID的索引（从1到所需节点ID的数量）必须作为4字节的大端整数预先添加到用户公钥的DER表示中，并采用高阶位。接受自签名证书时，节点必须检查节点ID和公钥是否匹配。这可以防止节点ID被盗。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once the node has constructed a self-signed certificate, it MAY join the overlay. It MUST store its certificate in the overlay (Section 8), but SHOULD look to see if the user name is already taken and, if so, choose another user name. Note that this provides protection only against accidental name collisions. Name theft is
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦节点构造了自签名证书，它就可以加入覆盖。它必须将其证书存储在覆盖中（第8节），但应查看用户名是否已被使用，如果已被使用，请选择其他用户名。请注意，这仅提供防止意外名称冲突的保护。盗名罪
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
still possible. If protection against name theft is desired, then the enrollment service MUST be used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还是有可能的。如果需要防止姓名被盗，则必须使用注册服务。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. Contacting a Bootstrap Node
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
11.4. 联系引导节点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to join the overlay, the Joining Node MUST contact a node in the overlay. Typically this means contacting the bootstrap nodes, since they are reachable by the local peer or have public IP addresses. If the Joining Node has cached a list of peers that it has previously been connected with in this overlay, as an optimization it MAY attempt to use one or more of them as bootstrap nodes before falling back to the bootstrap nodes listed in the configuration file.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了加入覆盖，加入节点必须接触覆盖中的节点。通常这意味着联系引导节点，因为本地对等方可以访问这些节点或具有公共IP地址。如果加入节点缓存了它以前在此覆盖中连接过的对等节点列表，作为优化，它可能会尝试在返回到配置文件中列出的引导节点之前，将其中一个或多个用作引导节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When contacting a bootstrap node, the Joining Node MUST first form the DTLS or TLS connection to the bootstrap node and then send an Attach request over this connection with the destination Resource-ID set to the Joining Node&#39;s Node-ID plus 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
联系引导节点时，加入节点必须首先与引导节点建立DTLS或TLS连接，然后通过此连接发送附加请求，目标资源ID设置为加入节点的节点ID加1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the requester node finally does receive a response from some responding node, it MUST use the Node-ID in the response to start sending requests to join the Overlay Instance as described in Section 6.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当请求者节点最终收到来自某个响应节点的响应时，它必须在响应中使用节点ID来开始发送加入覆盖实例的请求，如第6.4节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After a node has successfully joined the overlay network, it will have direct connections to several peers. Some MAY be added to the cached bootstrap nodes list and used in future boots. Peers that are not directly connected MUST NOT be cached. The suggested number of peers to cache is 10. Algorithms for determining which peers to cache are beyond the scope of this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个节点成功加入覆盖网络后，它将直接连接到多个对等节点。一些可以添加到缓存引导节点列表中，并在将来的引导中使用。不能缓存未直接连接的对等点。建议缓存的对等节点数为10。用于确定缓存哪些对等点的算法超出了本规范的范围。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. Message Flow Example
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
12. 消息流示例
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following abbreviations are used in the message flow diagrams: JN = Joining Node, AP = Admitting Peer, NP = next peer after the AP, NNP = next next peer which is the peer after NP, PP = previous peer before the AP, PPP = previous previous peer which is the peer before the PP, BP = bootstrap node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
消息流图中使用了以下缩写：JN=加入节点，AP=接纳节点，NP=AP之后的下一个节点，NNP=NP之后的下一个节点，PP=AP之前的上一个节点，PPP=PP之前的上一个节点，BP=引导节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the following example, we assume that JN has formed a connection to one of the bootstrap nodes. JN then sends an Attach through that peer to a Resource-ID of itself plus 1 (JN+1). It gets routed to the AP, because JN is not yet part of the overlay. When AP responds, JN and the AP use ICE to set up a connection and then set up DTLS. Once AP has connected to JN, AP sends to JN an Update to populate its Routing Table. The following example shows the Update happening after the DTLS connection is formed, but it could also happen before, in which case the Update would often be routed through other nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在下面的示例中，我们假设JN已形成到其中一个引导节点的连接。然后，JN通过该对等方向其自身的资源ID加1（JN+1）发送附加。它被路由到AP，因为JN还不是覆盖的一部分。当AP响应时，JN和AP使用ICE建立连接，然后建立DTL。一旦AP连接到JN，AP就会向JN发送更新以填充其路由表。下面的示例显示了在DTLS连接形成之后发生的更新，但也可能在之前发生，在这种情况下，更新通常会通过其他节点路由。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq Dest=JN+1|         |         |         |         |
        |----------------------------------------------------------&gt;|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachReq Dest=JN+1|         |
        |         |         |         |&lt;----------------------------|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachAns          |         |
        |         |         |         |----------------------------&gt;|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns          |         |         |         |         |
        |&lt;----------------------------------------------------------|
        |         |         |         |         |         |         |
        |ICE      |         |         |         |         |         |
        |&lt;===========================&gt;|         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |&lt;...........................&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq Dest=JN+1|         |         |         |         |
        |----------------------------------------------------------&gt;|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachReq Dest=JN+1|         |
        |         |         |         |&lt;----------------------------|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachAns          |         |
        |         |         |         |----------------------------&gt;|
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns          |         |         |         |         |
        |&lt;----------------------------------------------------------|
        |         |         |         |         |         |         |
        |ICE      |         |         |         |         |         |
        |&lt;===========================&gt;|         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |&lt;...........................&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 1
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
图1
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JN then forms connections to the appropriate neighbors, such as NP, by sending an Attach which gets routed via other nodes. When NP responds, JN and NP use ICE and DTLS to set up a connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然后，JN通过发送通过其他节点路由的附加，形成到适当邻居（如NP）的连接。当NP响应时，JN和NP使用ICE和DTLS建立连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq NP       |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachReq NP       |         |
        |         |         |         |--------&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachAns|         |         |
        |         |         |         |&lt;--------|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |ICE      |         |         |         |         |         |
        |&lt;=====================================&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |&lt;.....................................&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq NP       |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachReq NP       |         |
        |         |         |         |--------&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |AttachAns|         |         |
        |         |         |         |&lt;--------|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |ICE      |         |         |         |         |         |
        |&lt;=====================================&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |&lt;.....................................&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 2
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
图2
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The JN also needs to populate its Finger Table (for the Chord-based DHT). It issues an Attach to a variety of locations around the overlay. The diagram below shows JN sending an Attach halfway around the Chord ring to the JN + 2^127.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
JN还需要填充其Finger表（对于基于和弦的DHT）。它向覆盖周围的各种位置发出附加。下图显示了JN在弦环的一半向JN+2^127发送连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        NP        XX        TP
        |         |         |         |
        |         |         |         |
        |         |         |         |
        |AttachReq JN+2&lt;&lt;126|         |
        |--------&gt;|         |         |
        |         |         |         |
        |         |         |         |
        |         |AttachReq JN+2&lt;&lt;126|
        |         |--------&gt;|         |
        |         |         |         |
        |         |         |         |
        |         |         |AttachReq JN+2&lt;&lt;126
        |         |         |--------&gt;|
        |         |         |         |
        |         |         |         |
        |         |         |AttachAns|
        |         |         |&lt;--------|
        |         |         |         |
        |         |         |         |
        |         |AttachAns|         |
        |         |&lt;--------|         |
        |         |         |         |
        |         |         |         |
        |AttachAns|         |         |
        |&lt;--------|         |         |
        |         |         |         |
        |ICE      |         |         |
        |&lt;===========================&gt;|
        |         |         |         |
        |TLS      |         |         |
        |&lt;...........................&gt;|
        |         |         |         |
        |         |         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        NP        XX        TP
        |         |         |         |
        |         |         |         |
        |         |         |         |
        |AttachReq JN+2&lt;&lt;126|         |
        |--------&gt;|         |         |
        |         |         |         |
        |         |         |         |
        |         |AttachReq JN+2&lt;&lt;126|
        |         |--------&gt;|         |
        |         |         |         |
        |         |         |         |
        |         |         |AttachReq JN+2&lt;&lt;126
        |         |         |--------&gt;|
        |         |         |         |
        |         |         |         |
        |         |         |AttachAns|
        |         |         |&lt;--------|
        |         |         |         |
        |         |         |         |
        |         |AttachAns|         |
        |         |&lt;--------|         |
        |         |         |         |
        |         |         |         |
        |AttachAns|         |         |
        |&lt;--------|         |         |
        |         |         |         |
        |ICE      |         |         |
        |&lt;===========================&gt;|
        |         |         |         |
        |TLS      |         |         |
        |&lt;...........................&gt;|
        |         |         |         |
        |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
图3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Once JN has a reasonable set of connections, it is ready to take its place in the DHT. It does this by sending a Join to AP. AP sends a series of Store requests to JN to store the data that JN will be responsible for. AP then sends JN an Update that explicitly labels JN as its predecessor. At this point, JN is part of the ring and is responsible for a section of the overlay. AP can now forget any data which is assigned to JN and not to AP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一旦JN拥有了一组合理的连接，它就准备好在DHT中占据一席之地。它通过向AP发送连接来实现这一点。AP向JN发送一系列存储请求，以存储JN将负责的数据。AP然后向JN发送一个更新，明确地将JN标记为其前身。此时，JN是环的一部分，负责覆盖的一部分。AP现在可以忘记分配给JN而不是AP的任何数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |JoinReq  |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |JoinAns  |         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreReq Data A    |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreAns |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreReq Data B    |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreAns |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |JoinReq  |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |JoinAns  |         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreReq Data A    |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreAns |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreReq Data B    |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |StoreAns |         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 4
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
图4
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In Chord, JN&#39;s Neighbor Table needs to contain its own predecessors. It couldn&#39;t connect to them previously, because it did not yet know their addresses. However, now that it has received an Update from AP, as in the previous diagram, it has AP&#39;s predecessors, which are also its own, so it sends Attaches to them. Below, it is shown connecting only to AP&#39;s closest predecessor, PP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在Chord中，JN的邻居表需要包含它自己的前辈。它以前无法连接到他们，因为它还不知道他们的地址。然而，现在它已经收到了来自AP的更新，就像在前面的图中一样，它有了AP的前辈，这些前辈也是它自己的，所以它向他们发送附件。下图所示，它仅连接到AP最近的前置机PP。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq Dest=PP  |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |AttachReq Dest=PP  |         |         |
        |         |         |&lt;--------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |AttachAns|         |         |         |
        |         |         |--------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |...................|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |------------------&gt;|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;------------------|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       JN        PPP       PP        AP        NP        NNP       BP
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachReq Dest=PP  |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |AttachReq Dest=PP  |         |         |
        |         |         |&lt;--------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |AttachAns|         |         |         |
        |         |         |--------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |AttachAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |TLS      |         |         |         |         |         |
        |...................|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |------------------&gt;|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;------------------|         |         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        |----------------------------&gt;|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;----------------------------|         |         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateReq|         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        |--------------------------------------&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;--------------------------------------|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
        |--------------------------------------&gt;|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        |UpdateAns|         |         |         |         |         |
        |&lt;--------------------------------------|         |         |
        |         |         |         |         |         |         |
        |         |         |         |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 5
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
图5
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, now that JN has a copy of all the data and is ready to route messages and receive requests, it sends Updates to everyone in its Routing Table to tell them it is ready to go. Below, it is shown sending such an update to TP.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，既然JN已经有了所有数据的副本，并且已经准备好路由消息和接收请求，它就会向路由表中的每个人发送更新，告诉他们它已经准备好了。下面显示了向TP发送这样的更新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           JN        NP        XX        TP
            |         |         |         |
            |         |         |         |
            |         |         |         |
            |UpdateReq|         |         |
            |----------------------------&gt;|
            |         |         |         |
            |         |         |         |
            |UpdateAns|         |         |
            |&lt;----------------------------|
            |         |         |         |
            |         |         |         |
            |         |         |         |
            |         |         |         |
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           JN        NP        XX        TP
            |         |         |         |
            |         |         |         |
            |         |         |         |
            |UpdateReq|         |         |
            |----------------------------&gt;|
            |         |         |         |
            |         |         |         |
            |UpdateAns|         |         |
            |&lt;----------------------------|
            |         |         |         |
            |         |         |         |
            |         |         |         |
            |         |         |         |
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
Figure 6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-33">
图6
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.1. 概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD provides a generic storage service, albeit one designed to be useful for P2PSIP. In this section, we discuss security issues that are likely to be relevant to any usage of RELOAD. More background information can be found in [RFC5765].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD提供了一种通用的存储服务，尽管它的设计目的是对P2PSIP有用。在本节中，我们将讨论可能与任何重载使用相关的安全问题。更多背景信息可在[RFC5765]中找到。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In any Overlay Instance, any given user depends on a number of peers with which they have no well-defined relationship except that they are fellow members of the Overlay Instance. In practice, these other nodes may be friendly, lazy, curious, or outright malicious. No security system can provide complete protection in an environment where most nodes are malicious. The goal of security in RELOAD is to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在任何Overlay实例中，任何给定的用户都依赖于许多对等方，他们与这些对等方之间没有明确定义的关系，只是他们是Overlay实例的其他成员。实际上，这些其他节点可能是友好的、懒惰的、好奇的或完全恶意的。在大多数节点都是恶意的环境中，任何安全系统都无法提供完整的保护。重新加载中的安全性目标是
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
provide strong security guarantees of some properties even in the face of a large number of malicious nodes and to allow the overlay to function correctly in the face of a modest number of malicious nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
即使面对大量恶意节点，也能为某些属性提供强大的安全保证，并允许覆盖在面对少量恶意节点时正常工作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2PSIP deployments require the ability to authenticate both peers and resources (users) without the active presence of a trusted entity in the system. We describe two mechanisms. The first mechanism is based on public key certificates and is suitable for general deployments. The second is an admission control mechanism based on an overlay-wide shared symmetric key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2PSIP部署要求能够在系统中不存在受信任实体的情况下对对等方和资源（用户）进行身份验证。我们描述了两种机制。第一种机制基于公钥证书，适用于一般部署。第二种是基于覆盖范围的共享对称密钥的接纳控制机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. Attacks on P2P Overlays
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.2. 对P2P覆盖的攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The two basic functions provided by overlay nodes are storage and routing: some peer is responsible for storing a node&#39;s data and for allowing a third node to fetch this stored data, while other peers are responsible for routing messages to and from the storing nodes. Each of these issues is covered in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖节点提供的两个基本功能是存储和路由：一些对等方负责存储节点的数据，并允许第三个节点获取存储的数据，而其他对等方负责将消息路由到存储节点和从存储节点发送出去。以下各节将介绍这些问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2P overlays are subject to attacks by subversive nodes that may attempt to disrupt routing, corrupt or remove user registrations, or eavesdrop on signaling. The certificate-based security algorithms we describe in this specification are intended to protect overlay routing and user registration information in RELOAD messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P2P覆盖受到颠覆性节点的攻击，这些节点可能试图破坏路由、破坏或删除用户注册，或窃听信号。本规范中描述的基于证书的安全算法旨在保护重载消息中的覆盖路由和用户注册信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To protect the signaling from attackers pretending to be valid nodes (or nodes other than themselves), the first requirement is to ensure that all messages are received from authorized members of the overlay. For this reason, RELOAD MUST transport all messages over a secure channel (TLS and DTLS are defined in this document) which provides message integrity and authentication of the directly communicating peer. In addition, messages and data MUST be digitally signed with the sender&#39;s private key, providing end-to-end security for communications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了保护信令不受假装为有效节点（或自身以外的节点）的攻击者的攻击，第一个要求是确保从覆盖的授权成员处接收所有消息。因此，重新加载必须通过安全通道（本文档中定义了TLS和DTL）传输所有消息，该通道提供消息完整性和直接通信对等方的身份验证。此外，消息和数据必须使用发送方的私钥进行数字签名，从而为通信提供端到端的安全性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. Certificate-Based Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.3. 基于证书的安全性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification stores users&#39; registrations and possibly other data in an overlay network. This requires a solution both to securing this data and to securing, as well as possible, the routing in the overlay. Both types of security are based on requiring that every entity in the system (whether user or peer) authenticate cryptographically using an asymmetric key pair tied to a certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该规范将用户注册和其他数据存储在覆盖网络中。这需要一个解决方案来保护此数据，并尽可能保护覆盖中的路由。这两种类型的安全性都基于要求系统中的每个实体（无论是用户还是对等方）使用绑定到证书的非对称密钥对进行加密身份验证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a user enrolls in the Overlay Instance, they request or are assigned a unique name, such as &#34;alice@dht.example.net&#34;. These names MUST be unique and are meant to be chosen and used by humans much like a SIP address-of-record (AOR) or an email address. The user
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当用户注册覆盖实例时，他们请求或被分配一个唯一的名称，例如“alice@dht.example.net&#34;. 这些名称必须是唯一的，并由人类选择和使用，就像SIP记录地址（AOR）或电子邮件地址一样。用户
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MUST also be assigned one or more Node-IDs by the central enrollment authority. Both the name and the Node-IDs are placed in the certificate, along with the user&#39;s public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还必须由中央注册机构分配一个或多个节点ID。名称和节点ID与用户的公钥一起放置在证书中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each certificate enables an entity to act in two sorts of roles:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
每个证书使实体能够扮演两种角色：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a user, storing data at specific Resource-IDs in the Overlay Instance corresponding to the user name.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 作为用户，在与用户名对应的覆盖实例中以特定资源ID存储数据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o As a overlay peer with the Node-IDs listed in the certificate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 作为具有证书中列出的节点ID的覆盖对等方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that since only users of this Overlay Instance need to validate a certificate, this usage does not require a global Public Key Infrastructure (PKI). Instead, certificates MUST be signed by a central enrollment authority which acts as the certificate authority for the Overlay Instance. This authority signs each node&#39;s certificate. Because each node possesses the CA&#39;s certificate (which they receive upon enrollment), they can verify the certificates of the other entities in the overlay without further communication. Because the certificates contain the user&#39;s/node&#39;s public key, communications from the user/node can, in turn, be verified.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，由于只有此覆盖实例的用户需要验证证书，因此这种用法不需要全局公钥基础设施（PKI）。相反，证书必须由作为覆盖实例的证书颁发机构的中央注册机构签名。此权限对每个节点的证书进行签名。由于每个节点都拥有CA的证书（在注册时接收），因此它们可以验证覆盖中其他实体的证书，而无需进一步通信。由于证书包含用户/节点的公钥，因此可以依次验证来自用户/节点的通信。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If self-signed certificates are used, then the security provided is significantly decreased, since attackers can mount Sybil attacks. In addition, attackers cannot trust the user names in certificates (although they can trust the Node-IDs, because they are cryptographically verifiable). This scheme may be appropriate for some small deployments, such as a small office or an ad hoc overlay set up among participants in a meeting where all hosts on the network are trusted. Some additional security can be provided by using the shared secret admission control scheme as well.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果使用自签名证书，则提供的安全性会显著降低，因为攻击者可以发起Sybil攻击。此外，攻击者不能信任证书中的用户名（尽管他们可以信任节点ID，因为它们可以通过加密验证）。此方案可能适用于一些小型部署，例如小型办公室或在会议参与者之间设置的临时覆盖，其中网络上的所有主机都是可信的。使用共享秘密接纳控制方案也可以提供一些额外的安全性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because all stored data is signed by the owner of the data, the storing node can verify that the storer is authorized to perform a store at that Resource-ID and also can allow any consumer of the data to verify the provenance and integrity of the data when it retrieves it.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因为所有存储的数据都由数据所有者签名，所以存储节点可以验证存储者是否有权在该资源ID上执行存储，并且还可以允许数据的任何使用者在检索数据时验证数据的来源和完整性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that RELOAD does not itself provide a revocation/status mechanism (although certificates may, of course, include Online Certificate Status Protocol [OCSP] responder information). Thus, certificate lifetimes SHOULD be chosen to balance the compromise window versus the cost of certificate renewal. Because RELOAD is already designed to operate in the face of some fraction of malicious nodes, this form of compromise is not fatal.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，重新加载本身并不提供吊销/状态机制（当然，证书可能包括联机证书状态协议[OCSP]响应程序信息）。因此，应该选择证书生存期来平衡折衷窗口和证书更新成本。由于重新加载已经设计为在面对部分恶意节点时运行，因此这种形式的妥协不是致命的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All implementations MUST implement certificate-based security.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有实现都必须实现基于证书的安全性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. Shared-Secret Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.4. 共享秘密安全
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD also supports a shared secret admission control scheme that relies on a single key that is shared among all members of the overlay. It is appropriate for small groups that wish to form a private network without complexity. In shared secret mode, all the peers MUST share a single symmetric key which is used to key TLS-PSK or TLS-SRP mode. A peer which does not know the key cannot form TLS connections with any other peer and therefore cannot join the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD还支持共享秘密许可控制方案，该方案依赖于覆盖的所有成员共享的单个密钥。它适用于希望形成一个没有复杂性的专用网络的小团体。在共享秘密模式下，所有对等方必须共享一个用于密钥TLS-PSK或TLS-SRP模式的对称密钥。不知道密钥的对等方无法与任何其他对等方形成TLS连接，因此无法加入覆盖。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One natural approach to a shared-secret scheme is to use a user-entered password as the key. The difficulty with this is that in TLS-PSK mode, such keys are very susceptible to dictionary attacks. If passwords are used as the source of shared keys, then TLS-SRP is a superior choice, because it is not subject to dictionary attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
共享秘密方案的一种自然方法是使用用户输入的密码作为密钥。这样做的困难在于，在TLS-PSK模式下，此类密钥非常容易受到字典攻击。如果使用密码作为共享密钥的来源，那么TLS-SRP是一个更好的选择，因为它不会受到字典攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. Storage Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5. 存储安全
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When certificate-based security is used in RELOAD, any given Resource-ID/Kind-ID pair is bound to some small set of certificates. In order to write data, the writer must prove possession of the private key for one of those certificates. Moreover, all data is stored, signed with the same private key that was used to authorize the storage. This set of rules makes questions of authorization and data integrity, which have historically been thorny for overlays, relatively simple.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在重新加载中使用基于证书的安全性时，任何给定的资源ID/种类ID对都会绑定到一些小的证书集。为了写入数据，写入者必须证明拥有其中一个证书的私钥。此外，存储所有数据，并使用用于授权存储的相同私钥进行签名。这组规则使得授权和数据完整性问题相对简单，而授权和数据完整性在历史上一直是重叠的难题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.1. Authorization
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.1. 批准
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a node wants to store some value, it MUST first digitally sign the value with its own private key. It then sends a Store request that contains both the value and the signature towards the storing peer (which is defined by the Resource Name construction algorithm for that particular Kind of value).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当节点想要存储某个值时，它必须首先使用自己的私钥对该值进行数字签名。然后，它向存储对等方发送一个包含值和签名的存储请求（由资源名构造算法为该特定类型的值定义）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the storing peer receives the request, it MUST determine whether the storing node is authorized to store at this Resource-ID/Kind-ID pair. Determining this requires comparing the user&#39;s identity to the requirements of the access control model (see Section 7.3). If it satisfies those requirements, the user is authorized to write, pending quota checks, as described in the next section.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当存储对等方收到请求时，它必须确定存储节点是否有权存储在该资源ID/种类ID对上。确定这一点需要将用户身份与访问控制模型的要求进行比较（见第7.3节）。如果满足这些要求，则用户有权写入待定的配额检查，如下一节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For example, consider a certificate with the following properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
例如，考虑具有以下属性的证书：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
User name: alice@dht.example.com Node-ID: 013456789abcdef Serial: 1234
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-10">
用户名：alice@dht.example.com节点ID:013456789abcdef序列号：1234
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If Alice wishes to Store a value of the &#34;SIP Location&#34; Kind, the Resource Name will be the SIP AOR &#34;sip:alice@dht.example.com&#34;. The Resource-ID will be determined by hashing the Resource Name. Because SIP Location uses the USER-NODE-MATCH policy, it first verifies that the user name in the certificate hashes to the requested Resource-ID. It then verifies that the Node-ID in the certificate matches the dictionary key being used for the store. If both of these checks succeed, the Store is authorized. Note that because the access control model is different for different Kinds, the exact set of checks will vary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果Alice希望存储“SIP Location”类型的值，则资源名称将为SIP AOR“SIP:alice@dht.example.com&#34;. 资源ID将通过哈希资源名称来确定。由于SIP Location使用USER-NODE-MATCH策略，因此它首先验证证书中的用户名是否哈希到请求的资源ID。然后验证证书中的节点ID是否匹配用于存储的字典密钥。如果这两项检查都成功，则商店将获得授权。请注意，由于不同类型的访问控制模型不同，因此检查的确切设置也会有所不同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.2. Distributed Quota
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.2. 分配配额
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Being a peer in an Overlay Instance carries with it the responsibility to store data for a given region of the Overlay Instance. However, allowing nodes to store unlimited amounts of data would create unacceptable burdens on peers and would also enable trivial denial-of-service (DoS) attacks. RELOAD addresses this issue by requiring configurations to define maximum sizes for each Kind of stored data. Attempts to store values exceeding this size MUST be rejected. (If peers are inconsistent about this, then strange artifacts will happen when the zone of responsibility shifts and a different peer becomes responsible for overlarge data.) Because each Resource-ID/Kind-ID pair is bound to a small set of certificates, these size restrictions also create a distributed quota mechanism, with the quotas administered by the central configuration server.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为覆盖实例中的对等方，有责任存储覆盖实例给定区域的数据。然而，允许节点存储无限量的数据将给对等节点造成不可接受的负担，还将导致轻微的拒绝服务（DoS）攻击。重载通过要求配置为每种存储数据定义最大大小来解决此问题。必须拒绝存储超过此大小的值的尝试。（如果对等方对此不一致，那么当责任区转移时，会发生奇怪的工件，而另一个对等方负责过大的数据。）因为每个资源ID/种类ID对都绑定到一个小的证书集，这些大小限制还创建了一个分布式配额机制，使用由中央配置服务器管理的配额。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Allowing different Kinds of data to have different size restrictions allows new usages the flexibility to define limits that fit their needs without requiring all usages to have expansive limits.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
允许不同类型的数据具有不同的大小限制，允许新的用途灵活地定义适合其需要的限制，而不要求所有用途都具有扩展的限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.3. Correctness
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.3. 正确性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because each stored value is signed, it is trivial for any retrieving node to verify the integrity of the stored value. More care needs to be taken to prevent version rollback attacks. Rollback attacks on storage are prevented by the use of store times and lifetime values in each store. A lifetime represents the latest time at which the data is valid and thus limits (although does not completely prevent) the ability of the storing node to perform a rollback attack on retrievers. In order to prevent a rollback attack at the time of the Store request, it is REQUIRED that storage times be monotonically increasing. Storing peers MUST reject Store requests with storage times smaller than or equal to those that they are currently storing. In addition, a fetching node which receives a data value with a storage time older than the result of the previous fetch knows that a rollback has occurred.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
因为每个存储值都经过签名，所以任何检索节点都不需要验证存储值的完整性。需要更加小心地防止版本回滚攻击。通过在每个存储中使用存储时间和生存期值，可以防止对存储的回滚攻击。生存期表示数据有效的最新时间，因此限制（尽管不能完全阻止）存储节点对检索器执行回滚攻击的能力。为了防止在存储请求时发生回滚攻击，要求存储时间单调增加。存储对等方必须拒绝存储时间小于或等于其当前存储时间的存储请求。此外，接收存储时间早于前一次提取结果的数据值的提取节点知道发生了回滚。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.4. Residual Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.5.4. 剩余攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The mechanisms described here provide a high degree of security, but some attacks remain possible. Most simply, it is possible for storing peers to refuse to store a value (i.e., they reject any request). In addition, a storing peer can deny knowledge of values which it has previously accepted. To some extent, these attacks can be ameliorated by attempting to store to and retrieve from replicas, but a retrieving node does not know whether or not it should try this, as there is a cost to doing so.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里描述的机制提供了高度的安全性，但仍有一些攻击是可能的。最简单的是，存储对等方可以拒绝存储值（即，它们拒绝任何请求）。此外，存储对等方可以拒绝其先前接受的值的知识。在某种程度上，可以通过尝试存储副本和从副本中检索来改进这些攻击，但是检索节点不知道是否应该尝试，因为这样做是有代价的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate-based authentication scheme prevents a single peer from being able to forge data owned by other peers. Furthermore, although a subversive peer can refuse to return data resources for which it is responsible, it cannot return forged data, because it cannot provide authentication for such registrations. Therefore, parallel searches for redundant registrations can mitigate most of the effects of a compromised peer. The ultimate reliability of such an overlay is a statistical question based on the replication factor and the percentage of compromised peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基于证书的身份验证方案防止单个对等方伪造其他对等方拥有的数据。此外，尽管颠覆性对等方可以拒绝返回其负责的数据资源，但它不能返回伪造的数据，因为它不能为此类注册提供身份验证。因此，对冗余注册的并行搜索可以减轻受损对等的大部分影响。这种覆盖的最终可靠性是一个基于复制因子和受损节点百分比的统计问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, when a Kind is multivalued (e.g., an array data model), the storing peer can return only some subset of the values, thus biasing its responses. This can be countered by using single values rather than sets, but that makes coordination between multiple storing agents much more difficult. This is a trade-off that must be made when designing any usage.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，当一种类型是多值的（例如，数组数据模型）时，存储对等方只能返回一些值的子集，从而使其响应产生偏差。这可以通过使用单个值而不是集合来解决，但这使得多个存储代理之间的协调更加困难。这是设计任何用法时必须进行的权衡。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6. Routing Security
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6. 路由安全
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the storage security system guarantees (within limits) the integrity of the stored data, routing security focuses on stopping the attacker from performing a DoS attack that misroutes requests in the overlay. There are a few obvious observations to make about this. First, it is easy to ensure that an attacker is at least a valid node in the Overlay Instance. Second, this is a DoS attack only. Third, if a large percentage of the nodes on the Overlay Instance are controlled by the attacker, it is probably impossible to perfectly secure against this.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于存储安全系统保证（在一定范围内）存储数据的完整性，路由安全性的重点是阻止攻击者执行DoS攻击，该攻击会在覆盖中错误路由请求。关于这一点，有一些显而易见的观察。首先，很容易确保攻击者至少是覆盖实例中的有效节点。第二，这只是DoS攻击。第三，如果覆盖实例上的大部分节点由攻击者控制，则可能不可能完全防止这种情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.1. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.1. 出身背景
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, attacks on DHT routing are mounted by the attacker arranging to route traffic through one or two nodes that it controls. In the Eclipse attack [Eclipse], the attacker tampers with messages to and from nodes for which it is on-path with respect to a given victim node. This allows it to pretend to be all the nodes that are reachable through it. In the Sybil attack [Sybil], the attacker registers a large number of nodes and is therefore able to capture a large amount of the traffic through the DHT.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常，对DHT路由的攻击是由安排通过其控制的一个或两个节点路由流量的攻击者发起的。在Eclipse攻击[Eclipse]中，攻击者篡改与给定受害节点的路径上的节点之间的消息。这允许它假装是通过它可以访问的所有节点。在Sybil攻击[Sybil]中，攻击者注册了大量节点，因此能够通过DHT捕获大量流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Both the Eclipse and Sybil attacks require the attacker to be able to exercise control over her Node-IDs. The Sybil attack requires the creation of a large number of peers. The Eclipse attack requires that the attacker be able to impersonate specific peers. In both cases, RELOAD attempts to mitigate these attacks by the use of centralized, certificate-based admission control.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eclipse和Sybil攻击都要求攻击者能够控制其节点ID。Sybil攻击需要创建大量对等方。Eclipse攻击要求攻击者能够模拟特定的对等方。在这两种情况下，RELOAD都试图通过使用集中的、基于证书的准入控制来减轻这些攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.2. Admissions Control
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.2. 入学控制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Admission to a RELOAD Overlay Instance is controlled by requiring that each peer have a certificate containing its Node-ID. The requirement to have a certificate is enforced by using certificate-based mutual authentication on each connection. (Note: the following applies only when self-signed certificates are not used.) Whenever a peer connects to another peer, each side automatically checks that the other has a suitable certificate. These Node-IDs MUST be randomly assigned by the central enrollment server. This has two benefits:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过要求每个对等方都有一个包含其节点ID的证书来控制重新加载覆盖实例的许可。通过在每个连接上使用基于证书的相互身份验证来强制执行拥有证书的要求。（注意：以下仅适用于不使用自签名证书的情况。）每当一个对等方连接到另一个对等方时，每一方都会自动检查另一方是否拥有合适的证书。这些节点ID必须由中央注册服务器随机分配。这有两个好处：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It allows the enrollment server to limit the number of Node-IDs issued to any individual user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它允许注册服务器限制发给任何单个用户的节点ID的数量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It prevents the attacker from choosing specific Node-IDs.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它防止攻击者选择特定的节点ID。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The first property allows protection against Sybil attacks (provided that the enrollment server uses strict rate-limiting policies). The second property deters but does not completely prevent Eclipse attacks. Because an Eclipse attacker must impersonate peers on the other side of the attacker, the attacker must have a certificate for suitable Node-IDs, which requires him to repeatedly query the enrollment server for new certificates, which will match only by chance. From the attacker&#39;s perspective, the difficulty is that if the attacker has only a small number of certificates, the region of the Overlay Instance he is impersonating appears to be very sparsely populated by comparison to the victim&#39;s local region.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
第一个属性允许针对Sybil攻击提供保护（前提是注册服务器使用严格的速率限制策略）。第二个属性阻止但不能完全阻止Eclipse攻击。由于Eclipse攻击者必须模拟攻击者另一端的对等方，因此攻击者必须拥有适合节点ID的证书，这要求他重复查询注册服务器以获取新证书，而新证书只是偶然匹配的。从攻击者的角度来看，困难在于，如果攻击者只有少量证书，则与受害者的本地区域相比，他模拟的覆盖实例区域似乎非常稀疏。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.3. Peer Identification and Authentication
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.3. 对等身份识别和认证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, whenever a peer engages in overlay activity that might affect the Routing Table, it must establish its identity. This happens in two ways. First, whenever a peer establishes a direct connection to another peer, it authenticates via certificate-based mutual authentication. All messages between peers are sent over this protected channel, and therefore the peers can verify the data origin of the last-hop peer for requests and responses without further cryptography.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通常，当对等方参与可能影响路由表的覆盖活动时，它必须建立其标识。这有两种方式。首先，当一个对等方建立到另一个对等方的直接连接时，它通过基于证书的相互身份验证进行身份验证。对等方之间的所有消息都通过此受保护的通道发送，因此对等方可以验证最后一跳对等方的请求和响应的数据源，而无需进一步加密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In some situations, however, it is desirable to be able to establish the identity of a peer with whom one is not directly connected. The most natural case is when a peer Updates its state. At this point, other peers may need to update their view of the overlay structure, but they need to verify that the Update message came from the actual peer rather than from an attacker. To prevent having a peer accept Update messages from an attacker, all overlay routing messages are signed by the peer that generated them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
然而，在某些情况下，希望能够确定与自己没有直接连接的对等方的身份。最自然的情况是对等机更新其状态。此时，其他对等方可能需要更新其覆盖结构视图，但他们需要验证更新消息是否来自实际对等方，而不是来自攻击者。为了防止对等方接受来自攻击者的更新消息，所有覆盖路由消息都由生成它们的对等方签名。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For messages that impact the topology of the overlay, replay is typically prevented by having the information come directly from, or be verified by, the nodes that claimed to have generated the update. Data storage replay detection is done by signing the time of the node that generated the signature on the Store request, thus providing a time-based replay protection, but the time synchronization is needed only between peers that can write to the same location.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于影响覆盖拓扑的消息，通常通过让信息直接来自声称已生成更新的节点或由其验证来防止重播。数据存储重放检测是通过对存储请求上生成签名的节点的时间进行签名来完成的，因此提供了基于时间的重放保护，但时间同步只需要在可以写入同一位置的对等方之间进行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.4. Protecting the Signaling
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.4. 保护信号
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal here is to stop an attacker from knowing who is signaling what to whom. An attacker is unlikely to be able to observe the activities of a specific individual, given the randomization of IDs and routing based on the present peers discussed above. Furthermore, because messages can be routed using only the header information, the actual body of the RELOAD message can be encrypted during transmission.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里的目标是阻止攻击者知道谁在向谁发送信号。鉴于上述基于当前对等点的ID和路由的随机性，攻击者不太可能观察到特定个人的活动。此外，由于可以仅使用报头信息路由消息，因此可以在传输期间加密重新加载消息的实际正文。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are two lines of defense here. The first is the use of TLS or DTLS for each communications link between peers. This provides protection against attackers who are not members of the overlay. The second line of defense is to digitally sign each message. This prevents adversarial peers from modifying messages in flight, even if they are on the routing path.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这里有两道防线。第一种是对对等点之间的每个通信链路使用TLS或DTL。这为非覆盖层成员的攻击者提供了保护。第二道防线是对每条信息进行数字签名。这可以防止敌对对等方在飞行中修改消息，即使它们位于路由路径上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.5. Routing Loops and DoS Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.5. 路由循环和DoS攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source-routing mechanisms are known to create the possibility for DoS amplification, especially by the induction of routing loops [RFC5095]. In order to limit amplification, the initial-ttl value in the configuration file SHOULD be set to a value slightly larger than the longest expected path through the network. For Chord, experience has shown that log(2) of the number of nodes in the network + 5 is a safe bound. Because nodes are required to enforce the initial-ttl as the maximum value, an attacker cannot achieve an amplification factor greater than initial-ttl, thus limiting the additional capabilities provided by source routing.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已知源路由机制可产生DoS放大的可能性，特别是通过引入路由循环[RFC5095]。为了限制放大，配置文件中的初始ttl值应设置为略大于通过网络的最长预期路径的值。对于Chord，经验表明网络中节点数的log（2）＋5是一个安全界限。由于需要节点将初始ttl强制为最大值，因此攻击者无法获得大于初始ttl的放大系数，从而限制源路由提供的附加功能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to prevent the use of loops for targeted implementation attacks, implementations SHOULD check the Destination List for duplicate entries and discard such records with an &#34;Error_Invalid_Message&#34; error. This does not completely prevent loops, but it does require that at least one attacker node be part of the loop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了防止使用循环进行有针对性的实现攻击，实现应检查目标列表中的重复条目，并丢弃带有“Error\u Invalid\u Message”错误的记录。这并不能完全防止循环，但它确实要求至少有一个攻击者节点是循环的一部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.6. Residual Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
13.6.6. 剩余攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The routing security mechanisms in RELOAD are designed to contain rather than eliminate attacks on routing. It is still possible for an attacker to mount a variety of attacks. In particular, if an attacker is able to take up a position on the overlay routing between A and B, it can make it appear as if B does not exist or is disconnected. It can also advertise false network metrics in an attempt to reroute traffic. However, these are primarily DoS attacks.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RELOAD中的路由安全机制旨在遏制而不是消除对路由的攻击。攻击者仍有可能发起各种攻击。特别是，如果攻击者能够占据a和B之间的覆盖路由上的某个位置，则可以使其看起来好像B不存在或已断开连接。它还可以公布错误的网络度量，以尝试重新路由流量。但是，这些攻击主要是DoS攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The certificate-based security scheme secures the namespace, but if an individual peer is compromised or if an attacker obtains a certificate from the CA, then a number of subversive peers can still appear in the overlay. While these peers cannot falsify responses to resource queries, they can respond with error messages, effecting a DoS attack on the resource registration. They can also subvert routing to other compromised peers. To defend against such attacks, a resource search must still consist of parallel searches for replicated registrations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
基于证书的安全方案保护名称空间，但如果单个对等方受到攻击，或者如果攻击者从CA获得证书，则覆盖中仍会出现大量颠覆性对等方。虽然这些对等方不能伪造对资源查询的响应，但它们可以用错误消息进行响应，从而对资源注册造成DoS攻击。它们还可以破坏到其他受损对等方的路由。为了防御此类攻击，资源搜索必须仍然包括对复制注册的并行搜索。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14. IANA考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section contains the new code points registered by this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节包含本文档注册的新代码点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. Well-Known URI Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.1. 众所周知的URI注册
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has registered a &#34;well-known URI&#34; as described in [RFC5785]:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已注册了[RFC5785]中所述的“知名URI”：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +----------------------------+----------------------+
           | URI suffix:                | reload-config        |
           | Change controller:         | IETF &lt;iesg@ietf.org&gt; |
           | Specification document(s): | RFC 6940             |
           | Related information:       | None                 |
           +----------------------------+----------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +----------------------------+----------------------+
           | URI suffix:                | reload-config        |
           | Change controller:         | IETF &lt;iesg@ietf.org&gt; |
           | Specification document(s): | RFC 6940             |
           | Related information:       | None                 |
           +----------------------------+----------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. Port Registrations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.2. 港口注册
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has already allocated a TCP port for the main peer-to-peer protocol. This port had the name p2psip-enroll and the port number of 6084. Per this document, IANA has updated this registration to change the service name to reload-config.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已经为主对等协议分配了TCP端口。此端口的名称为p2psip enroll，端口号为6084。根据本文档，IANA已更新此注册，以将服务名称更改为重新加载配置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has made the following port registration:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已进行了以下港口注册：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------------+-------------------------------------+
   | Registration Technical      | IETF Chair &lt;chair@ietf.org&gt;         |
   | Contact                     |                                     |
   | Registration Owner          | IETF &lt;iesg@ietf.org&gt;                |
   | Transport Protocol          | TCP                                 |
   | Port Number                 | 6084                                |
   | Service Name                | reload-config                       |
   | Description                 | Peer-to-Peer Infrastructure         |
   |                             | Configuration                       |
   +-----------------------------+-------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-----------------------------+-------------------------------------+
   | Registration Technical      | IETF Chair &lt;chair@ietf.org&gt;         |
   | Contact                     |                                     |
   | Registration Owner          | IETF &lt;iesg@ietf.org&gt;                |
   | Transport Protocol          | TCP                                 |
   | Port Number                 | 6084                                |
   | Service Name                | reload-config                       |
   | Description                 | Peer-to-Peer Infrastructure         |
   |                             | Configuration                       |
   +-----------------------------+-------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. Overlay Algorithm Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.3. 覆盖算法类型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Overlay Algorithm Types&#34; Registry. Entries in this registry are strings denoting the names of overlay algorithms, as described in Section 11.1 of [RFC6940]. The registration policy for this registry is &#34;IETF Review&#34; [RFC522]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已经创建了一个“重载覆盖算法类型”注册表。该注册表中的条目是表示覆盖算法名称的字符串，如[RFC6940]第11.1节所述。此注册表的注册策略为“IETF审查”[RFC522]。此注册表的初始内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      +----------------+-----------+
                      | Algorithm Name | Reference |
                      +----------------+-----------+
                      | CHORD-RELOAD   |  RFC 6940 |
                      | EXP-OVERLAY    |  RFC 6940 |
                      +----------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      +----------------+-----------+
                      | Algorithm Name | Reference |
                      +----------------+-----------+
                      | CHORD-RELOAD   |  RFC 6940 |
                      | EXP-OVERLAY    |  RFC 6940 |
                      +----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-OVERLAY has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXP-OVERLAY值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. Access Control Policies
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.4. 访问控制策略
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Access Control Policies&#34; Registry. Entries in this registry are strings denoting access control policies, as described in Section 7.3 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已创建“重新加载访问控制策略”注册表。此注册表中的条目是表示访问控制策略的字符串，如[RFC6940]第7.3节所述。本登记册中的新条目应通过标准行动[RFC5226]进行登记。此注册表的初始内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      +-----------------+-----------+
                      | Access Policy   | Reference |
                      +-----------------+-----------+
                      | USER-MATCH      |  RFC 6940 |
                      | NODE-MATCH      |  RFC 6940 |
                      | USER-NODE-MATCH |  RFC 6940 |
                      | NODE-MULTIPLE   |  RFC 6940 |
                      | EXP-MATCH       |  RFC 6940 |
                      +-----------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                      +-----------------+-----------+
                      | Access Policy   | Reference |
                      +-----------------+-----------+
                      | USER-MATCH      |  RFC 6940 |
                      | NODE-MATCH      |  RFC 6940 |
                      | USER-NODE-MATCH |  RFC 6940 |
                      | NODE-MULTIPLE   |  RFC 6940 |
                      | EXP-MATCH       |  RFC 6940 |
                      +-----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-MATCH has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXP-MATCH值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. Application-ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.5. 应用程序ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Application-ID&#34; Registry. Entries in this registry are 16-bit integers denoting Application-IDs, as described in Section 6.5.2 of [RFC6940]. Code points in the range 1 to 32767 SHALL be registered via Standards Action [RFC5226]. Code points in the range 32768 to 61440 SHALL be registered via Expert Review [RFC5226]. Code points in the range 61441 to 65534 are reserved for private use. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已创建“重新加载应用程序ID”注册表。此注册表中的条目是表示应用程序ID的16位整数，如[RFC6940]第6.5.2节所述。1至32767范围内的代码点应通过标准行动[RFC5226]进行注册。32768至61440范围内的代码点应通过专家评审[RFC5226]进行登记。61441至65534范围内的代码点保留供私人使用。此注册表的初始内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     +-------------+----------------+-------------------------------+
     | Application | Application-ID |                 Specification |
     +-------------+----------------+-------------------------------+
     | INVALID     |              0 |                      RFC 6940 |
     | SIP         |           5060 | Reserved for use by SIP Usage |
     | SIP         |           5061 | Reserved for use by SIP Usage |
     | Reserved    |          65535 |                      RFC 6940 |
     +-------------+----------------+-------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     +-------------+----------------+-------------------------------+
     | Application | Application-ID |                 Specification |
     +-------------+----------------+-------------------------------+
     | INVALID     |              0 |                      RFC 6940 |
     | SIP         |           5060 | Reserved for use by SIP Usage |
     | SIP         |           5061 | Reserved for use by SIP Usage |
     | Reserved    |          65535 |                      RFC 6940 |
     +-------------+----------------+-------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.6. Data Kind-ID
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.6. 数据种类ID
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Data Kind-ID&#34; registry. Entries in this registry are 32-bit integers denoting data Kinds, as described in Section 5.2 of [RFC6940]. Code points in the range 0x00000001 to 0x7FFFFFFF SHALL be registered via Standards Action [RFC5226]. Code points in the range 0x8000000 to 0xF0000000 SHALL be registered via Expert Review [RFC5226]. Code points in the range 0xF0000001 to 0xFFFFFFFE are reserved for private use via the Kind description mechanism described in Section 11 of [RFC6940]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已经创建了一个“重新加载数据种类ID”注册表。此注册表中的条目是表示数据类型的32位整数，如[RFC6940]第5.2节所述。0x00000001至0x7FFFFFFF范围内的代码点应通过标准行动[RFC5226]进行注册。0x8000000至0xF0000000范围内的代码点应通过专家评审[RFC5226]进行登记。0xF0000001到0xFFFFFE范围内的代码点通过[RFC6940]第11节中描述的种类描述机制保留供私人使用。此注册表的初始内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             +---------------------+------------+-----------+
             | Kind                |    Kind-ID | Reference |
             +---------------------+------------+-----------+
             | INVALID             |        0x0 |  RFC 6940 |
             | TURN-SERVICE        |        0x2 |  RFC 6940 |
             | CERTIFICATE_BY_NODE |        0x3 |  RFC 6940 |
             | CERTIFICATE_BY_USER |       0x10 |  RFC 6940 |
             | Reserved            | 0x7fffffff |  RFC 6940 |
             | Reserved            | 0xfffffffe |  RFC 6940 |
             +---------------------+------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
             +---------------------+------------+-----------+
             | Kind                |    Kind-ID | Reference |
             +---------------------+------------+-----------+
             | INVALID             |        0x0 |  RFC 6940 |
             | TURN-SERVICE        |        0x2 |  RFC 6940 |
             | CERTIFICATE_BY_NODE |        0x3 |  RFC 6940 |
             | CERTIFICATE_BY_USER |       0x10 |  RFC 6940 |
             | Reserved            | 0x7fffffff |  RFC 6940 |
             | Reserved            | 0xfffffffe |  RFC 6940 |
             +---------------------+------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.7. Data Model
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.7. 数据模型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Data Model&#34; registry. Entries in this registry are strings denoting data models, as described in Section 7.2 of [RFC6940]. New entries in this registry SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已经创建了一个“重新加载数据模型”注册表。此注册表中的条目是表示数据模型的字符串，如[RFC6940]第7.2节所述。本登记册中的新条目应通过标准行动[RFC5226]进行登记。此注册表的初始内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                        +------------+-----------+
                        | Data Model | Reference |
                        +------------+-----------+
                        | INVALID    |  RFC 6940 |
                        | SINGLE     |  RFC 6940 |
                        | ARRAY      |  RFC 6940 |
                        | DICTIONARY |  RFC 6940 |
                        | EXP-DATA   |  RFC 6940 |
                        | RESERVED   |  RFC 6940 |
                        +------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                        +------------+-----------+
                        | Data Model | Reference |
                        +------------+-----------+
                        | INVALID    |  RFC 6940 |
                        | SINGLE     |  RFC 6940 |
                        | ARRAY      |  RFC 6940 |
                        | DICTIONARY |  RFC 6940 |
                        | EXP-DATA   |  RFC 6940 |
                        | RESERVED   |  RFC 6940 |
                        +------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-DATA has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXP-DATA的值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.8. Message Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.8. 消息代码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Message Codes&#34; registry. Entries in this registry are 16-bit integers denoting method codes, as described in Section 6.3.3 of [RFC6940]. These codes SHALL be registered via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已经创建了“重新加载消息代码”注册表。该注册表中的条目是16位整数，表示方法代码，如[RFC6940]第6.3.3节所述。这些代码应通过标准行动[RFC5226]进行注册。此注册表的初始内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------------------------------------+----------------+-----------+
   | Message Code Name                   |     Code Value | Reference |
   +-------------------------------------+----------------+-----------+
   | invalidMessageCode                  |            0x0 |  RFC 6940 |
   | probe_req                           |            0x1 |  RFC 6940 |
   | probe_ans                           |            0x2 |  RFC 6940 |
   | attach_req                          |            0x3 |  RFC 6940 |
   | attach_ans                          |            0x4 |  RFC 6940 |
   | Unassigned                          |            0x5 |           |
   | Unassigned                          |            0x6 |           |
   | store_req                           |            0x7 |  RFC 6940 |
   | store_ans                           |            0x8 |  RFC 6940 |
   | fetch_req                           |            0x9 |  RFC 6940 |
   | fetch_ans                           |            0xA |  RFC 6940 |
   | Unassigned (was remove_req)         |            0xB |  RFC 6940 |
   | Unassigned (was remove_ans)         |            0xC |  RFC 6940 |
   | find_req                            |            0xD |  RFC 6940 |
   | find_ans                            |            0xE |  RFC 6940 |
   | join_req                            |            0xF |  RFC 6940 |
   | join_ans                            |           0x10 |  RFC 6940 |
   | leave_req                           |           0x11 |  RFC 6940 |
   | leave_ans                           |           0x12 |  RFC 6940 |
   | update_req                          |           0x13 |  RFC 6940 |
   | update_ans                          |           0x14 |  RFC 6940 |
   | route_query_req                     |           0x15 |  RFC 6940 |
   | route_query_ans                     |           0x16 |  RFC 6940 |
   | ping_req                            |           0x17 |  RFC 6940 |
   | ping_ans                            |           0x18 |  RFC 6940 |
   | stat_req                            |           0x19 |  RFC 6940 |
   | stat_ans                            |           0x1A |  RFC 6940 |
   | Unassigned (was attachlite_req)     |           0x1B |  RFC 6940 |
   | Unassigned (was attachlite_ans)     |           0x1C |  RFC 6940 |
   | app_attach_req                      |           0x1D |  RFC 6940 |
   | app_attach_ans                      |           0x1E |  RFC 6940 |
   | Unassigned (was app_attachlite_req) |           0x1F |  RFC 6940 |
   | Unassigned (was app_attachlite_ans) |           0x20 |  RFC 6940 |
   | config_update_req                   |           0x21 |  RFC 6940 |
   | config_update_ans                   |           0x22 |  RFC 6940 |
   | exp_a_req                           |           0x23 |  RFC 6940 |
   | exp_a_ans                           |           0x24 |  RFC 6940 |
   | exp_b_req                           |           0x25 |  RFC 6940 |
   | exp_b_ans                           |           0x26 |  RFC 6940 |
   | Reserved                            | 0x8000..0xFFFE |  RFC 6940 |
   | error                               |         0xFFFF |  RFC 6940 |
   +-------------------------------------+----------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------------------------------------+----------------+-----------+
   | Message Code Name                   |     Code Value | Reference |
   +-------------------------------------+----------------+-----------+
   | invalidMessageCode                  |            0x0 |  RFC 6940 |
   | probe_req                           |            0x1 |  RFC 6940 |
   | probe_ans                           |            0x2 |  RFC 6940 |
   | attach_req                          |            0x3 |  RFC 6940 |
   | attach_ans                          |            0x4 |  RFC 6940 |
   | Unassigned                          |            0x5 |           |
   | Unassigned                          |            0x6 |           |
   | store_req                           |            0x7 |  RFC 6940 |
   | store_ans                           |            0x8 |  RFC 6940 |
   | fetch_req                           |            0x9 |  RFC 6940 |
   | fetch_ans                           |            0xA |  RFC 6940 |
   | Unassigned (was remove_req)         |            0xB |  RFC 6940 |
   | Unassigned (was remove_ans)         |            0xC |  RFC 6940 |
   | find_req                            |            0xD |  RFC 6940 |
   | find_ans                            |            0xE |  RFC 6940 |
   | join_req                            |            0xF |  RFC 6940 |
   | join_ans                            |           0x10 |  RFC 6940 |
   | leave_req                           |           0x11 |  RFC 6940 |
   | leave_ans                           |           0x12 |  RFC 6940 |
   | update_req                          |           0x13 |  RFC 6940 |
   | update_ans                          |           0x14 |  RFC 6940 |
   | route_query_req                     |           0x15 |  RFC 6940 |
   | route_query_ans                     |           0x16 |  RFC 6940 |
   | ping_req                            |           0x17 |  RFC 6940 |
   | ping_ans                            |           0x18 |  RFC 6940 |
   | stat_req                            |           0x19 |  RFC 6940 |
   | stat_ans                            |           0x1A |  RFC 6940 |
   | Unassigned (was attachlite_req)     |           0x1B |  RFC 6940 |
   | Unassigned (was attachlite_ans)     |           0x1C |  RFC 6940 |
   | app_attach_req                      |           0x1D |  RFC 6940 |
   | app_attach_ans                      |           0x1E |  RFC 6940 |
   | Unassigned (was app_attachlite_req) |           0x1F |  RFC 6940 |
   | Unassigned (was app_attachlite_ans) |           0x20 |  RFC 6940 |
   | config_update_req                   |           0x21 |  RFC 6940 |
   | config_update_ans                   |           0x22 |  RFC 6940 |
   | exp_a_req                           |           0x23 |  RFC 6940 |
   | exp_a_ans                           |           0x24 |  RFC 6940 |
   | exp_b_req                           |           0x25 |  RFC 6940 |
   | exp_b_ans                           |           0x26 |  RFC 6940 |
   | Reserved                            | 0x8000..0xFFFE |  RFC 6940 |
   | error                               |         0xFFFF |  RFC 6940 |
   +-------------------------------------+----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values exp_a_req, exp_a_ans, exp_b_req, and exp_b_ans have been made available for the purposes of experimentation. These values are not meant for vendor-specific use of any sort, and they MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exp_a_req、exp_a_ans、exp_b_req和exp_b_ans值可用于实验目的。这些值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9. Error Codes
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.9. 错误代码
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Error Code&#34; registry. Entries in this registry are 16-bit integers denoting error codes, as described in Section 6.3.3.1 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. The initial contents of this registry are:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已创建“重新加载错误代码”注册表。该注册表中的条目为16位整数，表示错误代码，如[RFC6940]第6.3.3.1节所述。应通过标准行动[RFC5226]定义新条目。此注册表的初始内容包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------------------------------------+----------------+-----------+
   | Error Code Name                     |     Code Value | Reference |
   +-------------------------------------+----------------+-----------+
   | invalidErrorCode                    |            0x0 |  RFC 6940 |
   | Unassigned                          |            0x1 |           |
   | Error_Forbidden                     |            0x2 |  RFC 6940 |
   | Error_Not_Found                     |            0x3 |  RFC 6940 |
   | Error_Request_Timeout               |            0x4 |  RFC 6940 |
   | Error_Generation_Counter_Too_Low    |            0x5 |  RFC 6940 |
   | Error_Incompatible_with_Overlay     |            0x6 |  RFC 6940 |
   | Error_Unsupported_Forwarding_Option |            0x7 |  RFC 6940 |
   | Error_Data_Too_Large                |            0x8 |  RFC 6940 |
   | Error_Data_Too_Old                  |            0x9 |  RFC 6940 |
   | Error_TTL_Exceeded                  |            0xA |  RFC 6940 |
   | Error_Message_Too_Large             |            0xB |  RFC 6940 |
   | Error_Unknown_Kind                  |            0xC |  RFC 6940 |
   | Error_Unknown_Extension             |            0xD |  RFC 6940 |
   | Error_Response_Too_Large            |            0xE |  RFC 6940 |
   | Error_Config_Too_Old                |            0xF |  RFC 6940 |
   | Error_Config_Too_New                |           0x10 |  RFC 6940 |
   | Error_In_Progress                   |           0x11 |  RFC 6940 |
   | Error_Exp_A                         |           0x12 |  RFC 6940 |
   | Error_Exp_B                         |           0x13 |  RFC 6940 |
   | Error_Invalid_Message               |           0x14 |  RFC 6940 |
   | Reserved                            | 0x8000..0xFFFE |  RFC 6940 |
   +-------------------------------------+----------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-------------------------------------+----------------+-----------+
   | Error Code Name                     |     Code Value | Reference |
   +-------------------------------------+----------------+-----------+
   | invalidErrorCode                    |            0x0 |  RFC 6940 |
   | Unassigned                          |            0x1 |           |
   | Error_Forbidden                     |            0x2 |  RFC 6940 |
   | Error_Not_Found                     |            0x3 |  RFC 6940 |
   | Error_Request_Timeout               |            0x4 |  RFC 6940 |
   | Error_Generation_Counter_Too_Low    |            0x5 |  RFC 6940 |
   | Error_Incompatible_with_Overlay     |            0x6 |  RFC 6940 |
   | Error_Unsupported_Forwarding_Option |            0x7 |  RFC 6940 |
   | Error_Data_Too_Large                |            0x8 |  RFC 6940 |
   | Error_Data_Too_Old                  |            0x9 |  RFC 6940 |
   | Error_TTL_Exceeded                  |            0xA |  RFC 6940 |
   | Error_Message_Too_Large             |            0xB |  RFC 6940 |
   | Error_Unknown_Kind                  |            0xC |  RFC 6940 |
   | Error_Unknown_Extension             |            0xD |  RFC 6940 |
   | Error_Response_Too_Large            |            0xE |  RFC 6940 |
   | Error_Config_Too_Old                |            0xF |  RFC 6940 |
   | Error_Config_Too_New                |           0x10 |  RFC 6940 |
   | Error_In_Progress                   |           0x11 |  RFC 6940 |
   | Error_Exp_A                         |           0x12 |  RFC 6940 |
   | Error_Exp_B                         |           0x13 |  RFC 6940 |
   | Error_Invalid_Message               |           0x14 |  RFC 6940 |
   | Reserved                            | 0x8000..0xFFFE |  RFC 6940 |
   +-------------------------------------+----------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The values Error_Exp_A and Error_Exp_B have been made available for the purposes of experimentation. These values are not meant for vendor-specific use of any sort, and they MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值Error_Exp_A和Error_Exp_B已用于实验目的。这些值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.10. Overlay Link Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.10. 覆盖链接类型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Overlay Link Registry&#34;. Entries in this registry are 8-bit integers, as described in Section 6.5.1.1 of [RFC6940]. For more information on the link types defined here, see Section 6.6 of [RFC6940]. New entries SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA创建了“重新加载覆盖链接注册表”。此注册表中的条目为8位整数，如[RFC6940]第6.5.1.1节所述。有关此处定义的链路类型的更多信息，请参见[RFC6940]第6.6节。应通过标准行动[RFC5226]定义新条目。此注册表最初已填充以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 +--------------------+------+-----------+
                 | Protocol           | Code | Reference |
                 +--------------------+------+-----------+
                 | INVALID-PROTOCOL   |    0 |  RFC 6940 |
                 | DTLS-UDP-SR        |    1 |  RFC 6940 |
                 | DTLS-UDP-SR-NO-ICE |    3 |  RFC 6940 |
                 | TLS-TCP-FH-NO-ICE  |    4 |  RFC 6940 |
                 | EXP-LINK           |    5 |  RFC 6940 |
                 | Reserved           |  255 |  RFC 6940 |
                 +--------------------+------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 +--------------------+------+-----------+
                 | Protocol           | Code | Reference |
                 +--------------------+------+-----------+
                 | INVALID-PROTOCOL   |    0 |  RFC 6940 |
                 | DTLS-UDP-SR        |    1 |  RFC 6940 |
                 | DTLS-UDP-SR-NO-ICE |    3 |  RFC 6940 |
                 | TLS-TCP-FH-NO-ICE  |    4 |  RFC 6940 |
                 | EXP-LINK           |    5 |  RFC 6940 |
                 | Reserved           |  255 |  RFC 6940 |
                 +--------------------+------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-LINK has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXP-LINK的值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.11. Overlay Link Protocols
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.11. 覆盖链路协议
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Overlay Link Protocol Registry&#34;. Entries in this registry are strings denoting protocols as described in Section 11.1 of this document and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA创建了“重新加载覆盖链路协议注册表”。本注册表中的条目是表示本文件第11.1节所述协议的字符串，应通过标准行动[RFC5226]进行定义。此注册表最初已填充以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       +---------------+-----------+
                       | Link Protocol | Reference |
                       +---------------+-----------+
                       | TLS           |  RFC 6940 |
                       | EXP-PROTOCOL  |  RFC 6940 |
                       +---------------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                       +---------------+-----------+
                       | Link Protocol | Reference |
                       +---------------+-----------+
                       | TLS           |  RFC 6940 |
                       | EXP-PROTOCOL  |  RFC 6940 |
                       +---------------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value EXP-PROTOCOL has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
EXP-PROTOCOL的值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.12. Forwarding Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.12. 转发选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Forwarding Option Registry&#34;. Entries in this registry are 8-bit integers denoting options, as described in Section 6.3.2.3 of [RFC6940]. Values between 1 and 127 SHALL be defined via Standards Action [RFC5226]. Entries in this registry between 128 and 254 SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已创建“重新加载转发选项注册表”。此注册表中的条目是表示选项的8位整数，如[RFC6940]第6.3.2.3节所述。1和127之间的值应通过标准行动[RFC5226]定义。该注册表中128和254之间的条目应通过所需规范[RFC5226]进行定义。此注册表最初已填充以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              +-------------------------+------+-----------+
              | Forwarding Option       | Code | Reference |
              +-------------------------+------+-----------+
              | invalidForwardingOption |    0 |  RFC 6940 |
              | exp-forward             |    1 |  RFC 6940 |
              | Reserved                |  255 |  RFC 6940 |
              +-------------------------+------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
              +-------------------------+------+-----------+
              | Forwarding Option       | Code | Reference |
              +-------------------------+------+-----------+
              | invalidForwardingOption |    0 |  RFC 6940 |
              | exp-forward             |    1 |  RFC 6940 |
              | Reserved                |  255 |  RFC 6940 |
              +-------------------------+------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value exp-forward has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exp forward的值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.13. Probe Information Types
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.13. 探测信息类型
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Probe Information Type Registry&#34;. Entries are 8-bit integers denoting types as described in Section 6.4.2.5.1 of [RFC6940] and SHALL be defined via Standards Action [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已创建“重新加载探测器信息类型注册表”。条目为8位整数，表示[RFC6940]第6.4.2.5.1节所述的类型，应通过标准行动[RFC5226]进行定义。此注册表最初已填充以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 +--------------------+------+-----------+
                 | Probe Option       | Code | Reference |
                 +--------------------+------+-----------+
                 | invalidProbeOption |    0 |  RFC 6940 |
                 | responsible_set    |    1 |  RFC 6940 |
                 | num_resources      |    2 |  RFC 6940 |
                 | uptime             |    3 |  RFC 6940 |
                 | exp-probe          |    4 |  RFC 6940 |
                 | Reserved           |  255 |  RFC 6940 |
                 +--------------------+------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
                 +--------------------+------+-----------+
                 | Probe Option       | Code | Reference |
                 +--------------------+------+-----------+
                 | invalidProbeOption |    0 |  RFC 6940 |
                 | responsible_set    |    1 |  RFC 6940 |
                 | num_resources      |    2 |  RFC 6940 |
                 | uptime             |    3 |  RFC 6940 |
                 | exp-probe          |    4 |  RFC 6940 |
                 | Reserved           |  255 |  RFC 6940 |
                 +--------------------+------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value exp-probe has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exp探针的值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.14. Message Extensions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.14. 消息扩展
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA has created a &#34;RELOAD Extensions Registry&#34;. Entries in this registry are 8-bit integers denoting extensions as described in Section 6.3.3 of [RFC6940] and SHALL be defined via Specification Required [RFC5226]. This registry has been initially populated with the following values:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA已经创建了一个“重新加载扩展注册表”。该注册表中的条目为8位整数，表示[RFC6940]第6.3.3节所述的扩展，并应通过所需规范[RFC5226]进行定义。此注册表最初已填充以下值：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-----------------------------+--------+-----------+
           | Extensions Name             |   Code | Reference |
           +-----------------------------+--------+-----------+
           | invalidMessageExtensionType |    0x0 |  RFC 6940 |
           | exp-ext                     |    0x1 |  RFC 6940 |
           | Reserved                    | 0xFFFF |  RFC 6940 |
           +-----------------------------+--------+-----------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
           +-----------------------------+--------+-----------+
           | Extensions Name             |   Code | Reference |
           +-----------------------------+--------+-----------+
           | invalidMessageExtensionType |    0x0 |  RFC 6940 |
           | exp-ext                     |    0x1 |  RFC 6940 |
           | Reserved                    | 0xFFFF |  RFC 6940 |
           +-----------------------------+--------+-----------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The value exp-ext has been made available for the purposes of experimentation. This value is not meant for vendor-specific use of any sort, and it MUST NOT be used for operational deployments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
exp ext值已用于实验目的。此值不适用于任何种类的供应商特定用途，也不得用于操作部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15. Reload URI Scheme
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15. 重新加载URI方案
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the scheme for a reload URI, which can be used to refer to either:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍重新加载URI的方案，该方案可用于引用以下任一方案：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A peer, e.g., as used in a certificate (see Section 11.3 of [RFC6940]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对等方，如证书中使用的对等方（见[RFC6940]第11.3节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A resource inside a peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 对等机中的资源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The reload URI is defined using a subset of the URI schema specified in Appendix A of RFC 3986 [RFC3986] and the associated URI Guidelines [RFC4395] per the following ABNF syntax:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
根据以下ABNF语法，使用RFC 3986[RFC3986]附录a中指定的URI模式子集和相关的URI指南[RFC4395]定义重新加载URI：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RELOAD-URI = &#34;reload://&#34; destination &#34;@&#34; overlay &#34;/&#34;
               [specifier]
      destination = 1*HEXDIG
      overlay = reg-name
      specifier = 1*HEXDIG
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
      RELOAD-URI = &#34;reload://&#34; destination &#34;@&#34; overlay &#34;/&#34;
               [specifier]
      destination = 1*HEXDIG
      overlay = reg-name
      specifier = 1*HEXDIG
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The definitions of these productions are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这些产品的定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
destination A hexadecimal-encoded Destination List object (i.e., multiple concatenated Destination objects with no length prefix prior to the object as a whole).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
目标十六进制编码的目标列表对象（即，在对象作为一个整体之前没有长度前缀的多个串联目标对象）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
overlay The name of the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
覆盖覆盖覆盖的名称。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
specifier A hexadecimal-encoded StoredDataSpecifier indicating the data element.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
表示数据元素的十六进制编码的StoredDataSpecifier。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If no specifier is present, this URI addresses the peer which can be reached via the indicated Destination List at the indicated overlay name. If a specifier is present, the URI addresses the data value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果不存在任何说明符，则此URI将寻址可通过指定覆盖名称处的指定目标列表访问的对等方。如果存在说明符，URI将对数据值进行寻址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15.1. URI Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.15.1. URI注册
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following summarizes the information necessary to register the reload URI.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面总结了注册重新加载URI所需的信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI Scheme Name: reload
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI方案名称：重新加载
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Status: permanent
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
地位：永久
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI Scheme Syntax: see Section 14.15 of RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI方案语法：参见RFC 6940第14.15节
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI Scheme Semantics: The reload URI is intended to be used as a reference to a RELOAD peer or resource.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
URI方案语义：重新加载URI旨在用作对重新加载对等方或资源的引用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Considerations: The reload URI is not intended to be human-readable text, so it is encoded entirely in US-ASCII.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码注意事项：重新加载URI不打算是人类可读的文本，因此它完全用US-ASCII编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications/protocols that Use this URI Scheme: The RELOAD protocol described in RFC 6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用此URI方案的应用程序/协议：RFC 6940中描述的重新加载协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability Considerations: See RFC 6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
互操作性注意事项：参见RFC 6940。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Considerations: See RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全注意事项：参见RFC 6940
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Contact:  Cullen Jennings &lt;fluffy@cisco.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Contact:  Cullen Jennings &lt;fluffy@cisco.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Author/Change Controller: IESG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作者/变更控制员：IESG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
References: RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
参考文献：RFC 6940
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.16. Media Type Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.16. 媒体类型注册
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Name: application
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
类型名称：应用程序
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Subtype Name: p2p-overlay+xml
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
子类型名称：p2p覆盖+xml
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Required Parameters: none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所需参数：无
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Optional Parameters: none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可选参数：无
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Considerations: Must be binary encoded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码注意事项：必须是二进制编码的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Security Considerations: This media type is typically not used to transport information that needs to be kept confidential. However, there are cases where it is integrity of the information is important. For these cases, using a digital signature is RECOMMENDED. One way of doing this is specified in RFC 6940. In the case when the media includes a shared-secret element, the contents of the file MUST be kept confidential or else anyone who can see the shared secret can affect the RELOAD overlay network.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安全注意事项：此媒体类型通常不用于传输需要保密的信息。然而，在某些情况下，信息的完整性很重要。对于这些情况，建议使用数字签名。RFC 6940中规定了一种方法。在媒体包含共享机密元素的情况下，文件内容必须保密，否则任何能看到共享机密的人都会影响网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interoperability Considerations: No known interoperability consideration beyond those identified for application/xml in [RFC3023].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
互操作性考虑因素：除了[RFC3023]中为应用程序/xml确定的互操作性考虑因素外，没有已知的互操作性考虑因素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Published Specification: RFC 6940
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已发布规范：RFC 6940
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Applications that Use this Media Type: The type is used to configure the peer-to-peer overlay networks defined in RFC 6940.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用此媒体类型的应用程序：该类型用于配置RFC 6940中定义的对等覆盖网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additional Information: The syntax for this media type is specified in Section 11.1 of [RFC6940]. The contents MUST be valid XML that is compliant with the RELAX NG grammar specified in RFC 6940 and that use the UTF-8[RFC3629] character encoding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
附加信息：[RFC6940]第11.1节规定了该媒体类型的语法。内容必须是符合RFC 6940中指定的RELAX NG语法且使用UTF-8[RFC3629]字符编码的有效XML。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Magic Number(s): none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
幻数：无
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
File Extension(s): relo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
文件扩展名：relo
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Macintosh File Type Code(s): none
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
Macintosh文件类型代码：无
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Person &amp; Email Address to Contact for Further Information: Cullen
   Jennings &lt;fluffy@cisco.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Person &amp; Email Address to Contact for Further Information: Cullen
   Jennings &lt;fluffy@cisco.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Intended Usage: COMMON
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
预期用途：普通
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Restrictions on Usage: None
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用限制：无
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Author: Cullen Jennings &lt;fluffy@cisco.com&gt;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Author: Cullen Jennings &lt;fluffy@cisco.com&gt;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Change Controller: IESG
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
更改控制器：IESG
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17. XML Namespace Registration
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17. XML命名空间注册
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document registers two URIs for the config and config-chord XML namespaces in the IETF XML registry defined in [RFC3688].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档为[RFC3688]中定义的IETF XML注册表中的config和config chord XML名称空间注册了两个URI。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.1. Config URL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.1. 配置URL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   URI: urn:ietf:params:xml:ns:p2p:config-base
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   URI: urn:ietf:params:xml:ns:p2p:config-base
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registrant Contact: IESG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注册人联系人：IESG。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML: N/A, the requested URIs are XML namespaces
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML：不适用，请求的URI是XML名称空间
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.2. Config Chord URL
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
14.17.2. 配置弦URL
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   URI: urn:ietf:params:xml:ns:p2p:config-chord
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   URI: urn:ietf:params:xml:ns:p2p:config-chord
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Registrant Contact: The IESG.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注册人联系人：IESG。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML: N/A, the requested URIs are XML namespaces
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
XML：不适用，请求的URI是XML名称空间
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
15. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification is a merge of the &#34;REsource LOcation And Discovery (RELOAD)&#34; document by David A. Bryan, Marcia Zangrilli, and Bruce B. Lowekamp; the &#34;Address Settlement by Peer to Peer&#34; document by Cullen Jennings, Jonathan Rosenberg, and Eric Rescorla; the &#34;Security Extensions for RELOAD&#34; document by Bruce B. Lowekamp and James Deverick; the &#34;A Chord-based DHT for Resource Lookup in P2PSIP&#34; by Marcia Zangrilli and David A. Bryan; and the Peer-to-Peer Protocol (P2PP) document by Salman A. Baset, Henning Schulzrinne, and Marcin Matuszewski. Thanks to the authors of [RFC5389] for text included from that document. Vidya Narayanan provided many comments and improvements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本规范合并了David a.Bryan、Marcia Zangrilli和Bruce B.Lowekamp的“资源定位和发现（重新加载）”文档；Cullen Jennings、Jonathan Rosenberg和Eric Rescorla的“通过点对点的地址结算”文档；Bruce B.Lowekamp和James Deverick编写的“重新加载的安全扩展”文档；Marcia Zangrilli和David A.Bryan的“P2PSIP中用于资源查找的基于和弦的DHT”；以及Salman A.Baset、Henning Schulzrinne和Marcin Matuszewski编写的对等协议（P2PP）文档。感谢[RFC5389]的作者提供该文档中包含的文本。维迪亚·纳拉亚南提供了许多意见和改进。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ideas and text for the Chord-specific extension data to the Leave mechanisms were provided by Jouni Maenpaa, Gonzalo Camarillo, and Jani Hautakorpi.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jouni Maenpaa、Gonzalo Camarillo和Jani Hautakorpi提供了左机制和弦特定延伸数据的想法和文本。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks to the many people who contributed, including Ted Hardie, Michael Chen, Dan York, Das Saumitra, Lyndsay Campbell, Brian Rosen, David Bryan, Dave Craig, and Julian Cain. Extensive last call comments were provided by Jouni Maenpaa, Roni Even, Gonzalo Camarillo, Ari Keranen, John Buford, Michael Chen, Frederic-Philippe Met, Mary Barnes, Roland Bless, David Bryan, and Polina Goltsman. Special thanks to Marc Petit-Huguenin, who provided an amazing amount of detailed review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
感谢许多做出贡献的人，包括泰德·哈迪、迈克尔·陈、丹·约克、达斯·索米特拉、林赛·坎贝尔、布赖恩·罗森、大卫·布莱恩、戴夫·克雷格和朱利安·凯恩。Jouni Maenpa、Roni Even、Gonzalo Camarillo、Ari Keranen、John Buford、Michael Chen、Frederic Philippe Met、Mary Barnes、Roland Bless、David Bryan和Polina Goltsman提供了大量的最后通话评论。特别感谢Marc Petit Huguein，他提供了大量的详细评论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Dean Willis and Marc Petit-Huguenin helped resolve and provided text to fix many comments received during the IESG review.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
迪安·威利斯（Dean Willis）和马克·佩蒂特·胡格宁（Marc Petit Huguenin）帮助解决了IESG审查期间收到的许多意见，并提供了文本，以修正这些意见。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OASIS.relax_ng] Bray, T. and M. Murata, &#34;RELAX NG Specification&#34;, December 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[OASIS.RELAXNG]Bray，T.和M.Murata，“RELAXNG规范”，2001年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1918] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, &#34;Address Allocation for Private Internets&#34;, BCP 5, RFC 1918, February 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1918]Rekhter，Y.，Moskowitz，R.，Karrenberg，D.，Groot，G.，和E.Lear，“私人互联网地址分配”，BCP 5，RFC 1918，1996年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2388] Masinter, L., &#34;Returning Values from Forms: multipart/ form-data&#34;, RFC 2388, August 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2388]Masinter，L.“从表单返回值：多部分/表单数据”，RFC 23881998年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2585] Housley, R. and P. Hoffman, &#34;Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP&#34;, RFC 2585, May 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2585]Housley，R.和P.Hoffman，“Internet X.509公钥基础设施操作协议：FTP和HTTP”，RFC 25851999年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, &#34;A DNS RR for specifying the location of services (DNS SRV)&#34;, RFC 2782, February 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2782]Gulbrandsen，A.，Vixie，P.和L.Esibov，“用于指定服务位置（DNS SRV）的DNS RR”，RFC 2782，2000年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818] Rescorla, E., &#34;HTTP Over TLS&#34;, RFC 2818, May 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2818]Rescorla，E.，“TLS上的HTTP”，RFC2818，2000年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3023] Murata, M., St. Laurent, S., and D. Kohn, &#34;XML Media Types&#34;, RFC 3023, January 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3023]Murata，M.，St.Laurent，S.，和D.Kohn，“XML媒体类型”，RFC 3023，2001年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3174] Eastlake, D. and P. Jones, &#34;US Secure Hash Algorithm 1 (SHA1)&#34;, RFC 3174, September 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3174]Eastlake，D.和P.Jones，“美国安全哈希算法1（SHA1）”，RFC 3174，2001年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3339] Klyne, G., Ed. and C. Newman, &#34;Date and Time on the Internet: Timestamps&#34;, RFC 3339, July 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3339]Klyne，G.，Ed.和C.Newman，“互联网上的日期和时间：时间戳”，RFC33392002年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3447] Jonsson, J. and B. Kaliski, &#34;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1&#34;, RFC 3447, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3447]Jonsson，J.和B.Kaliski，“公钥密码标准（PKCS）#1:RSA密码规范版本2.1”，RFC 3447，2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629] Yergeau, F., &#34;UTF-8, a transformation format of ISO 10646&#34;, STD 63, RFC 3629, November 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3629]Yergeau，F.，“UTF-8，ISO 10646的转换格式”，STD 63，RFC 3629，2003年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, &#34;Uniform Resource Identifier (URI): Generic Syntax&#34;, STD 66, RFC 3986, January 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3986]Berners Lee，T.，Fielding，R.，和L.Masinter，“统一资源标识符（URI）：通用语法”，STD 66，RFC 3986，2005年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4279] Eronen, P. and H. Tschofenig, &#34;Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)&#34;, RFC 4279, December 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4279]Eronen，P.和H.Tschofenig，“用于传输层安全（TLS）的预共享密钥密码套件”，RFC 4279，2005年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4395] Hansen, T., Hardie, T., and L. Masinter, &#34;Guidelines and Registration Procedures for New URI Schemes&#34;, BCP 35, RFC 4395, February 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4395]Hansen，T.，Hardie，T.，和L.Masinter，“新URI方案的指南和注册程序”，BCP 35，RFC 4395，2006年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648] Josefsson, S., &#34;The Base16, Base32, and Base64 Data Encodings&#34;, RFC 4648, October 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4648]Josefsson，S.，“Base16、Base32和Base64数据编码”，RFC4648，2006年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 5226, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5226]Narten，T.和H.Alvestrand，“在RFCs中编写IANA注意事项部分的指南”，BCP 26，RFC 5226，2008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245] Rosenberg, J., &#34;Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols&#34;, RFC 5245, April 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5245]Rosenberg，J.，“交互式连接建立（ICE）：提供/应答协议的网络地址转换器（NAT）遍历协议”，RFC 52452010年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246] Dierks, T. and E. Rescorla, &#34;The Transport Layer Security (TLS) Protocol Version 1.2&#34;, RFC 5246, August 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5246]Dierks，T.和E.Rescorla，“传输层安全（TLS）协议版本1.2”，RFC 5246，2008年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5272] Schaad, J. and M. Myers, &#34;Certificate Management over CMS (CMC)&#34;, RFC 5272, June 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5272]Schaad，J.和M.Myers，“CMS上的证书管理（CMC）”，RFC 52722008年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5273] Schaad, J. and M. Myers, &#34;Certificate Management over CMS (CMC): Transport Protocols&#34;, RFC 5273, June 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5273]Schaad，J.和M.Myers，“CMS上的证书管理（CMC）：传输协议”，RFC 5273，2008年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, &#34;Session Traversal Utilities for NAT (STUN)&#34;, RFC 5389, October 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5389]Rosenberg，J.，Mahy，R.，Matthews，P.，和D.Wing，“NAT的会话遍历实用程序（STUN）”，RFC 5389，2008年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405] Eggert, L. and G. Fairhurst, &#34;Unicast UDP Usage Guidelines for Application Designers&#34;, BCP 145, RFC 5405, November 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5405]Eggert，L.和G.Fairhurst，“应用程序设计者的单播UDP使用指南”，BCP 145，RFC 5405，2008年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5766] Mahy, R., Matthews, P., and J. Rosenberg, &#34;Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)&#34;, RFC 5766, April 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5766]Mahy，R.，Matthews，P.，和J.Rosenberg，“使用NAT周围的中继进行遍历（TURN）：NAT（STUN）会话遍历实用程序的中继扩展”，RFC 5766，2010年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5952] Kawamura, S. and M. Kawashima, &#34;A Recommendation for IPv6 Address Text Representation&#34;, RFC 5952, August 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5952]Kawamura，S.和M.Kawashima，“IPv6地址文本表示的建议”，RFC 59522010年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6091] Mavrogiannopoulos, N. and D. Gillmor, &#34;Using OpenPGP Keys for Transport Layer Security (TLS) Authentication&#34;, RFC 6091, February 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6091]Mavrogiannopoulos，N.和D.Gillmor，“使用OpenPGP密钥进行传输层安全（TLS）认证”，RFC 60912011年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6234] Eastlake, D. and T. Hansen, &#34;US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)&#34;, RFC 6234, May 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6234]Eastlake，D.和T.Hansen，“美国安全哈希算法（基于SHA和SHA的HMAC和HKDF）”，RFC 6234，2011年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, &#34;Computing TCP&#39;s Retransmission Timer&#34;, RFC 6298, June 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6298]Paxson，V.，Allman，M.，Chu，J.，和M.Sargent，“计算TCP的重传计时器”，RFC 62982011年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347] Rescorla, E. and N. Modadugu, &#34;Datagram Transport Layer Security Version 1.2&#34;, RFC 6347, January 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6347]Rescorla，E.和N.Modadugu，“数据报传输层安全版本1.2”，RFC 6347，2012年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-xmlschema-2-20041028] Malhotra, A. and P. Biron, &#34;XML Schema Part 2: Datatypes Second Edition&#34;, World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, &lt;http://www.w3.org/TR/2004/REC-xmlschema-2-20041028&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C.REC-xmlschema-2-20041028]Malhotra，A.和P.Biron，“XML模式第2部分：数据类型第二版”，万维网联盟建议REC-xmlschema-2-20041028，2004年10月&lt;http://www.w3.org/TR/2004/REC-xmlschema-2-20041028&gt;.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[w3c-xml-namespaces] Bray, T., Hollander, D., Layman, A., Tobin, R., and University of Edinburgh and W3C, &#34;Namespaces in XML 1.0 (Third Edition)&#34;, December 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[W3C XML命名空间] BRAY，T.，Hollander，D，Layman，A.托宾，R，爱丁堡大学和W3C，“XML 1（第三版）中的命名空间”，2008年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
16.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chord] Stoica, I., Morris, R., Liben-Nowell, D., Karger, D., Kaashoek, M., Dabek, F., and H. Balakrishnan, &#34;Chord: A Scalable Peer-to-peer Lookup Protocol for Internet Applications&#34;, IEEE/ACM Transactions on Networking Volume 11, Issue 1, 17-32, Feb 2003, 2001.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Chord]Stoica，I.，Morris，R.，Liben Nowell，D.，Karger，D.，Kaashoek，M.，Dabek，F.，和H.Balakrishnan，“Chord：互联网应用的可扩展对等查找协议”，IEEE/ACM网络交易卷11，第1期，第17-32期，2003年2月，2001年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHT-RELOAD] Maenpaa, J. and G. Camarillo, &#34;A Self-tuning Distributed Hash Table (DHT) for REsource LOcation And Discovery (RELOAD)&#34;, Work in Progress, August 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHT-RELOAD]Maenpaa，J.和G.Camarillo，“用于资源定位和发现（RELOAD）的自调优分布式哈希表（DHT）”，正在进行的工作，2013年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Eclipse] Singh, A., Ngan, T., Druschel, T., and D. Wallach, &#34;Eclipse Attacks on Overlay Networks: Threats and Defenses&#34;, INFOCOM 2006, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Eclipse]Singh，A.，Ngan，T.，Druschel，T.，和D.Wallach，“重叠网络上的Eclipse攻击：威胁和防御”，INFOCOM 2006，2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2P-DIAGNOSTICS] Song, H., Jiang, X., Even, R., and D. Bryan, &#34;P2P Overlay Diagnostics&#34;, Work in Progress, August 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2P-DIAGNOSTICS]Song，H.，Jiang，X.，Even，R.，和D.Bryan，“P2P覆盖诊断”，正在进行的工作，2013年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIP-RELAY] Zong, N., Jiang, X., Even, R., and Y. Zhang, &#34;An extension to RELOAD to support Relay Peer Routing&#34;, Work in Progress, October 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIP-RELAY]Zong，N.，Jiang，X.，Even，R.，和Y.Zhang，“支持中继对等路由的重新加载扩展”，正在进行的工作，2013年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDIR-RELOAD] Maenpaa, J. and G. Camarillo, &#34;Service Discovery Usage for REsource LOcation And Discovery (RELOAD)&#34;, Work in Progress, August 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[REDIR-RELOAD]Maenpaa，J.和G.Camarillo，“资源定位和发现的服务发现使用（重新加载）”，正在进行的工作，2013年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035] Mockapetris, P., &#34;Domain names - implementation and specification&#34;, STD 13, RFC 1035, November 1987.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1035]Mockapetris，P.，“域名-实现和规范”，STD 13，RFC 1035，1987年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122] Braden, R., &#34;Requirements for Internet Hosts - Communication Layers&#34;, STD 3, RFC 1122, October 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC1122]Braden，R.，“互联网主机的要求-通信层”，标准3，RFC 1122，1989年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2311] Dusse, S., Hoffman, P., Ramsdell, B., Lundblade, L., and L. Repka, &#34;S/MIME Version 2 Message Specification&#34;, RFC 2311, March 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2311]Dusse，S.，Hoffman，P.，Ramsdell，B.，Lundblade，L.，和L.Repka，“S/MIME版本2消息规范”，RFC 23111998年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3688] Mealling, M., &#34;The IETF XML Registry&#34;, BCP 81, RFC 3688, January 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC3688]Mealling，M.“IETF XML注册表”，BCP 81，RFC 3688，2004年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4013] Zeilenga, K., &#34;SASLprep: Stringprep Profile for User Names and Passwords&#34;, RFC 4013, February 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4013]Zeilenga，K.，“SASLprep：用户名和密码的Stringprep配置文件”，RFC40113，2005年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4086]Eastlake，D.，Schiller，J.，和S.Crocker，“安全的随机性要求”，BCP 106，RFC 4086，2005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4145] Yon, D. and G. Camarillo, &#34;TCP-Based Media Transport in the Session Description Protocol (SDP)&#34;, RFC 4145, September 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4145]Yon，D.和G.Camarillo，“会话描述协议（SDP）中基于TCP的媒体传输”，RFC 41452005年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340] Kohler, E., Handley, M., and S. Floyd, &#34;Datagram Congestion Control Protocol (DCCP)&#34;, RFC 4340, March 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4340]Kohler，E.，Handley，M.和S.Floyd，“数据报拥塞控制协议（DCCP）”，RFC 43402006年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787] Audet, F. and C. Jennings, &#34;Network Address Translation (NAT) Behavioral Requirements for Unicast UDP&#34;, BCP 127, RFC 4787, January 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4787]Audet，F.和C.Jennings，“单播UDP的网络地址转换（NAT）行为要求”，BCP 127，RFC 4787，2007年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960] Stewart, R., &#34;Stream Control Transmission Protocol&#34;, RFC 4960, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC4960]Stewart，R.，“流控制传输协议”，RFC 49602007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5054] Taylor, D., Wu, T., Mavrogiannopoulos, N., and T. Perrin, &#34;Using the Secure Remote Password (SRP) Protocol for TLS Authentication&#34;, RFC 5054, November 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5054]Taylor，D.，Wu，T.，Mavrogiannopoulos，N.，和T.Perrin，“使用安全远程密码（SRP）协议进行TLS身份验证”，RFC 5054，2007年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5095] Abley, J., Savola, P., and G. Neville-Neil, &#34;Deprecation of Type 0 Routing Headers in IPv6&#34;, RFC 5095, December 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5095]Abley，J.，Savola，P.，和G.Neville Neil，“IPv6中0型路由头的弃用”，RFC 5095，2007年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5201] Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &#34;Host Identity Protocol&#34;, RFC 5201, April 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5201]Moskowitz，R.，Nikander，P.，Jokela，P.，和T.Henderson，“主机身份协议”，RFC 52012008年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &#34;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile&#34;, RFC 5280, May 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5280]Cooper，D.，Santesson，S.，Farrell，S.，Boeyen，S.，Housley，R.，和W.Polk，“Internet X.509公钥基础设施证书和证书撤销列表（CRL）配置文件”，RFC 52802008年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5694] Camarillo, G., Ed., and IAB, &#34;Peer-to-Peer (P2P) Architecture: Definition, Taxonomies, Examples, and Applicability&#34;, RFC 5694, November 2009.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5694]Camarillo，G.，Ed.，和IAB，“对等（P2P）架构：定义、分类、示例和适用性”，RFC 56942009年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5765] Schulzrinne, H., Marocco, E., and E. Ivov, &#34;Security Issues and Solutions in Peer-to-Peer Systems for Realtime Communications&#34;, RFC 5765, February 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5765]Schulzrinne，H.，Marocco，E.，和E.Ivov，“用于实时通信的对等系统中的安全问题和解决方案”，RFC 57652010年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5785] Nottingham, M. and E. Hammer-Lahav, &#34;Defining Well-Known Uniform Resource Identifiers (URIs)&#34;, RFC 5785, April 2010.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC5785]诺丁汉，M.和E.Hammer Lahav，“定义众所周知的统一资源标识符（URI）”，RFC 5785，2010年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6079] Camarillo, G., Nikander, P., Hautakorpi, J., Keranen, A., and A. Johnston, &#34;HIP BONE: Host Identity Protocol (HIP) Based Overlay Networking Environment (BONE)&#34;, RFC 6079, January 2011.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6079]Camarillo，G.，Nikander，P.，Hautakorpi，J.，Keranen，A.，和A.Johnston，“HIP-BONE：基于主机身份协议（HIP）的覆盖网络环境（BONE）”，RFC 6079，2011年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6544] Rosenberg, J., Keranen, A., Lowekamp, B., and A. Roach, &#34;TCP Candidates with Interactive Connectivity Establishment (ICE)&#34;, RFC 6544, March 2012.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC6544]Rosenberg，J.，Keranen，A.，Lowekamp，B.，和A.Roach，“具有交互式连接建立（ICE）的TCP候选者”，RFC 65442012年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7086] Keranen, A., Camarillo, G., and J. Maenpaa, &#34;Host Identity Protocol-Based Overlay Networking Environment (HIP BONE) Instance Specification for REsource LOcation And Discovery (RELOAD)&#34;, RFC 7086, January 2014.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC7086]Keranen，A.，Camarillo，G.，和J.Maenpaa，“基于主机身份协议的覆盖网络环境（HIP-BONE）资源定位和发现（重新加载）实例规范”，RFC 7086，2014年1月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SIP-RELOAD] Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., Schulzrinne, H., and T. Schmidt, &#34;A SIP Usage for RELOAD&#34;, Work in Progress, July 2013.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SIP-RELOAD]詹宁斯，C.，洛维坎普，B.，雷科拉，E.，贝斯特，S.，舒尔兹林内，H.，和T.施密特，“重新加载的SIP使用”，正在进行的工作，2013年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sybil] Douceur, J., &#34;The Sybil Attack&#34;, IPTPS 02, March 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Sybil]Douceur，J.，“Sybil攻击”，IPTPS 02，2002年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UnixTime] Wikipedia, &#34;Unix Time&#34;, 2013, &lt;http://en.wikipedia.org/w/ index.php?title=Unix_time&amp;oldid=551527446&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[UnixTime]维基百科，“Unix时代”，2013年&lt;http://en.wikipedia.org/w/ index.php？title=Unix\u time&amp;oldid=551527446&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[bryan-design-hotp2p08] Bryan, D., Lowekamp, B., and M. Zangrilli, &#34;The Design of a Versatile, Secure P2PSIP Communications Architecture for the Public Internet&#34;, Hot-P2P&#39;08, 2008.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[bryan-design-hotp2p08]bryan，D.，Lowekamp，B.，和M.Zangrilli，“公共互联网多功能安全P2PSIP通信架构的设计”，Hot-P2P&#39;08，2008年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[handling-churn-usenix04] Rhea, S., Geels, D., Roscoe, T., and J. Kubiatowicz, &#34;Handling Churn in a DHT&#34;, In Proc. of the USENIX Annual Technical Conference June 2004 USENIX 2004, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[handling-Chorn-Usenix 04]Rhea，S.，Geels，D.，Roscoe，T.，和J.Kubiatowicz，“DHT中的搅拌处理”，在Proc。在2004年6月的USENIX年度技术会议上，USENIX 2004，2004。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[lookups-churn-p2p06] Wu, D., Tian, Y., and K. Ng, &#34;Analytical Study on Improving DHT Lookup Performance under Churn&#34;, IEEE P2P&#39;06, 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[lookups-Chorn-p2p06]Wu，D.，Tian，Y.，和K.Ng，“在搅动下改进DHT查找性能的分析研究”，IEEE P2P&#39;06，2006年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[minimizing-churn-sigcomm06] Godfrey, P., Shenker, S., and I. Stoica, &#34;Minimizing Churn in Distributed Systems&#34;, SIGCOMM 2006, 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[Minimized-Chorn-sigcomm06]Godfrey，P.，Shenker，S.，和I.Stoica，“分布式系统中的最小搅动”，SIGCOMM 2006，2006年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[non-transitive-dhts-worlds05] Freedman, M., Lakshminarayanan, K., Rhea, S., and I. Stoica, &#34;Non-Transitive Connectivity and DHTs&#34;, WORLDS&#39;05, 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[non-transitive-dhts-worlds05]Freedman，M.，Lakshminarayanan，K.，Rhea，S.，和I.Stoica，“非传递性连接和dhts”，世界杂志2005年5月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[opendht-sigcomm05] Rhea, S., Godfrey, B., Karp, B., Kubiatowicz, J., Ratnasamy, S., Shenker, S., Stoica, I., and H. Yu, &#34;OpenDHT: A Public DHT and its Uses&#34;, SIGCOMM&#39;05, 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[opendht-SIGCOM05]Rhea，S.，Godfrey，B.，Karp，B.，Kubiatowicz，J.，Ratnasamy，S.，Shenker，S.，Stoica，I.，和H.Yu，“opendht:公共DHT及其用途”，SIGCOM05，2005年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[vulnerabilities-acsac04] Srivatsa, M. and L. Liu, &#34;Vulnerabilities and Security Threats in Structured Peer-to-Peer Systems: A Quantitative Analysis&#34;, ACSAC 2004, 2004.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[漏洞-acsac04]Srivatsa，M.和L.Liu，“结构化对等系统中的漏洞和安全威胁：定量分析”，ACSAC 2004年，2004年。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiChord] Wikipedia, &#34;Chord (peer-to-peer)&#34;, 2013, &lt;http://en.wikipedia.org/w/ index.php?title=Chord_%28peer-to-peer%29&amp;oldid=549516287&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[维基和弦]维基百科，“和弦（点对点）”，2013年&lt;http://en.wikipedia.org/w/ index.php？title=Chord_u%28对等%29&amp;oldid=549516287&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiKBR] Wikipedia, &#34;Key-based routing&#34;, 2013, &lt;en.wikipedia.org/w/ index.php?title=Key-based_routing&amp;oldid=543850833&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiKBR]维基百科，“基于密钥的路由”，2013年，&lt;en.Wikipedia.org/w/index.php？title=Key-based_-routing&amp;oldid=543850833&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiSkiplist] Wikipedia, &#34;Skip list&#34;, 2013, &lt;http://en.wikipedia.org/w/ index.php?title=Skip_list&amp;oldid=551304213&gt;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[wikiSkiplist]维基百科，“跳过列表”，2013年&lt;http://en.wikipedia.org/w/ index.php？title=Skip_list&amp;oldid=551304213&gt;。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
Appendix A. Routing Alternatives
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
附录A.路线选择
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Significant discussion has been focused on the selection of a routing algorithm for P2PSIP. This section discusses the motivations for selecting symmetric recursive routing for RELOAD and describes the extensions that would be required to support additional routing algorithms.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有意义的讨论集中在P2PSIP路由算法的选择上。本节讨论选择对称递归路由进行重新加载的动机，并描述支持其他路由算法所需的扩展。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. Iterative vs. Recursive
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.1. 迭代与递归
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Iterative routing has a number of advantages. It is easier to debug, consumes fewer resources on intermediate peers, and allows the querying peer to identify and route around misbehaving peers [non-transitive-dhts-worlds05]. However, in the presence of NATs, iterative routing is intolerably expensive, because a new connection must be established for each hop (using ICE) [bryan-design-hotp2p08].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
迭代路由有许多优点。它更容易调试，在中间对等点上消耗更少的资源，并允许查询对等点识别和路由行为不正常的对等点[non-transitive-dhts-worlds05]。然而，在存在NAT的情况下，迭代路由的代价是无法忍受的，因为必须为每个跃点建立新的连接（使用ICE）[bryan-design-hotp2p08]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Iterative routing is supported through the RouteQuery mechanism and is primarily intended for debugging. It also allows the querying peer to evaluate the routing decisions made by the peers at each hop, consider alternatives, and perhaps detect at what point the forwarding path fails.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通过RouteQuery机制支持迭代路由，主要用于调试。它还允许查询对等体在每个跳点上评估对等体所做出的路由决定，考虑替代方案，并且可能检测转发路径在什么点上失败。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. Symmetric vs. Forward Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.2. 对称与正向响应
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An alternative to the symmetric recursive routing method used by RELOAD is forward-only routing, where the response is routed to the requester as if it were a new message initiated by the responder. (In the previous example, Z sends the response to A as if it were sending a request.) Forward-only routing requires no state in either the message or intermediate peers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
重载使用的对称递归路由方法的另一种替代方法是仅向前路由，其中响应被路由到请求者，就像它是由响应者发起的新消息一样。（在上一个示例中，Z向A发送响应，就像它发送请求一样。）仅转发路由不需要消息或中间对等方中的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The drawback of forward-only routing is that it does not work when the overlay is unstable. For example, if A is in the process of joining the overlay and is sending a Join request to Z, it is not yet reachable via forward-only routing. Even if it is established in the overlay, if network failures produce temporary instability, A may not be reachable (and may be trying to stabilize its network connectivity via Attach messages).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
仅前向路由的缺点是，当覆盖不稳定时，它不起作用。例如，如果A正在加入覆盖，并且正在向Z发送加入请求，那么它还不能通过仅转发路由到达。即使是在覆盖中建立的，如果网络故障导致暂时不稳定，A也可能无法访问（并且可能试图通过附加消息稳定其网络连接）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, forward-only responses are less likely to reach the querying peer than symmetric recursive ones are, because the forward path is more likely to have a failed peer than is the request path (which was just tested to route the request) [non-transitive-dhts-worlds05].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，与对称递归响应相比，仅前向响应到达查询对等方的可能性较小，因为前向路径比请求路径更可能有一个失败的对等方（该请求路径刚刚经过测试以路由请求）[non-transitive-dhts-worlds05]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension to RELOAD that supports forward-only routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use forward-only routing and when to fallback to symmetric routing, we have chosen not to include it as an option at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
支持仅前向路由但依赖于作为回退的对称响应的重新加载扩展是可能的，但由于确定何时使用仅前向路由以及何时回退到对称路由的复杂性，我们选择在此时不将其作为选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. Direct Response
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.3. 直接反应
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another routing option is direct response routing, in which the response is returned directly to the querying node. In the previous example, if A encodes its IP address in the request, then Z can simply deliver the response directly to A. In the absence of NATs or other connectivity issues, this is the optimal routing technique.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
另一个路由选项是直接响应路由，其中响应直接返回到查询节点。在前面的示例中，如果A在请求中编码其IP地址，那么Z可以直接将响应传递给A。在没有NAT或其他连接问题的情况下，这是最佳路由技术。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The challenge of implementing direct response routing is the presence of NATs. There are a number of complexities that must be addressed. In this discussion, we will continue our assumption that A issued the request and Z is generating the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现直接响应路由的挑战是NAT的存在。必须解决许多复杂问题。在本次讨论中，我们将继续假设A发出了请求，Z生成响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The IP address listed by A may be unreachable, either due to NAT or firewall rules. Therefore, a direct response technique must fallback to symmetric response [non-transitive-dhts-worlds05]. The hop-by-hop ACKs used by RELOAD allow Z to determine when A has received the message (and the TLS negotiation will provide earlier confirmation that A is reachable), but this fallback requires a timeout that will increase the response latency whenever A is not reachable from Z.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 由于NAT或防火墙规则，A列出的IP地址可能无法访问。因此，直接响应技术必须回退到对称响应[non-transitive-dhts-worlds05]。RELOAD使用的逐跳ACK允许Z确定A何时收到消息（TLS协商将提供A可访问的早期确认），但此回退需要超时，这将在A无法从Z访问时增加响应延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o Whenever A is behind a NAT it, will have multiple candidate IP addresses, each of which must be advertised to ensure connectivity. Therefore, Z will need to attempt multiple connections to deliver the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 无论何时，NAT后面都会有多个候选IP地址，每个候选IP地址都必须公布以确保连接性。因此，Z需要尝试多个连接来传递响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o One (or all) of A&#39;s candidate addresses may route from Z to a different device on the Internet. In the worst case, these nodes may actually be running RELOAD on the same port. Therefore, it is absolutely necessary to establish a secure connection to authenticate A before delivering the response. This step diminishes the efficiency of direct response routing, because multiple round-trips are required before the message can be delivered.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o A的一个（或全部）候选地址可以从Z路由到Internet上的不同设备。在最坏的情况下，这些节点可能实际上正在同一端口上运行重载。因此，在传递响应之前，绝对有必要建立一个安全连接来验证。此步骤降低了直接响应路由的效率，因为在传递消息之前需要多次往返。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o If A is behind a NAT and does not have a connection already established with Z, there are only two ways the direct response will work. The first is that A and Z must both be behind the same NAT, in which case the NAT is not involved. In the more common case, when Z is outside A&#39;s NAT, the response will be received only if A&#39;s NAT implements endpoint-independent filtering. As the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 如果A在NAT后面，并且没有与Z建立连接，那么直接响应只有两种方式可以工作。第一个是A和Z必须都位于同一个NAT后面，在这种情况下，NAT不涉及。在更常见的情况下，当Z位于A的NAT之外时，只有在A的NAT实现端点独立过滤时，才会收到响应。作为
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
choice of filtering mode conflates application transparency with security [RFC4787] and no clear recommendation is available, the prevalence of this feature in future devices remains unclear.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
过滤模式的选择将应用程序透明性与安全性混为一谈[RFC4787]，并且没有明确的建议可用，这一功能在未来设备中的普遍性仍不清楚。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension to RELOAD that supports direct response routing but relies on symmetric responses as a fallback would be possible, but due to the complexities of determining when to use direct response routing and when to fallback to symmetric routing, and the reduced performance for responses to peers behind restrictive NATs, we have chosen not to include it as an option at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
支持直接响应路由但依赖对称响应作为回退的重新加载扩展是可能的，但由于确定何时使用直接响应路由和何时回退到对称路由的复杂性，以及限制性NAT后对对等方的响应性能降低，目前，我们选择不将其作为一个选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. Relay Peers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.4. 中继节点
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIP-RELAY] has proposed implementing a form of direct response by having A identify a peer, Q, that will be directly reachable by any other peer. A uses Attach to establish a connection with Q and advertises Q&#39;s IP address in the request sent to Z. Z sends the response to Q, which relays it to A. This then reduces the latency to two hops, and Z is negotiating a secure connection to Q.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[P2PSIP-RELAY]建议通过使用一个标识对等方Q来实现一种形式的直接响应，该对等方Q将可由任何其他对等方直接访问。A使用Attach与Q建立连接，并在发送给Z的请求中公布Q的IP地址。Z将响应发送给Q，Q将其转发给A。这将延迟减少到两跳，Z正在协商与Q的安全连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This technique relies on the relative population of nodes such as A that require relay peers and peers such as Q that are capable of serving as a relay peer. It also requires nodes to be able to identify which category they are in. This identification problem has turned out to be hard to solve and is still an open area of exploration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该技术依赖于需要中继对等点的节点（如A）和能够充当中继对等点的对等点（如Q）的相对数量。它还要求节点能够识别它们所属的类别。事实证明，这个识别问题很难解决，仍然是一个有待探索的领域。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An extension to RELOAD that supports relay peers is possible, but due to the complexities of implementing such an alternative, we have not added such a feature to RELOAD at this point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
支持中继对等点的重新加载扩展是可能的，但是由于实现这种替代方案的复杂性，我们现在还没有添加这样的功能来重新加载。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A concept similar to relay peers, essentially choosing a relay peer at random, has previously been suggested to solve problems of pair-wise non-transitivity [non-transitive-dhts-worlds05], but deterministic filtering provided by NATs makes random relay peers no more likely to work than the responding peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
先前有人提出了一个类似于中继对等点的概念，本质上是随机选择中继对等点，以解决成对不可传递性问题[non-transitive-dhts-worlds05]，但NATs提供的确定性过滤使得随机中继对等点不比响应对等点更可能工作。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. Symmetric Route Stability
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
A.5. 对称路由稳定性
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A common concern about symmetric recursive routing has been that one or more peers along the request path may fail before the response is received. The significance of this problem essentially depends on the response latency of the overlay. An overlay that produces slow responses will be vulnerable to churn, whereas responses that are delivered very quickly are vulnerable only to failures that occur over that small interval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
关于对称递归路由的一个常见问题是，在收到响应之前，沿着请求路径的一个或多个对等点可能会失败。这个问题的重要性本质上取决于覆盖的响应延迟。产生缓慢响应的覆盖很容易受到搅动的影响，而交付速度非常快的响应只会在很短的时间间隔内发生故障。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The other aspect of this issue is whether the request itself can be successfully delivered. Assuming typical connection maintenance intervals, the time period between the last maintenance and the request being sent will be orders of magnitude greater than the delay between the request being forwarded and the response being received. Therefore, if the path was stable enough to be available to route the request, it is almost certainly going to remain available to route the response.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这个问题的另一个方面是请求本身是否能够成功交付。假设典型的连接维护间隔，最后一次维护和发送请求之间的时间段将比转发请求和接收响应之间的延迟大几个数量级。因此，如果路径足够稳定，可以用来路由请求，那么几乎可以肯定，它仍然可以路由响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An overlay that is unstable enough to suffer this type of failure frequently is unlikely to be able to support reliable functionality regardless of the routing mechanism. However, regardless of the stability of the return path, studies show that in the event of high churn, iterative routing is a better solution to ensure request completion [lookups-churn-p2p06] [non-transitive-dhts-worlds05]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无论路由机制如何，一个不稳定到足以经常遭受此类故障的覆盖不太可能支持可靠的功能。然而，不管返回路径的稳定性如何，研究表明，在高流失率的情况下，迭代路由是确保请求完成的更好解决方案[lookups-Chorn-p2p06][non-transitive-dhts-worlds05]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, because RELOAD retries the end-to-end request, that retry will address the issues of churn that remain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，由于重新加载会重试端到端请求，因此该重试将解决仍然存在的客户流失问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Appendix B. Why Clients?
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
附录B：为什么是客户？
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a wide variety of reasons a node may act as a client rather than as a peer. This section outlines some of those scenarios and how the client&#39;s behavior changes based on its capabilities.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点作为客户机而不是对等机的原因有很多。本节概述了其中一些场景，以及客户机的行为如何根据其功能发生变化。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. Why Not Only Peers?
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.1. 为什么不仅仅是同龄人？
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For a number of reasons, a particular node may be forced to act as a client even though it is willing to act as a peer. These include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
出于许多原因，特定节点可能被迫充当客户端，即使它愿意充当对等方。这些措施包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The node does not have appropriate network connectivity, typically because it has a low-bandwidth network connection.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 该节点没有适当的网络连接，通常是因为它具有低带宽网络连接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The node may not have sufficient resources, such as computing power, storage space, or battery power.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 节点可能没有足够的资源，例如计算能力、存储空间或电池电量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The overlay algorithm may dictate specific requirements for peer selection. These may include participating in the overlay to determine trustworthiness, controlling the number of peers in the overlay to reduce overly long routing paths, and ensuring minimum application uptime before a node can join as a peer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 覆盖算法可能规定对等选择的特定要求。这些可能包括参与覆盖以确定可信度，控制覆盖中的对等方数量以减少过长的路由路径，以及确保在节点可以作为对等方加入之前的最小应用程序正常运行时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The ultimate criteria for a node to become a peer are determined by the overlay algorithm and specific deployment. A node acting as a client that has a full implementation of RELOAD and the appropriate overlay algorithm is capable of locating its responsible peer in the overlay and using Attach to establish a direct connection to that peer. In that way, it may elect to be reachable under either of the
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点成为对等节点的最终标准由覆盖算法和特定部署决定。作为客户机的节点具有完全的重新加载实现，并且适当的覆盖算法能够在覆盖中定位其负责的对等方，并使用Attach建立与该对等方的直接连接。通过这种方式，它可以选择在以下任何一种情况下都可以访问：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
routing approaches listed above. Particularly for overlay algorithms that elect nodes to serve as peers based on trustworthiness or population, the overlay algorithm may require such a client to locate itself at a particular place in the overlay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上面列出的路由方法。特别是对于基于可信度或总体选择节点作为对等方的覆盖算法，覆盖算法可能要求这样的客户端将其自身定位在覆盖中的特定位置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. Clients as Application-Level Agents
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
B.2. 作为应用程序级代理的客户端
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SIP defines an extensive protocol for registration and security between a client and its registrar/proxy server(s). Any SIP device can act as a client of a RELOAD-based P2PSIP overlay if it contacts a peer that implements the server-side functionality required by the SIP protocol. In this case, the peer would be acting as if it were the user&#39;s peer and would need the appropriate credentials for that user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
SIP为客户机及其注册/代理服务器之间的注册和安全定义了广泛的协议。如果任何SIP设备与实现SIP协议所需的服务器端功能的对等方联系，则可以充当基于重新加载的P2PSIP覆盖的客户端。在这种情况下，对等方的行为就像它是用户的对等方一样，并且需要该用户的适当凭据。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Application-level support for clients is defined by a usage. A usage offering support for application-level clients should specify how the security of the system is maintained when the data is moved between the application and RELOAD layers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对客户端的应用程序级支持由用法定义。为应用程序级客户端提供支持的用法应指定在应用程序层和重新加载层之间移动数据时如何维护系统的安全性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cullen Jennings Cisco 400 3rd Avenue SW, Suite 350 Calgary Canada
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Cullen Jennings Cisco 400加拿大卡尔加里第三大道西南350号套房
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: fluffy@cisco.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: fluffy@cisco.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bruce B. Lowekamp (editor) Skype Palo Alto, CA USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Bruce B.Lowekamp（编辑）Skype Palo Alto，美国加利福尼亚州
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: bbl@lowekamp.net
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: bbl@lowekamp.net
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Eric Rescorla RTFM，Inc.美国加利福尼亚州帕洛阿尔托埃奇伍德大道2064号，邮编94303
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 678 2350
   EMail: ekr@rtfm.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   Phone: +1 650 678 2350
   EMail: ekr@rtfm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Salman A. Baset Columbia University 1214 Amsterdam Avenue New York, NY USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
美国纽约州阿姆斯特丹大道1214号萨尔曼·A·伯斯特哥伦比亚大学
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: salman@cs.columbia.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: salman@cs.columbia.edu
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Henning Schulzrinne Columbia University 1214 Amsterdam Avenue New York, NY USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
亨宁·舒尔兹林内哥伦比亚大学美国纽约州阿姆斯特丹大道1214号
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: hgs@cs.columbia.edu
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: hgs@cs.columbia.edu
        </pre>
      </div>

    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
