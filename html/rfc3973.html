<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 3973:  Protocol Independent Multicast - Dense Mode (PIM-DM): Protocol Specification (Revised) 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC3973 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">打赏</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">3973</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc3973">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 3973:  Protocol Independent Multicast - Dense Mode (PIM-DM): Protocol Specification (Revised)  中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc3973">
              https://datatracker.ietf.org/doc/html/rfc3973
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 3973</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                           A. Adams
Request for Comments: 3973                          NextHop Technologies
Category: Experimental                                       J. Nicholas
                                                                ITT A/CD
                                                               W. Siadak
                                                    NextHop Technologies
                                                            January 2005
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                           A. Adams
Request for Comments: 3973                          NextHop Technologies
Category: Experimental                                       J. Nicholas
                                                                ITT A/CD
                                                               W. Siadak
                                                    NextHop Technologies
                                                            January 2005
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
Protocol Independent Multicast - Dense Mode (PIM-DM): Protocol Specification (Revised)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-9">
协议独立多播-密集模式（PIM-DM）：协议规范（修订版）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这份备忘录为互联网社区定义了一个实验性协议。它没有规定任何类型的互联网标准。要求进行讨论并提出改进建议。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Copyright Notice
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
版权公告
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2005年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies Protocol Independent Multicast - Dense Mode (PIM-DM). PIM-DM is a multicast routing protocol that uses the underlying unicast routing information base to flood multicast datagrams to all multicast routers. Prune messages are used to prevent future messages from propagating to routers without group membership information.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档规定了协议独立多播密集模式（PIM-DM）。PIM-DM是一种多播路由协议，它使用底层单播路由信息库向所有多播路由器发送多播数据报。修剪消息用于防止将来的消息在没有组成员信息的情况下传播到路由器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  4
       2.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . .  4
       2.2.  Pseudocode Notation  . . . . . . . . . . . . . . . . . .  5
   3.  PIM-DM Protocol Overview . . . . . . . . . . . . . . . . . . .  5
   4.  Protocol Specification . . . . . . . . . . . . . . . . . . . .  6
       4.1.  PIM Protocol State . . . . . . . . . . . . . . . . . . .  7
             4.1.1.  General Purpose State  . . . . . . . . . . . . .  7
             4.1.2.  (S,G) State  . . . . . . . . . . . . . . . . . .  8
             4.1.3.  State Summarization Macros . . . . . . . . . . .  8
       4.2.  Data Packet Forwarding Rules . . . . . . . . . . . . . . 10
       4.3.  Hello Messages . . . . . . . . . . . . . . . . . . . . . 11
             4.3.1.  Sending Hello Messages . . . . . . . . . . . . . 11
             4.3.2.  Receiving Hello Messages . . . . . . . . . . . . 11
             4.3.3.  Hello Message Hold Time  . . . . . . . . . . . . 12
             4.3.4.  Handling Router Failures . . . . . . . . . . . . 12
             4.3.5.  Reducing Prune Propagation Delay on LANs . . . . 13
       4.4.  PIM-DM Prune, Join, and Graft Messages . . . . . . . . . 13
             4.4.1.  Upstream Prune, Join, and Graft Messages . . . . 14
                     4.4.1.1.  Transitions from the Forwarding
                               (F) State  . . . . . . . . . . . . . . 17
                     4.4.1.2.  Transitions from the Pruned
                               (P) State  . . . . . . . . . . . . . . 18
                     4.4.1.3.  Transitions from the AckPending
                               (AP) State . . . . . . . . . . . . . . 19
             4.4.2.  Downstream Prune, Join, and Graft Messages . . . 21
                     4.4.2.1.  Transitions from the NoInfo State  . . 23
                     4.4.2.2.  Transitions from the PrunePending
                               (PP) State . . . . . . . . . . . . . . 24
                     4.4.2.3.  Transitions from the Prune
                               (P) State  . . . . . . . . . . . . . . 25
       4.5.  State Refresh  . . . . . . . . . . . . . . . . . . . . . 26
             4.5.1.  Forwarding of State Refresh Messages . . . . . . 26
             4.5.2.  State Refresh Message Origination  . . . . . . . 28
                     4.5.2.1.  Transitions from the NotOriginator
                               (NO) State . . . . . . . . . . . . . . 29
                     4.5.2.2.  Transitions from the Originator
                               (O) State  . . . . . . . . . . . . . . 29
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  4
       2.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . .  4
       2.2.  Pseudocode Notation  . . . . . . . . . . . . . . . . . .  5
   3.  PIM-DM Protocol Overview . . . . . . . . . . . . . . . . . . .  5
   4.  Protocol Specification . . . . . . . . . . . . . . . . . . . .  6
       4.1.  PIM Protocol State . . . . . . . . . . . . . . . . . . .  7
             4.1.1.  General Purpose State  . . . . . . . . . . . . .  7
             4.1.2.  (S,G) State  . . . . . . . . . . . . . . . . . .  8
             4.1.3.  State Summarization Macros . . . . . . . . . . .  8
       4.2.  Data Packet Forwarding Rules . . . . . . . . . . . . . . 10
       4.3.  Hello Messages . . . . . . . . . . . . . . . . . . . . . 11
             4.3.1.  Sending Hello Messages . . . . . . . . . . . . . 11
             4.3.2.  Receiving Hello Messages . . . . . . . . . . . . 11
             4.3.3.  Hello Message Hold Time  . . . . . . . . . . . . 12
             4.3.4.  Handling Router Failures . . . . . . . . . . . . 12
             4.3.5.  Reducing Prune Propagation Delay on LANs . . . . 13
       4.4.  PIM-DM Prune, Join, and Graft Messages . . . . . . . . . 13
             4.4.1.  Upstream Prune, Join, and Graft Messages . . . . 14
                     4.4.1.1.  Transitions from the Forwarding
                               (F) State  . . . . . . . . . . . . . . 17
                     4.4.1.2.  Transitions from the Pruned
                               (P) State  . . . . . . . . . . . . . . 18
                     4.4.1.3.  Transitions from the AckPending
                               (AP) State . . . . . . . . . . . . . . 19
             4.4.2.  Downstream Prune, Join, and Graft Messages . . . 21
                     4.4.2.1.  Transitions from the NoInfo State  . . 23
                     4.4.2.2.  Transitions from the PrunePending
                               (PP) State . . . . . . . . . . . . . . 24
                     4.4.2.3.  Transitions from the Prune
                               (P) State  . . . . . . . . . . . . . . 25
       4.5.  State Refresh  . . . . . . . . . . . . . . . . . . . . . 26
             4.5.1.  Forwarding of State Refresh Messages . . . . . . 26
             4.5.2.  State Refresh Message Origination  . . . . . . . 28
                     4.5.2.1.  Transitions from the NotOriginator
                               (NO) State . . . . . . . . . . . . . . 29
                     4.5.2.2.  Transitions from the Originator
                               (O) State  . . . . . . . . . . . . . . 29
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       4.6.  PIM Assert Messages  . . . . . . . . . . . . . . . . . . 30
             4.6.1.  Assert Metrics . . . . . . . . . . . . . . . . . 30
             4.6.2.  AssertCancel Messages  . . . . . . . . . . . . . 31
             4.6.3.  Assert State Macros  . . . . . . . . . . . . . . 32
             4.6.4.  (S,G) Assert Message State Machine . . . . . . . 32
                     4.6.4.1.  Transitions from NoInfo State  . . . . 34
                     4.6.4.2.  Transitions from Winner State  . . . . 35
                     4.6.4.3.  Transitions from Loser State . . . . . 36
             4.6.5.  Rationale for Assert Rules . . . . . . . . . . . 38
       4.7.  PIM Packet Formats . . . . . . . . . . . . . . . . . . . 38
             4.7.1.  PIM Header . . . . . . . . . . . . . . . . . . . 38
             4.7.2.  Encoded Unicast Address  . . . . . . . . . . . . 39
             4.7.3.  Encoded Group Address  . . . . . . . . . . . . . 40
             4.7.4.  Encoded Source Address . . . . . . . . . . . . . 41
             4.7.5.  Hello Message Format . . . . . . . . . . . . . . 42
                     4.7.5.1.  Hello Hold Time Option . . . . . . . . 43
                     4.7.5.2.  LAN Prune Delay Option . . . . . . . . 43
                     4.7.5.3.  Generation ID Option . . . . . . . . . 44
                     4.7.5.4.  State Refresh Capable Option . . . . . 44
             4.7.6.  Join/Prune Message Format  . . . . . . . . . . . 45
             4.7.7.  Assert Message Format  . . . . . . . . . . . . . 47
             4.7.8.  Graft Message Format . . . . . . . . . . . . . . 48
             4.7.9.  Graft Ack Message Format . . . . . . . . . . . . 48
             4.7.10. State Refresh Message Format . . . . . . . . . . 48
       4.8.  PIM-DM Timers  . . . . . . . . . . . . . . . . . . . . . 50
   5.  Protocol Interaction Considerations  . . . . . . . . . . . . . 53
       5.1.  PIM-SM Interactions  . . . . . . . . . . . . . . . . . . 53
       5.2.  IGMP Interactions  . . . . . . . . . . . . . . . . . . . 54
       5.3.  Source Specific Multicast (SSM) Interactions . . . . . . 54
       5.4.  Multicast Group Scope Boundary Interactions  . . . . . . 54
   6.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 54
       6.1.  PIM Address Family . . . . . . . . . . . . . . . . . . . 54
       6.2.  PIM Hello Options  . . . . . . . . . . . . . . . . . . . 55
   7.  Security Considerations. . . . . . . . . . . . . . . . . . . . 55
       7.1.  Attacks Based on Forged Messages . . . . . . . . . . . . 55
       7.2.  Non-cryptographic Authentication Mechanisms  . . . . . . 56
       7.3.  Authentication Using IPsec . . . . . . . . . . . . . . . 56
       7.4.  Denial of Service Attacks  . . . . . . . . . . . . . . . 58
   8.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 58
   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 58
       9.1.  Normative References . . . . . . . . . . . . . . . . . . 58
       9.2.  Informative References . . . . . . . . . . . . . . . . . 59
   Authors&#39; Addresses . . . . . . . . . . . . . . . . . . . . . . . . 60
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 61
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
       4.6.  PIM Assert Messages  . . . . . . . . . . . . . . . . . . 30
             4.6.1.  Assert Metrics . . . . . . . . . . . . . . . . . 30
             4.6.2.  AssertCancel Messages  . . . . . . . . . . . . . 31
             4.6.3.  Assert State Macros  . . . . . . . . . . . . . . 32
             4.6.4.  (S,G) Assert Message State Machine . . . . . . . 32
                     4.6.4.1.  Transitions from NoInfo State  . . . . 34
                     4.6.4.2.  Transitions from Winner State  . . . . 35
                     4.6.4.3.  Transitions from Loser State . . . . . 36
             4.6.5.  Rationale for Assert Rules . . . . . . . . . . . 38
       4.7.  PIM Packet Formats . . . . . . . . . . . . . . . . . . . 38
             4.7.1.  PIM Header . . . . . . . . . . . . . . . . . . . 38
             4.7.2.  Encoded Unicast Address  . . . . . . . . . . . . 39
             4.7.3.  Encoded Group Address  . . . . . . . . . . . . . 40
             4.7.4.  Encoded Source Address . . . . . . . . . . . . . 41
             4.7.5.  Hello Message Format . . . . . . . . . . . . . . 42
                     4.7.5.1.  Hello Hold Time Option . . . . . . . . 43
                     4.7.5.2.  LAN Prune Delay Option . . . . . . . . 43
                     4.7.5.3.  Generation ID Option . . . . . . . . . 44
                     4.7.5.4.  State Refresh Capable Option . . . . . 44
             4.7.6.  Join/Prune Message Format  . . . . . . . . . . . 45
             4.7.7.  Assert Message Format  . . . . . . . . . . . . . 47
             4.7.8.  Graft Message Format . . . . . . . . . . . . . . 48
             4.7.9.  Graft Ack Message Format . . . . . . . . . . . . 48
             4.7.10. State Refresh Message Format . . . . . . . . . . 48
       4.8.  PIM-DM Timers  . . . . . . . . . . . . . . . . . . . . . 50
   5.  Protocol Interaction Considerations  . . . . . . . . . . . . . 53
       5.1.  PIM-SM Interactions  . . . . . . . . . . . . . . . . . . 53
       5.2.  IGMP Interactions  . . . . . . . . . . . . . . . . . . . 54
       5.3.  Source Specific Multicast (SSM) Interactions . . . . . . 54
       5.4.  Multicast Group Scope Boundary Interactions  . . . . . . 54
   6.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 54
       6.1.  PIM Address Family . . . . . . . . . . . . . . . . . . . 54
       6.2.  PIM Hello Options  . . . . . . . . . . . . . . . . . . . 55
   7.  Security Considerations. . . . . . . . . . . . . . . . . . . . 55
       7.1.  Attacks Based on Forged Messages . . . . . . . . . . . . 55
       7.2.  Non-cryptographic Authentication Mechanisms  . . . . . . 56
       7.3.  Authentication Using IPsec . . . . . . . . . . . . . . . 56
       7.4.  Denial of Service Attacks  . . . . . . . . . . . . . . . 58
   8.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 58
   9.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 58
       9.1.  Normative References . . . . . . . . . . . . . . . . . . 58
       9.2.  Informative References . . . . . . . . . . . . . . . . . 59
   Authors&#39; Addresses . . . . . . . . . . . . . . . . . . . . . . . . 60
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 61
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This specification defines a multicast routing algorithm for multicast groups that are densely distributed across a network. This protocol does not have a topology discovery mechanism often used by a unicast routing protocol. It employs the same packet formats sparse mode PIM (PIM-SM) uses. This protocol is called PIM - Dense Mode. The foundation of this design was largely built on Deering&#39;s early work on IP multicast routing [12].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本规范为密集分布在网络上的多播组定义了多播路由算法。此协议没有单播路由协议经常使用的拓扑发现机制。它采用了稀疏模式PIM（PIM-SM）使用的相同数据包格式。该协议称为PIM密集模式。这个设计的基础很大程度上是建立在迪灵早期的IP组播路由（12）上。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Terminology
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 术语
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; are to be interpreted as described in RFC 2119 [11] and indicate requirement levels for compliant PIM-DM implementations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
关键词“必须”、“不得”、“要求”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照RFC 2119[11]中所述进行解释，并表示符合PIM-DM实施的要求级别。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Definitions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 定义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast Routing Information Base (MRIB) This is the multicast topology table, which is typically derived from the unicast routing table, or from routing protocols such as MBGP that carry multicast-specific topology information. PIM-DM uses the MRIB to make decisions regarding RPF interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播路由信息库（MRIB）这是多播拓扑表，通常来自单播路由表，或来自承载多播特定拓扑信息的路由协议，如MBGP。PIM-DM使用MRIB来决定RPF接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Tree Information Base (TIB) This is the collection of state maintained by a PIM router and created by receiving PIM messages and IGMP information from local hosts. It essentially stores the state of all multicast distribution trees at that router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
树信息库（TIB）这是由PIM路由器维护的状态集合，通过从本地主机接收PIM消息和IGMP信息创建。它本质上存储该路由器上所有多播分发树的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reverse Path Forwarding (RPF) RPF is a multicast forwarding mode in which a data packet is accepted for forwarding only if it is received on an interface used to reach the source in unicast.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
反向路径转发（RPF）RPF是一种多播转发模式，在这种模式下，只有在用于单播到达源的接口上接收数据包时，才会接受数据包进行转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upstream Interface Interface toward the source of the datagram. Also known as the RPF Interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
指向数据报源的上游接口。也称为RPF接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Downstream Interface All interfaces that are not the upstream interface, including the router itself.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下游接口不是上游接口的所有接口，包括路由器本身。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
(S,G) Pair Source S and destination group G associated with an IP packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
（S，G）将与IP分组相关联的源S和目的地组G配对。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Pseudocode Notation
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 伪码表示法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We use set notation in several places in this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在本规范中，我们在几个地方使用集合表示法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A (+) B is the union of two sets, A and B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A（+）B是两个集合A和B的并集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A (-) B are the elements of set A that are not in set B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A（-）B是集合A中不在集合B中的元素。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULL is the empty set or list.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
NULL是空的集合或列表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that operations MUST be conducted in the order specified. This is due to the fact that (-) is not a true difference operator, because B is not necessarily a subset of A. That is, A (+) B (-) C = A (-) C (+) B is not a true statement unless C is a subset of both A and B.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，必须按照指定的顺序进行操作。这是因为（-）不是真差分运算符，因为B不一定是a的子集。也就是说，a（+）B（-）C=a（-）C（+）B不是真语句，除非C是a和B的子集。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, we use C-like syntax:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，我们使用类似C的语法：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
= denotes assignment of a variable. == denotes a comparison for equality. != denotes a comparison for inequality.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
=表示变量的赋值。==表示相等的比较。！=表示不等式的比较。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Braces { and } are used for grouping.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
大括号{和}用于分组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. PIM-DM Protocol Overview
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. PIM-DM协议概述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section provides an overview of PIM-DM behavior. It is intended as an introduction to how PIM-DM works and is NOT definitive. For the definitive specification, see Section 4, Protocol Specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节概述了PIM-DM行为。本手册旨在介绍PIM-DM的工作原理，但并不确定。有关最终规范，请参见第4节，协议规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM assumes that when a source starts sending, all downstream systems want to receive multicast datagrams. Initially, multicast datagrams are flooded to all areas of the network. PIM-DM uses RPF to prevent looping of multicast datagrams while flooding. If some areas of the network do not have group members, PIM-DM will prune off the forwarding branch by instantiating prune state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM假设当源开始发送时，所有下游系统都希望接收多播数据报。最初，多播数据报被淹没到网络的所有区域。PIM-DM使用RPF防止泛洪时多播数据报的循环。如果网络的某些区域没有组成员，PIM-DM将通过实例化prune状态来修剪转发分支。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prune state has a finite lifetime. When that lifetime expires, data will again be forwarded down the previously pruned branch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
修剪状态有一个有限的生存期。当该生存期到期时，数据将再次沿先前修剪的分支向下转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prune state is associated with an (S,G) pair. When a new member for a group G appears in a pruned area, a router can &#34;graft&#34; toward the source S for the group, thereby turning the pruned branch back into a forwarding branch.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
修剪状态与（S，G）对关联。当组G的新成员出现在修剪区域中时，路由器可以向组的源S“嫁接”，从而将修剪的分支变回转发分支。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The broadcast of datagrams followed by pruning of unwanted branches is often referred to as a flood and prune cycle and is typical of dense mode protocols.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
数据报的广播随后对不需要的分支进行修剪通常被称为洪水和修剪周期，这是密集模式协议的典型特征。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To minimize repeated flooding of datagrams and subsequent pruning associated with a particular (S,G) pair, PIM-DM uses a state refresh message. This message is sent by the router(s) directly connected to the source and is propagated throughout the network. When received by a router on its RPF interface, the state refresh message causes an existing prune state to be refreshed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了最大限度地减少数据报的重复泛滥和与特定（S，G）对相关联的后续修剪，PIM-DM使用状态刷新消息。此消息由直接连接到源的路由器发送，并在整个网络中传播。当路由器在其RPF接口上接收到状态刷新消息时，将刷新现有的修剪状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Compared with multicast routing protocols with built-in topology discovery mechanisms (e.g., DVMRP [13]), PIM-DM has a simplified design and is not hard-wired into a specific topology discovery protocol. However, this simplification does incur more overhead by causing flooding and pruning to occur on some links that could be avoided if sufficient topology information were available; i.e., to decide whether an interface leads to any downstream members of a particular group. Additional overhead is chosen in favor of the simplification and flexibility gained by not depending on a specific topology discovery protocol.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与具有内置拓扑发现机制的多播路由协议（例如DVMRP[13]）相比，PIM-DM具有简化的设计，并且没有硬连接到特定的拓扑发现协议中。然而，这种简化确实会导致在某些链路上发生泛洪和修剪，从而产生更多开销，如果有足够的拓扑信息可用，则可以避免这种情况；i、 例如，决定接口是否指向特定组的任何下游成员。选择额外的开销有利于通过不依赖特定的拓扑发现协议而获得的简化和灵活性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM differs from PIM-SM in two essential ways: 1) There are no periodic joins transmitted, only explicitly triggered prunes and grafts. 2) There is no Rendezvous Point (RP). This is particularly important in networks that cannot tolerate a single point of failure. (An RP is the root of a shared multicast distribution tree. For more details, see [4]).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM与PIM-SM在两个基本方面不同：1）没有传输周期性连接，只有显式触发的修剪和嫁接。2） 没有交会点（RP）。这在不能容忍单点故障的网络中尤为重要。（RP是共享多播分发树的根。有关更多详细信息，请参阅[4]）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Protocol Specification
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 协议规范
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The specification of PIM-DM is broken into several parts:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM的规范分为几个部分：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Section 4.1 details the protocol state stored. * Section 4.2 specifies the data packet forwarding rules. * Section 4.3 specifies generation and processing of Hello messages. * Section 4.4 specifies the Join, Prune, and Graft generation and processing rules. * Section 4.5 specifies the State Refresh generation and forwarding rules. * Section 4.6 specifies the Assert generation and processing rules. * Section 4.7 gives details on PIM-DM Packet Formats. * Section 4.8 summarizes PIM-DM timers and their defaults.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 第4.1节详细说明了存储的协议状态。*第4.2节规定了数据包转发规则。*第4.3节规定了Hello消息的生成和处理。*第4.4节规定了连接、修剪和嫁接生成和处理规则。*第4.5节规定了状态刷新生成和转发规则。*第4.6节规定了断言生成和处理规则。*第4.7节给出了PIM-DM数据包格式的详细信息。*第4.8节总结了PIM-DM定时器及其默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. PIM Protocol State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1. PIM协议状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section specifies all the protocol states that a PIM-DM implementation should maintain to function correctly. We term this state the Tree Information Base or TIB, as it holds the state of all the multicast distribution trees at this router. In this specification, we define PIM-DM mechanisms in terms of the TIB. However, only a very simple implementation would actually implement packet forwarding operations in terms of this state. Most implementations will use this state to build a multicast forwarding table, which would then be updated when the relevant state in the TIB changes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节规定了PIM-DM实现应维护的所有协议状态，以便正常运行。我们将此状态称为树信息库或TIB，因为它保存此路由器上所有多播分发树的状态。在本规范中，我们根据TIB定义PIM-DM机制。然而，只有一个非常简单的实现才能真正实现这种状态下的包转发操作。大多数实现将使用此状态来构建多播转发表，当TIB中的相关状态发生更改时，将更新该表。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unlike PIM-SM, PIM-DM does not maintain a keepalive timer associated with each (S,G) route. Within PIM-DM, route and state information associated with an (S,G) entry MUST be maintained as long as any timer associated with that (S,G) entry is active. When no timer associated with an (S,G) entry is active, all information concerning that (S,G) route may be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
与PIM-SM不同，PIM-DM不维护与每个（S，G）路由相关联的keepalive计时器。在PIM-DM中，只要与（S，G）条目相关联的任何计时器处于活动状态，就必须维护与（S，G）条目相关联的路由和状态信息。当没有与（S，G）条目相关联的计时器处于活动状态时，可能会丢弃与（S，G）路径相关的所有信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although we precisely specify the state to be kept, this does not mean that an implementation of PIM-DM has to hold the state in this form. This is actually an abstract state definition, which is needed in order to specify the router&#39;s behavior. A PIM-DM implementation is free to hold whatever internal state it requires and will still be conformant with this specification as long as it results in the same externally visible protocol behavior as an abstract router that holds the following state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管我们精确地指定了要保持的状态，但这并不意味着PIM-DM的实现必须以这种形式保持状态。这实际上是一个抽象的状态定义，需要它来指定路由器的行为。PIM-DM实现可以自由地保持其所需的任何内部状态，并且只要它产生与保持以下状态的抽象路由器相同的外部可见协议行为，就仍然符合本规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. General Purpose State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.1. 通用状态
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A router stores the following non-group-specific state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器存储以下非组特定状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For each interface: Hello Timer (HT) State Refresh Capable LAN Delay Enabled Propagation Delay (PD) Override Interval (OI)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个接口：Hello定时器（HT）状态刷新功能LAN延迟启用传播延迟（PD）覆盖间隔（OI）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Neighbor State: For each neighbor: Information from neighbor&#39;s Hello Neighbor&#39;s Gen ID. Neighbor&#39;s LAN Prune Delay Neighbor&#39;s Override Interval Neighbor&#39;s State Refresh Capability Neighbor Liveness Timer (NLT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
邻居状态：对于每个邻居：来自邻居的Hello邻居的Gen ID的信息。邻居的LAN修剪延迟邻居的覆盖间隔邻居的状态刷新能力邻居活跃度计时器（NLT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. (S,G) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.2. （S，G）国家
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For every source/group pair (S,G), a router stores the following state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于每个源/组对（S、G），路由器存储以下状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   (S,G) state:
     For each interface:
       Local Membership:
         State: One of {&#34;NoInfo&#34;, &#34;Include&#34;}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   (S,G) state:
     For each interface:
       Local Membership:
         State: One of {&#34;NoInfo&#34;, &#34;Include&#34;}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PIM (S,G) Prune State: State: One of {&#34;NoInfo&#34; (NI), &#34;Pruned&#34; (P), &#34;PrunePending&#34; (PP)} Prune Pending Timer (PPT) Prune Timer (PT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
PIM（S，G）修剪状态：状态：{“NoInfo”（NI），“修剪”（P），“修剪”（PP）}修剪挂起计时器（PPT）修剪计时器（PT）之一
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
(S,G) Assert Winner State: State: One of {&#34;NoInfo&#34; (NI), &#34;I lost Assert&#34; (L), &#34;I won Assert&#34; (W)} Assert Timer (AT) Assert winner&#39;s IP Address Assert winner&#39;s Assert Metric
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
（S，G）断言赢家状态：状态：{“NoInfo”（NI），“I lost Assert”（L），“I won Assert”（W）}断言计时器（AT）断言赢家的IP地址断言赢家的断言度量之一
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Upstream interface-specific: Graft/Prune State: State: One of {&#34;NoInfo&#34; (NI), &#34;Pruned&#34; (P), &#34;Forwarding&#34; (F), &#34;AckPending&#34; (AP) } GraftRetry Timer (GRT) Override Timer (OT) Prune Limit Timer (PLT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
上游接口特定：嫁接/修剪状态：状态：{“NoInfo”（NI），“修剪”（P），“转发”（F），“AckPending”（AP）}嫁接重试计时器（GRT）覆盖计时器（OT）修剪限制计时器（PLT）之一
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Originator State: Source Active Timer (SAT) State Refresh Timer (SRT)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
发起人状态：源活动计时器（SAT）状态刷新计时器（SRT）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. State Summarization Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.1.3. 状态摘要宏
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Using the state defined above, the following &#34;macros&#34; are defined and will be used in the descriptions of the state machines and pseudocode in the following sections.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用上面定义的状态，定义了以下“宏”，并将在以下部分的状态机和伪代码描述中使用这些宏。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The most important macros are those defining the outgoing interface list (or &#34;olist&#34;) for the relevant state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最重要的宏是那些为相关状态定义传出接口列表（或“olist”）的宏。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(S,G) = pim_nbrs (-) prunes(S,G) (+)
                          (pim_include(*,G) (-) pim_exclude(S,G) ) (+)
                          pim_include(S,G) (-) lost_assert(S,G) (-)
                          boundary(G)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   immediate_olist(S,G) = pim_nbrs (-) prunes(S,G) (+)
                          (pim_include(*,G) (-) pim_exclude(S,G) ) (+)
                          pim_include(S,G) (-) lost_assert(S,G) (-)
                          boundary(G)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   olist(S,G) = immediate_olist(S,G) (-) RPF_interface(S)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   olist(S,G) = immediate_olist(S,G) (-) RPF_interface(S)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macros pim_include(*,G) and pim_include(S,G) indicate the interfaces to which traffic might or might not be forwarded because of hosts that are local members on those interfaces.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏pim_include（*，G）和pim_include（S，G）表示由于主机是这些接口上的本地成员，流量可能会或可能不会被转发到的接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_include(*,G) = {all interfaces I such that:
                       local_receiver_include(*,G,I)}
   pim_include(S,G) = {all interfaces I such that:
                       local_receiver_include(S,G,I)}
   pim_exclude(S,G) = {all interfaces I such that:
                       local_receiver_exclude(S,G,I)}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   pim_include(*,G) = {all interfaces I such that:
                       local_receiver_include(*,G,I)}
   pim_include(S,G) = {all interfaces I such that:
                       local_receiver_include(S,G,I)}
   pim_exclude(S,G) = {all interfaces I such that:
                       local_receiver_exclude(S,G,I)}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macro RPF_interface(S) returns the RPF interface for source S. That is to say, it returns the interface used to reach S as indicated by the MRIB.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏RPF_接口返回源S的RPF接口。也就是说，它返回用于到达源S的接口，如MRIB所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macro local_receiver_include(S,G,I) is true if the IGMP module or other local membership mechanism ([1], [2], [3], [6]) has determined that there are local members on interface I that seek to receive traffic sent specifically by S to G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果IGMP模块或其他本地成员机制（[1]、[2]、[3]、[6]）已确定接口I上存在寻求接收由S专门发送到G的流量的本地成员，则宏本地_receiver_include（S、G、I）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macro local_receiver_include(*,G,I) is true if the IGMP module or other local membership mechanism has determined that there are local members on interface I that seek to receive all traffic sent to G. Note that this determination is expected to account for membership joins initiated on or by the router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果IGMP模块或其他本地成员机制已确定接口I上有本地成员寻求接收发送到G的所有通信量，则宏本地_receiver_include（*，G，I）为真。请注意，此确定应考虑路由器上或路由器发起的成员加入。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macro local_receiver_exclude(S,G,I) is true if local_receiver_include(*,G,I) is true but none of the local members seek to receive traffic from S.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果local_receiver_include（*，G，I）为true，但没有任何本地成员寻求从S接收流量，则宏local_receiver_exclude（S，G，I）为true。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set pim_nbrs is the set of all interfaces on which the router has at least one active PIM neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
set pim_nbrs是路由器至少有一个活动pim邻居的所有接口的集合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set prunes(S,G) is the set of all interfaces on which the router has received Prune(S,G) messages:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
set Prune（S，G）是路由器接收Prune（S，G）消息的所有接口的集合：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   prunes(S,G) = {all interfaces I such that
                  DownstreamPState(S,G,I) is in Pruned state}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   prunes(S,G) = {all interfaces I such that
                  DownstreamPState(S,G,I) is in Pruned state}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The set lost_assert(S,G) is the set of all interfaces on which the router has lost an (S,G) Assert.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
set loss_assert（S，G）是路由器丢失（S，G）assert的所有接口的集合。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(S,G) = {all interfaces I such that
                       lost_assert(S,G,I) == TRUE}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   lost_assert(S,G) = {all interfaces I such that
                       lost_assert(S,G,I) == TRUE}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   boundary(G) = {all interfaces I with an administratively scoped
                  boundary for group G}
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   boundary(G) = {all interfaces I with an administratively scoped
                  boundary for group G}
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following pseudocode macro definitions are also used in many places in the specification. Basically RPF&#39; is the RPF neighbor toward a source unless a PIM-DM Assert has overridden the normal choice of neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
规范中的许多地方也使用了以下伪代码宏定义。基本上，“RPF”是指向源的RPF邻居，除非PIM-DM断言覆盖了正常的邻居选择。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   neighbor RPF&#39;(S,G) {
     if ( I_Am_Assert_loser(S, G, RPF_interface(S) )) {
       return AssertWinner(S, G, RPF_interface(S) )
     } else {
       return MRIB.next_hop( S )
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   neighbor RPF&#39;(S,G) {
     if ( I_Am_Assert_loser(S, G, RPF_interface(S) )) {
       return AssertWinner(S, G, RPF_interface(S) )
     } else {
       return MRIB.next_hop( S )
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macro I_Am_Assert_loser(S, G, I) is true if the Assert state machine (in Section 4.6) for (S,G) on interface I is in the &#34;I am Assert Loser&#34; state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果接口I上（S，G）的断言状态机（第4.6节）处于“我是断言失败者”状态，则宏I_Am_断言失败者（S，G，I）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. Data Packet Forwarding Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.2. 数据包转发规则
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM-DM packet forwarding rules are defined below in pseudocode.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM数据包转发规则在下面的伪代码中定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iif is the incoming interface of the packet. S is the source address of the packet. G is the destination address of the packet (group address). RPF_interface(S) is the interface the MRIB indicates would be used to route packets to S.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
iif是数据包的传入接口。S是数据包的源地址。G是数据包的目标地址（组地址）。RPF_接口是MRIB指示用于将数据包路由到的接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
First, an RPF check MUST be performed to determine whether the packet should be accepted based on TIB state and the interface on which that the packet arrived. Packets that fail the RPF check MUST NOT be forwarded, and the router will conduct an assert process for the (S,G) pair specified in the packet. Packets for which a route to the source cannot be found MUST be discarded.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
首先，必须执行RPF检查，以根据TIB状态和数据包到达的接口确定是否应接受数据包。不能转发未通过RPF检查的数据包，路由器将对数据包中指定的（S，G）对执行断言过程。无法找到到源的路由的数据包必须丢弃。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the RPF check has been passed, an outgoing interface list is constructed for the packet. If this list is not empty, then the packet MUST be forwarded to all listed interfaces. If the list is empty, then the router will conduct a prune process for the (S,G) pair specified in the packet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果RPF检查已通过，则为数据包构造传出接口列表。如果此列表不为空，则必须将数据包转发到所有列出的接口。如果列表为空，则路由器将对数据包中指定的（S，G）对执行修剪过程。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon receipt of a data packet from S addressed to G on interface iif:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在接口iif上收到S发送给G的数据包后：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (iif == RPF_interface(S) AND UpstreamPState(S,G) != Pruned) {
       oiflist = olist(S,G)
   } else {
       oiflist = NULL
   }
   forward packet on all interfaces in oiflist
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (iif == RPF_interface(S) AND UpstreamPState(S,G) != Pruned) {
       oiflist = olist(S,G)
   } else {
       oiflist = NULL
   }
   forward packet on all interfaces in oiflist
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This pseudocode employs the following &#34;macro&#34; definition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此伪代码采用以下“宏”定义：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
UpstreamPState(S,G) is the state of the Upstream(S,G) state machine in Section 4.4.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游状态（S，G）是第4.4.1节中上游（S，G）状态机的状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. Hello Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3. 你好消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the generation and processing of Hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍Hello消息的生成和处理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. Sending Hello Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.1. 发送问候信息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM uses Hello messages to detect other PIM routers. Hello messages are sent periodically on each PIM enabled interface. Hello messages are multicast to the ALL-PIM-ROUTERS group. When PIM is enabled on an interface or when a router first starts, the Hello Timer (HT) MUST be set to random value between 0 and Triggered_Hello_Delay. This prevents synchronization of Hello messages if multiple routers are powered on simultaneously.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM使用Hello消息检测其他PIM路由器。Hello消息在每个启用PIM的接口上定期发送。所有的多播路由器都是Hello-PIM消息。当接口上启用PIM或路由器首次启动时，Hello定时器（HT）必须设置为介于0和触发\u Hello\u延迟之间的随机值。如果多个路由器同时通电，这将阻止Hello消息的同步。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
After the initial Hello message, a Hello message MUST be sent every Hello_Period. A single Hello timer MAY be used to trigger sending Hello messages on all active interfaces. The Hello Timer SHOULD NOT be reset except when it expires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在初始Hello消息之后，必须在每个Hello_期间发送Hello消息。单个Hello定时器可用于触发在所有活动接口上发送Hello消息。除非Hello计时器过期，否则不应重置它。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. Receiving Hello Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.2. 接收问候信息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a Hello message is received, the receiving router SHALL record the receiving interface, the sender, and any information contained in recognized options. This information is retained for a number of seconds in the Hold Time field of the Hello Message. If a new Hello message is received from a particular neighbor N, the Neighbor Liveness Timer (NLT(N,I)) MUST be reset to the newly received Hello Holdtime. If a Hello message is received from a new neighbor, the receiving router SHOULD send its own Hello message after a random delay between 0 and Triggered_Hello_Delay.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当收到Hello消息时，接收路由器应记录接收接口、发送方以及识别选项中包含的任何信息。此信息在Hello消息的保持时间字段中保留数秒。如果从特定邻居N接收到新的Hello消息，则必须将邻居活跃度计时器（NLT（N，I））重置为新接收到的Hello保持时间。如果从新邻居接收到Hello消息，则接收路由器应在0和触发的\u Hello\u延迟之间的随机延迟后发送其自己的Hello消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3. Hello Message Hold Time
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.3. 你好消息等待时间
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Hold Time in the Hello Message should be set to a value that can reasonably be expected to keep the Hello active until a new Hello message is received. On most links, this will be 3.5 times the value of Hello_Period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello消息中的保持时间应设置为一个值，该值可以合理预期保持Hello处于活动状态，直到收到新的Hello消息。在大多数链接上，这将是Hello_Period值的3.5倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If the Hold Time is set to &#39;0xffff&#39;, the receiving router MUST NOT time out that Hello message. This feature might be used for on-demand links to avoid keeping the link up with periodic Hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果保持时间设置为“0xffff”，则接收路由器不得超时该Hello消息。此功能可用于按需链接，以避免使用定期的Hello消息保持链接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a Hold Time of &#39;0&#39; is received, the corresponding neighbor state expires immediately. When a PIM router takes an interface down or changes IP address, a Hello message with a zero Hold Time SHOULD be sent immediately (with the old IP address if the IP address is changed) to cause any PIM neighbors to remove the old information immediately.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果接收到保持时间为“0”，则相应的邻居状态将立即过期。当PIM路由器关闭接口或更改IP地址时，应立即发送保持时间为零的Hello消息（如果IP地址更改，则使用旧IP地址），以使任何PIM邻居立即删除旧信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.4. Handling Router Failures
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.4. 处理路由器故障
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a Hello message is received from an active neighbor with a different Generation ID (GenID), the neighbor has restarted and may not contain the correct (S,G) state. A Hello message SHOULD be sent after a random delay between 0 and Triggered_Hello_Delay (see 4.8) before any other messages are sent. If the neighbor is downstream, the router MAY replay the last State Refresh message for any (S,G) pairs for which it is the Assert Winner indicating Prune and Assert status to the downstream router. These State Refresh messages SHOULD be sent out immediately after the Hello message. If the neighbor is the upstream neighbor for an (S,G) entry, the router MAY cancel its Prune Limit Timer to permit sending a prune and reestablishing a Pruned state in the upstream router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果从具有不同生成ID（GenID）的活动邻居接收到Hello消息，则该邻居已重新启动，并且可能不包含正确的（S，G）状态。在发送任何其他消息之前，应在0和触发\u Hello\u delay（见4.8）之间的随机延迟之后发送Hello消息。如果邻居在下游，路由器可以重播其作为断言赢家的任何（S，G）对的最后状态刷新消息，向下游路由器指示修剪和断言状态。这些状态刷新消息应该在Hello消息之后立即发送。如果邻居是（S，G）条目的上游邻居，则路由器可以取消其修剪限制计时器，以允许发送修剪并在上游路由器中重新建立修剪状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upon startup, a router MAY use any State Refresh messages received within Hello_Period of its first Hello message on an interface to establish state information. The State Refresh source will be the RPF&#39;(S), and Prune status for all interfaces will be set according to the Prune Indicator bit in the State Refresh message. If the Prune Indicator is set, the router SHOULD set the PruneLimitTimer to Prune_Holdtime and set the PruneTimer on all downstream interfaces to the State Refresh&#39;s Interval times two. The router SHOULD then propagate the State Refresh as described in Section 4.5.1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在启动时，路由器可以使用在其在接口上的第一条Hello消息的Hello_期间内接收到的任何状态刷新消息来建立状态信息。状态刷新源将是RPF，所有接口的修剪状态将根据状态刷新消息中的修剪指示符位设置。如果设置了Prune指示符，路由器应将PruneLimitTimer设置为Prune_Holdtime，并将所有下游接口上的PruneTimer设置为状态刷新间隔两倍。然后，路由器应按照第4.5.1节所述传播状态刷新。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5. Reducing Prune Propagation Delay on LANs
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.3.5. 减少局域网上的剪枝传播延迟
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If all routers on a LAN support the LAN Prune Delay option, then the PIM routers on that LAN will use the values received to adjust their J/P_Override_Interval on that interface and the interface is LAN Delay Enabled. Briefly, to avoid synchronization of Prune Override (Join) messages when multiple downstream routers share a multi-access link, sending of these messages is delayed by a small random amount of time. The period of randomization is configurable and has a default value of 3 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果LAN上的所有路由器都支持LAN Prune Delay选项，则该LAN上的PIM路由器将使用接收到的值来调整该接口上的J/P_Override_间隔，并且该接口已启用LAN Delay。简而言之，当多个下游路由器共享一个多址链路时，为了避免剪枝覆盖（Join）消息的同步，这些消息的发送会延迟一小段随机时间。随机化周期是可配置的，默认值为3秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Each router on the LAN expresses its view of the amount of randomization necessary in the Override Interval field of the LAN Prune Delay option. When all routers on a LAN use the LAN Prune Delay Option, all routers on the LAN MUST set their Override_Interval to the largest Override value on the LAN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAN上的每个路由器在LAN修剪延迟选项的覆盖间隔字段中表示其对所需随机化量的看法。当LAN上的所有路由器使用LAN修剪延迟选项时，LAN上的所有路由器必须将其覆盖间隔设置为LAN上的最大覆盖值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAN Delay inserted by a router in the LAN Prune Delay option expresses the expected message propagation delay on the link and SHOULD be configurable by the system administrator. When all routers on a link use the LAN Prune Delay Option, all routers on the LAN MUST set Propagation Delay to the largest LAN Delay on the LAN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
路由器在LAN Prune Delay选项中插入的LAN延迟表示链路上预期的消息传播延迟，应由系统管理员进行配置。当链路上的所有路由器使用LAN修剪延迟选项时，LAN上的所有路由器必须将传播延迟设置为LAN上最大的LAN延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM implementers should enforce a lower bound on the permitted values for this delay to allow for scheduling and processing delays within their router. Such delays may cause received messages to be processed later and triggered messages to be sent later than intended. Setting this LAN Prune Delay to too low a value may result in temporary forwarding outages, because a downstream router will not be able to override a neighbor&#39;s prune message before the upstream neighbor stops forwarding.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM实现者应该对该延迟的允许值实施一个下限，以允许其路由器内的调度和处理延迟。这种延迟可能会导致接收到的消息被延迟处理，而触发的消息被延迟发送。将此LAN修剪延迟设置为过低的值可能会导致临时转发中断，因为在上游邻居停止转发之前，下游路由器将无法覆盖邻居的修剪消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. PIM-DM Prune, Join, and Graft Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4. PIM-DM修剪、加入和嫁接消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the generation and processing of PIM-DM Join, Prune, and Graft messages. Prune messages are sent toward the upstream neighbor for S to indicate that traffic from S addressed to group G is not desired. In the case of downstream routers A and B, where A wishes to continue receiving data and B does not, A will send a Join in response to B&#39;s Prune to override the Prune. This is the only situation in PIM-DM in which a Join message is used. Finally, a Graft message is used to re-join a previously pruned branch to the delivery tree.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍PIM-DM联接、修剪和嫁接消息的生成和处理。修剪消息被发送到S的上游邻居，以指示不需要从S到G组的通信量。在下游路由器A和B的情况下，如果A希望继续接收数据而B没有，A将发送一个连接以响应B的修剪以覆盖修剪。这是PIM-DM中使用连接消息的唯一情况。最后，使用嫁接消息将先前修剪的分支重新连接到传递树。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. Upstream Prune, Join, and Graft Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1. 上游修剪、连接和嫁接消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Upstream(S,G) state machine for sending Prune, Graft, and Join messages is given below. There are three states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面给出了用于发送剪枝、嫁接和连接消息的上游（S，G）状态机。有三个州。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Forwarding (F) This is the starting state of the Upsteam(S,G) state machine. The state machine is in this state if it just started or if oiflist(S,G) != NULL.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
转发（F）这是Upsteam（S，G）状态机的开始状态。如果状态机刚刚启动或oiflist（S，G）！=无效的
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Pruned (P) The set, olist(S,G), is empty. The router will not forward data from S addressed to group G.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪（P）集合olist（S，G）为空。路由器不会将数据从S转发到G组。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AckPending (AP) The router was in the Pruned(P) state, but a transition has occurred in the Downstream(S,G) state machine for one of this (S,G) entry&#39;s outgoing interfaces, indicating that traffic from S addressed to G should again be forwarded. A Graft message has been sent to RPF&#39;(S), but a Graft Ack message has not yet been received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AckPending（AP）路由器处于修剪（P）状态，但此（S，G）项的一个传出接口的下游（S，G）状态机中发生了转换，表明从S到G的流量应再次转发。嫁接消息已发送到RPF&#39;，但尚未收到嫁接确认消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there are three state-machine-specific timers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有三种特定于状态机的计时器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
GraftRetry Timer (GRT(S,G)) This timer is set when a Graft is sent upstream. If a corresponding GraftAck is not received before the timer expires, then another Graft is sent, and the GraftRetry Timer is reset. The timer is stopped when a Graft Ack message is received. This timer is normally set to Graft_Retry_Period (see 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
嫁接重试计时器（GRT（S，G））当嫁接被发送到上游时，该计时器被设置。如果在计时器过期之前未收到相应的GraftAck，则发送另一个GraftRetry，并重置GraftRetry计时器。当接收到嫁接确认消息时，计时器停止。该计时器通常设置为嫁接重试周期（见4.8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Override Timer (OT(S,G)) This timer is set when a Prune(S,G) is received on the upstream interface where olist(S,G) != NULL. When the timer expires, a Join(S,G) message is sent on the upstream interface. This timer is normally set to t_override (see 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
覆盖计时器（OT（S，G））此计时器在上游接口上接收到修剪（S，G）时设置，其中olist（S，G）！=无效的当计时器过期时，将在上游接口上发送加入（S，G）消息。该定时器通常设置为t_超控（见4.8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Limit Timer (PLT(S,G)) This timer is used to rate-limit Prunes on a LAN. It is only used when the Upstream(S,G) state machine is in the Pruned state. A Prune cannot be sent if this timer is running. This timer is normally set to t_limit (see 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪限制计时器（PLT（S，G））此计时器用于对LAN上的修剪进行限制。它仅在上游（S，G）状态机处于修剪状态时使用。如果此计时器正在运行，则无法发送修剪。该定时器通常设置为t_限制（见4.8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          +-------------+                        +-------------+
          |             |     olist == NULL      |             |
          |   Forward   |-----------------------&gt;|   Pruned    |
          |             |                        |             |
          +-------------+                        +-------------+
               ^   |                                  ^   |
               |   |                                  |   |
               |   |RPF`(S) Changes      olist == NULL|   |
               |   |                                  |   |
               |   |         +-------------+          |   |
               |   +--------&gt;|             |----------+   |
               |             | AckPending  |              |
               +-------------|             |&lt;-------------+
             Rcv GraftAck OR +-------------+ olist != NULL
           Rcv State Refresh
              With (P==0) OR
          S Directly Connect
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
          +-------------+                        +-------------+
          |             |     olist == NULL      |             |
          |   Forward   |-----------------------&gt;|   Pruned    |
          |             |                        |             |
          +-------------+                        +-------------+
               ^   |                                  ^   |
               |   |                                  |   |
               |   |RPF`(S) Changes      olist == NULL|   |
               |   |                                  |   |
               |   |         +-------------+          |   |
               |   +--------&gt;|             |----------+   |
               |             | AckPending  |              |
               +-------------|             |&lt;-------------+
             Rcv GraftAck OR +-------------+ olist != NULL
           Rcv State Refresh
              With (P==0) OR
          S Directly Connect
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
Figure 1: Upstream Interface State Machine
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-16">
图1：上游接口状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In tabular form, the state machine is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以表格形式，状态机定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
|                               +------------+------------+------------+
|            Event              | Forwarding |   Pruned   | AckPending |
+-------------------------------+------------+------------+------------+
| Data packet arrives on        | -&gt;P Send   | -&gt;P Send   | N/A        |
| RPF_Interface(S) AND          | Prune(S,G) | Prune(S,G) |            |
| olist(S,G) == NULL AND        |Set PLT(S,G)|Set PLT(S,G)|            |
| PLT(S,G) not running          |            |            |            |
+-------------------------------+------------+------------+------------+
| State Refresh(S,G) received   | -&gt;F  Set   | -&gt;P Reset  |-&gt;AP  Set   |
| from RPF`(S) AND              |    OT(S,G) |  PLT(S,G)  |    OT(S,G) |
| Prune Indicator == 1          |            |            |            |
+-------------------------------+------------+------------+------------+
| State Refresh(S,G) received   | -&gt;F        | -&gt;P Send   |-&gt;F Cancel  |
| from RPF`(S) AND              |            | Prune(S,G) |  GRT(S,G)  |
| Prune Indicator == 0 AND      |            |Set PLT(S,G)|            |
| PLT(S,G) not running          |            |            |            |
+-------------------------------+------------+------------+------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
|                               +------------+------------+------------+
|            Event              | Forwarding |   Pruned   | AckPending |
+-------------------------------+------------+------------+------------+
| Data packet arrives on        | -&gt;P Send   | -&gt;P Send   | N/A        |
| RPF_Interface(S) AND          | Prune(S,G) | Prune(S,G) |            |
| olist(S,G) == NULL AND        |Set PLT(S,G)|Set PLT(S,G)|            |
| PLT(S,G) not running          |            |            |            |
+-------------------------------+------------+------------+------------+
| State Refresh(S,G) received   | -&gt;F  Set   | -&gt;P Reset  |-&gt;AP  Set   |
| from RPF`(S) AND              |    OT(S,G) |  PLT(S,G)  |    OT(S,G) |
| Prune Indicator == 1          |            |            |            |
+-------------------------------+------------+------------+------------+
| State Refresh(S,G) received   | -&gt;F        | -&gt;P Send   |-&gt;F Cancel  |
| from RPF`(S) AND              |            | Prune(S,G) |  GRT(S,G)  |
| Prune Indicator == 0 AND      |            |Set PLT(S,G)|            |
| PLT(S,G) not running          |            |            |            |
+-------------------------------+------------+------------+------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
+                               +------------+------------+------------+
|            Event              | Forwarding |   Pruned   | AckPending |
+-------------------------------+------------+------------+------------+
| See Join(S,G) to RPF&#39;(S)      | -&gt;F Cancel | -&gt;P        |-&gt;AP Cancel |
|                               |    OT(S,G) |            |    OT(S,G) |
+-------------------------------+------------+------------+------------+
| See Prune(S,G)                | -&gt;F Set    | -&gt;P        |-&gt;AP Set    |
|                               |    OT(S,G) |            |    OT(S,G) |
+-------------------------------+------------+------------+------------+
| OT(S,G) Expires               | -&gt;F Send   | N/A        |-&gt;AP Send   |
|                               |  Join(S,G) |            |  Join(S,G) |
+-------------------------------+------------+------------+------------+
| olist(S,G)-&gt;NULL              | -&gt;P Send   | N/A        |-&gt;P Send    |
|                               | Prune(S,G) |            | Prune(S,G) |
|                               |Set PLT(S,G)|            |Set PLT(S,G)|
|                               |            |            | Cancel     |
|                               |            |            | GRT(S,G)   |
+-------------------------------+------------+------------+------------+
| olist(S,G)-&gt;non-NULL          | N/A        | -&gt;AP Send  | N/A        |
|                               |            | Graft(S,G) |            |
|                               |            |Set GRT(S,G)|            |
+-------------------------------+------------+------------+------------+
| RPF&#39;(S) Changes AND           | -&gt;AP Send  | -&gt;AP Send  |-&gt;AP Send   |
| olist(S,G) != NULL            | Graft(S,G) | Graft(S,G) | Graft(S,G) |
|                               |Set GRT(S,G)|Set GRT(S,G)|Set GRT(S,G)|
+-------------------------------+------------+------------+------------+
| RPF&#39;(S) Changes AND           | -&gt;P        | -&gt;P Cancel |-&gt;P Cancel  |
| olist(S,G) == NULL            |            |  PLT(S,G)  |  GRT(S,G)  |
+-------------------------------+------------+------------+------------+
| S becomes directly connected  | -&gt;F        | -&gt;P        |-&gt;F Cancel  |
|                               |            |            |  GRT(S,G)  |
+-------------------------------+------------+------------+------------+
| GRT(S,G) Expires              | N/A        | N/A        |-&gt;AP Send   |
|                               |            |            | Graft(S,G) |
|                               |            |            |Set GRT(S,G)|
+-------------------------------+------------+------------+------------+
| Receive GraftAck(S,G) from    | -&gt;F        | -&gt;P        |-&gt;F Cancel  |
| RPF&#39;(S)                       |            |            |  GRT(S,G)  |
+-------------------------------+------------+------------+------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
+                               +------------+------------+------------+
|            Event              | Forwarding |   Pruned   | AckPending |
+-------------------------------+------------+------------+------------+
| See Join(S,G) to RPF&#39;(S)      | -&gt;F Cancel | -&gt;P        |-&gt;AP Cancel |
|                               |    OT(S,G) |            |    OT(S,G) |
+-------------------------------+------------+------------+------------+
| See Prune(S,G)                | -&gt;F Set    | -&gt;P        |-&gt;AP Set    |
|                               |    OT(S,G) |            |    OT(S,G) |
+-------------------------------+------------+------------+------------+
| OT(S,G) Expires               | -&gt;F Send   | N/A        |-&gt;AP Send   |
|                               |  Join(S,G) |            |  Join(S,G) |
+-------------------------------+------------+------------+------------+
| olist(S,G)-&gt;NULL              | -&gt;P Send   | N/A        |-&gt;P Send    |
|                               | Prune(S,G) |            | Prune(S,G) |
|                               |Set PLT(S,G)|            |Set PLT(S,G)|
|                               |            |            | Cancel     |
|                               |            |            | GRT(S,G)   |
+-------------------------------+------------+------------+------------+
| olist(S,G)-&gt;non-NULL          | N/A        | -&gt;AP Send  | N/A        |
|                               |            | Graft(S,G) |            |
|                               |            |Set GRT(S,G)|            |
+-------------------------------+------------+------------+------------+
| RPF&#39;(S) Changes AND           | -&gt;AP Send  | -&gt;AP Send  |-&gt;AP Send   |
| olist(S,G) != NULL            | Graft(S,G) | Graft(S,G) | Graft(S,G) |
|                               |Set GRT(S,G)|Set GRT(S,G)|Set GRT(S,G)|
+-------------------------------+------------+------------+------------+
| RPF&#39;(S) Changes AND           | -&gt;P        | -&gt;P Cancel |-&gt;P Cancel  |
| olist(S,G) == NULL            |            |  PLT(S,G)  |  GRT(S,G)  |
+-------------------------------+------------+------------+------------+
| S becomes directly connected  | -&gt;F        | -&gt;P        |-&gt;F Cancel  |
|                               |            |            |  GRT(S,G)  |
+-------------------------------+------------+------------+------------+
| GRT(S,G) Expires              | N/A        | N/A        |-&gt;AP Send   |
|                               |            |            | Graft(S,G) |
|                               |            |            |Set GRT(S,G)|
+-------------------------------+------------+------------+------------+
| Receive GraftAck(S,G) from    | -&gt;F        | -&gt;P        |-&gt;F Cancel  |
| RPF&#39;(S)                       |            |            |  GRT(S,G)  |
+-------------------------------+------------+------------+------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition event &#34;RcvGraftAck(S,G)&#34; implies receiving a Graft Ack message targeted to this router&#39;s address on the incoming interface for the (S,G) entry. If the destination address is not correct, the state transitions in this state machine must not occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转换事件“RcvGraftAck（S，G）”意味着在（S，G）条目的传入接口上接收以该路由器地址为目标的graftack消息。如果目标地址不正确，则此状态机中的状态转换不得发生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1.1. Transitions from the Forwarding (F) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1.1. 从转发（F）状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Upstream(S,G) state machine is in the Forwarding (F) state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（S，G）状态机处于转发（F）状态时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Data Packet arrives on RPF_Interface(S) AND olist(S,G) == NULL AND S NOT directly connected The Upstream(S,G) state machine MUST transition to the Pruned (P) state, send a Prune(S,G) to RPF&#39;(S), and set PLT(S,G) to t_limit seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
数据包到达RPF_接口且olist（S，G）=NULL且未直接连接上游（S，G）状态机必须转换到修剪（P）状态，向RPF（S）发送修剪（S，G），并将PLT（S，G）设置为t_限制秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
State Refresh(S,G) Received from RPF&#39;(S) The Upstream(S,G) state machine remains in a Forwarding state. If the received State Refresh has the Prune Indicator bit set to one, this router must override the upstream router&#39;s Prune state after a short random interval. If OT(S,G) is not running and the Prune Indicator bit equals one, the router MUST set OT(S,G) to t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从RPF（S）接收的状态刷新（S，G）上游（S，G）状态机保持转发状态。如果接收到的状态刷新将修剪指示符位设置为1，则此路由器必须在短随机间隔后覆盖上游路由器的修剪状态。如果OT（S，G）未运行且修剪指示符位等于1，路由器必须将OT（S，G）设置为t_覆盖秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Join(S,G) to RPF&#39;(S) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Join(S,G) to RPF&#39;(S,G). If the OT(S,G) is running, then it means that the router had scheduled a Join to override a previously received Prune. Another router has responded more quickly with a Join, so the local router SHOULD cancel its OT(S,G), if it is running. The Upstream(S,G) state machine remains in the Forwarding (F) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅将（S，G）连接到RPF’（S）。只有当RPF_接口是共享介质时，此事件才相关。此路由器看到RPF_接口上的另一个路由器向RPF&#39;（S，G）发送连接（S，G）。如果OT（S，G）正在运行，那么这意味着路由器已经安排了一个连接来覆盖先前接收到的修剪。另一个路由器的响应速度更快，因此如果本地路由器正在运行，则应该取消其OT（S，G）。上游（S，G）状态机保持在转发（F）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(S,G) AND S NOT directly connected This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(S,G). As this router is in Forwarding state, it must override the Prune after a short random interval. If OT(S,G) is not running, the router MUST set OT(S,G) to t_override seconds. The Upstream(S,G) state machine remains in Forwarding (F) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅Prune（S，G）和S NOT directly connected仅当RPF_接口是共享介质时，此事件才相关。此路由器看到RPF_接口上的另一个路由器发送修剪（S，G）。由于此路由器处于转发状态，它必须在短的随机间隔后覆盖修剪。如果OT（S，G）未运行，路由器必须将OT（S，G）设置为t_覆盖秒。上游（S，G）状态机保持在转发（F）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
OT(S,G) Expires AND S NOT directly connected The OverrideTimer (OT(S,G)) expires. The router MUST send a Join(S,G) to RPF&#39;(S) to override a previously detected prune. The Upstream(S,G) state machine remains in the Forwarding (F) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
OT（S，G）到期，且未直接连接重写器的S（OT（S，G））到期。路由器必须向RPF（S，G）发送连接，以覆盖先前检测到的修剪。上游（S，G）状态机保持在转发（F）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
olist(S,G) -&gt; NULL AND S NOT directly connected The Upstream(S,G) state machine MUST transition to the Pruned (P) state, send a Prune(S,G) to RPF&#39;(S), and set PLT(S,G) to t_limit seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
olist（S，G）-&gt;NULL和S未直接连接上游（S，G）状态机必须转换到修剪（P）状态，向RPF（S）发送修剪（S，G），并将PLT（S，G）设置为t_限制秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S) Changes AND olist(S,G) is non-NULL AND S NOT directly connected Unicast routing or Assert state causes RPF&#39;(S) to change, including changes to RPF_Interface(S). The Upstream(S,G) state machine MUST transition to the AckPending (AP) state, unicast a Graft to the new RPF&#39;(S), and set the GraftRetry Timer (GRT(S,G)) to Graft_Retry_Period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF’（S）发生更改，且olist（S，G）为非NULL，且S未直接连接单播路由或断言状态导致RPF’（S）发生更改，包括对RPF_接口的更改。上游（S，G）状态机必须转换到AckPending（AP）状态，单播一个嫁接到新的RPF（S），并将嫁接重试计时器（GRT（S，G））设置为嫁接重试周期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S) Changes AND olist(S,G) is NULL Unicast routing or Assert state causes RPF&#39;(S) to change, including changes to RPF_Interface(S). The Upstream(S,G) state machine MUST transition to the Pruned (P) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF’（S）更改，且olist（S，G）为空单播路由或断言状态导致RPF’（S）更改，包括对RPF_接口的更改。上游（S，G）状态机必须转换到修剪（P）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1.2. Transitions from the Pruned (P) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1.2. 从修剪（P）状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Upstream(S,G) state machine is in the Pruned (P) state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（S，G）状态机处于修剪（P）状态时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Data arrives on RPF_interface(S) AND PLT(S,G) not running AND S NOT directly connected Either another router on the LAN desires traffic from S addressed to G or a previous Prune was lost. To prevent generating a Prune(S,G) in response to every data packet, the PruneLimit Timer (PLT(S,G)) is used. Once the PLT(S,G) expires, the router needs to send another prune in response to a data packet not received directly from the source. A Prune(S,G) MUST be sent to RPF&#39;(S), and the PLT(S,G) MUST be set to t_limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
数据到达RPF_接口，PLT（S，G）未运行，且S未直接连接LAN上的另一个路由器，需要从S发送到G的流量，或者先前的修剪丢失。为了防止响应于每个数据包生成修剪（S，G），使用了修剪限制计时器（PLT（S，G））。一旦从另一个PLT源接收到的数据（prune），则不需要直接发送到另一个PLT源。修剪（S，G）必须发送到RPF’（S），并且PLT（S，G）必须设置为t_限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
State Refresh(S,G) Received from RPF&#39;(S) The Upstream(S,G) state machine remains in a Pruned state. If the State Refresh has its Prune Indicator bit set to zero and PLT(S,G) is not running, a Prune(S,G) MUST be sent to RPF&#39;(S), and the PLT(S,G) MUST be set to t_limit. If the State Refresh has its Prune Indicator bit set to one, the router MUST reset PLT(S,G) to t_limit.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从RPF（S）接收的状态刷新（S，G）上游（S，G）状态机保持修剪状态。如果状态刷新将其修剪指示符位设置为零，并且PLT（S，G）未运行，则必须将修剪（S，G）发送到RPF’（S），并且PLT（S，G）必须设置为t_limit。如果状态刷新将其修剪指示符位设置为1，路由器必须将PLT（S，G）重置为t_限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(S,G) to RPF&#39;(S) A Prune(S,G) is seen on RPF_interface(S) to RPF&#39;(S). The Upstream(S,G) state machine stays in the Pruned (P) state. The router MAY reset its PLT(S,G) to the value in the Holdtime field of the received message if it is greater than the current value of the PLT(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参见修剪（S，G）到RPF’（S）在RPF_接口到RPF’（S）上可以看到修剪（S，G）。上游（S，G）状态机保持在修剪（P）状态。如果其大于PLT（S，G）的当前值，则路由器可将其PLT（S，G）重置为所接收消息的保持时间字段中的值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
olist(S,G)-&gt;non-NULL AND S NOT directly connected The set of interfaces defined by the olist(S,G) macro becomes non-empty, indicating that traffic from S addressed to group G must be forwarded. The Upstream(S,G) state machine MUST cancel PLT(S,G), transition to the AckPending (AP) state and unicast a
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
olist（S，G）-&gt;非空且未直接连接。由olist（S，G）宏定义的接口集变为非空，表示必须转发从S到G组的通信量。上游（S，G）状态机必须取消PLT（S，G），转换到AckPending（AP）状态并单播a
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
Graft message to RPF&#39;(S). The Graft Retry Timer (GRT(S,G)) MUST be set to Graft_Retry_Period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
将消息嫁接到RPF（S）。嫁接重试计时器（GRT（S，G））必须设置为嫁接重试周期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S) Changes AND olist(S,G) == non-NULL AND S NOT directly connected Unicast routing or Assert state causes RPF&#39;(S) to change, including changes to RPF_Interface(S). The Upstream(S,G) state machine MUST cancel PLT(S,G), transition to the AckPending (AP) state, send a Graft unicast to the new RPF&#39;(S), and set the GraftRetry Timer (GRT(S,G)) to Graft_Retry_Period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF’（S）更改和olist（S，G）=非空且S未直接连接单播路由或断言状态导致RPF’（S）更改，包括对RPF_接口的更改。上游（S，G）状态机必须取消PLT（S，G），转换到AckPending（AP）状态，向新RPF（S）发送嫁接单播，并将嫁接重试计时器（GRT（S，G））设置为嫁接重试周期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S) Changes AND olist(S,G) == NULL AND S NOT directly connected Unicast routing or Assert state causes RPF&#39;(S) to change, including changes to RPF_Interface(S). The Upstream(S,G) state machine stays in the Pruned (P) state and MUST cancel the PLT(S,G) timer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF’（S）更改和olist（S，G）=NULL，且S未直接连接单播路由或断言状态导致RPF’（S）更改，包括对RPF_接口的更改。上游（S，G）状态机保持在修剪（P）状态，并且必须取消PLT（S，G）计时器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
S becomes directly connected Unicast routing changed so that S is directly connected. The Upstream(S,G) state machine remains in the Pruned (P) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
S变为直接连接单播路由已更改，因此S是直接连接的。上游（S，G）状态机保持在修剪（P）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1.3. Transitions from the AckPending (AP) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.1.3. 从AckPending（AP）状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Upstream(S,G) state machine is in the AckPending (AP) state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当上游（S，G）状态机处于AckPending（AP）状态时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
State Refresh(S,G) Received from RPF&#39;(S) with Prune Indicator == 1 The Upstream(S,G) state machine remains in an AckPending state. The router must override the upstream router&#39;s Prune state after a short random interval. If OT(S,G) is not running and the Prune Indicator bit equals one, the router MUST set OT(S,G) to t_override seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从RPF’（S）接收到状态刷新（S，G），且修剪指示符==1。上游（S，G）状态机仍处于AckPending状态。路由器必须在短的随机间隔后覆盖上游路由器的修剪状态。如果OT（S，G）未运行且修剪指示符位等于1，路由器必须将OT（S，G）设置为t_覆盖秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
State Refresh(S,G) Received from RPF&#39;(S) with Prune Indicator == 0 The router MUST cancel its GraftRetry Timer (GRT(S,G)) and transition to the Forwarding (F) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从RPF（S）接收的状态刷新（S，G），删除指示符==0路由器必须取消其重试计时器（GRT（S，G））并转换到转发（F）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Join(S,G) to RPF&#39;(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Join(S,G) to RPF&#39;(S,G). If the OT(S,G) is running, then it means that the router had scheduled a Join to override a previously received Prune. Another router has responded more quickly with a Join, so the local router SHOULD cancel its OT(S,G), if it is running. The Upstream(S,G) state machine remains in the AckPending (AP) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅将（S，G）连接到RPF&#39;（S，G）此事件仅在RPF_接口是共享介质时相关。此路由器看到RPF_接口上的另一个路由器向RPF&#39;（S，G）发送连接（S，G）。如果OT（S，G）正在运行，那么这意味着路由器已经安排了一个连接来覆盖先前接收到的修剪。另一个路由器的响应速度更快，因此如果本地路由器正在运行，则应该取消其OT（S，G）。上游（S，G）状态机仍处于AckPending（AP）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See Prune(S,G) This event is only relevant if RPF_interface(S) is a shared medium. This router sees another router on RPF_interface(S) send a Prune(S,G). As this router is in AckPending (AP) state, it must override the Prune after a short random interval. If OT(S,G) is not running, the router MUST set OT(S,G) to t_override seconds. The Upstream(S,G) state machine remains in AckPending (AP) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅Prune（S，G）。此事件仅在RPF_接口是共享介质时相关。此路由器看到RPF_接口上的另一个路由器发送修剪（S，G）。由于此路由器处于AckPending（AP）状态，它必须在短的随机间隔后覆盖修剪。如果OT（S，G）未运行，路由器必须将OT（S，G）设置为t_覆盖秒。上游（S，G）状态机仍处于AckPending（AP）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
OT(S,G) Expires The OverrideTimer (OT(S,G)) expires. The router MUST send a Join(S,G) to RPF&#39;(S). The Upstream(S,G) state machine remains in the AckPending (AP) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
OT（S，G）过期重写器（OT（S，G））过期。路由器必须向RPF（S，G）发送连接。上游（S，G）状态机仍处于AckPending（AP）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
olist(S,G) -&gt; NULL The set of interfaces defined by the olist(S,G) macro becomes null, indicating that traffic from S addressed to group G should no longer be forwarded. The Upstream(S,G) state machine MUST transition to the Pruned (P) state. A Prune(S,G) MUST be multicast to the RPF_interface(S), with RPF&#39;(S) named in the upstream neighbor field. The GraftRetry Timer (GRT(S,G)) MUST be cancelled, and PLT(S,G) MUST be set to t_limit seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
olist（S，G）-&gt;NULL由olist（S，G）宏定义的接口集变为NULL，表示从S到G组的通信量不应再转发。上游（S，G）状态机必须转换到修剪（P）状态。Prune（S，G）必须多播到RPF_接口，RPF（S）在上游邻居字段中命名。必须取消重试计时器（GRT（S，G）），并且必须将PLT（S，G）设置为t_limit seconds。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S) Changes AND olist(S,G) does not become NULL AND S NOT directly connected Unicast routing or Assert state causes RPF&#39;(S) to change, including changes to RPF_Interface(S). The Upstream(S,G) state machine stays in the AckPending (AP) state. A Graft MUST be unicast to the new RPF&#39;(S) and the GraftRetry Timer (GRT(S,G)) reset to Graft_Retry_Period.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF’（S）发生更改，并且olist（S，G）不会变为NULL，并且S未直接连接的单播路由或断言状态会导致RPF’（S）发生更改，包括对RPF_接口的更改。上游（S，G）状态机保持在AckPending（AP）状态。要重试嫁接，必须重置新的嫁接时间（GRU）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF&#39;(S) Changes AND olist(S,G) == NULL AND S NOT directly connected Unicast routing or Assert state causes RPF&#39;(S) to change, including changes to RPF_Interface(S). The Upstream(S,G) state machine MUST transition to the Pruned (P) state. The GraftRetry Timer (GRT(S,G)) MUST be cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF’（S）更改和olist（S，G）=NULL，且S未直接连接单播路由或断言状态导致RPF’（S）更改，包括对RPF_接口的更改。上游（S，G）状态机必须转换到修剪（P）状态。必须取消重试计时器（GRT（S，G））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
S becomes directly connected Unicast routing has changed so that S is directly connected. The GraftRetry Timer MUST be cancelled, and the Upstream(S,G) state machine MUST transition to the Forwarding(F) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
S变为直接连接单播路由已更改，因此S是直接连接的。必须取消重试计时器，上游（S，G）状态机必须转换为转发（F）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
GRT(S,G) Expires The GraftRetry Timer (GRT(S,G)) expires for this (S,G) entry. The Upstream(S,G) state machine stays in the AckPending (AP) state. Another Graft message for (S,G) SHOULD be unicast to RPF&#39;(S) and the GraftRetry Timer (GRT(S,G)) reset to Graft_Retry_Period. It is RECOMMENDED that the router retry a configured number of times before ceasing retries.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
GRT（S，G）过期此（S，G）项的重试计时器（GRT（S，G））过期。上游（S，G）状态机保持在AckPending（AP）状态。（S，G）的另一个嫁接消息应单播到RPF’（S），嫁接重试计时器（GRT（S，G））重置为嫁接重试周期。建议路由器在停止重试之前重试配置的次数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
See GraftAck(S,G) from RPF&#39;(S) A GraftAck is received from RPF&#39;(S). The GraftRetry Timer MUST be cancelled, and the Upstream(S,G) state machine MUST transition to the Forwarding(F) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
请参阅来自RPF&#39;（S）的GraftAck（S，G）。从RPF&#39;（S）接收GraftAck。必须取消重试计时器，上游（S，G）状态机必须转换为转发（F）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. Downstream Prune, Join, and Graft Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2. 下游修剪、连接和嫁接消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Prune(S,G) Downstream state machine for receiving Prune, Join and Graft messages on interface I is given below. This state machine MUST always be in the NoInfo state on the upstream interface. It contains three states.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
下面给出了在接口I上接收Prune、Join和Graft消息的Prune（S，G）下游状态机。此状态机在上游接口上必须始终处于NoInfo状态。它包含三个状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo(NI) The interface has no (S,G) Prune state, and neither the Prune timer (PT(S,G,I)) nor the PrunePending timer ((PPT(S,G,I)) is running.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo（NI）接口没有（S，G）修剪状态，并且修剪计时器（PT（S，G，I））和修剪计时器（（PPT（S，G，I））都没有运行。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PrunePending(PP) The router has received a Prune(S,G) on this interface from a downstream neighbor and is waiting to see whether the prune will be overridden by another downstream router. For forwarding purposes, the PrunePending state functions exactly like the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
剪枝结束（PP）路由器已从下游邻居收到此接口上的剪枝（S，G），并等待查看该剪枝是否将被另一个下游路由器覆盖。出于转发目的，PrunePending状态的功能与NoInfo状态完全相同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Pruned(P) The router has received a Prune(S,G) on this interface from a downstream neighbor, and the Prune was not overridden. Data from S addressed to group G is no longer being forwarded on this interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪（P）路由器已从下游邻居收到此接口上的修剪（S，G），且修剪未被覆盖。从S发送到G组的数据不再在此接口上转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there are two timers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有两个计时器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PrunePending Timer (PPT(S,G,I)) This timer is set when a valid Prune(S,G) is received. Expiry of the PrunePending Timer (PPT(S,G,I)) causes the interface to transition to the Pruned state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪结束计时器（PPT（S，G，I））当接收到有效的修剪（S，G）时设置此计时器。修剪结束计时器（PPT（S，G，I））的到期将导致接口转换到修剪状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Prune Timer (PT(S,G,I)) This timer is set when the PrunePending Timer (PT(S,G,I)) expires. Expiry of the Prune Timer (PT(S,G,I)) causes the interface to transition to the NoInfo (NI) state, thereby allowing data from S addressed to group G to be forwarded on the interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
修剪计时器（PT（S，G，I））此计时器在修剪计时器（PT（S，G，I））过期时设置。修剪计时器（PT（S，G，I））的到期将导致接口转换到NoInfo（NI）状态，从而允许从S到组G的数据在接口上转发。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +-------------+                        +-------------+
            |             |      PPT Expires       |             |
            |PrunePending |-----------------------&gt;|   Pruned    |
            |             |                        |             |
            +-------------+                        +-------------+
                 |   ^                                      |
                 |   |                                      |
                 |   |Rcv Prune                             |
                 |   |                                      |
                 |   |         +-------------+              |
                 |   +---------|             |              |
                 |             |   NoInfo    |&lt;-------------+
                 +------------&gt;|             | Rcv Join/Graft OR
             Rcv Join/Graft OR +-------------+ PT Expires OR
           RPF_Interface(S)-&gt;I                 RPF_Interface(S)-&gt;I
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +-------------+                        +-------------+
            |             |      PPT Expires       |             |
            |PrunePending |-----------------------&gt;|   Pruned    |
            |             |                        |             |
            +-------------+                        +-------------+
                 |   ^                                      |
                 |   |                                      |
                 |   |Rcv Prune                             |
                 |   |                                      |
                 |   |         +-------------+              |
                 |   +---------|             |              |
                 |             |   NoInfo    |&lt;-------------+
                 +------------&gt;|             | Rcv Join/Graft OR
             Rcv Join/Graft OR +-------------+ PT Expires OR
           RPF_Interface(S)-&gt;I                 RPF_Interface(S)-&gt;I
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
Figure 2: Downstream Interface State Machine
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-17">
图2：下游接口状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In tabular form, the state machine is as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以表格形式，状态机如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
+                               +------------+------------+------------+
|            Event              |  No Info   | PrunePend  |   Pruned   |
+-------------------------------+------------+------------+------------+
| Receive Prune(S,G)            |-&gt;PP  Set   |-&gt;PP        |-&gt;P Reset   |
|                               | PPT(S,G,I) |            |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| Receive Join(S,G)             |-&gt;NI        |-&gt;NI Cancel |-&gt;NI Cancel |
|                               |            | PPT(S,G,I) |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| Receive Graft(S,G)            |-&gt;NI Send   |-&gt;NI Send   |-&gt;NI Send   |
|                               |  GraftAck  |  GraftAck  |  GraftAck  |
|                               |            |  Cancel    |  Cancel    |
|                               |            | PPT(S,G,I) |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| PPT(S,G) Expires              | N/A        |-&gt;P Set     | N/A        |
|                               |            |  PT(S,G,I) |            |
+-------------------------------+------------+------------+------------+
| PT(S,G) Expires               | N/A        | N/A        |-&gt;NI        |
+-------------------------------+------------+------------+------------+
| RPF_Interface(S) becomes I    |-&gt;NI        |-&gt;NI Cancel |-&gt;NI Cancel |
|                               |            | PPT(S,G,I) |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| Send State Refresh(S,G) out I |-&gt;NI        |-&gt;PP        |-&gt;P Reset   |
|                               |            |            |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
+                               +------------+------------+------------+
|            Event              |  No Info   | PrunePend  |   Pruned   |
+-------------------------------+------------+------------+------------+
| Receive Prune(S,G)            |-&gt;PP  Set   |-&gt;PP        |-&gt;P Reset   |
|                               | PPT(S,G,I) |            |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| Receive Join(S,G)             |-&gt;NI        |-&gt;NI Cancel |-&gt;NI Cancel |
|                               |            | PPT(S,G,I) |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| Receive Graft(S,G)            |-&gt;NI Send   |-&gt;NI Send   |-&gt;NI Send   |
|                               |  GraftAck  |  GraftAck  |  GraftAck  |
|                               |            |  Cancel    |  Cancel    |
|                               |            | PPT(S,G,I) |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| PPT(S,G) Expires              | N/A        |-&gt;P Set     | N/A        |
|                               |            |  PT(S,G,I) |            |
+-------------------------------+------------+------------+------------+
| PT(S,G) Expires               | N/A        | N/A        |-&gt;NI        |
+-------------------------------+------------+------------+------------+
| RPF_Interface(S) becomes I    |-&gt;NI        |-&gt;NI Cancel |-&gt;NI Cancel |
|                               |            | PPT(S,G,I) |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
| Send State Refresh(S,G) out I |-&gt;NI        |-&gt;PP        |-&gt;P Reset   |
|                               |            |            |  PT(S,G,I) |
+-------------------------------+------------+------------+------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The transition events &#34;Receive Graft(S,G)&#34;, &#34;Receive Prune(S,G)&#34;, and &#34;Receive Join(S,G)&#34; denote receiving a Graft, Prune, or Join message in which this router&#39;s address on I is contained in the message&#39;s upstream neighbor field. If the upstream neighbor field does not match this router&#39;s address on I, then these state transitions in this state machine must not occur.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
转换事件“接收嫁接（S，G）”、“接收修剪（S，G）”和“接收加入（S，G）”表示接收嫁接、修剪或加入消息，其中该路由器在I上的地址包含在消息的上游邻居字段中。如果上游邻居字段与I上此路由器的地址不匹配，则此状态机中的这些状态转换不得发生。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.1. Transitions from the NoInfo State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.1. 从NoInfo状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Prune(S,G) Downstream state machine is in the NoInfo (NI) state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当Prune（S，G）下游状态机处于NoInfo（NI）状态时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G) A Prune(S,G) is received on interface I with the upstream neighbor field set to the router&#39;s address on I. The Prune(S,G) Downstream state machine on interface I MUST transition to the PrunePending (PP) state. The PrunePending Timer (PPT(S,G,I)) MUST be set to J/P_Override_Interval if the router has more than
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G）在接口I上接收修剪（S，G），上游邻居字段设置为I上路由器的地址。接口I上的修剪（S，G）下游状态机必须转换为修剪结束（PP）状态。如果路由器具有超过1个以上的路径，则必须将修剪结束计时器（PPT（S，G，I））设置为J/P_覆盖_间隔
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
one neighbor on I. If the router has only one neighbor on interface I, then it SHOULD set the PPT(S,G,I) to zero, effectively transitioning immediately to the Pruned (P) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
I上的一个邻居。如果路由器在接口I上只有一个邻居，那么它应该将PPT（S，G，I）设置为零，有效地立即转换为修剪（P）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Graft(S,G) A Graft(S,G) is received on the interface I with the upstream neighbor field set to the router&#39;s address on I. The Prune(S,G) Downstream state machine on interface I stays in the NoInfo (NI) state. A GraftAck(S,G) MUST be unicast to the originator of the Graft(S,G) message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收嫁接（S，G）在接口I上接收嫁接（S，G），上游邻居字段设置为I上路由器的地址。接口I上的修剪（S，G）下游状态机保持NoInfo（NI）状态。GraftAck（S，G）必须单播到GraftAck（S，G）消息的发起者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.2. Transitions from the PrunePending (PP) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.2. 从修剪结束（PP）状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Prune(S,G) downstream state machine is in the PrunePending (PP) state, the following events may trigger a transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当修剪（S，G）下游状态机处于修剪结束（PP）状态时，以下事件可能触发转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G) A Join(S,G) is received on interface I with the upstream neighbor field set to the router&#39;s address on I. The Prune(S,G) Downstream state machine on interface I MUST transition to the NoInfo (NI) state. The PrunePending Timer (PPT(S,G,I)) MUST be cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（S，G）在接口I上接收连接（S，G），上游邻居字段设置为I上路由器的地址。接口I上的修剪（S，G）下游状态机必须转换为NoInfo（NI）状态。必须取消剪枝计时器（PPT（S、G、I））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Graft(S,G) A Graft(S,G) is received on interface I with the upstream neighbor field set to the router&#39;s address on I. The Prune(S,G) Downstream state machine on interface I MUST transition to the NoInfo (NI) state and MUST unicast a Graft Ack message to the Graft originator. The PrunePending Timer (PPT(S,G,I)) MUST be cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收嫁接（S，G）在接口I上接收嫁接（S，G），上游邻居字段设置为I上路由器的地址。接口I上的修剪（S，G）下游状态机必须转换为NoInfo（NI）状态，并且必须单播嫁接确认消息给嫁接发起人。必须取消剪枝计时器（PPT（S、G、I））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PPT(S,G,I) Expires The PrunePending Timer (PPT(S,G,I)) expires, indicating that no neighbors have overridden the previous Prune(S,G) message. The Prune(S,G) Downstream state machine on interface I MUST transition to the Pruned (P) state. The Prune Timer (PT(S,G,I)) is started and MUST be initialized to the received Prune_Hold_Time minus J/P_Override_Interval. A PruneEcho(S,G) MUST be sent on I if I has more than one PIM neighbor. A PruneEcho(S,G) is simply a Prune(S,G) message multicast by the upstream router to a LAN, with itself as the Upstream Neighbor. Its purpose is to add additional reliability so that if a Join that should have overridden the Prune is lost locally on the LAN, the PruneEcho(S,G) may be received and trigger a new Join message. A PruneEcho(S,G) is OPTIONAL on an interface with only one PIM neighbor. In addition, the router MUST evaluate any possible transitions in the Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PPT（S，G，I）过期修剪结束计时器（PPT（S，G，I））过期，表示没有邻居覆盖了以前的修剪（S，G）消息。接口I上的Prune（S，G）下游状态机必须转换为Prune（P）状态。修剪计时器（PT（S，G，I））启动，必须初始化为接收到的修剪保持时间减去J/P覆盖时间间隔。如果我有多个PIM邻居，则必须在I上发送Prueecho（S，G）。PruneEcho（S，G）简单地说就是上游路由器到局域网的Prune（S，G）消息多播，其自身作为上游邻居。它的目的是增加额外的可靠性，以便在LAN上本地丢失本应覆盖修剪的连接时，可以接收到prueecho（S，G）并触发新的连接消息。在只有一个PIM邻居的接口上，prueecho（S，G）是可选的。此外，路由器必须评估上游（S，G）状态机中的任何可能转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_Interface(S) becomes interface I The upstream interface for S has changed. The Prune(S,G) Downstream state machine on interface I MUST transition to the NoInfo (NI) state. The PrunePending Timer (PPT(S,G,I)) MUST be cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_接口变为接口I。S的上游接口已更改。接口I上的Prune（S，G）下游状态机必须转换为NoInfo（NI）状态。必须取消剪枝计时器（PPT（S、G、I））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.3. Transitions from the Prune (P) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.4.2.3. 从修剪（P）状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Prune(S,G) Downstream state machine is in the Pruned (P) state, the following events may trigger a transition.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当修剪（S，G）下游状态机处于修剪（P）状态时，以下事件可能触发转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G) A Prune(S,G) is received on the interface I with the upstream neighbor field set to the router&#39;s address on I. The Prune(S,G) Downstream state machine on interface I remains in the Pruned (P) state. The Prune Timer (PT(S,G,I)) SHOULD be reset to the holdtime contained in the Prune(S,G) message if it is greater than the current value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G）在接口I上接收修剪（S，G），上游邻居字段设置为I上路由器的地址。接口I上的修剪（S，G）下游状态机保持修剪（P）状态。如果修剪计时器（PT（S，G，I））大于当前值，则应将其重置为修剪（S，G）消息中包含的保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Join(S,G) A Join(S,G) is received on the interface I with the upstream neighbor field set to the router&#39;s address on I. The Prune(S,G) downstream state machine on interface I MUST transition to the NoInfo (NI) state. The Prune Timer (PT(S,G,I)) MUST be cancelled. The router MUST evaluate any possible transitions in the Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收连接（S，G）在接口I上接收连接（S，G），上游邻居字段设置为I上路由器的地址。接口I上的修剪（S，G）下游状态机必须转换为NoInfo（NI）状态。必须取消修剪计时器（PT（S，G，I））。路由器必须评估上行（S，G）状态机中任何可能的转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Graft(S,G) A Graft(S,G) is received on interface I with the upstream neighbor field set to the router&#39;s address on I. The Prune(S,G) Downstream state machine on interface I MUST transition to the NoInfo (NI) state and send a Graft Ack back to the Graft&#39;s source. The Prune Timer (PT(S,G,I)) MUST be cancelled. The router MUST evaluate any possible transitions in the Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收嫁接（S，G）在接口I上接收嫁接（S，G），上游邻居字段设置为I上路由器的地址。接口I上的修剪（S，G）下游状态机必须转换为NoInfo（NI）状态，并将嫁接确认发送回嫁接的源。必须取消修剪计时器（PT（S，G，I））。路由器必须评估上行（S，G）状态机中任何可能的转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PT(S,G,I) Expires The Prune Timer (PT(S,G,I)) expires, indicating that it is again time to flood data from S addressed to group G onto interface I. The Prune(S,G) Downstream state machine on interface I MUST transition to the NoInfo (NI) state. The router MUST evaluate any possible transitions in the Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
PT（S，G，I）过期修剪计时器（PT（S，G，I））过期，表示再次是时候将S中的数据发送到组G到接口I上。接口I上的修剪（S，G）下游状态机必须转换到NoInfo（NI）状态。路由器必须评估上行（S，G）状态机中任何可能的转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_Interface(S) becomes interface I The upstream interface for S has changed. The Prune(S,G) Downstream state machine on interface I MUST transition to the NoInfo (NI) state. The PruneTimer (PT(S,G,I)) MUST be cancelled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
RPF_接口变为接口I。S的上游接口已更改。接口I上的Prune（S，G）下游状态机必须转换为NoInfo（NI）状态。必须取消PruneTimer（PT（S，G，I））。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Send State Refresh(S,G) out interface I The router has refreshed the Prune(S,G) state on interface I. The router MUST reset the Prune Timer (PT(S,G,I)) to the Holdtime from an active Prune received on interface I. The Holdtime used SHOULD be the largest active one but MAY be the most recently received active Prune Holdtime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
发送状态刷新（S，G）输出接口I路由器已刷新接口I上的修剪（S，G）状态。路由器必须将修剪计时器（PT（S，G，I））重置为从接口I上接收到的活动修剪的保持时间。使用的保持时间应该是最大的活动修剪，但可能是最近接收到的活动修剪保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. State Refresh
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5. 状态刷新
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the major portions of the state refresh mechanism.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍状态刷新机制的主要部分。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. Forwarding of State Refresh Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.1. 转发状态刷新消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a State Refresh message, SRM, is received, it is forwarded according to the following pseudo-code.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当收到状态刷新消息SRM时，将根据以下伪代码转发该消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (iif != RPF_interface(S))
     return;
   if (RPF&#39;(S) != srcaddr(SRM))
     return;
   if (StateRefreshRateLimit(S,G) == TRUE)
     return;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   if (iif != RPF_interface(S))
     return;
   if (RPF&#39;(S) != srcaddr(SRM))
     return;
   if (StateRefreshRateLimit(S,G) == TRUE)
     return;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   for each interface I in pim_nbrs {
     if (TTL(SRM) == 0 OR (TTL(SRM) - 1) &lt; Threshold(I))
       continue;     /* Out of TTL, skip this interface */
     if (boundary(I,G))
       continue;     /* This interface is scope boundary, skip it */
     if (I == iif)
       continue;     /* This is the incoming interface, skip it */
     if (lost_assert(S,G,I) == TRUE)
       continue;     /* Let the Assert Winner do State Refresh */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   for each interface I in pim_nbrs {
     if (TTL(SRM) == 0 OR (TTL(SRM) - 1) &lt; Threshold(I))
       continue;     /* Out of TTL, skip this interface */
     if (boundary(I,G))
       continue;     /* This interface is scope boundary, skip it */
     if (I == iif)
       continue;     /* This is the incoming interface, skip it */
     if (lost_assert(S,G,I) == TRUE)
       continue;     /* Let the Assert Winner do State Refresh */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     Copy SRM to SRM&#39;;   /* Make a copy of SRM to forward */
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     Copy SRM to SRM&#39;;   /* Make a copy of SRM to forward */
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (I contained in prunes(S,G)) {
       set Prune Indicator bit of SRM&#39; to 1;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (I contained in prunes(S,G)) {
       set Prune Indicator bit of SRM&#39; to 1;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if StateRefreshCapable(I) == TRUE
         set PT(S,G) to largest active holdtime read from a Prune
         message accepted on I;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       if StateRefreshCapable(I) == TRUE
         set PT(S,G) to largest active holdtime read from a Prune
         message accepted on I;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     } else {
       set Prune Indicator bit of SRM&#39; to 0;
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     } else {
       set Prune Indicator bit of SRM&#39; to 0;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     set srcaddr(SRM&#39;) to my_addr(I);
     set TTL of SRM&#39; to TTL(SRM) - 1;
     set metric of SRM&#39; to metric of unicast route used to reach S;
     set pref of SRM&#39; to preference of unicast route used to reach S;
     set mask of SRM&#39; to mask of route used to reach S;
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     set srcaddr(SRM&#39;) to my_addr(I);
     set TTL of SRM&#39; to TTL(SRM) - 1;
     set metric of SRM&#39; to metric of unicast route used to reach S;
     set pref of SRM&#39; to preference of unicast route used to reach S;
     set mask of SRM&#39; to mask of route used to reach S;
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (AssertState == NoInfo) {
       set Assert Override of SRM&#39; to 1;
     } else {
       set Assert Override of SRM&#39; to 0;
     }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     if (AssertState == NoInfo) {
       set Assert Override of SRM&#39; to 1;
     } else {
       set Assert Override of SRM&#39; to 0;
     }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     transmit SRM&#39; on I;
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
     transmit SRM&#39; on I;
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The pseudocode above employs the following macro definitions.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上面的伪代码采用以下宏定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Boundary(I,G) is TRUE if an administratively scoped boundary for group G is configured on interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果在接口I上配置了组G的管理范围边界，则边界（I，G）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StateRefreshCapable(I) is TRUE if all neighbors on an interface use the State Refresh option.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果接口上的所有邻居都使用状态刷新选项，则StateRefreshCapable（I）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
StateRefreshRateLimit(S,G) is TRUE if the time elapsed since the last received StateRefresh(S,G) is less than the configured RefreshLimitInterval.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果自上次接收到StateRefresh（S，G）以来经过的时间小于配置的RefreshLimitInterval，则StateRefreshRateLimit（S，G）为真。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TTL(SRM) returns the TTL contained in the State Refresh Message, SRM. This is different from the TTL contained in the IP header.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TTL（SRM）返回状态刷新消息SRM中包含的TTL。这与IP头中包含的TTL不同。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Threshold(I) returns the minimum TTL that a packet must have before it can be transmitted on interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
阈值（I）返回数据包在接口I上传输之前必须具有的最小TTL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
srcaddr(SRM) returns the source address contained in the network protocol (e.g., IPv4) header of the State Refresh Message, SRM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
srcaddr（SRM）返回状态刷新消息SRM的网络协议（例如IPv4）头中包含的源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
my_addr(I) returns this node&#39;s network (e.g., IPv4) address on interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
my_addr（I）在接口I上返回此节点的网络（例如IPv4）地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. State Refresh Message Origination
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2. 状态刷新消息源
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section describes the origination of State Refresh messages. These messages are generated periodically by the PIM-DM router directly connected to a source. One Origination(S,G) state machine exists per (S,G) entry in a PIM-DM router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节介绍状态刷新消息的起源。这些消息由直接连接到源的PIM-DM路由器定期生成。PIM-DM路由器中每个（S，G）条目都存在一个原始（S，G）状态机。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Origination(S,G) state machine has the following states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发起（S，G）状态机具有以下状态：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NotOriginator(NO) This is the starting state of the Origination(S,G) state machine. While in this state, a router will not originate State Refresh messages for the (S,G) pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NOTRIGINATOR（否）这是起始（S，G）状态机的起始状态。在此状态下，路由器不会为（S，G）对发起状态刷新消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Originator(O) When in this state the router will periodically originate State Refresh messages. Only routers directly connected to S may transition to this state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
发起者（O）处于该状态时，路由器将定期发起状态刷新消息。只有直接连接到S的路由器才能转换到此状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, there are two state machine specific timers:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，还有两个特定于状态机的计时器：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
State Refresh Timer (SRT(S,G)) This timer controls when State Refresh messages are generated. The timer is initially set when that Origination(S,G) state machine transitions to the O state. It is cancelled when the Origination(S,G) state machine transitions to the NO state. This timer is normally set to StateRefreshInterval (see 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
状态刷新计时器（SRT（S，G））此计时器控制何时生成状态刷新消息。当发端（S，G）状态机转换为O状态时，计时器最初设置。当发端（S、G）状态机转换为“否”状态时，它将被取消。该计时器通常设置为StateRefreshInterval（见4.8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Source Active Timer (SAT(S,G)) This timer is first set when the Origination(S,G) state machine transitions to the O state and is reset on the receipt of every data packet from S addressed to group G. When it expires, the Origination(S,G) state machine transitions to the NO state. This timer is normally set to SourceLifetime (see 4.8).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
源活动计时器（SAT（S，G））当发端（S，G）状态机转换为O状态时，首先设置此计时器，并在接收到从S发往G组的每个数据包时重置。当其过期时，发端（S，G）状态机转换为NO状态。此计时器通常设置为SourceLifetime（参见4.8）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +-------------+  Rcv Directly From S   +-------------+
            |             |-----------------------&gt;|             |
            |NotOriginator|                        | Originator  |
            |             |&lt;-----------------------|             |
            +-------------+     SAT Expires OR     +-------------+
                             S NOT Direct Connect
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
            +-------------+  Rcv Directly From S   +-------------+
            |             |-----------------------&gt;|             |
            |NotOriginator|                        | Originator  |
            |             |&lt;-----------------------|             |
            +-------------+     SAT Expires OR     +-------------+
                             S NOT Direct Connect
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 3: State Refresh State Machine
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
图3：状态刷新状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In tabular form, the state machine is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以表格形式，状态机定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                                  |           Previous State          |
|                                  +---------------+-------------------+
|            Event                 | NotOriginator |    Originator     |
+----------------------------------+---------------+-------------------+
| Receive Data from S AND          | -&gt;O           | -&gt;O Reset         |
| S directly connected             | Set SRT(S,G)  |     SAT(S,G)      |
|                                  | Set SAT(S,G)  |                   |
+----------------------------------+---------------+-------------------+
| SRT(S,G) Expires                 | N/A           | -&gt;O    Send       |
|                                  |               | StateRefresh(S,G) |
|                                  |               |  Reset SRT(S,G)   |
+----------------------------------+---------------+-------------------+
| SAT(S,G) Expires                 | N/A           | -&gt;NO  Cancel      |
|                                  |               |       SRT(S,G)    |
+----------------------------------+---------------+-------------------+
| S no longer directly connected   | -&gt;NO          | -&gt;NO              |
|                                  |               |   Cancel SRT(S,G) |
|                                  |               |   Cancel SAT(S,G) |
+----------------------------------+---------------+-------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+----------------------------------------------------------------------+
|                                  |           Previous State          |
|                                  +---------------+-------------------+
|            Event                 | NotOriginator |    Originator     |
+----------------------------------+---------------+-------------------+
| Receive Data from S AND          | -&gt;O           | -&gt;O Reset         |
| S directly connected             | Set SRT(S,G)  |     SAT(S,G)      |
|                                  | Set SAT(S,G)  |                   |
+----------------------------------+---------------+-------------------+
| SRT(S,G) Expires                 | N/A           | -&gt;O    Send       |
|                                  |               | StateRefresh(S,G) |
|                                  |               |  Reset SRT(S,G)   |
+----------------------------------+---------------+-------------------+
| SAT(S,G) Expires                 | N/A           | -&gt;NO  Cancel      |
|                                  |               |       SRT(S,G)    |
+----------------------------------+---------------+-------------------+
| S no longer directly connected   | -&gt;NO          | -&gt;NO              |
|                                  |               |   Cancel SRT(S,G) |
|                                  |               |   Cancel SAT(S,G) |
+----------------------------------+---------------+-------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2.1. Transitions from the NotOriginator (NO) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2.1. 从NotRiginator（否）状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Originating(S,G) state machine is in the NotOriginator (NO) state, the following event may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当原始（S，G）状态机处于NotRiginator（NO）状态时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Data Packet received from directly connected Source S addressed to group G The router MUST transition to an Originator (O) state, set SAT(S,G) to SourceLifetime, and set SRT(S,G) to StateRefreshInterval. The router SHOULD record the TTL of the packet for use in State Refresh messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从直接连接的源S接收到的数据包发往G组路由器必须转换为发起者（O）状态，将SAT（S，G）设置为SourceLifetime，并将SRT（S，G）设置为StateRefreshInterval。路由器应记录数据包的TTL，以便在状态刷新消息中使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2.2. Transitions from the Originator (O) State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.5.2.2. 从发起人（O）状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When the Originating(S,G) state machine is in the Originator (O) state, the following events may trigger a transition:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当原始（S，G）状态机处于原始（O）状态时，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Data Packet from S addressed to G The router remains in the Originator (O) state and MUST reset SAT(S,G) to SourceLifetime. The router SHOULD increase its recorded TTL to match the TTL of the packet, if the packet&#39;s TTL is larger than the previously recorded TTL. A router MAY record the TTL based on an implementation specific sampling policy to avoid examining the TTL of every multicast packet it handles.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从发送到G的S接收数据包路由器仍处于发起者（O）状态，并且必须将SAT（S，G）重置为SourceLifetime。如果包的TTL大于先前记录的TTL，路由器应增加其记录的TTL以匹配包的TTL。路由器可以基于特定于实现的采样策略记录TTL，以避免检查其处理的每个多播分组的TTL。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
SRT(S,G) Expires The router remains in the Originator (O) state and MUST reset SRT(S,G) to StateRefreshInterval. The router MUST also generate State Refresh messages for transmission, as described in the State Refresh Forwarding rules (Section 4.5.1), except for the TTL. If the TTL of data packets from S to G are being recorded, then the TTL of each State Refresh message is set to the highest recorded TTL. Otherwise, the TTL is set to the configured State Refresh TTL. Let I denote the interface over which a State Refresh message is being sent. If the Prune(S,G) Downstream state machine is in the Pruned (P) state, then the Prune-Indicator bit MUST be set to 1 in the State Refresh message being sent over I. Otherwise, the Prune-Indicator bit MUST be set to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
SRT（S，G）过期路由器仍处于发起者（O）状态，必须将SRT（S，G）重置为StateRefreshInterval。路由器还必须生成用于传输的状态刷新消息，如状态刷新转发规则（第4.5.1节）所述，TTL除外。如果正在记录从S到G的数据包的TTL，则每个状态刷新消息的TTL设置为记录的最高TTL。否则，TTL设置为配置状态刷新TTL。让我表示发送状态刷新消息的接口。如果修剪（S，G）下游状态机处于修剪（P）状态，则在通过I发送的状态刷新消息中，修剪指示符位必须设置为1。否则，修剪指示符位必须设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
SAT(S,G) Expires The router MUST cancel the SRT(S,G) timer and transition to the NotOriginator (NO) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
SAT（S，G）过期路由器必须取消SRT（S，G）计时器并转换到NOTIGINATOR（NO）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
S is no longer directly connected The router MUST transition to the NotOriginator (NO) state and cancel both the SAT(S,G) and SRT(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
S不再直接连接，路由器必须转换到NOTIGINATOR（no）状态并取消SAT（S，G）和SRT（S，G）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. PIM Assert Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6. PIM断言消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. Assert Metrics
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.1. 断言度量
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Assert metrics are defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
断言度量定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct assert_metric {
     metric_preference;
     route_metric;
     ip_address;
   };
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   struct assert_metric {
     metric_preference;
     route_metric;
     ip_address;
   };
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When assert_metrics are compared, the metric_preference and route_metric field are compared in order, where the first lower value wins. If all fields are equal, the IP address of the router that sourced the Assert message is used as a tie-breaker, with the highest IP address winning.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
比较assert_度量时，将按顺序比较度量_首选项和route_度量字段，其中第一个较低的值获胜。如果所有字段都相等，则源于断言消息的路由器的IP地址将用作平局断路器，最高IP地址获胜。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Assert metric for (S,G) to include in (or compare against) an Assert message sent on interface I should be computed by using the following pseudocode:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
应使用以下伪代码计算（S，G）的断言度量，以将其包含在接口I上发送的断言消息中（或与之进行比较）：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   assert_metric
   my_assert_metric(S,G,I) {
     if (CouldAssert(S,G,I) == TRUE) {
       return spt_assert_metric(S,G,I)
     } else {
       return infinite_assert_metric()
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   assert_metric
   my_assert_metric(S,G,I) {
     if (CouldAssert(S,G,I) == TRUE) {
       return spt_assert_metric(S,G,I)
     } else {
       return infinite_assert_metric()
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
spt_assert_metric(S,I) gives the Assert metric we use if we&#39;re sending an Assert based on active (S,G) forwarding state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
spt_assert_metric（S，I）给出了我们在基于活动（S，G）转发状态发送断言时使用的断言度量：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   assert_metric
   spt_assert_metric(S,I) {
     return {0,MRIB.pref(S),MRIB.metric(S),my_addr(I)}
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   assert_metric
   spt_assert_metric(S,I) {
     return {0,MRIB.pref(S),MRIB.metric(S),my_addr(I)}
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MRIB.pref(X) and MRIB.metric(X) are the routing preference and routing metrics associated with the route to a particular (unicast) destination X, as determined by the MRIB. my_addr(I) is simply the router&#39;s network (e.g., IP) address associated with the local interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MRIB.pref（X）和MRIB.metric（X）是与到特定（单播）目的地X的路由相关联的路由首选项和路由度量，由MRIB确定。my_addr（I）只是与本地接口I关联的路由器网络（例如，IP）地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
infinite_assert_metric() gives the Assert metric we need to send an Assert but doesn&#39;t match (S,G) forwarding state:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
infinite_assert_metric（）提供了我们需要发送断言但与（S，G）转发状态不匹配的断言度量：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   assert_metric
   infinite_assert_metric() {
     return {1,infinity,infinity,0}
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   assert_metric
   infinite_assert_metric() {
     return {1,infinity,infinity,0}
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. AssertCancel Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.2. 资产取消消息
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An AssertCancel(S,G) message is simply an Assert message for (S,G) with infinite metric. The Assert winner sends this message when it changes its upstream interface to this interface. Other routers will see this metric, causing those with forwarding state to send their own Asserts and re-establish an Assert winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel（S，G）消息只是具有无限度量的（S，G）的断言消息。Assert winner将其上游接口更改为此接口时发送此消息。其他路由器将看到此度量，导致那些具有转发状态的路由器发送自己的断言并重新建立断言赢家。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel messages are simply an optimization. The original Assert timeout mechanism will eventually allow a subnet to become consistent; the AssertCancel mechanism simply causes faster convergence. No special processing is required for an AssertCancel message, as it is simply an Assert message from the current winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertCancel消息只是一种优化。最初的断言超时机制最终将允许子网变得一致；AssertCancel机制只会加快收敛速度。AssertCancel消息不需要特殊处理，因为它只是来自当前获胜者的断言消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. Assert State Macros
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.3. 断言状态宏
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The macro lost_assert(S,G,I), is used in the olist computations of Section 4.1.3, and is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
宏lost_assert（S，G，I）用于第4.1.3节的olist计算，定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   bool lost_assert(S,G,I) {
     if ( RPF_interface(S) == I ) {
       return FALSE
     } else {
       return (AssertWinner(S,G,I) != me  AND
               (AssertWinnerMetric(S,G,I) is better than
                spt_assert_metric(S,G,I)))
     }
   }
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   bool lost_assert(S,G,I) {
     if ( RPF_interface(S) == I ) {
       return FALSE
     } else {
       return (AssertWinner(S,G,I) != me  AND
               (AssertWinnerMetric(S,G,I) is better than
                spt_assert_metric(S,G,I)))
     }
   }
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinner(S,G,I) defaults to NULL, and AssertWinnerMetric(S,G,I) defaults to Infinity when in the NoInfo state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
AssertWinner（S，G，I）在NoInfo状态下默认为NULL，AssertWinnerMetric（S，G，I）在NoInfo状态下默认为无穷大。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4. (S,G) Assert Message State Machine
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4. （S，G）断言消息状态机
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The (S,G) Assert state machine for interface I is shown in Figure 4. There are three states:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
接口I的（S，G）断言状态机如图4所示。有三个州：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo (NI) This router has no (S,G) Assert state on interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
NoInfo（NI）此路由器在接口I上没有（S，G）断言状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
I am Assert Winner (W) This router has won an (S,G) Assert on interface I. It is now responsible for forwarding traffic from S destined for G via interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我是断言赢家（W）此路由器在接口I上赢得了（S，G）断言。它现在负责通过接口I转发从S到G的流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
I am Assert Loser (L) This router has lost an (S,G) Assert on interface I. It must not forward packets from S destined for G onto interface I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
我是断言丢失者（L）此路由器在接口I上丢失了一个（S，G）断言。它不能将数据包从S转发到接口I。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In addition, an Assert Timer (AT(S,G,I)) is used to time out the Assert state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，断言计时器（AT（S，G，I））用于超时断言状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         +-------------+                        +-------------+
         |             | Rcv Pref Assert or SR  |             |
         |   Winner    |-----------------------&gt;|    Loser    |
         |             |                        |             |
         +-------------+                        +-------------+
              ^   |                                  ^   |
              |   |                Rcv Pref Assert or|   |
              |   |AT Expires OR        State Refresh|   |
              |   |CouldAssert-&gt;FALSE                |   |
              |   |                                  |   |
              |   |         +-------------+          |   |
              |   +--------&gt;|             |----------+   |
              |             |   No Info   |              |
              +-------------|             |&lt;-------------+
       Rcv Data from dnstrm +-------------+ Rcv Inf Assert from Win OR
     OR Rcv Inferior Assert                 Rcv Inf SR from Winner OR
         OR Rcv Inferior SR                 AT Expires OR
                                            CouldAssert Changes OR
                                            Winner&#39;s NLT Expires
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
         +-------------+                        +-------------+
         |             | Rcv Pref Assert or SR  |             |
         |   Winner    |-----------------------&gt;|    Loser    |
         |             |                        |             |
         +-------------+                        +-------------+
              ^   |                                  ^   |
              |   |                Rcv Pref Assert or|   |
              |   |AT Expires OR        State Refresh|   |
              |   |CouldAssert-&gt;FALSE                |   |
              |   |                                  |   |
              |   |         +-------------+          |   |
              |   +--------&gt;|             |----------+   |
              |             |   No Info   |              |
              +-------------|             |&lt;-------------+
       Rcv Data from dnstrm +-------------+ Rcv Inf Assert from Win OR
     OR Rcv Inferior Assert                 Rcv Inf SR from Winner OR
         OR Rcv Inferior SR                 AT Expires OR
                                            CouldAssert Changes OR
                                            Winner&#39;s NLT Expires
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
Figure 4: Assert State Machine
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-21">
图4：断言状态机
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In tabular form, the state machine is defined as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以表格形式，状态机定义如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
|                               +------------+------------+------------+
|            Event              |  No Info   |   Winner   |    Loser   |
+-------------------------------+------------+------------+------------+
| An (S,G) Data packet received | -&gt;W Send   | -&gt;W Send   | -&gt;L        |
| on downstream interface       | Assert(S,G)| Assert(S,G)|            |
|                               |    Set     |    Set     |            |
|                               |  AT(S,G,I) |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
| Receive Inferior (Assert OR   | N/A        | N/A        |-&gt;NI Cancel |
| State Refresh) from Assert    |            |            |  AT(S,G,I) |
| Winner                        |            |            |            |
+-------------------------------+--------------------------------------+
| Receive Inferior (Assert OR   | -&gt;W Send   | -&gt;W Send   | -&gt;L        |
| State Refresh) from non-Assert| Assert(S,G)| Assert(S,G)|            |
| Winner AND CouldAssert==TRUE  |    Set     |    Set     |            |
|                               |  AT(S,G,I) |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
|                               +------------+------------+------------+
|            Event              |  No Info   |   Winner   |    Loser   |
+-------------------------------+------------+------------+------------+
| An (S,G) Data packet received | -&gt;W Send   | -&gt;W Send   | -&gt;L        |
| on downstream interface       | Assert(S,G)| Assert(S,G)|            |
|                               |    Set     |    Set     |            |
|                               |  AT(S,G,I) |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
| Receive Inferior (Assert OR   | N/A        | N/A        |-&gt;NI Cancel |
| State Refresh) from Assert    |            |            |  AT(S,G,I) |
| Winner                        |            |            |            |
+-------------------------------+--------------------------------------+
| Receive Inferior (Assert OR   | -&gt;W Send   | -&gt;W Send   | -&gt;L        |
| State Refresh) from non-Assert| Assert(S,G)| Assert(S,G)|            |
| Winner AND CouldAssert==TRUE  |    Set     |    Set     |            |
|                               |  AT(S,G,I) |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
|                               +------------+------------+------------+
|            Event              |  No Info   |   Winner   |    Loser   |
+-------------------------------+------------+------------+------------+
| Receive Preferred Assert OR   | -&gt;L Send   | -&gt;L Send   | -&gt;L  Set   |
| State Refresh                 | Prune(S,G) | Prune(S,G) |  AT(S,G,I) |
|                               |    Set     |    Set     |            |
|                               |  AT(S,G,I) |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
| Send State Refresh            | -&gt;NI       | -&gt;W Reset  | N/A        |
|                               |            |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
| AT(S,G) Expires               | N/A        | -&gt;NI       | -&gt;NI       |
+-------------------------------+--------------------------------------+
| CouldAssert -&gt; FALSE          | -&gt;NI       |-&gt;NI Cancel |-&gt;NI Cancel |
|                               |            |  AT(S,G,I) |  AT(S,G,I) |
+-------------------------------+--------------------------------------+
| CouldAssert -&gt; TRUE           | -&gt;NI       | N/A        |-&gt;NI Cancel |
|                               |            |            |  AT(S,G,I) |
+-------------------------------+--------------------------------------+
| Winner&#39;s NLT(N,I) Expires     | N/A        | N/A        |-&gt;NI Cancel |
|                               |            |            |  AT(S,G,I) |
+-------------------------------+--------------------------------------+
| Receive Prune(S,G), Join(S,G) | -&gt;NI       | -&gt;W        | -&gt;L Send   |
| or Graft(S,G)                 |            |            | Assert(S,G)|
+-------------------------------+--------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
+-------------------------------+--------------------------------------+
|                               |            Previous State            |
|                               +------------+------------+------------+
|            Event              |  No Info   |   Winner   |    Loser   |
+-------------------------------+------------+------------+------------+
| Receive Preferred Assert OR   | -&gt;L Send   | -&gt;L Send   | -&gt;L  Set   |
| State Refresh                 | Prune(S,G) | Prune(S,G) |  AT(S,G,I) |
|                               |    Set     |    Set     |            |
|                               |  AT(S,G,I) |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
| Send State Refresh            | -&gt;NI       | -&gt;W Reset  | N/A        |
|                               |            |  AT(S,G,I) |            |
+-------------------------------+--------------------------------------+
| AT(S,G) Expires               | N/A        | -&gt;NI       | -&gt;NI       |
+-------------------------------+--------------------------------------+
| CouldAssert -&gt; FALSE          | -&gt;NI       |-&gt;NI Cancel |-&gt;NI Cancel |
|                               |            |  AT(S,G,I) |  AT(S,G,I) |
+-------------------------------+--------------------------------------+
| CouldAssert -&gt; TRUE           | -&gt;NI       | N/A        |-&gt;NI Cancel |
|                               |            |            |  AT(S,G,I) |
+-------------------------------+--------------------------------------+
| Winner&#39;s NLT(N,I) Expires     | N/A        | N/A        |-&gt;NI Cancel |
|                               |            |            |  AT(S,G,I) |
+-------------------------------+--------------------------------------+
| Receive Prune(S,G), Join(S,G) | -&gt;NI       | -&gt;W        | -&gt;L Send   |
| or Graft(S,G)                 |            |            | Assert(S,G)|
+-------------------------------+--------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Terminology: A &#34;preferred assert&#34; is one with a better metric than the current winner. An &#34;inferior assert&#34; is one with a worse metric than my_assert_metric(S,G,I).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
术语：“首选断言”是指比当前获胜者具有更好的度量标准的断言。“次断言”是指比我的度量（S、G、I）更差的度量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The state machine uses the following macro:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
状态机使用以下宏：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CouldAssert(S,G,I) = (RPF_interface(S) != I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   CouldAssert(S,G,I) = (RPF_interface(S) != I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4.1. Transitions from NoInfo State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4.1. 从NoInfo状态的转换
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the NoInfo state, the following events may trigger transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在NoInfo状态下，以下事件可能触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
An (S,G) data packet arrives on downstream interface I An (S,G) data packet arrived on a downstream interface. It is optimistically assumed that this router will be the Assert winner for this (S,G). The Assert state machine MUST transition to the &#34;I am Assert Winner&#34; state, send an Assert(S,G) to interface I, store its own address and metric as the Assert Winner, and set the Assert_Timer (AT(S,G,I) to Assert_Time, thereby initiating the Assert negotiation for (S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（S，G）数据包到达下游接口I（S，G）数据包到达下游接口。乐观地认为，该路由器将是该（S，G）的断言赢家。断言状态机必须转换到“我是断言赢家”状态，向接口I发送断言（S，G），将其自己的地址和度量存储为断言赢家，并将断言计时器（在（S，G，I）设置为断言时间，从而启动（S，G）的断言协商。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior (Assert OR State Refresh) AND CouldAssert(S,G,I)==TRUE An Assert or State Refresh is received for (S,G) that is inferior to our own assert metric on interface I. The Assert state machine MUST transition to the &#34;I am Assert Winner&#34; state, send an Assert(S,G) to interface I, store its own address and metric as the Assert Winner, and set the Assert Timer (AT(S,G,I)) to Assert_Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收下级（断言或状态刷新）和CouldAssert（S，G，I）=TRUE为接口I上低于我们自己的断言度量的（S，G）接收断言或状态刷新。断言状态机必须转换到“我是断言赢家”状态，向接口I发送断言（S，G），将其自己的地址和度量存储为断言赢家，并将断言计时器（在（S，G，I））设置为断言时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Preferred Assert or State Refresh The received Assert or State Refresh has a better metric than this router&#39;s, and therefore the Assert state machine MUST transition to the &#34;I am Assert Loser&#34; state and store the Assert Winner&#39;s address and metric. If the metric was received in an Assert, the router MUST set the Assert Timer (AT(S,G,I)) to Assert_Time. If the metric was received in a State Refresh, the router MUST set the Assert Timer (AT(S,G,I)) to three times the received State Refresh Interval. If CouldAssert(S,G,I) == TRUE, the router MUST also multicast a Prune(S,G) to the Assert winner with a Prune Hold Time equal to the Assert Timer and evaluate any changes in its Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收首选断言或状态刷新接收到的断言或状态刷新具有比此路由器更好的度量，因此断言状态机必须转换为“我是断言输家”状态，并存储断言赢家的地址和度量。如果在断言中接收到度量，路由器必须将断言计时器（在（S，G，I））设置为断言时间。如果在状态刷新中接收到度量，路由器必须将断言计时器（在（S，G，I））设置为接收到的状态刷新间隔的三倍。如果CouldAssert（S，G，I）=TRUE，路由器还必须将修剪（S，G）多播到断言赢家，修剪保持时间等于断言计时器，并评估其上游（S，G）状态机中的任何更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4.2. Transitions from Winner State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4.2. 从赢家状态过渡
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Winner&#34; state, the following events trigger transitions:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“我是赢家”状态时，以下事件触发转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
An (S,G) data packet arrives on downstream interface I An (S,G) data packet arrived on a downstream interface. The Assert state machine remains in the &#34;I am Assert Winner&#34; state. The router MUST send an Assert(S,G) to interface I and set the Assert Timer (AT(S,G,I) to Assert_Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
（S，G）数据包到达下游接口I（S，G）数据包到达下游接口。断言状态机保持“我是断言赢家”状态。路由器必须向接口I发送断言（S，G），并将断言计时器（在（S，G，I）设置为断言时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert or State Refresh An (S,G) Assert is received containing a metric for S that is worse than this router&#39;s metric for S. Whoever sent the Assert is in error. The router MUST send an Assert(S,G) to interface I and reset the Assert Timer (AT(S,G,I)) to Assert_Time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收低级断言或状态刷新接收到的（S，G）断言包含的S度量比此路由器的S度量差。发送断言的人都有错误。路由器必须向接口I发送断言（S，G），并重置断言计时器（在（S，G，I））以断言时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Preferred Assert or State Refresh An (S,G) Assert or State Refresh is received that has a better metric than this router&#39;s metric for S on interface I. The Assert state machine MUST transition to &#34;I am Assert Loser&#34; state and store the new Assert Winner&#39;s address and metric. If the metric was received in an Assert, the router MUST set the Assert Timer (AT(S,G,I)) to Assert_Time. If the metric was received in a State Refresh, the router MUST set the Assert Timer (AT(S,G,I)) to three times the State Refresh Interval. The router MUST also
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收首选断言或状态刷新收到的（S，G）断言或状态刷新在接口I上具有比此路由器的S度量更好的度量。断言状态机必须转换为“我是断言输家”状态，并存储新的断言赢家地址和度量。如果在断言中接收到度量，路由器必须将断言计时器（在（S，G，I））设置为断言时间。如果在状态刷新中收到度量，路由器必须将断言计时器（在（S，G，I））设置为状态刷新间隔的三倍。路由器还必须
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
multicast a Prune(S,G) to the Assert winner, with a Prune Hold Time equal to the Assert Timer, and evaluate any changes in its Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
将剪枝（S，G）多播到断言赢家，剪枝保持时间等于断言计时器，并评估其上游（S，G）状态机中的任何更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Send State Refresh The router is sending a State Refresh(S,G) message on interface I. The router MUST set the Assert Timer (AT(S,G,I)) to three times the State Refresh Interval contained in the State Refresh(S,G) message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
发送状态刷新路由器正在接口I上发送状态刷新（S，G）消息。路由器必须将断言计时器（在（S，G，I））设置为状态刷新（S，G）消息中包含的状态刷新间隔的三倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AT(S,G,I) Expires The (S,G) Assert Timer (AT(S,G,I)) expires. The Assert state machine MUST transition to the NoInfo (NI) state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
在（S，G，I）到期时，（S，G）断言计时器（在（S，G，I）到期。断言状态机必须转换到NoInfo（NI）状态。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert(S,G,I) -&gt; FALSE This router&#39;s RPF interface changed, making CouldAssert(S,G,I) false. This router can no longer perform the actions of the Assert winner, so the Assert state machine MUST transition to NoInfo (NI) state, send an AssertCancel(S,G) to interface I, cancel the Assert Timer (AT(S,G,I)), and remove itself as the Assert Winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert（S，G，I）-&gt;FALSE此路由器的RPF接口已更改，使CouldAssert（S，G，I）为FALSE。此路由器无法再执行Assert winner的操作，因此Assert状态机必须转换为NoInfo（NI）状态，向接口I发送AssertCancel（S，G），取消Assert计时器（在（S，G，I）），并将自身作为Assert winner移除。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4.3. Transitions from Loser State
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.4.3. 从失败者状态过渡
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When in &#34;I am Assert Loser&#34; state, the following transitions can occur:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当处于“我是失败者”状态时，可能会发生以下转换：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Inferior Assert or State Refresh from Current Winner An Assert or State Refresh is received from the current Assert winner that is worse than this router&#39;s metric for S (typically, the winner&#39;s metric became worse). The Assert state machine MUST transition to NoInfo (NI) state and cancel AT(S,G,I). The router MUST delete the previous Assert Winner&#39;s address and metric and evaluate any possible transitions to its Upstream(S,G) state machine. Usually this router will eventually re-assert and win when data packets from S have started flowing again.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
从当前胜利者接收较差的断言或状态刷新从当前断言胜利者接收的断言或状态刷新比此路由器的s度量差（通常，胜利者的度量变差）。断言状态机必须转换到NoInfo（NI）状态，并在（S，G，I）处取消。路由器必须删除前一个断言赢家的地址和度量，并评估到其上游（s，G）状态机的任何可能转换。通常，当来自S的数据包再次开始流动时，该路由器最终将重新断言并获胜。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Preferred Assert or State Refresh An Assert or State Refresh is received that has a metric better than or equal to that of the current Assert winner. The Assert state machine remains in Loser (L) state. If the metric was received in an Assert, the router MUST set the Assert Timer (AT(S,G,I)) to Assert_Time. If the metric was received in a State Refresh, the router MUST set the Assert Timer (AT(S,G,I)) to three times the received State Refresh Interval. If the metric is better than the current Assert Winner, the router MUST
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收首选断言或状态刷新接收的断言或状态刷新的度量值优于或等于当前断言的度量值。断言状态机保持在Loser（L）状态。如果在断言中接收到度量，路由器必须将断言计时器（在（S，G，I））设置为断言时间。如果在状态刷新中接收到度量，路由器必须将断言计时器（在（S，G，I））设置为接收到的状态刷新间隔的三倍。如果指标优于当前的断言赢家，路由器必须
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
store the address and metric of the new Assert Winner, and if CouldAssert(S,G,I) == TRUE, the router MUST multicast a Prune(S,G) to the new Assert winner.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
存储新的断言赢家的地址和度量，如果CouldAssert（S，G，I）=TRUE，路由器必须将剪枝（S，G）多播到新的断言赢家。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
AT(S,G,I) Expires The (S,G) Assert Timer (AT(S,G,I)) expires. The Assert state machine MUST transition to NoInfo (NI) state. The router MUST delete the Assert Winner&#39;s address and metric. If CouldAssert == TRUE, the router MUST evaluate any possible transitions to its Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
在（S，G，I）到期时，（S，G）断言计时器（在（S，G，I）到期。断言状态机必须转换为NoInfo（NI）状态。路由器必须删除断言赢家的地址和度量。如果CouldAssert==TRUE，路由器必须评估到其上游（S，G）状态机的任何可能转换。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert -&gt; FALSE CouldAssert has become FALSE because interface I has become the RPF interface for S. The Assert state machine MUST transition to NoInfo (NI) state, cancel AT(S,G,I), and delete information concerning the Assert Winner on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert-&gt;FALSE CouldAssert已变为FALSE，因为接口I已成为S的RPF接口。断言状态机必须转换为NoInfo（NI）状态，在（S，G，I）处取消，并删除关于I上断言获胜者的信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert -&gt; TRUE CouldAssert has become TRUE because interface I used to be the RPF interface for S, and now it is not. The Assert state machine MUST transition to NoInfo (NI) state, cancel AT(S,G,I), and delete information concerning the Assert Winner on I.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
CouldAssert-&gt;TRUE CouldAssert已经变为TRUE，因为接口I过去是S的RPF接口，现在不是了。断言状态机必须转换到NoInfo（NI）状态，在（S，G，I）处取消，并删除关于I上断言获胜者的信息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Current Assert Winner&#39;s NeighborLiveness Timer Expires The current Assert winner&#39;s NeighborLiveness Timer (NLT(N,I)) has expired. The Assert state machine MUST transition to the NoInfo (NI) state, delete the Assert Winner&#39;s address and metric, and evaluate any possible transitions to its Upstream(S,G) state machine.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
当前断言赢家的邻居关系计时器过期当前断言赢家的邻居关系计时器（NLT（N，I））已过期。断言状态机必须转换到NoInfo（NI）状态，删除断言获胜者的地址和度量，并评估任何可能转换到其上游（s，G）状态机的情况。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Receive Prune(S,G), Join(S,G), or Graft(S,G) A Prune(S,G), Join(S,G), or Graft(S,G) message was received on interface I with its upstream neighbor address set to the router&#39;s address on I. The router MUST send an Assert(S,G) on the receiving interface I to initiate an Assert negotiation. The Assert state machine remains in the Assert Loser(L) state. If a Graft(S,G) was received, the router MUST respond with a GraftAck(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
接收修剪（S，G）、连接（S，G）或嫁接（S，G）接口I上接收到修剪（S，G）、连接（S，G）或嫁接（S，G）消息，其上游邻居地址设置为路由器在I上的地址。路由器必须在接收接口I上发送断言（S，G）以启动断言协商。断言状态机仍处于断言输家（L）状态。如果接收到嫁接（S，G），路由器必须用嫁接（S，G）进行响应。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.5. Rationale for Assert Rules
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.6.5. 断言规则的基本原理
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following is a summary of the rules for generating and processing Assert messages. It is not intended to be definitive (the state machines and pseudocode provide the definitive behavior). Instead, it provides some rationale for the behavior.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下是生成和处理断言消息的规则摘要。它不是确定的（状态机和伪代码提供了确定的行为）。相反，它为这种行为提供了一些基本原理。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. The Assert winner for (S,G) must act as the local forwarder for (S,G) on behalf of all downstream members. 2. PIM messages are directed to the RPF&#39; neighbor and not to the regular RPF neighbor. 3. An Assert loser that receives a Prune(S,G), Join(S,G), or Graft(S,G) directed to it initiates a new Assert negotiation so that the downstream router can correct its RPF&#39;(S). 4. An Assert winner for (S,G) sends a cancelling assert when it is about to stop forwarding on an (S,G) entry. Example: If a router is being taken down, then a canceling assert is sent.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. （S，G）的断言赢家必须代表所有下游成员担任（S，G）的本地转运商。2.PIM消息被定向到RPF的邻居，而不是常规RPF邻居。3.接收指向它的剪枝（S，G）、连接（S，G）或嫁接（S，G）的断言失败者启动新的断言协商，以便下游路由器可以更正其RPF。4.（S，G）的断言赢家将在（S，G）项上停止转发时发送取消断言。示例：如果正在关闭路由器，则发送取消断言。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. PIM Packet Formats
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7. PIM数据包格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All PIM-DM packets use the same format as PIM-SM packets. In the event of a discrepancy, PIM-SM [4] should be considered the definitive specification. All PIM control messages have IP protocol number 103. All PIM-DM messages MUST be sent with a TTL of 1. All PIM-DM messages except Graft and Graft Ack messages MUST be sent to the ALL-PIM-ROUTERS group. Graft messages SHOULD be unicast to the RPF&#39;(S). Graft Ack messages MUST be unicast to the sender of the Graft.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有PIM-DM数据包使用与PIM-SM数据包相同的格式。如果存在差异，应将PIM-SM[4]视为最终规范。所有PIM控制消息的IP协议号均为103。所有PIM-DM消息必须以1的TTL发送。除嫁接和嫁接确认消息外，所有PIM-DM消息必须发送至All-PIM-ROUTERS组。嫁接消息应单播到RPF。嫁接确认消息必须单播到嫁接的发送方。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPv4 ALL-PIM-ROUTERS group is 224.0.0.13. The IPv6 ALL-PIM-ROUTERS group is &#39;ff02::d&#39;.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv4全PIM路由器组为224.0.0.13。IPv6全PIM路由器组为“ff02:：d”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.1. PIM Header
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.1. 动力传动系接口
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All PIM control messages have the following header:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有动力传动系接口模块控制信息都有以下标题：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Ver PIM version number is 2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM版本号为2。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Type Types for specific PIM messages. Available types are as follows: 0 = Hello 1 = Register (PIM-SM only) 2 = Register Stop (PIM-SM only) 3 = Join/Prune 4 = Bootstrap (PIM-SM only) 5 = Assert 6 = Graft 7 = Graft Ack 8 = Candidate RP Advertisement (PIM-SM only) 9 = State Refresh
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
键入特定PIM消息的类型。可用类型如下：0=Hello 1=寄存器（仅限PIM-SM）2=寄存器停止（仅限PIM-SM）3=连接/删除4=引导（仅限PIM-SM）5=断言6=移植7=移植Ack 8=候选RP播发（仅限PIM-SM）9=状态刷新
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Set to zero on transmission. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
传输时保留设置为零。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Checksum The checksum is the standard IP checksum; i.e., the 16 bit one&#39;s complement of the one&#39;s complement sum of the entire PIM message. For computing checksum, the checksum field is zeroed.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
校验和校验和是标准IP校验和；i、 例如，整个PIM消息的1的补码和的16位1的补码。对于计算校验和，校验和字段为零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
For IPv6, the checksum also includes the IPv6 &#34;pseudo-header&#34;, as specified in RFC 2460, Section 8.1 [5].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
对于IPv6，校验和还包括IPv6“伪报头”，如RFC 2460第8.1[5]节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.2. Encoded Unicast Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.2. 编码单播地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Encoded Unicast Address has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码单播地址具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |     Unicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |     Unicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family The PIM Address Family of the &#39;Unicast Address&#39; field of this address. Values 0 - 127 are as assigned by the IANA for Internet Address Families in [9]. Values 128 - 250 are reserved to be assigned by the IANA for PIM specific Address Families. Values 251 - 255 are designated for private use. As there is no assignment authority for this space; collisions should be expected.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family此地址的“单播地址”字段的PIM地址系列。IANA为[9]中的互联网地址族指定了0-127的值。IANA为PIM特定地址系列保留了128-250的值。值251-255指定为私人使用。因为该空间没有分配权限；应该预料会发生碰撞。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Type The type of encoding used with a specific Address Family. The value &#39;0&#39; is reserved for this field and represents the native encoding of the Address Family.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码类型用于特定地址族的编码类型。值“0”是为此字段保留的，表示地址族的本机编码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Unicast Address The unicast address as represented by the given Address Family and Encoding Type.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
单播地址由给定地址族和编码类型表示的单播地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.3. Encoded Group Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.3. 编码组地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Encoded Group address has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码的组地址具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Group Multicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |B| Reserved  |Z|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Group Multicast Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family As described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述的Addr系列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Type As described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码类型如上所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B Indicates that the group range should use Bidirectional PIM [16]. Transmitted as zero; ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
B表示组范围应使用双向PIM[16]。传输为零；收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Transmitted as zero. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留传输为零。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Z Indicates that the group range is an admin scope zone. This is used in the Bootstrap Router Mechanism [18] only. For all other purposes, this bit is set to zero and ignored on receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Z表示组范围是管理范围区域。这仅用于引导路由器机制[18]。出于所有其他目的，该位设置为零，并在接收时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mask Len The mask length field is 8 bits. The value is the number of contiguous left justified one bits used as a mask, which, combined with the address, describes a range of addresses. It is less than or equal to the address length in bits for the given Address Family and Encoding Type. If the message is sent for a single address then the mask length MUST equal the address length. PIM-DM routers MUST only send for a single address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
掩码长度掩码长度字段为8位。该值是用作掩码的连续左对齐一位的数目，该掩码与地址一起描述了地址范围。它小于或等于给定地址族和编码类型的地址长度（以位为单位）。如果为单个地址发送消息，则掩码长度必须等于地址长度。PIM-DM路由器必须只发送一个地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Group Multicast Address The address of the multicast group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组多播地址多播组的地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.4. Encoded Source Address
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.4. 编码源地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An Encoded Source address has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码的源地址具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |  Rsrvd  |S|W|R|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Source Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Addr Family  | Encoding Type |  Rsrvd  |S|W|R|  Mask Len     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Source Address
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addr Family As described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述的Addr系列。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Encoding Type As described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
编码类型如上所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rsrvd Reserved. Transmitted as zero. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留Rsrvd。传输为零。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
S The Sparse Bit. Set to 0 for PIM-DM. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
这是稀疏的一点。PIM-DM设置为0。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W The Wild Card Bit. Set to 0 for PIM-DM. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
W通配符位。PIM-DM设置为0。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R The Rendezvous Point Tree bit. Set to 0 for PIM-DM. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R集合点树位。PIM-DM设置为0。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Mask Len As described above. PIM-DM routers MUST only send for a single source address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如上所述的遮罩透镜。PIM-DM路由器必须只发送一个源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source Address The source address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
源地址源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5. Hello Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5. 你好消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM Hello message, as defined by PIM-SM [4], has the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM[4]定义的PIM Hello消息具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Option Type          |         Option Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Option Value                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Option Type          |         Option Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Option Value                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Option Type          |         Option Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Option Value                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Option Type          |         Option Length         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Option Value                          |
   |                              ...                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Ver, Type, Reserved, Checksum Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Option Type The type of option given in the Option Value field. Available types are as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选项类型选项值字段中给定的选项类型。可用类型如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
0 Reserved 1 Hello Hold Time 2 LAN Prune Delay 3 - 16 Reserved 17 To be assigned by IANA 18 Deprecated and SHOULD NOT be used 19 DR Priority (PIM-SM Only) 20 Generation ID 21 State Refresh Capable 22 Bidir Capable 23 - 65000 To be assigned by IANA 65001 - 65535 Reserved for Private Use [9]
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
0保留1 Hello保持时间2 LAN修剪延迟3-16保留17由IANA分配18已弃用且不应使用19 DR优先级（仅限PIM-SM）20代ID 21状态刷新22 Bidir能力23-65000由IANA分配65001-65535保留供私人使用[9]
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Unknown options SHOULD be ignored.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
应忽略未知选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.1. Hello Hold Time Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.1. Hello等待时间选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Type = 1           |           Length = 2          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Hold Time          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Type = 1           |           Length = 2          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Hold Time          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hold Time is the number of seconds a receiver MUST keep the neighbor reachable. If the Hold Time is set to &#39;0xffff&#39;, the receiver of this message never times out the neighbor. This may be used with dial-on-demand links to avoid keeping the link up with periodic Hello messages. Furthermore, if the Holdtime is set to &#39;0&#39;, the information is timed out immediately. The Hello Hold Time option MUST be used by PIM-DM routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保持时间是接收器必须使邻居保持可到达的秒数。如果保持时间设置为“0xffff”，则此消息的接收器不会使邻居超时。这可以与按需拨号链接一起使用，以避免在链接中出现周期性的Hello消息。此外，如果保持时间设置为“0”，则信息将立即超时。Hello保持时间选项必须由PIM-DM路由器使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.2. LAN Prune Delay Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.2. LAN修剪延迟选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Type = 2           |           Length = 4          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |T|       LAN Prune Delay       |       Override Interval       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Type = 2           |           Length = 4          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |T|       LAN Prune Delay       |       Override Interval       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The LAN_Prune_Delay option is used to tune the prune propagation delay on multi-access LANs. The T bit is used by PIM-SM and SHOULD be set to 0 by PIM-DM routers and ignored upon receipt. The LAN Delay and Override Interval fields are time intervals in units of milliseconds and are used to tune the value of the J/P Override Interval and its derived timer values. Section 4.3.5 describes how these values affect the behavior of a router. The LAN Prune Delay SHOULD be used by PIM-DM routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
LAN_Prune_Delay选项用于调整多址LAN上的修剪传播延迟。PIM-SM使用T位，PIM-DM路由器应将T位设置为0，并在收到时忽略。LAN Delay和Override Interval字段是以毫秒为单位的时间间隔，用于调整J/P Override Interval的值及其导出的计时器值。第4.3.5节描述了这些值如何影响路由器的行为。PIM-DM路由器应使用LAN修剪延迟。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.3. Generation ID Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.3. 生成ID选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Type = 20           |           Length = 4          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Generation ID                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Type = 20           |           Length = 4          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Generation ID                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generation ID is a random value for the interface on which the Hello message is sent. The Generation ID is regenerated whenever PIM forwarding is started or restarted on the interface. The Generation ID option MAY be used by PIM-DM routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Generation ID是发送Hello消息的接口的随机值。只要在接口上启动或重新启动PIM转发，就会重新生成生成ID。PIM-DM路由器可以使用Generation ID选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.4. State Refresh Capable Option
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.5.4. 状态刷新功能选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Type = 21           |           Length = 4          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Version = 1  |   Interval    |            Reserved           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Type = 21           |           Length = 4          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Version = 1  |   Interval    |            Reserved           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Interval field is the router&#39;s configured State Refresh Interval in seconds. The Reserved field is set to zero and ignored upon receipt. The State Refresh Capable option MUST be used by State Refresh capable PIM-DM routers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interval字段是路由器配置的状态刷新间隔（秒）。保留字段设置为零，并在收到时忽略。支持状态刷新的PIM-DM路由器必须使用支持状态刷新的选项。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.6. Join/Prune Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.6. 加入/删除消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Join/Prune messages, as defined in PIM-SM [4], have the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM[4]中定义的PIM加入/删减消息具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Upstream Neighbor Address (Encoded Unicast Format)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Reserved    |  Num Groups   |          Hold Time            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |        Upstream Neighbor Address (Encoded Unicast Format)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Reserved    |  Num Groups   |          Hold Time            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address 1 (Encoded Group Format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address m (Encoded Group Format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address 1 (Encoded Group Format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address m (Encoded Group Format)      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Number of Joined Sources    |   Number of Pruned Sources    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Joined Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address 1 (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                               .                               |
   |                               .                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Pruned Source Address n (Encoded Source Format)       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Ver, Type, Reserved, Checksum Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Upstream Neighbor Address The address of the upstream neighbor. The format for this address is given in the Encoded Unicast address in Section 4.7.2. PIM-DM routers MUST set this field to the RPF next hop.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上游邻居地址上游邻居的地址。该地址的格式见第4.7.2节中的编码单播地址。PIM-DM路由器必须将此字段设置为RPF下一跳。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Transmitted as zero. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留传输为零。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hold Time The number of seconds a receiving PIM-DM router MUST keep a Prune state alive, unless removed by a Join or Graft message. If the Hold Time is &#39;0xffff&#39;, the receiver MUST NOT remove the Prune state unless a corresponding Join or Graft message is received. The Hold Time is ignored in Join messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
除非PIM-Hold路由器接收到的消息数为秒，否则Join-Prune必须保持有效。如果保持时间为“0xffff”，则接收方不得移除修剪状态，除非接收到相应的连接或嫁接消息。在联接消息中忽略保持时间。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of Groups Number of multicast group sets contained in the message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
组数消息中包含的多播组集数。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast Group Address The multicast group address in the Encoded Multicast address format given in Section 4.7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播组地址第4.7.3节中给出的编码多播地址格式的多播组地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of Joined Sources Number of Join source addresses listed for a given group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已加入源的数量为给定组列出的加入源地址的数量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Number of Pruned Sources Number of Prune source addresses listed for a given group.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
已修剪源的数目为给定组列出的修剪源地址的数目。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Join Source Address 1..n This list contains the sources from which the sending router wishes to continue to receive multicast messages for the given group on this interface. The addresses use the Encoded Source address format given in Section 4.7.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
加入源地址1..n此列表包含发送路由器希望在此接口上继续接收给定组的多播消息的源。地址使用第4.7.4节中给出的编码源地址格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Prune Source Address 1..n This list contains the sources from which the sending router does not wish to receive multicast messages for the given group on this interface. The addresses use the Encoded Source address format given in Section 4.7.4.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
删除源地址1..n此列表包含发送路由器不希望从此接口上接收给定组的多播消息的源。地址使用第4.7.4节中给出的编码源地址格式。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.7. Assert Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.7. 断言消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Assert Messages, as defined in PIM-SM [4], have the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-SM[4]中定义的PIM断言消息具有以下格式：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address (Encoded Group Format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Source Address (Encoded Unicast Format)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|                     Metric Preference                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Metric                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address (Encoded Group Format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Source Address (Encoded Unicast Format)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|                     Metric Preference                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Metric                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Ver, Type, Reserved, Checksum Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast Group Address The multicast group address in the Encoded Multicast address format given in Section 4.7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播组地址第4.7.3节中给出的编码多播地址格式的多播组地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source Address The source address in the Encoded Unicast address format given in Section 4.7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
源地址第4.7.2节中给出的编码单播地址格式的源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R The Rendezvous Point Tree bit. Set to 0 for PIM-DM. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R集合点树位。PIM-DM设置为0。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric Preference The preference value assigned to the unicast routing protocol that provided the route to the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric Preference指定给向源提供路由的单播路由协议的首选项值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric The cost metric of the unicast route to the source. The metric is in units applicable to the unicast routing protocol used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric到源的单播路由的成本度量。度量单位适用于所使用的单播路由协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.8. Graft Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.8. 嫁接消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Graft messages use the same format as Join/Prune messages, except that the Type field is set to 6. The source address MUST be in the Join section of the message. The Hold Time field SHOULD be zero and SHOULD be ignored when a Graft is received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM嫁接消息使用与连接/修剪消息相同的格式，只是类型字段设置为6。源地址必须位于消息的联接部分。保持时间字段应为零，并且在接受移植物时应忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.9. Graft Ack Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.9. 自动应答报文格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Graft Ack messages are identical in format to the received Graft message, except that the Type field is set to 7. The Upstream Neighbor Address field SHOULD be set to the sender of the Graft message and SHOULD be ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM嫁接确认消息的格式与接收到的嫁接消息相同，只是类型字段设置为7。上游邻居地址字段应设置为嫁接消息的发送者，并在收到消息时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.10. State Refresh Message Format
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.7.10. 状态刷新消息格式
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM State Refresh Messages have the following format:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM状态刷新消息的格式如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address (Encoded Group Format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Source Address (Encoded Unicast Format)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Originator Address (Encoded Unicast Format)         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|                     Metric Preference                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Metric                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Masklen    |    TTL        |P|N|O|Reserved |   Interval    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |PIM Ver| Type  |   Reserved    |           Checksum            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Multicast Group Address (Encoded Group Format)        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |             Source Address (Encoded Unicast Format)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Originator Address (Encoded Unicast Format)         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |R|                     Metric Preference                       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Metric                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    Masklen    |    TTL        |P|N|O|Reserved |   Interval    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM Ver, Type, Reserved, Checksum Described above.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
上述PIM版本、类型、保留、校验和。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Multicast Group Address The multicast group address in the Encoded Multicast address format given in Section 4.7.3.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
多播组地址第4.7.3节中给出的编码多播地址格式的多播组地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Source Address The address of the data source in the Encoded Unicast address format given in Section 4.7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
源地址第4.7.2节中给出的编码单播地址格式的数据源地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Originator Address The address of the first hop router in the Encoded Unicast address format given in Section 4.7.2.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
发起者地址第4.7.2节中给出的编码单播地址格式的第一跳路由器的地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R The Rendezvous Point Tree bit. Set to 0 for PIM-DM. Ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
R集合点树位。PIM-DM设置为0。收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric Preference The preference value assigned to the unicast routing protocol that provided the route to the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric Preference指定给向源提供路由的单播路由协议的首选项值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric The cost metric of the unicast route to the source. The metric is in units applicable to the unicast routing protocol used.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Metric到源的单播路由的成本度量。度量单位适用于所使用的单播路由协议。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Masklen The length of the address mask of the unicast route to the source.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Masklen到源的单播路由的地址掩码的长度。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TTL Time To Live of the State Refresh message. Decremented each time the message is forwarded. Note that this is different from the IP Header TTL, which is always set to 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TTL状态刷新消息的生存时间。每次转发消息时递减。请注意，这与IP头TTL不同，后者始终设置为1。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P Prune indicator flag. This MUST be set to 1 if the State Refresh is to be sent on a Pruned interface. Otherwise, it MUST be set to 0.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
P删减指示符标志。如果要在修剪后的接口上发送状态刷新，则必须将其设置为1。否则，必须将其设置为0。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N Prune Now flag. This SHOULD be set to 1 by the State Refresh originator on every third State Refresh message and SHOULD be ignored upon receipt. This is for compatibility with earlier versions of state refresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
N现在修剪旗帜。每收到第三条状态刷新消息，状态刷新发起人应将其设置为1，并在收到后忽略。这是为了与状态刷新的早期版本兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O Assert Override flag. This SHOULD be set to 1 by upstream routers on a LAN if the Assert Timer (AT(S,G)) is not running and SHOULD be ignored upon receipt. This is for compatibility with earlier versions of state refresh.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
O断言覆盖标志。如果断言计时器（在（S，G））未运行，则LAN上的上游路由器应将其设置为1，并应在收到时忽略。这是为了与状态刷新的早期版本兼容。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Reserved Set to zero and ignored upon receipt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保留设置为零，并在收到时忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Interval Set by the originating router to the interval (in seconds) between consecutive State Refresh messages for this (S,G) pair.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由发起路由器设置的该（S，G）对的连续状态刷新消息之间的间隔（以秒为单位）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. PIM-DM Timers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4.8. PIM-DM定时器
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM maintains the following timers. All timers are countdown timers -- they are set to a value and count down to zero, at which point they typically trigger an action. Of course they can just as easily be implemented as count-up timers, where the absolute expiry time is stored and compared against a real-time clock, but the language in this specification assumes that they count downward towards zero.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM维护以下计时器。所有计时器都是倒计时计时器——它们被设置为一个值并倒计时到零，在这一点上它们通常触发一个动作。当然，它们可以像计数计时器一样容易地实现，其中存储绝对到期时间并与实时时钟进行比较，但是本规范中的语言假设它们向下计数到零。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Global Timers Hello Timer: HT
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
全球定时器你好定时器：HT
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
Per interface (I): Per neighbor (N): Neighbor Liveness Timer: NLT(N,I)
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-5">
每个接口（I）：每个邻居（N）：邻居活跃度计时器：NLT（N，I）
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Per (S,G) Pair:
         (S,G) Assert Timer: AT(S,G,I)
         (S,G) Prune Timer: PT(S,G,I)
         (S,G) PrunePending Timer: PPT(S,G,I)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Per (S,G) Pair:
         (S,G) Assert Timer: AT(S,G,I)
         (S,G) Prune Timer: PT(S,G,I)
         (S,G) PrunePending Timer: PPT(S,G,I)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Per (S,G) Pair:
         (S,G) Graft Retry Timer: GRT(S,G)
         (S,G) Upstream Override Timer: OT(S,G)
         (S,G) Prune Limit Timer: PLT(S,G)
         (S,G) Source Active Timer: SAT(S,G)
         (S,G) State Refresh Timer: SRT(S,G)
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
       Per (S,G) Pair:
         (S,G) Graft Retry Timer: GRT(S,G)
         (S,G) Upstream Override Timer: OT(S,G)
         (S,G) Prune Limit Timer: PLT(S,G)
         (S,G) Source Active Timer: SAT(S,G)
         (S,G) State Refresh Timer: SRT(S,G)
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When timer values are started or restarted, they are set to default values. The following tables summarize those default values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
启动或重新启动计时器值时，它们被设置为默认值。下表总结了这些默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Hello Timer (HT)
+----------------------+--------+--------------------------------------+
| Value Name           | Value  | Explanation                          |
+----------------------+--------+--------------------------------------+
|Hello_Period          | 30 sec | Periodic interval for hello messages |
+----------------------+--------+--------------------------------------+
|Triggered_Hello_Delay | 5 sec  | Random interval for initial Hello    |
|                      |        | message on bootup or triggered Hello |
|                      |        | message to a rebooting neighbor      |
+----------------------+--------+--------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Hello Timer (HT)
+----------------------+--------+--------------------------------------+
| Value Name           | Value  | Explanation                          |
+----------------------+--------+--------------------------------------+
|Hello_Period          | 30 sec | Periodic interval for hello messages |
+----------------------+--------+--------------------------------------+
|Triggered_Hello_Delay | 5 sec  | Random interval for initial Hello    |
|                      |        | message on bootup or triggered Hello |
|                      |        | message to a rebooting neighbor      |
+----------------------+--------+--------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello messages are sent on every active interface once every Hello_Period seconds. At system power-up, the timer is initialized to rand(0,Triggered_Hello_Delay) to prevent synchronization. When a new or rebooting neighbor is detected, a responding Hello is sent within rand(0,Triggered_Hello_Delay).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Hello消息在每个活动接口上每隔Hello_周期秒发送一次。系统通电时，定时器初始化为rand（0，触发\u Hello\u延迟），以防止同步。当检测到新邻居或正在重新启动的邻居时，将在rand（0，触发的\u Hello\u延迟）内发送响应的Hello。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Neighbor Liveness Timer (NLT(N,I))
+-------------------+-----------------+--------------------------------+
| Value Name        | Value           | Explanation                    |
+-------------------+-----------------+--------------------------------+
| Hello Holdtime    | From message    | Hold Time from Hello Message   |
+-------------------+-----------------+--------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Neighbor Liveness Timer (NLT(N,I))
+-------------------+-----------------+--------------------------------+
| Value Name        | Value           | Explanation                    |
+-------------------+-----------------+--------------------------------+
| Hello Holdtime    | From message    | Hold Time from Hello Message   |
+-------------------+-----------------+--------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: PrunePending Timer (PPT(S,G,I))
+-----------------------+---------------+------------------------------+
| Value Name            | Value         | Explanation                  |
+-----------------------+---------------+------------------------------+
| J/P_Override_Interval | OI(I) + PD(I) | Short time after a Prune to  |
|                       |               | allow other routers on the   |
|                       |               | LAN to send a Join           |
+-----------------------+---------------+------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: PrunePending Timer (PPT(S,G,I))
+-----------------------+---------------+------------------------------+
| Value Name            | Value         | Explanation                  |
+-----------------------+---------------+------------------------------+
| J/P_Override_Interval | OI(I) + PD(I) | Short time after a Prune to  |
|                       |               | allow other routers on the   |
|                       |               | LAN to send a Join           |
+-----------------------+---------------+------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The J/P_Override_Interval is the sum of the interface&#39;s Override_Interval (OI(I)) and Propagation_Delay (PD(I)). If all routers on a LAN are using the LAN Prune Delay option, both parameters MUST be set to the largest value on the LAN. Otherwise, the Override_Interval (OI(I)) MUST be set to 2.5 seconds, and the Propagation_Delay (PD(I)) MUST be set to 0.5 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
J/P_覆盖间隔是接口的覆盖间隔（OI（I））和传播延迟（PD（I））的总和。如果LAN上的所有路由器都使用LAN修剪延迟选项，则必须将这两个参数设置为LAN上的最大值。否则，覆盖间隔（OI（I））必须设置为2.5秒，传播延迟（PD（I））必须设置为0.5秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Prune Timer (PT(S,G,I))
+----------------+----------------+------------------------------------+
| Value Name     | Value          | Explanation                        |
+----------------+----------------+------------------------------------+
| Prune Holdtime | From message   | Hold Time read from Prune Message  |
+----------------+----------------+------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Prune Timer (PT(S,G,I))
+----------------+----------------+------------------------------------+
| Value Name     | Value          | Explanation                        |
+----------------+----------------+------------------------------------+
| Prune Holdtime | From message   | Hold Time read from Prune Message  |
+----------------+----------------+------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Assert Timer (AT(S,G,I))
+--------------------------+---------+---------------------------------+
| Value Name               | Value   | Explanation                     |
+--------------------------+---------+---------------------------------+
| Assert Time              | 180 sec | Period after last assert before |
|                          |         | assert state is timed out       |
+--------------------------+---------+---------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Assert Timer (AT(S,G,I))
+--------------------------+---------+---------------------------------+
| Value Name               | Value   | Explanation                     |
+--------------------------+---------+---------------------------------+
| Assert Time              | 180 sec | Period after last assert before |
|                          |         | assert state is timed out       |
+--------------------------+---------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that, for historical reasons, the Assert message lacks a Holdtime field. Thus, changing the Assert Time from the default value is not recommended. If all members of a LAN are state refresh enabled, the Assert Time will be three times the received RefreshInterval(S,G).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
注意，由于历史原因，Assert消息缺少Holdtime字段。因此，不建议将断言时间更改为默认值。如果LAN的所有成员都启用状态刷新，则断言时间将是收到的刷新间隔（S，G）的三倍。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Graft Retry Timer (GRT(S,G))
+--------------------+-------+-----------------------------------------+
| Value Name         | Value | Explanation                             |
+--------------------+-------+-----------------------------------------+
| Graft_Retry_Period | 3 sec | In the absence of receipt of a GraftAck |
|                    |       | message, the time before retransmission |
|                    |       | of a Graft message                      |
+--------------------+-------+-----------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Graft Retry Timer (GRT(S,G))
+--------------------+-------+-----------------------------------------+
| Value Name         | Value | Explanation                             |
+--------------------+-------+-----------------------------------------+
| Graft_Retry_Period | 3 sec | In the absence of receipt of a GraftAck |
|                    |       | message, the time before retransmission |
|                    |       | of a Graft message                      |
+--------------------+-------+-----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Upstream Override Timer (OT(S,G))
+------------+----------------+----------------------------------------+
| Value Name | Value          | Explanation                            |
+------------+----------------+----------------------------------------|
| t_override | rand(0, OI(I)) | Randomized delay to prevent response   |
|            |                | implosion when sending a join message  |
|            |                | to override someone else&#39;s prune       |
+------------+----------------+----------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Upstream Override Timer (OT(S,G))
+------------+----------------+----------------------------------------+
| Value Name | Value          | Explanation                            |
+------------+----------------+----------------------------------------|
| t_override | rand(0, OI(I)) | Randomized delay to prevent response   |
|            |                | implosion when sending a join message  |
|            |                | to override someone else&#39;s prune       |
+------------+----------------+----------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t_override is a random value between 0 and the interface&#39;s Override_Interval (OI(I)). If all routers on a LAN are using the LAN Prune Delay option, the Override_Interval (OI(I)) MUST be set to the largest value on the LAN. Otherwise, the Override_Interval (OI(I)) MUST be set to 2.5 seconds.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
t_override是介于0和接口的override_间隔（OI（I））之间的随机值。如果LAN上的所有路由器都使用LAN修剪延迟选项，则必须将覆盖间隔（OI（I））设置为LAN上的最大值。否则，超控间隔（OI（I））必须设置为2.5秒。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Prune Limit Timer (PLT(S,G))
+------------+--------------------+------------------------------------+
| Value Name | Value              | Explanation                        |
+------------+--------------------+------------------------------------|
| t_limit    | Default: 210 secs  | Used to prevent Prune storms on a  |
|            |                    | LAN                                |
+------------+--------------------+------------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Prune Limit Timer (PLT(S,G))
+------------+--------------------+------------------------------------+
| Value Name | Value              | Explanation                        |
+------------+--------------------+------------------------------------|
| t_limit    | Default: 210 secs  | Used to prevent Prune storms on a  |
|            |                    | LAN                                |
+------------+--------------------+------------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Source Active Timer (SAT(S,G))
+----------------+-------------------+---------------------------------+
| Value Name     | Value             | Explanation                     |
+----------------+-------------------+---------------------------------+
| SourceLifetime | Default: 210 secs | Period of time after receiving  |
|                |                   | a multicast message a directly  |
|                |                   | attached router will continue   |
|                |                   | to send State Refresh messages  |
+----------------+-------------------+---------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: Source Active Timer (SAT(S,G))
+----------------+-------------------+---------------------------------+
| Value Name     | Value             | Explanation                     |
+----------------+-------------------+---------------------------------+
| SourceLifetime | Default: 210 secs | Period of time after receiving  |
|                |                   | a multicast message a directly  |
|                |                   | attached router will continue   |
|                |                   | to send State Refresh messages  |
+----------------+-------------------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: State Refresh Timer (SRT(S,G))
+-----------------+------------------+---------------------------------+
| Value Name      | Value            | Explanation                     |
+-----------------+------------------+---------------------------------+
| RefreshInterval | Default: 60 secs | Interval between successive     |
|                 |                  | state refresh messages          |
+-----------------+------------------+---------------------------------+
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Timer Name: State Refresh Timer (SRT(S,G))
+-----------------+------------------+---------------------------------+
| Value Name      | Value            | Explanation                     |
+-----------------+------------------+---------------------------------+
| RefreshInterval | Default: 60 secs | Interval between successive     |
|                 |                  | state refresh messages          |
+-----------------+------------------+---------------------------------+
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Protocol Interaction Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 协议交互注意事项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM is designed to be independent of underlying unicast routing protocols and will interact only to the extent needed to perform RPF checks. It is generally assumed that multicast area and autonomous system boundaries will correspond to the same boundaries for unicast routing, though a deployment that does not follow this assumption is not precluded by this specification.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM被设计为独立于底层单播路由协议，并且仅在执行RPF检查所需的范围内进行交互。通常假设多播区域和自治系统边界将对应于单播路由的相同边界，尽管本规范不排除不遵循此假设的部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In general, PIM-DM interactions with other multicast routing protocols should be in compliance with RFC 2715 [7]. Other specific interactions are noted below.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一般来说，PIM-DM与其他多播路由协议的交互应符合RFC 2715[7]。其他具体交互作用如下所示。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. PIM-SM Interactions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.1. PIM-SM相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM is not intended to interact directly with PIM-SM, even though they share a common packet format. It is particularly important to note that a router cannot differentiate between a PIM-DM neighbor and a PIM-SM neighbor based on Hello messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM不打算直接与PIM-SM交互，即使它们共享一种通用的数据包格式。需要特别注意的是，路由器无法根据Hello消息区分PIM-DM邻居和PIM-SM邻居。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the event that a PIM-DM router becomes a neighbor of a PIM-SM router, the two will effectively form a simplex link, with the PIM-DM router sending all multicast messages to the PIM-SM router while the PIM-SM router sends no multicast messages to the PIM-DM router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果PIM-DM路由器成为PIM-SM路由器的邻居，两个路由器将有效地形成单工链路，PIM-DM路由器向PIM-SM路由器发送所有多播消息，而PIM-SM路由器不向PIM-DM路由器发送多播消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The common packet format permits a hybrid PIM-SM/DM implementation that would use PIM-SM when a rendezvous point is known and PIM-DM when one is not. Such an implementation is outside the scope of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
通用数据包格式允许混合PIM-SM/DM实现，在已知会合点时使用PIM-SM，在未知会合点时使用PIM-DM。此类实施不在本文件的范围内。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. IGMP Interactions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.2. IGMP相互作用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM will forward received multicast data packets to neighboring host group members in all cases except when the PIM-DM router is in an Assert Loser state on that interface. Note that a PIM Prune message is not permitted to prevent the delivery of messages to a network with group members.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在任何情况下，PIM-DM都会将接收到的多播数据包转发给相邻的主机组成员，除非PIM-DM路由器在该接口上处于“断言-丢失”状态。请注意，不允许使用PIM删减消息来阻止将消息传递到具有组成员的网络。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM-DM Router MAY use the DR Priority option described in PIM-SM [14] to elect an IGMP v1 querier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM路由器可以使用PIM-SM[14]中描述的DR优先级选项来选择IGMP v1查询器。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. Source Specific Multicast (SSM) Interactions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.3. 源特定多播（SSM）交互
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM makes no special considerations for SSM [15]. All Prunes and Grafts within the protocol are for a specific source, so no additional checks have to be made.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM对SSM没有特殊考虑[15]。协议中的所有修剪和嫁接都是针对特定来源的，因此无需进行额外检查。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. Multicast Group Scope Boundary Interactions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5.4. 多播组作用域边界交互
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Although multicast group scope boundaries are generally identical to routing area boundaries, it is conceivable that a routing area might be partitioned for a particular multicast group. PIM-DM routers MUST NOT send any messages concerning a particular group across that group&#39;s scope boundary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
尽管多播组作用域边界通常与路由区域边界相同，但可以想象，路由区域可能会针对特定多播组进行分区。PIM-DM路由器不得跨特定组的范围边界发送任何有关该组的消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANA Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. IANA考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. PIM Address Family
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.1. PIM地址族
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The PIM Address Family field was chosen to be 8 bits as a tradeoff between packet format and use of the IANA assigned numbers. When the PIM packet format was designed, only 15 values were assigned for Address Families, and large numbers of new Address Families were not envisioned; 8 bits seemed large enough. However, the IANA assigns Address Families in a 16 bit value. Therefore, the PIM Address Family is allocated as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM地址族字段被选择为8位，作为数据包格式和IANA分配号码使用之间的折衷。在设计PIM数据包格式时，仅为地址族分配了15个值，并且没有设想大量新的地址族；8位似乎足够大了。但是，IANA以16位值分配地址族。因此，PIM地址系列分配如下：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Values 0 - 127 are designated to have the same meaning as IANA assigned Address Family Numbers [9].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值0-127指定为与IANA分配的地址系列号具有相同的含义[9]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Values 128 - 250 are designated to be assigned by the IANA based on IESG approval, as defined in [8].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA根据IESG批准指定128-250的值，如[8]中所定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Values 251 - 255 are designated for Private Use, as defined in [8].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
值251-255指定为私人使用，如[8]中所定义。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. PIM Hello Options
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6.2. PIM Hello选项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Values 17 - 65000 are to be assigned by the IANA. Since the space is large, they may be assigned as First Come First Served, as defined in [8]. Assignments are valid for one year and may be renewed. Permanent assignments require a specification, as defined in [8].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IANA将分配值17-65000。由于空间较大，可按照[8]中的定义将其分配为先到先得。任务有效期为一年，可以续签。永久性转让需要[8]中定义的规范。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPsec authentication header [10] MAY be used to provide data integrity protection and groupwise data origin authentication of PIM protocol messages. Authentication of PIM messages can protect against unwanted behaviors caused by unauthorized or altered PIM messages. In any case, a PIM router SHOULD NOT accept and process PIM messages from neighbors unless a valid Hello message has been received from that neighbor.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPsec认证头[10]可用于提供PIM协议消息的数据完整性保护和分组数据源认证。PIM消息的身份验证可以防止未经授权或更改的PIM消息导致的不必要行为。在任何情况下，PIM路由器都不应接受和处理来自邻居的PIM消息，除非已从该邻居接收到有效的Hello消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that PIM-DM has no rendezvous point, and therefore no single point of failure that may be vulnerable. Because PIM-DM uses unicast routes provided by an unknown routing protocol, it may suffer collateral effects if the unicast routing protocol is attacked.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，PIM-DM没有集合点，因此没有易受攻击的单点故障。由于PIM-DM使用由未知路由协议提供的单播路由，因此如果单播路由协议受到攻击，它可能会受到附带影响。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. Attacks Based on Forged Messages
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.1. 基于伪造消息的攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The extent of possible damage depends on the type of counterfeit messages accepted. We next consider the impact of possible forgeries. A forged PIM-DM message is link local and can only reach a LAN if it was sent by a local host or if it was allowed onto the LAN by a compromised or non-compliant router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
可能损坏的程度取决于所接受的假冒信息的类型。接下来我们考虑可能伪造品的影响。伪造的PIM-DM消息是本地链路，只有当它由本地主机发送或被泄露或不兼容的路由器允许进入LAN时，才能到达LAN。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. A forged Hello message can cause multicast traffic to be delivered to links where there are no legitimate requestors, potentially wasting bandwidth on that link. On a multi-access LAN, the effects are limited without the capability to forge a Join message, as other routers will Prune the link if the traffic is not desired.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 伪造的Hello消息可能会导致多播通信量传递到没有合法请求者的链路，从而可能会浪费该链路上的带宽。在多址局域网上，由于没有伪造连接消息的能力，影响是有限的，因为如果不需要通信量，其他路由器将修剪链路。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. A forged Join/Prune message can cause multicast traffic to be delivered to links where there are no legitimate requestors, potentially wasting bandwidth on that link. A forged Prune
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 伪造的加入/删减消息可能会导致多播流量传递到没有合法请求者的链路，从而可能会浪费该链路上的带宽。伪造的梅子
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
message on a multi-access LAN is generally not a significant attack in PIM, because any legitimately joined router on the LAN would override the Prune with a Join before the upstream router stops forwarding data to the LAN.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-6">
在PIM中，多址LAN上的消息通常不是重要的攻击，因为LAN上任何合法连接的路由器都会在上游路由器停止向LAN转发数据之前用连接覆盖修剪。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. A forged Graft message can cause multicast traffic to be delivered to links where there are no legitimate requestors, potentially wasting bandwidth on that link. In principle, Graft messages could be sent multiple hops because they are unicast to the upstream router. This should not be a problem, as the remote forger should have no way to get a Hello message to the target of the attack. Without a valid Hello message, the receiving router SHOULD NOT accept the Graft.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 伪造的嫁接消息可能会导致多播通信量传递到没有合法请求者的链路，从而可能会在该链路上浪费带宽。原则上，嫁接消息可以多跳发送，因为它们是单播到上游路由器的。这不应该是一个问题，因为远程伪造者应该没有办法向攻击目标发送Hello消息。如果没有有效的Hello消息，则接收路由器不应接受嫁接。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. A forged GraftAck message has no impact, as it will be ignored unless the router has recently sent a Graft to its upstream router.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 伪造的GraftAck消息没有影响，因为除非路由器最近向其上游路由器发送了嫁接，否则它将被忽略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. By forging an Assert message on a multi-access LAN, an attacker could cause the legitimate forwarder to stop forwarding traffic to the LAN. Such a forgery would prevent any hosts downstream of that LAN from receiving traffic.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 通过在多访问LAN上伪造断言消息，攻击者可以使合法转发器停止向LAN转发流量。这种伪造将阻止该LAN下游的任何主机接收流量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. A forged State Refresh message on a multi-access LAN would have the same impact as a forged Assert message, having the same general functions. In addition, forged State Refresh messages would be propagated downstream and might be used in a denial of service attack. Therefore, a PIM-DM router SHOULD rate limit State Refresh messages propagated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 多访问LAN上的伪造状态刷新消息与伪造断言消息具有相同的影响，具有相同的一般功能。此外，伪造状态刷新消息将向下游传播，并可能用于拒绝服务攻击。因此，PIM-DM路由器应该对传播的极限状态刷新消息进行速率控制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. Non-cryptographic Authentication Mechanisms
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.2. 非加密身份验证机制
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A PIM-DM router SHOULD provide an option to limit the set of neighbors from which it will accept PIM-DM messages. Either static configuration of IP addresses or an IPSec security association may be used. All options that restrict the range of addresses from which packets are accepted MUST default to allowing all packets.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM路由器应提供一个选项，以限制其将从中接受PIM-DM消息的邻居集。可以使用IP地址的静态配置或IPSec安全关联。所有限制接受数据包的地址范围的选项必须默认为允许所有数据包。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Furthermore, a PIM router SHOULD NOT accept protocol messages from a router from which it has not yet received a valid Hello message.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，PIM路由器不应接受来自尚未收到有效Hello消息的路由器的协议消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. Authentication Using IPsec
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.3. 使用IPsec的身份验证
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPSec [10] transport mode using the Authentication Header (AH) is the recommended method to prevent the above attacks in PIM. The specific AH authentication algorithm and parameters, including the choice of authentication algorithm and the choice of key, are configured by the network administrator. The Encapsulating Security
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
建议使用使用身份验证头（AH）的IPSec[10]传输模式来防止PIM中的上述攻击。具体的AH认证算法和参数，包括认证算法的选择和密钥的选择，由网络管理员配置。封装安全性
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Payload (ESP) MAY also be used to provide both encryption and authentication of PIM protocol messages. When IPsec authentication is used, a PIM router SHOULD reject (drop without processing) any unauthorized PIM protocol messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
有效载荷（ESP）也可用于提供PIM协议消息的加密和认证。当使用IPsec身份验证时，PIM路由器应拒绝（丢弃而不处理）任何未经授权的PIM协议消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To use IPSec, the administrator of a PIM network configures each PIM router with one or more Security Associations and associated Security Parameters Indices that are used by senders to authenticate PIM protocol messages and are used by receivers to authenticate received PIM protocol messages. This document does not describe protocols for establishing Security Associations. It assumes that manual configuration of Security Associations is performed, but it does not preclude the use of some future negotiation protocol such as GDOI [17] to establish Security Associations.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
要使用IPSec，PIM网络的管理员将每个PIM路由器配置为具有一个或多个安全关联和关联的安全参数索引，发送方使用这些安全关联和索引对PIM协议消息进行身份验证，接收方使用这些安全关联和索引对接收到的PIM协议消息进行身份验证。本文档不描述建立安全关联的协议。它假设执行了安全关联的手动配置，但并不排除使用某些未来的协商协议（如GDOI[17]）来建立安全关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The network administrator defines a Security Association (SA) and Security Parameters Index (SPI) to be used to authenticate all PIM-DM protocol messages from each router on each link in a PIM-DM domain.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
网络管理员定义了一个安全关联（SA）和安全参数索引（SPI），用于验证来自PIM-DM域中每个链路上每个路由器的所有PIM-DM协议消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In order to avoid the problem of allocating individual keys for each neighbor on a link to each individual router, it is acceptable to establish only one authentication key for all PIM-DM routers on a link. This will not specifically authenticate the individual router sending the message, but will ensure that the sender is a PIM-DM router on that link. If this method is used, the receiver of the message MUST ignore the received sequence number, thus disabling anti-replay mechanisms. The effects of disabling anti-replay mechanisms are essentially the same as the effects of forged messages, described in Section 7.1, with the additional protection that the forger can only reuse legitimate messages.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了避免为链路上的每个邻居分配单个密钥到每个单独路由器的问题，可以只为链路上的所有PIM-DM路由器建立一个身份验证密钥。这不会专门验证发送消息的单个路由器，但会确保发送方是该链路上的PIM-DM路由器。如果使用此方法，则消息的接收方必须忽略接收到的序列号，从而禁用反重播机制。禁用反重放机制的效果基本上与第7.1节中描述的伪造消息的效果相同，但额外的保护是伪造者只能重用合法消息。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The Security Policy Database at a PIM-DM router should be configured to ensure that all incoming and outgoing PIM-DM packets use the SA associated with the interface to which the packet is sent. Note that, according to [10], there is nominally a different Security Association Database (SAD) for each router interface. Thus, the selected Security Association for an inbound PIM-DM packet can vary depending on the interface on which the packet arrived. This fact allows the network administrator to use different authentication methods for each link, even though the destination address is the same for most PIM-DM packets, regardless of interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM路由器上的安全策略数据库应配置为确保所有传入和传出PIM-DM数据包使用与数据包发送到的接口相关联的SA。注意，根据[10]，每个路由器接口名义上有一个不同的安全关联数据库（SAD）。因此，为入站PIM-DM分组选择的安全关联可以根据分组到达的接口而变化。这一事实允许网络管理员对每个链路使用不同的身份验证方法，即使大多数PIM-DM数据包的目标地址相同，而不管接口如何。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. Denial of Service Attacks
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7.4. 拒绝服务攻击
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are a number of possible denial of service attacks against PIM that can be caused by generating false PIM protocol messages or even by generating false data traffic. Authenticating PIM protocol traffic prevents some, but not all, of these attacks. The possible attacks include the following:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
针对PIM的许多可能的拒绝服务攻击可能是由生成错误的PIM协议消息，甚至生成错误的数据流量引起的。对PIM协议流量进行身份验证可以防止部分（但不是全部）此类攻击。可能的攻击包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Sending packets to many different group addresses quickly can amount to a denial of service attack in and of itself. These messages will initially be flooded throughout the network before they are pruned back. The maintenance of state machines and State Refresh messages will be a continual drain on network resources.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 将数据包快速发送到多个不同的组地址本身就可能构成拒绝服务攻击。这些消息在被删除之前，最初会在整个网络中泛滥。状态机和状态刷新消息的维护将持续消耗网络资源。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* Forged State Refresh messages sent quickly could be propagated by downstream routers, creating a potential denial of service attack. Therefore, a PIM-DM router SHOULD limit the rate of State Refresh messages propagated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
* 快速发送的伪造状态刷新消息可能会被下游路由器传播，从而造成潜在的拒绝服务攻击。因此，PIM-DM路由器应限制传播的状态刷新消息的速率。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The major features of PIM-DM were originally designed by Stephen Deering, Deborah Estrin, Dino Farinacci, Van Jacobson, Ahmed Helmy, David Meyer, and Liming Wei. Additional features for state refresh were designed by Dino Farinacci, Isidor Kouvelas, and Kurt Windisch. This revision was undertaken to incorporate some of the lessons learned during the evolution of the PIM-SM specification and early deployments of PIM-DM.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
PIM-DM的主要功能最初由Stephen Deering、Deborah Estrin、Dino Farinaci、Van Jacobson、Ahmed Helmy、David Meyer和Liming Wei设计。Dino Farinaci、Isidor Kouvelas和Kurt Windisch设计了用于状态刷新的其他功能。本次修订旨在纳入PIM-SM规范演变过程中的一些经验教训以及PIM-DM的早期部署。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thanks the PIM Working Group for their comments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
感谢PIM工作组的评论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Deering, S., &#34;Host extensions for IP multicasting&#34;, STD 5, RFC 1112, August 1989.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[1] Deering，S.，“IP多播的主机扩展”，STD 5，RFC 1112，1989年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Fenner, W., &#34;Internet Group Management Protocol, Version 2&#34;, RFC 2236, November 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[2] Fenner，W.，“互联网组管理协议，第2版”，RFC 2236，1997年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A. Thyagarajan, &#34;Internet Group Management Protocol, Version 3&#34;, RFC 3376, October 2002.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[3] Cain，B.，Deering，S.，Kouvelas，I.，Fenner，B.，和A.Thyagarajan，“互联网组管理协议，第3版”，RFC 3376，2002年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Estrin, D., Farinacci, D., Helmy, A., Thaler, D., Deering, S., Handley, M., Jacobson, V., Liu, C., Sharma, P., and L. Wei, &#34;Protocol Independent Multicast-Sparse Mode (PIM-SM): Protocol Specification&#34;, RFC 2362, June 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[4] Estrin，D.，Farinaci，D.，Helmy，A.，Thaler，D.，Deering，S.，Handley，M.，Jacobson，V.，Liu，C.，Sharma，P.，和L.Wei，“协议独立多播稀疏模式（PIM-SM）：协议规范”，RFC 2362，1998年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Deering, S. and R. Hinden, &#34;Internet Protocol, Version 6 (IPv6) Specification&#34;, RFC 2460, December 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[5] Deering，S.和R.Hinden，“互联网协议，第6版（IPv6）规范”，RFC 2460，1998年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Deering, S., Fenner, W., and B. Haberman, &#34;Multicast Listener Discovery (MLD) for IPv6&#34;, RFC 2710, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[6] Deering，S.，Fenner，W.和B.Haberman，“IPv6的多播侦听器发现（MLD）”，RFC 2710，1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Thaler, D., &#34;Interoperability Rules for Multicast Routing Protocols&#34;, RFC 2715, October 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[7] Thaler，D.，“多播路由协议的互操作性规则”，RFC 2715，1999年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Narten, T. and H. Alvestrand, &#34;Guidelines for Writing an IANA Considerations Section in RFCs&#34;, BCP 26, RFC 2434, October 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[8] Narten，T.和H.Alvestrand，“在RFCs中编写IANA注意事项部分的指南”，BCP 26，RFC 2434，1998年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] IANA, &#34;Address Family Numbers&#34;, linked from http://www.iana.org/numbers.html.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[9] IANA，“地址家庭编号”，链接自http://www.iana.org/numbers.html.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Kent, S. and R. Atkinson, &#34;Security Architecture for the Internet Protocol&#34;, RFC 2401, November 1998.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[10] Kent，S.和R.Atkinson，“互联网协议的安全架构”，RFC 2401，1998年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, BCP 14, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[11] Bradner，S.，“RFC中用于表示需求水平的关键词”，BCP 14，RFC 2119，1997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Deering, S.E., &#34;Multicast Routing in a Datagram Internetwork&#34;, Ph.D. Thesis, Electrical Engineering Dept., Stanford University, December 1991.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[12] Deering，S.E.，“数据报网络中的多播路由”，博士。斯坦福大学电气工程系论文，1991年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Waitzman, D., Partridge, C., and S. Deering, &#34;Distance Vector Multicast Routing Protocol&#34;, RFC 1075, November 1988.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[13] Waitzman，D.，Partridge，C.和S.Deering，“距离向量多播路由协议”，RFC 1075，1988年11月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] Fenner, W., Handley, M., Holbrook, H., and I. Kouvelas, &#34;Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[14] Fenner，W.，Handley，M.，Holbrook，H.，和I.Kouvelas，“协议独立多播-稀疏模式（PIM-SM）：协议规范（修订版）”，正在进行中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Holbrook, H. and B. Cain, &#34;Source Specific Multicast for IP&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[15] Holbrook，H.和B.Cain，“IP的源特定多播”，工作正在进行中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, &#34;Bi-directional Protocol Independent Multicast&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[16] Handley，M.，Kouvelas，I.，Speakman，T.，和L.Vicisano，“双向协议独立多播”，工作正在进行中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Baugher, M., Weis, B., Hardjono, T., and H. Harney, &#34;The Group Domain of Interpretation&#34;, RFC 3547, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[17] Baugher，M.，Weis，B.，Hardjono，T.，和H.Harney，“解释的群体领域”，RFC 3547，2003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Fenner, W., Handley, M., Kermode, R., and D. Thaler, &#34;Bootstrap Router (BSR) Mechanism for PIM Sparse Mode&#34;, Work in Progress.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[18] Fenner，W.，Handley，M.，Kermode，R.，和D.Thaler，“PIM稀疏模式的引导路由器（BSR）机制”，工作正在进行中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Andrew Adams NextHop Technologies 825 Victors Way, Suite 100 Ann Arbor, MI 48108-2738
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
安德鲁·亚当斯NextHop Technologies密歇根州安娜堡维克多大道825号100室48108-2738
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: ala@nexthop.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: ala@nexthop.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jonathan Nicholas ITT Industries Aerospace/Communications Division 100 Kingsland Rd Clifton, NJ 07014
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Jonathan Nicholas ITT工业航空/通信部，新泽西州克利夫顿金斯兰路100号，邮编07014
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jonathan.nicholas@itt.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: jonathan.nicholas@itt.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
William Siadak NextHop Technologies 825 Victors Way, Suite 100 Ann Arbor, MI 48108-2738
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
William Siadak NextHop Technologies密歇根州安娜堡维克多大道825号100室48108-2738
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: wfs@nexthop.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: wfs@nexthop.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The Internet Society (2005).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）互联网协会（2005年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其包含的信息是按“原样”提供的，贡献者、他/她所代表或赞助的组织（如有）、互联网协会和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the IETF&#39;s procedures with respect to rights in IETF Documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关IETF文件中权利的IETF程序信息，请参见BCP 78和BCP 79。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Acknowledgement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
确认
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Funding for the RFC Editor function is currently provided by the Internet Society.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
RFC编辑功能的资金目前由互联网协会提供。
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
