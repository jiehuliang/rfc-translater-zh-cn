<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name='description' content="RFC 4941: Privacy Extensions for Stateless Address Autoconfiguration in IPv6中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版">
  <title>RFC4941 中文翻译 中文RFC RFC文档 RFC翻译 RFC中文版</title>

  <link rel="shortcut icon" type="image/x-icon"
    href="favicon.ico" />

  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

  <link rel="stylesheet" href="master.css">
  <script src="index.js"></script>
  <script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?b7f7721ebaa11b23aaf77df0590e7f4a";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
  </script>
  <script data-ad-client="ca-pub-9129771189441092" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  
</head>
<body>
  <nav class="navbar navbar-expand navbar-light bg-light">
    <a class="navbar-brand" href="index.html">RFC2CN</a>
    <div class="collapse navbar-collapse" id="navbarText">
      <div class="navbar-nav mr-auto">
        <a class="nav-item nav-link" href="about.html">关于</a>
      </div>
    </div>
  </nav>

  <span id="rfc_number" class="hidden">4941</span>
  <div style="height: 1ex;"></div>
  <div class="jump-to-original-rfc-container">
    <a href="https://datatracker.ietf.org/doc/html/rfc4941">
      <button type="button" class="btn btn-light btn-sm">
        <span class="jump-to-original-rfc">Orig</span>
      </button>
    </a>
  </div>
  <div class="container">
    <div class="row">
      <div id="rfc_header" class="col-sm-12 col-md-12">
        <div class="alert alert-info" role="alert">
          <h1 class="alert-heading">RFC 4941: Privacy Extensions for Stateless Address Autoconfiguration in IPv6 中文翻译</h1>
          <span class="URL">URL :
            <a href="https://datatracker.ietf.org/doc/html/rfc4941">
              https://datatracker.ietf.org/doc/html/rfc4941
            </a>
          </span><br>
          <span class="title_ja">
            标题 : <strong>RFC 4941</strong></span><br>
          <span class="updated_by">翻译类型 : 自动生成</span><br>
        </div>
      </div>
      <div id="rfc_alert" class="col-sm-12 col-md-12 hidden" role="alert">
        <div class="alert alert-danger">
          <span id="rfc_alert_obsoleted_by"></span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          T. Narten
Request for Comments: 4941                               IBM Corporation
Obsoletes: 3041                                                R. Draves
Category: Standards Track                             Microsoft Research
                                                             S. Krishnan
                                                       Ericsson Research
                                                          September 2007
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
Network Working Group                                          T. Narten
Request for Comments: 4941                               IBM Corporation
Obsoletes: 3041                                                R. Draves
Category: Standards Track                             Microsoft Research
                                                             S. Krishnan
                                                       Ericsson Research
                                                          September 2007
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Privacy Extensions for Stateless Address Autoconfiguration in IPv6
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6中无状态地址自动配置的隐私扩展
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Status of This Memo
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
关于下段备忘
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#34;Internet Official Protocol Standards&#34; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件规定了互联网社区的互联网标准跟踪协议，并要求进行讨论和提出改进建议。有关本协议的标准化状态和状态，请参考当前版本的“互联网官方协议标准”（STD 1）。本备忘录的分发不受限制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Abstract
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
摘要
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nodes use IPv6 stateless address autoconfiguration to generate addresses using a combination of locally available information and information advertised by routers. Addresses are formed by combining network prefixes with an interface identifier. On an interface that contains an embedded IEEE Identifier, the interface identifier is typically derived from it. On other interface types, the interface identifier is generated through other means, for example, via random number generation. This document describes an extension to IPv6 stateless address autoconfiguration for interfaces whose interface identifier is derived from an IEEE identifier. Use of the extension causes nodes to generate global scope addresses from interface identifiers that change over time, even in cases where the interface contains an embedded IEEE identifier. Changing the interface identifier (and the global scope addresses generated from it) over time makes it more difficult for eavesdroppers and other information collectors to identify when different addresses used in different transactions actually correspond to the same node.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
节点使用IPv6无状态地址自动配置，结合本地可用信息和路由器发布的信息生成地址。地址由网络前缀和接口标识符组合而成。在包含嵌入式IEEE标识符的接口上，接口标识符通常从该标识符派生。在其他接口类型上，接口标识符通过其他方式生成，例如，通过随机数生成。本文档描述了对IPv6无状态地址自动配置的扩展，用于接口标识符派生自IEEE标识符的接口。使用扩展会导致节点从随时间变化的接口标识符生成全局作用域地址，即使在接口包含嵌入式IEEE标识符的情况下也是如此。随着时间的推移，更改接口标识符（以及由此生成的全局作用域地址）会使窃听者和其他信息收集器更难识别不同事务中使用的不同地址何时实际对应于同一节点。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Table of Contents
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
目录
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Conventions Used in This Document  . . . . . . . . . . . .  4
     1.2.  Problem Statement  . . . . . . . . . . . . . . . . . . . .  4
   2.  Background . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     2.1.  Extended Use of the Same Identifier  . . . . . . . . . . .  5
     2.2.  Address Usage in IPv4 Today  . . . . . . . . . . . . . . .  6
     2.3.  The Concern with IPv6 Addresses  . . . . . . . . . . . . .  7
     2.4.  Possible Approaches  . . . . . . . . . . . . . . . . . . .  8
   3.  Protocol Description . . . . . . . . . . . . . . . . . . . . .  9
     3.1.  Assumptions  . . . . . . . . . . . . . . . . . . . . . . . 10
     3.2.  Generation of Randomized Interface Identifiers . . . . . . 10
       3.2.1.  When Stable Storage Is Present . . . . . . . . . . . . 11
       3.2.2.  In The Absence of Stable Storage . . . . . . . . . . . 12
       3.2.3.  Alternate Approaches . . . . . . . . . . . . . . . . . 12
     3.3.  Generating Temporary Addresses . . . . . . . . . . . . . . 13
     3.4.  Expiration of Temporary Addresses  . . . . . . . . . . . . 14
     3.5.  Regeneration of Randomized Interface Identifiers . . . . . 15
     3.6.  Deployment Considerations  . . . . . . . . . . . . . . . . 16
   4.  Implications of Changing Interface Identifiers . . . . . . . . 17
   5.  Defined Constants  . . . . . . . . . . . . . . . . . . . . . . 18
   6.  Future Work  . . . . . . . . . . . . . . . . . . . . . . . . . 18
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 19
   8.  Significant Changes from RFC 3041  . . . . . . . . . . . . . . 19
   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 20
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 20
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 20
     10.2. Informative References . . . . . . . . . . . . . . . . . . 20
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace toc">
   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Conventions Used in This Document  . . . . . . . . . . . .  4
     1.2.  Problem Statement  . . . . . . . . . . . . . . . . . . . .  4
   2.  Background . . . . . . . . . . . . . . . . . . . . . . . . . .  5
     2.1.  Extended Use of the Same Identifier  . . . . . . . . . . .  5
     2.2.  Address Usage in IPv4 Today  . . . . . . . . . . . . . . .  6
     2.3.  The Concern with IPv6 Addresses  . . . . . . . . . . . . .  7
     2.4.  Possible Approaches  . . . . . . . . . . . . . . . . . . .  8
   3.  Protocol Description . . . . . . . . . . . . . . . . . . . . .  9
     3.1.  Assumptions  . . . . . . . . . . . . . . . . . . . . . . . 10
     3.2.  Generation of Randomized Interface Identifiers . . . . . . 10
       3.2.1.  When Stable Storage Is Present . . . . . . . . . . . . 11
       3.2.2.  In The Absence of Stable Storage . . . . . . . . . . . 12
       3.2.3.  Alternate Approaches . . . . . . . . . . . . . . . . . 12
     3.3.  Generating Temporary Addresses . . . . . . . . . . . . . . 13
     3.4.  Expiration of Temporary Addresses  . . . . . . . . . . . . 14
     3.5.  Regeneration of Randomized Interface Identifiers . . . . . 15
     3.6.  Deployment Considerations  . . . . . . . . . . . . . . . . 16
   4.  Implications of Changing Interface Identifiers . . . . . . . . 17
   5.  Defined Constants  . . . . . . . . . . . . . . . . . . . . . . 18
   6.  Future Work  . . . . . . . . . . . . . . . . . . . . . . . . . 18
   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 19
   8.  Significant Changes from RFC 3041  . . . . . . . . . . . . . . 19
   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 20
   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 20
     10.1. Normative References . . . . . . . . . . . . . . . . . . . 20
     10.2. Informative References . . . . . . . . . . . . . . . . . . 20
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. Introduction
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1. 介绍
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Stateless address autoconfiguration [ADDRCONF] defines how an IPv6 node generates addresses without the need for a Dynamic Host Configuration Protocol for IPv6 (DHCPv6) server. Some types of network interfaces come with an embedded IEEE Identifier (i.e., a link-layer MAC address), and in those cases, stateless address autoconfiguration uses the IEEE identifier to generate a 64-bit interface identifier [ADDRARCH]. By design, the interface identifier is likely to be globally unique when generated in this fashion. The interface identifier is in turn appended to a prefix to form a 128-bit IPv6 address. Note that an IPv6 identifier does not necessarily have to be 64 bits in length, but the algorithm specified in this document is targeted towards 64-bit interface identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
无状态地址自动配置[ADDRCONF]定义了IPv6节点如何在不需要IPv6（DHCPv6）服务器的动态主机配置协议的情况下生成地址。某些类型的网络接口带有嵌入式IEEE标识符（即链路层MAC地址），在这些情况下，无状态地址自动配置使用IEEE标识符生成64位接口标识符[ADDRARCH]。根据设计，当以这种方式生成时，接口标识符可能是全局唯一的。接口标识符依次附加到前缀以形成128位IPv6地址。请注意，IPv6标识符的长度不一定必须为64位，但本文档中指定的算法针对的是64位接口标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
All nodes combine interface identifiers (whether derived from an IEEE identifier or generated through some other technique) with the reserved link-local prefix to generate link-local addresses for their attached interfaces. Additional addresses can then be created by combining prefixes advertised in Router Advertisements via Neighbor Discovery [DISCOVERY] with the interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
所有节点都将接口标识符（无论是从IEEE标识符派生的还是通过其他技术生成的）与保留的链路本地前缀相结合，为其连接的接口生成链路本地地址。然后，通过将路由器广告中通过邻居发现[Discovery]播发的前缀与接口标识符相结合，可以创建其他地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Not all nodes and interfaces contain IEEE identifiers. In such cases, an interface identifier is generated through some other means (e.g., at random), and the resultant interface identifier may not be globally unique and may also change over time. The focus of this document is on addresses derived from IEEE identifiers because tracking of individual devices, the concern being addressed here, is possible only in those cases where the interface identifier is globally unique and non-changing. The rest of this document assumes that IEEE identifiers are being used, but the techniques described may also apply to interfaces with other types of globally unique and/or persistent identifiers.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
并非所有节点和接口都包含IEEE标识符。在这种情况下，通过一些其他方式（例如，随机）生成接口标识符，并且生成的接口标识符可能不是全局唯一的，并且也可能随时间而改变。本文档的重点是从IEEE标识符派生的地址，因为只有在接口标识符全局唯一且不改变的情况下，才可能跟踪单个设备（此处讨论的问题）。本文档的其余部分假设正在使用IEEE标识符，但所描述的技术也可能适用于具有其他类型的全局唯一和/或持久标识符的接口。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document discusses concerns associated with the embedding of non-changing interface identifiers within IPv6 addresses and describes extensions to stateless address autoconfiguration that can help mitigate those concerns for individual users and in environments where such concerns are significant. Section 2 provides background information on the issue. Section 3 describes a procedure for generating alternate interface identifiers and global scope addresses. Section 4 discusses implications of changing interface identifiers. The term &#34;global scope addresses&#34; is used in this document to collectively refer to &#34;Global unicast addresses&#34; as defined in [ADDRARCH] and &#34;Unique local addresses&#34; as defined in [ULA].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文档讨论了与在IPv6地址中嵌入不变接口标识符相关的问题，并描述了对无状态地址自动配置的扩展，该扩展可帮助缓解单个用户和此类问题严重的环境中的这些问题。第2节提供了有关该问题的背景资料。第3节描述了生成备用接口标识符和全局作用域地址的过程。第4节讨论了更改接口标识符的含义。本文件中使用的术语“全局范围地址”统称为[ADDRARCH]中定义的“全局单播地址”和[ULA]中定义的“唯一本地地址”。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. Conventions Used in This Document
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.1. 本文件中使用的公约
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The key words &#34;MUST&#34;, &#34;MUST NOT&#34;, &#34;REQUIRED&#34;, &#34;SHALL&#34;, &#34;SHALL NOT&#34;, &#34;SHOULD&#34;, &#34;SHOULD NOT&#34;, &#34;RECOMMENDED&#34;, &#34;MAY&#34;, and &#34;OPTIONAL&#34; in this document are to be interpreted as described in [RFC2119].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中的关键词“必须”、“不得”、“必需”、“应”、“不应”、“应”、“不应”、“建议”、“可”和“可选”应按照[RFC2119]中所述进行解释。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. Problem Statement
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
1.2. 问题陈述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addresses generated using stateless address autoconfiguration [ADDRCONF] contain an embedded interface identifier, which remains constant over time. Anytime a fixed identifier is used in multiple contexts, it becomes possible to correlate seemingly unrelated activity using this identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用无状态地址自动配置[ADDRCONF]生成的地址包含一个嵌入式接口标识符，该标识符随时间保持不变。只要在多个上下文中使用固定标识符，就可以使用该标识符关联看似无关的活动。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The correlation can be performed by
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
关联可以通过以下方式执行：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An attacker who is in the path between the node in question and the peer(s) to which it is communicating, and who can view the IPv6 addresses present in the datagrams.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 位于相关节点与其通信的对等方之间的路径中，并且能够查看数据报中存在的IPv6地址的攻击者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o An attacker who can access the communication logs of the peers with which the node has communicated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 可以访问与节点通信的对等方的通信日志的攻击者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Since the identifier is embedded within the IPv6 address, which is a fundamental requirement of communication, it cannot be easily hidden. This document proposes a solution to this issue by generating interface identifiers that vary over time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于标识符嵌入在IPv6地址中（这是通信的基本要求），因此它不容易隐藏。本文档通过生成随时间变化的接口标识符，提出了此问题的解决方案。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that an attacker, who is on path, may be able to perform significant correlation based on
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，位于路径上的攻击者可能能够基于
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The payload contents of the packets on the wire
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 导线上数据包的有效负载内容
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The characteristics of the packets such as packet size and timing
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 数据包的特征，如数据包大小和时间
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of temporary addresses will not prevent such payload-based correlation.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用临时地址不会阻止这种基于有效负载的关联。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. Background
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2. 出身背景
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section discusses the problem in more detail, provides context for evaluating the significance of the concerns in specific environments and makes comparisons with existing practices.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节将更详细地讨论这个问题，为评估特定环境中关注点的重要性提供上下文，并与现有实践进行比较。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. Extended Use of the Same Identifier
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.1. 同一标识符的扩展使用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of a non-changing interface identifier to form addresses is a specific instance of the more general case where a constant identifier is reused over an extended period of time and in multiple independent activities. Any time the same identifier is used in multiple contexts, it becomes possible for that identifier to be used to correlate seemingly unrelated activity. For example, a network sniffer placed strategically on a link across which all traffic to/ from a particular host crosses could keep track of which destinations a node communicated with and at what times. Such information can in some cases be used to infer things, such as what hours an employee was active, when someone is at home, etc. Although it might appear that changing an address regularly in such environments would be desirable to lessen privacy concerns, it should be noted that the network prefix portion of an address also serves as a constant identifier. All nodes at, say, a home, would have the same network prefix, which identifies the topological location of those nodes. This has implications for privacy, though not at the same granularity as the concern that this document addresses. Specifically, all nodes within a home could be grouped together for the purposes of collecting information. If the network contains a very small number of nodes, say, just one, changing just the interface identifier will not enhance privacy at all, since the prefix serves as a constant identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用不改变的接口标识符来形成地址是更一般情况下的一个具体实例，在这种情况下，常量标识符在一段较长的时间内以及在多个独立的活动中被重用。每当同一标识符在多个上下文中使用时，该标识符就有可能用于关联看似无关的活动。例如，将网络嗅探器战略性地放置在一条链路上，通过该链路，进出特定主机的所有流量都可以跟踪节点与哪个目的地通信以及在什么时候通信。在某些情况下，此类信息可用于推断事件，例如员工的工作时间、某人在家的时间等。尽管在此类环境中定期更改地址可能有助于减少隐私问题，应当注意的是，地址的网络前缀部分也用作常量标识符。比如说，一个家庭中的所有节点都将具有相同的网络前缀，用于标识这些节点的拓扑位置。这对隐私有影响，但与本文档涉及的问题的粒度不同。具体而言，为了收集信息，可以将家庭中的所有节点分组在一起。如果网络包含非常少的节点，比如说只有一个节点，那么仅仅更改接口标识符根本不会增强隐私性，因为前缀用作常量标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One of the requirements for correlating seemingly unrelated activities is the use (and reuse) of an identifier that is recognizable over time within different contexts. IP addresses provide one obvious example, but there are more. Many nodes also have DNS names associated with their addresses, in which case the DNS name serves as a similar identifier. Although the DNS name associated with an address is more work to obtain (it may require a DNS query), the information is often readily available. In such cases, changing the address on a machine over time would do little to address the concerns raised in this document, unless the DNS name is changed as well (see Section 4).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
关联看似不相关的活动的一个要求是使用（和重用）一个标识符，该标识符在不同的上下文中随着时间的推移是可识别的。IP地址提供了一个明显的例子，但还有更多。许多节点还具有与其地址关联的DNS名称，在这种情况下，DNS名称用作类似的标识符。虽然与地址相关联的DNS名称需要更多的工作才能获得（可能需要DNS查询），但信息通常是现成的。在这种情况下，随着时间的推移更改计算机上的地址对解决本文档中提出的问题几乎没有帮助，除非DNS名称也发生了更改（请参见第4节）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Web browsers and servers typically exchange &#34;cookies&#34; with each other [COOKIES]. Cookies allow Web servers to correlate a current activity with a previous activity. One common usage is to send back targeted advertising to a user by using the cookie supplied by the browser to
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Web浏览器和服务器通常相互交换“cookies”[cookies]。Cookie允许Web服务器将当前活动与以前的活动关联起来。一种常见的用法是使用浏览器提供的cookie将目标广告发送回用户，以便
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
identify what earlier queries had been made (e.g., for what type of information). Based on the earlier queries, advertisements can be targeted to match the (assumed) interests of the end user.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
确定以前曾进行过哪些查询（例如，针对何种类型的信息）。根据前面的查询，可以将广告定位为与最终用户的（假定）兴趣相匹配。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of a constant identifier within an address is of special concern because addresses are a fundamental requirement of communication and cannot easily be hidden from eavesdroppers and other parties. Even when higher layers encrypt their payloads, addresses in packet headers appear in the clear. Consequently, if a mobile host (e.g., laptop) accessed the network from several different locations, an eavesdropper might be able to track the movement of that mobile host from place to place, even if the upper layer payloads were encrypted.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在地址中使用常量标识符是一个特别值得关注的问题，因为地址是通信的基本要求，不容易被窃听者和其他方隐藏。即使当更高层加密其有效载荷时，数据包头中的地址也会显示为明文。因此，如果移动主机（例如笔记本电脑）从几个不同的位置访问网络，则窃听者可能能够跟踪该移动主机从一个地方到另一个地方的移动，即使上层有效载荷被加密。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. Address Usage in IPv4 Today
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.2. 当前IPv4中的地址使用情况
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Addresses used in today&#39;s Internet are often non-changing in practice for extended periods of time. In an increasing number of sites, addresses are assigned statically and typically change infrequently. Over the last few years, sites have begun moving away from static allocation to dynamic allocation via DHCP [DHCP]. In theory, the address a client gets via DHCP can change over time, but in practice servers often return the same address to the same client (unless addresses are in such short supply that they are reused immediately by a different node when they become free). Thus, even within sites using DHCP, clients frequently end up using the same address for weeks to months at a time.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在今天的互联网上使用的地址通常在很长一段时间内是不变的。在越来越多的站点中，地址是静态分配的，通常很少更改。在过去几年中，站点已经开始从静态分配转向通过DHCP[DHCP]进行动态分配。理论上，客户机通过DHCP获得的地址可能会随着时间的推移而改变，但实际上服务器通常会将相同的地址返回给同一客户机（除非地址非常短缺，当地址空闲时会立即被其他节点重新使用）。因此，即使在使用DHCP的站点中，客户端也常常一次使用同一地址达数周到数月之久。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
For home users accessing the Internet over dial-up lines, the situation is generally different. Such users do not have permanent connections and are often assigned temporary addresses each time they connect to their ISP. Consequently, the addresses they use change frequently over time and are shared among a number of different users. Thus, an address does not reliably identify a particular device over time spans of more than a few minutes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
对于通过拨号线路访问互联网的家庭用户来说，情况通常是不同的。这类用户没有永久连接，每次连接到ISP时通常会被分配临时地址。因此，他们使用的地址会随着时间的推移而频繁更改，并在多个不同的用户之间共享。因此，地址在超过几分钟的时间跨度内不能可靠地识别特定设备。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more interesting case concerns always-on connections (e.g., cable modems, ISDN, DSL, etc.) that result in a home site using the same address for extended periods of time. This is a scenario that is just starting to become common in IPv4 and promises to become more of a concern as always-on Internet connectivity becomes widely available.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个更有趣的情况是，总是在连接上（例如，电缆调制解调器、ISDN、DSL等），这会导致家庭站点长时间使用同一地址。这是一个在IPv4中刚刚开始变得普遍的场景，并且随着“始终在线”互联网连接变得广泛可用，它有望成为一个更令人关注的问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, it should be noted that nodes that need a (non-changing) DNS name generally have static addresses assigned to them to simplify the configuration of DNS servers. Although Dynamic DNS [DDNS] can be used to update the DNS dynamically, it may not always be available depending on the administrative policy. In addition, changing an
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，应该注意的是，需要（非更改）DNS名称的节点通常具有分配给它们的静态地址，以简化DNS服务器的配置。尽管动态DNS[DDNS]可用于动态更新DNS，但根据管理策略，它可能并不总是可用。此外，更改
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
address but keeping the same DNS name does not really address the underlying concern, since the DNS name becomes a non-changing identifier. Servers generally require a DNS name (so clients can connect to them), and clients often do as well (e.g., some servers refuse to speak to a client whose address cannot be mapped into a DNS name that also maps back into the same address). Section 4 describes one approach to this issue.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
地址，但保持相同的DNS名称并不能真正解决根本问题，因为DNS名称成为一个不变的标识符。服务器通常需要DNS名称（因此客户端可以连接到它们），客户端通常也需要DNS名称（例如，一些服务器拒绝与地址无法映射到DNS名称（该名称也映射回同一地址）的客户端通话）。第4节描述了解决此问题的一种方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. The Concern with IPv6 Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.3. 与IPv6地址有关的问题
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The division of IPv6 addresses into distinct topology and interface identifier portions raises an issue new to IPv6 in that a fixed portion of an IPv6 address (i.e., the interface identifier) can contain an identifier that remains constant even when the topology portion of an address changes (e.g., as the result of connecting to a different part of the Internet). In IPv4, when an address changes, the entire address (including the local part of the address) usually changes. It is this new issue that this document addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
将IPv6地址划分为不同的拓扑和接口标识符部分对IPv6提出了一个新问题，即IPv6地址的固定部分（即接口标识符）可以包含一个标识符，即使地址的拓扑部分发生变化，该标识符也会保持不变（例如，由于连接到Internet的不同部分）。在IPv4中，当地址更改时，整个地址（包括地址的本地部分）通常都会更改。本文档针对的正是这个新问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If addresses are generated from an interface identifier, a home user&#39;s address could contain an interface identifier that remains the same from one dial-up session to the next, even if the rest of the address changes. The way PPP is used today, however, PPP servers typically unilaterally inform the client what address they are to use (i.e., the client doesn&#39;t generate one on its own). This practice, if continued in IPv6, would avoid the concerns that are the focus of this document.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果地址是从接口标识符生成的，则家庭用户的地址可能包含一个接口标识符，该接口标识符在一个拨号会话到下一个拨号会话期间保持不变，即使其余地址发生变化。然而，按照目前使用PPP的方式，PPP服务器通常会单方面通知客户端他们要使用的地址（即，客户端不会自行生成地址）。如果在IPv6中继续使用这种做法，将避免本文档重点关注的问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A more troubling case concerns mobile devices (e.g., laptops, PDAs, etc.) that move topologically within the Internet. Whenever they move, they form new addresses for their current topological point of attachment. This is typified today by the &#34;road warrior&#34; who has Internet connectivity both at home and at the office. While the node&#39;s address changes as it moves, the interface identifier contained within the address remains the same (when derived from an IEEE Identifier). In such cases, the interface identifier can be used to track the movement and usage of a particular machine. For example, a server that logs usage information together with source addresses, is also recording the interface identifier since it is embedded within an address. Consequently, any data-mining technique that correlates activity based on addresses could easily be extended to do the same using the interface identifier. This is of particular concern with the expected proliferation of next-generation network-connected devices (e.g., PDAs, cell phones, etc.) in which large numbers of devices are, in practice, associated with individual users (i.e., not shared). Thus, the interface identifier embedded within an address could be used to track activities of an individual, even as they move topologically within the Internet.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
一个更令人不安的情况涉及在互联网内拓扑移动的移动设备（例如笔记本电脑、PDA等）。无论何时移动，它们都会为当前拓扑连接点形成新地址。今天的“道路战士”就是一个典型，他在家里和办公室都能连接互联网。当节点的地址随着移动而改变时，地址中包含的接口标识符保持不变（当从IEEE标识符派生时）。在这种情况下，接口标识符可用于跟踪特定机器的移动和使用情况。例如，记录使用信息和源地址的服务器也在记录接口标识符，因为它嵌入在地址中。因此，任何基于地址关联活动的数据挖掘技术都可以通过使用接口标识符轻松地进行扩展。下一代网络连接设备（如PDA、手机等）的预期激增尤其令人担忧，在这些设备中，大量设备实际上与个人用户相关（即，不共享）。因此，嵌入在地址中的接口标识符可用于跟踪个人的活动，即使这些活动在互联网中按拓扑结构移动。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In summary, IPv6 addresses on a given interface generated via Stateless Autoconfiguration contain the same interface identifier, regardless of where within the Internet the device connects. This facilitates the tracking of individual devices (and thus, potentially, users). The purpose of this document is to define mechanisms that eliminate this issue in those situations where it is a concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
总之，通过无状态自动配置生成的给定接口上的IPv6地址包含相同的接口标识符，而不管设备连接到Internet中的何处。这有助于跟踪单个设备（因此可能还有用户）。本文件的目的是确定在关注这一问题的情况下消除这一问题的机制。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. Possible Approaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
2.4. 可能的办法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
One way to avoid having a static non-changing address is to use DHCPv6 [DHCPV6] for obtaining addresses. Section 12 of [DHCPV6] discusses the use of DHCPv6 for the assignment and management of &#34;temporary addresses&#34;, which are never renewed and provide the same property of temporary addresses described in this document with regards to the privacy concern.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
避免使用静态不变地址的一种方法是使用DHCPv6[DHCPv6]获取地址。[DHCPV6]第12节讨论了使用DHCPV6分配和管理“临时地址”，这些地址从不更新，并提供与本文件中所述的有关隐私问题的临时地址相同的属性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Another approach, compatible with the stateless address autoconfiguration architecture, would be to change the interface identifier portion of an address over time and generate new addresses from the interface identifier for some address scopes. Changing the interface identifier can make it more difficult to look at the IP addresses in independent transactions and identify which ones actually correspond to the same node, both in the case where the routing prefix portion of an address changes and when it does not.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
另一种与无状态地址自动配置体系结构兼容的方法是，随着时间的推移更改地址的接口标识符部分，并为某些地址范围从接口标识符生成新地址。更改接口标识符会使查看独立事务中的IP地址以及识别哪些IP地址实际上对应于同一节点变得更加困难，无论是在地址的路由前缀部分发生更改的情况下，还是在地址的路由前缀部分未发生更改的情况下。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Many machines function as both clients and servers. In such cases, the machine would need a DNS name for its use as a server. Whether the address stays fixed or changes has little privacy implication since the DNS name remains constant and serves as a constant identifier. When acting as a client (e.g., initiating communication), however, such a machine may want to vary the addresses it uses. In such environments, one may need multiple addresses: a &#34;public&#34; (i.e., non-secret) server address, registered in the DNS, that is used to accept incoming connection requests from other machines, and a &#34;temporary&#34; address used to shield the identity of the client when it initiates communication. These two cases are roughly analogous to telephone numbers and caller ID, where a user may list their telephone number in the public phone book, but disable the display of its number via caller ID when initiating calls.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
许多机器同时充当客户机和服务器。在这种情况下，机器需要DNS名称才能用作服务器。无论地址是否保持固定还是更改都没有什么隐私含义，因为DNS名称保持不变，并充当常量标识符。然而，当充当客户机（例如，启动通信）时，这样的机器可能希望改变其使用的地址。在这种环境中，可能需要多个地址：在DNS中注册的“公共”（即非机密）服务器地址，用于接收来自其他机器的传入连接请求，以及用于在客户端启动通信时屏蔽其身份的“临时”地址。这两种情况大致类似于电话号码和呼叫者ID，其中用户可以在公用电话簿中列出其电话号码，但在发起呼叫时禁用通过呼叫者ID显示其号码。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
To make it difficult to make educated guesses as to whether two different interface identifiers belong to the same node, the algorithm for generating alternate identifiers must include input that has an unpredictable component from the perspective of the outside entities that are collecting information. Picking identifiers from a pseudo-random sequence suffices, so long as the specific sequence cannot be determined by an outsider examining
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
为了使对两个不同接口标识符是否属于同一节点进行有根据的猜测变得困难，用于生成备用标识符的算法必须包括从收集信息的外部实体的角度来看具有不可预测组件的输入。只要外部人员无法确定特定序列，从伪随机序列中选取标识符就足够了
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
information that is readily available or easily determinable (e.g., by examining packet contents). This document proposes the generation of a pseudo-random sequence of interface identifiers via an MD5 hash. Periodically, the next interface identifier in the sequence is generated, a new set of temporary addresses is created, and the previous temporary addresses are deprecated to discourage their further use. The precise pseudo-random sequence depends on both a random component and the globally unique interface identifier (when available), to increase the likelihood that different nodes generate different sequences.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
容易获得或容易确定的信息（例如，通过检查数据包内容）。本文档建议通过MD5哈希生成接口标识符的伪随机序列。定期生成序列中的下一个接口标识符，创建一组新的临时地址，并弃用以前的临时地址以阻止其进一步使用。精确的伪随机序列取决于随机分量和全局唯一接口标识符（如果可用），以增加不同节点生成不同序列的可能性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. Protocol Description
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3. 协议描述
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The goal of this section is to define procedures that:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节的目标是定义以下程序：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Do not result in any changes to the basic behavior of addresses generated via stateless address autoconfiguration [ADDRCONF].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 不要对通过无状态地址自动配置[ADDRCONF]生成的地址的基本行为进行任何更改。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Create additional addresses based on a random interface identifier for the purpose of initiating outgoing sessions. These &#34;random&#34; or temporary addresses would be used for a short period of time (hours to days) and would then be deprecated. Deprecated address can continue to be used for already established connections, but are not used to initiate new connections. New temporary addresses are generated periodically to replace temporary addresses that expire, with the exact time between address generation a matter of local policy.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 基于随机接口标识符创建其他地址，以启动传出会话。这些“随机”或临时地址将在短时间内（数小时到数天）使用，然后将被弃用。不推荐使用的地址可继续用于已建立的连接，但不用于启动新连接。定期生成新的临时地址以替换过期的临时地址，地址生成之间的确切时间取决于本地策略。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Produce a sequence of temporary global scope addresses from a sequence of interface identifiers that appear to be random in the sense that it is difficult for an outside observer to predict a future address (or identifier) based on a current one, and it is difficult to determine previous addresses (or identifiers) knowing only the present one.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 从接口标识符序列生成临时全局作用域地址序列，该序列看起来是随机的，因为外部观察者难以基于当前地址预测未来地址（或标识符），并且难以确定仅知道当前地址的先前地址（或标识符）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. By default, generate a set of addresses from the same (randomized) interface identifier, one address for each prefix for which a global address has been generated via stateless address autoconfiguration. Using the same interface identifier to generate a set of temporary addresses reduces the number of IP multicast groups a host must join. Nodes join the solicited-node multicast address for each unicast address they support, and solicited-node addresses are dependent only on the low-order bits of the corresponding address. This default behavior was made to address the concern that a node that joins a large number of multicast groups may be required to put its interface into promiscuous mode, resulting in possible reduced performance.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 默认情况下，从相同（随机）接口标识符生成一组地址，通过无状态地址自动配置为每个前缀生成一个全局地址。使用相同的接口标识符生成一组临时地址可以减少主机必须加入的IP多播组的数量。节点为其支持的每个单播地址加入请求节点多播地址，请求节点地址仅依赖于相应地址的低位。此默认行为是为了解决加入大量多播组的节点可能需要将其接口置于混杂模式，从而可能导致性能降低的问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
A node highly concerned about privacy MAY use different interface identifiers on different prefixes, resulting in a set of global addresses that cannot be easily tied to each other. For example a node MAY create different interface identifiers I1, I2, and I3 for use with different prefixes P1, P2, and P3 on the same interface.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
高度关注隐私的节点可能会在不同的前缀上使用不同的接口标识符，从而导致一组全局地址不容易相互绑定。例如，节点可以创建不同的接口标识符I1、I2和I3，以便与同一接口上的不同前缀P1、P2和P3一起使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. Assumptions
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.1. 假设
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following algorithm assumes that each interface maintains an associated randomized interface identifier. When temporary addresses are generated, the current value of the associated randomized interface identifier is used. While the same identifier can be used to create more than one temporary address, the value SHOULD change over time as described in Section 3.5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下算法假设每个接口都维护一个关联的随机接口标识符。生成临时地址时，将使用关联的随机接口标识符的当前值。虽然同一标识符可用于创建多个临时地址，但该值应随时间变化，如第3.5节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The algorithm also assumes that, for a given temporary address, an implementation can determine the prefix from which it was generated. When a temporary address is deprecated, a new temporary address is generated. The specific valid and preferred lifetimes for the new address are dependent on the corresponding lifetime values set for the prefix from which it was generated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
该算法还假设，对于给定的临时地址，实现可以确定生成该地址的前缀。不推荐使用临时地址时，将生成新的临时地址。新地址的特定有效和首选生存期取决于为生成新地址的前缀设置的相应生存期值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, this document assumes that when a node initiates outgoing communication, temporary addresses can be given preference over public addresses when the device is configured to do so. [ADDR_SELECT] mandates implementations to provide a mechanism, which allows an application to configure its preference for temporary addresses over public addresses. It also allows for an implementation to prefer temporary addresses by default, so that the connections initiated by the node can use temporary addresses without requiring application-specific enablement. This document also assumes that an API will exist that allows individual applications to indicate whether they prefer to use temporary or public addresses and override the system defaults.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，本文档假设当节点启动传出通信时，当设备配置为这样做时，临时地址可以优先于公共地址。[ADDR_SELECT]要求实现提供一种机制，允许应用程序配置其对临时地址的偏好，而不是公共地址。它还允许实现在默认情况下选择临时地址，以便节点启动的连接可以使用临时地址，而无需特定于应用程序的启用。本文档还假设将存在一个API，该API允许单个应用程序指示它们是喜欢使用临时地址还是公共地址，并覆盖系统默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. Generation of Randomized Interface Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2. 随机接口标识符的生成
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
We describe two approaches for the generation and maintenance of the randomized interface identifier. The first assumes the presence of stable storage that can be used to record state history for use as input into the next iteration of the algorithm across system restarts. A second approach addresses the case where stable storage is unavailable and there is a need to generate randomized interface identifiers without previous state.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
我们描述了两种生成和维护随机接口标识符的方法。第一种方法假设存在稳定的存储，可用于记录状态历史，作为下一次迭代算法在系统重启时的输入。第二种方法解决了稳定存储不可用的情况，并且需要在没有先前状态的情况下生成随机接口标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The random interface identifier generation algorithm, as described in this document, uses MD5 as the hash algorithm. The node MAY use another algorithm instead of MD5 to produce the random interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如本文所述，随机接口标识符生成算法使用MD5作为哈希算法。节点可以使用另一种算法而不是MD5来生成随机接口标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. When Stable Storage Is Present
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.1. 当存在稳定的存储时
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The following algorithm assumes the presence of a 64-bit &#34;history value&#34; that is used as input in generating a randomized interface identifier. The very first time the system boots (i.e., out-of-the-box), a random value SHOULD be generated using techniques that help ensure the initial value is hard to guess [RANDOM]. Whenever a new interface identifier is generated, a value generated by the computation is saved in the history value for the next iteration of the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
以下算法假设存在64位“历史值”，该值用作生成随机接口标识符的输入。系统第一次启动（即开箱即用）时，应使用有助于确保初始值难以猜测的技术生成随机值[随机]。每当生成新的接口标识符时，计算生成的值将保存在历史值中，以供算法的下一次迭代使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
A randomized interface identifier is created as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
随机接口标识符的创建如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Take the history value from the previous iteration of this algorithm (or a random value if there is no previous value) and append to it the interface identifier generated as described in [ADDRARCH].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 从该算法的上一次迭代中获取历史值（如果没有以前的值，则为随机值），并将[ADDRARCH]中所述生成的接口标识符附加到该值中。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Compute the MD5 message digest [MD5] over the quantity created in the previous step.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 根据上一步中创建的数量计算MD5消息摘要[MD5]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Take the leftmost 64-bits of the MD5 digest and set bit 6 (the leftmost bit is numbered 0) to zero. This creates an interface identifier with the universal/local bit indicating local significance only.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 获取MD5摘要最左边的64位，并将第6位（最左边的位编号为0）设置为零。这将创建一个接口标识符，其通用/本地位仅表示本地重要性。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. Compare the generated identifier against a list of reserved interface identifiers and to those already assigned to an address on the local device. In the event that an unacceptable identifier has been generated, the node MUST restart the process at step 1 above, using the rightmost 64 bits of the MD5 digest obtained in step 2 in place of the history value in step 1.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 将生成的标识符与保留接口标识符列表以及已分配给本地设备上地址的标识符进行比较。如果生成了不可接受的标识符，则节点必须在上面的步骤1重新启动进程，使用在步骤2中获得的MD5摘要的最右边64位来代替步骤1中的历史值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Save the generated identifier as the associated randomized interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 将生成的标识符保存为关联的随机接口标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. Take the rightmost 64-bits of the MD5 digest computed in step 2) and save them in stable storage as the history value to be used in the next iteration of the algorithm.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 获取在步骤2）中计算的MD5摘要最右边的64位，并将其保存在稳定存储器中，作为历史值，以便在算法的下一次迭代中使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MD5 was chosen for convenience, and because its particular properties were adequate to produce the desired level of randomization. The node MAY use another algorithm instead of MD5 to produce the random interface identifier
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
选择MD5是为了方便，因为它的特殊性质足以产生所需的随机化水平。节点可以使用另一种算法而不是MD5来生成随机接口标识符
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In theory, generating successive randomized interface identifiers using a history scheme as above has no advantages over generating them at random. In practice, however, generating truly random numbers can be tricky. Use of a history value is intended to avoid the particular scenario where two nodes generate the same randomized interface identifier, both detect the situation via DAD, but then proceed to generate identical randomized interface identifiers via the same (flawed) random number generation algorithm. The above algorithm avoids this problem by having the interface identifier (which will often be globally unique) used in the calculation that generates subsequent randomized interface identifiers. Thus, if two nodes happen to generate the same randomized interface identifier, they should generate different ones on the follow-up attempt.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
理论上，使用如上所述的历史方案生成连续的随机接口标识符与随机生成它们相比没有任何优势。然而，在实践中，生成真正的随机数可能很棘手。使用历史值旨在避免两个节点生成相同的随机接口标识符的特定场景，这两个节点都通过DAD检测情况，但随后通过相同的（有缺陷的）随机数生成算法生成相同的随机接口标识符。上述算法通过在生成后续随机接口标识符的计算中使用接口标识符（通常是全局唯一的）来避免此问题。因此，如果两个节点碰巧生成相同的随机接口标识符，那么它们应该在后续尝试中生成不同的标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. In The Absence of Stable Storage
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.2. 在缺乏稳定储存的情况下
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
In the absence of stable storage, no history value will be available across system restarts to generate a pseudo-random sequence of interface identifiers. Consequently, the initial history value used above SHOULD be generated at random. A number of techniques might be appropriate. Consult [RANDOM] for suggestions on good sources for obtaining random numbers. Note that even though machines may not have stable storage for storing a history value, they will in many cases have configuration information that differs from one machine to another (e.g., user identity, security keys, serial numbers, etc.). One approach to generating a random initial history value in such cases is to use the configuration information to generate some data bits (which may remain constant for the life of the machine, but will vary from one machine to another), append some random data, and compute the MD5 digest as before.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在没有稳定存储的情况下，在系统重新启动时，将没有可用的历史值来生成接口标识符的伪随机序列。因此，上述使用的初始历史值应随机生成。一些技术可能是合适的。有关获取随机数的良好来源的建议，请参考[RANDOM]。请注意，尽管计算机可能没有用于存储历史值的稳定存储器，但在许多情况下，它们的配置信息在不同的计算机之间是不同的（例如，用户身份、安全密钥、序列号等）。在这种情况下，生成随机初始历史值的一种方法是使用配置信息生成一些数据位（在机器的使用寿命内可能保持不变，但在不同的机器上会有所不同），附加一些随机数据，并像以前一样计算MD5摘要。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. Alternate Approaches
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.2.3. 替代方法
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Note that there are other approaches to generate random interface identifiers, albeit with different goals and applicability. One such approach is Cryptographically Generated Addresses (CGAs) [CGA], which generate a random interface identifier based on the public key of the node. The goal of CGAs is to prove ownership of an address and to prevent spoofing and stealing of existing IPv6 addresses. They are used for securing neighbor discovery using [SEND]. The CGA random interface identifier generation algorithm may not be suitable for privacy addresses because of the following properties:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
请注意，还有其他生成随机接口标识符的方法，尽管目标和适用性不同。其中一种方法是加密生成地址（CGA）[CGA]，它基于节点的公钥生成随机接口标识符。CGAs的目标是证明地址的所有权，并防止对现有IPv6地址的欺骗和窃取。它们用于使用[SEND]保护邻居发现。由于以下属性，CGA随机接口标识符生成算法可能不适用于隐私地址：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o It requires the node to have a public key. This means that the node can still be identified by its public key.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 它要求节点具有公钥。这意味着节点仍然可以通过其公钥进行标识。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o The random interface identifier process is computationally intensive and hence discourages frequent regeneration.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
o 随机接口标识符过程需要大量计算，因此不鼓励频繁重新生成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. Generating Temporary Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.3. 生成临时地址
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRCONF] describes the steps for generating a link-local address when an interface becomes enabled as well as the steps for generating addresses for other scopes. This document extends [ADDRCONF] as follows. When processing a Router Advertisement with a Prefix Information option carrying a global scope prefix for the purposes of address autoconfiguration (i.e., the A bit is set), the node MUST perform the following steps:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRCONF]描述了在启用接口时生成链接本地地址的步骤以及为其他作用域生成地址的步骤。本文档对[ADDRCONF]进行了如下扩展。为了地址自动配置的目的（即，设置了a位），处理带有带有带有全局作用域前缀的前缀信息选项的路由器播发时，节点必须执行以下步骤：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Process the Prefix Information Option as defined in [ADDRCONF], either creating a new public address or adjusting the lifetimes of existing addresses, both public and temporary. If a received option will extend the lifetime of a public address, the lifetimes of temporary addresses should be extended, subject to the overall constraint that no temporary addresses should ever remain &#34;valid&#34; or &#34;preferred&#34; for a time longer than (TEMP_VALID_LIFETIME) or (TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR), respectively. The configuration variables TEMP_VALID_LIFETIME and TEMP_PREFERRED_LIFETIME correspond to approximate target lifetimes for temporary addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 处理[ADDRCONF]中定义的前缀信息选项，创建新的公共地址或调整现有公共和临时地址的生存期。如果收到的选项将延长公共广播的生存期，则应延长临时地址的生存期，但须遵守以下总体约束：临时地址的“有效”或“首选”时间不得分别超过（临时有效生存期）或（临时首选生存期-失同步系数）。配置变量TEMP_VALID_life和TEMP_PREFERRED_life对应于临时地址的近似目标生存期。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. One way an implementation can satisfy the above constraints is to associate with each temporary address a creation time (called CREATION_TIME) that indicates the time at which the address was created. When updating the preferred lifetime of an existing temporary address, it would be set to expire at whichever time is earlier: the time indicated by the received lifetime or (CREATION_TIME + TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR). A similar approach can be used with the valid lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 实现满足上述约束的一种方法是将一个创建时间（称为creation_time）与每个临时地址相关联，该时间指示地址的创建时间。当更新现有临时地址的首选生存期时，它将被设置为在较早的时间过期：由接收的生存期或（创建时间+临时首选生存期-去同步系数）指示的时间。对于有效的生存期，也可以使用类似的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. When a new public address is created as described in [ADDRCONF], the node SHOULD also create a new temporary address.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 当按照[ADDRCONF]中的说明创建新的公共地址时，节点还应创建一个新的临时地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. When creating a temporary address, the lifetime values MUST be derived from the corresponding prefix as follows:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. 创建临时地址时，生存期值必须从相应的前缀派生，如下所示：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Its Valid Lifetime is the lower of the Valid Lifetime of the public address or TEMP_VALID_LIFETIME.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 其有效生存期为公共广播的有效生存期或临时有效生存期中的较低者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* Its Preferred Lifetime is the lower of the Preferred Lifetime of the public address or TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-7">
* 其首选寿命是公共广播的首选寿命或临时首选寿命-去同步系数中的较低者。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. A temporary address is created only if this calculated Preferred Lifetime is greater than REGEN_ADVANCE time units. In particular, an implementation MUST NOT create a temporary address with a zero Preferred Lifetime.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 仅当计算的首选生存期大于REGEN_提前时间单位时，才会创建临时地址。特别是，实现不能创建首选生存期为零的临时地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. New temporary addresses MUST be created by appending the interface&#39;s current randomized interface identifier to the prefix that was received.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 必须通过将接口的当前随机接口标识符附加到接收到的前缀来创建新的临时地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The node MUST perform duplicate address detection (DAD) on the generated temporary address. If DAD indicates the address is already in use, the node MUST generate a new randomized interface identifier as described in Section 3.2 above, and repeat the previous steps as appropriate up to TEMP_IDGEN_RETRIES times. If after TEMP_IDGEN_RETRIES consecutive attempts no non-unique address was generated, the node MUST log a system error and MUST NOT attempt to generate temporary addresses for that interface. Note that DAD MUST be performed on every unicast address generated from this randomized interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. 节点必须对生成的临时地址执行重复地址检测（DAD）。如果DAD指示该地址已在使用中，则节点必须生成一个新的随机接口标识符，如上文第3.2节所述，并根据需要重复前面的步骤，直到TEMP_IDGEN_重试次数。如果在TEMP_IDGEN_重试连续尝试后未生成非唯一地址，则节点必须记录系统错误，并且不得尝试为该接口生成临时地址。请注意，必须对由该随机接口标识符生成的每个单播地址执行DAD。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. Expiration of Temporary Addresses
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.4. 临时地址过期
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
When a temporary address becomes deprecated, a new one MUST be generated. This is done by repeating the actions described in Section 3.3, starting at step 3). Note that, except for the transient period when a temporary address is being regenerated, in normal operation at most one temporary address per prefix should be in a non-deprecated state at any given time on a given interface. Note that if a temporary address becomes deprecated as result of processing a Prefix Information Option with a zero Preferred Lifetime, then a new temporary address MUST NOT be generated. To ensure that a preferred temporary address is always available, a new temporary address SHOULD be regenerated slightly before its predecessor is deprecated. This is to allow sufficient time to avoid race conditions in the case where generating a new temporary address is not instantaneous, such as when duplicate address detection must be run. The node SHOULD start the address regeneration process REGEN_ADVANCE time units before a temporary address would actually be deprecated.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
当临时地址不推荐使用时，必须生成一个新地址。从步骤3）开始，通过重复第3.3节中描述的操作来完成。请注意，除了重新生成临时地址的过渡期外，在正常操作中，在给定接口上的任何给定时间，每个前缀最多有一个临时地址应处于非弃用状态。请注意，如果临时地址因处理首选生存期为零的前缀信息选项而被弃用，则不得生成新的临时地址。为确保首选临时地址始终可用，应在不推荐使用新临时地址之前重新生成新临时地址。这是为了在生成新临时地址不是即时的情况下（例如必须运行重复地址检测时），允许有足够的时间避免争用情况。在临时地址实际被弃用之前，节点应启动地址重新生成过程，以提前时间单位重新生成。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
As an optional optimization, an implementation MAY remove a deprecated temporary address that is not in use by applications or upper layers as detailed in Section 6.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
作为可选优化，实现可以删除应用程序或上层未使用的不推荐的临时地址，如第6节所述。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. Regeneration of Randomized Interface Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.5. 随机接口标识符的再生
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The frequency at which temporary addresses changes depends on how a device is being used (e.g., how frequently it initiates new communication) and the concerns of the end user. The most egregious privacy concerns appear to involve addresses used for long periods of time (weeks to months to years). The more frequently an address changes, the less feasible collecting or coordinating information keyed on interface identifiers becomes. Moreover, the cost of collecting information and attempting to correlate it based on interface identifiers will only be justified if enough addresses contain non-changing identifiers to make it worthwhile. Thus, having large numbers of clients change their address on a daily or weekly basis is likely to be sufficient to alleviate most privacy concerns.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
临时地址更改的频率取决于设备的使用方式（例如，它启动新通信的频率）和最终用户的关注点。最令人震惊的隐私问题似乎涉及长时间（数周到数月到数年）使用的地址。地址更改越频繁，收集或协调接口标识符上键入的信息就越不可行。此外，只有当足够多的地址包含不变的标识符，使信息变得有价值时，收集信息并尝试基于接口标识符将其关联起来的成本才是合理的。因此，让大量客户每天或每周更改地址可能足以缓解大多数隐私问题。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
There are also client costs associated with having a large number of addresses associated with a node (e.g., in doing address lookups, the need to join many multicast groups, etc.). Thus, changing addresses frequently (e.g., every few minutes) may have performance implications.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
还有与具有大量与节点相关联的地址相关联的客户端成本（例如，在进行地址查找时，需要加入许多多播组等）。因此，频繁更改地址（例如，每隔几分钟）可能会影响性能。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Nodes following this specification SHOULD generate new temporary addresses on a periodic basis. This can be achieved automatically by generating a new randomized interface identifier at least once every (TEMP_PREFERRED_LIFETIME - REGEN_ADVANCE - DESYNC_FACTOR) time units. As described above, generating a new temporary address REGEN_ADVANCE time units before a temporary address becomes deprecated produces addresses with a preferred lifetime no larger than TEMP_PREFERRED_LIFETIME. The value DESYNC_FACTOR is a random value (different for each client) that ensures that clients don&#39;t synchronize with each other and generate new addresses at exactly the same time. When the preferred lifetime expires, a new temporary address MUST be generated using the new randomized interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
遵循此规范的节点应定期生成新的临时地址。这可以通过至少每一个时间单位生成一个新的随机接口标识符（TEMP_PREFERRED_LIFETIME-REGEN_ADVANCE-DESYNC_FACTOR）自动实现。如上所述，在临时地址不推荐使用之前生成新的临时地址REGEN_ADVANCE time units会生成首选生存期不大于TEMP_首选生存期的地址。值DESYNC_因子是一个随机值（每个客户机不同），它确保客户机不会彼此同步并在完全相同的时间生成新地址。当首选生存期到期时，必须使用新的随机接口标识符生成新的临时地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Because the precise frequency at which it is appropriate to generate new addresses varies from one environment to another, implementations SHOULD provide end users with the ability to change the frequency at which addresses are regenerated. The default value is given in TEMP_PREFERRED_LIFETIME and is one day. In addition, the exact time at which to invalidate a temporary address depends on how applications are used by end users. Thus, the suggested default value of one week (TEMP_VALID_LIFETIME) may not be appropriate in all environments. Implementations SHOULD provide end users with the ability to override both of these default values.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
由于生成新地址的准确频率因环境而异，因此实现应使最终用户能够更改重新生成地址的频率。默认值在TEMP_PREFERRED_LIFETIME中给出，为一天。此外，使临时地址无效的确切时间取决于最终用户如何使用应用程序。因此，建议的默认值一周（TEMP_VALID_life）可能并不适用于所有环境。实现应该为最终用户提供覆盖这两个默认值的能力。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Finally, when an interface connects to a new link, a new randomized interface identifier SHOULD be generated immediately together with a new set of temporary addresses. If a device moves from one ethernet to another, generating a new set of temporary addresses from a different randomized interface identifier ensures that the device uses different randomized interface identifiers for the temporary addresses associated with the two links, making it more difficult to correlate addresses from the two different links as being from the same node. The node MAY follow any process available to it, to determine that the link change has occurred. One such process is described by Detecting Network Attachment [DNA].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最后，当接口连接到新链接时，应立即生成新的随机接口标识符和一组新的临时地址。如果设备从一个以太网移动到另一个以太网，则从不同的随机接口标识符生成一组新的临时地址可确保设备对与两个链路相关联的临时地址使用不同的随机接口标识符，这使得将来自两个不同链路的地址关联为来自同一节点的地址变得更加困难。节点可以遵循其可用的任何过程，以确定链路更改已经发生。一个这样的过程是通过检测网络连接[DNA]来描述的。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. Deployment Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
3.6. 部署注意事项
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Devices implementing this specification MUST provide a way for the end user to explicitly enable or disable the use of temporary addresses. In addition, a site might wish to disable the use of temporary addresses in order to simplify network debugging and operations. Consequently, implementations SHOULD provide a way for trusted system administrators to enable or disable the use of temporary addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现本规范的设备必须为最终用户提供明确启用或禁用临时地址的方法。此外，站点可能希望禁用临时地址的使用，以简化网络调试和操作。因此，实现应该为受信任的系统管理员提供一种启用或禁用临时地址的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Additionally, sites might wish to selectively enable or disable the use of temporary addresses for some prefixes. For example, a site might wish to disable temporary address generation for &#34;Unique local&#34; [ULA] prefixes while still generating temporary addresses for all other global prefixes. Another site might wish to enable temporary address generation only for the prefixes 2001::/16 and 2002::/16, while disabling it for all other prefixes. To support this behavior, implementations SHOULD provide a way to enable and disable generation of temporary addresses for specific prefix subranges. This per-prefix setting SHOULD override the global settings on the node with respect to the specified prefix subranges. Note that the pre-prefix setting can be applied at any granularity, and not necessarily on a per-subnet basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
此外，站点可能希望有选择地启用或禁用某些前缀的临时地址。例如，站点可能希望禁用“唯一本地”[ULA]前缀的临时地址生成，同时仍为所有其他全局前缀生成临时地址。另一个站点可能希望仅为前缀2001:：/16和2002:：/16启用临时地址生成，而对所有其他前缀禁用临时地址生成。为了支持这种行为，实现应该提供一种方法来启用和禁用为特定前缀子范围生成临时地址。此每前缀设置应覆盖节点上有关指定前缀子范围的全局设置。请注意，预前缀设置可以在任何粒度上应用，而不一定是在每个子网的基础上应用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The use of temporary addresses may cause unexpected difficulties with some applications. As described below, some servers refuse to accept communications from clients for which they cannot map the IP address into a DNS name. In addition, some applications may not behave robustly if temporary addresses are used and an address expires before the application has terminated, or if it opens multiple sessions, but expects them to all use the same addresses. Consequently, the use of temporary addresses SHOULD be disabled by default in order to minimize potential disruptions. Individual applications, which have specific knowledge about the normal duration of connections, MAY override this as appropriate.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用临时地址可能会在某些应用程序中造成意外困难。如下所述，一些服务器拒绝接受来自客户端的通信，因为它们无法将IP地址映射到DNS名称。此外，如果使用了临时地址，并且某个地址在应用程序终止之前过期，或者如果它打开多个会话，但希望它们都使用相同的地址，则某些应用程序的行为可能不稳定。因此，默认情况下应禁用临时地址的使用，以尽量减少潜在的中断。对正常连接持续时间有特定了解的单个应用程序可能会在适当的情况下覆盖此设置。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
If a very small number of nodes (say, only one) use a given prefix for extended periods of time, just changing the interface identifier part of the address may not be sufficient to ensure privacy, since the prefix acts as a constant identifier. The procedures described in this document are most effective when the prefix is reasonably non static or is used by a fairly large number of nodes.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
如果极少数节点（例如，只有一个节点）长时间使用给定前缀，那么仅仅更改地址的接口标识符部分可能不足以确保隐私，因为前缀充当恒定标识符。当前缀是合理的非静态前缀或被相当多的节点使用时，本文档中描述的过程最为有效。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. Implications of Changing Interface Identifiers
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
4. 更改接口标识符的含义
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IPv6 addressing architecture goes to some lengths to ensure that interface identifiers are likely to be globally unique where easy to do so. The widespread use of temporary addresses may result in a significant fraction of Internet traffic not using addresses in which the interface identifier portion is globally unique. Consequently, usage of the algorithms in this document may complicate providing such a future flexibility, if global uniqueness is necessary.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IPv6寻址体系结构在一定程度上确保了接口标识符在容易做到的地方可能是全局唯一的。临时地址的广泛使用可能导致很大一部分互联网流量不使用接口标识符部分全局唯一的地址。因此，若需要全局唯一性，本文档中算法的使用可能会使提供这种未来灵活性变得复杂。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The desires of protecting individual privacy versus the desire to effectively maintain and debug a network can conflict with each other. Having clients use addresses that change over time will make it more difficult to track down and isolate operational problems. For example, when looking at packet traces, it could become more difficult to determine whether one is seeing behavior caused by a single errant machine, or by a number of them.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
保护个人隐私的愿望与有效维护和调试网络的愿望可能相互冲突。让客户机使用随时间变化的地址将使跟踪和隔离操作问题变得更加困难。例如，当查看数据包跟踪时，确定一个人看到的行为是由一台出错的机器引起的，还是由多台机器引起的，可能会变得更加困难。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Some servers refuse to grant access to clients for which no DNS name exists. That is, they perform a DNS PTR query to determine the DNS name, and may then also perform an AAAA query on the returned name to verify that the returned DNS name maps back into the address being used. Consequently, clients not properly registered in the DNS may be unable to access some services. As noted earlier, however, a node&#39;s DNS name (if non-changing) serves as a constant identifier. The wide deployment of the extension described in this document could challenge the practice of inverse-DNS-based &#34;authentication,&#34; which has little validity, though it is widely implemented. In order to meet server challenges, nodes could register temporary addresses in the DNS using random names (for example, a string version of the random address itself).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
某些服务器拒绝向不存在DNS名称的客户端授予访问权限。也就是说，它们执行DNS PTR查询以确定DNS名称，然后还可以对返回的名称执行AAAA查询以验证返回的DNS名称映射回正在使用的地址。因此，未在DNS中正确注册的客户端可能无法访问某些服务。但是，如前所述，节点的DNS名称（如果不更改）用作常量标识符。本文档中描述的扩展的广泛部署可能会挑战基于DNS的反向“身份验证”的实践，该实践的有效性很低，尽管它已被广泛实施。为了应对服务器挑战，节点可以使用随机名称（例如，随机地址本身的字符串版本）在DNS中注册临时地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Use of the extensions defined in this document may complicate debugging and other operational troubleshooting activities. Consequently, it may be site policy that temporary addresses should not be used. Consequently, implementations MUST provide a method for the end user or trusted administrator to override the use of temporary addresses.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
使用本文档中定义的扩展可能会使调试和其他操作故障排除活动复杂化。因此，不应使用临时地址可能是现场政策。因此，实现必须为最终用户或受信任的管理员提供覆盖临时地址使用的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. Defined Constants
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
5. 定义常数
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Constants defined in this document include:
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件中定义的常量包括：
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_VALID_LIFETIME -- Default value: 1 week. Users should be able to override the default value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
临时有效生命周期--默认值：1周。用户应该能够覆盖默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_PREFERRED_LIFETIME -- Default value: 1 day. Users should be able to override the default value.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_PREFERRED_LIFETIME--默认值：1天。用户应该能够覆盖默认值。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
REGEN_ADVANCE -- 5 seconds
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
恢复前进——5秒
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
MAX_DESYNC_FACTOR -- 10 minutes. Upper bound on DESYNC_FACTOR.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
最大失同步系数——10分钟。失同步因子的上界。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
DESYNC_FACTOR -- A random value within the range 0 - MAX_DESYNC_FACTOR. It is computed once at system start (rather than each time it is used) and must never be greater than (TEMP_VALID_LIFETIME - REGEN_ADVANCE).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
失同步系数——0-最大失同步系数范围内的随机值。它在系统启动时计算一次（而不是每次使用时），并且不得大于（临时有效寿命-重新生成提前）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP_IDGEN_RETRIES -- Default value: 3
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
TEMP\u IDGEN\u重试次数--默认值：3
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. Future Work
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
6. 今后的工作
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
An implementation might want to keep track of which addresses are being used by upper layers so as to be able to remove a deprecated temporary address from internal data structures once no upper layer protocols are using it (but not before). This is in contrast to current approaches where addresses are removed from an interface when they become invalid [ADDRCONF], independent of whether or not upper layer protocols are still using them. For TCP connections, such information is available in control blocks. For UDP-based applications, it may be the case that only the applications have knowledge about what addresses are actually in use. Consequently, an implementation generally will need to use heuristics in deciding when an address is no longer in use.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
实现可能希望跟踪上层使用的地址，以便在没有上层协议使用临时地址时（但在此之前），能够从内部数据结构中删除不推荐使用的临时地址。这与当前的方法不同，当前的方法是当地址变为无效[ADDRCONF]时从接口中删除地址，这与上层协议是否仍在使用地址无关。对于TCP连接，此类信息在控制块中可用。对于基于UDP的应用程序，可能只有应用程序才知道实际使用的地址。因此，实现通常需要使用启发式方法来确定地址何时不再使用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The determination as to whether to use public versus temporary addresses can in some cases only be made by an application. For example, some applications may always want to use temporary addresses, while others may want to use them only in some circumstances or not at all. Suitable API extensions will likely need to be developed to enable individual applications to indicate with sufficient granularity their needs with regards to the use of temporary addresses. Recommendations on DNS practices to avoid the problem described in Section 4 when reverse DNS lookups fail may be needed. [DNSOP] contains a more detailed discussion of the DNS-related issues.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
在某些情况下，只能通过应用程序确定是否使用公共地址或临时地址。例如，一些应用程序可能总是希望使用临时地址，而其他应用程序可能只希望在某些情况下使用临时地址，或者根本不使用临时地址。可能需要开发合适的API扩展，以使各个应用程序能够以足够的粒度表示其对临时地址使用的需求。当反向DNS查找失败时，可能需要有关DNS实践的建议，以避免第4节中描述的问题。[DNSOP]包含有关DNS相关问题的更详细讨论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
While this document discusses ways of obscuring a user&#39;s permanent IP address, the method described is believed to be ineffective against sophisticated forms of traffic analysis. To increase effectiveness, one may need to consider use of more advanced techniques, such as Onion Routing [ONION].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
虽然本文档讨论了隐藏用户永久IP地址的方法，但所述方法被认为对复杂形式的流量分析无效。为了提高效力，人们可能需要考虑使用更先进的技术，如洋葱路由[洋葱]。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. Security Considerations
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
7. 安全考虑
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Ingress filtering has been and is being deployed as a means of preventing the use of spoofed source addresses in Distributed Denial of Service (DDoS) attacks. In a network with a large number of nodes, new temporary addresses are created at a fairly high rate. This might make it difficult for ingress filtering mechanisms to distinguish between legitimately changing temporary addresses and spoofed source addresses, which are &#34;in-prefix&#34; (using a topologically correct prefix and non-existent interface ID). This can be addressed by using access control mechanisms on a per-address basis on the network egress point.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
入口过滤已经并正在被部署为防止在分布式拒绝服务（DDoS）攻击中使用伪造源地址的一种手段。在具有大量节点的网络中，以相当高的速率创建新的临时地址。这可能使入口过滤机制难以区分合法更改的临时地址和伪造的源地址，它们是“前缀中”（使用拓扑正确的前缀和不存在的接口ID）。这可以通过在网络出口点上使用基于每个地址的访问控制机制来解决。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. Significant Changes from RFC 3041
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
8. RFC 3041的重大变化
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This section summarizes the changes in this document relative to RFC 3041 that an implementer of RFC 3041 should be aware of.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本节总结了本文档中与RFC 3041相关的变更，RFC 3041的实施者应该了解这些变更。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. Excluded certain interface identifiers from the range of acceptable interface identifiers. Interface IDs such as those for reserved anycast addresses [RFC2526], etc.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
1. 将某些接口标识符从可接受的接口标识符范围中排除。接口ID，如保留选播地址[RFC2526]的ID等。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. Added a configuration knob that provides the end user with a way to enable or disable the use of temporary addresses on a per-prefix basis.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
2. 添加了一个配置旋钮，该旋钮为最终用户提供了一种基于每个前缀启用或禁用临时地址的方法。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. Added a check for denial of service attacks using low valid lifetimes in router advertisements.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
3. 添加了使用路由器广告中的低有效生存期检查拒绝服务攻击。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. DAD is now run on all temporary addresses, not just the first one generated from an interface identifier.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
4. DAD现在在所有临时地址上运行，而不仅仅是从接口标识符生成的第一个临时地址。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. Changed the default setting for usage of temporary addresses to be disabled.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
5. 将临时地址使用的默认设置更改为禁用。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. The node is now allowed to generate different interface identifiers for different prefixes, if it so desires.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
6. 如果需要，现在允许节点为不同的前缀生成不同的接口标识符。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. The algorithm used for generating random interface identifiers is no longer restricted to just MD5.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
7. 用于生成随机接口标识符的算法不再局限于MD5。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. Reduced default number of retries to 3 and added a configuration variable.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
8. 将默认重试次数减少到3次，并添加了一个配置变量。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. Router advertisement (RA) processing algorithm is no longer included in the document, and is replaced by a reference to [ADDRCONF].
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
9. 路由器广告（RA）处理算法不再包含在文档中，并由对[ADDRCONF]的引用代替。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. Acknowledgments
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
9. 致谢
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rich Draves and Thomas Narten were the authors of RFC 3041. They would like to acknowledge the contributions of the ipv6 working group and, in particular, Ran Atkinson, Matt Crawford, Steve Deering, Allison Mankin, and Peter Bieringer.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Rich Draves和Thomas Narten是RFC 3041的作者。他们要感谢ipv6工作组的贡献，特别是Atkinson、Matt Crawford、Steve Deering、Allison Mankin和Peter Bieringer。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suresh Krishnan was the sole author of this version of the document. He would like to acknowledge the contributions of the ipv6 working group and, in particular, Jari Arkko, Pekka Nikander, Pekka Savola, Francis Dupont, Brian Haberman, Tatuya Jinmei, and Margaret Wasserman for their detailed comments.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suresh Krishnan是该版本文件的唯一作者。他要感谢ipv6工作组的贡献，特别是Jari Arkko、Pekka Nikander、Pekka Savola、Francis Dupont、Brian Haberman、Tatuya Jinmei和Margaret Wasserman的详细评论。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10. 工具书类
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. Normative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.1. 规范性引用文件
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRARCH] Hinden, R. and S. Deering, &#34;IP Version 6 Addressing Architecture&#34;, RFC 4291, February 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRARCH]Hinden，R.和S.Deering，“IP版本6寻址体系结构”，RFC 42912006年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRCONF] Thomson, S., Narten, T., and T. Jinmei, &#34;IPv6 Stateless Address Autoconfiguration&#34;, RFC 4862, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDRCONF]Thomson，S.，Narten，T.，和T.Jinmei，“IPv6无状态地址自动配置”，RFC 48622007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DISCOVERY] Narten, T., Nordmark, E., Simpson, W., and H. Soliman, &#34;Neighbor Discovery for IP version 6 (IPv6)&#34;, RFC 4861, September 2007.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[发现]Narten，T.，Nordmark，E.，Simpson，W.，和H.Soliman，“IP版本6（IPv6）的邻居发现”，RFC 48612007年9月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5] Rivest, R., &#34;The MD5 Message-Digest Algorithm&#34;, RFC 1321, April 1992.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[MD5]Rivest，R.，“MD5消息摘要算法”，RFC 13211992年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119] Bradner, S., &#34;Key words for use in RFCs to Indicate Requirement Levels&#34;, RFC 2119, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2119]Bradner，S.，“RFC中用于表示需求水平的关键词”，RFC 211997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. Informative References
        </h5>
      </div>
      <div class="col-sm-12 col-md-6">
        <h5 class="text mt-2">
10.2. 资料性引用
        </h5>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDR_SELECT] Draves, R., &#34;Default Address Selection for Internet Protocol version 6 (IPv6)&#34;, RFC 3484, February 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ADDR_SELECT]Draves，R.，“互联网协议版本6（IPv6）的默认地址选择”，RFC 3484，2003年2月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CGA] Aura, T., &#34;Cryptographically Generated Addresses (CGA)&#34;, RFC 3972, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[CGA]Aura，T.，“加密生成地址（CGA）”，RFC 39722005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COOKIES] Kristol, D. and L. Montulli, &#34;HTTP State Management Mechanism&#34;, RFC 2965, October 2000.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[COOKIES]Kristol，D.和L.Montulli，“HTTP状态管理机制”，RFC 29652000年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DDNS] Vixie, P., Thomson, S., Rekhter, Y., and J. Bound, &#34;Dynamic Updates in the Domain Name System (DNS UPDATE)&#34;, RFC 2136, April 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DDNS]Vixie，P.，Thomson，S.，Rekhter，Y.，和J.Bound，“域名系统中的动态更新（DNS更新）”，RFC 21361997年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHCP] Droms, R., &#34;Dynamic Host Configuration Protocol&#34;, RFC 2131, March 1997.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHCP]Droms，R.，“动态主机配置协议”，RFC 21311997年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHCPV6] Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, &#34;Dynamic Host Configuration Protocol for IPv6 (DHCPv6)&#34;, RFC 3315, July 2003.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DHCPV6]Droms，R.，Bound，J.，Volz，B.，Lemon，T.，Perkins，C.，和M.Carney，“IPv6的动态主机配置协议（DHCPV6）”，RFC 33151003年7月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNA] Choi, JH. and G. Daley, &#34;Goals of Detecting Network Attachment in IPv6&#34;, RFC 4135, August 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNA]Choi，JH。和G.Daley，“在IPv6中检测网络连接的目标”，RFC 41352005年8月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSOP] Durand, A., Ihren, J., and P. Savola, &#34;Operational Considerations and Issues with IPv6 DNS&#34;, RFC 4472, April 2006.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[DNSOP]Durand，A.，Ihren，J.，和P.Savola，“IPv6 DNS的操作注意事项和问题”，RFC 4472，2006年4月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ONION] Reed, MGR., Syverson, PFS., and DMG. Goldschlag, &#34;Proxies for Anonymous Routing&#34;, Proceedings of the 12th Annual Computer Security Applications Conference, San Diego, CA, December 1996.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[洋葱]里德，经理，西弗森，PFS和DMG。Goldschlag，“匿名路由代理”，第12届计算机安全应用年会论文集，加利福尼亚州圣地亚哥，1996年12月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RANDOM] Eastlake, D., Schiller, J., and S. Crocker, &#34;Randomness Requirements for Security&#34;, BCP 106, RFC 4086, June 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[随机]Eastlake，D.，Schiller，J.，和S.Crocker，“安全的随机性要求”，BCP 106，RFC 40862005年6月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2526] Johnson, D. and S. Deering, &#34;Reserved IPv6 Subnet Anycast Addresses&#34;, RFC 2526, March 1999.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[RFC2526]Johnson，D.和S.Deering，“保留的IPv6子网选播地址”，RFC 25261999年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[SEND] Arkko, J., Kempf, J., Zill, B., and P. Nikander, &#34;SEcure Neighbor Discovery (SEND)&#34;, RFC 3971, March 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[发送]Arkko，J.，Kempf，J.，Zill，B.，和P.Nikander，“安全邻居发现（发送）”，RFC 39712005年3月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ULA] Hinden, R. and B. Haberman, &#34;Unique Local IPv6 Unicast Addresses&#34;, RFC 4193, October 2005.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
[ULA]Hinden，R.和B.Haberman，“唯一本地IPv6单播地址”，RFC 41932005年10月。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Authors&#39; Addresses
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
作者地址
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Narten IBM Corporation P.O. Box 12195 Research Triangle Park, NC USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Thomas Narten IBM Corporation美国北卡罗来纳州三角研究园12195号邮政信箱
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: narten@us.ibm.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: narten@us.ibm.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard Draves Microsoft Research One Microsoft Way Redmond, WA USA
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Richard在美国华盛顿州雷德蒙市的微软研究中心工作
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: richdr@microsoft.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: richdr@microsoft.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Suresh Krishnan Ericsson Research 8400 Decarie Blvd. Town of Mount Royal, QC Canada
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
苏雷什·克里希南·爱立信研究院，德卡里大道8400号。加拿大皇家山镇
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: suresh.krishnan@ericsson.com
        </pre>
      </div>
      <div class="col-sm-12 col-md-6">
        <pre class="text text-monospace">
   EMail: suresh.krishnan@ericsson.com
        </pre>
      </div>

    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Full Copyright Statement
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
完整版权声明
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copyright (C) The IETF Trust (2007).
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
版权所有（C）IETF信托基金（2007年）。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件受BCP 78中包含的权利、许可和限制的约束，除其中规定外，作者保留其所有权利。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
This document and the information contained herein are provided on an &#34;AS IS&#34; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
本文件及其包含的信息以“原样”为基础提供，贡献者、他/她所代表或赞助的组织（如有）、互联网协会、IETF信托基金和互联网工程任务组不承担任何明示或暗示的担保，包括但不限于任何保证，即使用本文中的信息不会侵犯任何权利，或对适销性或特定用途适用性的任何默示保证。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
Intellectual Property
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-0">
知识产权
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF对可能声称与本文件所述技术的实施或使用有关的任何知识产权或其他权利的有效性或范围，或此类权利下的任何许可可能或可能不可用的程度，不采取任何立场；它也不表示它已作出任何独立努力来确定任何此类权利。有关RFC文件中权利的程序信息，请参见BCP 78和BCP 79。
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
向IETF秘书处披露的知识产权副本和任何许可证保证，或本规范实施者或用户试图获得使用此类专有权利的一般许可证或许可的结果，可从IETF在线知识产权存储库获取，网址为http://www.ietf.org/ipr.
        </p>
      </div>
    </div>
    <div class="row">
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.
        </p>
      </div>
      <div class="col-sm-12 col-md-6">
        <p class="text indent-3">
IETF邀请任何相关方提请其注意任何版权、专利或专利申请，或其他可能涵盖实施本标准所需技术的专有权利。请将信息发送至IETF的IETF-ipr@ietf.org.
        </p>
      </div>
    </div>
  </div>
  <div id="rfc_footer"></div>
</body>
</html>
