{
  "title": {
    "text": "RFC 6458: Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)",
    "zh-CHS": "RFC 6458"
  },
  "number": 6458,
  "created_at": "2021-11-06 11:55:55.729295+08:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        R. Stewart\nRequest for Comments: 6458                                Adara Networks\nCategory: Informational                                        M. Tuexen\nISSN: 2070-1721                         Muenster Univ. of Appl. Sciences\n                                                                 K. Poon\n                                                      Oracle Corporation\n                                                                  P. Lei\n                                                     Cisco Systems, Inc.\n                                                             V. Yasevich\n                                                                      HP\n                                                           December 2011",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 10,
      "text": " Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)",
      "zh-CHS": "流控制传输协议（SCTP）的套接字API扩展"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "zh-CHS": "摘要"
    },
    {
      "indent": 3,
      "text": "This document describes a mapping of the Stream Control Transmission Protocol (SCTP) into a sockets API. The benefits of this mapping include compatibility for TCP applications, access to new SCTP features, and a consolidated error and event notification scheme.",
      "zh-CHS": "本文档描述了流控制传输协议（SCTP）到套接字API的映射。这种映射的好处包括对TCP应用程序的兼容性、对新SCTP功能的访问以及一个统一的错误和事件通知方案。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "zh-CHS": "关于下段备忘"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "zh-CHS": "本文件不是互联网标准跟踪规范；它是为了提供信息而发布的。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "zh-CHS": "本文件是互联网工程任务组（IETF）的产品。它代表了IETF社区的共识。它已经接受了公众审查，并已被互联网工程指导小组（IESG）批准出版。并非IESG批准的所有文件都适用于任何级别的互联网标准；见RFC 5741第2节。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6458.",
      "zh-CHS": "有关本文件当前状态、任何勘误表以及如何提供反馈的信息，请访问http://www.rfc-editor.org/info/rfc6458."
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "zh-CHS": "版权公告"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "zh-CHS": "版权所有（c）2011 IETF信托基金和确定为文件作者的人员。版权所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "zh-CHS": "本文件受BCP 78和IETF信托有关IETF文件的法律规定的约束(http://trustee.ietf.org/license-info)自本文件出版之日起生效。请仔细阅读这些文件，因为它们描述了您对本文件的权利和限制。从本文件中提取的代码组件必须包括信托法律条款第4.e节中所述的简化BSD许可证文本，并提供简化BSD许可证中所述的无担保。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "zh-CHS": "本文件可能包含2008年11月10日之前发布或公开的IETF文件或IETF贡献中的材料。控制某些材料版权的人员可能未授予IETF信托允许在IETF标准流程之外修改此类材料的权利。在未从控制此类材料版权的人员处获得充分许可的情况下，不得在IETF标准流程之外修改本文件，也不得在IETF标准流程之外创建其衍生作品，除了将其格式化以RFC形式发布或将其翻译成英语以外的其他语言。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "zh-CHS": "目录"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................6\n2. Data Types ......................................................8\n3. One-to-Many Style Interface .....................................8\n   3.1. Basic Operation ............................................8\n        3.1.1. socket() ............................................9\n        3.1.2. bind() .............................................10\n        3.1.3. listen() ...........................................11\n        3.1.4. sendmsg() and recvmsg() ............................12\n        3.1.5. close() ............................................14\n        3.1.6. connect() ..........................................14\n   3.2. Non-Blocking Mode .........................................15\n   3.3. Special Considerations ....................................16\n4. One-to-One Style Interface .....................................18\n   4.1. Basic Operation ...........................................18\n        4.1.1. socket() ...........................................19\n        4.1.2. bind() .............................................19\n        4.1.3. listen() ...........................................21\n        4.1.4. accept() ...........................................21\n        4.1.5. connect() ..........................................22\n        4.1.6. close() ............................................23\n        4.1.7. shutdown() .........................................23\n        4.1.8. sendmsg() and recvmsg() ............................24\n        4.1.9. getpeername() ......................................24\n5. Data Structures ................................................25\n   5.1. The msghdr and cmsghdr Structures .........................25\n   5.2. Ancillary Data Considerations and Semantics ...............26\n        5.2.1. Multiple Items and Ordering ........................27\n        5.2.2. Accessing and Manipulating Ancillary Data ..........27\n        5.2.3. Control Message Buffer Sizing ......................28\n   5.3. SCTP msg_control Structures ...............................28\n        5.3.1. SCTP Initiation Structure (SCTP_INIT) ..............29\n        5.3.2. SCTP Header Information Structure\n               (SCTP_SNDRCV) - DEPRECATED .........................30\n        5.3.3. Extended SCTP Header Information Structure\n               (SCTP_EXTRCV) - DEPRECATED .........................33\n        5.3.4. SCTP Send Information Structure (SCTP_SNDINFO) .....35\n        5.3.5. SCTP Receive Information Structure (SCTP_RCVINFO) ..37\n        5.3.6. SCTP Next Receive Information Structure\n               (SCTP_NXTINFO) .....................................38\n        5.3.7. SCTP PR-SCTP Information Structure (SCTP_PRINFO) ...39\n        5.3.8. SCTP AUTH Information Structure (SCTP_AUTHINFO) ....40\n        5.3.9. SCTP Destination IPv4 Address Structure\n               (SCTP_DSTADDRV4) ...................................41\n        5.3.10. SCTP Destination IPv6 Address Structure\n                (SCTP_DSTADDRV6) ..................................41",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "6. SCTP Events and Notifications ..................................41\n   6.1. SCTP Notification Structure ...............................42\n        6.1.1. SCTP_ASSOC_CHANGE ..................................43\n        6.1.2. SCTP_PEER_ADDR_CHANGE ..............................45\n        6.1.3. SCTP_REMOTE_ERROR ..................................46\n        6.1.4. SCTP_SEND_FAILED - DEPRECATED ......................47\n        6.1.5. SCTP_SHUTDOWN_EVENT ................................48\n        6.1.6. SCTP_ADAPTATION_INDICATION .........................49\n        6.1.7. SCTP_PARTIAL_DELIVERY_EVENT ........................49\n        6.1.8. SCTP_AUTHENTICATION_EVENT ..........................50\n        6.1.9. SCTP_SENDER_DRY_EVENT ..............................51\n        6.1.10. SCTP_NOTIFICATIONS_STOPPED_EVENT ..................52\n        6.1.11. SCTP_SEND_FAILED_EVENT ............................52\n   6.2. Notification Interest Options .............................54\n        6.2.1. SCTP_EVENTS Option - DEPRECATED ....................54\n        6.2.2. SCTP_EVENT Option ..................................56\n7. Common Operations for Both Styles ..............................57\n   7.1. send(), recv(), sendto(), and recvfrom() ..................57\n   7.2. setsockopt() and getsockopt() .............................59\n   7.3. read() and write() ........................................60\n   7.4. getsockname() .............................................60\n   7.5. Implicit Association Setup ................................61\n8. Socket Options .................................................61\n   8.1. Read/Write Options ........................................63\n        8.1.1. Retransmission Timeout Parameters (SCTP_RTOINFO) ...63\n        8.1.2. Association Parameters (SCTP_ASSOCINFO) ............64\n        8.1.3. Initialization Parameters (SCTP_INITMSG) ...........66\n        8.1.4. SO_LINGER ..........................................66\n        8.1.5. SCTP_NODELAY .......................................66\n        8.1.6. SO_RCVBUF ..........................................67\n        8.1.7. SO_SNDBUF ..........................................67\n        8.1.8. Automatic Close of Associations (SCTP_AUTOCLOSE) ...67\n        8.1.9. Set Primary Address (SCTP_PRIMARY_ADDR) ............68\n        8.1.10. Set Adaptation Layer Indicator\n                (SCTP_ADAPTATION_LAYER) ...........................68\n        8.1.11. Enable/Disable Message Fragmentation\n                (SCTP_DISABLE_FRAGMENTS) ..........................68\n        8.1.12. Peer Address Parameters (SCTP_PEER_ADDR_PARAMS) ...69\n        8.1.13. Set Default Send Parameters\n                (SCTP_DEFAULT_SEND_PARAM) - DEPRECATED ............71\n        8.1.14. Set Notification and Ancillary Events\n                (SCTP_EVENTS) - DEPRECATED ........................72\n        8.1.15. Set/Clear IPv4 Mapped Addresses\n                (SCTP_I_WANT_MAPPED_V4_ADDR) ......................72\n        8.1.16. Get or Set the Maximum Fragmentation Size\n                (SCTP_MAXSEG) .....................................72\n        8.1.17. Get or Set the List of Supported HMAC\n                Identifiers (SCTP_HMAC_IDENT) .....................73",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "     8.1.18. Get or Set the Active Shared Key\n             (SCTP_AUTH_ACTIVE_KEY) ............................74\n     8.1.19. Get or Set Delayed SACK Timer\n             (SCTP_DELAYED_SACK) ...............................74\n     8.1.20. Get or Set Fragmented Interleave\n             (SCTP_FRAGMENT_INTERLEAVE) ........................75\n     8.1.21. Set or Get the SCTP Partial Delivery Point\n             (SCTP_PARTIAL_DELIVERY_POINT) .....................77\n     8.1.22. Set or Get the Use of Extended Receive Info\n             (SCTP_USE_EXT_RCVINFO) - DEPRECATED ...............77\n     8.1.23. Set or Get the Auto ASCONF Flag\n             (SCTP_AUTO_ASCONF) ................................77\n     8.1.24. Set or Get the Maximum Burst (SCTP_MAX_BURST) .....78\n     8.1.25. Set or Get the Default Context (SCTP_CONTEXT) .....78\n     8.1.26. Enable or Disable Explicit EOR Marking\n             (SCTP_EXPLICIT_EOR) ...............................79\n     8.1.27. Enable SCTP Port Reusage (SCTP_REUSE_PORT) ........79\n     8.1.28. Set Notification Event (SCTP_EVENT) ...............79\n     8.1.29. Enable or Disable the Delivery of SCTP_RCVINFO\n             as Ancillary Data (SCTP_RECVRCVINFO) ..............79\n     8.1.30. Enable or Disable the Delivery of SCTP_NXTINFO\n             as Ancillary Data (SCTP_RECVNXTINFO) ..............80\n     8.1.31. Set Default Send Parameters\n             (SCTP_DEFAULT_SNDINFO) ............................80\n     8.1.32. Set Default PR-SCTP Parameters\n             (SCTP_DEFAULT_PRINFO) .............................80\n8.2. Read-Only Options .........................................81\n     8.2.1. Association Status (SCTP_STATUS) ...................81\n     8.2.2. Peer Address Information\n            (SCTP_GET_PEER_ADDR_INFO) ..........................82\n     8.2.3. Get the List of Chunks the Peer Requires to\n            Be Authenticated (SCTP_PEER_AUTH_CHUNKS) ...........84\n     8.2.4. Get the List of Chunks the Local Endpoint Requires\n            to Be Authenticated (SCTP_LOCAL_AUTH_CHUNKS) .......84\n     8.2.5. Get the Current Number of Associations\n            (SCTP_GET_ASSOC_NUMBER) ............................85\n     8.2.6. Get the Current Identifiers of Associations\n            (SCTP_GET_ASSOC_ID_LIST) ...........................85\n8.3. Write-Only Options ........................................85\n     8.3.1. Set Peer Primary Address\n            (SCTP_SET_PEER_PRIMARY_ADDR) .......................86\n     8.3.2. Add a Chunk That Must Be Authenticated\n            (SCTP_AUTH_CHUNK) ..................................86\n     8.3.3. Set a Shared Key (SCTP_AUTH_KEY) ...................86\n     8.3.4. Deactivate a Shared Key\n            (SCTP_AUTH_DEACTIVATE_KEY) .........................87\n     8.3.5. Delete a Shared Key (SCTP_AUTH_DELETE_KEY) .........88",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "9. New Functions ..................................................88\n   9.1. sctp_bindx() ..............................................88\n   9.2. sctp_peeloff() ............................................90\n   9.3. sctp_getpaddrs() ..........................................91\n   9.4. sctp_freepaddrs() .........................................92\n   9.5. sctp_getladdrs() ..........................................92\n   9.6. sctp_freeladdrs() .........................................93\n   9.7. sctp_sendmsg() - DEPRECATED ...............................93\n   9.8. sctp_recvmsg() - DEPRECATED ...............................94\n   9.9. sctp_connectx() ...........................................95\n   9.10. sctp_send() - DEPRECATED .................................96\n   9.11. sctp_sendx() - DEPRECATED ................................97\n   9.12. sctp_sendv() .............................................98\n   9.13. sctp_recvv() ............................................101\n10. Security Considerations ......................................103\n11. Acknowledgments ..............................................103\n12. References ...................................................104\n   12.1. Normative References ....................................104\n   12.2. Informative References ..................................104\nAppendix A. Example Using One-to-One Style Sockets ...............106\nAppendix B. Example Using One-to-Many Style Sockets ..............109",
      "raw": true,
      "toc": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "zh-CHS": "1. 介绍"
    },
    {
      "indent": 3,
      "text": "The sockets API has provided a standard mapping of the Internet Protocol suite to many operating systems. Both TCP [RFC0793] and UDP [RFC0768] have benefited from this standard representation and access method across many diverse platforms. SCTP is a new protocol that provides many of the characteristics of TCP but also incorporates semantics more akin to UDP. This document defines a method to map the existing sockets API for use with SCTP, providing both a base for access to new features and compatibility so that most existing TCP applications can be migrated to SCTP with few (if any) changes.",
      "zh-CHS": "sockets API提供了Internet协议套件到许多操作系统的标准映射。TCP[RFC0793]和UDP[RFC0768]都受益于这种跨多种平台的标准表示和访问方法。SCTP是一种新的协议，它提供了TCP的许多特性，但也包含了更类似于UDP的语义。本文档定义了一种映射现有套接字API以用于SCTP的方法，为访问新功能和兼容性提供了基础，以便大多数现有TCP应用程序都可以迁移到SCTP，而只需很少（如果有）更改。"
    },
    {
      "indent": 3,
      "text": "There are three basic design objectives:",
      "zh-CHS": "有三个基本设计目标："
    },
    {
      "indent": 3,
      "text": "1. Maintain consistency with existing sockets APIs: We define a sockets mapping for SCTP that is consistent with other sockets API protocol mappings (for instance UDP, TCP, IPv4, and IPv6).",
      "zh-CHS": "1. 保持与现有套接字API的一致性：我们为SCTP定义了与其他套接字API协议映射（例如UDP、TCP、IPv4和IPv6）一致的套接字映射。"
    },
    {
      "indent": 3,
      "text": "2. Support a one-to-many style interface: This set of semantics is similar to that defined for connectionless protocols, such as UDP. A one-to-many style SCTP socket should be able to control multiple SCTP associations. This is similar to a UDP socket, which can communicate with many peer endpoints. Each of these associations is assigned an association identifier so that an",
      "zh-CHS": "2. 支持一对多风格的接口：这组语义类似于为无连接协议（如UDP）定义的语义。一对多样式的SCTP套接字应该能够控制多个SCTP关联。这类似于UDP套接字，它可以与许多对等端点通信。每个关联都分配了一个关联标识符，以便"
    },
    {
      "indent": 7,
      "text": "application can use the ID to differentiate them. Note that SCTP is connection-oriented in nature, and it does not support broadcast or multicast communications, as UDP does.",
      "zh-CHS": "应用程序可以使用ID来区分它们。请注意，SCTP本质上是面向连接的，它不支持广播或多播通信，就像UDP一样。"
    },
    {
      "indent": 3,
      "text": "3. Support a one-to-one style interface: This interface supports a similar semantics as sockets for connection-oriented protocols, such as TCP. A one-to-one style SCTP socket should only control one SCTP association. One purpose of defining this interface is to allow existing applications built on other connection-oriented protocols to be ported to use SCTP with very little effort. Developers familiar with these semantics can easily adapt to SCTP. Another purpose is to make sure that existing mechanisms in most operating systems that support sockets, such as select(), should continue to work with this style of socket. Extensions are added to this mapping to provide mechanisms to exploit new features of SCTP.",
      "zh-CHS": "3. 支持一对一风格的接口：该接口支持与面向连接的协议（如TCP）的套接字类似的语义。一对一样式的SCTP套接字应该只控制一个SCTP关联。定义此接口的一个目的是允许在其他面向连接的协议上构建的现有应用程序移植到使用SCTP而不费吹灰之力。熟悉这些语义的开发人员可以很容易地适应SCTP。另一个目的是确保大多数支持套接字的操作系统中的现有机制（如select（））应继续使用这种类型的套接字。此映射中添加了扩展，以提供利用SCTP新特性的机制。"
    },
    {
      "indent": 3,
      "text": "Goals 2 and 3 are not compatible, so this document defines two modes of mapping, namely the one-to-many style mapping and the one-to-one style mapping. These two modes share some common data structures and operations, but will require the use of two different application programming styles. Note that all new SCTP features can be used with both styles of socket. The decision on which one to use depends mainly on the nature of the applications.",
      "zh-CHS": "目标2和目标3不兼容，因此本文档定义了两种映射模式，即一对多样式映射和一对一样式映射。这两种模式共享一些常见的数据结构和操作，但需要使用两种不同的应用程序编程风格。请注意，所有新的SCTP功能都可以用于这两种类型的套接字。使用哪一个主要取决于应用程序的性质。"
    },
    {
      "indent": 3,
      "text": "A mechanism is defined to extract an SCTP association from a one-to-many style socket into a one-to-one style socket.",
      "zh-CHS": "定义了一种将SCTP关联从一对多样式套接字提取到一对一样式套接字的机制。"
    },
    {
      "indent": 3,
      "text": "Some of the SCTP mechanisms cannot be adequately mapped to an existing socket interface. In some cases, it is more desirable to have a new interface instead of using existing socket calls. Section 9 of this document describes these new interfaces.",
      "zh-CHS": "某些SCTP机制无法充分映射到现有套接字接口。在某些情况下，更希望有一个新的接口，而不是使用现有的套接字调用。本文件第9节描述了这些新接口。"
    },
    {
      "indent": 3,
      "text": "Please note that some elements of the SCTP sockets API are declared as deprecated. During the evolution of this document, elements of the API were introduced, implemented, and later on replaced by other elements. These replaced elements are declared as deprecated, since they are still available in some implementations and the replacement functions are not. This applies especially to older versions of operating systems supporting SCTP. New SCTP socket implementations must implement at least the non-deprecated elements. Implementations intending interoperability with older versions of the API should also include the deprecated functions.",
      "zh-CHS": "请注意，SCTP套接字API的某些元素被声明为已弃用。在本文档的发展过程中，引入并实现了API的元素，后来又被其他元素取代。这些被替换的元素被声明为已弃用，因为它们在某些实现中仍然可用，而替换函数不可用。这尤其适用于支持SCTP的旧版本操作系统。新的SCTP套接字实现必须至少实现未弃用的元素。打算与旧版本的API进行互操作的实现还应包括不推荐使用的函数。"
    },
    {
      "indent": 0,
      "text": "2. Data Types",
      "section_title": true,
      "zh-CHS": "2. 数据类型"
    },
    {
      "indent": 3,
      "text": "Whenever possible, Portable Operating System Interface (POSIX) data types defined in [IEEE-1003.1-2008] are used: uintN_t means an unsigned integer of exactly N bits (e.g., uint16_t). This document also assumes the argument data types from POSIX when possible (e.g., the final argument to setsockopt() is a socklen_t value). Whenever buffer sizes are specified, the POSIX size_t data type is used.",
      "zh-CHS": "尽可能使用[IEEE-1003.1-2008]中定义的便携式操作系统接口（POSIX）数据类型：uintN_t表示正好为N位的无符号整数（例如uint16_t）。在可能的情况下，本文档还假设POSIX中的参数数据类型（例如，setsockopt（）的最终参数是socklen_t值）。每当指定缓冲区大小时，都会使用POSIX size_t数据类型。"
    },
    {
      "indent": 0,
      "text": "3. One-to-Many Style Interface",
      "section_title": true,
      "zh-CHS": "3. 一对多风格界面"
    },
    {
      "indent": 3,
      "text": "In the one-to-many style interface, there is a one-to-many relationship between sockets and associations.",
      "zh-CHS": "在一对多样式接口中，套接字和关联之间存在一对多关系。"
    },
    {
      "indent": 0,
      "text": "3.1. Basic Operation",
      "section_title": true,
      "zh-CHS": "3.1. 基本操作"
    },
    {
      "indent": 3,
      "text": "A typical server in this style uses the following socket calls in sequence to prepare an endpoint for servicing requests:",
      "zh-CHS": "此样式的典型服务器按顺序使用以下套接字调用来准备端点以服务请求："
    },
    {
      "indent": 3,
      "text": "o socket()",
      "zh-CHS": "o 套接字（）"
    },
    {
      "indent": 3,
      "text": "o bind()",
      "zh-CHS": "o 绑定（）"
    },
    {
      "indent": 3,
      "text": "o listen()",
      "zh-CHS": "o 听"
    },
    {
      "indent": 3,
      "text": "o recvmsg()",
      "zh-CHS": "o recvmsg（）"
    },
    {
      "indent": 3,
      "text": "o sendmsg()",
      "zh-CHS": "o sendmsg（）"
    },
    {
      "indent": 3,
      "text": "o close()",
      "zh-CHS": "o 关闭（）"
    },
    {
      "indent": 3,
      "text": "A typical client uses the following calls in sequence to set up an association with a server to request services:",
      "zh-CHS": "典型的客户端按顺序使用以下调用来建立与服务器的关联以请求服务："
    },
    {
      "indent": 3,
      "text": "o socket()",
      "zh-CHS": "o 套接字（）"
    },
    {
      "indent": 3,
      "text": "o sendmsg()",
      "zh-CHS": "o sendmsg（）"
    },
    {
      "indent": 3,
      "text": "o recvmsg()",
      "zh-CHS": "o recvmsg（）"
    },
    {
      "indent": 3,
      "text": "o close()",
      "zh-CHS": "o 关闭（）"
    },
    {
      "indent": 3,
      "text": "In this style, by default, all of the associations connected to the endpoint are represented with a single socket. Each association is assigned an association identifier (the type is sctp_assoc_t) so that an application can use it to differentiate among them. In some implementations, the peer endpoints' addresses can also be used for this purpose. But this is not required for performance reasons. If",
      "zh-CHS": "在这种样式中，默认情况下，连接到端点的所有关联都用一个套接字表示。每个关联都分配了一个关联标识符（类型为sctp_assoc_t），以便应用程序可以使用它来区分它们。在某些实现中，对等端点的地址也可用于此目的。但出于性能原因，这不是必需的。如果"
    },
    {
      "indent": 3,
      "text": "an implementation does not support using addresses to differentiate between different associations, the sendto() call can only be used to set up an association implicitly. It cannot be used to send data to an established association, as the association identifier cannot be specified.",
      "zh-CHS": "实现不支持使用地址区分不同的关联，sendto（）调用只能用于隐式设置关联。它不能用于向已建立的关联发送数据，因为无法指定关联标识符。"
    },
    {
      "indent": 3,
      "text": "Once an association identifier is assigned to an SCTP association, that identifier will not be reused until the application explicitly terminates the use of the association. The resources belonging to that association will not be freed until that happens. This is similar to the close() operation on a normal socket. The only exception is when the SCTP_AUTOCLOSE option (Section 8.1.8) is set. In this case, after the association is terminated gracefully and automatically, the association identifier assigned to it can be reused. All applications using this option should be aware of this to avoid the possible problem of sending data to an incorrect peer endpoint.",
      "zh-CHS": "一旦将关联标识符分配给SCTP关联，在应用程序显式终止该关联的使用之前，将不会重用该标识符。在此之前，属于该关联的资源不会被释放。这类似于普通套接字上的close（）操作。唯一的例外情况是设置了SCTP_自动关闭选项（第8.1.8节）。在这种情况下，关联正常自动终止后，可以重用分配给它的关联标识符。所有使用此选项的应用程序都应该知道这一点，以避免向不正确的对等端点发送数据的可能问题。"
    },
    {
      "indent": 3,
      "text": "If the server or client wishes to branch an existing association off to a separate socket, it is required to call sctp_peeloff() and to specify the association identifier. The sctp_peeloff() call will return a new one-to-one style socket that can then be used with recv() and send() functions for message passing. See Section 9.2 for more on branched-off associations.",
      "zh-CHS": "如果服务器或客户端希望将现有关联分支到单独的套接字，则需要调用sctp_peeloff（）并指定关联标识符。sctp_peeloff（）调用将返回一个新的一对一样式的套接字，然后可以与recv（）和send（）函数一起用于消息传递。有关分支关联的更多信息，请参见第9.2节。"
    },
    {
      "indent": 3,
      "text": "Once an association is branched off to a separate socket, it becomes completely separated from the original socket. All subsequent control and data operations to that association must be done through the new socket. For example, the close() operation on the original socket will not terminate any associations that have been branched off to a different socket.",
      "zh-CHS": "一旦一个关联分支到一个单独的套接字，它就会与原始套接字完全分离。该关联的所有后续控制和数据操作都必须通过新套接字完成。例如，原始套接字上的close（）操作不会终止已分支到其他套接字的任何关联。"
    },
    {
      "indent": 3,
      "text": "One-to-many style socket calls are discussed in more detail in the following subsections.",
      "zh-CHS": "下面的小节将更详细地讨论一对多样式套接字调用。"
    },
    {
      "indent": 0,
      "text": "3.1.1. socket()",
      "section_title": true,
      "zh-CHS": "3.1.1. 套接字（）"
    },
    {
      "indent": 3,
      "text": "Applications use socket() to create a socket descriptor to represent an SCTP endpoint.",
      "zh-CHS": "应用程序使用socket（）创建套接字描述符来表示SCTP端点。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int socket(int domain, int type, int protocol);",
      "zh-CHS": "int套接字（int域、int类型、int协议）；"
    },
    {
      "indent": 3,
      "text": "and one uses PF_INET or PF_INET6 as the domain, SOCK_SEQPACKET as the type, and IPPROTO_SCTP as the protocol.",
      "zh-CHS": "其中一个使用PF_INET或PF_INET6作为域，SOCK_SEQPACKET作为类型，IPPROTO_SCTP作为协议。"
    },
    {
      "indent": 3,
      "text": "Here, SOCK_SEQPACKET indicates the creation of a one-to-many style socket.",
      "zh-CHS": "这里，SOCK_SEQPACKET表示一对多样式套接字的创建。"
    },
    {
      "indent": 3,
      "text": "The function returns a socket descriptor, or -1 in case of an error.",
      "zh-CHS": "函数返回套接字描述符，如果出现错误，则返回-1。"
    },
    {
      "indent": 3,
      "text": "Using the PF_INET domain indicates the creation of an endpoint that can use only IPv4 addresses, while PF_INET6 creates an endpoint that can use both IPv6 and IPv4 addresses.",
      "zh-CHS": "使用PF_INET域表示创建只能使用IPv4地址的端点，而PF_INET6创建可以同时使用IPv6和IPv4地址的端点。"
    },
    {
      "indent": 0,
      "text": "3.1.2. bind()",
      "section_title": true,
      "zh-CHS": "3.1.2. 绑定（）"
    },
    {
      "indent": 3,
      "text": "Applications use bind() to specify with which local address and port the SCTP endpoint should associate itself.",
      "zh-CHS": "应用程序使用bind（）指定SCTP端点应将自身与哪个本地地址和端口相关联。"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint can be associated with multiple addresses. To do this, sctp_bindx() is introduced in Section 9.1 to help applications do the job of associating multiple addresses. But note that an endpoint can only be associated with one local port.",
      "zh-CHS": "SCTP端点可以与多个地址关联。为此，在第9.1节中引入了sctp_bindx（），以帮助应用程序完成关联多个地址的工作。但请注意，端点只能与一个本地端口关联。"
    },
    {
      "indent": 3,
      "text": "These addresses associated with a socket are the eligible transport addresses for the endpoint to send and receive data. The endpoint will also present these addresses to its peers during the association initialization process; see [RFC4960].",
      "zh-CHS": "这些与套接字关联的地址是端点发送和接收数据的合格传输地址。端点还将在关联初始化过程中向其对等方呈现这些地址；参见[RFC4960]。"
    },
    {
      "indent": 3,
      "text": "After calling bind(), if the endpoint wishes to accept new associations on the socket, it must call listen() (see Section 3.1.3).",
      "zh-CHS": "调用bind（）后，如果端点希望接受套接字上的新关联，则必须调用listen（）（参见第3.1.3节）。"
    },
    {
      "indent": 3,
      "text": "The function prototype of bind() is",
      "zh-CHS": "bind（）的函数原型是"
    },
    {
      "indent": 3,
      "text": "int bind(int sd, struct sockaddr *addr, socklen_t addrlen);",
      "zh-CHS": "int bind（int sd，结构sockaddr*addr，socklen\\u t addrlen）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor returned by socket().",
      "zh-CHS": "sd:套接字（）返回的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "addr: The address structure (struct sockaddr_in for an IPv4 address or struct sockaddr_in6 for an IPv6 address; see [RFC3493]).",
      "zh-CHS": "地址：地址结构（对于IPv4地址为struct sockaddr_in，对于IPv6地址为struct sockaddr_in；请参阅[RFC3493]）。"
    },
    {
      "indent": 3,
      "text": "addrlen: The size of the address structure.",
      "zh-CHS": "地址结构的大小。"
    },
    {
      "indent": 3,
      "text": "bind() returns 0 on success and -1 in case of an error.",
      "zh-CHS": "bind（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "If sd is an IPv4 socket, the address passed must be an IPv4 address. If the sd is an IPv6 socket, the address passed can either be an IPv4 or an IPv6 address.",
      "zh-CHS": "如果sd是IPv4套接字，则传递的地址必须是IPv4地址。如果sd是IPv6套接字，则传递的地址可以是IPv4或IPv6地址。"
    },
    {
      "indent": 3,
      "text": "Applications cannot call bind() multiple times to associate multiple addresses to an endpoint. After the first call to bind(), all subsequent calls will return an error.",
      "zh-CHS": "应用程序不能多次调用bind（）将多个地址与端点关联。在第一次调用bind（）之后，所有后续调用都将返回错误。"
    },
    {
      "indent": 3,
      "text": "If the IP address part of addr is specified as a wildcard (INADDR_ANY for an IPv4 address, or as IN6ADDR_ANY_INIT or in6addr_any for an IPv6 address), the operating system will associate the endpoint with an optimal address set of the available interfaces. If the IPv4 sin_port or IPv6 sin6_port is set to 0, the operating system will choose an ephemeral port for the endpoint.",
      "zh-CHS": "如果将addr的IP地址部分指定为通配符（INADDR_ANY用于IPv4地址，IN6ADDR_ANY_INIT或IN6ADDR_ANY用于IPv6地址），则操作系统将端点与可用接口的最佳地址集相关联。如果IPv4 sin_端口或IPv6 sin6_端口设置为0，则操作系统将为端点选择临时端口。"
    },
    {
      "indent": 3,
      "text": "If bind() is not called prior to a sendmsg() call that initiates a new association, the system picks an ephemeral port and will choose an address set equivalent to binding with a wildcard address. One of those addresses will be the primary address for the association. This automatically enables the multi-homing capability of SCTP.",
      "zh-CHS": "如果在启动新关联的sendmsg（）调用之前未调用bind（），系统将选择一个临时端口，并将选择一个相当于使用通配符地址绑定的地址集。其中一个地址将是关联的主地址。这将自动启用SCTP的多主功能。"
    },
    {
      "indent": 3,
      "text": "The completion of this bind() process does not allow the SCTP endpoint to accept inbound SCTP association requests. Until a listen() system call, described below, is performed on the socket, the SCTP endpoint will promptly reject an inbound SCTP INIT request with an SCTP ABORT.",
      "zh-CHS": "此bind（）进程的完成不允许SCTP端点接受入站SCTP关联请求。在套接字上执行下面描述的listen（）系统调用之前，SCTP端点将立即拒绝带有SCTP中止的入站SCTP INIT请求。"
    },
    {
      "indent": 0,
      "text": "3.1.3. listen()",
      "section_title": true,
      "zh-CHS": "3.1.3. 听"
    },
    {
      "indent": 3,
      "text": "By default, a one-to-many style socket does not accept new association requests. An application uses listen() to mark a socket as being able to accept new associations.",
      "zh-CHS": "默认情况下，一对多样式套接字不接受新的关联请求。应用程序使用listen（）将套接字标记为能够接受新关联。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int listen(int sd, int backlog);",
      "zh-CHS": "int-listen（int-sd，int-backlog）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of the endpoint.",
      "zh-CHS": "sd：端点的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "backlog: If backlog is non-zero, enable listening, else disable listening.",
      "zh-CHS": "backlog：如果backlog非零，则启用侦听，否则禁用侦听。"
    },
    {
      "indent": 3,
      "text": "listen() returns 0 on success and -1 in case of an error.",
      "zh-CHS": "listen（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "Note that one-to-many style socket consumers do not need to call accept() to retrieve new associations. Calling accept() on a one-to-many style socket should return EOPNOTSUPP. Rather, new associations are accepted automatically, and notifications of the new associations are delivered via recvmsg() with the SCTP_ASSOC_CHANGE event (if",
      "zh-CHS": "请注意，一对多样式套接字使用者不需要调用accept（）来检索新关联。在一对多样式套接字上调用accept（）应返回EOPNOTSUPP。相反，会自动接受新关联，并通过带有SCTP_ASSOC_CHANGE事件（如果需要）的recvmsg（）传递新关联的通知"
    },
    {
      "indent": 3,
      "text": "these notifications are enabled). Clients will typically not call listen(), so that they can be assured that only actively initiated associations are possible on the socket. Server or peer-to-peer sockets, on the other hand, will always accept new associations, so a well-written application using server one-to-many style sockets must be prepared to handle new associations from unwanted peers.",
      "zh-CHS": "这些通知已启用）。客户端通常不会调用listen（），因此可以确保套接字上只能进行主动启动的关联。另一方面，服务器或对等套接字将始终接受新的关联，因此使用服务器一对多样式套接字的编写良好的应用程序必须准备好处理来自不需要的对等方的新关联。"
    },
    {
      "indent": 3,
      "text": "Also note that the SCTP_ASSOC_CHANGE event provides the association identifier for a new association, so if applications wish to use the association identifier as a parameter to other socket calls, they should ensure that the SCTP_ASSOC_CHANGE event is enabled.",
      "zh-CHS": "还请注意，SCTP_ASSOC_CHANGE事件为新关联提供关联标识符，因此如果应用程序希望将关联标识符用作其他套接字调用的参数，则应确保启用SCTP_ASSOC_CHANGE事件。"
    },
    {
      "indent": 0,
      "text": "3.1.4. sendmsg() and recvmsg()",
      "section_title": true,
      "zh-CHS": "3.1.4. sendmsg（）和recvmsg（）"
    },
    {
      "indent": 3,
      "text": "An application uses the sendmsg() and recvmsg() calls to transmit data to and receive data from its peer.",
      "zh-CHS": "应用程序使用sendmsg（）和recvmsg（）调用向其对等方传输数据和从其对等方接收数据。"
    },
    {
      "indent": 3,
      "text": "The function prototypes are",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t sendmsg(int sd, const struct msghdr *message, int flags);",
      "zh-CHS": "ssize_t sendmsg（int-sd，const-struct-msghdr*消息，int-flags）；"
    },
    {
      "indent": 3,
      "text": "and",
      "zh-CHS": "和"
    },
    {
      "indent": 3,
      "text": "ssize_t recvmsg(int sd, struct msghdr *message, int flags);",
      "zh-CHS": "ssize_t recvmsg（int-sd，struct-msghdr*消息，int-flags）；"
    },
    {
      "indent": 3,
      "text": "using the following arguments:",
      "zh-CHS": "使用以下参数："
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of the endpoint.",
      "zh-CHS": "sd：端点的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "message: Pointer to the msghdr structure that contains a single user message and possibly some ancillary data. See Section 5 for a complete description of the data structures.",
      "zh-CHS": "message：指向msghdr结构的指针，该结构包含单个用户消息，可能还包含一些辅助数据。有关数据结构的完整描述，请参见第5节。"
    },
    {
      "indent": 3,
      "text": "flags: No new flags are defined for SCTP at this level. See Section 5 for SCTP-specific flags used in the msghdr structure.",
      "zh-CHS": "标志：在该级别没有为SCTP定义新标志。有关msghdr结构中使用的SCTP特定标志，请参见第5节。"
    },
    {
      "indent": 3,
      "text": "sendmsg() returns the number of bytes accepted by the kernel or -1 in case of an error. recvmsg() returns the number of bytes received or -1 in case of an error.",
      "zh-CHS": "sendmsg（）返回内核接受的字节数，或者在出现错误时返回-1。recvmsg（）返回接收的字节数，如果出现错误，返回-1。"
    },
    {
      "indent": 3,
      "text": "As described in Section 5, different types of ancillary data can be sent and received along with user data. When sending, the ancillary data is used to specify the sent behavior, such as the SCTP stream number to use. When receiving, the ancillary data is used to describe the received data, such as the SCTP stream sequence number of the message.",
      "zh-CHS": "如第5节所述，不同类型的辅助数据可以与用户数据一起发送和接收。发送时，辅助数据用于指定发送的行为，例如要使用的SCTP流号。当接收时，辅助数据用于描述接收到的数据，例如消息的SCTP流序列号。"
    },
    {
      "indent": 3,
      "text": "When sending user data with sendmsg(), the msg_name field in the msghdr structure will be filled with one of the transport addresses of the intended receiver. If there is no existing association between the sender and the intended receiver, the sender's SCTP stack will set up a new association and then send the user data (see Section 7.5 for more on implicit association setup). If sendmsg() is called with no data and there is no existing association, a new one will be established. The SCTP_INIT type ancillary data can be used to change some of the parameters used to set up a new association. If sendmsg() is called with NULL data, and there is no existing association but the SCTP_ABORT or SCTP_EOF flags are set as described in Section 5.3.4, then -1 is returned and errno is set to EINVAL. Sending a message using sendmsg() is atomic unless explicit end of record (EOR) marking is enabled on the socket specified by sd (see Section 8.1.26).",
      "zh-CHS": "使用sendmsg（）发送用户数据时，msghdr结构中的msg_name字段将填充预期接收器的一个传输地址。如果发送方和预期接收方之间不存在关联，发送方的SCTP堆栈将建立新关联，然后发送用户数据（有关隐式关联设置的更多信息，请参阅第7.5节）。如果在没有数据的情况下调用sendmsg（），并且没有现有关联，则将建立一个新关联。SCTP_INIT类型的辅助数据可用于更改用于建立新关联的某些参数。如果使用空数据调用sendmsg（），并且不存在关联，但按照第5.3.4节中的说明设置了SCTP_ABORT或SCTP_EOF标志，则返回-1并将errno设置为EINVAL。使用sendmsg（）发送消息是原子性的，除非在sd指定的套接字上启用了显式记录结束（EOR）标记（见第8.1.26节）。"
    },
    {
      "indent": 3,
      "text": "If a peer sends a SHUTDOWN, an SCTP_SHUTDOWN_EVENT notification will be delivered if that notification has been enabled, and no more data can be sent to that association. Any attempt to send more data will cause sendmsg() to return with an ESHUTDOWN error. Note that the socket is still open for reading at this point, so it is possible to retrieve notifications.",
      "zh-CHS": "如果对等方发送关闭，则将发送SCTP_SHUTDOWN_事件通知（如果该通知已启用），并且无法向该关联发送更多数据。任何发送更多数据的尝试都会导致sendmsg（）返回一个ESHUTDOWN错误。请注意，此时套接字仍处于打开状态以供读取，因此可以检索通知。"
    },
    {
      "indent": 3,
      "text": "When receiving a user message with recvmsg(), the msg_name field in the msghdr structure will be populated with the source transport address of the user data. The caller of recvmsg() can use this address information to determine to which association the received user message belongs. Note that if SCTP_ASSOC_CHANGE events are disabled, applications must use the peer transport address provided in the msg_name field by recvmsg() to perform correlation to an association, since they will not have the association identifier.",
      "zh-CHS": "接收带有recvmsg（）的用户消息时，msghdr结构中的msg_name字段将填充用户数据的源传输地址。recvmsg（）的调用方可以使用此地址信息来确定收到的用户消息属于哪个关联。请注意，如果禁用SCTP_ASSOC_CHANGE事件，则应用程序必须使用recvmsg（）在msg_name字段中提供的对等传输地址来执行与关联的关联，因为它们没有关联标识符。"
    },
    {
      "indent": 3,
      "text": "If all data in a single message has been delivered, MSG_EOR will be set in the msg_flags field of the msghdr structure (see Section 5.1).",
      "zh-CHS": "如果单个消息中的所有数据都已交付，则msghdr结构的MSG_标志字段中将设置MSG_EOR（参见第5.1节）。"
    },
    {
      "indent": 3,
      "text": "If the application does not provide enough buffer space to completely receive a data message, MSG_EOR will not be set in msg_flags. Successive reads will consume more of the same message until the entire message has been delivered, and MSG_EOR will be set.",
      "zh-CHS": "如果应用程序没有提供足够的缓冲区空间来完全接收数据消息，则不会在MSG_标志中设置MSG_EOR。连续读取将消耗更多相同的消息，直到整个消息被传递，并且将设置MSG_EOR。"
    },
    {
      "indent": 3,
      "text": "If the SCTP stack is running low on buffers, it may partially deliver a message. In this case, MSG_EOR will not be set, and more calls to recvmsg() will be necessary to completely consume the message. Only one message at a time can be partially delivered in any stream. The socket option SCTP_FRAGMENT_INTERLEAVE controls various aspects of what interlacing of messages occurs for both the one-to-one and the one-to-many style sockets. Please consult Section 8.1.20 for further details on message delivery options.",
      "zh-CHS": "如果SCTP堆栈的缓冲区不足，它可能会部分传递消息。在这种情况下，将不会设置MSG_EOR，需要对recvmsg（）进行更多调用才能完全使用消息。在任何流中，一次只能部分传递一条消息。套接字选项SCTP_FRAGMENT_INTERLEAVE控制一对一和一对多样式套接字的消息交错的各个方面。请参阅第8.1.20节，了解有关邮件传递选项的更多详细信息。"
    },
    {
      "indent": 0,
      "text": "3.1.5. close()",
      "section_title": true,
      "zh-CHS": "3.1.5. 关闭（）"
    },
    {
      "indent": 3,
      "text": "Applications use close() to perform graceful shutdown (as described in Section 10.1 of [RFC4960]) on all of the associations currently represented by a one-to-many style socket.",
      "zh-CHS": "应用程序使用close（）对当前由一对多样式套接字表示的所有关联执行正常关闭（如[RFC4960]第10.1节所述）。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int close(int sd);",
      "zh-CHS": "内部关闭（内部sd）；"
    },
    {
      "indent": 3,
      "text": "and the argument is",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of the associations to be closed.",
      "zh-CHS": "sd：要关闭的关联的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "0 is returned on success and -1 in case of an error.",
      "zh-CHS": "成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "To gracefully shut down a specific association represented by the one-to-many style socket, an application should use the sendmsg() call and include the SCTP_EOF flag. A user may optionally terminate an association non-gracefully by using sendmsg() with the SCTP_ABORT flag set and possibly passing a user-specified abort code in the data field. Both flags SCTP_EOF and SCTP_ABORT are passed with ancillary data (see Section 5.3.4) in the sendmsg() call.",
      "zh-CHS": "要优雅地关闭由一对多样式套接字表示的特定关联，应用程序应使用sendmsg（）调用并包含SCTP_EOF标志。用户可以选择使用设置了SCTP_ABORT标志的sendmsg（）并可能在数据字段中传递用户指定的中止代码，从而非正常终止关联。在sendmsg（）调用中，SCTP_EOF和SCTP_ABORT两个标志都与辅助数据一起传递（参见第5.3.4节）。"
    },
    {
      "indent": 3,
      "text": "If sd in the close() call is a branched-off socket representing only one association, the shutdown is performed on that association only.",
      "zh-CHS": "如果close（）调用中的sd是只表示一个关联的分支套接字，则仅对该关联执行关闭。"
    },
    {
      "indent": 0,
      "text": "3.1.6. connect()",
      "section_title": true,
      "zh-CHS": "3.1.6. 连接（）"
    },
    {
      "indent": 3,
      "text": "An application may use the connect() call in the one-to-many style to initiate an association without sending data.",
      "zh-CHS": "应用程序可以使用一对多样式的connect（）调用来启动关联，而不发送数据。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int connect(int sd, const struct sockaddr *nam, socklen_t len);",
      "zh-CHS": "int connect（int sd，const struct sockaddr*nam，socklen_t len）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor to which a new association is added.",
      "zh-CHS": "sd：添加新关联的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "nam: The address structure (struct sockaddr_in for an IPv4 address or struct sockaddr_in6 for an IPv6 address; see [RFC3493]).",
      "zh-CHS": "nam：地址结构（对于IPv4地址为struct sockaddr_in，对于IPv6地址为struct sockaddr_in；请参阅[RFC3493]）。"
    },
    {
      "indent": 3,
      "text": "len: The size of the address.",
      "zh-CHS": "len:地址的大小。"
    },
    {
      "indent": 3,
      "text": "0 is returned on success and -1 in case of an error.",
      "zh-CHS": "成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "Multiple connect() calls can be made on the same socket to create multiple associations. This is different from the semantics of connect() on a UDP socket.",
      "zh-CHS": "可以在同一套接字上进行多个connect（）调用以创建多个关联。这与UDP套接字上connect（）的语义不同。"
    },
    {
      "indent": 3,
      "text": "Note that SCTP allows data exchange, similar to T/TCP [RFC1644] (made Historic by [RFC6247]), during the association setup phase. If an application wants to do this, it cannot use the connect() call. Instead, it should use sendto() or sendmsg() to initiate an association. If it uses sendto() and it wants to change the initialization behavior, it needs to use the SCTP_INITMSG socket option before calling sendto(). Or it can use sendmsg() with SCTP_INIT type ancillary data to initiate an association without calling setsockopt(). Note that the implicit setup is supported for the one-to-many style sockets.",
      "zh-CHS": "请注意，SCTP允许在关联设置阶段进行数据交换，类似于T/TCP[RFC1644]（由[RFC6247]创建历史记录）。如果应用程序想这样做，它不能使用connect（）调用。相反，它应该使用sendto（）或sendmsg（）来启动关联。如果它使用sendto（）并希望更改初始化行为，则需要在调用sendto（）之前使用SCTP_INITMSG socket选项。或者，它可以将sendmsg（）与SCTP_INIT类型的辅助数据一起使用，以启动关联，而无需调用setsockopt（）。请注意，一对多样式套接字支持隐式设置。"
    },
    {
      "indent": 3,
      "text": "SCTP does not support half close semantics. This means that unlike T/TCP, MSG_EOF should not be set in the flags parameter when calling sendto() or sendmsg() when the call is used to initiate a connection. MSG_EOF is not an acceptable flag with an SCTP socket.",
      "zh-CHS": "SCTP不支持半封闭语义。这意味着，与T/TCP不同，在调用sendto（）或sendmsg（）以启动连接时，不应在flags参数中设置MSG_EOF。MSG_EOF不是SCTP套接字的可接受标志。"
    },
    {
      "indent": 0,
      "text": "3.2. Non-Blocking Mode",
      "section_title": true,
      "zh-CHS": "3.2. 非阻塞模式"
    },
    {
      "indent": 3,
      "text": "Some SCTP applications may wish to avoid being blocked when calling a socket interface function.",
      "zh-CHS": "一些SCTP应用程序可能希望在调用套接字接口函数时避免被阻塞。"
    },
    {
      "indent": 3,
      "text": "Once a bind() call and/or subsequent sctp_bindx() calls are complete on a one-to-many style socket, an application may set the non-blocking option via a fcntl() (such as O_NONBLOCK). After setting the socket to non-blocking mode, the sendmsg() function returns immediately. The success or failure of sending the data message (with possible SCTP_INITMSG ancillary data) will be signaled by the SCTP_ASSOC_CHANGE event with SCTP_COMM_UP or SCTP_CANT_START_ASSOC. If user data could not be sent (due to an SCTP_CANT_START_ASSOC), the sender will also receive an SCTP_SEND_FAILED_EVENT event. Events can be received by the user calling recvmsg(). A server (having called listen()) is also",
      "zh-CHS": "在一对多样式套接字上完成bind（）调用和/或后续sctp_bindx（）调用后，应用程序可以通过fcntl（）设置非阻塞选项（例如O_NONBLOCK）。将套接字设置为非阻塞模式后，sendmsg（）函数立即返回。发送数据消息（可能包含SCTP_INITMSG辅助数据）的成功或失败将由SCTP_ASSOC_CHANGE事件和SCTP_COMM_UP或SCTP_CANT_START_ASSOC发出信号。如果用户数据无法发送（由于SCTP_CANT_START_ASSOC），发送方还将收到SCTP_SEND_FAILED_事件。调用recvmsg（）的用户可以接收事件。服务器（调用了listen（））也在运行"
    },
    {
      "indent": 3,
      "text": "notified of an association-up event via the reception of an SCTP_ASSOC_CHANGE with SCTP_COMM_UP via the calling of recvmsg() and possibly the reception of the first data message.",
      "zh-CHS": "通过调用recvmsg（）接收SCTP_ASSOC_CHANGE和SCTP_COMM_up，并可能接收第一条数据消息，通知关联up事件。"
    },
    {
      "indent": 3,
      "text": "To shut down the association gracefully, the user must call sendmsg() with no data and with the SCTP_EOF flag set as described in Section 5.3.4. The function returns immediately, and completion of the graceful shutdown is indicated by an SCTP_ASSOC_CHANGE notification of type SCTP_SHUTDOWN_COMP (see Section 6.1.1). Note that this can also be done using the sctp_sendv() call described in Section 9.12.",
      "zh-CHS": "要优雅地关闭关联，用户必须调用sendmsg（），无数据且设置SCTP_EOF标志，如第5.3.4节所述。该功能立即返回，SCTP_shutdown_COMP类型的SCTP_ASSOC_变更通知（见第6.1.1节）指示正常关机完成。请注意，这也可以使用第9.12节中描述的sctp_sendv（）调用来完成。"
    },
    {
      "indent": 3,
      "text": "It is recommended that an application use caution when using select() (or poll()) for writing on a one-to-many style socket, because the interpretation of select() on write is implementation specific. Generally, a positive return on a select() on write would only indicate that one of the associations represented by the one-to-many style socket is writable. An application that writes after the select() returns may still block, since the association that was writable is not the destination association of the write call. Likewise, select() (or poll()) for reading from a one-to-many style socket will only return an indication that one of the associations represented by the socket has data to be read.",
      "zh-CHS": "建议应用程序在一对多样式套接字上使用select（）或poll（）进行写入时要小心，因为写入时select（）的解释是特定于实现的。通常，写入时select（）的正返回仅表示一对多样式套接字表示的关联之一是可写的。在select（）返回后写入的应用程序可能仍然会阻塞，因为可写入的关联不是写入调用的目标关联。同样，用于从一对多样式套接字读取的select（）（或poll（））将只返回一个指示，表明套接字表示的其中一个关联具有要读取的数据。"
    },
    {
      "indent": 3,
      "text": "An application that wishes to know that a particular association is ready for reading or writing should either use the one-to-one style or use the sctp_peeloff() function (see Section 9.2) to separate the association of interest from the one-to-many style socket.",
      "zh-CHS": "如果应用程序希望知道某个特定关联已准备好读或写，则应使用一对一样式或使用sctp_peeloff（）函数（参见第9.2节）将感兴趣的关联从一对多样式套接字中分离出来。"
    },
    {
      "indent": 3,
      "text": "Note that some implementations may have an extended select call, such as epoll or kqueue, that may escape this limitation and allow a select on a specific association of a one-to-many style socket, but this is an implementation-specific detail that a portable application cannot depend on.",
      "zh-CHS": "请注意，某些实现可能具有扩展的select调用，如epoll或kqueue，这可能会逃脱此限制，并允许对一对多样式套接字的特定关联进行选择，但这是一个可移植应用程序无法依赖的实现特定细节。"
    },
    {
      "indent": 0,
      "text": "3.3. Special Considerations",
      "section_title": true,
      "zh-CHS": "3.3. 特别注意事项"
    },
    {
      "indent": 3,
      "text": "The fact that a one-to-many style socket can provide access to many SCTP associations through a single socket descriptor has important implications for both application programmers and system programmers implementing this API. A key issue is how buffer space inside the sockets layer is managed. Because this implementation detail directly affects how application programmers must write their code to ensure correct operation and portability, this section provides some guidance to both implementers and application programmers.",
      "zh-CHS": "一对多样式的套接字可以通过单个套接字描述符提供对多个SCTP关联的访问，这一事实对实现此API的应用程序程序员和系统程序员都有重要的意义。一个关键问题是如何管理套接字层中的缓冲区空间。由于此实现细节直接影响应用程序程序员必须如何编写代码以确保正确的操作和可移植性，因此本节为实现者和应用程序程序员提供了一些指导。"
    },
    {
      "indent": 3,
      "text": "An important feature that SCTP shares with TCP is flow control. Specifically, a sender may not send data faster than the receiver can consume it.",
      "zh-CHS": "SCTP与TCP共享的一个重要特性是流量控制。具体而言，发送方发送数据的速度可能不会超过接收方使用数据的速度。"
    },
    {
      "indent": 3,
      "text": "For TCP, flow control is typically provided for in the sockets API as follows. If the reader stops reading, the sender queues messages in the socket layer until the send socket buffer is completely filled. This results in a \"stalled connection\". Further attempts to write to the socket will block or return the error EAGAIN or EWOULDBLOCK for a non-blocking socket. At some point, either the connection is closed, or the receiver begins to read, again freeing space in the output queue.",
      "zh-CHS": "对于TCP，流控制通常在套接字API中提供，如下所示。如果读卡器停止读取，发送器将在套接字层中对消息排队，直到发送套接字缓冲区完全填满。这会导致“连接暂停”。进一步尝试写入套接字将阻塞或返回非阻塞套接字的错误EAGAIN或EWOULDLOCK。在某个时刻，要么关闭连接，要么接收器开始读取，再次释放输出队列中的空间。"
    },
    {
      "indent": 3,
      "text": "For one-to-one style SCTP sockets (this includes sockets descriptors that were separated from a one-to-many style socket with sctp_peeloff()), the behavior is identical. For one-to-many style SCTP sockets, there are multiple associations for a single socket, which makes the situation more complicated. If the implementation uses a single buffer space allocation shared by all associations, a single stalled association can prevent the further sending of data on all associations active on a particular one-to-many style socket.",
      "zh-CHS": "对于一对一样式的SCTP套接字（包括使用SCTP_peeloff（）从一对多样式套接字中分离出来的套接字描述符），其行为是相同的。对于一对多样式的SCTP套接字，单个套接字有多个关联，这使得情况更加复杂。如果实现使用由所有关联共享的单个缓冲区空间分配，则单个暂停的关联可以阻止进一步发送特定一对多样式套接字上所有活动关联的数据。"
    },
    {
      "indent": 3,
      "text": "For a blocking socket, it should be clear that a single stalled association can block the entire socket. For this reason, application programmers may want to use non-blocking one-to-many style sockets. The application should at least be able to send messages to the non-stalled associations.",
      "zh-CHS": "对于阻塞套接字，应该清楚的是，单个暂停的关联可以阻塞整个套接字。因此，应用程序程序员可能希望使用非阻塞的一对多样式套接字。应用程序应至少能够向未暂停的关联发送消息。"
    },
    {
      "indent": 3,
      "text": "But a non-blocking socket is not sufficient if the API implementer has chosen a single shared buffer allocation for the socket. A single stalled association would eventually cause the shared allocation to fill, and it would become impossible to send even to non-stalled associations.",
      "zh-CHS": "但是，如果API实现者为套接字选择了单个共享缓冲区分配，则非阻塞套接字是不够的。单个暂停的关联最终会导致共享分配被填满，甚至无法发送到未暂停的关联。"
    },
    {
      "indent": 3,
      "text": "The API implementer can solve this problem by providing each association with its own allocation of outbound buffer space. Each association should conceptually have as much buffer space as it would have if it had its own socket. As a bonus, this simplifies the implementation of sctp_peeloff().",
      "zh-CHS": "API实现者可以通过为每个关联提供其自己的出站缓冲区空间分配来解决这个问题。从概念上讲，每个关联都应该具有与拥有自己的套接字时相同的缓冲区空间。另外，这简化了sctp_peeloff（）的实现。"
    },
    {
      "indent": 3,
      "text": "To ensure that a given stalled association will not prevent other non-stalled associations from being writable, application programmers should either",
      "zh-CHS": "为了确保给定的暂停关联不会阻止其他非暂停关联的可写性，应用程序程序员应该"
    },
    {
      "indent": 3,
      "text": "o demand that the underlying implementation dedicates independent buffer space reservation to each association (as suggested above), or",
      "zh-CHS": "o 要求底层实现为每个关联指定独立的缓冲区空间保留（如上所述），或"
    },
    {
      "indent": 3,
      "text": "o verify that their application-layer protocol does not permit large amounts of unread data at the receiver (this is true of some request-response protocols, for example), or",
      "zh-CHS": "o 验证其应用层协议不允许在接收器处存在大量未读数据（例如，某些请求-响应协议就是如此），或者"
    },
    {
      "indent": 3,
      "text": "o use one-to-one style sockets for association, which may potentially stall (either from the beginning, or by using sctp_peeloff() before sending large amounts of data that may cause a stalled condition).",
      "zh-CHS": "o 使用一对一样式的套接字进行关联，这可能会导致暂停（从一开始，或者在发送可能导致暂停的大量数据之前使用sctp_peeloff（））。"
    },
    {
      "indent": 0,
      "text": "4. One-to-One Style Interface",
      "section_title": true,
      "zh-CHS": "4. 一对一风格的界面"
    },
    {
      "indent": 3,
      "text": "The goal of this style is to follow as closely as possible the current practice of using the sockets interface for a connection-oriented protocol such as TCP. This style enables existing applications using connection-oriented protocols to be ported to SCTP with very little effort.",
      "zh-CHS": "这种风格的目标是尽可能地遵循当前的做法，即为面向连接的协议（如TCP）使用套接字接口。这种风格使使用面向连接的协议的现有应用程序能够轻松地移植到SCTP。"
    },
    {
      "indent": 3,
      "text": "One-to-one style sockets can be connected (explicitly or implicitly) at most once, similar to TCP sockets.",
      "zh-CHS": "与TCP套接字类似，一对一样式的套接字最多只能连接一次（显式或隐式）。"
    },
    {
      "indent": 3,
      "text": "Note that some new SCTP features and some new SCTP socket options can only be utilized through the use of sendmsg() and recvmsg() calls; see Section 4.1.8.",
      "zh-CHS": "请注意，一些新的SCTP功能和一些新的SCTP套接字选项只能通过使用sendmsg（）和recvmsg（）调用来使用；见第4.1.8节。"
    },
    {
      "indent": 0,
      "text": "4.1. Basic Operation",
      "section_title": true,
      "zh-CHS": "4.1. 基本操作"
    },
    {
      "indent": 3,
      "text": "A typical one-to-one style server uses the following system call sequence to prepare an SCTP endpoint for servicing requests:",
      "zh-CHS": "典型的一对一样式的服务器使用以下系统调用序列来准备SCTP端点以服务请求："
    },
    {
      "indent": 3,
      "text": "o socket()",
      "zh-CHS": "o 套接字（）"
    },
    {
      "indent": 3,
      "text": "o bind()",
      "zh-CHS": "o 绑定（）"
    },
    {
      "indent": 3,
      "text": "o listen()",
      "zh-CHS": "o 听"
    },
    {
      "indent": 3,
      "text": "o accept()",
      "zh-CHS": "o 接受"
    },
    {
      "indent": 3,
      "text": "The accept() call blocks until a new association is set up. It returns with a new socket descriptor. The server then uses the new socket descriptor to communicate with the client, using recv() and send() calls to get requests and send back responses.",
      "zh-CHS": "accept（）调用将一直阻塞，直到建立新的关联。它返回一个新的套接字描述符。然后，服务器使用新的套接字描述符与客户端通信，使用recv（）和send（）调用获取请求并发回响应。"
    },
    {
      "indent": 3,
      "text": "Then it calls",
      "zh-CHS": "然后它会呼叫"
    },
    {
      "indent": 3,
      "text": "o close()",
      "zh-CHS": "o 关闭（）"
    },
    {
      "indent": 3,
      "text": "to terminate the association.",
      "zh-CHS": "终止协会。"
    },
    {
      "indent": 3,
      "text": "A typical client uses the following system call sequence to set up an association with a server to request services:",
      "zh-CHS": "典型的客户端使用以下系统调用序列设置与服务器的关联以请求服务："
    },
    {
      "indent": 3,
      "text": "o socket()",
      "zh-CHS": "o 套接字（）"
    },
    {
      "indent": 3,
      "text": "o connect()",
      "zh-CHS": "o 连接（）"
    },
    {
      "indent": 3,
      "text": "After returning from the connect() call, the client uses send()/ sendmsg() and recv()/recvmsg() calls to send out requests and receive responses from the server.",
      "zh-CHS": "从connect（）调用返回后，客户端使用send（）/sendmsg（）和recv（）/recvmsg（）调用发送请求并从服务器接收响应。"
    },
    {
      "indent": 3,
      "text": "The client calls",
      "zh-CHS": "客户打电话来"
    },
    {
      "indent": 3,
      "text": "o close()",
      "zh-CHS": "o 关闭（）"
    },
    {
      "indent": 3,
      "text": "to terminate this association when done.",
      "zh-CHS": "完成后终止此关联。"
    },
    {
      "indent": 0,
      "text": "4.1.1. socket()",
      "section_title": true,
      "zh-CHS": "4.1.1. 套接字（）"
    },
    {
      "indent": 3,
      "text": "Applications call socket() to create a socket descriptor to represent an SCTP endpoint.",
      "zh-CHS": "应用程序调用socket（）以创建一个套接字描述符来表示SCTP端点。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int socket(int domain, int type, int protocol);",
      "zh-CHS": "int套接字（int域、int类型、int协议）；"
    },
    {
      "indent": 3,
      "text": "and one uses PF_INET or PF_INET6 as the domain, SOCK_STREAM as the type, and IPPROTO_SCTP as the protocol.",
      "zh-CHS": "其中一个使用PF_INET或PF_INET6作为域，SOCK_流作为类型，IPPROTO_SCTP作为协议。"
    },
    {
      "indent": 3,
      "text": "Here, SOCK_STREAM indicates the creation of a one-to-one style socket.",
      "zh-CHS": "这里，SOCK_流表示创建一对一样式的套接字。"
    },
    {
      "indent": 3,
      "text": "Using the PF_INET domain indicates the creation of an endpoint that can use only IPv4 addresses, while PF_INET6 creates an endpoint that can use both IPv6 and IPv4 addresses.",
      "zh-CHS": "使用PF_INET域表示创建只能使用IPv4地址的端点，而PF_INET6创建可以同时使用IPv6和IPv4地址的端点。"
    },
    {
      "indent": 0,
      "text": "4.1.2. bind()",
      "section_title": true,
      "zh-CHS": "4.1.2. 绑定（）"
    },
    {
      "indent": 3,
      "text": "Applications use bind() to specify with which local address and port the SCTP endpoint should associate itself.",
      "zh-CHS": "应用程序使用bind（）指定SCTP端点应将自身与哪个本地地址和端口相关联。"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint can be associated with multiple addresses. To do this, sctp_bindx() is introduced in Section 9.1 to help applications do the job of associating multiple addresses. But note that an endpoint can only be associated with one local port.",
      "zh-CHS": "SCTP端点可以与多个地址关联。为此，在第9.1节中引入了sctp_bindx（），以帮助应用程序完成关联多个地址的工作。但请注意，端点只能与一个本地端口关联。"
    },
    {
      "indent": 3,
      "text": "These addresses associated with a socket are the eligible transport addresses for the endpoint to send and receive data. The endpoint will also present these addresses to its peers during the association initialization process; see [RFC4960].",
      "zh-CHS": "这些与套接字关联的地址是端点发送和接收数据的合格传输地址。端点还将在关联初始化过程中向其对等方呈现这些地址；参见[RFC4960]。"
    },
    {
      "indent": 3,
      "text": "The function prototype of bind() is",
      "zh-CHS": "bind（）的函数原型是"
    },
    {
      "indent": 3,
      "text": "int bind(int sd, struct sockaddr *addr, socklen_t addrlen);",
      "zh-CHS": "int bind（int sd，结构sockaddr*addr，socklen\\u t addrlen）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor returned by socket().",
      "zh-CHS": "sd:套接字（）返回的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "addr: The address structure (struct sockaddr_in for an IPv4 address or struct sockaddr_in6 for an IPv6 address; see [RFC3493]).",
      "zh-CHS": "地址：地址结构（对于IPv4地址为struct sockaddr_in，对于IPv6地址为struct sockaddr_in；请参阅[RFC3493]）。"
    },
    {
      "indent": 3,
      "text": "addrlen: The size of the address structure.",
      "zh-CHS": "地址结构的大小。"
    },
    {
      "indent": 3,
      "text": "If sd is an IPv4 socket, the address passed must be an IPv4 address. If sd is an IPv6 socket, the address passed can either be an IPv4 or an IPv6 address.",
      "zh-CHS": "如果sd是IPv4套接字，则传递的地址必须是IPv4地址。如果sd是IPv6套接字，则传递的地址可以是IPv4或IPv6地址。"
    },
    {
      "indent": 3,
      "text": "Applications cannot call bind() multiple times to associate multiple addresses to the endpoint. After the first call to bind(), all subsequent calls will return an error.",
      "zh-CHS": "应用程序无法多次调用bind（）将多个地址与端点关联。在第一次调用bind（）之后，所有后续调用都将返回错误。"
    },
    {
      "indent": 3,
      "text": "If the IP address part of addr is specified as a wildcard (INADDR_ANY for an IPv4 address, or as IN6ADDR_ANY_INIT or in6addr_any for an IPv6 address), the operating system will associate the endpoint with an optimal address set of the available interfaces. If the IPv4 sin_port or IPv6 sin6_port is set to 0, the operating system will choose an ephemeral port for the endpoint.",
      "zh-CHS": "如果将addr的IP地址部分指定为通配符（INADDR_ANY用于IPv4地址，IN6ADDR_ANY_INIT或IN6ADDR_ANY用于IPv6地址），则操作系统将端点与可用接口的最佳地址集相关联。如果IPv4 sin_端口或IPv6 sin6_端口设置为0，则操作系统将为端点选择临时端口。"
    },
    {
      "indent": 3,
      "text": "If bind() is not called prior to the connect() call, the system picks an ephemeral port and will choose an address set equivalent to binding with a wildcard address. One of these addresses will be the primary address for the association. This automatically enables the multi-homing capability of SCTP.",
      "zh-CHS": "如果在connect（）调用之前未调用bind（），系统将选择一个临时端口，并将选择一个与使用通配符地址绑定等效的地址集。其中一个地址将是关联的主地址。这将自动启用SCTP的多主功能。"
    },
    {
      "indent": 3,
      "text": "The completion of this bind() process does not allow the SCTP endpoint to accept inbound SCTP association requests. Until a listen() system call, described below, is performed on the socket, the SCTP endpoint will promptly reject an inbound SCTP INIT request with an SCTP ABORT.",
      "zh-CHS": "此bind（）进程的完成不允许SCTP端点接受入站SCTP关联请求。在套接字上执行下面描述的listen（）系统调用之前，SCTP端点将立即拒绝带有SCTP中止的入站SCTP INIT请求。"
    },
    {
      "indent": 0,
      "text": "4.1.3. listen()",
      "section_title": true,
      "zh-CHS": "4.1.3. 听"
    },
    {
      "indent": 3,
      "text": "Applications use listen() to allow the SCTP endpoint to accept inbound associations.",
      "zh-CHS": "应用程序使用listen（）允许SCTP端点接受入站关联。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int listen(int sd, int backlog);",
      "zh-CHS": "int-listen（int-sd，int-backlog）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of the SCTP endpoint.",
      "zh-CHS": "sd：SCTP端点的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "backlog: Specifies the max number of outstanding associations allowed in the socket's accept queue. These are the associations that have finished the four-way initiation handshake (see Section 5 of [RFC4960]) and are in the ESTABLISHED state. Note that a backlog of '0' indicates that the caller no longer wishes to receive new associations.",
      "zh-CHS": "backlog：指定套接字的接受队列中允许的最大未完成关联数。这些关联已完成四向启动握手（参见[RFC4960]第5节），并处于已建立状态。请注意，积压的“0”表示调用方不再希望接收新关联。"
    },
    {
      "indent": 3,
      "text": "listen() returns 0 on success and -1 in case of an error.",
      "zh-CHS": "listen（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 0,
      "text": "4.1.4. accept()",
      "section_title": true,
      "zh-CHS": "4.1.4. 接受"
    },
    {
      "indent": 3,
      "text": "Applications use the accept() call to remove an established SCTP association from the accept queue of the endpoint. A new socket descriptor will be returned from accept() to represent the newly formed association.",
      "zh-CHS": "应用程序使用accept（）调用从端点的接受队列中删除已建立的SCTP关联。accept（）将返回一个新的套接字描述符来表示新形成的关联。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int accept(int sd, struct sockaddr *addr, socklen_t *addrlen);",
      "zh-CHS": "int accept（int sd，结构sockaddr*addr，socklen\\u t*addrlen）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The listening socket descriptor.",
      "zh-CHS": "sd：侦听套接字描述符。"
    },
    {
      "indent": 3,
      "text": "addr: On return, addr (struct sockaddr_in for an IPv4 address or struct sockaddr_in6 for an IPv6 address; see [RFC3493]) will contain the primary address of the peer endpoint.",
      "zh-CHS": "addr：返回时，addr（struct sockaddr_in表示IPv4地址，struct sockaddr_in表示IPv6地址；请参阅[RFC3493]）将包含对等端点的主地址。"
    },
    {
      "indent": 3,
      "text": "addrlen: On return, addrlen will contain the size of addr.",
      "zh-CHS": "addrlen：返回时，addrlen将包含addr的大小。"
    },
    {
      "indent": 3,
      "text": "The function returns the socket descriptor for the newly formed association on success and -1 in case of an error.",
      "zh-CHS": "函数在成功时返回新形成的关联的套接字描述符，在出错时返回-1。"
    },
    {
      "indent": 0,
      "text": "4.1.5. connect()",
      "section_title": true,
      "zh-CHS": "4.1.5. 连接（）"
    },
    {
      "indent": 3,
      "text": "Applications use connect() to initiate an association to a peer.",
      "zh-CHS": "应用程序使用connect（）启动与对等方的关联。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int connect(int sd, const struct sockaddr *addr, socklen_t addrlen);",
      "zh-CHS": "int connect（int sd，常量结构sockaddr*addr，socklen\\u t addrlen）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of the endpoint.",
      "zh-CHS": "sd：端点的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "addr: The peer's (struct sockaddr_in for an IPv4 address or struct sockaddr_in6 for an IPv6 address; see [RFC3493]) address.",
      "zh-CHS": "addr：对等方的（struct sockaddr_in表示IPv4地址，struct sockaddr_in表示IPv6地址；请参阅[RFC3493]）地址。"
    },
    {
      "indent": 3,
      "text": "addrlen: The size of the address.",
      "zh-CHS": "地址的大小。"
    },
    {
      "indent": 3,
      "text": "connect() returns 0 on success and -1 on error.",
      "zh-CHS": "connect（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "This operation corresponds to the ASSOCIATE primitive described in Section 10.1 of [RFC4960].",
      "zh-CHS": "此操作对应于[RFC4960]第10.1节中描述的关联原语。"
    },
    {
      "indent": 3,
      "text": "The number of outbound streams the new association has is stack dependent. Before connecting, applications can use the SCTP_INITMSG option described in Section 8.1.3 to change the number of outbound streams.",
      "zh-CHS": "新关联的出站流数量取决于堆栈。在连接之前，应用程序可以使用第8.1.3节中描述的SCTP_INITMSG选项来更改出站流的数量。"
    },
    {
      "indent": 3,
      "text": "If bind() is not called prior to the connect() call, the system picks an ephemeral port and will choose an address set equivalent to binding with INADDR_ANY and IN6ADDR_ANY_INIT for IPv4 and IPv6 sockets, respectively. One of the addresses will be the primary address for the association. This automatically enables the multi-homing capability of SCTP.",
      "zh-CHS": "如果在connect（）调用之前未调用bind（），系统将选择一个临时端口，并将选择一个地址集，该地址集相当于分别使用IPv4和IPv6套接字的INADDR_ANY和IN6ADDR_ANY_INIT进行绑定。其中一个地址将是关联的主地址。这将自动启用SCTP的多主功能。"
    },
    {
      "indent": 3,
      "text": "Note that SCTP allows data exchange, similar to T/TCP [RFC1644] (made Historic by [RFC6247]), during the association setup phase. If an application wants to do this, it cannot use the connect() call. Instead, it should use sendto() or sendmsg() to initiate an association. If it uses sendto() and it wants to change the initialization behavior, it needs to use the SCTP_INITMSG socket option before calling sendto(). Or it can use sendmsg() with SCTP_INIT type ancillary data to initiate an association without calling setsockopt(). Note that the implicit setup is supported for the one-to-one style sockets.",
      "zh-CHS": "请注意，SCTP允许在关联设置阶段进行数据交换，类似于T/TCP[RFC1644]（由[RFC6247]创建历史记录）。如果应用程序想这样做，它不能使用connect（）调用。相反，它应该使用sendto（）或sendmsg（）来启动关联。如果它使用sendto（）并希望更改初始化行为，则需要在调用sendto（）之前使用SCTP_INITMSG socket选项。或者，它可以将sendmsg（）与SCTP_INIT类型的辅助数据一起使用，以启动关联，而无需调用setsockopt（）。请注意，一对一样式的套接字支持隐式设置。"
    },
    {
      "indent": 3,
      "text": "SCTP does not support half close semantics. This means that unlike T/TCP, MSG_EOF should not be set in the flags parameter when calling sendto() or sendmsg() when the call is used to initiate a connection. MSG_EOF is not an acceptable flag with an SCTP socket.",
      "zh-CHS": "SCTP不支持半封闭语义。这意味着，与T/TCP不同，在调用sendto（）或sendmsg（）以启动连接时，不应在flags参数中设置MSG_EOF。MSG_EOF不是SCTP套接字的可接受标志。"
    },
    {
      "indent": 0,
      "text": "4.1.6. close()",
      "section_title": true,
      "zh-CHS": "4.1.6. 关闭（）"
    },
    {
      "indent": 3,
      "text": "Applications use close() to gracefully close down an association.",
      "zh-CHS": "应用程序使用close（）优雅地关闭关联。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int close(int sd);",
      "zh-CHS": "内部关闭（内部sd）；"
    },
    {
      "indent": 3,
      "text": "and the argument is",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of the association to be closed.",
      "zh-CHS": "sd：要关闭的关联的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "close() returns 0 on success and -1 in case of an error.",
      "zh-CHS": "close（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "After an application calls close() on a socket descriptor, no further socket operations will succeed on that descriptor.",
      "zh-CHS": "应用程序在套接字描述符上调用close（）后，将不会在该描述符上成功执行进一步的套接字操作。"
    },
    {
      "indent": 0,
      "text": "4.1.7. shutdown()",
      "section_title": true,
      "zh-CHS": "4.1.7. 关机（）"
    },
    {
      "indent": 3,
      "text": "SCTP differs from TCP in that it does not have half close semantics. Hence, the shutdown() call for SCTP is an approximation of the TCP shutdown() call, and solves some different problems. Full TCP compatibility is not provided, so developers porting TCP applications to SCTP may need to recode sections that use shutdown(). (Note that it is possible to achieve the same results as half close in SCTP using SCTP streams.)",
      "zh-CHS": "SCTP与TCP的不同之处在于它没有半封闭语义。因此，SCTP的shutdown（）调用是TCP shutdown（）调用的近似值，可以解决一些不同的问题。没有提供完全的TCP兼容性，因此将TCP应用程序移植到SCTP的开发人员可能需要重新编码使用shutdown（）的部分。（请注意，使用SCTP流可以实现与SCTP中半封闭相同的结果。）"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int shutdown(int sd, int how);",
      "zh-CHS": "int关闭（int sd，int how）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of the association to be closed.",
      "zh-CHS": "sd：要关闭的关联的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "how: Specifies the type of shutdown. The values are as follows:",
      "zh-CHS": "如何：指定关闭的类型。数值如下："
    },
    {
      "indent": 6,
      "text": "SHUT_RD: Disables further receive operations. No SCTP protocol action is taken.",
      "zh-CHS": "关闭：禁用进一步的接收操作。未采取SCTP协议操作。"
    },
    {
      "indent": 6,
      "text": "SHUT_WR: Disables further send operations, and initiates the SCTP shutdown sequence.",
      "zh-CHS": "SHUT_WR：禁用进一步的发送操作，并启动SCTP关闭序列。"
    },
    {
      "indent": 6,
      "text": "SHUT_RDWR: Disables further send and receive operations, and initiates the SCTP shutdown sequence.",
      "zh-CHS": "SHUT_RDWR：禁用进一步的发送和接收操作，并启动SCTP关闭序列。"
    },
    {
      "indent": 3,
      "text": "shutdown() returns 0 on success and -1 in case of an error.",
      "zh-CHS": "shutdown（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "The major difference between SCTP and TCP shutdown() is that SCTP SHUT_WR initiates immediate and full protocol shutdown, whereas TCP SHUT_WR causes TCP to go into the half close state. SHUT_RD behaves the same for SCTP as for TCP. The purpose of SCTP SHUT_WR is to close the SCTP association while still leaving the socket descriptor open. This allows the caller to receive back any data that SCTP is unable to deliver (see Section 6.1.4 for more information) and receive event notifications.",
      "zh-CHS": "SCTP和TCP shutdown（）之间的主要区别在于，SCTP SHUT_WR启动即时和完全协议关闭，而TCP SHUT_WR导致TCP进入半关闭状态。SCTP的SHUT_RD行为与TCP相同。SCTP SHUT_WR的目的是在保持套接字描述符打开的同时关闭SCTP关联。这允许调用者接收回SCTP无法传送的任何数据（有关更多信息，请参阅第6.1.4节）并接收事件通知。"
    },
    {
      "indent": 3,
      "text": "To perform the ABORT operation described in Section 10.1 of [RFC4960], an application can use the socket option SO_LINGER. SO_LINGER is described in Section 8.1.4.",
      "zh-CHS": "要执行[RFC4960]第10.1节中所述的中止操作，应用程序可以使用socket选项来执行中止操作。因此，第8.1.4节描述了U LINGER。"
    },
    {
      "indent": 0,
      "text": "4.1.8. sendmsg() and recvmsg()",
      "section_title": true,
      "zh-CHS": "4.1.8. sendmsg（）和recvmsg（）"
    },
    {
      "indent": 3,
      "text": "With a one-to-one style socket, the application can also use sendmsg() and recvmsg() to transmit data to and receive data from its peer. The semantics is similar to those used in the one-to-many style (see Section 3.1.4), with the following differences:",
      "zh-CHS": "使用一对一样式的套接字，应用程序还可以使用sendmsg（）和recvmsg（）向对等方发送数据和从对等方接收数据。语义与一对多样式中使用的语义相似（见第3.1.4节），但有以下区别："
    },
    {
      "indent": 3,
      "text": "1. When sending, the msg_name field in the msghdr is not used to specify the intended receiver; rather, it is used to indicate a preferred peer address if the sender wishes to discourage the stack from sending the message to the primary address of the receiver. If the socket is connected and the transport address given is not part of the current association, the data will not be sent, and an SCTP_SEND_FAILED_EVENT event will be delivered to the application if send failure events are enabled.",
      "zh-CHS": "1. 发送时，msghdr中的msg_name字段不用于指定预期的接收器；相反，如果发送方希望阻止堆栈将消息发送到接收方的主地址，则它用于指示首选对等地址。如果套接字已连接且给定的传输地址不是当前关联的一部分，则不会发送数据，并且如果启用了发送失败事件，则会向应用程序发送SCTP_发送失败事件。"
    },
    {
      "indent": 3,
      "text": "2. Using sendmsg() on a non-connected one-to-one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.",
      "zh-CHS": "2. 在未连接的一对一样式套接字上使用sendmsg（）进行隐式连接设置可能有效，也可能无效，具体取决于SCTP实现。"
    },
    {
      "indent": 0,
      "text": "4.1.9. getpeername()",
      "section_title": true,
      "zh-CHS": "4.1.9. getpeername（）"
    },
    {
      "indent": 3,
      "text": "Applications use getpeername() to retrieve the primary socket address of the peer. This call is for TCP compatibility and is not multi-homed. It may not work with one-to-many style sockets, depending on the implementation. See Section 9.3 for a multi-homed style version of the call.",
      "zh-CHS": "应用程序使用getpeername（）检索对等方的主套接字地址。此调用是为了TCP兼容性，不是多宿主的。它可能不适用于一对多样式套接字，具体取决于实现。请参阅第9.3节，以了解呼叫的多宿主样式版本。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int getpeername(int sd, struct sockaddr *address, socklen_t *len);",
      "zh-CHS": "int getpeername（int sd，结构sockaddr*地址，socklen\\u t*len）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor to be queried.",
      "zh-CHS": "sd：要查询的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "address: On return, the peer primary address is stored in this buffer. If the socket is an IPv4 socket, the address will be IPv4. If the socket is an IPv6 socket, the address will be either an IPv6 or IPv4 address.",
      "zh-CHS": "地址：返回时，对等主地址存储在此缓冲区中。如果套接字是IPv4套接字，则地址将是IPv4。如果套接字是IPv6套接字，则地址将是IPv6或IPv4地址。"
    },
    {
      "indent": 3,
      "text": "len: The caller should set the length of address here. On return, this is set to the length of the returned address.",
      "zh-CHS": "len:呼叫者应该在这里设置地址的长度。返回时，该值设置为返回地址的长度。"
    },
    {
      "indent": 3,
      "text": "getpeername() returns 0 on success and -1 in case of an error.",
      "zh-CHS": "getpeername（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address will be truncated.",
      "zh-CHS": "如果地址的实际长度大于提供的sockaddr结构的长度，则存储的地址将被截断。"
    },
    {
      "indent": 0,
      "text": "5. Data Structures",
      "section_title": true,
      "zh-CHS": "5. 数据结构"
    },
    {
      "indent": 3,
      "text": "This section discusses important data structures that are specific to SCTP and are used with sendmsg() and recvmsg() calls to control SCTP endpoint operations and to access ancillary information and notifications.",
      "zh-CHS": "本节讨论特定于SCTP的重要数据结构，这些数据结构与sendmsg（）和recvmsg（）调用一起使用，以控制SCTP端点操作并访问辅助信息和通知。"
    },
    {
      "indent": 0,
      "text": "5.1. The msghdr and cmsghdr Structures",
      "section_title": true,
      "zh-CHS": "5.1. msghdr和cmsghdr结构"
    },
    {
      "indent": 3,
      "text": "The msghdr structure used in the sendmsg() and recvmsg() calls, as well as the ancillary data carried in the structure, is the key for the application to set and get various control information from the SCTP endpoint.",
      "zh-CHS": "sendmsg（）和recvmsg（）调用中使用的msghdr结构，以及结构中携带的辅助数据，是应用程序从SCTP端点设置和获取各种控制信息的关键。"
    },
    {
      "indent": 3,
      "text": "The msghdr and the related cmsghdr structures are defined and discussed in detail in [RFC3542]. They are defined as",
      "zh-CHS": "[RFC3542]中详细定义和讨论了msghdr和相关cmsghdr结构。它们被定义为"
    },
    {
      "indent": 3,
      "text": "struct msghdr {\n  void *msg_name;           /* ptr to socket address structure */\n  socklen_t msg_namelen;    /* size of socket address structure */\n  struct iovec *msg_iov;    /* scatter/gather array */\n  int msg_iovlen;           /* # elements in msg_iov */\n  void *msg_control;        /* ancillary data */\n  socklen_t msg_controllen; /* ancillary data buffer length */\n  int msg_flags;            /* flags on received message */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "struct cmsghdr {\n  socklen_t cmsg_len; /* # bytes, including this header */\n  int cmsg_level;     /* originating protocol */\n  int cmsg_type;      /* protocol-specific type */\n                      /* followed by unsigned char cmsg_data[]; */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In the msghdr structure, the usage of msg_name has been discussed in previous sections (see Sections 3.1.4 and 4.1.8).",
      "zh-CHS": "在msghdr结构中，msg_名称的使用已在前几节中讨论过（见第3.1.4节和第4.1.8节）。"
    },
    {
      "indent": 3,
      "text": "The scatter/gather buffers, or I/O vectors (pointed to by the msg_iov field) are treated by SCTP as a single user message for both sendmsg() and recvmsg().",
      "zh-CHS": "SCTP将分散/聚集缓冲区或I/O向量（由msg_iov字段指向）视为sendmsg（）和recvmsg（）的单个用户消息。"
    },
    {
      "indent": 3,
      "text": "The SCTP stack uses the ancillary data (msg_control field) to communicate the attributes, such as SCTP_RCVINFO, of the message stored in msg_iov to the socket endpoint. The different ancillary data types are described in Section 5.3.",
      "zh-CHS": "SCTP堆栈使用辅助数据（msg_控制字段）将存储在msg_iov中的消息的属性（如SCTP_RCVINFO）传递给套接字端点。第5.3节描述了不同的辅助数据类型。"
    },
    {
      "indent": 3,
      "text": "The msg_flags are not used when sending a message with sendmsg().",
      "zh-CHS": "使用sendmsg（）发送消息时不使用msg_标志。"
    },
    {
      "indent": 3,
      "text": "If a notification has arrived, recvmsg() will return the notification in the msg_iov field and set the MSG_NOTIFICATION flag in msg_flags. If the MSG_NOTIFICATION flag is not set, recvmsg() will return data. See Section 6 for more information about notifications.",
      "zh-CHS": "如果通知已到达，recvmsg（）将在msg_iov字段中返回通知，并在msg_标志中设置msg_通知标志。如果未设置MSG_通知标志，recvmsg（）将返回数据。有关通知的更多信息，请参见第6节。"
    },
    {
      "indent": 3,
      "text": "If all portions of a data frame or notification have been read, recvmsg() will return with MSG_EOR set in msg_flags.",
      "zh-CHS": "如果数据帧或通知的所有部分都已读取，recvmsg（）将返回，并在MSG_标志中设置MSG_EOR。"
    },
    {
      "indent": 0,
      "text": "5.2. Ancillary Data Considerations and Semantics",
      "section_title": true,
      "zh-CHS": "5.2. 辅助数据注意事项和语义"
    },
    {
      "indent": 3,
      "text": "Programming with ancillary socket data (msg_control) contains some subtleties and pitfalls, which are discussed below.",
      "zh-CHS": "使用辅助套接字数据（msg_控件）编程包含一些微妙之处和陷阱，将在下面讨论。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Multiple Items and Ordering",
      "section_title": true,
      "zh-CHS": "5.2.1. 多个项目和订购"
    },
    {
      "indent": 3,
      "text": "Multiple ancillary data items may be included in any call to sendmsg() or recvmsg(); these may include multiple SCTP items, non-SCTP items (such as IP-level items), or both.",
      "zh-CHS": "对sendmsg（）或recvmsg（）的任何调用中都可能包含多个辅助数据项；这些可能包括多个SCTP项目、非SCTP项目（如IP级项目）或两者。"
    },
    {
      "indent": 3,
      "text": "The ordering of ancillary data items (either by SCTP or another protocol) is not significant and is implementation dependent, so applications must not depend on any ordering.",
      "zh-CHS": "辅助数据项的排序（通过SCTP或其他协议）并不重要，并且依赖于实现，因此应用程序不得依赖于任何排序。"
    },
    {
      "indent": 3,
      "text": "SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO type ancillary data always corresponds to the data in the msghdr's msg_iov member. There can be only one such type of ancillary data for each sendmsg() or recvmsg() call.",
      "zh-CHS": "SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO类型的辅助数据始终与msghdr的msg_iov成员中的数据相对应。对于每个sendmsg（）或recvmsg（）调用，只能有一种此类辅助数据。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Accessing and Manipulating Ancillary Data",
      "section_title": true,
      "zh-CHS": "5.2.2. 访问和操作辅助数据"
    },
    {
      "indent": 3,
      "text": "Applications can infer the presence of data or ancillary data by examining the msg_iovlen and msg_controllen msghdr members, respectively.",
      "zh-CHS": "应用程序可以通过分别检查msg_iovlen和msg_controllen msghdr成员来推断数据或辅助数据的存在。"
    },
    {
      "indent": 3,
      "text": "Implementations may have different padding requirements for ancillary data, so portable applications should make use of the macros CMSG_FIRSTHDR, CMSG_NXTHDR, CMSG_DATA, CMSG_SPACE, and CMSG_LEN. See [RFC3542] and the SCTP implementation's documentation for more information. The following is an example, from [RFC3542], demonstrating the use of these macros to access ancillary data:",
      "zh-CHS": "实现可能对辅助数据有不同的填充要求，因此便携式应用程序应该使用宏CMSG_FIRSTHDR、CMSG_NXTHDR、CMSG_data、CMSG_SPACE和CMSG_LEN。有关更多信息，请参阅[RFC3542]和SCTP实施的文档。以下是[RFC3542]中的一个示例，演示了如何使用这些宏访问辅助数据："
    },
    {
      "indent": 3,
      "text": "struct msghdr msg;\nstruct cmsghdr *cmsgptr;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "/* fill in msg */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "/* call recvmsg() */",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;\n     cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {\n  if (cmsgptr->cmsg_len == 0) {\n     /* Error handling */\n     break;\n  }\n  if (cmsgptr->cmsg_level == ... && cmsgptr->cmsg_type == ... ) {\n    u_char  *ptr;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "    ptr = CMSG_DATA(cmsgptr);\n    /* process data pointed to by ptr */\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "5.2.3. Control Message Buffer Sizing",
      "section_title": true,
      "zh-CHS": "5.2.3. 控制消息缓冲区大小"
    },
    {
      "indent": 3,
      "text": "The information conveyed via SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO ancillary data will often be fundamental to the correct and sane operation of the sockets application. This is particularly true for one-to-many style sockets, but also for one-to-one style sockets. For example, if an application needs to send and receive data on different SCTP streams, SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO ancillary data is indispensable.",
      "zh-CHS": "通过SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO辅助数据传输的信息通常是套接字应用程序正确和正常运行的基础。对于一对多样式的套接字尤其如此，对于一对一样式的套接字也是如此。例如，如果应用程序需要在不同的SCTP流上发送和接收数据，则SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO辅助数据必不可少。"
    },
    {
      "indent": 3,
      "text": "Given that some ancillary data is critical, and that multiple ancillary data items may appear in any order, applications should be carefully written to always provide a large enough buffer to contain all possible ancillary data that can be presented by recvmsg(). If the buffer is too small, and crucial data is truncated, it may pose a fatal error condition.",
      "zh-CHS": "考虑到某些辅助数据是关键的，并且多个辅助数据项可能以任何顺序出现，因此应仔细编写应用程序，以始终提供足够大的缓冲区，以包含recvmsg（）可以显示的所有可能的辅助数据。如果缓冲区太小，并且关键数据被截断，则可能会造成致命错误。"
    },
    {
      "indent": 3,
      "text": "Thus, it is essential that applications be able to deterministically calculate the maximum required buffer size to pass to recvmsg(). One constraint imposed on this specification that makes this possible is that all ancillary data definitions are of a fixed length. One way to calculate the maximum required buffer size might be to take the sum of the sizes of all enabled ancillary data item structures, as calculated by CMSG_SPACE. For example, if we enabled SCTP_SNDRCV_INFO and IPV6_RECVPKTINFO [RFC3542], we would calculate and allocate the buffer size as follows:",
      "zh-CHS": "因此，应用程序必须能够确定地计算传递给recvmsg（）所需的最大缓冲区大小。对本规范施加的一个限制使之成为可能，即所有辅助数据定义都是固定长度的。计算所需最大缓冲区大小的一种方法可能是获取所有启用的辅助数据项结构的大小之和，由CMSG_SPACE计算。例如，如果我们启用了SCTP_SNDRCV_INFO和IPV6_RECVPKTINFO[RFC3542]，我们将按如下方式计算和分配缓冲区大小："
    },
    {
      "indent": 3,
      "text": "size_t total;\nvoid *buf;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "total = CMSG_SPACE(sizeof(struct sctp_sndrcvinfo)) +\n        CMSG_SPACE(sizeof(struct in6_pktinfo));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "buf = malloc(total);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "We could then use this buffer (buf) for msg_control on each call to recvmsg() and be assured that we would not lose any ancillary data to truncation.",
      "zh-CHS": "然后，我们可以在每次调用recvmsg（）时使用此缓冲区（buf）进行msg_控制，并确保不会因截断而丢失任何辅助数据。"
    },
    {
      "indent": 0,
      "text": "5.3. SCTP msg_control Structures",
      "section_title": true,
      "zh-CHS": "5.3. SCTP msg_控制结构"
    },
    {
      "indent": 3,
      "text": "A key element of all SCTP-specific socket extensions is the use of ancillary data to specify and access SCTP-specific data via the msghdr structure's msg_control member used in sendmsg() and recvmsg(). Fine-grained control over initialization and sending parameters are handled with ancillary data.",
      "zh-CHS": "所有特定于SCTP的套接字扩展的一个关键元素是使用辅助数据，通过在sendmsg（）和recvmsg（）中使用的msghdr结构的msg_控制成员来指定和访问特定于SCTP的数据。通过辅助数据处理对初始化和发送参数的细粒度控制。"
    },
    {
      "indent": 3,
      "text": "Each ancillary data item is preceded by a struct cmsghdr (see Section 5.1), which defines the function and purpose of the data contained in the cmsg_data[] member.",
      "zh-CHS": "每个辅助数据项前面都有一个struct cmsghdr（见第5.1节），它定义了cmsg_data[]成员中包含的数据的功能和用途。"
    },
    {
      "indent": 3,
      "text": "By default, on either style of socket, SCTP will pass no ancillary data. Specific ancillary data items can be enabled with socket options defined for SCTP; see Section 6.2.",
      "zh-CHS": "默认情况下，在任何一种类型的套接字上，SCTP都不会传递任何辅助数据。可以使用为SCTP定义的套接字选项启用特定的辅助数据项；见第6.2节。"
    },
    {
      "indent": 3,
      "text": "Note that all ancillary types are of fixed length; see Section 5.2 for further discussion on this. These data structures use struct sockaddr_storage (defined in [RFC3493]) as a portable, fixed-length address format.",
      "zh-CHS": "请注意，所有辅助类型均为固定长度；有关这方面的进一步讨论，请参见第5.2节。这些数据结构使用struct sockaddr_存储（在[RFC3493]中定义）作为可移植的固定长度地址格式。"
    },
    {
      "indent": 3,
      "text": "Other protocols may also provide ancillary data to the socket layer consumer. These ancillary data items from other protocols may intermingle with SCTP data. For example, the IPv6 sockets API definitions ([RFC3542] and [RFC3493]) define a number of ancillary data items. If a sockets API consumer enables delivery of both SCTP and IPv6 ancillary data, they both may appear in the same msg_control buffer in any order. An application may thus need to handle other types of ancillary data besides those passed by SCTP.",
      "zh-CHS": "其他协议也可以向套接字层消费者提供辅助数据。来自其他协议的这些辅助数据项可能与SCTP数据混合。例如，IPv6套接字API定义（[RFC3542]和[RFC3493]）定义了许多辅助数据项。如果套接字API使用者同时启用SCTP和IPv6辅助数据的传递，则它们可能以任意顺序出现在同一msg_控制缓冲区中。因此，应用程序可能需要处理SCTP传递的辅助数据之外的其他类型的辅助数据。"
    },
    {
      "indent": 3,
      "text": "The sockets application must provide a buffer large enough to accommodate all ancillary data provided via recvmsg(). If the buffer is not large enough, the ancillary data will be truncated and the msghdr's msg_flags will include MSG_CTRUNC.",
      "zh-CHS": "套接字应用程序必须提供足够大的缓冲区，以容纳通过recvmsg（）提供的所有辅助数据。如果缓冲区不够大，辅助数据将被截断，msghdr的msg_标志将包括msg_CTRUNC。"
    },
    {
      "indent": 0,
      "text": "5.3.1. SCTP Initiation Structure (SCTP_INIT)",
      "section_title": true,
      "zh-CHS": "5.3.1. SCTP起始结构（SCTP_INIT）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure provides information for initializing new SCTP associations with sendmsg(). The SCTP_INITMSG socket option uses this same data structure. This structure is not used for recvmsg().",
      "zh-CHS": "此cmsghdr结构提供有关使用sendmsg（）初始化新SCTP关联的信息。SCTP_INITMSG套接字选项使用相同的数据结构。此结构不用于recvmsg（）。"
    },
    {
      "indent": 12,
      "text": "+--------------+-----------+---------------------+\n| cmsg_level   | cmsg_type | cmsg_data[]         |\n+--------------+-----------+---------------------+\n| IPPROTO_SCTP | SCTP_INIT | struct sctp_initmsg |\n+--------------+-----------+---------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_initmsg structure is defined below:",
      "zh-CHS": "sctp_initmsg结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_initmsg {\n  uint16_t sinit_num_ostreams;\n  uint16_t sinit_max_instreams;\n  uint16_t sinit_max_attempts;\n  uint16_t sinit_max_init_timeo;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sinit_num_ostreams: This is an integer representing the number of streams to which the application wishes to be able to send. This number is confirmed in the SCTP_COMM_UP notification and must be verified, since it is a negotiated number with the remote endpoint. The default value of 0 indicates the use of the endpoint's default value.",
      "zh-CHS": "sinit_num_ostreams：这是一个整数，表示应用程序希望能够发送到的流的数量。此号码在SCTP_通信通知中确认，并且必须进行验证，因为它是与远程端点协商的号码。默认值0表示使用端点的默认值。"
    },
    {
      "indent": 3,
      "text": "sinit_max_instreams: This value represents the maximum number of inbound streams the application is prepared to support. This value is bounded by the actual implementation. In other words, the user may be able to support more streams than the operating system. In such a case, the operating-system limit overrides the value requested by the user. The default value of 0 indicates the use of the endpoint's default value.",
      "zh-CHS": "sinit_max_instreams：此值表示应用程序准备支持的最大入站流数。此值受实际实现的限制。换句话说，用户可以支持比操作系统更多的流。在这种情况下，操作系统限制将覆盖用户请求的值。默认值0表示使用端点的默认值。"
    },
    {
      "indent": 3,
      "text": "sinit_max_attempts: This integer specifies how many attempts the SCTP endpoint should make at resending the INIT. This value overrides the system SCTP 'Max.Init.Retransmits' value. The default value of 0 indicates the use of the endpoint's default value. This is normally set to the system's default 'Max.Init.Retransmit' value.",
      "zh-CHS": "sinit_max_尝试次数：该整数指定SCTP端点在重新发送INIT时应进行的尝试次数。此值覆盖系统SCTP“Max.Init.Retransmits”值。默认值0表示使用端点的默认值。这通常设置为系统的默认“Max.Init.Retransmit”值。"
    },
    {
      "indent": 3,
      "text": "sinit_max_init_timeo: This value represents the largest timeout or retransmission timeout (RTO) value (in milliseconds) to use in attempting an INIT. Normally, the 'RTO.Max' is used to limit the doubling of the RTO upon timeout. For the INIT message, this value may override 'RTO.Max'. This value must not influence 'RTO.Max' during data transmission and is only used to bound the initial setup time. A default value of 0 indicates the use of the endpoint's default value. This is normally set to the system's 'RTO.Max' value (60 seconds).",
      "zh-CHS": "sinit_max_init_timeo：此值表示尝试初始化时使用的最大超时或重传超时（RTO）值（以毫秒为单位）。通常，“RTO.Max”用于限制超时时RTO的加倍。对于INIT消息，此值可能会覆盖“RTO.Max”。此值在数据传输期间不得影响“RTO.Max”，仅用于限制初始设置时间。默认值0表示使用端点的默认值。这通常设置为系统的“RTO.Max”值（60秒）。"
    },
    {
      "indent": 0,
      "text": "5.3.2. SCTP Header Information Structure (SCTP_SNDRCV) - DEPRECATED",
      "section_title": true,
      "zh-CHS": "5.3.2. SCTP头信息结构（SCTP_SNDRCV）-已弃用"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure specifies SCTP options for sendmsg() and describes SCTP header information about a received message through recvmsg(). This structure mixes the send and receive path. SCTP_SNDINFO (described in Section 5.3.4) and SCTP_RCVINFO (described in Section 5.3.5) split this information. These structures should be used, when possible, since SCTP_SNDRCV is deprecated.",
      "zh-CHS": "此cmsghdr结构指定sendmsg（）的SCTP选项，并描述有关通过recvmsg（）接收的消息的SCTP头信息。此结构混合了发送和接收路径。SCTP_SNDINFO（如第5.3.4节所述）和SCTP_RCVINFO（如第5.3.5节所述）拆分此信息。如果可能，应使用这些结构，因为不推荐使用SCTP_SNDRCV。"
    },
    {
      "indent": 10,
      "text": "+--------------+-------------+------------------------+\n| cmsg_level   | cmsg_type   | cmsg_data[]            |\n+--------------+-------------+------------------------+\n| IPPROTO_SCTP | SCTP_SNDRCV | struct sctp_sndrcvinfo |\n+--------------+-------------+------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_sndrcvinfo structure is defined below:",
      "zh-CHS": "sctp_sndrcvinfo结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_sndrcvinfo {\n  uint16_t sinfo_stream;\n  uint16_t sinfo_ssn;\n  uint16_t sinfo_flags;\n  uint32_t sinfo_ppid;\n  uint32_t sinfo_context;\n  uint32_t sinfo_timetolive;\n  uint32_t sinfo_tsn;\n  uint32_t sinfo_cumtsn;\n  sctp_assoc_t sinfo_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sinfo_stream: For recvmsg(), the SCTP stack places the message's stream number in this value. For sendmsg(), this value holds the stream number to which the application wishes to send this message. If a sender specifies an invalid stream number, an error indication is returned and the call fails.",
      "zh-CHS": "sinfo_stream：对于recvmsg（），SCTP堆栈将消息的流号放在该值中。对于sendmsg（），此值保存应用程序希望向其发送此消息的流编号。如果发送方指定了无效的流号，则返回错误指示，调用失败。"
    },
    {
      "indent": 3,
      "text": "sinfo_ssn: For recvmsg(), this value contains the stream sequence number that the remote endpoint placed in the DATA chunk. For fragmented messages, this is the same number for all deliveries of the message (if more than one recvmsg() is needed to read the message). The sendmsg() call will ignore this parameter.",
      "zh-CHS": "sinfo_ssn：对于recvmsg（），此值包含远程端点放置在数据块中的流序列号。对于分段消息，对于消息的所有传递，这是相同的数字（如果需要多个recvmsg（）来读取消息）。sendmsg（）调用将忽略此参数。"
    },
    {
      "indent": 3,
      "text": "sinfo_flags: This field may contain any of the following flags and is composed of a bitwise OR of these values.",
      "zh-CHS": "sinfo_标志：此字段可能包含以下任何标志，并由按位或这些值组成。"
    },
    {
      "indent": 6,
      "text": "recvmsg() flags:",
      "zh-CHS": "recvmsg（）标志："
    },
    {
      "indent": 9,
      "text": "SCTP_UNORDERED: This flag is present when the message was sent unordered.",
      "zh-CHS": "SCTP_UNORDERED：消息无序发送时，此标志存在。"
    },
    {
      "indent": 6,
      "text": "sendmsg() flags:",
      "zh-CHS": "sendmsg（）标志："
    },
    {
      "indent": 9,
      "text": "SCTP_UNORDERED: This flag requests the unordered delivery of the message. If this flag is clear, the datagram is considered an ordered send.",
      "zh-CHS": "SCTP_UNORDERED：此标志请求消息的无序传递。如果清除此标志，则数据报被视为有序发送。"
    },
    {
      "indent": 9,
      "text": "SCTP_ADDR_OVER: This flag, for a one-to-many style socket, requests that the SCTP stack override the primary destination address with the address found with the sendto/ sendmsg call.",
      "zh-CHS": "SCTP_ADDR_OVER：对于一对多样式套接字，此标志请求SCTP堆栈使用sendto/sendmsg调用中找到的地址覆盖主目标地址。"
    },
    {
      "indent": 9,
      "text": "SCTP_ABORT: Setting this flag causes the specified association to abort by sending an ABORT message to the peer. The ABORT chunk will contain an error cause of 'User Initiated Abort' with cause code 12. The cause-specific information of this error cause is provided in msg_iov.",
      "zh-CHS": "SCTP_ABORT：设置此标志会通过向对等方发送中止消息，导致指定的关联中止。中止区块将包含“用户启动中止”的错误原因，原因代码为12。此错误原因的原因特定信息在msg_iov中提供。"
    },
    {
      "indent": 9,
      "text": "SCTP_EOF: Setting this flag invokes the SCTP graceful shutdown procedure on the specified association. Graceful shutdown assures that all data queued by both endpoints is successfully transmitted before closing the association.",
      "zh-CHS": "SCTP_EOF：设置此标志将调用指定关联上的SCTP正常关闭过程。优雅关闭可确保在关闭关联之前成功传输两个端点排队的所有数据。"
    },
    {
      "indent": 9,
      "text": "SCTP_SENDALL: This flag, if set, will cause a one-to-many style socket to send the message to all associations that are currently established on this socket. For the one-to-one style socket, this flag has no effect.",
      "zh-CHS": "SCTP_SENDALL：如果设置此标志，将导致一对多样式套接字向当前在此套接字上建立的所有关联发送消息。对于一对一样式的套接字，此标志无效。"
    },
    {
      "indent": 3,
      "text": "sinfo_ppid: This value in sendmsg() is an unsigned integer that is passed to the remote end in each user message. In recvmsg(), this value is the same information that was passed by the upper layer in the peer application. Please note that the SCTP stack performs no byte order modification of this field. For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the htonl() computation.",
      "zh-CHS": "sinfo_ppid:sendmsg（）中的这个值是一个无符号整数，在每个用户消息中传递给远程端。在recvmsg（）中，此值与上层在对等应用程序中传递的信息相同。请注意，SCTP堆栈不执行此字段的字节顺序修改。例如，如果数据块必须包含网络字节顺序的给定值，则SCTP用户必须执行htonl（）计算。"
    },
    {
      "indent": 3,
      "text": "sinfo_context: This value is an opaque 32-bit context datum that is used in the sendmsg() function. This value is passed back to the upper layer if an error occurs on the send of a message and is retrieved with each undelivered message.",
      "zh-CHS": "sinfo_context：此值是sendmsg（）函数中使用的不透明32位上下文数据。如果在发送消息时发生错误，则此值会传回上层，并随每个未送达的消息一起检索。"
    },
    {
      "indent": 3,
      "text": "sinfo_timetolive: For the sending side, this field contains the message's time to live, in milliseconds. The sending side will expire the message within the specified time period if the message has not been sent to the peer within this time period. This value will override any default value set using any socket option. Also note that the value of 0 is special in that it indicates no timeout should occur on this message.",
      "zh-CHS": "sinfo_timetolive：对于发送端，此字段包含消息的生存时间，以毫秒为单位。如果消息在此时间段内未发送给对等方，则发送端将在指定的时间段内使消息过期。此值将覆盖使用任何套接字选项设置的任何默认值。还请注意，0的值很特殊，因为它表示此消息不应超时。"
    },
    {
      "indent": 3,
      "text": "sinfo_tsn: For the receiving side, this field holds a Transmission Sequence Number (TSN) that was assigned to one of the SCTP DATA chunks. For the sending side, it is ignored.",
      "zh-CHS": "sinfo_tsn：对于接收端，该字段保存分配给其中一个SCTP数据块的传输序列号（tsn）。对于发送端，它被忽略。"
    },
    {
      "indent": 3,
      "text": "sinfo_cumtsn: This field will hold the current cumulative TSN as known by the underlying SCTP layer. Note that this field is ignored when sending.",
      "zh-CHS": "sinfo_cumtsn：此字段将保存当前累积TSN，如底层SCTP层所知。请注意，发送时忽略此字段。"
    },
    {
      "indent": 3,
      "text": "sinfo_assoc_id: The association handle field, sinfo_assoc_id, holds the identifier for the association announced in the SCTP_COMM_UP notification. All notifications for a given association have the same identifier. This field is ignored for one-to-one style sockets.",
      "zh-CHS": "sinfo_assoc_id：关联句柄字段sinfo_assoc_id保存SCTP_通信通知中宣布的关联的标识符。给定关联的所有通知都具有相同的标识符。对于一对一样式的套接字，此字段将被忽略。"
    },
    {
      "indent": 3,
      "text": "An sctp_sndrcvinfo item always corresponds to the data in msg_iov.",
      "zh-CHS": "sctp_sndrcvinfo项始终对应于msg_iov中的数据。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Extended SCTP Header Information Structure (SCTP_EXTRCV) - DEPRECATED",
      "zh-CHS": "5.3.3. 扩展SCTP标头信息结构（SCTP_EXTRACV）-已弃用"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure specifies SCTP options for SCTP header information about a received message via recvmsg(). Note that this structure is an extended version of SCTP_SNDRCV (see Section 5.3.2) and will only be received if the user has set the socket option SCTP_USE_EXT_RCVINFO (see Section 8.1.22) to true in addition to any event subscription needed to receive ancillary data. Note that data in the next message is not valid unless the current message is completely read, i.e., unless the MSG_EOR is set; in other words, if the application has more data to read from the current message, then no next-message information will be available.",
      "zh-CHS": "此cmsghdr结构为通过recvmsg（）接收的消息的SCTP头信息指定SCTP选项。请注意，此结构是SCTP_SNDRCV的扩展版本（见第5.3.2节），仅当用户将套接字选项SCTP_USE_EXT_RCVINFO（见第8.1.22节）设置为true，以及接收辅助数据所需的任何事件订阅时，才会接收此结构。请注意，除非完全读取当前消息（即，除非设置了MSG_EOR），否则下一条消息中的数据无效；换句话说，如果应用程序要从当前消息中读取更多数据，则下一条消息信息将不可用。"
    },
    {
      "indent": 3,
      "text": "SCTP_NXTINFO (described in Section 5.3.6) should be used when possible, since SCTP_EXTRCV is considered deprecated.",
      "zh-CHS": "可能时应使用SCTP_NXTINFO（见第5.3.6节），因为SCTP_EXTRCV被视为不推荐使用。"
    },
    {
      "indent": 10,
      "text": "+--------------+-------------+------------------------+\n| cmsg_level   | cmsg_type   | cmsg_data[]            |\n+--------------+-------------+------------------------+\n| IPPROTO_SCTP | SCTP_EXTRCV | struct sctp_extrcvinfo |\n+--------------+-------------+------------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_extrcvinfo structure is defined below:",
      "zh-CHS": "sctp_ExtCVInfo结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_extrcvinfo {\n  uint16_t sinfo_stream;\n  uint16_t sinfo_ssn;\n  uint16_t sinfo_flags;\n  uint32_t sinfo_ppid;\n  uint32_t sinfo_context;\n  uint32_t sinfo_pr_value;\n  uint32_t sinfo_tsn;\n  uint32_t sinfo_cumtsn;\n  uint16_t serinfo_next_flags;\n  uint16_t serinfo_next_stream;\n  uint32_t serinfo_next_aid;\n  uint32_t serinfo_next_length;\n  uint32_t serinfo_next_ppid;\n  sctp_assoc_t sinfo_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sinfo_*: Please see Section 5.3.2 for details for these fields.",
      "zh-CHS": "sinfo_u*：有关这些字段的详细信息，请参见第5.3.2节。"
    },
    {
      "indent": 3,
      "text": "serinfo_next_flags: This bitmask will hold one or more of the following values:",
      "zh-CHS": "serinfo_next_标志：此位掩码将包含以下一个或多个值："
    },
    {
      "indent": 6,
      "text": "SCTP_NEXT_MSG_AVAIL: This bit, when set to 1, indicates that next-message information is available; i.e., next_stream, next_aid, next_length, and next_ppid fields all have valid values. If this bit is set to 0, then these fields are not valid and should be ignored.",
      "zh-CHS": "SCTP_NEXT_MSG_AVAIL：此位设置为1时，表示下一条消息信息可用；i、 例如，next_stream、next_aid、next_length和next_ppid字段都具有有效值。如果此位设置为0，则这些字段无效，应忽略。"
    },
    {
      "indent": 6,
      "text": "SCTP_NEXT_MSG_ISCOMPLETE: This bit, when set, indicates that the next message is completely in the receive buffer. The next_length field thus contains the entire message size. If this flag is set to 0, then the next_length field only contains part of the message size, since the message is still being received (it is being partially delivered).",
      "zh-CHS": "SCTP_NEXT_MSG_ISCOMPLETE：设置此位时，表示下一条消息完全在接收缓冲区中。因此，下一个长度字段包含整个消息大小。如果此标志设置为0，则下一个_长度字段仅包含消息大小的一部分，因为消息仍在接收（部分传递）。"
    },
    {
      "indent": 6,
      "text": "SCTP_NEXT_MSG_IS_UNORDERED: This bit, when set, indicates that the next message to be received was sent by the peer as unordered. If this bit is not set (i.e., the bit is 0) the next message to be read is an ordered message in the stream specified.",
      "zh-CHS": "SCTP_NEXT_MSG_IS_UNORDERED：设置此位时，表示要接收的下一条消息是由对等方以无序方式发送的。如果未设置该位（即，该位为0），则要读取的下一条消息是指定流中的有序消息。"
    },
    {
      "indent": 6,
      "text": "SCTP_NEXT_MSG_IS_NOTIFICATION: This bit, when set, indicates that the next message to be received is not a message from the peer, but instead is a MSG_NOTIFICATION from the local SCTP stack.",
      "zh-CHS": "SCTP_NEXT_MSG_IS_NOTIFICATION：设置此位时，表示要接收的下一条消息不是来自对等方的消息，而是来自本地SCTP堆栈的消息。"
    },
    {
      "indent": 3,
      "text": "serinfo_next_stream: This value, when valid (see serinfo_next_flags), contains the next stream number that will be received on a subsequent call to one of the receive message functions.",
      "zh-CHS": "serinfo_next_stream：此值有效时（请参阅serinfo_next_标志），包含后续调用接收消息函数之一时将接收的下一个流编号。"
    },
    {
      "indent": 3,
      "text": "serinfo_next_aid: This value, when valid (see serinfo_next_flags), contains the next association identifier that will be received on a subsequent call to one of the receive message functions.",
      "zh-CHS": "serinfo_next_aid：此值有效时（请参阅serinfo_next_标志），包含下一个关联标识符，该标识符将在后续调用其中一个接收消息函数时接收。"
    },
    {
      "indent": 3,
      "text": "serinfo_next_length: This value, when valid (see serinfo_next_flags), contains the length of the next message that will be received on a subsequent call to one of the receive message functions. Note that this length may be a partial length, depending on the settings of next_flags.",
      "zh-CHS": "serinfo_next_length：此值有效时（请参阅serinfo_next_标志），包含后续调用接收消息函数之一时将接收的下一条消息的长度。请注意，此长度可能是部分长度，具体取决于next_标志的设置。"
    },
    {
      "indent": 3,
      "text": "serinfo_next_ppid: This value, when valid (see serinfo_next_flags), contains the ppid of the next message that will be received on a subsequent call to one of the receive message functions.",
      "zh-CHS": "serinfo_next_ppid：此值有效时（请参阅serinfo_next_标志），包含下一条消息的ppid，该消息将在后续调用接收消息函数时接收。"
    },
    {
      "indent": 0,
      "text": "5.3.4. SCTP Send Information Structure (SCTP_SNDINFO)",
      "section_title": true,
      "zh-CHS": "5.3.4. SCTP发送信息结构（SCTP_SNDINFO）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure specifies SCTP options for sendmsg().",
      "zh-CHS": "此cmsghdr结构指定sendmsg（）的SCTP选项。"
    },
    {
      "indent": 11,
      "text": "+--------------+--------------+---------------------+\n| cmsg_level   | cmsg_type    | cmsg_data[]         |\n+--------------+--------------+---------------------+\n| IPPROTO_SCTP | SCTP_SNDINFO | struct sctp_sndinfo |\n+--------------+--------------+---------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_sndinfo structure is defined below:",
      "zh-CHS": "sctp_sndinfo结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_sndinfo {\n  uint16_t snd_sid;\n  uint16_t snd_flags;\n  uint32_t snd_ppid;\n  uint32_t snd_context;\n  sctp_assoc_t snd_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "snd_sid: This value holds the stream number to which the application wishes to send this message. If a sender specifies an invalid stream number, an error indication is returned and the call fails.",
      "zh-CHS": "snd_sid：此值保存应用程序希望向其发送此消息的流编号。如果发送方指定了无效的流号，则返回错误指示，调用失败。"
    },
    {
      "indent": 3,
      "text": "snd_flags: This field may contain any of the following flags and is composed of a bitwise OR of these values.",
      "zh-CHS": "snd_标志：此字段可能包含以下任何标志，并由按位或这些值组成。"
    },
    {
      "indent": 6,
      "text": "SCTP_UNORDERED: This flag requests the unordered delivery of the message. If this flag is clear, the datagram is considered an ordered send.",
      "zh-CHS": "SCTP_UNORDERED：此标志请求消息的无序传递。如果清除此标志，则数据报被视为有序发送。"
    },
    {
      "indent": 6,
      "text": "SCTP_ADDR_OVER: This flag, for a one-to-many style socket, requests that the SCTP stack override the primary destination address with the address found with the sendto()/sendmsg call.",
      "zh-CHS": "SCTP_ADDR_OVER：对于一对多样式套接字，此标志请求SCTP堆栈使用sendto（）/sendmsg调用中找到的地址覆盖主目标地址。"
    },
    {
      "indent": 6,
      "text": "SCTP_ABORT: Setting this flag causes the specified association to abort by sending an ABORT message to the peer. The ABORT chunk will contain an error cause of 'User Initiated Abort' with cause code 12. The cause-specific information of this error cause is provided in msg_iov.",
      "zh-CHS": "SCTP_ABORT：设置此标志会通过向对等方发送中止消息，导致指定的关联中止。中止区块将包含“用户启动中止”的错误原因，原因代码为12。此错误原因的原因特定信息在msg_iov中提供。"
    },
    {
      "indent": 6,
      "text": "SCTP_EOF: Setting this flag invokes the SCTP graceful shutdown procedures on the specified association. Graceful shutdown assures that all data queued by both endpoints is successfully transmitted before closing the association.",
      "zh-CHS": "SCTP_EOF：设置此标志将调用指定关联上的SCTP正常关闭过程。优雅关闭可确保在关闭关联之前成功传输两个端点排队的所有数据。"
    },
    {
      "indent": 6,
      "text": "SCTP_SENDALL: This flag, if set, will cause a one-to-many style socket to send the message to all associations that are currently established on this socket. For the one-to-one style socket, this flag has no effect.",
      "zh-CHS": "SCTP_SENDALL：如果设置此标志，将导致一对多样式套接字向当前在此套接字上建立的所有关联发送消息。对于一对一样式的套接字，此标志无效。"
    },
    {
      "indent": 3,
      "text": "snd_ppid: This value in sendmsg() is an unsigned integer that is passed to the remote end in each user message. Please note that the SCTP stack performs no byte order modification of this field. For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the htonl() computation.",
      "zh-CHS": "snd_ppid:sendmsg（）中的这个值是一个无符号整数，在每个用户消息中传递给远程端。请注意，SCTP堆栈不执行此字段的字节顺序修改。例如，如果数据块必须包含网络字节顺序的给定值，则SCTP用户必须执行htonl（）计算。"
    },
    {
      "indent": 3,
      "text": "snd_context: This value is an opaque 32-bit context datum that is used in the sendmsg() function. This value is passed back to the upper layer if an error occurs on the send of a message and is retrieved with each undelivered message.",
      "zh-CHS": "snd_上下文：此值是sendmsg（）函数中使用的不透明32位上下文数据。如果在发送消息时发生错误，则此值会传回上层，并随每个未送达的消息一起检索。"
    },
    {
      "indent": 3,
      "text": "snd_assoc_id: The association handle field, sinfo_assoc_id, holds the identifier for the association announced in the SCTP_COMM_UP notification. All notifications for a given association have the same identifier. This field is ignored for one-to-one style sockets.",
      "zh-CHS": "snd_assoc_id：关联句柄字段sinfo_assoc_id保存SCTP_通信通知中宣布的关联的标识符。给定关联的所有通知都具有相同的标识符。对于一对一样式的套接字，此字段将被忽略。"
    },
    {
      "indent": 3,
      "text": "An sctp_sndinfo item always corresponds to the data in msg_iov.",
      "zh-CHS": "sctp_sndinfo项始终与msg_iov中的数据相对应。"
    },
    {
      "indent": 0,
      "text": "5.3.5. SCTP Receive Information Structure (SCTP_RCVINFO)",
      "section_title": true,
      "zh-CHS": "5.3.5. SCTP接收信息结构（SCTP_RCVINFO）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure describes SCTP receive information about a received message through recvmsg().",
      "zh-CHS": "此cmsghdr结构描述了SCTP通过recvmsg（）接收有关已接收消息的信息。"
    },
    {
      "indent": 3,
      "text": "To enable the delivery of this information, an application must use the SCTP_RECVRCVINFO socket option (see Section 8.1.29).",
      "zh-CHS": "为了能够传递此信息，应用程序必须使用SCTP_RECVRCVINFO套接字选项（见第8.1.29节）。"
    },
    {
      "indent": 11,
      "text": "+--------------+--------------+---------------------+\n| cmsg_level   | cmsg_type    | cmsg_data[]         |\n+--------------+--------------+---------------------+\n| IPPROTO_SCTP | SCTP_RCVINFO | struct sctp_rcvinfo |\n+--------------+--------------+---------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_rcvinfo structure is defined below:",
      "zh-CHS": "sctp_rcvinfo结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_rcvinfo {\n  uint16_t rcv_sid;\n  uint16_t rcv_ssn;\n  uint16_t rcv_flags;\n  uint32_t rcv_ppid;\n  uint32_t rcv_tsn;\n  uint32_t rcv_cumtsn;\n  uint32_t rcv_context;\n  sctp_assoc_t rcv_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "rcv_sid: The SCTP stack places the message's stream number in this value.",
      "zh-CHS": "rcv_sid:SCTP堆栈将消息的流号放在该值中。"
    },
    {
      "indent": 3,
      "text": "rcv_ssn: This value contains the stream sequence number that the remote endpoint placed in the DATA chunk. For fragmented messages, this is the same number for all deliveries of the message (if more than one recvmsg() is needed to read the message).",
      "zh-CHS": "rcv_ssn：此值包含远程端点放置在数据块中的流序列号。对于分段消息，对于消息的所有传递，这是相同的数字（如果需要多个recvmsg（）来读取消息）。"
    },
    {
      "indent": 3,
      "text": "rcv_flags: This field may contain any of the following flags and is composed of a bitwise OR of these values.",
      "zh-CHS": "rcv_标志：此字段可能包含以下任何标志，并由按位或这些值组成。"
    },
    {
      "indent": 6,
      "text": "SCTP_UNORDERED: This flag is present when the message was sent unordered.",
      "zh-CHS": "SCTP_UNORDERED：消息无序发送时，此标志存在。"
    },
    {
      "indent": 3,
      "text": "rcv_ppid: This value is the same information that was passed by the upper layer in the peer application. Please note that the SCTP stack performs no byte order modification of this field. For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the ntohl() computation.",
      "zh-CHS": "rcv_ppid：该值与上层在对等应用程序中传递的信息相同。请注意，SCTP堆栈不执行此字段的字节顺序修改。例如，如果数据块必须包含网络字节顺序的给定值，则SCTP用户必须执行ntohl（）计算。"
    },
    {
      "indent": 3,
      "text": "rcv_tsn: This field holds a TSN that was assigned to one of the SCTP DATA chunks.",
      "zh-CHS": "rcv_tsn：此字段保存分配给其中一个SCTP数据块的tsn。"
    },
    {
      "indent": 3,
      "text": "rcv_cumtsn: This field will hold the current cumulative TSN as known by the underlying SCTP layer.",
      "zh-CHS": "rcv_cumtsn：此字段将保存底层SCTP层已知的当前累积TSN。"
    },
    {
      "indent": 3,
      "text": "rcv_context: This value is an opaque 32-bit context datum that was set by the user with the SCTP_CONTEXT socket option. This value is passed back to the upper layer if an error occurs on the send of a message and is retrieved with each undelivered message.",
      "zh-CHS": "rcv_上下文：此值是一个不透明的32位上下文数据，由用户使用SCTP_上下文套接字选项设置。如果在发送消息时发生错误，则此值会传回上层，并随每个未送达的消息一起检索。"
    },
    {
      "indent": 3,
      "text": "rcv_assoc_id: The association handle field, sinfo_assoc_id, holds the identifier for the association announced in the SCTP_COMM_UP notification. All notifications for a given association have the same identifier. This field is ignored for one-to-one style sockets.",
      "zh-CHS": "rcv_assoc_id：关联句柄字段sinfo_assoc_id保存SCTP通信通知中宣布的关联的标识符。给定关联的所有通知都具有相同的标识符。对于一对一样式的套接字，此字段将被忽略。"
    },
    {
      "indent": 3,
      "text": "An sctp_rcvinfo item always corresponds to the data in msg_iov.",
      "zh-CHS": "sctp_rcvinfo项始终与msg_iov中的数据相对应。"
    },
    {
      "indent": 0,
      "text": "5.3.6. SCTP Next Receive Information Structure (SCTP_NXTINFO)",
      "section_title": true,
      "zh-CHS": "5.3.6. SCTP下一接收信息结构（SCTP_NXTINFO）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure describes SCTP receive information of the next message that will be delivered through recvmsg() if this information is already available when delivering the current message.",
      "zh-CHS": "此cmsghdr结构描述了SCTP接收下一条消息的信息，如果在传递当前消息时该信息已可用，则该信息将通过recvmsg（）传递。"
    },
    {
      "indent": 3,
      "text": "To enable the delivery of this information, an application must use the SCTP_RECVNXTINFO socket option (see Section 8.1.30).",
      "zh-CHS": "为了能够传递此信息，应用程序必须使用SCTP_RECVNXTINFO套接字选项（参见第8.1.30节）。"
    },
    {
      "indent": 11,
      "text": "+--------------+--------------+---------------------+\n| cmsg_level   | cmsg_type    | cmsg_data[]         |\n+--------------+--------------+---------------------+\n| IPPROTO_SCTP | SCTP_NXTINFO | struct sctp_nxtinfo |\n+--------------+--------------+---------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_nxtinfo structure is defined below:",
      "zh-CHS": "sctp_nxtinfo结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_nxtinfo {\n  uint16_t nxt_sid;\n  uint16_t nxt_flags;\n  uint32_t nxt_ppid;\n  uint32_t nxt_length;\n  sctp_assoc_t nxt_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "nxt_sid: The SCTP stack places the next message's stream number in this value.",
      "zh-CHS": "nxt_sid:SCTP堆栈将下一条消息的流号放在该值中。"
    },
    {
      "indent": 3,
      "text": "nxt_flags: This field may contain any of the following flags and is composed of a bitwise OR of these values.",
      "zh-CHS": "nxt_标志：此字段可能包含以下任何标志，并由按位或这些值组成。"
    },
    {
      "indent": 6,
      "text": "SCTP_UNORDERED: This flag is present when the next message was sent unordered.",
      "zh-CHS": "SCTP_无序：下一条消息无序发送时，此标志存在。"
    },
    {
      "indent": 6,
      "text": "SCTP_COMPLETE: This flag indicates that the entire message has been received and is in the socket buffer. Note that this has special implications with respect to the nxt_length field; see the description for nxt_length below.",
      "zh-CHS": "SCTP_COMPLETE：此标志表示已接收到整个消息，并且在套接字缓冲区中。注意，这对于nxt_长度字段具有特殊含义；请参见下面关于nxt_长度的说明。"
    },
    {
      "indent": 6,
      "text": "SCTP_NOTIFICATION: This flag is present when the next message is not a user message but instead is a notification.",
      "zh-CHS": "SCTP_通知：当下一条消息不是用户消息而是通知时，此标志出现。"
    },
    {
      "indent": 3,
      "text": "nxt_ppid: This value is the same information that was passed by the upper layer in the peer application for the next message. Please note that the SCTP stack performs no byte order modification of this field. For example, if the DATA chunk has to contain a given value in network byte order, the SCTP user has to perform the ntohl() computation.",
      "zh-CHS": "nxt_ppid：该值与上层在对等应用程序中为下一条消息传递的信息相同。请注意，SCTP堆栈不执行此字段的字节顺序修改。例如，如果数据块必须包含网络字节顺序的给定值，则SCTP用户必须执行ntohl（）计算。"
    },
    {
      "indent": 3,
      "text": "nxt_length: This value is the length of the message currently within the socket buffer. This might NOT be the entire length of the message, since a partial delivery may be in progress. Only if the flag SCTP_COMPLETE is set in the nxt_flags field does this field represent the size of the entire next message.",
      "zh-CHS": "nxt_length：该值是套接字缓冲区中当前消息的长度。这可能不是消息的全部长度，因为可能正在进行部分传递。只有在nxt_标志字段中设置了标志SCTP_COMPLETE时，此字段才表示整个下一条消息的大小。"
    },
    {
      "indent": 3,
      "text": "nxt_assoc_id: The association handle field of the next message, nxt_assoc_id, holds the identifier for the association announced in the SCTP_COMM_UP notification. All notifications for a given association have the same identifier. This field is ignored for one-to-one style sockets.",
      "zh-CHS": "nxt_assoc_id：下一条消息的关联句柄字段nxt_assoc_id包含SCTP_通信通知中宣布的关联的标识符。给定关联的所有通知都具有相同的标识符。对于一对一样式的套接字，此字段将被忽略。"
    },
    {
      "indent": 0,
      "text": "5.3.7. SCTP PR-SCTP Information Structure (SCTP_PRINFO)",
      "section_title": true,
      "zh-CHS": "5.3.7. SCTP PR-SCTP信息结构（SCTP_PRINFO）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure specifies SCTP options for sendmsg().",
      "zh-CHS": "此cmsghdr结构指定sendmsg（）的SCTP选项。"
    },
    {
      "indent": 12,
      "text": "+--------------+-------------+--------------------+\n| cmsg_level   | cmsg_type   | cmsg_data[]        |\n+--------------+-------------+--------------------+\n| IPPROTO_SCTP | SCTP_PRINFO | struct sctp_prinfo |\n+--------------+-------------+--------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_prinfo structure is defined below:",
      "zh-CHS": "sctp_prinfo结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_prinfo {\n  uint16_t pr_policy;\n  uint32_t pr_value;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "pr_policy: This specifies which Partially Reliable SCTP (PR-SCTP) policy is used. Using SCTP_PR_SCTP_NONE results in a reliable transmission. When SCTP_PR_SCTP_TTL is used, the PR-SCTP policy \"timed reliability\" defined in [RFC3758] is used. In this case, the lifetime is provided in pr_value.",
      "zh-CHS": "pr_策略：指定使用哪个部分可靠的SCTP（pr-SCTP）策略。使用SCTP_PR_SCTP_NONE可实现可靠的传输。当使用SCTP_PR_SCTP_TTL时，使用[RFC3758]中定义的PR-SCTP策略“定时可靠性”。在这种情况下，寿命以pr_值提供。"
    },
    {
      "indent": 3,
      "text": "pr_value: The meaning of this field depends on the PR-SCTP policy specified by the pr_policy field. It is ignored when SCTP_PR_SCTP_NONE is specified. In the case of SCTP_PR_SCTP_TTL, the lifetime in milliseconds is specified.",
      "zh-CHS": "pr_值：此字段的含义取决于pr_策略字段指定的pr-SCTP策略。当指定SCTP_PR_SCTP_NONE时，它将被忽略。在SCTP_PR_SCTP_TTL的情况下，以毫秒为单位指定生存期。"
    },
    {
      "indent": 3,
      "text": "An sctp_prinfo item always corresponds to the data in msg_iov.",
      "zh-CHS": "sctp_prinfo项始终与msg_iov中的数据相对应。"
    },
    {
      "indent": 0,
      "text": "5.3.8. SCTP AUTH Information Structure (SCTP_AUTHINFO)",
      "section_title": true,
      "zh-CHS": "5.3.8. SCTP AUTH信息结构（SCTP\\U AUTHINFO）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure specifies SCTP options for sendmsg().",
      "zh-CHS": "此cmsghdr结构指定sendmsg（）的SCTP选项。"
    },
    {
      "indent": 10,
      "text": "+--------------+---------------+----------------------+\n| cmsg_level   | cmsg_type     | cmsg_data[]          |\n+--------------+---------------+----------------------+\n| IPPROTO_SCTP | SCTP_AUTHINFO | struct sctp_authinfo |\n+--------------+---------------+----------------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sctp_authinfo structure is defined below:",
      "zh-CHS": "sctp_authinfo结构定义如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_authinfo {\n  uint16_t auth_keynumber;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "auth_keynumber: This specifies the shared key identifier used for sending the user message.",
      "zh-CHS": "auth_keynumber：指定用于发送用户消息的共享密钥标识符。"
    },
    {
      "indent": 3,
      "text": "An sctp_authinfo item always corresponds to the data in msg_iov. Please note that the SCTP implementation must not bundle user messages that need to be authenticated using different shared key identifiers.",
      "zh-CHS": "sctp_authinfo项始终与msg_iov中的数据相对应。请注意，SCTP实现不能捆绑需要使用不同共享密钥标识符进行身份验证的用户消息。"
    },
    {
      "indent": 0,
      "text": "5.3.9. SCTP Destination IPv4 Address Structure (SCTP_DSTADDRV4)",
      "section_title": true,
      "zh-CHS": "5.3.9. SCTP目标IPv4地址结构（SCTPdstaddrv4）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure specifies SCTP options for sendmsg().",
      "zh-CHS": "此cmsghdr结构指定sendmsg（）的SCTP选项。"
    },
    {
      "indent": 12,
      "text": "+--------------+----------------+----------------+\n| cmsg_level   | cmsg_type      | cmsg_data[]    |\n+--------------+----------------+----------------+\n| IPPROTO_SCTP | SCTP_DSTADDRV4 | struct in_addr |\n+--------------+----------------+----------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This ancillary data can be used to provide more than one destination address to sendmsg(). It can be used to implement sctp_sendv() using sendmsg().",
      "zh-CHS": "此辅助数据可用于向sendmsg（）提供多个目标地址。它可用于使用sendmsg（）实现sctp_sendv（）。"
    },
    {
      "indent": 0,
      "text": "5.3.10. SCTP Destination IPv6 Address Structure (SCTP_DSTADDRV6)",
      "section_title": true,
      "zh-CHS": "5.3.10. SCTP目标IPv6地址结构（SCTPdstaddrv6）"
    },
    {
      "indent": 3,
      "text": "This cmsghdr structure specifies SCTP options for sendmsg().",
      "zh-CHS": "此cmsghdr结构指定sendmsg（）的SCTP选项。"
    },
    {
      "indent": 12,
      "text": "+--------------+----------------+-----------------+\n| cmsg_level   | cmsg_type      | cmsg_data[]     |\n+--------------+----------------+-----------------+\n| IPPROTO_SCTP | SCTP_DSTADDRV6 | struct in6_addr |\n+--------------+----------------+-----------------+",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "This ancillary data can be used to provide more than one destination address to sendmsg(). It can be used to implement sctp_sendv() using sendmsg().",
      "zh-CHS": "此辅助数据可用于向sendmsg（）提供多个目标地址。它可用于使用sendmsg（）实现sctp_sendv（）。"
    },
    {
      "indent": 0,
      "text": "6. SCTP Events and Notifications",
      "section_title": true,
      "zh-CHS": "6. SCTP事件和通知"
    },
    {
      "indent": 3,
      "text": "An SCTP application may need to understand and process events and errors that happen on the SCTP stack. These events include network status changes, association startups, remote operational errors, and undeliverable messages. All of these can be essential for the application.",
      "zh-CHS": "SCTP应用程序可能需要理解和处理SCTP堆栈上发生的事件和错误。这些事件包括网络状态更改、关联启动、远程操作错误和无法传递的消息。所有这些都是应用程序所必需的。"
    },
    {
      "indent": 3,
      "text": "When an SCTP application layer does a recvmsg(), the message read is normally a data message from a peer endpoint. If the application wishes to have the SCTP stack deliver notifications of non-data events, it sets the appropriate socket option for the notifications it wants. See Section 6.2 for these socket options. When a notification arrives, recvmsg() returns the notification in the application-supplied data buffer via msg_iov, and sets MSG_NOTIFICATION in msg_flags.",
      "zh-CHS": "当SCTP应用层执行recvmsg（）时，读取的消息通常是来自对等端点的数据消息。如果应用程序希望让SCTP堆栈传递非数据事件的通知，它将为所需的通知设置适当的套接字选项。有关这些插座选项，请参见第6.2节。当通知到达时，recvmsg（）通过msg_iov返回应用程序提供的数据缓冲区中的通知，并在msg_标志中设置msg_通知。"
    },
    {
      "indent": 3,
      "text": "This section details the notification structures. Every notification structure carries some common fields that provide general information.",
      "zh-CHS": "本节详细介绍了通知结构。每个通知结构都包含一些提供一般信息的公共字段。"
    },
    {
      "indent": 3,
      "text": "A recvmsg() call will return only one notification at a time. Just as when reading normal data, it may return part of a notification if the msg_iov buffer is not large enough. If a single read is not sufficient, msg_flags will have MSG_EOR clear. The user must finish reading the notification before subsequent data can arrive.",
      "zh-CHS": "recvmsg（）调用一次只返回一个通知。与读取正常数据一样，如果msg_iov缓冲区不够大，它可能会返回部分通知。如果单次读取不够，msg_标志将清除msg_EOR。在后续数据到达之前，用户必须完成通知的读取。"
    },
    {
      "indent": 0,
      "text": "6.1. SCTP Notification Structure",
      "section_title": true,
      "zh-CHS": "6.1. SCTP通知结构"
    },
    {
      "indent": 3,
      "text": "The notification structure is defined as the union of all notification types.",
      "zh-CHS": "通知结构定义为所有通知类型的联合。"
    },
    {
      "indent": 3,
      "text": "union sctp_notification {\n  struct sctp_tlv {\n    uint16_t sn_type; /* Notification type. */\n    uint16_t sn_flags;\n    uint32_t sn_length;\n  } sn_header;\n  struct sctp_assoc_change sn_assoc_change;\n  struct sctp_paddr_change sn_paddr_change;\n  struct sctp_remote_error sn_remote_error;\n  struct sctp_send_failed sn_send_failed;\n  struct sctp_shutdown_event sn_shutdown_event;\n  struct sctp_adaptation_event sn_adaptation_event;\n  struct sctp_pdapi_event sn_pdapi_event;\n  struct sctp_authkey_event sn_auth_event;\n  struct sctp_sender_dry_event sn_sender_dry_event;\n  struct sctp_send_failed_event sn_send_failed_event;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sn_type: The following list describes the SCTP notification and event types for the field sn_type.",
      "zh-CHS": "序列号类型：以下列表描述了字段序列号类型的SCTP通知和事件类型。"
    },
    {
      "indent": 6,
      "text": "SCTP_ASSOC_CHANGE: This tag indicates that an association has either been opened or closed. Refer to Section 6.1.1 for details.",
      "zh-CHS": "SCTP\\ U ASSOC\\ U CHANGE：此标记表示已打开或关闭关联。详见第6.1.1节。"
    },
    {
      "indent": 6,
      "text": "SCTP_PEER_ADDR_CHANGE: This tag indicates that an address that is part of an existing association has experienced a change of state (e.g., a failure or return to service of the reachability of an endpoint via a specific transport address). Please see Section 6.1.2 for data structure details.",
      "zh-CHS": "SCTP_PEER_ADDR_CHANGE：此标记表示作为现有关联一部分的地址经历了状态更改（例如，通过特定传输地址的端点可达性故障或返回服务）。有关数据结构的详细信息，请参见第6.1.2节。"
    },
    {
      "indent": 6,
      "text": "SCTP_REMOTE_ERROR: The attached error message is an Operation Error message received from the remote peer. It includes the complete TLV sent by the remote endpoint. See Section 6.1.3 for the detailed format.",
      "zh-CHS": "SCTP_远程_错误：附加的错误消息是从远程对等方接收的操作错误消息。它包括远程端点发送的完整TLV。详细格式见第6.1.3节。"
    },
    {
      "indent": 6,
      "text": "SCTP_SEND_FAILED_EVENT: The attached datagram could not be sent to the remote endpoint. This structure includes the original SCTP_SNDINFO that was used in sending this message; i.e., this structure uses the sctp_sndinfo per Section 6.1.11.",
      "zh-CHS": "SCTP_发送_失败_事件：无法将附加的数据报发送到远程终结点。此结构包括发送此消息时使用的原始SCTP_SNDINFO；i、 e.根据第6.1.11节，该结构使用sctp_sndinfo。"
    },
    {
      "indent": 6,
      "text": "SCTP_SHUTDOWN_EVENT: The peer has sent a SHUTDOWN. No further data should be sent on this socket.",
      "zh-CHS": "SCTP_SHUTDOWN_事件：对等方已发送关机消息。不应在此套接字上发送更多数据。"
    },
    {
      "indent": 6,
      "text": "SCTP_ADAPTATION_INDICATION: This notification holds the peer's indicated adaptation layer. Please see Section 6.1.6.",
      "zh-CHS": "SCTP_适配_指示：此通知保存对等方指示的适配层。请参见第6.1.6节。"
    },
    {
      "indent": 6,
      "text": "SCTP_PARTIAL_DELIVERY_EVENT: This notification is used to tell a receiver that the partial delivery has been aborted. This may indicate that the association is about to be aborted. Please see Section 6.1.7.",
      "zh-CHS": "SCTP_部分交付事件：此通知用于通知接收方部分交付已中止。这可能表示关联即将中止。请参见第6.1.7节。"
    },
    {
      "indent": 6,
      "text": "SCTP_AUTHENTICATION_EVENT: This notification is used to tell a receiver that either an error occurred on authentication, or a new key was made active. See Section 6.1.8.",
      "zh-CHS": "SCTP_AUTHENTICATION_事件：此通知用于通知接收者身份验证时发生错误或新密钥已激活。见第6.1.8节。"
    },
    {
      "indent": 6,
      "text": "SCTP_SENDER_DRY_EVENT: This notification is used to inform the application that the sender has no more user data queued for transmission or retransmission. See Section 6.1.9.",
      "zh-CHS": "SCTP_SENDER_DRY_事件：此通知用于通知应用程序发送方没有更多的用户数据排队等待传输或重新传输。见第6.1.9节。"
    },
    {
      "indent": 3,
      "text": "sn_flags: These are notification-specific flags.",
      "zh-CHS": "序列号标志：这些是特定于通知的标志。"
    },
    {
      "indent": 3,
      "text": "sn_length: This is the length of the whole sctp_notification structure, including the sn_type, sn_flags, and sn_length fields.",
      "zh-CHS": "sn_长度：这是整个sctp_通知结构的长度，包括sn_类型、sn_标志和sn_长度字段。"
    },
    {
      "indent": 0,
      "text": "6.1.1. SCTP_ASSOC_CHANGE",
      "section_title": true,
      "zh-CHS": "6.1.1. SCTP助理变更"
    },
    {
      "indent": 3,
      "text": "Communication notifications inform the application that an SCTP association has either begun or ended. The identifier for a new association is provided by this notification. The notification information has the following format:",
      "zh-CHS": "通信通知通知应用程序SCTP关联已开始或结束。此通知提供了新关联的标识符。通知信息的格式如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_change {\n  uint16_t sac_type;\n  uint16_t sac_flags;\n  uint32_t sac_length;\n  uint16_t sac_state;\n  uint16_t sac_error;\n  uint16_t sac_outbound_streams;\n  uint16_t sac_inbound_streams;\n  sctp_assoc_t sac_assoc_id;\n  uint8_t  sac_info[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sac_type: This field should be set to SCTP_ASSOC_CHANGE.",
      "zh-CHS": "sac_类型：此字段应设置为SCTP_ASSOC_CHANGE。"
    },
    {
      "indent": 3,
      "text": "sac_flags: This field is currently unused.",
      "zh-CHS": "sac_标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "sac_length: This field is the total length of the notification data, including the notification header.",
      "zh-CHS": "sac_length：此字段是通知数据的总长度，包括通知头。"
    },
    {
      "indent": 3,
      "text": "sac_state: This field holds one of a number of values that communicate the event that happened to the association. These values include",
      "zh-CHS": "sac_状态：此字段保存多个值中的一个，这些值用于传递关联发生的事件。这些值包括"
    },
    {
      "indent": 6,
      "text": "SCTP_COMM_UP: A new association is now ready, and data may be exchanged with this peer. When an association has been established successfully, this notification should be the first one.",
      "zh-CHS": "SCTP_COMM_UP：一个新的关联现在准备就绪，并且可以与该对等方交换数据。成功建立关联后，此通知应为第一个通知。"
    },
    {
      "indent": 6,
      "text": "SCTP_COMM_LOST: The association has failed. The association is now in the closed state. If SEND_FAILED notifications are turned on, an SCTP_COMM_LOST is accompanied by a series of SCTP_SEND_FAILED_EVENT events, one for each outstanding message.",
      "zh-CHS": "SCTP_通信丢失：关联失败。该关联现在处于关闭状态。如果启用发送失败通知，则SCTP通信丢失会伴随一系列SCTP发送失败事件，每个未完成消息对应一个事件。"
    },
    {
      "indent": 6,
      "text": "SCTP_RESTART: SCTP has detected that the peer has restarted.",
      "zh-CHS": "SCTP_重启：SCTP检测到对等方已重启。"
    },
    {
      "indent": 6,
      "text": "SCTP_SHUTDOWN_COMP: The association has gracefully closed.",
      "zh-CHS": "SCTP_SHUTDOWN_COMP:关联已正常关闭。"
    },
    {
      "indent": 6,
      "text": "SCTP_CANT_STR_ASSOC: The association setup failed. If non-blocking mode is set and data was sent (on a one-to-many style socket), an SCTP_CANT_STR_ASSOC is accompanied by a series of SCTP_SEND_FAILED_EVENT events, one for each outstanding message.",
      "zh-CHS": "SCTP\\u CANT\\u STR\\u ASSOC:关联设置失败。如果设置了非阻塞模式并发送了数据（在一对多样式套接字上），则SCTP_CANT_STR_ASSOC会伴随一系列SCTP_SEND_FAILED_事件，每个未完成的消息对应一个事件。"
    },
    {
      "indent": 3,
      "text": "sac_error: If the state was reached due to an error condition (e.g., SCTP_COMM_LOST), any relevant error information is available in this field. This corresponds to the protocol error codes defined in [RFC4960].",
      "zh-CHS": "sac_错误：如果由于错误条件（例如SCTP_通信丢失）而达到该状态，则此字段中可提供任何相关错误信息。这对应于[RFC4960]中定义的协议错误代码。"
    },
    {
      "indent": 3,
      "text": "sac_outbound_streams and sac_inbound_streams: The maximum number of streams allowed in each direction is available in sac_outbound_streams and sac_inbound streams.",
      "zh-CHS": "sac_出站_流和sac_入站_流：sac_出站_流和sac_入站流中每个方向允许的最大流数。"
    },
    {
      "indent": 3,
      "text": "sac_assoc_id: The sac_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "sac_assoc_id：sac_assoc_id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 3,
      "text": "sac_info: If sac_state is SCTP_COMM_LOST and an ABORT chunk was received for this association, sac_info[] contains the complete ABORT chunk as defined in Section 3.3.7 of the SCTP specification [RFC4960]. If sac_state is SCTP_COMM_UP or SCTP_RESTART, sac_info may contain an array of uint8_t describing the features that the current association supports. Features may include",
      "zh-CHS": "sac_信息：如果sac_状态为SCTP_COMM_LOST，并且为此关联接收到中止区块，则sac_信息[]包含SCTP规范[RFC4960]第3.3.7节中定义的完整中止区块。如果sac_状态为SCTP_COMM_UP或SCTP_RESTART，则sac_info可能包含描述当前关联支持的功能的uint8_t数组。功能可能包括"
    },
    {
      "indent": 6,
      "text": "SCTP_ASSOC_SUPPORTS_PR: Both endpoints support the protocol extension described in [RFC3758].",
      "zh-CHS": "SCTP_ASSOC_支持：两个端点都支持[RFC3758]中描述的协议扩展。"
    },
    {
      "indent": 6,
      "text": "SCTP_ASSOC_SUPPORTS_AUTH: Both endpoints support the protocol extension described in [RFC4895].",
      "zh-CHS": "SCTP_ASSOC_支持认证：两个端点都支持[RFC4895]中描述的协议扩展。"
    },
    {
      "indent": 6,
      "text": "SCTP_ASSOC_SUPPORTS_ASCONF: Both endpoints support the protocol extension described in [RFC5061].",
      "zh-CHS": "SCTP_ASSOC_支持ASCONF：两个端点都支持[RFC5061]中描述的协议扩展。"
    },
    {
      "indent": 6,
      "text": "SCTP_ASSOC_SUPPORTS_MULTIBUF: For a one-to-many style socket, the local endpoints use separate send and/or receive buffers for each SCTP association.",
      "zh-CHS": "SCTP_ASSOC_支持多缓冲区：对于一对多样式套接字，本地端点为每个SCTP关联使用单独的发送和/或接收缓冲区。"
    },
    {
      "indent": 0,
      "text": "6.1.2. SCTP_PEER_ADDR_CHANGE",
      "section_title": true,
      "zh-CHS": "6.1.2. SCTP\\u对等地址更改"
    },
    {
      "indent": 3,
      "text": "When a destination address of a multi-homed peer encounters a state change, a peer address change event is sent. The notification has the following format:",
      "zh-CHS": "当多宿对等机的目标地址遇到状态更改时，将发送对等机地址更改事件。通知的格式如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_paddr_change {\n  uint16_t spc_type;\n  uint16_t spc_flags;\n  uint32_t spc_length;\n  struct sockaddr_storage spc_aaddr;\n  uint32_t spc_state;\n  uint32_t spc_error;\n  sctp_assoc_t spc_assoc_id;\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "spc_type: This field should be set to SCTP_PEER_ADDR_CHANGE.",
      "zh-CHS": "spc_类型：此字段应设置为SCTP_PEER_ADDR_CHANGE。"
    },
    {
      "indent": 3,
      "text": "spc_flags: This field is currently unused.",
      "zh-CHS": "spc_标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "spc_length: This field is the total length of the notification data, including the notification header.",
      "zh-CHS": "spc_长度：此字段是通知数据的总长度，包括通知头。"
    },
    {
      "indent": 3,
      "text": "spc_aaddr: The affected address field holds the remote peer's address that is encountering the change of state.",
      "zh-CHS": "spc_aaddr：受影响的地址字段保存遇到状态更改的远程对等方的地址。"
    },
    {
      "indent": 3,
      "text": "spc_state: This field holds one of a number of values that communicate the event that happened to the address. They include",
      "zh-CHS": "spc_状态：此字段保存多个值中的一个，这些值用于传递地址上发生的事件。包括"
    },
    {
      "indent": 6,
      "text": "SCTP_ADDR_AVAILABLE: This address is now reachable. This notification is provided whenever an address becomes reachable.",
      "zh-CHS": "SCTP_地址可用：现在可以访问此地址。只要可以访问地址，就会提供此通知。"
    },
    {
      "indent": 6,
      "text": "SCTP_ADDR_UNREACHABLE: The address specified can no longer be reached. Any data sent to this address is rerouted to an alternate until this address becomes reachable. This notification is provided whenever an address becomes unreachable.",
      "zh-CHS": "SCTP_ADDR_不可访问：无法再访问指定的地址。发送到此地址的任何数据都将被重新路由到备用地址，直到可以访问此地址为止。每当无法访问地址时，就会提供此通知。"
    },
    {
      "indent": 6,
      "text": "SCTP_ADDR_REMOVED: The address is no longer part of the association.",
      "zh-CHS": "SCTP_ADDR_REMOVED:地址不再是关联的一部分。"
    },
    {
      "indent": 6,
      "text": "SCTP_ADDR_ADDED: The address is now part of the association.",
      "zh-CHS": "SCTP_ADDR_添加：该地址现在是关联的一部分。"
    },
    {
      "indent": 6,
      "text": "SCTP_ADDR_MADE_PRIM: This address has now been made the primary destination address. This notification is provided whenever an address is made primary.",
      "zh-CHS": "SCTP_ADDR_MADE_PRIM：此地址现在已成为主要目标地址。只要将地址设为主要地址，就会提供此通知。"
    },
    {
      "indent": 3,
      "text": "spc_error: If the state was reached due to any error condition (e.g., SCTP_ADDR_UNREACHABLE), any relevant error information is available in this field.",
      "zh-CHS": "spc_错误：如果由于任何错误条件（例如，SCTP_ADDR_不可访问）而达到状态，则此字段中有任何相关错误信息。"
    },
    {
      "indent": 3,
      "text": "spc_assoc_id: The spc_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "spc\\U assoc\\U id：spc\\U assoc\\U id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 0,
      "text": "6.1.3. SCTP_REMOTE_ERROR",
      "section_title": true,
      "zh-CHS": "6.1.3. SCTP_远程_错误"
    },
    {
      "indent": 3,
      "text": "A remote peer may send an Operation Error message to its peer. This message indicates a variety of error conditions on an association. The entire ERROR chunk as it appears on the wire is included in an SCTP_REMOTE_ERROR event. Please refer to the SCTP specification [RFC4960] and any extensions for a list of possible error formats. An SCTP error notification has the following format:",
      "zh-CHS": "远程对等方可向其对等方发送操作错误消息。此消息表示关联上的各种错误情况。出现在线路上的整个错误块包含在SCTP_REMOTE_错误事件中。请参考SCTP规范[RFC4960]和任何扩展，了解可能的错误格式列表。SCTP错误通知的格式如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_remote_error {\n  uint16_t sre_type;\n  uint16_t sre_flags;\n  uint32_t sre_length;\n  uint16_t sre_error;\n  sctp_assoc_t sre_assoc_id;\n  uint8_t  sre_data[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sre_type: This field should be set to SCTP_REMOTE_ERROR.",
      "zh-CHS": "sre_类型：此字段应设置为SCTP_REMOTE_ERROR。"
    },
    {
      "indent": 3,
      "text": "sre_flags: This field is currently unused.",
      "zh-CHS": "sre_标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "sre_length: This field is the total length of the notification data, including the notification header and the contents of sre_data.",
      "zh-CHS": "sre_length：该字段是通知数据的总长度，包括通知头和sre_数据的内容。"
    },
    {
      "indent": 3,
      "text": "sre_error: This value represents one of the Operation Error causes defined in the SCTP specification [RFC4960], in network byte order.",
      "zh-CHS": "sre_error：该值表示SCTP规范[RFC4960]中定义的操作错误原因之一，以网络字节顺序表示。"
    },
    {
      "indent": 3,
      "text": "sre_assoc_id: The sre_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "sre_assoc_id:sre_assoc_id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 3,
      "text": "sre_data: This contains the ERROR chunk as defined in Section 3.3.10 of the SCTP specification [RFC4960].",
      "zh-CHS": "sre_数据：包含SCTP规范[RFC4960]第3.3.10节中定义的错误块。"
    },
    {
      "indent": 0,
      "text": "6.1.4. SCTP_SEND_FAILED - DEPRECATED",
      "section_title": true,
      "zh-CHS": "6.1.4. SCTP_发送_失败-已弃用"
    },
    {
      "indent": 3,
      "text": "Please note that this notification is deprecated. Use SCTP_SEND_FAILED_EVENT instead.",
      "zh-CHS": "请注意，此通知已弃用。改用SCTP_发送_失败事件。"
    },
    {
      "indent": 3,
      "text": "If SCTP cannot deliver a message, it can return back the message as a notification if the SCTP_SEND_FAILED event is enabled. The notification has the following format:",
      "zh-CHS": "如果SCTP无法传递消息，则如果启用了SCTP_SEND_FAILED事件，它可以将消息作为通知返回。通知的格式如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_send_failed {\n  uint16_t ssf_type;\n  uint16_t ssf_flags;\n  uint32_t ssf_length;\n  uint32_t ssf_error;\n  struct sctp_sndrcvinfo ssf_info;\n  sctp_assoc_t ssf_assoc_id;\n  uint8_t  ssf_data[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ssf_type: This field should be set to SCTP_SEND_FAILED.",
      "zh-CHS": "ssf_类型：此字段应设置为SCTP_发送失败。"
    },
    {
      "indent": 3,
      "text": "ssf_flags: The flag value will take one of the following values:",
      "zh-CHS": "ssf_标志：标志值将采用以下值之一："
    },
    {
      "indent": 6,
      "text": "SCTP_DATA_UNSENT: This value indicates that the data was never put on the wire.",
      "zh-CHS": "SCTP_DATA_UNSENT：此值表示数据从未放在导线上。"
    },
    {
      "indent": 6,
      "text": "SCTP_DATA_SENT: This value indicates that the data was put on the wire. Note that this does not necessarily mean that the data was (or was not) successfully delivered.",
      "zh-CHS": "SCTP_DATA_SENT：此值表示数据已放在导线上。请注意，这并不一定意味着数据已（或未）成功交付。"
    },
    {
      "indent": 3,
      "text": "ssf_length: This field is the total length of the notification data, including the notification header and the payload in ssf_data.",
      "zh-CHS": "ssf_长度：此字段是通知数据的总长度，包括通知头和ssf_数据中的有效负载。"
    },
    {
      "indent": 3,
      "text": "ssf_error: This value represents the reason why the send failed, and if set, will be an SCTP protocol error code as defined in Section 3.3.10 of [RFC4960].",
      "zh-CHS": "ssf_错误：该值表示发送失败的原因，如果设置，将是[RFC4960]第3.3.10节中定义的SCTP协议错误代码。"
    },
    {
      "indent": 3,
      "text": "ssf_info: This field includes the ancillary data (struct sctp_sndrcvinfo) used to send the undelivered message. Regardless of whether ancillary data is used or not, the ssf_info.sinfo_flags field indicates whether the complete message or only part of the message is returned in ssf_data. If only part of the message is returned, it means that the part that is not present has been sent successfully to the peer.",
      "zh-CHS": "ssf_info：此字段包括用于发送未送达消息的辅助数据（struct sctp_sndrcvinfo）。无论是否使用辅助数据，ssf_info.sinfo_flags字段指示是在ssf_数据中返回完整消息还是仅返回部分消息。如果只返回部分消息，则表示不存在的部分已成功发送到对等方。"
    },
    {
      "indent": 6,
      "text": "If the complete message cannot be sent, the SCTP_DATA_NOT_FRAG flag is set in ssf_info.sinfo_flags. If the first part of the message is sent successfully, SCTP_DATA_LAST_FRAG is set. This means that the tail end of the message is returned in ssf_data.",
      "zh-CHS": "如果无法发送完整消息，则在ssf_info.sinfo_标志中设置SCTP_DATA_NOT_FRAG标志。如果成功发送消息的第一部分，则设置SCTP_DATA_LAST_FRAG。这意味着在ssf_数据中返回消息的结尾。"
    },
    {
      "indent": 3,
      "text": "ssf_assoc_id: The ssf_assoc_id field, ssf_assoc_id, holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "ssf_assoc_id:ssf_assoc_id字段ssf_assoc_id保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 3,
      "text": "ssf_data: The undelivered message or part of the undelivered message will be present in the ssf_data field. Note that the ssf_info.sinfo_flags field as noted above should be used to determine whether a complete message or just a piece of the message is present. Note that only user data is present in this field; any chunk headers or SCTP common headers must be removed by the SCTP stack.",
      "zh-CHS": "ssf_数据：未送达的消息或部分未送达的消息将出现在ssf_数据字段中。请注意，如上所述的ssf_info.sinfo_flags字段应用于确定是否存在完整的消息或消息的一部分。请注意，此字段中仅显示用户数据；SCTP堆栈必须删除任何区块头或SCTP公共头。"
    },
    {
      "indent": 0,
      "text": "6.1.5. SCTP_SHUTDOWN_EVENT",
      "section_title": true,
      "zh-CHS": "6.1.5. SCTP\\u关闭\\u事件"
    },
    {
      "indent": 3,
      "text": "When a peer sends a SHUTDOWN, SCTP delivers this notification to inform the application that it should cease sending data.",
      "zh-CHS": "当对等方发送关机时，SCTP会发送此通知，通知应用程序它应该停止发送数据。"
    },
    {
      "indent": 7,
      "text": "struct sctp_shutdown_event {\n    uint16_t sse_type;\n    uint16_t sse_flags;\n    uint32_t sse_length;\n    sctp_assoc_t sse_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sse_type: This field should be set to SCTP_SHUTDOWN_EVENT.",
      "zh-CHS": "sse_类型：此字段应设置为SCTP_SHUTDOWN_事件。"
    },
    {
      "indent": 3,
      "text": "sse_flags: This field is currently unused.",
      "zh-CHS": "sse_标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "sse_length: This field is the total length of the notification data, including the notification header. It will generally be sizeof(struct sctp_shutdown_event).",
      "zh-CHS": "sse_length：此字段是通知数据的总长度，包括通知标头。它通常是sizeof（struct sctp\\u shutdown\\u事件）。"
    },
    {
      "indent": 3,
      "text": "sse_assoc_id: The sse_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "sse_assoc_id：sse_assoc_id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 0,
      "text": "6.1.6. SCTP_ADAPTATION_INDICATION",
      "section_title": true,
      "zh-CHS": "6.1.6. SCTP_自适应_指示"
    },
    {
      "indent": 3,
      "text": "When a peer sends an Adaptation Layer Indication parameter as described in [RFC5061], SCTP delivers this notification to inform the application about the peer's adaptation layer indication.",
      "zh-CHS": "当对等方发送[RFC5061]中所述的适配层指示参数时，SCTP发送此通知以通知应用程序对等方的适配层指示。"
    },
    {
      "indent": 3,
      "text": "struct sctp_adaptation_event {\n  uint16_t sai_type;\n  uint16_t sai_flags;\n  uint32_t sai_length;\n  uint32_t sai_adaptation_ind;\n  sctp_assoc_t sai_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sai_type: This field should be set to SCTP_ADAPTATION_INDICATION.",
      "zh-CHS": "sai_类型：该字段应设置为SCTP_自适应_指示。"
    },
    {
      "indent": 3,
      "text": "sai_flags: This field is currently unused.",
      "zh-CHS": "sai_标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "sai_length: This field is the total length of the notification data, including the notification header. It will generally be sizeof(struct sctp_adaptation_event).",
      "zh-CHS": "sai_length：此字段是通知数据的总长度，包括通知标头。它通常是sizeof（struct sctp_adaption_事件）。"
    },
    {
      "indent": 3,
      "text": "sai_adaptation_ind: This field holds the bit array sent by the peer in the Adaptation Layer Indication parameter.",
      "zh-CHS": "sai_adaption_ind：该字段保存自适应层指示参数中对等方发送的位数组。"
    },
    {
      "indent": 3,
      "text": "sai_assoc_id: The sai_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "sai_assoc_id：sai_assoc_id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 0,
      "text": "6.1.7. SCTP_PARTIAL_DELIVERY_EVENT",
      "section_title": true,
      "zh-CHS": "6.1.7. SCTP_部分_交付_事件"
    },
    {
      "indent": 3,
      "text": "When a receiver is engaged in a partial delivery of a message, this notification will be used to indicate various events.",
      "zh-CHS": "当接收者参与部分传递消息时，此通知将用于指示各种事件。"
    },
    {
      "indent": 3,
      "text": "struct sctp_pdapi_event {\n  uint16_t pdapi_type;\n  uint16_t pdapi_flags;\n  uint32_t pdapi_length;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  uint32_t pdapi_indication;\n  uint32_t pdapi_stream;\n  uint32_t pdapi_seq;\n  sctp_assoc_t pdapi_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "pdapi_type: This field should be set to SCTP_PARTIAL_DELIVERY_EVENT.",
      "zh-CHS": "pdapi_类型：此字段应设置为SCTP_部分_交付_事件。"
    },
    {
      "indent": 3,
      "text": "pdapi_flags: This field is currently unused.",
      "zh-CHS": "pdapi_标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "pdapi_length: This field is the total length of the notification data, including the notification header. It will generally be sizeof(struct sctp_pdapi_event).",
      "zh-CHS": "pdapi_length：此字段是通知数据的总长度，包括通知头。它通常是sizeof（struct sctp_pdapi_事件）。"
    },
    {
      "indent": 3,
      "text": "pdapi_indication: This field holds the indication being sent to the application. Currently, there is only one defined value:",
      "zh-CHS": "pdapi_指示：此字段保存发送到应用程序的指示。目前，只有一个定义值："
    },
    {
      "indent": 6,
      "text": "SCTP_PARTIAL_DELIVERY_ABORTED: This indicates that the partial delivery of a user message has been aborted. This happens, for example, if an association is aborted while a partial delivery is going on or the user message gets abandoned using PR-SCTP while the partial delivery of this message is going on.",
      "zh-CHS": "SCTP_PARTIAL_DELIVERY_ABORTED：这表示用户消息的部分传递已中止。例如，如果在部分传递过程中中止关联，或者在部分传递过程中使用PR-SCTP放弃用户消息，则会发生这种情况。"
    },
    {
      "indent": 3,
      "text": "pdapi_stream: This field holds the stream on which the partial delivery event happened.",
      "zh-CHS": "pdapi_流：此字段保存发生部分传递事件的流。"
    },
    {
      "indent": 3,
      "text": "pdapi_seq: This field holds the stream sequence number that was being partially delivered.",
      "zh-CHS": "pdapi_seq：此字段保存部分交付的流序列号。"
    },
    {
      "indent": 3,
      "text": "pdapi_assoc_id: The pdapi_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "pdapi_assoc_id:pdapi_assoc_id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 0,
      "text": "6.1.8. SCTP_AUTHENTICATION_EVENT",
      "section_title": true,
      "zh-CHS": "6.1.8. SCTP_身份验证_事件"
    },
    {
      "indent": 3,
      "text": "[RFC4895] defines an extension to authenticate SCTP messages. The following notification is used to report different events relating to the use of this extension.",
      "zh-CHS": "[RFC4895]定义用于验证SCTP消息的扩展。以下通知用于报告与使用此扩展相关的不同事件。"
    },
    {
      "indent": 3,
      "text": "struct sctp_authkey_event {\n  uint16_t auth_type;\n  uint16_t auth_flags;\n  uint32_t auth_length;\n  uint16_t auth_keynumber;\n  uint32_t auth_indication;\n  sctp_assoc_t auth_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "auth_type: This field should be set to SCTP_AUTHENTICATION_EVENT.",
      "zh-CHS": "身份验证类型：此字段应设置为SCTP\\U身份验证\\U事件。"
    },
    {
      "indent": 3,
      "text": "auth_flags: This field is currently unused.",
      "zh-CHS": "验证标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "auth_length: This field is the total length of the notification data, including the notification header. It will generally be sizeof(struct sctp_authkey_event).",
      "zh-CHS": "auth_length：此字段是通知数据的总长度，包括通知头。它通常是sizeof（struct sctp\\u authkey\\u事件）。"
    },
    {
      "indent": 3,
      "text": "auth_keynumber: This field holds the key number for the affected key indicated in the event (depends on auth_indication).",
      "zh-CHS": "auth_keynumber：此字段保存事件中指示的受影响密钥的密钥号（取决于auth_指示）。"
    },
    {
      "indent": 3,
      "text": "auth_indication: This field holds the error or indication being reported. The following values are currently defined:",
      "zh-CHS": "验证指示：此字段保存正在报告的错误或指示。当前定义了以下值："
    },
    {
      "indent": 6,
      "text": "SCTP_AUTH_NEW_KEY: This report indicates that a new key has been made active (used for the first time by the peer) and is now the active key. The auth_keynumber field holds the user-specified key number.",
      "zh-CHS": "SCTP_AUTH_NEW_KEY：此报告表示新密钥已被激活（对等方首次使用），并且现在是活动密钥。auth_keynumber字段保存用户指定的密钥号。"
    },
    {
      "indent": 6,
      "text": "SCTP_AUTH_NO_AUTH: This report indicates that the peer does not support SCTP authentication as defined in [RFC4895].",
      "zh-CHS": "SCTP_AUTH_NO_AUTH：此报告表示对等方不支持[RFC4895]中定义的SCTP身份验证。"
    },
    {
      "indent": 6,
      "text": "SCTP_AUTH_FREE_KEY: This report indicates that the SCTP implementation will no longer use the key identifier specified in auth_keynumber.",
      "zh-CHS": "SCTP_AUTH_FREE_KEY：此报告表示SCTP实现将不再使用AUTH_keynumber中指定的密钥标识符。"
    },
    {
      "indent": 3,
      "text": "auth_assoc_id: The auth_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "auth_assoc_id：auth_assoc_id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 0,
      "text": "6.1.9. SCTP_SENDER_DRY_EVENT",
      "section_title": true,
      "zh-CHS": "6.1.9. SCTP\\u发送器\\u干\\u事件"
    },
    {
      "indent": 3,
      "text": "When the SCTP stack has no more user data to send or retransmit, this notification is given to the user. Also, at the time when a user app subscribes to this event, if there is no data to be sent or retransmit, the stack will immediately send up this notification.",
      "zh-CHS": "当SCTP堆栈没有更多的用户数据要发送或重新传输时，将向用户发出此通知。此外，当用户应用程序订阅此事件时，如果没有要发送或重新传输的数据，堆栈将立即发送此通知。"
    },
    {
      "indent": 3,
      "text": "struct sctp_sender_dry_event {\n  uint16_t sender_dry_type;\n  uint16_t sender_dry_flags;\n  uint32_t sender_dry_length;\n  sctp_assoc_t sender_dry_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sender_dry_type: This field should be set to SCTP_SENDER_DRY_EVENT.",
      "zh-CHS": "sender\\u dry\\u type：此字段应设置为SCTP\\u sender\\u dry\\u事件。"
    },
    {
      "indent": 3,
      "text": "sender_dry_flags: This field is currently unused.",
      "zh-CHS": "发送方标志：此字段当前未使用。"
    },
    {
      "indent": 3,
      "text": "sender_dry_length: This field is the total length of the notification data, including the notification header. It will generally be sizeof(struct sctp_sender_dry_event).",
      "zh-CHS": "sender_dry_length：此字段是通知数据的总长度，包括通知标头。它通常是sizeof（struct sctp\\u sender\\u dry\\u事件）。"
    },
    {
      "indent": 3,
      "text": "sender_dry_assoc_id: The sender_dry_assoc_id field holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "sender\\u dry\\u assoc\\u id：sender\\u dry\\u assoc\\u id字段保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 0,
      "text": "6.1.10. SCTP_NOTIFICATIONS_STOPPED_EVENT",
      "section_title": true,
      "zh-CHS": "6.1.10. SCTP\\u通知\\u停止\\u事件"
    },
    {
      "indent": 3,
      "text": "SCTP notifications, when subscribed to, are reliable. They are always delivered as long as there is space in the socket receive buffer. However, if an implementation experiences a notification storm, it may run out of socket buffer space. When this occurs, it may wish to disable notifications. If the implementation chooses to do this, it will append a final notification SCTP_NOTIFICATIONS_STOPPED_EVENT. This notification is a union sctp_notification, where only the sctp_tlv structure (see the union above) is used. It only contains this type in the sn_type field, the sn_length field set to the size of an sctp_tlv structure, and the sn_flags set to 0. If an application receives this notification, it will need to re-subscribe to any notifications of interest to it, except for the sctp_data_io_event (note that SCTP_EVENTS is deprecated).",
      "zh-CHS": "SCTP通知在订阅时是可靠的。只要套接字接收缓冲区中有空间，就始终传递它们。但是，如果实现遇到通知风暴，它可能会耗尽套接字缓冲区空间。出现这种情况时，它可能希望禁用通知。如果实现选择这样做，它将附加一个最终通知SCTP\\u NOTIFICATIONS\\u STOPPED\\u事件。此通知是union sctp_通知，其中仅使用sctp_tlv结构（参见上面的union）。它仅在sn_类型字段、设置为sctp_tlv结构大小的sn_长度字段以及设置为0的sn_标志中包含此类型。如果应用程序收到此通知，则需要重新订阅其感兴趣的任何通知，但sctp_数据_io_事件除外（请注意，sctp_事件已弃用）。"
    },
    {
      "indent": 3,
      "text": "An endpoint is automatically subscribed to this event as soon as it is subscribed to any event other than data io events.",
      "zh-CHS": "只要端点订阅了除数据io事件以外的任何事件，它就会自动订阅此事件。"
    },
    {
      "indent": 0,
      "text": "6.1.11. SCTP_SEND_FAILED_EVENT",
      "section_title": true,
      "zh-CHS": "6.1.11. SCTP\\u发送\\u失败\\u事件"
    },
    {
      "indent": 3,
      "text": "If SCTP cannot deliver a message, it can return back the message as a notification if the SCTP_SEND_FAILED_EVENT event is enabled. The notification has the following format:",
      "zh-CHS": "如果SCTP无法传递消息，则如果启用了SCTP_SEND_FAILED_事件，它可以将消息作为通知返回。通知的格式如下："
    },
    {
      "indent": 3,
      "text": "struct sctp_send_failed_event {\n  uint16_t ssfe_type;\n  uint16_t ssfe_flags;\n  uint32_t ssfe_length;\n  uint32_t ssfe_error;\n  struct sctp_sndinfo ssfe_info;\n  sctp_assoc_t ssfe_assoc_id;\n  uint8_t  ssfe_data[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ssfe_type: This field should be set to SCTP_SEND_FAILED_EVENT.",
      "zh-CHS": "ssfe_类型：此字段应设置为SCTP_发送_失败_事件。"
    },
    {
      "indent": 3,
      "text": "ssfe_flags: The flag value will take one of the following values:",
      "zh-CHS": "ssfe_标志：标志值将采用以下值之一："
    },
    {
      "indent": 6,
      "text": "SCTP_DATA_UNSENT: This value indicates that the data was never put on the wire.",
      "zh-CHS": "SCTP_DATA_UNSENT：此值表示数据从未放在导线上。"
    },
    {
      "indent": 6,
      "text": "SCTP_DATA_SENT: This value indicates that the data was put on the wire. Note that this does not necessarily mean that the data was (or was not) successfully delivered.",
      "zh-CHS": "SCTP_DATA_SENT：此值表示数据已放在导线上。请注意，这并不一定意味着数据已（或未）成功交付。"
    },
    {
      "indent": 3,
      "text": "ssfe_length: This field is the total length of the notification data, including the notification header and the payload in ssf_data.",
      "zh-CHS": "ssfe_长度：此字段是通知数据的总长度，包括通知头和ssf_数据中的有效负载。"
    },
    {
      "indent": 3,
      "text": "ssfe_error: This value represents the reason why the send failed, and if set, will be an SCTP protocol error code as defined in Section 3.3.10 of [RFC4960].",
      "zh-CHS": "ssfe_错误：该值表示发送失败的原因，如果设置，将是[RFC4960]第3.3.10节中定义的SCTP协议错误代码。"
    },
    {
      "indent": 3,
      "text": "ssfe_info: This field includes the ancillary data (struct sctp_sndinfo) used to send the undelivered message. Regardless of whether ancillary data is used or not, the ssfe_info.sinfo_flags field indicates whether the complete message or only part of the message is returned in ssf_data. If only part of the message is returned, it means that the part that is not present has been sent successfully to the peer.",
      "zh-CHS": "ssfe_info：此字段包括用于发送未送达消息的辅助数据（struct sctp_sndinfo）。无论是否使用辅助数据，ssfe_info.sinfo_flags字段指示是在ssf_数据中返回完整消息还是仅返回部分消息。如果只返回部分消息，则表示不存在的部分已成功发送到对等方。"
    },
    {
      "indent": 6,
      "text": "If the complete message cannot be sent, the SCTP_DATA_NOT_FRAG flag is set in ssfe_info.sinfo_flags. If the first part of the message is sent successfully, SCTP_DATA_LAST_FRAG is set. This means that the tail end of the message is returned in ssf_data.",
      "zh-CHS": "如果无法发送完整消息，则在ssfe_info.sinfo_标志中设置SCTP_DATA_NOT_FRAG标志。如果成功发送消息的第一部分，则设置SCTP_DATA_LAST_FRAG。这意味着在ssf_数据中返回消息的结尾。"
    },
    {
      "indent": 3,
      "text": "ssfe_assoc_id: The ssfe_assoc_id field, ssf_assoc_id, holds the identifier for the association. All notifications for a given association have the same association identifier. For a one-to-one style socket, this field is ignored.",
      "zh-CHS": "ssfe_assoc_id:ssfe_assoc_id字段ssf_assoc_id保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。对于一对一样式的套接字，将忽略此字段。"
    },
    {
      "indent": 3,
      "text": "ssfe_data: The undelivered message or part of the undelivered message will be present in the ssf_data field. Note that the ssf_info.sinfo_flags field as noted above should be used to determine whether a complete message or just a piece of the message is present. Note that only user data is present in this field; any chunk headers or SCTP common headers must be removed by the SCTP stack.",
      "zh-CHS": "ssfe_数据：未送达的消息或部分未送达的消息将出现在ssf_数据字段中。请注意，如上所述的ssf_info.sinfo_flags字段应用于确定是否存在完整的消息或消息的一部分。请注意，此字段中仅显示用户数据；SCTP堆栈必须删除任何区块头或SCTP公共头。"
    },
    {
      "indent": 0,
      "text": "6.2. Notification Interest Options",
      "section_title": true,
      "zh-CHS": "6.2. 通知利息期权"
    },
    {
      "indent": 0,
      "text": "6.2.1. SCTP_EVENTS Option - DEPRECATED",
      "section_title": true,
      "zh-CHS": "6.2.1. SCTP_事件选项-已弃用"
    },
    {
      "indent": 3,
      "text": "Please note that this option is deprecated. Use the SCTP_EVENT option described in Section 6.2.2 instead.",
      "zh-CHS": "请注意，此选项已弃用。改用第6.2.2节所述的SCTP_事件选项。"
    },
    {
      "indent": 3,
      "text": "To receive SCTP event notifications, an application registers its interest by setting the SCTP_EVENTS socket option. The application then uses recvmsg() to retrieve notifications. A notification is stored in the data part (msg_iov) of the msghdr structure. The socket option uses the following structure:",
      "zh-CHS": "为了接收SCTP事件通知，应用程序通过设置SCTP_事件套接字选项来注册其兴趣。然后，应用程序使用recvmsg（）检索通知。通知存储在msghdr结构的数据部分（msg_iov）中。套接字选项使用以下结构："
    },
    {
      "indent": 3,
      "text": "struct sctp_event_subscribe {\n  uint8_t sctp_data_io_event;\n  uint8_t sctp_association_event;\n  uint8_t sctp_address_event;\n  uint8_t sctp_send_failure_event;\n  uint8_t sctp_peer_error_event;\n  uint8_t sctp_shutdown_event;\n  uint8_t sctp_partial_delivery_event;\n  uint8_t sctp_adaptation_layer_event;\n  uint8_t sctp_authentication_event;\n  uint8_t sctp_sender_dry_event;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sctp_data_io_event: Setting this flag to 1 will cause the reception of SCTP_SNDRCV information on a per-message basis. The application will need to use the recvmsg() interface so that it can receive the event information contained in the msg_control field. Setting the flag to 0 will disable the reception of the message control information. Note that this flag is not really a notification and is stored in the ancillary data (msg_control), not in the data part (msg_iov).",
      "zh-CHS": "sctp_数据_io_事件：将此标志设置为1将导致接收每条消息的sctp_SNDRCV信息。应用程序将需要使用recvmsg（）接口，以便能够接收msg_控件字段中包含的事件信息。将标志设置为0将禁用消息控制信息的接收。请注意，此标志实际上不是通知，而是存储在辅助数据（msg_控件）中，而不是存储在数据部分（msg_iov）中。"
    },
    {
      "indent": 3,
      "text": "sctp_association_event: Setting this flag to 1 will enable the reception of association event notifications. Setting the flag to 0 will disable association event notifications.",
      "zh-CHS": "sctp_关联_事件：将此标志设置为1将启用关联事件通知的接收。将标志设置为0将禁用关联事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_address_event: Setting this flag to 1 will enable the reception of address event notifications. Setting the flag to 0 will disable address event notifications.",
      "zh-CHS": "sctp_地址_事件：将此标志设置为1将启用地址事件通知的接收。将标志设置为0将禁用地址事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_send_failure_event: Setting this flag to 1 will enable the reception of send failure event notifications. Setting the flag to 0 will disable send failure event notifications.",
      "zh-CHS": "sctp_发送失败事件：将此标志设置为1将启用发送失败事件通知的接收。将标志设置为0将禁用发送失败事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_peer_error_event: Setting this flag to 1 will enable the reception of peer error event notifications. Setting the flag to 0 will disable peer error event notifications.",
      "zh-CHS": "sctp_对等错误事件：将此标志设置为1将启用对等错误事件通知的接收。将标志设置为0将禁用对等错误事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_shutdown_event: Setting this flag to 1 will enable the reception of shutdown event notifications. Setting the flag to 0 will disable shutdown event notifications.",
      "zh-CHS": "sctp_shutdown_事件：将此标志设置为1将启用关机事件通知的接收。将标志设置为0将禁用关机事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_partial_delivery_event: Setting this flag to 1 will enable the reception of partial delivery event notifications. Setting the flag to 0 will disable partial delivery event notifications.",
      "zh-CHS": "sctp_部分交付事件：将此标志设置为1将启用部分交付事件通知的接收。将标志设置为0将禁用部分传递事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_adaptation_layer_event: Setting this flag to 1 will enable the reception of adaptation layer event notifications. Setting the flag to 0 will disable adaptation layer event notifications.",
      "zh-CHS": "sctp_自适应_层_事件：将此标志设置为1将启用自适应层事件通知的接收。将标志设置为0将禁用自适应层事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_authentication_event: Setting this flag to 1 will enable the reception of authentication layer event notifications. Setting the flag to 0 will disable authentication layer event notifications.",
      "zh-CHS": "sctp_认证_事件：将此标志设置为1将启用认证层事件通知的接收。将标志设置为0将禁用身份验证层事件通知。"
    },
    {
      "indent": 3,
      "text": "sctp_sender_dry_event: Setting this flag to 1 will enable the reception of sender dry event notifications. Setting the flag to 0 will disable sender dry event notifications.",
      "zh-CHS": "sctp_sender_dry_事件：将此标志设置为1将启用对sender dry事件通知的接收。将标志设置为0将禁用发件人干事件通知。"
    },
    {
      "indent": 3,
      "text": "An example where an application would like to receive data_io_events and association_events but no others would be as follows:",
      "zh-CHS": "应用程序希望接收数据io事件和关联事件，但不接收其他事件的示例如下："
    },
    {
      "indent": 3,
      "text": "{\n  struct sctp_event_subscribe events;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "memset(&events, 0, sizeof(events));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "events.sctp_data_io_event = 1;\nevents.sctp_association_event = 1;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  setsockopt(sd, IPPROTO_SCTP, SCTP_EVENTS, &events, sizeof(events));\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Note that for one-to-many style SCTP sockets, the caller of recvmsg() receives ancillary data and notifications for all associations bound to the file descriptor. For one-to-one style SCTP sockets, the caller receives ancillary data and notifications only for the single association bound to the file descriptor.",
      "zh-CHS": "注意，对于一对多样式的SCTP套接字，recvmsg（）的调用方接收绑定到文件描述符的所有关联的辅助数据和通知。对于一对一样式的SCTP套接字，调用方仅接收绑定到文件描述符的单个关联的辅助数据和通知。"
    },
    {
      "indent": 3,
      "text": "By default, both the one-to-one style and the one-to-many style socket do not subscribe to any notification.",
      "zh-CHS": "默认情况下，一对一样式和一对多样式套接字都不订阅任何通知。"
    },
    {
      "indent": 0,
      "text": "6.2.2. SCTP_EVENT Option",
      "section_title": true,
      "zh-CHS": "6.2.2. SCTP_事件选项"
    },
    {
      "indent": 3,
      "text": "The SCTP_EVENTS socket option has one issue for future compatibility. As new features are added, the structure (sctp_event_subscribe) must be expanded. This can cause an application binary interface (ABI) issue unless an implementation has added padding at the end of the structure. To avoid this problem, SCTP_EVENTS has been deprecated and a new socket option SCTP_EVENT has taken its place. The option is used with the following structure:",
      "zh-CHS": "SCTP_事件套接字选项有一个未来兼容性问题。随着新功能的添加，必须扩展结构（sctp_事件_订阅）。这可能会导致应用程序二进制接口（ABI）问题，除非实现在结构末尾添加了填充。为了避免此问题，SCTP_事件已被弃用，并使用了一个新的套接字选项SCTP_事件。该选项与以下结构一起使用："
    },
    {
      "indent": 3,
      "text": "struct sctp_event {\n        sctp_assoc_t se_assoc_id;\n        uint16_t     se_type;\n        uint8_t      se_on;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "se_assoc_id: The se_assoc_id field is ignored for one-to-one style sockets. For one-to-many style sockets, this field can be a particular association identifier or SCTP_{FUTURE|CURRENT| ALL}_ASSOC.",
      "zh-CHS": "se_assoc_id：对于一对一样式的套接字，se_assoc_id字段被忽略。对于一对多样式套接字，此字段可以是特定的关联标识符或SCTP{FUTURE | CURRENT | ALL}_ASSOC。"
    },
    {
      "indent": 3,
      "text": "se_type: The se_type field can be filled with any value that would show up in the respective sn_type field (in the sctp_tlv structure of the notification).",
      "zh-CHS": "se_类型：se_类型字段可以填充在相应的sn_类型字段（在通知的sctp_tlv结构中）中显示的任何值。"
    },
    {
      "indent": 3,
      "text": "se_on: The se_on field is set to 1 to turn on an event and set to 0 to turn off an event.",
      "zh-CHS": "se_on：se_on字段设置为1以打开事件，设置为0以关闭事件。"
    },
    {
      "indent": 3,
      "text": "To use this option, the user fills in this structure and then calls setsockopt() to turn on or off an individual event. The following is an example use of this option:",
      "zh-CHS": "要使用此选项，用户填写此结构，然后调用setsockopt（）来打开或关闭单个事件。以下是此选项的使用示例："
    },
    {
      "indent": 3,
      "text": "{\n  struct sctp_event event;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "memset(&event, 0, sizeof(event));",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  event.se_assoc_id = SCTP_FUTURE_ASSOC;\n  event.se_type = SCTP_SENDER_DRY_EVENT;\n  event.se_on = 1;\n  setsockopt(sd, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(event));\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "By default, both the one-to-one style and the one-to-many style socket do not subscribe to any notification.",
      "zh-CHS": "默认情况下，一对一样式和一对多样式套接字都不订阅任何通知。"
    },
    {
      "indent": 0,
      "text": "7. Common Operations for Both Styles",
      "section_title": true,
      "zh-CHS": "7. 两种样式的通用操作"
    },
    {
      "indent": 0,
      "text": "7.1. send(), recv(), sendto(), and recvfrom()",
      "section_title": true,
      "zh-CHS": "7.1. send（）、recv（）、sendto（）和recvfrom（）"
    },
    {
      "indent": 3,
      "text": "Applications can use send() and sendto() to transmit data to the peer of an SCTP endpoint. recv() and recvfrom() can be used to receive data from the peer.",
      "zh-CHS": "应用程序可以使用send（）和sendto（）将数据传输到SCTP端点的对等方。recv（）和recvfrom（）可用于从对等方接收数据。"
    },
    {
      "indent": 3,
      "text": "The function prototypes are",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t send(int sd, const void *msg, size_t len, int flags);",
      "zh-CHS": "ssize_t send（int sd，const void*msg，size_t len，int标志）；"
    },
    {
      "indent": 3,
      "text": "ssize_t sendto(int sd, const void *msg, size_t len, int flags, const struct sockaddr *to, socklen_t tolen);",
      "zh-CHS": "ssize_t sendto（int sd，const void*msg，size_t len，int flags，const struct sockaddr*to，socklen\\u t tolen）；"
    },
    {
      "indent": 3,
      "text": "ssize_t recv(int sd, void *buf, size_t len, int flags);",
      "zh-CHS": "ssize_t recv（内部sd、无效*buf、大小长度、内部标志）；"
    },
    {
      "indent": 3,
      "text": "ssize_t recvfrom(int sd, void *buf, size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);",
      "zh-CHS": "ssize_t recvfrom（int sd，void*buf，size_t len，int flags，struct sockaddr*from，socklen\\u t*fromlen）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor of an SCTP endpoint.",
      "zh-CHS": "sd：SCTP端点的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "msg: The message to be sent.",
      "zh-CHS": "msg：要发送的消息。"
    },
    {
      "indent": 3,
      "text": "len: The size of the message or the size of the buffer.",
      "zh-CHS": "len：消息的大小或缓冲区的大小。"
    },
    {
      "indent": 3,
      "text": "to: One of the peer addresses of the association to be used to send the message.",
      "zh-CHS": "收件人：用于发送消息的关联的对等地址之一。"
    },
    {
      "indent": 3,
      "text": "tolen: The size of the address.",
      "zh-CHS": "托伦：地址的大小。"
    },
    {
      "indent": 3,
      "text": "buf: The buffer to store a received message.",
      "zh-CHS": "buf：用于存储接收到的消息的缓冲区。"
    },
    {
      "indent": 3,
      "text": "from: The buffer to store the peer address used to send the received message.",
      "zh-CHS": "from：用于存储用于发送接收到的消息的对等地址的缓冲区。"
    },
    {
      "indent": 3,
      "text": "fromlen: The size of the from address.",
      "zh-CHS": "fromlen：发件人地址的大小。"
    },
    {
      "indent": 3,
      "text": "flags: (described below).",
      "zh-CHS": "标志：（如下所述）。"
    },
    {
      "indent": 3,
      "text": "These calls give access to only basic SCTP protocol features. If either peer in the association uses multiple streams, or sends unordered data, these calls will usually be inadequate and may deliver the data in unpredictable ways.",
      "zh-CHS": "这些调用只允许访问基本的SCTP协议功能。如果关联中的任何一个对等方使用多个流，或者发送无序数据，这些调用通常是不充分的，并且可能以不可预测的方式传递数据。"
    },
    {
      "indent": 3,
      "text": "SCTP has the concept of multiple streams in one association. The above calls do not allow the caller to specify on which stream a message should be sent. The system uses stream 0 as the default stream for send() and sendto(). recv() and recvfrom() return data from any stream, but the caller cannot distinguish the different streams. This may result in data seeming to arrive out of order. Similarly, if a DATA chunk is sent unordered, recv() and recvfrom() provide no indication.",
      "zh-CHS": "SCTP的概念是在一个关联中包含多个流。上述调用不允许调用方指定消息应在哪个流上发送。系统使用流0作为send（）和sendto（）的默认流。recv（）和recvfrom（）从任何流返回数据，但调用方无法区分不同的流。这可能会导致数据到达时出现故障。类似地，如果数据块是无序发送的，则recv（）和recvfrom（）不提供任何指示。"
    },
    {
      "indent": 3,
      "text": "SCTP is message based. The msg buffer above in send() and sendto() is considered to be a single message. This means that if the caller wants to send a message that is composed by several buffers, the caller needs to combine them before calling send() or sendto(). Alternately, the caller can use sendmsg() to do that without combining them. Sending a message using send() or sendto() is atomic unless explicit EOR marking is enabled on the socket specified by sd. Using sendto() on a non-connected one-to-one style socket for implicit connection setup may or may not work, depending on the SCTP implementation. recv() and recvfrom() cannot distinguish message boundaries (i.e., there is no way to observe the MSG_EOR flag to detect partial delivery).",
      "zh-CHS": "SCTP是基于消息的。上面send（）和sendto（）中的msg缓冲区被视为一条消息。这意味着，如果调用方希望发送由多个缓冲区组成的消息，则调用方需要在调用send（）或sendto（）之前将它们组合起来。或者，调用方可以使用sendmsg（）来执行此操作，而无需组合它们。除非在sd指定的套接字上启用了显式EOR标记，否则使用send（）或sendto（）发送消息是原子的。在未连接的一对一样式套接字上使用sendto（）进行隐式连接设置可能有效，也可能无效，具体取决于SCTP实现。recv（）和recvfrom（）无法区分消息边界（即，无法观察MSG_EOR标志来检测部分传递）。"
    },
    {
      "indent": 3,
      "text": "When receiving, if the buffer supplied is not large enough to hold a complete message, the receive call acts like a stream socket and returns as much data as will fit in the buffer.",
      "zh-CHS": "在接收时，如果提供的缓冲区不够大，无法容纳完整的消息，则接收调用的行为类似于流套接字，并返回缓冲区中容纳的尽可能多的数据。"
    },
    {
      "indent": 3,
      "text": "Note that the send() and recv() calls may not be used for a one-to-many style socket.",
      "zh-CHS": "请注意，send（）和recv（）调用不能用于一对多样式套接字。"
    },
    {
      "indent": 3,
      "text": "Note that if an application calls a send() or sendto() function with no user data, the SCTP implementation should reject the request with an appropriate error message. An implementation is not allowed to send a DATA chunk with no user data [RFC4960].",
      "zh-CHS": "请注意，如果应用程序在没有用户数据的情况下调用send（）或sendto（）函数，则SCTP实现应使用适当的错误消息拒绝该请求。不允许实现发送没有用户数据的数据块[RFC4960]。"
    },
    {
      "indent": 0,
      "text": "7.2. setsockopt() and getsockopt()",
      "section_title": true,
      "zh-CHS": "7.2. setsockopt（）和getsockopt（）"
    },
    {
      "indent": 3,
      "text": "Applications use setsockopt() and getsockopt() to set or retrieve socket options. Socket options are used to change the default behavior of socket calls. They are described in Section 8.",
      "zh-CHS": "应用程序使用setsockopt（）和getsockopt（）设置或检索套接字选项。套接字选项用于更改套接字调用的默认行为。第8节对其进行了描述。"
    },
    {
      "indent": 3,
      "text": "The function prototypes are",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int getsockopt(int sd, int level, int optname, void *optval, socklen_t *optlen);",
      "zh-CHS": "int getsockopt（int-sd、int-level、int-optname、void*optval、socklen\\u t*optlen）；"
    },
    {
      "indent": 3,
      "text": "and",
      "zh-CHS": "和"
    },
    {
      "indent": 3,
      "text": "int setsockopt(int sd, int level, int optname, const void *optval, socklen_t optlen);",
      "zh-CHS": "int setsockopt（int sd，int level，int optname，const void*optval，socklen_t optlen）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "level: Set to IPPROTO_SCTP for all SCTP options.",
      "zh-CHS": "级别：对于所有SCTP选项，设置为IPPROTO_SCTP。"
    },
    {
      "indent": 3,
      "text": "optname: The option name.",
      "zh-CHS": "optname：选项名。"
    },
    {
      "indent": 3,
      "text": "optval: The buffer to store the value of the option.",
      "zh-CHS": "optval：用于存储选项值的缓冲区。"
    },
    {
      "indent": 3,
      "text": "optlen: The size of the buffer (or the length of the option returned).",
      "zh-CHS": "optlen：缓冲区的大小（或返回的选项的长度）。"
    },
    {
      "indent": 3,
      "text": "These functions return 0 on success and -1 in case of an error.",
      "zh-CHS": "这些函数在成功时返回0，在出错时返回-1。"
    },
    {
      "indent": 3,
      "text": "All socket options set on a one-to-one style listening socket also apply to all future accepted sockets. For one-to-many style sockets, often a socket option will pass a structure that includes an assoc_id field. This field can be filled with the association identifier of a particular association and unless otherwise specified can be filled with one of the following constants:",
      "zh-CHS": "在一对一样式侦听套接字上设置的所有套接字选项也适用于所有将来接受的套接字。对于一对多样式套接字，套接字选项通常会传递包含assoc_id字段的结构。此字段可以用特定关联的关联标识符填充，除非另有规定，否则可以用以下常量之一填充："
    },
    {
      "indent": 3,
      "text": "SCTP_FUTURE_ASSOC: Specifies that only future associations created after this socket option will be affected by this call.",
      "zh-CHS": "SCTP_FUTURE_ASSOC：指定只有在此套接字选项之后创建的未来关联才会受到此调用的影响。"
    },
    {
      "indent": 3,
      "text": "SCTP_CURRENT_ASSOC: Specifies that only currently existing associations will be affected by this call, and future associations will still receive the previous default value.",
      "zh-CHS": "SCTP_CURRENT_ASSOC：指定只有当前存在的关联将受到此调用的影响，并且将来的关联仍将接收以前的默认值。"
    },
    {
      "indent": 3,
      "text": "SCTP_ALL_ASSOC: Specifies that all current and future associations will be affected by this call.",
      "zh-CHS": "SCTP_ALL_ASSOC：指定所有当前和将来的关联都将受此调用的影响。"
    },
    {
      "indent": 0,
      "text": "7.3. read() and write()",
      "section_title": true,
      "zh-CHS": "7.3. 读（）和写（）"
    },
    {
      "indent": 3,
      "text": "Applications can use read() and write() to receive and send data from and to a peer. They have the same semantics as recv() and send(), except that the flags parameter cannot be used.",
      "zh-CHS": "应用程序可以使用read（）和write（）从对等方接收和发送数据。它们的语义与recv（）和send（）相同，只是不能使用flags参数。"
    },
    {
      "indent": 0,
      "text": "7.4. getsockname()",
      "section_title": true,
      "zh-CHS": "7.4. getsockname（）"
    },
    {
      "indent": 3,
      "text": "Applications use getsockname() to retrieve the locally bound socket address of the specified socket. This is especially useful if the caller let SCTP choose a local port. This call is for single-homed endpoints. It does not work well with multi-homed endpoints. See Section 9.5 for a multi-homed version of the call.",
      "zh-CHS": "应用程序使用getsockname（）检索指定套接字的本地绑定套接字地址。如果调用方让SCTP选择一个本地端口，这尤其有用。此调用适用于单宿主端点。它不适用于多宿主端点。有关呼叫的多宿版本，请参见第9.5节。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int getsockname(int sd, struct sockaddr *address, socklen_t *len);",
      "zh-CHS": "int getsockname（int-sd，结构sockaddr*地址，socklen\\u t*len）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor to be queried.",
      "zh-CHS": "sd：要查询的套接字描述符。"
    },
    {
      "indent": 3,
      "text": "address: On return, one locally bound address (chosen by the SCTP stack) is stored in this buffer. If the socket is an IPv4 socket, the address will be IPv4. If the socket is an IPv6 socket, the address will be either an IPv6 or IPv4 address.",
      "zh-CHS": "地址：返回时，一个本地绑定地址（由SCTP堆栈选择）存储在此缓冲区中。如果套接字是IPv4套接字，则地址将是IPv4。如果套接字是IPv6套接字，则地址将是IPv6或IPv4地址。"
    },
    {
      "indent": 3,
      "text": "len: The caller should set the length of the address here. On return, this is set to the length of the returned address.",
      "zh-CHS": "len:呼叫者应该在这里设置地址的长度。返回时，该值设置为返回地址的长度。"
    },
    {
      "indent": 3,
      "text": "getsockname() returns 0 on success and -1 in case of an error.",
      "zh-CHS": "getsockname（）成功时返回0，错误时返回-1。"
    },
    {
      "indent": 3,
      "text": "If the actual length of the address is greater than the length of the supplied sockaddr structure, the stored address will be truncated.",
      "zh-CHS": "如果地址的实际长度大于提供的sockaddr结构的长度，则存储的地址将被截断。"
    },
    {
      "indent": 3,
      "text": "If the socket has not been bound to a local name, the value stored in the object pointed to by address is unspecified.",
      "zh-CHS": "如果套接字尚未绑定到本地名称，则存储在地址指向的对象中的值是未指定的。"
    },
    {
      "indent": 0,
      "text": "7.5. Implicit Association Setup",
      "section_title": true,
      "zh-CHS": "7.5. 隐式关联设置"
    },
    {
      "indent": 3,
      "text": "The application can begin sending and receiving data using the sendmsg()/recvmsg() or sendto()/recvfrom() calls, without going through any explicit association setup procedures (i.e., no connect() calls required).",
      "zh-CHS": "应用程序可以使用sendmsg（）/recvmsg（）或sendto（）/recvfrom（）调用开始发送和接收数据，而无需执行任何显式关联设置过程（即不需要connect（）调用）。"
    },
    {
      "indent": 3,
      "text": "Whenever sendmsg() or sendto() is called and the SCTP stack at the sender finds that no association exists between the sender and the intended receiver (identified by the address passed either in the msg_name field of the msghdr structure in the sendmsg() call or the dest_addr field in the sendto() call), the SCTP stack will automatically set up an association to the intended receiver.",
      "zh-CHS": "无论何时调用sendmsg（）或sendto（），且发送方的SCTP堆栈发现发送方和预期接收方之间不存在关联（通过sendmsg（）调用中msghdr结构的msg_name字段或sendto（）调用中的dest_addr字段中传递的地址标识），SCTP堆栈将自动设置与预期接收器的关联。"
    },
    {
      "indent": 3,
      "text": "Upon successful association setup, an SCTP_COMM_UP notification will be dispatched to the socket at both the sender and receiver side. This notification can be read by the recvmsg() system call (see Section 3.1.4).",
      "zh-CHS": "成功建立关联后，将向发送方和接收方的套接字发送SCTP_COMM_UP通知。recvmsg（）系统调用可以读取此通知（请参阅第3.1.4节）。"
    },
    {
      "indent": 3,
      "text": "Note that if the SCTP stack at the sender side supports bundling, the first user message may be bundled with the COOKIE ECHO message [RFC4960].",
      "zh-CHS": "注意，如果发送方端的SCTP堆栈支持绑定，则第一条用户消息可能与COOKIE ECHO消息[RFC4960]绑定。"
    },
    {
      "indent": 3,
      "text": "When the SCTP stack sets up a new association implicitly, the SCTP_INIT type ancillary data may also be passed along (see Section 5.3.1 for details of the data structures) to change some parameters used in setting up a new association.",
      "zh-CHS": "当SCTP堆栈隐式设置新关联时，也可以传递SCTP_INIT类型的辅助数据（有关数据结构的详细信息，请参见第5.3.1节），以更改设置新关联时使用的一些参数。"
    },
    {
      "indent": 3,
      "text": "If this information is not present in the sendmsg() call, or if the implicit association setup is triggered by a sendto() call, the default association initialization parameters will be used. These default association parameters may be set with respective setsockopt() calls or be left to the system defaults.",
      "zh-CHS": "如果sendmsg（）调用中不存在此信息，或者如果sendto（）调用触发了隐式关联设置，则将使用默认关联初始化参数。这些默认关联参数可以通过相应的setsockopt（）调用进行设置，也可以由系统默认设置。"
    },
    {
      "indent": 3,
      "text": "Implicit association setup cannot be initiated by send() calls.",
      "zh-CHS": "无法通过send（）调用启动隐式关联设置。"
    },
    {
      "indent": 0,
      "text": "8. Socket Options",
      "section_title": true,
      "zh-CHS": "8. 插座选项"
    },
    {
      "indent": 3,
      "text": "The following subsection describes various SCTP-level socket options that are common to both styles. SCTP associations can be multi-homed. Therefore, certain option parameters include a sockaddr_storage structure to select to which peer address the option should be applied.",
      "zh-CHS": "以下小节介绍两种样式共有的各种SCTP级别套接字选项。SCTP关联可以是多宿主的。因此，某些选项参数包括一个sockaddr_存储结构，用于选择该选项应应用于哪个对等地址。"
    },
    {
      "indent": 3,
      "text": "For the one-to-many style sockets, an sctp_assoc_t (association identifier) parameter is used to identify the association instance that the operation affects. So it must be set when using this style.",
      "zh-CHS": "对于一对多样式套接字，sctp_assoc_t（关联标识符）参数用于标识操作影响的关联实例。因此，在使用此样式时必须设置它。"
    },
    {
      "indent": 3,
      "text": "For the one-to-one style sockets and branched-off one-to-many style sockets (see Section 9.2), this association ID parameter is ignored.",
      "zh-CHS": "对于一对一样式套接字和分支的一对多样式套接字（参见第9.2节），此关联ID参数将被忽略。"
    },
    {
      "indent": 3,
      "text": "Note that socket- or IP-level options are set or retrieved per socket. This means that for one-to-many style sockets, the options will be applied to all associations (similar to using SCTP_ALL_ASSOC as the association identifier) belonging to the socket. For the one-to-one style, these options will be applied to all peer addresses of the association controlled by the socket. Applications should be careful in setting those options.",
      "zh-CHS": "请注意，每个套接字都设置或检索套接字或IP级别选项。这意味着对于一对多样式套接字，选项将应用于属于该套接字的所有关联（类似于使用SCTP_all_ASSOC作为关联标识符）。对于一对一样式，这些选项将应用于套接字控制的关联的所有对等地址。应用程序在设置这些选项时应小心。"
    },
    {
      "indent": 3,
      "text": "For some IP stacks, getsockopt() is read-only, so a new interface will be needed when information must be passed both into and out of the SCTP stack. The syntax for sctp_opt_info() is",
      "zh-CHS": "对于某些IP堆栈，getsockopt（）是只读的，因此当信息必须传入和传出SCTP堆栈时，需要一个新接口。sctp_opt_info（）的语法为"
    },
    {
      "indent": 3,
      "text": "int sctp_opt_info(int sd, sctp_assoc_t id, int opt, void *arg, socklen_t *size);",
      "zh-CHS": "int sctp_opt_info（int sd、sctp_assoc_t id、int opt、void*arg、socklen_t*size）；"
    },
    {
      "indent": 3,
      "text": "The sctp_opt_info() call is a replacement for getsockopt() only and will not set any options associated with the specified socket. A setsockopt() call must be used to set any writable option.",
      "zh-CHS": "sctp_opt_info（）调用仅替换getsockopt（），不会设置与指定套接字关联的任何选项。必须使用setsockopt（）调用来设置任何可写选项。"
    },
    {
      "indent": 3,
      "text": "For one-to-many style sockets, id specifies the association to query. For one-to-one style sockets, id is ignored. For one-to-many style sockets, any association identifier in the structure provided as arg is ignored, and id takes precedence.",
      "zh-CHS": "对于一对多样式套接字，id指定要查询的关联。对于一对一样式的套接字，将忽略id。对于一对多样式套接字，将忽略作为arg提供的结构中的任何关联标识符，id优先。"
    },
    {
      "indent": 3,
      "text": "Note that SCTP_CURRENT_ASSOC and SCTP_ALL_ASSOC cannot be used with sctp_opt_info() or in getsockopt() calls. Using them will result in an error (returning -1 and errno set to EINVAL). SCTP_FUTURE_ASSOC can be used to query information for future associations.",
      "zh-CHS": "请注意，SCTP_CURRENT_ASSOC和SCTP_ALL_ASSOC不能与SCTP_opt_info（）或getsockopt（）调用一起使用。使用它们将导致错误（将-1和errno设置返回到EINVAL）。SCTP_FUTURE_ASSOC可用于查询未来关联的信息。"
    },
    {
      "indent": 3,
      "text": "The field opt specifies which SCTP socket option to get. It can get any socket option currently supported that requests information (either read/write options or read-only) such as",
      "zh-CHS": "字段opt指定要获取哪个SCTP套接字选项。它可以获取当前支持的请求信息的任何套接字选项（读/写选项或只读），例如"
    },
    {
      "indent": 3,
      "text": "SCTP_RTOINFO",
      "zh-CHS": "SCTP_RTOINFO"
    },
    {
      "indent": 3,
      "text": "SCTP_ASSOCINFO",
      "zh-CHS": "SCTP_协会信息"
    },
    {
      "indent": 3,
      "text": "SCTP_PRIMARY_ADDR",
      "zh-CHS": "SCTP\\u主地址"
    },
    {
      "indent": 3,
      "text": "SCTP_PEER_ADDR_PARAMS",
      "zh-CHS": "SCTP_PEER_ADDR_参数"
    },
    {
      "indent": 3,
      "text": "SCTP_DEFAULT_SEND_PARAM",
      "zh-CHS": "SCTP_默认_发送_参数"
    },
    {
      "indent": 3,
      "text": "SCTP_MAX_SEG",
      "zh-CHS": "SCTP_最大_段"
    },
    {
      "indent": 3,
      "text": "SCTP_AUTH_ACTIVE_KEY",
      "zh-CHS": "SCTP\\u验证\\u活动\\u密钥"
    },
    {
      "indent": 3,
      "text": "SCTP_DELAYED_SACK",
      "zh-CHS": "SCTP_延迟_袋"
    },
    {
      "indent": 3,
      "text": "SCTP_MAX_BURST",
      "zh-CHS": "最大脉冲群"
    },
    {
      "indent": 3,
      "text": "SCTP_CONTEXT",
      "zh-CHS": "SCTP_上下文"
    },
    {
      "indent": 3,
      "text": "SCTP_EVENT",
      "zh-CHS": "SCTP_事件"
    },
    {
      "indent": 3,
      "text": "SCTP_DEFAULT_SNDINFO",
      "zh-CHS": "SCTP\\u默认值\\u SNDINFO"
    },
    {
      "indent": 3,
      "text": "SCTP_DEFAULT_PRINFO",
      "zh-CHS": "SCTP\\u默认值\\u原则"
    },
    {
      "indent": 3,
      "text": "SCTP_STATUS",
      "zh-CHS": "SCTP_状态"
    },
    {
      "indent": 3,
      "text": "SCTP_GET_PEER_ADDR_INFO",
      "zh-CHS": "SCTP\\u获取\\u对等\\u地址\\u信息"
    },
    {
      "indent": 3,
      "text": "SCTP_PEER_AUTH_CHUNKS",
      "zh-CHS": "SCTP_PEER_AUTH_块"
    },
    {
      "indent": 3,
      "text": "SCTP_LOCAL_AUTH_CHUNKS",
      "zh-CHS": "SCTP_本地_身份验证_块"
    },
    {
      "indent": 3,
      "text": "The arg field is an option-specific structure buffer provided by the caller. See the rest of this section for more information on these options and option-specific structures.",
      "zh-CHS": "arg字段是调用方提供的特定于选项的结构缓冲区。有关这些选项和选项特定结构的更多信息，请参阅本节的其余部分。"
    },
    {
      "indent": 3,
      "text": "sctp_opt_info() returns 0 on success, or on failure returns -1 and sets errno to the appropriate error code.",
      "zh-CHS": "sctp_opt_info（）成功时返回0，失败时返回-1并将errno设置为相应的错误代码。"
    },
    {
      "indent": 0,
      "text": "8.1. Read/Write Options",
      "section_title": true,
      "zh-CHS": "8.1. 读/写选项"
    },
    {
      "indent": 0,
      "text": "8.1.1. Retransmission Timeout Parameters (SCTP_RTOINFO)",
      "section_title": true,
      "zh-CHS": "8.1.1. 重传超时参数（SCTP\\U RTOINFO）"
    },
    {
      "indent": 3,
      "text": "The protocol parameters used to initialize and limit the retransmission timeout (RTO) are tunable. See [RFC4960] for more information on how these parameters are used in RTO calculation.",
      "zh-CHS": "用于初始化和限制重传超时（RTO）的协议参数是可调的。有关如何在RTO计算中使用这些参数的更多信息，请参见[RFC4960]。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify these parameters:",
      "zh-CHS": "以下结构用于访问和修改这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_rtoinfo {\n  sctp_assoc_t srto_assoc_id;\n  uint32_t srto_initial;\n  uint32_t srto_max;\n  uint32_t srto_min;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "srto_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, the application may fill in an association identifier or SCTP_FUTURE_ASSOC. It is an error to use SCTP_{CURRENT|ALL}_ASSOC in srto_assoc_id.",
      "zh-CHS": "srto_assoc_id：对于一对一样式套接字，忽略此参数。对于一对多样式套接字，应用程序可能会填写关联标识符或SCTP_FUTURE_ASSOC。在srto_ASSOC_id中使用SCTP_{CURRENT | ALL}_ASSOC是错误的。"
    },
    {
      "indent": 3,
      "text": "srto_initial: This parameter contains the initial RTO value.",
      "zh-CHS": "srto_initial：此参数包含初始RTO值。"
    },
    {
      "indent": 3,
      "text": "srto_max and srto_min: These parameters contain the maximum and minimum bounds for all RTOs.",
      "zh-CHS": "srto_max和srto_min：这些参数包含所有RTO的最大和最小界限。"
    },
    {
      "indent": 3,
      "text": "All times are given in milliseconds. A value of 0, when modifying the parameters, indicates that the current value should not be changed.",
      "zh-CHS": "所有时间均以毫秒为单位。修改参数时，值为0表示不应更改当前值。"
    },
    {
      "indent": 3,
      "text": "To access or modify these parameters, the application should call getsockopt() or setsockopt(), respectively, with the option name SCTP_RTOINFO.",
      "zh-CHS": "要访问或修改这些参数，应用程序应分别调用getsockopt（）或setsockopt（），选项名为SCTP_RTOINFO。"
    },
    {
      "indent": 0,
      "text": "8.1.2. Association Parameters (SCTP_ASSOCINFO)",
      "section_title": true,
      "zh-CHS": "8.1.2. 关联参数（SCTP_AssociInfo）"
    },
    {
      "indent": 3,
      "text": "This option is used to both examine and set various association and endpoint parameters. See [RFC4960] for more information on how these parameters are used.",
      "zh-CHS": "此选项用于检查和设置各种关联和端点参数。有关如何使用这些参数的更多信息，请参见[RFC4960]。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify these parameters:",
      "zh-CHS": "以下结构用于访问和修改这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_assocparams {\n  sctp_assoc_t sasoc_assoc_id;\n  uint16_t sasoc_asocmaxrxt;\n  uint16_t sasoc_number_peer_destinations;\n  uint32_t sasoc_peer_rwnd;\n  uint32_t sasoc_local_rwnd;\n  uint32_t sasoc_cookie_life;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sasoc_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, the application may fill in an association identifier or SCTP_FUTURE_ASSOC. It is an error to use SCTP_{CURRENT|ALL}_ASSOC in sasoc_assoc_id.",
      "zh-CHS": "sasoc_assoc_id：对于一对一样式的套接字，忽略此参数。对于一对多样式套接字，应用程序可能会填写关联标识符或SCTP_FUTURE_ASSOC。在sasoc_ASSOC_id中使用SCTP_{CURRENT | ALL}_ASSOC是错误的。"
    },
    {
      "indent": 3,
      "text": "sasoc_asocmaxrxt: This parameter contains the maximum retransmission attempts to make for the association.",
      "zh-CHS": "sasoc_asocmaxrxt：此参数包含为关联进行的最大重新传输尝试。"
    },
    {
      "indent": 3,
      "text": "sasoc_number_peer_destinations: This parameter is the number of destination addresses that the peer has.",
      "zh-CHS": "sasoc_number_peer_destinations：此参数是对等方拥有的目标地址数。"
    },
    {
      "indent": 3,
      "text": "sasoc_peer_rwnd: This parameter holds the current value of the peer's rwnd (reported in the last selective acknowledgment (SACK)) minus any outstanding data (i.e., data in flight).",
      "zh-CHS": "sasoc_peer_rwnd：此参数保存对等方的rwnd（在上次选择性确认（SACK）中报告）的当前值减去任何未完成的数据（即飞行中的数据）。"
    },
    {
      "indent": 3,
      "text": "sasoc_local_rwnd: This parameter holds the last reported rwnd that was sent to the peer.",
      "zh-CHS": "sasoc_local_rwnd：此参数保存发送给对等方的上一次报告的rwnd。"
    },
    {
      "indent": 3,
      "text": "sasoc_cookie_life: This parameter is the association's cookie life value used when issuing cookies.",
      "zh-CHS": "sasoc_cookie_life：此参数是发布cookie时使用的关联的cookie life值。"
    },
    {
      "indent": 3,
      "text": "The value of sasoc_peer_rwnd is meaningless when examining endpoint information (i.e., it is only valid when examining information on a specific association).",
      "zh-CHS": "sasoc_peer_rwnd的值在检查端点信息时没有意义（即，它仅在检查特定关联的信息时有效）。"
    },
    {
      "indent": 3,
      "text": "All time values are given in milliseconds. A value of 0, when modifying the parameters, indicates that the current value should not be changed.",
      "zh-CHS": "所有时间值均以毫秒为单位。修改参数时，值为0表示不应更改当前值。"
    },
    {
      "indent": 3,
      "text": "The values of sasoc_asocmaxrxt and sasoc_cookie_life may be set on either an endpoint or association basis. The rwnd and destination counts (sasoc_number_peer_destinations, sasoc_peer_rwnd, sasoc_local_rwnd) are not settable, and any value placed in these is ignored.",
      "zh-CHS": "sasoc_asocmaxrxt和sasoc_cookie_life的值可以在端点或关联基础上设置。rwnd和目的地计数（sasoc\\u编号\\u对等\\u目的地、sasoc\\u对等\\u rwnd、sasoc\\u本地\\u rwnd）不可设置，并且忽略其中的任何值。"
    },
    {
      "indent": 3,
      "text": "To access or modify these parameters, the application should call getsockopt() or setsockopt(), respectively, with the option name SCTP_ASSOCINFO.",
      "zh-CHS": "要访问或修改这些参数，应用程序应分别调用getsockopt（）或setsockopt（），选项名为SCTP_ASSOCINFO。"
    },
    {
      "indent": 3,
      "text": "The maximum number of retransmissions before an address is considered unreachable is also tunable, but is address-specific, so it is covered in a separate option. If an application attempts to set the value of the association's maximum retransmission parameter to more than the sum of all maximum retransmission parameters, setsockopt() may return an error. The reason for this, from Section 8.2 of [RFC4960], is as follows:",
      "zh-CHS": "在地址被视为不可访问之前的最大重传次数也是可调的，但它是特定于地址的，因此它包含在单独的选项中。如果应用程序试图将关联的最大重传参数的值设置为大于所有最大重传参数之和，则setsockopt（）可能会返回错误。根据[RFC4960]第8.2节，原因如下："
    },
    {
      "indent": 6,
      "text": "Note: When configuring the SCTP endpoint, the user should avoid having the value of 'Association.Max.Retrans' (sasoc_maxrxt in this option) larger than the summation of the 'Path.Max.Retrans' (see spp_pathmaxrxt in Section 8.1.12) of all of the destination addresses for the remote endpoint. Otherwise, all of the destination addresses may become inactive while the endpoint still considers the peer endpoint reachable.",
      "zh-CHS": "注意：配置SCTP端点时，用户应避免“Association.Max.Retrans”（此选项中的sasoc_maxrxt）的值大于远程端点所有目标地址的“Path.Max.Retrans”（参见第8.1.12节中的spp_pathmaxrxt）之和。否则，当端点仍然认为对等端点可到达时，所有目标地址都可能变为非活动。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Initialization Parameters (SCTP_INITMSG)",
      "section_title": true,
      "zh-CHS": "8.1.3. 初始化参数（SCTP_INITMSG）"
    },
    {
      "indent": 3,
      "text": "Applications can specify protocol parameters for the default association initialization. The structure used to access and modify these parameters is defined in Section 5.3.1. The option name argument to setsockopt() and getsockopt() is SCTP_INITMSG.",
      "zh-CHS": "应用程序可以为默认关联初始化指定协议参数。第5.3.1节定义了用于访问和修改这些参数的结构。setsockopt（）和getsockopt（）的option name参数是SCTP_INITMSG。"
    },
    {
      "indent": 3,
      "text": "Setting initialization parameters is effective only on an unconnected socket (for one-to-many style sockets, only future associations are affected by the change).",
      "zh-CHS": "设置初始化参数仅在未连接的套接字上有效（对于一对多样式套接字，只有将来的关联会受到更改的影响）。"
    },
    {
      "indent": 0,
      "text": "8.1.4. SO_LINGER",
      "section_title": true,
      "zh-CHS": "8.1.4. 所以你留恋"
    },
    {
      "indent": 3,
      "text": "An application can use this option to perform the SCTP ABORT primitive. This option affects all associations related to the socket.",
      "zh-CHS": "应用程序可以使用此选项执行SCTP ABORT原语。此选项影响与套接字相关的所有关联。"
    },
    {
      "indent": 3,
      "text": "The linger option structure is",
      "zh-CHS": "玲珑期权结构为"
    },
    {
      "indent": 3,
      "text": "struct linger {\n  int l_onoff;  /* option on/off */\n  int l_linger; /* linger time   */\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "To enable the option, set l_onoff to 1. If the l_linger value is set to 0, calling close() is the same as the ABORT primitive. If the value is set to a negative value, the setsockopt() call will return an error. If the value is set to a positive value linger_time, the close() can be blocked for at most linger_time. Please note that the time unit is in seconds, according to POSIX, but might be different on specific platforms. If the graceful shutdown phase does not finish during this period, close() will return, but the graceful shutdown phase will continue in the system.",
      "zh-CHS": "要启用该选项，请将l_onoff设置为1。如果l_linger值设置为0，则调用close（）与ABORT原语相同。如果该值设置为负值，则setsockopt（）调用将返回错误。如果该值设置为正值linger\\u time，则close（）最多可被阻止一段时间。请注意，根据POSIX，时间单位为秒，但在特定平台上可能有所不同。如果在此期间未完成正常关机阶段，close（）将返回，但正常关机阶段将在系统中继续。"
    },
    {
      "indent": 3,
      "text": "Note that this is a socket-level option, not an SCTP-level option. When using this option, an application must specify a level of SOL_SOCKET in the call.",
      "zh-CHS": "请注意，这是一个套接字级别选项，而不是SCTP级别选项。使用此选项时，应用程序必须在调用中指定SOL_套接字的级别。"
    },
    {
      "indent": 0,
      "text": "8.1.5. SCTP_NODELAY",
      "section_title": true,
      "zh-CHS": "8.1.5. SCTP_NODELAY"
    },
    {
      "indent": 3,
      "text": "This option turns on/off any Nagle-like algorithm. This means that packets are generally sent as soon as possible, and no unnecessary delays are introduced, at the cost of more packets in the network. In particular, not using any Nagle-like algorithm might reduce the bundling of small user messages in cases where this would require an additional delay.",
      "zh-CHS": "此选项打开/关闭任何类似Nagle的算法。这意味着数据包通常是尽快发送的，并且不会引入不必要的延迟，这是以网络中的更多数据包为代价的。特别是，在需要额外延迟的情况下，不使用任何类似Nagle的算法可能会减少小用户消息的捆绑。"
    },
    {
      "indent": 3,
      "text": "Turning this option on disables any Nagle-like algorithm.",
      "zh-CHS": "启用此选项将禁用任何类似Nagle的算法。"
    },
    {
      "indent": 3,
      "text": "This option expects an integer boolean flag, where a non-zero value turns on the option, and a zero value turns off the option.",
      "zh-CHS": "此选项需要一个整数布尔标志，其中非零值打开该选项，零值关闭该选项。"
    },
    {
      "indent": 0,
      "text": "8.1.6. SO_RCVBUF",
      "section_title": true,
      "zh-CHS": "8.1.6. 所以(u RCVBUF)"
    },
    {
      "indent": 3,
      "text": "This option sets the receive buffer size in octets. For SCTP one-to-one style sockets, this option controls the receiver window size. For one-to-many style sockets, the meaning is implementation dependent. It might control the receive buffer for each association bound to the socket descriptor, or it might control the receive buffer for the whole socket. This option expects an integer.",
      "zh-CHS": "此选项以八位字节为单位设置接收缓冲区大小。对于SCTP一对一样式插座，此选项控制接收器窗口大小。对于一对多样式套接字，其含义取决于实现。它可以控制绑定到套接字描述符的每个关联的接收缓冲区，也可以控制整个套接字的接收缓冲区。此选项需要一个整数。"
    },
    {
      "indent": 3,
      "text": "Note that this is a socket-level option, not an SCTP-level option. When using this option, an application must specify a level of SOL_SOCKET in the call.",
      "zh-CHS": "请注意，这是一个套接字级别选项，而不是SCTP级别选项。使用此选项时，应用程序必须在调用中指定SOL_套接字的级别。"
    },
    {
      "indent": 0,
      "text": "8.1.7. SO_SNDBUF",
      "section_title": true,
      "zh-CHS": "8.1.7. 苏斯努德布夫"
    },
    {
      "indent": 3,
      "text": "This option sets the send buffer size. For SCTP one-to-one style sockets, this option controls the amount of data SCTP may have waiting in internal buffers to be sent. This option therefore bounds the maximum size of data that can be sent in a single send call. For one-to-many style sockets, the effect is the same, except that it applies to one or all associations (see Section 3.3) bound to the socket descriptor used in the setsockopt() or getsockopt() call. The option applies to each association's window size separately. This option expects an integer.",
      "zh-CHS": "此选项设置发送缓冲区大小。对于SCTP一对一样式的套接字，此选项控制SCTP在内部缓冲区中等待发送的数据量。因此，此选项限制单个发送调用中可以发送的最大数据大小。对于一对多样式套接字，效果相同，只是它适用于绑定到setsockopt（）或getsockopt（）调用中使用的套接字描述符的一个或所有关联（请参见第3.3节）。该选项分别应用于每个关联的窗口大小。此选项需要一个整数。"
    },
    {
      "indent": 3,
      "text": "Note that this is a socket-level option, not an SCTP-level option. When using this option, an application must specify a level of SOL_SOCKET in the call.",
      "zh-CHS": "请注意，这是一个套接字级别选项，而不是SCTP级别选项。使用此选项时，应用程序必须在调用中指定SOL_套接字的级别。"
    },
    {
      "indent": 0,
      "text": "8.1.8. Automatic Close of Associations (SCTP_AUTOCLOSE)",
      "section_title": true,
      "zh-CHS": "8.1.8. 自动关闭关联（SCTP\\U自动关闭）"
    },
    {
      "indent": 3,
      "text": "This socket option is applicable to the one-to-many style socket only. When set, it will cause associations that are idle for more than the specified number of seconds to automatically close using the graceful shutdown procedure. An idle association is defined as an association that has not sent or received user data. The special value of '0' indicates that no automatic close of any association should be performed; this is the default value. This option expects an integer defining the number of seconds of idle time before an association is closed.",
      "zh-CHS": "此套接字选项仅适用于一对多样式的套接字。设置后，将使用正常关闭过程自动关闭空闲时间超过指定秒数的关联。空闲关联定义为未发送或接收用户数据的关联。特殊值“0”表示不应自动关闭任何关联；这是默认值。此选项需要一个整数，定义关闭关联前的空闲时间秒数。"
    },
    {
      "indent": 3,
      "text": "An application using this option should enable the ability to receive the association change notification. This is the only mechanism by which an application is informed about the closing of an association. After an association is closed, the association identifier assigned to it can be reused. An application should be aware of this to avoid the possible problem of sending data to an incorrect peer endpoint.",
      "zh-CHS": "使用此选项的应用程序应能够接收关联更改通知。这是通知应用程序关闭关联的唯一机制。关闭关联后，可以重用分配给它的关联标识符。应用程序应该意识到这一点，以避免向不正确的对等端点发送数据的可能问题。"
    },
    {
      "indent": 0,
      "text": "8.1.9. Set Primary Address (SCTP_PRIMARY_ADDR)",
      "section_title": true,
      "zh-CHS": "8.1.9. 设置主地址（SCTP\\U Primary\\U ADDR）"
    },
    {
      "indent": 3,
      "text": "This option requests that the local SCTP stack uses the enclosed peer address as the association's primary. The enclosed address must be one of the association peer's addresses.",
      "zh-CHS": "此选项要求本地SCTP堆栈使用附带的对等地址作为关联的主地址。所附地址必须是协会对等方的地址之一。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to make a set peer primary request:",
      "zh-CHS": "以下结构用于发出设置对等主请求："
    },
    {
      "indent": 3,
      "text": "struct sctp_setprim {\n  sctp_assoc_t ssp_assoc_id;\n  struct sockaddr_storage ssp_addr;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ssp_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, it identifies the association for this request. Note that the special sctp_assoc_t SCTP_{FUTURE|ALL|CURRENT}_ASSOC are not allowed.",
      "zh-CHS": "ssp_assoc_id：对于一对一样式的套接字，忽略此参数。对于一对多样式套接字，它标识此请求的关联。请注意，不允许使用特殊的sctp|u assoc|t sctp|{FUTURE | ALL | CURRENT}assoc。"
    },
    {
      "indent": 3,
      "text": "ssp_addr: This parameter is the address to set as primary. No wildcard address is allowed.",
      "zh-CHS": "ssp_addr：此参数是要设置为主地址的地址。不允许使用通配符地址。"
    },
    {
      "indent": 0,
      "text": "8.1.10. Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)",
      "section_title": true,
      "zh-CHS": "8.1.10. 设置适配层指示器（SCTP\\U适配层）"
    },
    {
      "indent": 3,
      "text": "This option requests that the local endpoint set the specified Adaptation Layer Indication parameter for all future INIT and INIT-ACK exchanges.",
      "zh-CHS": "此选项要求本地端点为所有未来的INIT和INIT-ACK交换设置指定的适配层指示参数。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify this parameter:",
      "zh-CHS": "以下结构用于访问和修改此参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_setadaptation {\n  uint32_t   ssb_adaptation_ind;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "ssb_adaptation_ind: The adaptation layer indicator that will be included in any outgoing Adaptation Layer Indication parameter.",
      "zh-CHS": "ssb_adaption_ind：将包含在任何传出适配层指示参数中的适配层指示符。"
    },
    {
      "indent": 0,
      "text": "8.1.11. Enable/Disable Message Fragmentation (SCTP_DISABLE_FRAGMENTS)",
      "section_title": true,
      "zh-CHS": "8.1.11. 启用/禁用消息分段（SCTP\\u禁用\\u分段）"
    },
    {
      "indent": 3,
      "text": "This option is an on/off flag and is passed as an integer, where a non-zero is on and a zero is off. If enabled, no SCTP message fragmentation will be performed. The effect of enabling this option",
      "zh-CHS": "此选项是一个开/关标志，作为整数传递，其中非零为开，零为关。如果启用，则不会执行SCTP消息分段。启用此选项的效果"
    },
    {
      "indent": 3,
      "text": "is that if a message being sent exceeds the current Path MTU (PMTU) size, the message will not be sent and instead an error will be indicated to the user. If this option is disabled (the default), then a message exceeding the size of the PMTU will be fragmented and reassembled by the peer.",
      "zh-CHS": "如果发送的消息超过当前路径MTU（PMTU）大小，则不会发送该消息，而是向用户指示错误。如果禁用此选项（默认设置），则超过PMTU大小的消息将被分割并由对等方重新组装。"
    },
    {
      "indent": 0,
      "text": "8.1.12. Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)",
      "section_title": true,
      "zh-CHS": "8.1.12. 对等地址参数（SCTP_Peer_ADDR_PARAMS）"
    },
    {
      "indent": 3,
      "text": "Applications can enable or disable heartbeats for any peer address of an association, modify an address's heartbeat interval, force a heartbeat to be sent immediately, and adjust the address's maximum number of retransmissions sent before an address is considered unreachable.",
      "zh-CHS": "应用程序可以为关联的任何对等地址启用或禁用心跳，修改地址的心跳间隔，强制立即发送心跳，并在认为无法访问地址之前调整地址发送的最大重传次数。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify an address's parameters:",
      "zh-CHS": "以下结构用于访问和修改地址的参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_paddrparams {\n  sctp_assoc_t spp_assoc_id;\n  struct sockaddr_storage spp_address;\n  uint32_t spp_hbinterval;\n  uint16_t spp_pathmaxrxt;\n  uint32_t spp_pathmtu;\n  uint32_t spp_flags;\n  uint32_t spp_ipv6_flowlabel;\n  uint8_t  spp_dscp;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "spp_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, the application may fill in an association identifier or SCTP_FUTURE_ASSOC for this query. It is an error to use SCTP_{CURRENT|ALL}_ASSOC in spp_assoc_id.",
      "zh-CHS": "spp_assoc_id：对于一对一样式的套接字，此参数被忽略。对于一对多样式套接字，应用程序可以为此查询填写关联标识符或SCTP_FUTURE_ASSOC。在spp_ASSOC_id中使用SCTP_{CURRENT | ALL}_ASSOC是一个错误。"
    },
    {
      "indent": 3,
      "text": "spp_address: This specifies which address is of interest. If a wildcard address is provided, it applies to all current and future paths.",
      "zh-CHS": "spp_地址：指定感兴趣的地址。如果提供了通配符地址，它将应用于所有当前和未来路径。"
    },
    {
      "indent": 3,
      "text": "spp_hbinterval: This contains the value of the heartbeat interval, in milliseconds (HB.Interval in [RFC4960]). Note that unless the spp_flags field is set to SPP_HB_ENABLE, the value of this field is ignored. Note also that a value of zero indicates that the current setting should be left unchanged. To set an actual value of zero, the SPP_HB_TIME_IS_ZERO flag should be used. Even when it is set to 0, it does not mean that SCTP will continuously send out heartbeats, since the actual interval also includes the current RTO and jitter (see Section 8.3 of [RFC4960]).",
      "zh-CHS": "spp_hbinterval：它包含心跳间隔的值，以毫秒为单位（HB.interval in[RFC4960]）。请注意，除非spp_flags字段设置为spp_HB_ENABLE，否则将忽略此字段的值。还请注意，值为零表示当前设置应保持不变。要将实际值设置为零，应使用SPP_HB_TIME_IS_zero标志。即使将其设置为0，也不意味着SCTP将持续发送心跳，因为实际间隔还包括当前RTO和抖动（参见[RFC4960]第8.3节）。"
    },
    {
      "indent": 3,
      "text": "spp_pathmaxrxt: This contains the maximum number of retransmissions before this address shall be considered unreachable. Note that a value of zero indicates that the current setting should be left unchanged.",
      "zh-CHS": "spp_pathmaxrxt：这包含在认为无法访问此地址之前的最大重传次数。请注意，值为零表示当前设置应保持不变。"
    },
    {
      "indent": 3,
      "text": "spp_pathmtu: This field contains the current Path MTU of the peer address. It is the number of bytes available in an SCTP packet for chunks. Providing a value of 0 does not change the current setting. If a positive value is provided and SPP_PMTUD_DISABLE is set in the spp_flags field, the given value is used as the Path MTU. If SPP_PMTUD_ENABLE is set in the spp_flags field, the spp_pathmtu field is ignored.",
      "zh-CHS": "spp_pathmtu：此字段包含对等地址的当前路径MTU。它是SCTP数据包中可用于数据块的字节数。提供值0不会更改当前设置。如果提供了正值，并且在SPP_标志字段中设置了SPP_PMTUD_DISABLE，则给定值将用作路径MTU。如果在SPP_标志字段中设置了SPP_PMTUD_启用，则忽略SPP_路径MTU字段。"
    },
    {
      "indent": 3,
      "text": "spp_flags: These flags are used to control various features on an association. The flag field is a bitmask that may contain zero or more of the following options:",
      "zh-CHS": "spp_标志：这些标志用于控制关联上的各种功能。标志字段是位掩码，可能包含以下零个或多个选项："
    },
    {
      "indent": 6,
      "text": "SPP_HB_ENABLE: This field enables heartbeats on the specified address.",
      "zh-CHS": "SPP_HB_ENABLE：此字段启用指定地址上的心跳。"
    },
    {
      "indent": 6,
      "text": "SPP_HB_DISABLE: This field disables heartbeats on the specified address. Note that SPP_HB_ENABLE and SPP_HB_DISABLE are mutually exclusive; only one of these two should be specified. Enabling both fields will yield undetermined results.",
      "zh-CHS": "SPP_HB_DISABLE：此字段禁用指定地址上的心跳。请注意，SPP_HB_ENABLE和SPP_HB_DISABLE是互斥的；仅应指定这两个选项中的一个。启用这两个字段将产生不确定的结果。"
    },
    {
      "indent": 6,
      "text": "SPP_HB_DEMAND: This field requests that a user-initiated heartbeat be made immediately. This must not be used in conjunction with a wildcard address.",
      "zh-CHS": "SPP_HB_DEMAND：此字段请求立即发出用户启动的心跳信号。这不能与通配符地址一起使用。"
    },
    {
      "indent": 6,
      "text": "SPP_HB_TIME_IS_ZERO: This field specifies that the time for heartbeat delay is to be set to 0 milliseconds.",
      "zh-CHS": "SPP_HB_TIME_为0：此字段指定心跳延迟的时间设置为0毫秒。"
    },
    {
      "indent": 6,
      "text": "SPP_PMTUD_ENABLE: This field will enable PMTU discovery on the specified address.",
      "zh-CHS": "SPP_PMTUD_ENABLE：此字段将在指定地址上启用PMTU发现。"
    },
    {
      "indent": 6,
      "text": "SPP_PMTUD_DISABLE: This field will disable PMTU discovery on the specified address. Note that if the address field is empty, then all addresses on the association are affected. Note also that SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually exclusive. Enabling both fields will yield undetermined results.",
      "zh-CHS": "SPP_PMTUD_DISABLE：此字段将禁用指定地址上的PMTU发现。请注意，如果地址字段为空，则关联上的所有地址都会受到影响。还请注意，SPP_PMTUD_ENABLE和SPP_PMTUD_DISABLE是互斥的。启用这两个字段将产生不确定的结果。"
    },
    {
      "indent": 6,
      "text": "SPP_IPV6_FLOWLABEL: Setting this flag enables the setting of the IPV6 flow label value. The value is contained in the spp_ipv6_flowlabel field.",
      "zh-CHS": "SPP_IPV6_流标签：设置此标志可启用IPV6流标签值的设置。该值包含在spp_ipv6_flowlabel字段中。"
    },
    {
      "indent": 9,
      "text": "Upon retrieval, this flag will be set to indicate that the spp_ipv6_flowlabel field has a valid value returned. If a specific destination address is set (in the spp_address field), then the value returned is that of the address. If just an association is specified (and no address), then the association's default flow label is returned. If neither an association nor a destination is specified, then the socket's default flow label is returned. For non-IPv6 sockets, this flag will be left cleared.",
      "zh-CHS": "检索时，此标志将设置为指示spp_ipv6_flowlabel字段返回了有效值。如果设置了特定的目标地址（在spp_地址字段中），则返回的值是该地址的值。如果只指定了一个关联（并且没有地址），则返回该关联的默认流标签。如果未指定关联或目标，则返回套接字的默认流标签。对于非IPv6套接字，此标志将保持清除状态。"
    },
    {
      "indent": 6,
      "text": "SPP_DSCP: Setting this flag enables the setting of the Differentiated Services Code Point (DSCP) value associated with either the association or a specific address. The value is obtained in the spp_dscp field.",
      "zh-CHS": "SPP_DSCP：设置此标志可启用与关联或特定地址关联的差异化服务代码点（DSCP）值的设置。该值在spp_dscp字段中获得。"
    },
    {
      "indent": 9,
      "text": "Upon retrieval, this flag will be set to indicate that the spp_dscp field has a valid value returned. If a specific destination address is set when called (in the spp_address field), then that specific destination address's DSCP value is returned. If just an association is specified, then the association's default DSCP is returned. If neither an association nor a destination is specified, then the socket's default DSCP is returned.",
      "zh-CHS": "检索时，此标志将设置为指示spp_dscp字段返回了有效值。如果调用时设置了特定的目标地址（在spp_地址字段中），则返回该特定目标地址的DSCP值。如果只指定了一个关联，则返回该关联的默认DSCP。如果未指定关联或目标，则返回套接字的默认DSCP。"
    },
    {
      "indent": 3,
      "text": "spp_ipv6_flowlabel: This field is used in conjunction with the SPP_IPV6_FLOWLABEL flag and contains the IPv6 flow label. The 20 least significant bits are used for the flow label. This setting has precedence over any IPv6-layer setting.",
      "zh-CHS": "spp_ipv6_flowlabel：此字段与spp_ipv6_flowlabel标志一起使用，并包含ipv6流标签。20个最低有效位用于流标签。此设置优先于任何IPv6层设置。"
    },
    {
      "indent": 3,
      "text": "spp_dscp: This field is used in conjunction with the SPP_DSCP flag and contains the DSCP. The 6 most significant bits are used for the DSCP. This setting has precedence over any IPv4- or IPv6- layer setting.",
      "zh-CHS": "spp_dscp：此字段与spp_dscp标志一起使用，并包含dscp。6个最高有效位用于DSCP。此设置优先于任何IPv4或IPv6层设置。"
    },
    {
      "indent": 3,
      "text": "Please note that changing the flow label or DSCP value will affect all packets sent by the SCTP stack after setting these parameters. The flow label might also be set via the sin6_flowinfo field of the sockaddr_in6 structure.",
      "zh-CHS": "请注意，设置这些参数后，更改流标签或DSCP值将影响SCTP堆栈发送的所有数据包。还可以通过sockaddr_in6结构的sin6_flowinfo字段设置流标签。"
    },
    {
      "indent": 0,
      "text": "8.1.13. Set Default Send Parameters (SCTP_DEFAULT_SEND_PARAM) - DEPRECATED",
      "zh-CHS": "8.1.13. 设置默认发送参数（SCTP\\U Default\\U Send\\U PARAM）-已弃用"
    },
    {
      "indent": 3,
      "text": "Please note that this option is deprecated. SCTP_DEFAULT_SNDINFO (Section 8.1.31) should be used instead.",
      "zh-CHS": "请注意，此选项已弃用。应改用SCTP_DEFAULT_SNDINFO（第8.1.31节）。"
    },
    {
      "indent": 3,
      "text": "Applications that wish to use the sendto() system call may wish to specify a default set of parameters that would normally be supplied through the inclusion of ancillary data. This socket option allows",
      "zh-CHS": "希望使用sendto（）系统调用的应用程序可能希望指定一组默认参数，这些参数通常通过包含辅助数据来提供。此套接字选项允许"
    },
    {
      "indent": 3,
      "text": "such an application to set the default sctp_sndrcvinfo structure. The application that wishes to use this socket option simply passes the sctp_sndrcvinfo structure (defined in Section 5.3.2) to this call. The input parameters accepted by this call include sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context, and sinfo_timetolive. The sinfo_flags field is composed of a bitwise OR of SCTP_UNORDERED, SCTP_EOF, and SCTP_SENDALL. The sinfo_assoc_id field specifies the association to which to apply the parameters. For a one-to-many style socket, any of the predefined constants are also allowed in this field. The field is ignored for one-to-one style sockets.",
      "zh-CHS": "这样的应用程序可以设置默认的sctp_sndrcvinfo结构。希望使用此套接字选项的应用程序只需将sctp_sndrcvinfo结构（在第5.3.2节中定义）传递给此调用。此调用接受的输入参数包括sinfo_流、sinfo_标志、sinfo_ppid、sinfo_上下文和sinfo_timetolive。sinfo_flags字段由SCTP_UNORDERED、SCTP_EOF和SCTP_SENDALL的按位OR组成。sinfo_assoc_id字段指定要应用参数的关联。对于一对多样式套接字，此字段中还允许使用任何预定义常量。一对一样式套接字忽略该字段。"
    },
    {
      "indent": 0,
      "text": "8.1.14. Set Notification and Ancillary Events (SCTP_EVENTS) - DEPRECATED",
      "zh-CHS": "8.1.14. 设置通知和辅助事件（SCTP_事件）-已弃用"
    },
    {
      "indent": 3,
      "text": "This socket option is used to specify various notifications and ancillary data the user wishes to receive. Please see Section 6.2.1 for a full description of this option and its usage. Note that this option is considered deprecated and is present for backward compatibility. New applications should use the SCTP_EVENT option. See Section 6.2.2 for a full description of that option as well.",
      "zh-CHS": "此套接字选项用于指定用户希望接收的各种通知和辅助数据。请参阅第6.2.1节，了解该选项及其用法的完整说明。请注意，此选项被视为已弃用，并且是为了向后兼容而提供的。新应用程序应使用SCTP_事件选项。有关该选项的完整说明，请参见第6.2.2节。"
    },
    {
      "indent": 0,
      "text": "8.1.15. Set/Clear IPv4 Mapped Addresses (SCTP_I_WANT_MAPPED_V4_ADDR)",
      "section_title": true,
      "zh-CHS": "8.1.15. 设置/清除IPv4映射地址（SCTP\\u I\\u WANT\\u Mapped\\u V4\\u ADDR）"
    },
    {
      "indent": 3,
      "text": "This socket option is a boolean flag that turns on or off the mapping of IPv4 addresses. If this option is turned on, then IPv4 addresses will be mapped to IPv6 representation. If this option is turned off, then no mapping will be done of IPv4 addresses, and a user will receive both PF_INET6 and PF_INET type addresses on the socket. See [RFC3542] for more details on mapped IPv6 addresses.",
      "zh-CHS": "此套接字选项是一个布尔标志，用于打开或关闭IPv4地址的映射。如果启用此选项，则IPv4地址将映射到IPv6表示。如果关闭此选项，则不会对IPv4地址进行映射，并且用户将在套接字上接收PF_INET6和PF_INET类型的地址。有关映射的IPv6地址的更多详细信息，请参阅[RFC3542]。"
    },
    {
      "indent": 3,
      "text": "If this socket option is used on a socket of type PF_INET, an error is returned.",
      "zh-CHS": "如果在PF_INET类型的套接字上使用此套接字选项，则返回错误。"
    },
    {
      "indent": 3,
      "text": "By default, this option is turned off and expects an integer to be passed where a non-zero value turns on the option and a zero value turns off the option.",
      "zh-CHS": "默认情况下，此选项处于禁用状态，并期望传递一个整数，其中非零值打开该选项，零值关闭该选项。"
    },
    {
      "indent": 0,
      "text": "8.1.16. Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)",
      "section_title": true,
      "zh-CHS": "8.1.16. 获取或设置最大碎片大小（SCTP\\U MAXSEG）"
    },
    {
      "indent": 3,
      "text": "This option will get or set the maximum size to put in any outgoing SCTP DATA chunk. If a message is larger than this maximum size, it will be fragmented by SCTP into the specified size. Note that the underlying SCTP implementation may fragment into smaller sized chunks when the PMTU of the underlying association is smaller than the value set by the user. The default value for this option is '0', which indicates that the user is not limiting fragmentation and only the PMTU will affect SCTP's choice of DATA chunk size. Note also that",
      "zh-CHS": "此选项将获取或设置放入任何传出SCTP数据块的最大大小。如果消息大于此最大大小，则SCTP会将其分段为指定大小。注意，当底层关联的PMTU小于用户设置的值时，底层SCTP实现可能会分割成更小的块。此选项的默认值为“0”，表示用户没有限制碎片，只有PMTU会影响SCTP对数据块大小的选择。还请注意"
    },
    {
      "indent": 3,
      "text": "values set larger than the maximum size of an IP datagram will effectively let SCTP control fragmentation (i.e., the same as setting this option to 0).",
      "zh-CHS": "设置大于IP数据报最大大小的值将有效地让SCTP控制碎片（即，与将此选项设置为0相同）。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify this parameter:",
      "zh-CHS": "以下结构用于访问和修改此参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_value {\n  sctp_assoc_t assoc_id;\n  uint32_t assoc_value;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, this parameter indicates upon which association the user is performing an action. It is an error to use SCTP_{CURRENT|ALL}_ASSOC in assoc_id.",
      "zh-CHS": "assoc_id：对于一对一样式的套接字，此参数被忽略。对于一对多样式套接字，此参数指示用户执行操作的关联。在ASSOC_id中使用SCTP_u{CURRENT | ALL}ASSOC是一个错误。"
    },
    {
      "indent": 3,
      "text": "assoc_value: This parameter specifies the maximum size in bytes.",
      "zh-CHS": "assoc_值：此参数以字节为单位指定最大大小。"
    },
    {
      "indent": 0,
      "text": "8.1.17. Get or Set the List of Supported HMAC Identifiers (SCTP_HMAC_IDENT)",
      "zh-CHS": "8.1.17. 获取或设置支持的HMAC标识符列表（SCTP_HMAC_IDENT）"
    },
    {
      "indent": 3,
      "text": "This option gets or sets the list of Hashed Message Authentication Code (HMAC) algorithms that the local endpoint requires the peer to use.",
      "zh-CHS": "此选项获取或设置本地端点要求对等方使用的哈希消息身份验证码（HMAC）算法列表。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to get or set these identifiers:",
      "zh-CHS": "以下结构用于获取或设置这些标识符："
    },
    {
      "indent": 3,
      "text": "struct sctp_hmacalgo {\n  uint32_t shmac_number_of_idents;\n  uint16_t shmac_idents[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "shmac_number_of_idents: This field gives the number of elements present in the array shmac_idents.",
      "zh-CHS": "shmac_number_of_idents：此字段提供数组shmac_idents中存在的元素数。"
    },
    {
      "indent": 3,
      "text": "shmac_idents: This parameter contains an array of HMAC identifiers that the local endpoint is requesting the peer to use, in priority order. The following identifiers are valid:",
      "zh-CHS": "shmac_idents：此参数包含本地端点按优先级顺序请求对等方使用的HMAC标识符数组。以下标识符有效："
    },
    {
      "indent": 6,
      "text": "* SCTP_AUTH_HMAC_ID_SHA1",
      "zh-CHS": "* SCTP_AUTH_HMAC_ID_SHA1"
    },
    {
      "indent": 6,
      "text": "* SCTP_AUTH_HMAC_ID_SHA256",
      "zh-CHS": "* SCTP_AUTH_HMAC_ID_SHA256"
    },
    {
      "indent": 3,
      "text": "Note that the list supplied must include SCTP_AUTH_HMAC_ID_SHA1 and may include any of the other values in its preferred order (lowest list position has the highest preference in algorithm selection).",
      "zh-CHS": "请注意，所提供的列表必须包括SCTP_AUTH_HMAC_ID_SHA1，并且可以包括其首选顺序中的任何其他值（最低的列表位置在算法选择中具有最高的首选）。"
    },
    {
      "indent": 3,
      "text": "Note also that the lack of SCTP_AUTH_HMAC_ID_SHA1, or the inclusion of an unknown HMAC identifier (including optional identifiers unknown to the implementation), will cause the set option to fail and return an error.",
      "zh-CHS": "还请注意，缺少SCTP_AUTH_HMAC_ID_SHA1，或包含未知的HMAC标识符（包括实现未知的可选标识符），将导致set选项失败并返回错误。"
    },
    {
      "indent": 0,
      "text": "8.1.18. Get or Set the Active Shared Key (SCTP_AUTH_ACTIVE_KEY)",
      "section_title": true,
      "zh-CHS": "8.1.18. 获取或设置活动共享密钥（SCTP\\U AUTH\\U Active\\U密钥）"
    },
    {
      "indent": 3,
      "text": "This option will get or set the active shared key to be used to build the association shared key.",
      "zh-CHS": "此选项将获取或设置用于构建关联共享密钥的活动共享密钥。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify these parameters:",
      "zh-CHS": "以下结构用于访问和修改这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_authkeyid {\n  sctp_assoc_t scact_assoc_id;\n  uint16_t scact_keynumber;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "scact_assoc_id: This parameter sets the active key of the specified association. The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can be used. For one-to-one style sockets, this parameter is ignored. Note, however, that this option will set the active key on the association if the socket is connected; otherwise, this option will set the default active key for the endpoint.",
      "zh-CHS": "scact\\U assoc\\U id：此参数设置指定关联的活动密钥。可以使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。对于一对一样式的套接字，将忽略此参数。但是，请注意，如果连接了套接字，此选项将在关联上设置活动密钥；否则，此选项将设置端点的默认活动密钥。"
    },
    {
      "indent": 3,
      "text": "scact_keynumber: This parameter is the shared key identifier that the application is requesting to become the active shared key to be used for sending authenticated chunks. The key identifier must correspond to an existing shared key. Note that shared key identifier '0' defaults to a null key.",
      "zh-CHS": "scact_keynumber：此参数是共享密钥标识符，应用程序请求该标识符成为用于发送经过身份验证的区块的活动共享密钥。密钥标识符必须与现有共享密钥对应。请注意，共享密钥标识符“0”默认为空密钥。"
    },
    {
      "indent": 3,
      "text": "When used with setsockopt(), the SCTP implementation must use the indicated shared key identifier for all messages being given to an SCTP implementation via a send call after the setsockopt() call, until changed again. Therefore, the SCTP implementation must not bundle user messages that should be authenticated using different shared key identifiers.",
      "zh-CHS": "当与setsockopt（）一起使用时，SCTP实现必须在setsockopt（）调用之后通过发送调用为SCTP实现提供的所有消息使用指定的共享密钥标识符，直到再次更改为止。因此，SCTP实现不能捆绑应使用不同共享密钥标识符进行身份验证的用户消息。"
    },
    {
      "indent": 3,
      "text": "Initially, the key with key identifier 0 is the active key.",
      "zh-CHS": "最初，密钥标识符为0的密钥是活动密钥。"
    },
    {
      "indent": 0,
      "text": "8.1.19. Get or Set Delayed SACK Timer (SCTP_DELAYED_SACK)",
      "section_title": true,
      "zh-CHS": "8.1.19. 获取或设置延迟的SACK计时器（SCTP\\U延迟的\\U SACK）"
    },
    {
      "indent": 3,
      "text": "This option will affect the way delayed SACKs are performed. This option allows the application to get or set the delayed SACK time, in milliseconds. It also allows changing the delayed SACK frequency. Changing the frequency to 1 disables the delayed SACK algorithm. Note that if sack_delay or sack_freq is 0 when setting this option, the current values will remain unchanged.",
      "zh-CHS": "此选项将影响延迟行李的执行方式。此选项允许应用程序获取或设置延迟的SACK时间（以毫秒为单位）。它还允许更改延迟的SACK频率。将频率更改为1将禁用延迟SACK算法。请注意，如果设置此选项时sack_delay或sack_freq为0，则当前值将保持不变。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify these parameters:",
      "zh-CHS": "以下结构用于访问和修改这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_sack_info {\n  sctp_assoc_t sack_assoc_id;\n  uint32_t sack_delay;\n  uint32_t sack_freq;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sack_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, this parameter indicates upon which association the user is performing an action. The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.",
      "zh-CHS": "sack_assoc_id：对于一对一样式的套接字，此参数被忽略。对于一对多样式套接字，此参数指示用户执行操作的关联。也可以使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。"
    },
    {
      "indent": 3,
      "text": "sack_delay: This parameter contains the number of milliseconds the user is requesting that the delayed SACK timer be set to. Note that this value is defined in [RFC4960] to be between 200 and 500 milliseconds.",
      "zh-CHS": "sack_delay：此参数包含用户请求将延迟sack计时器设置为的毫秒数。请注意，该值在[RFC4960]中定义为介于200和500毫秒之间。"
    },
    {
      "indent": 3,
      "text": "sack_freq: This parameter contains the number of packets that must be received before a SACK is sent without waiting for the delay timer to expire. The default value is 2; setting this value to 1 will disable the delayed SACK algorithm.",
      "zh-CHS": "sack_freq：此参数包含在发送sack之前必须接收的数据包数，而无需等待延迟计时器过期。默认值为2；将该值设置为1将禁用延迟SACK算法。"
    },
    {
      "indent": 0,
      "text": "8.1.20. Get or Set Fragmented Interleave (SCTP_FRAGMENT_INTERLEAVE)",
      "section_title": true,
      "zh-CHS": "8.1.20. 获取或设置碎片交织（SCTP\\u碎片\\u交织）"
    },
    {
      "indent": 3,
      "text": "Fragmented interleave controls how the presentation of messages occurs for the message receiver. There are three levels of fragment interleave defined. Two of the levels affect one-to-one style sockets, while one-to-many style sockets are affected by all three levels.",
      "zh-CHS": "分段交织控制消息接收者如何呈现消息。定义了三个级别的片段交织。其中两个级别影响一对一样式套接字，而一对多样式套接字受所有三个级别的影响。"
    },
    {
      "indent": 3,
      "text": "This option takes an integer value. It can be set to a value of 0, 1, or 2. Attempting to set this level to other values will return an error.",
      "zh-CHS": "此选项采用整数值。可以将其设置为0、1或2的值。尝试将此级别设置为其他值将返回错误。"
    },
    {
      "indent": 3,
      "text": "Setting the three levels provides the following receiver interactions:",
      "zh-CHS": "设置三个级别可提供以下接收器交互："
    },
    {
      "indent": 3,
      "text": "level 0: Prevents the interleaving of any messages. This means that when a partial delivery begins, no other messages will be received except the message being partially delivered. If another message arrives on a different stream (or association) that could be delivered, it will be blocked waiting for the user to read all of the partially delivered message.",
      "zh-CHS": "级别0：防止任何消息的交错。这意味着，当部分传递开始时，除了部分传递的消息外，不会收到其他消息。如果另一条消息到达可以传递的不同流（或关联），它将被阻止，等待用户读取所有部分传递的消息。"
    },
    {
      "indent": 3,
      "text": "level 1: Allows interleaving of messages that are from different associations. For one-to-one style sockets, level 0 and level 1 thus have the same meaning, since a one-to-one style socket always receives messages from the same association. Note that setting a one-to-many style socket to this level may cause multiple partial deliveries from different associations, but for any given association, only one message will be delivered until all parts of a message have been delivered. This means that one large message, being read with an association identifier of \"X\", will block other messages from association \"X\" from being delivered.",
      "zh-CHS": "级别1：允许来自不同关联的消息交错。对于一对一样式的套接字，级别0和级别1因此具有相同的含义，因为一对一样式的套接字总是从相同的关联接收消息。请注意，将一对多样式套接字设置为该级别可能会导致来自不同关联的多个部分传递，但对于任何给定关联，只有一条消息将被传递，直到消息的所有部分都被传递为止。这意味着使用关联标识符“X”读取的一条大消息将阻止来自关联“X”的其他消息的传递。"
    },
    {
      "indent": 3,
      "text": "level 2: Allows complete interleaving of messages. This level requires that the sender not only carefully observe the peer association identifier (or address) but also pay careful attention to the stream number. With this option enabled, a partially delivered message may begin being delivered for association \"X\" stream \"Y\", and the next subsequent receive may return a message from association \"X\" stream \"Z\". Note that no other messages would be delivered for association \"X\" stream \"Y\" until all of stream \"Y\"'s partially delivered message was read. Note that this option also affects one-to-one style sockets. Also note that for one-to-many style sockets, not only another stream's message from the same association may be delivered upon the next receive, but some other association's message may also be delivered upon the next receive.",
      "zh-CHS": "级别2：允许消息的完全交错。这一级别要求发送方不仅要仔细观察对等关联标识符（或地址），还要仔细注意流号。启用此选项后，可以开始为关联“X”流“Y”传递部分传递的消息，并且下一次后续接收可以返回来自关联“X”流“Z”的消息。请注意，在读取流“Y”的所有部分传递的消息之前，不会为关联“X”流“Y”传递其他消息。请注意，此选项还影响一对一样式的套接字。还请注意，对于一对多样式套接字，不仅来自同一关联的另一个流的消息可以在下一次接收时传递，而且一些其他关联的消息也可以在下一次接收时传递。"
    },
    {
      "indent": 3,
      "text": "An implementation should default one-to-many style sockets to level 1, because otherwise, it is possible that a peer could begin sending a partial message and thus block all other peers from sending data. However, a setting of level 2 requires that the application not only be aware of the association (via the association identifier or peer's address) but also the stream number. The stream number is not present unless the user has subscribed to the sctp_data_io_event (see Section 6.2), which is deprecated, or has enabled the SCTP_RECVRCVINFO socket option (see Section 8.1.29). This is also why we recommend that one-to-one style sockets be defaulted to level 0 (level 1 for one-to-one style sockets has no effect). Note that an implementation should return an error if an application attempts to set the level to 2 and has not subscribed to the sctp_data_io_event event, which is deprecated, or has enabled the SCTP_RECVRCVINFO socket option.",
      "zh-CHS": "一个实现应该将一对多样式套接字默认为级别1，因为否则，一个对等方可能会开始发送部分消息，从而阻止所有其他对等方发送数据。然而，级别2的设置要求应用程序不仅要知道关联（通过关联标识符或对等方的地址），还要知道流编号。除非用户已订阅sctp_data_io_事件（见第6.2节），否则流号不存在。sctp_data_io_事件已被弃用，或已启用sctp_RECVRCVINFO套接字选项（见第8.1.29节）。这也是为什么我们建议将一对一样式套接字默认设置为0级（一对一样式套接字的1级无效）。请注意，如果应用程序尝试将级别设置为2，但未订阅sctp_data_io_事件（已弃用），或已启用sctp_RECVRCVINFO套接字选项，则实现应返回错误。"
    },
    {
      "indent": 3,
      "text": "For applications that have subscribed to events, those events appear in the normal socket buffer data stream. This means that unless the user has set the fragmentation interleave level to 0, notifications may also be interleaved with partially delivered messages.",
      "zh-CHS": "对于已订阅事件的应用程序，这些事件显示在正常套接字缓冲区数据流中。这意味着，除非用户已将碎片交错级别设置为0，否则通知也可能与部分传递的消息交错。"
    },
    {
      "indent": 0,
      "text": "8.1.21. Set or Get the SCTP Partial Delivery Point (SCTP_PARTIAL_DELIVERY_POINT)",
      "zh-CHS": "8.1.21. 设置或获取SCTP部分交付点（SCTP部分交付点）"
    },
    {
      "indent": 3,
      "text": "This option will set or get the SCTP partial delivery point. This point is the size of a message where the partial delivery API will be invoked to help free up rwnd space for the peer. Setting this to a lower value will cause partial deliveries to happen more often. This option expects an integer that sets or gets the partial delivery point in bytes. Note also that the call will fail if the user attempts to set this value larger than the socket receive buffer size.",
      "zh-CHS": "此选项将设置或获取SCTP部分交付点。这一点是消息的大小，将在其中调用部分传递API以帮助为对等方释放rwnd空间。将此值设置为较低的值将导致更频繁地发生部分交付。此选项需要设置或获取部分传递点（以字节为单位）的整数。还请注意，如果用户试图将此值设置为大于套接字接收缓冲区大小，则调用将失败。"
    },
    {
      "indent": 3,
      "text": "Note that any single message having a length smaller than or equal to the SCTP partial delivery point will be delivered in a single read call as long as the user-provided buffer is large enough to hold the message.",
      "zh-CHS": "请注意，只要用户提供的缓冲区足够大以容纳消息，长度小于或等于SCTP部分传递点的任何单个消息都将在单个读取调用中传递。"
    },
    {
      "indent": 0,
      "text": "8.1.22. Set or Get the Use of Extended Receive Info (SCTP_USE_EXT_RCVINFO) - DEPRECATED",
      "zh-CHS": "8.1.22. 设置或获取扩展接收信息的使用（SCTP\\U Use\\U EXT\\U RCVINFO）-已弃用"
    },
    {
      "indent": 3,
      "text": "This option will enable or disable the use of the extended version of the sctp_sndrcvinfo structure. If this option is disabled, then the normal sctp_sndrcvinfo structure is returned in all receive message calls. If this option is enabled, then the sctp_extrcvinfo structure is returned in all receive message calls. The default is off.",
      "zh-CHS": "此选项将启用或禁用sctp_sndrcvinfo结构的扩展版本。如果禁用此选项，则在所有接收消息调用中返回正常的sctp_sndrcvinfo结构。如果启用此选项，则在所有接收消息调用中都会返回sctp_extrcvinfo结构。默认设置为关闭。"
    },
    {
      "indent": 3,
      "text": "Note that the sctp_extrcvinfo structure is never used in any send call.",
      "zh-CHS": "请注意，sctp_extrcvinfo结构从未在任何发送调用中使用。"
    },
    {
      "indent": 3,
      "text": "This option is present for compatibility with older applications and is deprecated. Future applications should use SCTP_NXTINFO to retrieve this same information via ancillary data.",
      "zh-CHS": "此选项的存在是为了与旧应用程序兼容，不推荐使用。未来的应用程序应使用SCTP_NXTINFO通过辅助数据检索相同的信息。"
    },
    {
      "indent": 0,
      "text": "8.1.23. Set or Get the Auto ASCONF Flag (SCTP_AUTO_ASCONF)",
      "section_title": true,
      "zh-CHS": "8.1.23. 设置或获取自动ASCONF标志（SCTP\\U Auto\\U ASCONF）"
    },
    {
      "indent": 3,
      "text": "This option will enable or disable the use of the automatic generation of ASCONF chunks to add and delete addresses to an existing association. Note that this option has two caveats, namely a) it only affects sockets that are bound to all addresses available to the SCTP stack, and b) the system administrator may have an overriding control that turns the ASCONF feature off no matter what setting the socket option may have.",
      "zh-CHS": "此选项将启用或禁用自动生成ASCONF块的功能，以向现有关联添加和删除地址。请注意，此选项有两个警告，即a）它仅影响绑定到SCTP堆栈可用的所有地址的套接字，以及b）系统管理员可能有一个覆盖控件，该控件可关闭ASCONF功能，无论套接字选项的设置如何。"
    },
    {
      "indent": 3,
      "text": "This option expects an integer boolean flag, where a non-zero value turns on the option, and a zero value turns off the option.",
      "zh-CHS": "此选项需要一个整数布尔标志，其中非零值打开该选项，零值关闭该选项。"
    },
    {
      "indent": 0,
      "text": "8.1.24. Set or Get the Maximum Burst (SCTP_MAX_BURST)",
      "section_title": true,
      "zh-CHS": "8.1.24. 设置或获取最大突发（SCTP\\U MAX\\U突发）"
    },
    {
      "indent": 3,
      "text": "This option will allow a user to change the maximum burst of packets that can be emitted by this association. Note that the default value is 4, and some implementations may restrict this setting so that it can only be lowered to positive values.",
      "zh-CHS": "此选项将允许用户更改此关联可以发出的最大数据包突发。请注意，默认值为4，一些实现可能会限制此设置，以便只能将其降低为正值。"
    },
    {
      "indent": 3,
      "text": "To set or get this option, the user fills in the following structure:",
      "zh-CHS": "要设置或获取此选项，用户需要填写以下结构："
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_value {\n  sctp_assoc_t assoc_id;\n  uint32_t assoc_value;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, this parameter indicates upon which association the user is performing an action. The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.",
      "zh-CHS": "assoc_id：对于一对一样式的套接字，此参数被忽略。对于一对多样式套接字，此参数指示用户执行操作的关联。也可以使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。"
    },
    {
      "indent": 3,
      "text": "assoc_value: This parameter contains the maximum burst. Setting the value to 0 disables burst mitigation.",
      "zh-CHS": "assoc_值：此参数包含最大突发。将该值设置为0将禁用突发缓解。"
    },
    {
      "indent": 0,
      "text": "8.1.25. Set or Get the Default Context (SCTP_CONTEXT)",
      "section_title": true,
      "zh-CHS": "8.1.25. 设置或获取默认上下文（SCTP\\U上下文）"
    },
    {
      "indent": 3,
      "text": "The context field in the sctp_sndrcvinfo structure is normally only used when a failed message is retrieved holding the value that was sent down on the actual send call. This option allows the setting, on an association basis, of a default context that will be received on reading messages from the peer. This is especially helpful for an application when using one-to-many style sockets to keep some reference to an internal state machine that is processing messages on the association. Note that the setting of this value only affects received messages from the peer and does not affect the value that is saved with outbound messages.",
      "zh-CHS": "sctp_sndrcvinfo结构中的上下文字段通常仅在检索包含实际发送调用中发送的值的失败消息时使用。此选项允许在关联的基础上设置从对等方读取消息时接收的默认上下文。当应用程序使用一对多样式套接字来保留对正在处理关联消息的内部状态机的一些引用时，这对应用程序尤其有用。请注意，此值的设置仅影响从对等方接收的消息，而不影响与出站消息一起保存的值。"
    },
    {
      "indent": 3,
      "text": "To set or get this option, the user fills in the following structure:",
      "zh-CHS": "要设置或获取此选项，用户需要填写以下结构："
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_value {\n  sctp_assoc_t assoc_id;\n  uint32_t assoc_value;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, this parameter indicates upon which association the user is performing an action. The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.",
      "zh-CHS": "assoc_id：对于一对一样式的套接字，此参数被忽略。对于一对多样式套接字，此参数指示用户执行操作的关联。也可以使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。"
    },
    {
      "indent": 3,
      "text": "assoc_value: This parameter contains the context.",
      "zh-CHS": "assoc_值：此参数包含上下文。"
    },
    {
      "indent": 0,
      "text": "8.1.26. Enable or Disable Explicit EOR Marking (SCTP_EXPLICIT_EOR)",
      "section_title": true,
      "zh-CHS": "8.1.26. 启用或禁用显式EOR标记（SCTP\\U Explicit\\U EOR）"
    },
    {
      "indent": 3,
      "text": "This boolean flag is used to enable or disable explicit end of record (EOR) marking. When this option is enabled, a user may make multiple send system calls to send a record and must indicate that they are finished sending a particular record by including the SCTP_EOR flag. If this boolean flag is disabled, then each individual send system call is considered to have an SCTP_EOR indicator set on it implicitly without the user having to explicitly add this flag. The default is off.",
      "zh-CHS": "此布尔标志用于启用或禁用显式记录结束（EOR）标记。启用此选项后，用户可以进行多个发送系统调用以发送记录，并且必须通过包含SCTP_EOR标志来指示他们已完成发送特定记录。如果禁用此布尔标志，则每个单独的发送系统调用都被视为隐式设置了SCTP_EOR指示符，而用户无需显式添加此标志。默认设置为关闭。"
    },
    {
      "indent": 3,
      "text": "This option expects an integer boolean flag, where a non-zero value turns on the option, and a zero value turns off the option.",
      "zh-CHS": "此选项需要一个整数布尔标志，其中非零值打开该选项，零值关闭该选项。"
    },
    {
      "indent": 0,
      "text": "8.1.27. Enable SCTP Port Reusage (SCTP_REUSE_PORT)",
      "section_title": true,
      "zh-CHS": "8.1.27. 启用SCTP端口重用（SCTP\\U重用\\U端口）"
    },
    {
      "indent": 3,
      "text": "This option only supports one-to-one style SCTP sockets. If used on a one-to-many style SCTP socket, an error is indicated.",
      "zh-CHS": "此选项仅支持一对一样式的SCTP套接字。如果在一对多样式的SCTP套接字上使用，则会指示错误。"
    },
    {
      "indent": 3,
      "text": "This option expects an integer boolean flag, where a non-zero value turns on the option, and a zero value turns off the option.",
      "zh-CHS": "此选项需要一个整数布尔标志，其中非零值打开该选项，零值关闭该选项。"
    },
    {
      "indent": 3,
      "text": "This socket option must not be used after calling bind() or sctp_bindx() for a one-to-one style SCTP socket. If using bind() or sctp_bindx() on a socket with the SCTP_REUSE_PORT option, all other SCTP sockets bound to the same port must have set the SCTP_REUSE_PORT option. Calling bind() or sctp_bindx() for a socket without having set the SCTP_REUSE_PORT option will fail if there are other sockets bound to the same port. At most one socket being bound to the same port may be listening.",
      "zh-CHS": "在为一对一样式的sctp套接字调用bind（）或sctp_bindx（）后，不得使用此套接字选项。如果在带有sctp_重用_端口选项的套接字上使用bind（）或sctp_bindx（），则绑定到同一端口的所有其他sctp套接字必须已设置sctp_重用_端口选项。如果有其他套接字绑定到同一端口，则在未设置sctp_重用_端口选项的情况下为套接字调用bind（）或sctp_bindx（）将失败。最多一个绑定到同一端口的套接字可能正在侦听。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the behavior of the socket-level socket option to reuse ports and/or addresses for SCTP sockets is unspecified.",
      "zh-CHS": "应该注意的是，套接字级别套接字选项重用SCTP套接字的端口和/或地址的行为未指定。"
    },
    {
      "indent": 0,
      "text": "8.1.28. Set Notification Event (SCTP_EVENT)",
      "section_title": true,
      "zh-CHS": "8.1.28. 设置通知事件（SCTP\\U事件）"
    },
    {
      "indent": 3,
      "text": "This socket option is used to set a specific notification option. Please see Section 6.2.2 for a full description of this option and its usage.",
      "zh-CHS": "此套接字选项用于设置特定的通知选项。请参阅第6.2.2节，了解该选项及其用法的完整说明。"
    },
    {
      "indent": 0,
      "text": "8.1.29. Enable or Disable the Delivery of SCTP_RCVINFO as Ancillary Data (SCTP_RECVRCVINFO)",
      "zh-CHS": "8.1.29. 启用或禁用SCTP_RCVINFO作为辅助数据的传递（SCTP_RECVRCVINFO）"
    },
    {
      "indent": 3,
      "text": "Setting this option specifies that SCTP_RCVINFO (defined in Section 5.3.5) is returned as ancillary data by recvmsg().",
      "zh-CHS": "设置此选项指定recvmsg（）将SCTP_RCVINFO（在第5.3.5节中定义）作为辅助数据返回。"
    },
    {
      "indent": 3,
      "text": "This option expects an integer boolean flag, where a non-zero value turns on the option, and a zero value turns off the option.",
      "zh-CHS": "此选项需要一个整数布尔标志，其中非零值打开该选项，零值关闭该选项。"
    },
    {
      "indent": 0,
      "text": "8.1.30. Enable or Disable the Delivery of SCTP_NXTINFO as Ancillary Data (SCTP_RECVNXTINFO)",
      "zh-CHS": "8.1.30. 启用或禁用SCTP_NXTINFO作为辅助数据的传递（SCTP_RECVNXTINFO）"
    },
    {
      "indent": 3,
      "text": "Setting this option specifies that SCTP_NXTINFO (defined in Section 5.3.6) is returned as ancillary data by recvmsg().",
      "zh-CHS": "设置此选项指定recvmsg（）将SCTP_NXTINFO（在第5.3.6节中定义）作为辅助数据返回。"
    },
    {
      "indent": 3,
      "text": "This option expects an integer boolean flag, where a non-zero value turns on the option, and a zero value turns off the option.",
      "zh-CHS": "此选项需要一个整数布尔标志，其中非零值打开该选项，零值关闭该选项。"
    },
    {
      "indent": 0,
      "text": "8.1.31. Set Default Send Parameters (SCTP_DEFAULT_SNDINFO)",
      "section_title": true,
      "zh-CHS": "8.1.31. 设置默认发送参数（SCTP\\U Default\\U SNDINFO）"
    },
    {
      "indent": 3,
      "text": "Applications that wish to use the sendto() system call may wish to specify a default set of parameters that would normally be supplied through the inclusion of ancillary data. This socket option allows such an application to set the default sctp_sndinfo structure. The application that wishes to use this socket option simply passes the sctp_sndinfo structure (defined in Section 5.3.4) to this call. The input parameters accepted by this call include snd_sid, snd_flags, snd_ppid, and snd_context. The snd_flags parameter is composed of a bitwise OR of SCTP_UNORDERED, SCTP_EOF, and SCTP_SENDALL. The snd_assoc_id field specifies the association to which to apply the parameters. For a one-to-many style socket, any of the predefined constants are also allowed in this field. The field is ignored for one-to-one style sockets.",
      "zh-CHS": "希望使用sendto（）系统调用的应用程序可能希望指定一组默认参数，这些参数通常通过包含辅助数据来提供。此套接字选项允许此类应用程序设置默认的sctp_sndinfo结构。希望使用此套接字选项的应用程序只需将sctp_sndinfo结构（在第5.3.4节中定义）传递给此调用。此调用接受的输入参数包括snd_sid、snd_标志、snd_ppid和snd_上下文。snd_flags参数由SCTP_UNORDERED、SCTP_EOF和SCTP_SENDALL的按位OR组成。snd_assoc_id字段指定要应用参数的关联。对于一对多样式套接字，此字段中还允许使用任何预定义常量。一对一样式套接字忽略该字段。"
    },
    {
      "indent": 0,
      "text": "8.1.32. Set Default PR-SCTP Parameters (SCTP_DEFAULT_PRINFO)",
      "section_title": true,
      "zh-CHS": "8.1.32. 设置默认PR-SCTP参数（SCTP\\U Default\\U PRINFO）"
    },
    {
      "indent": 3,
      "text": "This option sets and gets the default parameters for PR-SCTP. They can be overwritten by specific information provided in send calls.",
      "zh-CHS": "此选项设置并获取PR-SCTP的默认参数。它们可以被send calls中提供的特定信息覆盖。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify these parameters:",
      "zh-CHS": "以下结构用于访问和修改这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_default_prinfo {\n  uint16_t pr_policy;\n  uint32_t pr_value;\n  sctp_assoc_t pr_assoc_id;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "pr_policy: This field is the same as that described in Section 5.3.7.",
      "zh-CHS": "pr_政策：该字段与第5.3.7节所述相同。"
    },
    {
      "indent": 3,
      "text": "pr_value: This field is the same as that described in Section 5.3.7.",
      "zh-CHS": "pr_值：该字段与第5.3.7节所述相同。"
    },
    {
      "indent": 3,
      "text": "pr_assoc_id: This field is ignored for one-to-one style sockets. For one-to-many style sockets, pr_assoc_id can be a particular association identifier or SCTP_{FUTURE|CURRENT|ALL}_ASSOC.",
      "zh-CHS": "pr_assoc_id：一对一样式套接字忽略此字段。对于一对多样式套接字，pr_assoc_id可以是特定的关联标识符或SCTP_{FUTURE | CURRENT | ALL}assoc。"
    },
    {
      "indent": 0,
      "text": "8.2. Read-Only Options",
      "section_title": true,
      "zh-CHS": "8.2. 只读选项"
    },
    {
      "indent": 3,
      "text": "The options defined in this subsection are read-only. Using this option in a setsockopt() call will result in an error indicating EOPNOTSUPP.",
      "zh-CHS": "本小节中定义的选项是只读的。在setsockopt（）调用中使用此选项将导致指示EOPNOTSUPP的错误。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Association Status (SCTP_STATUS)",
      "section_title": true,
      "zh-CHS": "8.2.1. 关联状态（SCTP_状态）"
    },
    {
      "indent": 3,
      "text": "Applications can retrieve current status information about an association, including association state, peer receiver window size, number of unacknowledged DATA chunks, and number of DATA chunks pending receipt. This information is read-only.",
      "zh-CHS": "应用程序可以检索有关关联的当前状态信息，包括关联状态、对等接收方窗口大小、未确认的数据块数量和待接收的数据块数量。此信息是只读的。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access this information:",
      "zh-CHS": "以下结构用于访问此信息："
    },
    {
      "indent": 3,
      "text": "struct sctp_status {\n  sctp_assoc_t sstat_assoc_id;\n  int32_t  sstat_state;\n  uint32_t sstat_rwnd;\n  uint16_t sstat_unackdata;\n  uint16_t sstat_penddata;\n  uint16_t sstat_instrms;\n  uint16_t sstat_outstrms;\n  uint32_t sstat_fragmentation_point;\n  struct sctp_paddrinfo sstat_primary;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sstat_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, it holds the identifier for the association. All notifications for a given association have the same association identifier. The special SCTP_{FUTURE| CURRENT|ALL}_ASSOC cannot be used.",
      "zh-CHS": "sstat_assoc_id：对于一对一样式的套接字，此参数被忽略。对于一对多样式套接字，它保存关联的标识符。给定关联的所有通知都具有相同的关联标识符。不能使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。"
    },
    {
      "indent": 3,
      "text": "sstat_state: This contains the association's current state, i.e., one of the following values:",
      "zh-CHS": "sstat_状态：包含关联的当前状态，即以下值之一："
    },
    {
      "indent": 6,
      "text": "* SCTP_CLOSED",
      "zh-CHS": "* SCTP_关闭"
    },
    {
      "indent": 6,
      "text": "* SCTP_BOUND",
      "zh-CHS": "* SCTP_界"
    },
    {
      "indent": 6,
      "text": "* SCTP_LISTEN",
      "zh-CHS": "* 听"
    },
    {
      "indent": 6,
      "text": "* SCTP_COOKIE_WAIT",
      "zh-CHS": "* SCTP_COOKIE_等待"
    },
    {
      "indent": 6,
      "text": "* SCTP_COOKIE_ECHOED",
      "zh-CHS": "* SCTP_COOKIE_回响"
    },
    {
      "indent": 6,
      "text": "* SCTP_ESTABLISHED",
      "zh-CHS": "* SCTP_成立"
    },
    {
      "indent": 6,
      "text": "* SCTP_SHUTDOWN_PENDING",
      "zh-CHS": "* SCTP\\u关闭\\u挂起"
    },
    {
      "indent": 6,
      "text": "* SCTP_SHUTDOWN_SENT",
      "zh-CHS": "* SCTP\\u关机\\u已发送"
    },
    {
      "indent": 6,
      "text": "* SCTP_SHUTDOWN_RECEIVED",
      "zh-CHS": "* 接收到SCTP_关机_"
    },
    {
      "indent": 6,
      "text": "* SCTP_SHUTDOWN_ACK_SENT",
      "zh-CHS": "* SCTP\\u关闭\\u确认\\u发送"
    },
    {
      "indent": 3,
      "text": "sstat_rwnd: This contains the association peer's current receiver window size.",
      "zh-CHS": "sstat\\u rwnd：包含关联对等方的当前接收器窗口大小。"
    },
    {
      "indent": 3,
      "text": "sstat_unackdata: This is the number of unacknowledged DATA chunks.",
      "zh-CHS": "sstat_unackdata：这是未确认数据块的数量。"
    },
    {
      "indent": 3,
      "text": "sstat_penddata: This is the number of DATA chunks pending receipt.",
      "zh-CHS": "sstat_penddata：这是等待接收的数据块数。"
    },
    {
      "indent": 3,
      "text": "sstat_instrms: This is the number of streams that the peer will be using outbound.",
      "zh-CHS": "sstat_instrms：这是对等方将使用出站的流的数量。"
    },
    {
      "indent": 3,
      "text": "sstat_outstrms: This is the number of outbound streams that the endpoint is allowed to use.",
      "zh-CHS": "sstat_outsrms：这是允许端点使用的出站流数。"
    },
    {
      "indent": 3,
      "text": "sstat_fragmentation_point: This is the size at which SCTP fragmentation will occur.",
      "zh-CHS": "sstat_fragmentation_point：这是发生SCTP碎片的大小。"
    },
    {
      "indent": 3,
      "text": "sstat_primary: This is information on the current primary peer address.",
      "zh-CHS": "sstat_primary：这是关于当前主要对等地址的信息。"
    },
    {
      "indent": 3,
      "text": "To access these status values, the application calls getsockopt() with the option name SCTP_STATUS.",
      "zh-CHS": "要访问这些状态值，应用程序调用getsockopt（），选项名为SCTP_status。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Peer Address Information (SCTP_GET_PEER_ADDR_INFO)",
      "section_title": true,
      "zh-CHS": "8.2.2. 对等地址信息（SCTP\\u获取\\u对等地址\\u信息）"
    },
    {
      "indent": 3,
      "text": "Applications can retrieve information about a specific peer address of an association, including its reachability state, congestion window, and retransmission timer values. This information is read-only.",
      "zh-CHS": "应用程序可以检索有关关联的特定对等地址的信息，包括其可达性状态、拥塞窗口和重传计时器值。此信息是只读的。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access this information:",
      "zh-CHS": "以下结构用于访问此信息："
    },
    {
      "indent": 3,
      "text": "struct sctp_paddrinfo {\n  sctp_assoc_t spinfo_assoc_id;\n  struct sockaddr_storage spinfo_address;\n  int32_t  spinfo_state;\n  uint32_t spinfo_cwnd;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  uint32_t spinfo_srtt;\n  uint32_t spinfo_rto;\n  uint32_t spinfo_mtu;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "spinfo_assoc_id: This parameter is ignored for one-to-one style sockets.",
      "zh-CHS": "spinfo_assoc_id：对于一对一样式套接字，此参数被忽略。"
    },
    {
      "indent": 6,
      "text": "For one-to-many style sockets, this field may be filled by the application, and if so, this field will have priority in looking up the association instead of using the address specified in spinfo_address. Note that if the address does not belong to the association specified, then this call will fail. If the application does not fill in the spinfo_assoc_id, then the address will be used to look up the association, and on return, this field will have the valid association identifier. In other words, this call can be used to translate an address into an association identifier. Note that the predefined constants are not allowed for this option.",
      "zh-CHS": "对于一对多样式套接字，此字段可能由应用程序填充，如果是，则此字段将优先查找关联，而不是使用spinfo_address中指定的地址。请注意，如果地址不属于指定的关联，则此调用将失败。如果应用程序未填写spinfo_assoc_id，则该地址将用于查找关联，返回时，该字段将具有有效的关联标识符。换句话说，此调用可用于将地址转换为关联标识符。请注意，此选项不允许使用预定义常量。"
    },
    {
      "indent": 3,
      "text": "spinfo_address: This is filled by the application and contains the peer address of interest.",
      "zh-CHS": "spinfo_地址：由应用程序填写，包含感兴趣的对等地址。"
    },
    {
      "indent": 3,
      "text": "spinfo_state: This contains the peer address's state:",
      "zh-CHS": "spinfo_状态：包含对等地址的状态："
    },
    {
      "indent": 6,
      "text": "SCTP_UNCONFIRMED: This is the initial state of a peer address.",
      "zh-CHS": "SCTP_未确认：这是对等地址的初始状态。"
    },
    {
      "indent": 6,
      "text": "SCTP_ACTIVE: This state is entered the first time after path verification. It can also be entered if the state is SCTP_INACTIVE and the path supervision detects that the peer address is reachable again.",
      "zh-CHS": "SCTP_活动：此状态在路径验证后第一次进入。如果状态为SCTP_INACTIVE且路径监控检测到对等地址可再次访问，则也可以输入该地址。"
    },
    {
      "indent": 6,
      "text": "SCTP_INACTIVE: This state is entered whenever a path failure is detected.",
      "zh-CHS": "SCTP_INACTIVE：只要检测到路径故障，就会进入该状态。"
    },
    {
      "indent": 3,
      "text": "spinfo_cwnd: This contains the peer address's current congestion window.",
      "zh-CHS": "spinfo_cwnd：它包含对等地址的当前拥塞窗口。"
    },
    {
      "indent": 3,
      "text": "spinfo_srtt: This contains the peer address's current smoothed round-trip time calculation in milliseconds.",
      "zh-CHS": "spinfo_srtt：它包含对等地址的当前平滑往返时间计算（以毫秒为单位）。"
    },
    {
      "indent": 3,
      "text": "spinfo_rto: This contains the peer address's current retransmission timeout value in milliseconds.",
      "zh-CHS": "spinfo_rto：它包含对等地址的当前重传超时值（以毫秒为单位）。"
    },
    {
      "indent": 3,
      "text": "spinfo_mtu: This is the current Path MTU of the peer address. It is the number of bytes available in an SCTP packet for chunks.",
      "zh-CHS": "spinfou mtu：这是对等地址的当前路径mtu。它是SCTP数据包中可用于数据块的字节数。"
    },
    {
      "indent": 0,
      "text": "8.2.3. Get the List of Chunks the Peer Requires to Be Authenticated (SCTP_PEER_AUTH_CHUNKS)",
      "zh-CHS": "8.2.3. 获取对等方需要进行身份验证的块列表（SCTP_Peer_AUTH_Chunks）"
    },
    {
      "indent": 3,
      "text": "This option gets a list of chunk types (see [RFC4960]) for a specified association that the peer requires to be received authenticated only.",
      "zh-CHS": "此选项获取指定关联的块类型列表（请参见[RFC4960]），该关联仅要求对等方通过身份验证才能接收。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access these parameters:",
      "zh-CHS": "以下结构用于访问这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_authchunks {\n  sctp_assoc_t gauth_assoc_id;\n  uint32_t gauth_number_of_chunks\n  uint8_t  gauth_chunks[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "gauth_assoc_id: This parameter indicates for which association the user is requesting the list of peer-authenticated chunks. For one-to-one style sockets, this parameter is ignored. Note that the predefined constants are not allowed with this option.",
      "zh-CHS": "gauth_assoc_id：此参数指示用户请求对等身份验证区块列表的关联。对于一对一样式的套接字，将忽略此参数。请注意，此选项不允许使用预定义常量。"
    },
    {
      "indent": 3,
      "text": "gauth_number_of_chunks: This parameter gives the number of elements in the array gauth_chunks.",
      "zh-CHS": "gauth_number_of_chunks：此参数给出数组gauth_chunks中的元素数。"
    },
    {
      "indent": 3,
      "text": "gauth_chunks: This parameter contains an array of chunk types that the peer is requesting to be authenticated. If the passed-in buffer size is not large enough to hold the list of chunk types, ENOBUFS is returned.",
      "zh-CHS": "gauth_chunks：此参数包含对等方请求进行身份验证的块类型数组。如果传入的缓冲区大小不足以容纳块类型列表，则返回ENOBUFS。"
    },
    {
      "indent": 0,
      "text": "8.2.4. Get the List of Chunks the Local Endpoint Requires to Be Authenticated (SCTP_LOCAL_AUTH_CHUNKS)",
      "zh-CHS": "8.2.4. 获取本地端点需要进行身份验证的块列表（SCTP\\u Local\\u AUTH\\u Chunks）"
    },
    {
      "indent": 3,
      "text": "This option gets a list of chunk types (see [RFC4960]) for a specified association that the local endpoint requires to be received authenticated only.",
      "zh-CHS": "此选项获取指定关联的块类型列表（请参见[RFC4960]），本地端点仅要求接收该关联进行身份验证。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access these parameters:",
      "zh-CHS": "以下结构用于访问这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_authchunks {\n  sctp_assoc_t gauth_assoc_id;\n  uint32_t gauth_number_of_chunks;\n  uint8_t  gauth_chunks[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "gauth_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, the application may fill in an association identifier or SCTP_FUTURE_ASSOC. It is an error to use SCTP_{CURRENT|ALL}_ASSOC in gauth_assoc_id.",
      "zh-CHS": "gauth_assoc_id：对于一对一样式的套接字，此参数被忽略。对于一对多样式套接字，应用程序可能会填写关联标识符或SCTP_FUTURE_ASSOC。在gauth_ASSOC_id中使用SCTP_{CURRENT | ALL}_ASSOC是错误的。"
    },
    {
      "indent": 3,
      "text": "gauth_number_of_chunks: This parameter gives the number of elements in the array gauth_chunks.",
      "zh-CHS": "gauth_number_of_chunks：此参数给出数组gauth_chunks中的元素数。"
    },
    {
      "indent": 3,
      "text": "gauth_chunks: This parameter contains an array of chunk types that the local endpoint is requesting to be authenticated. If the passed-in buffer is not large enough to hold the list of chunk types, ENOBUFS is returned.",
      "zh-CHS": "gauth_chunks：此参数包含本地端点请求进行身份验证的块类型数组。如果传入的缓冲区不够大，无法容纳块类型列表，则返回ENOBUFS。"
    },
    {
      "indent": 0,
      "text": "8.2.5. Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)",
      "section_title": true,
      "zh-CHS": "8.2.5. 获取当前关联数（SCTP\\U Get\\U ASSOC\\U编号）"
    },
    {
      "indent": 3,
      "text": "This option gets the current number of associations that are attached to a one-to-many style socket. The option value is an uint32_t. Note that this number is only a snapshot. This means that the number of associations may have changed when the caller gets back the option result.",
      "zh-CHS": "此选项获取连接到一对多样式套接字的当前关联数。选项值是uint32\\t。请注意，此数字只是一个快照。这意味着当调用者返回选项结果时，关联的数量可能已经改变。"
    },
    {
      "indent": 3,
      "text": "For a one-to-one style socket, this socket option results in an error.",
      "zh-CHS": "对于一对一样式的套接字，此套接字选项将导致错误。"
    },
    {
      "indent": 0,
      "text": "8.2.6. Get the Current Identifiers of Associations (SCTP_GET_ASSOC_ID_LIST)",
      "zh-CHS": "8.2.6. 获取关联的当前标识符（SCTP\\U Get\\U ASSOC\\U ID\\U列表）"
    },
    {
      "indent": 3,
      "text": "This option gets the current list of SCTP association identifiers of the SCTP associations handled by a one-to-many style socket.",
      "zh-CHS": "此选项获取由一对多样式套接字处理的SCTP关联的当前SCTP关联标识符列表。"
    },
    {
      "indent": 3,
      "text": "The option value has the structure",
      "zh-CHS": "选项值具有以下结构："
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_ids {\n  uint32_t gaids_number_of_ids;\n  sctp_assoc_t gaids_assoc_id[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The caller must provide a large enough buffer to hold all association identifiers. If the buffer is too small, an error must be returned. The user can use the SCTP_GET_ASSOC_NUMBER socket option to get an idea of how large the buffer has to be. gaids_number_of_ids gives the number of elements in the array gaids_assoc_id. Note also that some or all of sctp_assoc_t returned in the array may become invalid by the time the caller gets back the result.",
      "zh-CHS": "调用方必须提供足够大的缓冲区来容纳所有关联标识符。如果缓冲区太小，则必须返回错误。用户可以使用SCTP_GET_ASSOC_NUMBER套接字选项了解缓冲区的大小。gaids_number_of_id给出数组gaids_assoc_id中的元素数。还请注意，在调用方返回结果时，数组中返回的部分或全部sctp_assoc_t可能会无效。"
    },
    {
      "indent": 3,
      "text": "For a one-to-one style socket, this socket option results in an error.",
      "zh-CHS": "对于一对一样式的套接字，此套接字选项将导致错误。"
    },
    {
      "indent": 0,
      "text": "8.3. Write-Only Options",
      "section_title": true,
      "zh-CHS": "8.3. 只写选项"
    },
    {
      "indent": 3,
      "text": "The options defined in this subsection are write-only. Using this option in a getsockopt() or sctp_opt_info() call will result in an error indicating EOPNOTSUPP.",
      "zh-CHS": "本小节中定义的选项仅为写选项。在getsockopt（）或sctp_opt_info（）调用中使用此选项将导致指示EOPNOTSUPP的错误。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)",
      "section_title": true,
      "zh-CHS": "8.3.1. 设置对等主地址（SCTP\\U Set\\U Peer\\U Primary\\U ADDR）"
    },
    {
      "indent": 3,
      "text": "This call requests that the peer mark the enclosed address as the association primary (see [RFC5061]). The enclosed address must be one of the association's locally bound addresses.",
      "zh-CHS": "此调用要求对等方将附带的地址标记为关联主地址（请参见[RFC5061]）。所附地址必须是协会的本地绑定地址之一。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to make a set peer primary request:",
      "zh-CHS": "以下结构用于发出设置对等主请求："
    },
    {
      "indent": 3,
      "text": "struct sctp_setpeerprim {\n  sctp_assoc_t sspp_assoc_id;\n  struct sockaddr_storage sspp_addr;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sspp_assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, it identifies the association for this request. Note that the predefined constants are not allowed for this option.",
      "zh-CHS": "sspp_assoc_id：对于一对一样式套接字，忽略此参数。对于一对多样式套接字，它标识此请求的关联。请注意，此选项不允许使用预定义常量。"
    },
    {
      "indent": 3,
      "text": "sspp_addr: The address to set as primary.",
      "zh-CHS": "sspp_addr：要设置为主地址的地址。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Add a Chunk That Must Be Authenticated (SCTP_AUTH_CHUNK)",
      "section_title": true,
      "zh-CHS": "8.3.2. 添加一个必须经过身份验证的区块（SCTP_AUTH_Chunk）"
    },
    {
      "indent": 3,
      "text": "This set option adds a chunk type that the user is requesting to be received only in an authenticated way. Changes to the list of chunks will only affect future associations on the socket.",
      "zh-CHS": "此集合选项添加一个区块类型，用户请求仅以经过身份验证的方式接收该区块类型。对块列表的更改只会影响套接字上的未来关联。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to add a chunk:",
      "zh-CHS": "以下结构用于添加块："
    },
    {
      "indent": 3,
      "text": "struct sctp_authchunk {\n  uint8_t sauth_chunk;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sauth_chunk: This parameter contains a chunk type that the user is requesting to be authenticated.",
      "zh-CHS": "sauth_chunk：此参数包含用户请求进行身份验证的块类型。"
    },
    {
      "indent": 3,
      "text": "The chunk types for INIT, INIT-ACK, SHUTDOWN-COMPLETE, and AUTH chunks must not be used. If they are used, an error must be returned. The usage of this option enables SCTP AUTH in cases where it is not required by other means (for example, the use of dynamic address reconfiguration).",
      "zh-CHS": "不能使用INIT、INIT-ACK、SHUTDOWN-COMPLETE和AUTH块的块类型。如果使用它们，则必须返回错误。在其他方式（例如，使用动态地址重新配置）不需要SCTP AUTH的情况下，使用此选项可以启用SCTP AUTH。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Set a Shared Key (SCTP_AUTH_KEY)",
      "section_title": true,
      "zh-CHS": "8.3.3. 设置共享密钥（SCTP\\U AUTH\\U密钥）"
    },
    {
      "indent": 3,
      "text": "This option will set a shared secret key that is used to build an association shared key.",
      "zh-CHS": "此选项将设置用于构建关联共享密钥的共享密钥。"
    },
    {
      "indent": 3,
      "text": "The following structure is used to access and modify these parameters:",
      "zh-CHS": "以下结构用于访问和修改这些参数："
    },
    {
      "indent": 3,
      "text": "struct sctp_authkey {\n  sctp_assoc_t sca_assoc_id;\n  uint16_t sca_keynumber;\n  uint16_t sca_keylength;\n  uint8_t  sca_key[];\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "sca_assoc_id: This parameter indicates on what association the shared key is being set. The special SCTP_{FUTURE|CURRENT| ALL}_ASSOC can be used. For one-to-one style sockets, this parameter is ignored. Note, however, that on one-to-one style sockets, this option will set a key on the association if the socket is connected; otherwise, this option will set a key on the endpoint.",
      "zh-CHS": "sca_assoc_id：此参数指示正在设置共享密钥的关联。可以使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。对于一对一样式的套接字，将忽略此参数。但是，请注意，在一对一样式的套接字上，如果套接字已连接，则此选项将在关联上设置一个键；否则，此选项将在端点上设置一个键。"
    },
    {
      "indent": 3,
      "text": "sca_keynumber: This parameter is the shared key identifier by which the application will refer to this shared key. If a key of the specified index already exists, then this new key will replace the old existing key. Note that shared key identifier '0' defaults to a null key.",
      "zh-CHS": "sca_keynumber：此参数是应用程序引用此共享密钥的共享密钥标识符。如果指定索引的键已存在，则此新键将替换旧的现有键。请注意，共享密钥标识符“0”默认为空密钥。"
    },
    {
      "indent": 3,
      "text": "sca_keylength: This parameter is the length of the array sca_key.",
      "zh-CHS": "sca_密钥长度：此参数是数组sca_密钥的长度。"
    },
    {
      "indent": 3,
      "text": "sca_key: This parameter contains an array of bytes that is to be used by the endpoint (or association) as the shared secret key. Note that if the length of this field is zero, a null key is set.",
      "zh-CHS": "sca_密钥：此参数包含端点（或关联）用作共享密钥的字节数组。请注意，如果此字段的长度为零，则设置空键。"
    },
    {
      "indent": 0,
      "text": "8.3.4. Deactivate a Shared Key (SCTP_AUTH_DEACTIVATE_KEY)",
      "section_title": true,
      "zh-CHS": "8.3.4. 停用共享密钥（SCTP\\u验证\\u停用\\u密钥）"
    },
    {
      "indent": 3,
      "text": "This set option indicates that the application will no longer send user messages using the indicated key identifier.",
      "zh-CHS": "此设置选项表示应用程序将不再使用指定的密钥标识符发送用户消息。"
    },
    {
      "indent": 3,
      "text": "struct sctp_authkeyid {\n  sctp_assoc_t scact_assoc_id;\n  uint16_t scact_keynumber;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "scact_assoc_id: This parameter indicates from which association the shared key identifier is being deleted. The special SCTP_{FUTURE| CURRENT|ALL}_ASSOC can be used. For one-to-one style sockets, this parameter is ignored. Note, however, that this option will deactivate the key from the association if the socket is connected; otherwise, this option will deactivate the key from the endpoint.",
      "zh-CHS": "scact_assoc_id：此参数指示从哪个关联删除共享密钥标识符。可以使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。对于一对一样式的套接字，将忽略此参数。但是，请注意，如果连接了套接字，此选项将从关联中停用密钥；否则，此选项将从端点停用密钥。"
    },
    {
      "indent": 3,
      "text": "scact_keynumber: This parameter is the shared key identifier that the application is requesting to be deactivated. The key identifier must correspond to an existing shared key. Note that if this parameter is zero, use of the null key identifier '0' is deactivated on the endpoint and/or association.",
      "zh-CHS": "scact_keynumber：此参数是应用程序请求停用的共享密钥标识符。密钥标识符必须与现有共享密钥对应。请注意，如果此参数为零，则在端点和/或关联上禁用空密钥标识符“0”的使用。"
    },
    {
      "indent": 3,
      "text": "The currently active key cannot be deactivated.",
      "zh-CHS": "无法停用当前激活的密钥。"
    },
    {
      "indent": 0,
      "text": "8.3.5. Delete a Shared Key (SCTP_AUTH_DELETE_KEY)",
      "section_title": true,
      "zh-CHS": "8.3.5. 删除共享密钥（SCTP\\U AUTH\\U Delete\\U密钥）"
    },
    {
      "indent": 3,
      "text": "This set option will delete an SCTP association's shared secret key that has been deactivated.",
      "zh-CHS": "此设置选项将删除已停用的SCTP关联的共享密钥。"
    },
    {
      "indent": 3,
      "text": "struct sctp_authkeyid {\n  sctp_assoc_t scact_assoc_id;\n  uint16_t scact_keynumber;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "scact_assoc_id: This parameter indicates from which association the shared key identifier is being deleted. The special SCTP_{FUTURE| CURRENT|ALL}_ASSOC can be used. For one-to-one style sockets, this parameter is ignored. Note, however, that this option will delete the key from the association if the socket is connected; otherwise, this option will delete the key from the endpoint.",
      "zh-CHS": "scact_assoc_id：此参数指示从哪个关联删除共享密钥标识符。可以使用特殊的SCTP{FUTURE | CURRENT | ALL}{u ASSOC。对于一对一样式的套接字，将忽略此参数。但是，请注意，如果套接字已连接，此选项将从关联中删除密钥；否则，此选项将从端点删除密钥。"
    },
    {
      "indent": 3,
      "text": "scact_keynumber: This parameter is the shared key identifier that the application is requesting to be deleted. The key identifier must correspond to an existing shared key and must not be in use for any packet being sent by the SCTP implementation. This means, in particular, that it must be deactivated first. Note that if this parameter is zero, use of the null key identifier '0' is deleted from the endpoint and/or association.",
      "zh-CHS": "scact_keynumber：此参数是应用程序请求删除的共享密钥标识符。密钥标识符必须对应于现有共享密钥，并且不得用于SCTP实现发送的任何数据包。这尤其意味着，必须首先停用它。请注意，如果此参数为零，则将从端点和/或关联中删除空密钥标识符“0”的使用。"
    },
    {
      "indent": 3,
      "text": "Only deactivated keys that are no longer used by an association can be deleted.",
      "zh-CHS": "只能删除关联不再使用的停用密钥。"
    },
    {
      "indent": 0,
      "text": "9. New Functions",
      "section_title": true,
      "zh-CHS": "9. 新功能"
    },
    {
      "indent": 3,
      "text": "Depending on the system, the following interface can be implemented as a system call or library function.",
      "zh-CHS": "根据系统的不同，以下接口可以实现为系统调用或库函数。"
    },
    {
      "indent": 0,
      "text": "9.1. sctp_bindx()",
      "section_title": true,
      "zh-CHS": "9.1. sctp_bindx（）"
    },
    {
      "indent": 3,
      "text": "This function allows the user to bind a specific subset of addresses or, if the SCTP extension described in [RFC5061] is supported, add or delete specific addresses.",
      "zh-CHS": "此功能允许用户绑定特定的地址子集，或者，如果支持[RFC5061]中描述的SCTP扩展，则可以添加或删除特定地址。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int sctp_bindx(int sd, struct sockaddr *addrs, int addrcnt, int flags);",
      "zh-CHS": "int-sctp_bindx（int-sd，结构sockaddr*addrs，int-addrcnt，int-flags）；"
    },
    {
      "indent": 3,
      "text": "If sd is an IPv4 socket, the addresses passed must be IPv4 addresses. If the sd is an IPv6 socket, the addresses passed can either be IPv4 or IPv6 addresses.",
      "zh-CHS": "如果sd是IPv4套接字，则传递的地址必须是IPv4地址。如果sd是IPv6套接字，则传递的地址可以是IPv4或IPv6地址。"
    },
    {
      "indent": 3,
      "text": "A single address may be specified as INADDR_ANY for an IPv4 address, or as IN6ADDR_ANY_INIT or in6addr_any for an IPv6 address; see Section 3.1.2 for this usage.",
      "zh-CHS": "对于IPv4地址，可以将单个地址指定为INADDR_任意；对于IPv6地址，可以将单个地址指定为IN6ADDR_任意INIT或IN6ADDR_任意；有关此用途，请参见第3.1.2节。"
    },
    {
      "indent": 3,
      "text": "addrs is a pointer to an array of one or more socket addresses. Each address is contained in its appropriate structure. For an IPv6 socket, an array of sockaddr_in6 is used. For an IPv4 socket, an array of sockaddr_in is used. The caller specifies the number of addresses in the array with addrcnt. Note that the wildcard addresses cannot be used in combination with non-wildcard addresses on a socket with this function; doing so will result in an error.",
      "zh-CHS": "addrs是指向一个或多个套接字地址数组的指针。每个地址都包含在其适当的结构中。对于IPv6套接字，使用sockaddru in6数组。对于IPv4套接字，将使用中的sockaddr_数组。调用者使用addrcnt指定数组中的地址数。注意，通配符地址不能与具有此功能的套接字上的非通配符地址结合使用；这样做将导致错误。"
    },
    {
      "indent": 3,
      "text": "On success, sctp_bindx() returns 0. On failure, sctp_bindx() returns -1 and sets errno to the appropriate error code.",
      "zh-CHS": "成功时，sctp_bindx（）返回0。失败时，sctp_bindx（）返回-1并将errno设置为相应的错误代码。"
    },
    {
      "indent": 3,
      "text": "For SCTP, the port given in each socket address must be the same, or sctp_bindx() will fail, setting errno to EINVAL.",
      "zh-CHS": "对于SCTP，每个套接字地址中给定的端口必须相同，否则SCTP_bindx（）将失败，并将errno设置为EINVAL。"
    },
    {
      "indent": 3,
      "text": "The flags parameter is formed from the bitwise OR of zero or more of the following currently defined flags:",
      "zh-CHS": "flags参数由以下当前定义的零个或多个标志的按位或组成："
    },
    {
      "indent": 3,
      "text": "o SCTP_BINDX_ADD_ADDR",
      "zh-CHS": "o SCTP_BINDX_ADDR_ADDR"
    },
    {
      "indent": 3,
      "text": "o SCTP_BINDX_REM_ADDR",
      "zh-CHS": "o SCTP_BINDX_REM_ADDR"
    },
    {
      "indent": 3,
      "text": "SCTP_BINDX_ADD_ADDR directs SCTP to add the given addresses to the socket (i.e., endpoint), and SCTP_BINDX_REM_ADDR directs SCTP to remove the given addresses from the socket. The two flags are mutually exclusive; if both are given, sctp_bindx() will fail with EINVAL. A caller may not remove all addresses from a socket; sctp_bindx() will reject such an attempt with EINVAL.",
      "zh-CHS": "SCTP_BINDX_ADD_ADDR指示SCTP将给定地址添加到套接字（即端点），SCTP_BINDX_REM_ADDR指示SCTP从套接字中删除给定地址。这两面旗帜是相互排斥的；如果两者都给定，则sctp_bindx（）将使用EINVAL失败。调用者不能从套接字中删除所有地址；sctp_bindx（）将拒绝使用EINVAL进行此类尝试。"
    },
    {
      "indent": 3,
      "text": "An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate additional addresses with an endpoint after calling bind(). Or, an application can use sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some addresses with which a listening socket is associated, so that no new association accepted will be associated with these addresses. If the",
      "zh-CHS": "在调用bind（）之后，应用程序可以使用sctp_bindx（sctp_bindx_ADD_ADDR）将其他地址与端点关联。或者，应用程序可以使用sctp_bindx（sctp_bindx_REM_ADDR）删除与侦听套接字关联的一些地址，这样就不会接受与这些地址关联的新关联。如果"
    },
    {
      "indent": 3,
      "text": "endpoint supports dynamic address reconfiguration, an SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR may cause an endpoint to send the appropriate message to its peers to change the peers' address lists.",
      "zh-CHS": "端点支持动态地址重新配置，SCTP_BINDX_REM_ADDR或SCTP_BINDX_ADD_ADDR可能会导致端点向其对等方发送适当的消息以更改对等方的地址列表。"
    },
    {
      "indent": 3,
      "text": "Adding and removing addresses from established associations is an optional functionality. Implementations that do not support this functionality should return -1 and set errno to EOPNOTSUPP.",
      "zh-CHS": "从已建立的关联中添加和删除地址是可选功能。不支持此功能的实现应返回-1并将errno设置为EOPNOTSUPP。"
    },
    {
      "indent": 3,
      "text": "sctp_bindx() can be called on an already bound socket or on an unbound socket. If the socket is unbound and the first port number in the addrs parameter is zero, the kernel will choose a port number. All port numbers after the first one being 0 must also be zero. If the first port number is not zero, the following port numbers must be zero or have the same value as the first one. For an already bound socket, all port numbers provided must be the bound one or 0.",
      "zh-CHS": "可以在已绑定的套接字或未绑定的套接字上调用sctp_bindx（）。如果套接字未绑定并且addrs参数中的第一个端口号为零，那么内核将选择一个端口号。第一个端口号为0后的所有端口号也必须为零。如果第一个端口号不为零，则以下端口号必须为零或与第一个端口号具有相同的值。对于已绑定的套接字，提供的所有端口号必须为绑定端口号或0。"
    },
    {
      "indent": 3,
      "text": "sctp_bindx() is an atomic operation. Therefore, the binding will either succeed on all addresses or fail on all addresses. If multiple addresses are provided and the sctp_bindx() call fails, there is no indication of which address is responsible for the failure. The only way to identify the specific error indication is to call sctp_bindx() sequentially with only one address per call.",
      "zh-CHS": "sctp_bindx（）是一种原子操作。因此，绑定要么在所有地址上成功，要么在所有地址上失败。如果提供了多个地址，并且sctp_bindx（）调用失败，则没有指示哪个地址是导致失败的原因。识别特定错误指示的唯一方法是按顺序调用sctp_bindx（），每次调用只有一个地址。"
    },
    {
      "indent": 0,
      "text": "9.2. sctp_peeloff()",
      "section_title": true,
      "zh-CHS": "9.2. sctp_peeloff（）"
    },
    {
      "indent": 3,
      "text": "After an association is established on a one-to-many style socket, the application may wish to branch off the association into a separate socket/file descriptor.",
      "zh-CHS": "在一对多样式套接字上建立关联后，应用程序可能希望将关联分支到单独的套接字/文件描述符中。"
    },
    {
      "indent": 3,
      "text": "This is particularly desirable when, for instance, the application wishes to have a number of sporadic message senders/receivers remain under the original one-to-many style socket but branch off these associations carrying high-volume data traffic into their own separate socket descriptors.",
      "zh-CHS": "例如，当应用程序希望在原始的一对多样式套接字下保留多个零星消息发送者/接收者，但将这些承载高容量数据流量的关联分支到它们自己的单独套接字描述符中时，这是特别需要的。"
    },
    {
      "indent": 3,
      "text": "The application uses the sctp_peeloff() call to branch off an association into a separate socket. (Note that the semantics are somewhat changed from the traditional one-to-one style accept() call.) Note also that the new socket is a one-to-one style socket. Thus, it will be confined to operations allowed for a one-to-one style socket.",
      "zh-CHS": "应用程序使用sctp_peeloff（）调用将关联分支到单独的套接字中。（注意，语义与传统的一对一样式accept（）调用有所不同。）还要注意，新套接字是一对一样式的套接字。因此，它将仅限于一对一式插座允许的操作。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int sctp_peeloff(int sd, sctp_assoc_t assoc_id);",
      "zh-CHS": "内部sctp_peeloff（内部sd、sctp_assoc_t assoc_id）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The original one-to-many style socket descriptor returned from the socket() system call (see Section 3.1.1).",
      "zh-CHS": "sd：从socket（）系统调用返回的原始一对多样式套接字描述符（参见第3.1.1节）。"
    },
    {
      "indent": 3,
      "text": "assoc_id: The specified identifier of the association that is to be branched off to a separate file descriptor. (Note that in a traditional one-to-one style accept() call, this would be an out parameter, but for the one-to-many style call, this is an in parameter.)",
      "zh-CHS": "assoc_id：要分支到单独文件描述符的关联的指定标识符。（请注意，在传统的一对一样式accept（）调用中，这将是一个out参数，但对于一对多样式调用，这是一个in参数。）"
    },
    {
      "indent": 3,
      "text": "The function returns a non-negative file descriptor representing the branched-off association, or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "该函数返回表示分支关联的非负文件描述符，如果发生错误，则返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 0,
      "text": "9.3. sctp_getpaddrs()",
      "section_title": true,
      "zh-CHS": "9.3. sctp_getpaddrs（）"
    },
    {
      "indent": 3,
      "text": "sctp_getpaddrs() returns all peer addresses in an association.",
      "zh-CHS": "sctp_getpaddrs（）返回关联中的所有对等地址。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int sctp_getpaddrs(int sd, sctp_assoc_t id, struct sockaddr **addrs);",
      "zh-CHS": "int sctp_getpaddrs（int sd、sctp_assoc_t id、结构sockaddr**addrs）；"
    },
    {
      "indent": 3,
      "text": "On return, addrs will point to a dynamically allocated array of sockaddr structures of the appropriate type for the socket type. The caller should use sctp_freepaddrs() to free the memory. Note that the in/out parameter addrs must not be NULL.",
      "zh-CHS": "返回时，addr将指向一个动态分配的sockaddr结构数组，该数组的类型与socket类型对应。调用方应使用sctp_freepardrs（）释放内存。请注意，输入/输出参数addrs不能为NULL。"
    },
    {
      "indent": 3,
      "text": "If sd is an IPv4 socket, the addresses returned will be all IPv4 addresses. If sd is an IPv6 socket, the addresses returned can be a mix of IPv4 or IPv6 addresses, with IPv4 addresses returned according to the SCTP_I_WANT_MAPPED_V4_ADDR option setting.",
      "zh-CHS": "如果sd是IPv4套接字，则返回的地址将是所有IPv4地址。如果sd是IPv6套接字，则返回的地址可以是IPv4或IPv6地址的混合，IPv4地址根据SCTP_I_WANT_MAPPED_V4_ADDR选项设置返回。"
    },
    {
      "indent": 3,
      "text": "For one-to-many style sockets, id specifies the association to query. For one-to-one style sockets, id is ignored.",
      "zh-CHS": "对于一对多样式套接字，id指定要查询的关联。对于一对一样式的套接字，将忽略id。"
    },
    {
      "indent": 3,
      "text": "On success, sctp_getpaddrs() returns the number of peer addresses in the association. If there is no association on this socket, sctp_getpaddrs() returns 0, and the value of *addrs is undefined. If an error occurs, sctp_getpaddrs() returns -1, and the value of *addrs is undefined.",
      "zh-CHS": "成功时，sctp_getpaddrs（）返回关联中的对等地址数。如果此套接字上没有关联，则sctp_getpaddrs（）返回0，*addrs的值未定义。如果发生错误，sctp_getpaddrs（）将返回-1，*addrs的值未定义。"
    },
    {
      "indent": 0,
      "text": "9.4. sctp_freepaddrs()",
      "section_title": true,
      "zh-CHS": "9.4. sctp_freepaddrs（）"
    },
    {
      "indent": 3,
      "text": "sctp_freepaddrs() frees all resources allocated by sctp_getpaddrs().",
      "zh-CHS": "sctp_freepaddrs（）释放sctp_getpaddrs（）分配的所有资源。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "void sctp_freepaddrs(struct sockaddr *addrs);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and addrs is the array of peer addresses returned by sctp_getpaddrs().",
      "zh-CHS": "addrs是sctp_getpaddrs（）返回的对等地址数组。"
    },
    {
      "indent": 0,
      "text": "9.5. sctp_getladdrs()",
      "section_title": true,
      "zh-CHS": "9.5. sctp_getladdrs（）"
    },
    {
      "indent": 3,
      "text": "sctp_getladdrs() returns all locally bound addresses on a socket.",
      "zh-CHS": "sctp_getladdrs（）返回套接字上所有本地绑定的地址。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int sctp_getladdrs(int sd, sctp_assoc_t id, struct sockaddr **addrs);",
      "zh-CHS": "int sctp_getladdrs（int sd、sctp_assoc_t id、结构sockaddr**addrs）；"
    },
    {
      "indent": 3,
      "text": "On return, addrs will point to a dynamically allocated array of sockaddr structures of the appropriate type for the socket type. The caller should use sctp_freeladdrs() to free the memory. Note that the in/out parameter addrs must not be NULL.",
      "zh-CHS": "返回时，addr将指向一个动态分配的sockaddr结构数组，该数组的类型与socket类型对应。调用方应使用sctp_freeladrs（）释放内存。请注意，输入/输出参数addrs不能为NULL。"
    },
    {
      "indent": 3,
      "text": "If sd is an IPv4 socket, the addresses returned will be all IPv4 addresses. If sd is an IPv6 socket, the addresses returned can be a mix of IPv4 or IPv6 addresses, with IPv4 addresses returned according to the SCTP_I_WANT_MAPPED_V4_ADDR option setting.",
      "zh-CHS": "如果sd是IPv4套接字，则返回的地址将是所有IPv4地址。如果sd是IPv6套接字，则返回的地址可以是IPv4或IPv6地址的混合，IPv4地址根据SCTP_I_WANT_MAPPED_V4_ADDR选项设置返回。"
    },
    {
      "indent": 3,
      "text": "For one-to-many style sockets, id specifies the association to query. For one-to-one style sockets, id is ignored.",
      "zh-CHS": "对于一对多样式套接字，id指定要查询的关联。对于一对一样式的套接字，将忽略id。"
    },
    {
      "indent": 3,
      "text": "If the id field is set to the value '0', then the locally bound addresses are returned without regard to any particular association.",
      "zh-CHS": "如果id字段设置为值“0”，则返回本地绑定地址，而不考虑任何特定关联。"
    },
    {
      "indent": 3,
      "text": "On success, sctp_getladdrs() returns the number of local addresses bound to the socket. If the socket is unbound, sctp_getladdrs() returns 0, and the value of *addrs is undefined. If an error occurs, sctp_getladdrs() returns -1, and the value of *addrs is undefined.",
      "zh-CHS": "成功时，sctp_getladdrs（）返回绑定到套接字的本地地址数。如果套接字未绑定，则sctp_getladdrs（）返回0，*addrs的值未定义。如果发生错误，sctp_getladdrs（）将返回-1，*addrs的值未定义。"
    },
    {
      "indent": 0,
      "text": "9.6. sctp_freeladdrs()",
      "section_title": true,
      "zh-CHS": "9.6. sctp_freeladrs（）"
    },
    {
      "indent": 3,
      "text": "sctp_freeladdrs() frees all resources allocated by sctp_getladdrs().",
      "zh-CHS": "sctp_freeladrs（）释放sctp_getladdrs（）分配的所有资源。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "void sctp_freeladdrs(struct sockaddr *addrs);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "and addrs is the array of local addresses returned by sctp_getladdrs().",
      "zh-CHS": "addrs是sctp_getladdrs（）返回的本地地址数组。"
    },
    {
      "indent": 0,
      "text": "9.7. sctp_sendmsg() - DEPRECATED",
      "section_title": true,
      "zh-CHS": "9.7. sctp_sendmsg（）-已弃用"
    },
    {
      "indent": 3,
      "text": "This function is deprecated; sctp_sendv() (see Section 9.12) should be used instead.",
      "zh-CHS": "此函数已弃用；应改用sctp_sendv（）（见第9.12节）。"
    },
    {
      "indent": 3,
      "text": "An implementation may provide a library function (or possibly system call) to assist the user with the advanced features of SCTP.",
      "zh-CHS": "实现可以提供库函数（或可能的系统调用），以帮助用户使用SCTP的高级特性。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t sctp_sendmsg(int sd, const void *msg, size_t len, const struct sockaddr *to, socklen_t tolen, uint32_t ppid, uint32_t flags, uint16_t stream_no, uint32_t timetolive, uint32_t context);",
      "zh-CHS": "ssize_t sctp_sendmsg（int sd，const void*msg，size_t len，const struct sockaddr*to，socklen_t tolen，uint32_t ppid，uint32_t标志，uint16_t流号，uint32_t timetolive，uint32_t上下文）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "msg: The message to be sent.",
      "zh-CHS": "msg：要发送的消息。"
    },
    {
      "indent": 3,
      "text": "len: The length of the message.",
      "zh-CHS": "len:消息的长度。"
    },
    {
      "indent": 3,
      "text": "to: The destination address of the message.",
      "zh-CHS": "收件人：邮件的目标地址。"
    },
    {
      "indent": 3,
      "text": "tolen: The length of the destination address.",
      "zh-CHS": "tolen：目标地址的长度。"
    },
    {
      "indent": 3,
      "text": "ppid: The same as sinfo_ppid (see Section 5.3.2).",
      "zh-CHS": "ppid：与sinfo_ppid相同（见第5.3.2节）。"
    },
    {
      "indent": 3,
      "text": "flags: The same as sinfo_flags (see Section 5.3.2).",
      "zh-CHS": "标志：与sinfo_标志相同（见第5.3.2节）。"
    },
    {
      "indent": 3,
      "text": "stream_no: The same as sinfo_stream (see Section 5.3.2).",
      "zh-CHS": "溪流：与sinfo_溪流相同（见第5.3.2节）。"
    },
    {
      "indent": 3,
      "text": "timetolive: The same as sinfo_timetolive (see Section 5.3.2).",
      "zh-CHS": "timetolive：与sinfo_timetolive相同（见第5.3.2节）。"
    },
    {
      "indent": 3,
      "text": "context: The same as sinfo_context (see Section 5.3.2).",
      "zh-CHS": "上下文：与sinfo_上下文相同（见第5.3.2节）。"
    },
    {
      "indent": 3,
      "text": "The call returns the number of characters sent, or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "调用返回发送的字符数，如果发生错误，则返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 3,
      "text": "Sending a message using sctp_sendmsg() is atomic (unless explicit EOR marking is enabled on the socket specified by sd).",
      "zh-CHS": "使用sctp_sendmsg（）发送消息是原子性的（除非在sd指定的套接字上启用了显式EOR标记）。"
    },
    {
      "indent": 3,
      "text": "Using sctp_sendmsg() on a non-connected one-to-one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.",
      "zh-CHS": "在未连接的一对一样式套接字上使用sctp_sendmsg（）进行隐式连接设置可能有效，也可能无效，具体取决于sctp实现。"
    },
    {
      "indent": 0,
      "text": "9.8. sctp_recvmsg() - DEPRECATED",
      "section_title": true,
      "zh-CHS": "9.8. sctp_recvmsg（）-已弃用"
    },
    {
      "indent": 3,
      "text": "This function is deprecated; sctp_recvv() (see Section 9.13) should be used instead.",
      "zh-CHS": "此函数已弃用；应改用sctp_recvv（）（见第9.13节）。"
    },
    {
      "indent": 3,
      "text": "An implementation may provide a library function (or possibly system call) to assist the user with the advanced features of SCTP. Note that in order for the sctp_sndrcvinfo structure to be filled in by sctp_recvmsg(), the caller must enable the sctp_data_io_event with the SCTP_EVENTS option. Note that the setting of the SCTP_USE_EXT_RCVINFO will affect this function as well, causing the sctp_sndrcvinfo information to be extended.",
      "zh-CHS": "实现可以提供库函数（或可能的系统调用），以帮助用户使用SCTP的高级特性。注意，为了让sctp_recvmsg（）填充sctp_sndrcvinfo结构，调用方必须使用sctp_EVENTS选项启用sctp_data_io_事件。请注意，SCTP_USE_EXT_RCVINFO的设置也会影响此功能，导致SCTP_sndrcvinfo信息被扩展。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t sctp_recvmsg(int sd, void *msg, size_t len, struct sockaddr *from, socklen_t *fromlen struct sctp_sndrcvinfo *sinfo int *msg_flags);",
      "zh-CHS": "ssize_t sctp_recvmsg（int sd，void*msg，size\\u t len，struct sockaddr*from，socklen\\u t*from len struct sctp\\u sndrcvinfo*sinfo int*msg_标志）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "msg: The message buffer to be filled.",
      "zh-CHS": "msg：要填充的消息缓冲区。"
    },
    {
      "indent": 3,
      "text": "len: The length of the message buffer.",
      "zh-CHS": "len：消息缓冲区的长度。"
    },
    {
      "indent": 3,
      "text": "from: A pointer to an address to be filled with the address of the sender of this message.",
      "zh-CHS": "发件人：指向要填入此邮件发件人地址的地址的指针。"
    },
    {
      "indent": 3,
      "text": "fromlen: An in/out parameter describing the from length.",
      "zh-CHS": "fromlen：描述起始长度的输入/输出参数。"
    },
    {
      "indent": 3,
      "text": "sinfo: A pointer to an sctp_sndrcvinfo structure to be filled upon receipt of the message.",
      "zh-CHS": "sinfo：指向sctp_sndrcvinfo结构的指针，在收到消息时填充。"
    },
    {
      "indent": 3,
      "text": "msg_flags: A pointer to an integer to be filled with any message flags (e.g., MSG_NOTIFICATION). Note that this field is an in-out field. Options for the receive may also be passed into the value (e.g., MSG_PEEK). On return from the call, the msg_flags value will be different than what was sent in to the call. If implemented via a recvmsg() call, the msg_flags parameter should only contain the value of the flags from the recvmsg() call.",
      "zh-CHS": "msg_标志：指向要填充任何消息标志（例如，msg_通知）的整数的指针。请注意，此字段是输入输出字段。接收选项也可以传递到值中（例如，MSG_PEEK）。从调用返回时，msg_flags值将不同于发送到调用的值。如果通过recvmsg（）调用实现，msg_flags参数应仅包含recvmsg（）调用中的标志值。"
    },
    {
      "indent": 3,
      "text": "The call returns the number of bytes received, or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "调用返回接收的字节数，如果发生错误，则返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 0,
      "text": "9.9. sctp_connectx()",
      "section_title": true,
      "zh-CHS": "9.9. sctp_connectx（）"
    },
    {
      "indent": 3,
      "text": "An implementation may provide a library function (or possibly system call) to assist the user with associating to an endpoint that is multi-homed. Much like sctp_bindx(), this call allows a caller to specify multiple addresses at which a peer can be reached. The way the SCTP stack uses the list of addresses to set up the association is implementation dependent. This function only specifies that the stack will try to make use of all of the addresses in the list when needed.",
      "zh-CHS": "实现可以提供库函数（或可能的系统调用）来帮助用户关联到多宿的端点。与sctp_bindx（）非常相似，此调用允许调用方指定多个可以到达对等方的地址。SCTP堆栈使用地址列表建立关联的方式取决于实现。此函数仅指定堆栈在需要时尝试使用列表中的所有地址。"
    },
    {
      "indent": 3,
      "text": "Note that the list of addresses passed in is only used for setting up the association. It does not necessarily equal the set of addresses the peer uses for the resulting association. If the caller wants to find out the set of peer addresses, it must use sctp_getpaddrs() to retrieve them after the association has been set up.",
      "zh-CHS": "请注意，传入的地址列表仅用于设置关联。它不一定等于对等方用于结果关联的地址集。如果调用方希望找到对等地址集，则必须在建立关联后使用sctp_getpaddrs（）检索它们。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "int sctp_connectx(int sd, struct sockaddr *addrs, int addrcnt, sctp_assoc_t *id);",
      "zh-CHS": "int sctp_connectx（int sd、结构sockaddr*addrs、int addrcnt、sctp_assoc\\u t*id）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "addrs: An array of addresses.",
      "zh-CHS": "地址：地址数组。"
    },
    {
      "indent": 3,
      "text": "addrcnt: The number of addresses in the array.",
      "zh-CHS": "addrcnt：数组中的地址数。"
    },
    {
      "indent": 3,
      "text": "id: An output parameter that, if passed in as non-NULL, will return the association identifier for the newly created association (if successful).",
      "zh-CHS": "id：一个输出参数，如果作为非NULL传入，将返回新创建的关联的关联标识符（如果成功）。"
    },
    {
      "indent": 3,
      "text": "The call returns 0 on success or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "调用成功时返回0，发生错误时返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 0,
      "text": "9.10. sctp_send() - DEPRECATED",
      "section_title": true,
      "zh-CHS": "9.10. sctp_send（）-已弃用"
    },
    {
      "indent": 3,
      "text": "This function is deprecated; sctp_sendv() should be used instead.",
      "zh-CHS": "此函数已弃用；应改用sctp_sendv（）。"
    },
    {
      "indent": 3,
      "text": "An implementation may provide another alternative function or system call to assist an application with the sending of data without the use of the cmsghdr structures.",
      "zh-CHS": "实现可提供另一替代功能或系统调用，以协助应用程序在不使用cmsghdr结构的情况下发送数据。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t sctp_send(int sd, const void *msg, size_t len, const struct sctp_sndrcvinfo *sinfo, int flags);",
      "zh-CHS": "ssize_t sctp_send（int sd，const void*msg，size_t len，const struct sctp_sndrcvinfo*sinfo，int标志）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "msg: The message to be sent.",
      "zh-CHS": "msg：要发送的消息。"
    },
    {
      "indent": 3,
      "text": "len: The length of the message.",
      "zh-CHS": "len:消息的长度。"
    },
    {
      "indent": 3,
      "text": "sinfo: A pointer to an sctp_sndrcvinfo structure used as described in Section 5.3.2 for a sendmsg() call.",
      "zh-CHS": "sinfo：指向sctp_sndrcvinfo结构的指针，如第5.3.2节所述，用于sendmsg（）调用。"
    },
    {
      "indent": 3,
      "text": "flags: The same flags as used by the sendmsg() call flags (e.g., MSG_DONTROUTE).",
      "zh-CHS": "标志：与sendmsg（）调用标志使用的标志相同（例如，MSG_DONTROUTE）。"
    },
    {
      "indent": 3,
      "text": "The call returns the number of bytes sent, or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "调用返回发送的字节数，如果发生错误，则返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 3,
      "text": "This function call may also be used to terminate an association using an association identifier by setting the sinfo.sinfo_flags to SCTP_EOF and the sinfo.sinfo_assoc_id to the association that needs to be terminated. In such a case, len can be zero.",
      "zh-CHS": "此函数调用还可用于通过将sinfo.sinfo_标志设置为SCTP_EOF并将sinfo.sinfo_assoc_id设置为需要终止的关联来终止使用关联标识符的关联。在这种情况下，len可以为零。"
    },
    {
      "indent": 3,
      "text": "Using sctp_send() on a non-connected one-to-one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.",
      "zh-CHS": "在未连接的一对一样式套接字上使用sctp_send（）进行隐式连接设置可能有效，也可能无效，具体取决于sctp实现。"
    },
    {
      "indent": 3,
      "text": "Sending a message using sctp_send() is atomic unless explicit EOR marking is enabled on the socket specified by sd.",
      "zh-CHS": "除非在sd指定的套接字上启用了显式EOR标记，否则使用sctp_send（）发送消息是原子的。"
    },
    {
      "indent": 0,
      "text": "9.11. sctp_sendx() - DEPRECATED",
      "section_title": true,
      "zh-CHS": "9.11. sctp_sendx（）-已弃用"
    },
    {
      "indent": 3,
      "text": "This function is deprecated; sctp_sendv() should be used instead.",
      "zh-CHS": "此函数已弃用；应改用sctp_sendv（）。"
    },
    {
      "indent": 3,
      "text": "An implementation may provide another alternative function or system call to assist an application with the sending of data without the use of the cmsghdr structure, and to provide a list of addresses. The list of addresses is provided for implicit association setup. In such a case, the list of addresses serves the same purpose as the addresses given in sctp_connectx() (see Section 9.9).",
      "zh-CHS": "实现可提供另一替代功能或系统调用，以协助应用程序在不使用cmsghdr结构的情况下发送数据，并提供地址列表。为隐式关联设置提供了地址列表。在这种情况下，地址列表的用途与sctp_connectx（）中给出的地址相同（参见第9.9节）。"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t sctp_sendx(int sd, const void *msg, size_t len, struct sockaddr *addrs, int addrcnt, struct sctp_sndrcvinfo *sinfo, int flags);",
      "zh-CHS": "ssize_t sctp_sendx（int sd，const void*msg，size_t len，struct sockaddr*addrs，int addrcnt，struct sctp_sndrcvinfo*sinfo，int标志）；"
    },
    {
      "indent": 3,
      "text": "and the arguments are",
      "zh-CHS": "争论是"
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "msg: The message to be sent.",
      "zh-CHS": "msg：要发送的消息。"
    },
    {
      "indent": 3,
      "text": "len: The length of the message.",
      "zh-CHS": "len:消息的长度。"
    },
    {
      "indent": 3,
      "text": "addrs: An array of addresses.",
      "zh-CHS": "地址：地址数组。"
    },
    {
      "indent": 3,
      "text": "addrcnt: The number of addresses in the array.",
      "zh-CHS": "addrcnt：数组中的地址数。"
    },
    {
      "indent": 3,
      "text": "sinfo: A pointer to an sctp_sndrcvinfo structure used as described in Section 5.3.2 for a sendmsg() call.",
      "zh-CHS": "sinfo：指向sctp_sndrcvinfo结构的指针，如第5.3.2节所述，用于sendmsg（）调用。"
    },
    {
      "indent": 3,
      "text": "flags: The same flags as used by the sendmsg() call flags (e.g., MSG_DONTROUTE).",
      "zh-CHS": "标志：与sendmsg（）调用标志使用的标志相同（例如，MSG_DONTROUTE）。"
    },
    {
      "indent": 3,
      "text": "The call returns the number of bytes sent, or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "调用返回发送的字节数，如果发生错误，则返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 3,
      "text": "Note that in the case of implicit connection setup, on return from this call, the sinfo_assoc_id field of the sinfo structure will contain the new association identifier.",
      "zh-CHS": "注意，在隐式连接设置的情况下，从该调用返回时，sinfo结构的sinfo_assoc_id字段将包含新的关联标识符。"
    },
    {
      "indent": 3,
      "text": "This function call may also be used to terminate an association using an association identifier by setting the sinfo.sinfo_flags to SCTP_EOF and the sinfo.sinfo_assoc_id to the association that needs to be terminated. In such a case, len would be zero.",
      "zh-CHS": "此函数调用还可用于通过将sinfo.sinfo_标志设置为SCTP_EOF并将sinfo.sinfo_assoc_id设置为需要终止的关联来终止使用关联标识符的关联。在这种情况下，len将为零。"
    },
    {
      "indent": 3,
      "text": "Sending a message using sctp_sendx() is atomic unless explicit EOR marking is enabled on the socket specified by sd.",
      "zh-CHS": "除非在sd指定的套接字上启用了显式EOR标记，否则使用sctp_sendx（）发送消息是原子的。"
    },
    {
      "indent": 3,
      "text": "Using sctp_sendx() on a non-connected one-to-one style socket for implicit connection setup may or may not work, depending on the SCTP implementation.",
      "zh-CHS": "在未连接的一对一样式套接字上使用sctp_sendx（）进行隐式连接设置可能有效，也可能无效，具体取决于sctp实现。"
    },
    {
      "indent": 0,
      "text": "9.12. sctp_sendv()",
      "section_title": true,
      "zh-CHS": "9.12. sctp_sendv（）"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t sctp_sendv(int sd, const struct iovec *iov, int iovcnt, struct sockaddr *addrs, int addrcnt, void *info, socklen_t infolen, unsigned int infotype, int flags);",
      "zh-CHS": "ssize_t sctp_sendv（int sd，const struct iovec*iov，int iovcnt，struct sockaddr*addrs，int addrcnt，void*info，socklen\\u t infolen，unsigned int infotype，int flags）；"
    },
    {
      "indent": 3,
      "text": "The function sctp_sendv() provides an extensible way for an application to communicate different send attributes to the SCTP stack when sending a message. An implementation may provide sctp_sendv() as a library function or a system call.",
      "zh-CHS": "函数sctp_sendv（）为应用程序提供了一种可扩展的方式，以便在发送消息时将不同的发送属性传递给sctp堆栈。实现可以将sctp_sendv（）作为库函数或系统调用提供。"
    },
    {
      "indent": 3,
      "text": "This document defines three types of attributes that can be used to describe a message to be sent. They are struct sctp_sndinfo (Section 5.3.4), struct sctp_prinfo (Section 5.3.7), and struct sctp_authinfo (Section 5.3.8). The following structure, sctp_sendv_spa, is defined to be used when more than one of the above attributes are needed to describe a message to be sent.",
      "zh-CHS": "本文档定义了三种类型的属性，可用于描述要发送的消息。它们是struct sctp_sndinfo（第5.3.4节）、struct sctp_prinfo（第5.3.7节）和struct sctp_authinfo（第5.3.8节）。以下结构sctp_sendv_spa被定义为在需要使用上述多个属性来描述要发送的消息时使用。"
    },
    {
      "indent": 3,
      "text": "struct sctp_sendv_spa {\n  uint32_t sendv_flags;\n  struct sctp_sndinfo sendv_sndinfo;\n  struct sctp_prinfo sendv_prinfo;\n  struct sctp_authinfo sendv_authinfo;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "The sendv_flags field holds a bitwise OR of SCTP_SEND_SNDINFO_VALID, SCTP_SEND_PRINFO_VALID, and SCTP_SEND_AUTHINFO_VALID indicating if the sendv_sndinfo/sendv_prinfo/sendv_authinfo fields contain valid information.",
      "zh-CHS": "sendv_flags字段保存SCTP_SEND_SNDINFO_VALID、SCTP_SEND_PRINFO_VALID和SCTP_SEND_AUTHINFO_VALID的按位OR，指示sendv_SNDINFO/sendv_PRINFO/sendv_AUTHINFO字段是否包含有效信息。"
    },
    {
      "indent": 3,
      "text": "In future, when new send attributes are needed, new structures can be defined. But those new structures do not need to be based on any of the above defined structures.",
      "zh-CHS": "将来，当需要新的发送属性时，可以定义新的结构。但这些新结构不需要基于上述任何定义的结构。"
    },
    {
      "indent": 3,
      "text": "The function takes the following arguments:",
      "zh-CHS": "该函数采用以下参数："
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "iov: The gather buffer. The data in the buffer is treated as a single user message.",
      "zh-CHS": "iov：收集缓冲区。缓冲区中的数据被视为单个用户消息。"
    },
    {
      "indent": 3,
      "text": "iovcnt: The number of elements in iov.",
      "zh-CHS": "iovcnt：iov中的元素数。"
    },
    {
      "indent": 3,
      "text": "addrs: An array of addresses to be used to set up an association or a single address to be used to send the message. NULL is passed in if the caller neither wants to set up an association nor wants to send the message to a specific address.",
      "zh-CHS": "地址：用于建立关联的地址数组或用于发送消息的单个地址。如果调用方既不想建立关联也不想将消息发送到特定地址，则传入NULL。"
    },
    {
      "indent": 3,
      "text": "addrcnt: The number of addresses in the addrs array.",
      "zh-CHS": "addrcnt：addrs数组中的地址数。"
    },
    {
      "indent": 3,
      "text": "info: A pointer to the buffer containing the attribute associated with the message to be sent. The type is indicated by the info_type parameter.",
      "zh-CHS": "信息：指向缓冲区的指针，其中包含与要发送的消息关联的属性。类型由info_type参数指示。"
    },
    {
      "indent": 3,
      "text": "infolen: The length of info, in bytes.",
      "zh-CHS": "infolen：信息的长度，以字节为单位。"
    },
    {
      "indent": 3,
      "text": "infotype: Identifies the type of the information provided in info. The current defined values are as follows:",
      "zh-CHS": "infotype：标识信息中提供的信息的类型。当前定义的值如下所示："
    },
    {
      "indent": 6,
      "text": "SCTP_SENDV_NOINFO: No information is provided. The parameter info is a NULL pointer, and infolen is 0.",
      "zh-CHS": "SCTP_SENDV_NOINFO：没有提供任何信息。参数info是空指针，infolen是0。"
    },
    {
      "indent": 6,
      "text": "SCTP_SENDV_SNDINFO: The parameter info is pointing to a struct sctp_sndinfo.",
      "zh-CHS": "SCTP_SENDV_SNDINFO：参数信息指向结构SCTP_SNDINFO。"
    },
    {
      "indent": 6,
      "text": "SCTP_SENDV_PRINFO: The parameter info is pointing to a struct sctp_prinfo.",
      "zh-CHS": "SCTP_SENDV_PRINFO：参数信息指向结构SCTP_PRINFO。"
    },
    {
      "indent": 6,
      "text": "SCTP_SENDV_AUTHINFO: The parameter info is pointing to a struct sctp_authinfo.",
      "zh-CHS": "SCTP_SENDV_AUTHINFO：参数info指向结构SCTP_AUTHINFO。"
    },
    {
      "indent": 6,
      "text": "SCTP_SENDV_SPA: The parameter info is pointing to a struct sctp_sendv_spa.",
      "zh-CHS": "SCTP_SENDV_SPA：参数信息指向结构SCTP_SENDV_SPA。"
    },
    {
      "indent": 3,
      "text": "flags: The same flags as used by the sendmsg() call flags (e.g., MSG_DONTROUTE).",
      "zh-CHS": "标志：与sendmsg（）调用标志使用的标志相同（例如，MSG_DONTROUTE）。"
    },
    {
      "indent": 3,
      "text": "The call returns the number of bytes sent, or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "调用返回发送的字节数，如果发生错误，则返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 3,
      "text": "A note on the one-to-many style socket: The struct sctp_sndinfo attribute must always be used in order to specify the association on which the message is to be sent. The only case where it is not needed is when this call is used to set up a new association.",
      "zh-CHS": "关于一对多样式套接字的一个注意事项：必须始终使用struct sctp_sndinfo属性来指定要在其上发送消息的关联。唯一不需要它的情况是使用此调用建立新关联。"
    },
    {
      "indent": 3,
      "text": "The caller provides a list of addresses in the addrs parameter to set up an association. This function will behave like calling sctp_connectx() (see Section 9.9), first using the list of addresses and then calling sendmsg() with the given message and attributes. For a one-to-many style socket, if the struct sctp_sndinfo attribute is provided, the snd_assoc_id field must be 0. When this function returns, the snd_assoc_id field will contain the association identifier of the newly established association. Note that the struct sctp_sndinfo attribute is not required to set up an association for a one-to-many style socket. If this attribute is not provided, the caller can enable the SCTP_ASSOC_CHANGE notification and use the SCTP_COMM_UP message to find out the association identifier.",
      "zh-CHS": "调用者在addrs参数中提供地址列表以建立关联。此函数的行为类似于调用sctp_connectx（）（请参见第9.9节），首先使用地址列表，然后使用给定的消息和属性调用sendmsg（）。对于一对多样式套接字，如果提供了struct sctp_sndinfo属性，则snd_assoc_id字段必须为0。当此函数返回时，snd_assoc_id字段将包含新建立的关联的关联标识符。请注意，为一对多样式套接字设置关联不需要struct sctp_sndinfo属性。如果未提供此属性，则调用者可以启用SCTP_ASSOC_CHANGE通知，并使用SCTP_COMM_UP消息查找关联标识符。"
    },
    {
      "indent": 3,
      "text": "If the caller wants to send the message to a specific peer address (hence overriding the primary address), it can provide the specific address in the addrs parameter and provide a struct sctp_sndinfo attribute with the field snd_flags set to SCTP_ADDR_OVER.",
      "zh-CHS": "如果调用方希望将消息发送到特定的对等地址（从而覆盖主地址），则可以在addrs参数中提供特定地址，并提供struct sctp_sndinfo属性，其中字段snd_flags设置为sctp_ADDR_OVER。"
    },
    {
      "indent": 3,
      "text": "This function call may also be used to terminate an association. The caller provides an sctp_sndinfo attribute with the snd_flags set to SCTP_EOF. In this case, len would be zero.",
      "zh-CHS": "此函数调用也可用于终止关联。调用者提供一个sctp_sndinfo属性，其中snd_标志设置为sctp_EOF。在这种情况下，len将为零。"
    },
    {
      "indent": 3,
      "text": "Sending a message using sctp_sendv() is atomic unless explicit EOR marking is enabled on the socket specified by sd.",
      "zh-CHS": "除非在sd指定的套接字上启用了显式EOR标记，否则使用sctp_sendv（）发送消息是原子的。"
    },
    {
      "indent": 0,
      "text": "9.13. sctp_recvv()",
      "section_title": true,
      "zh-CHS": "9.13. sctp_recvv（）"
    },
    {
      "indent": 3,
      "text": "The function prototype is",
      "zh-CHS": "功能原型是"
    },
    {
      "indent": 3,
      "text": "ssize_t sctp_recvv(int sd, const struct iovec *iov, int iovlen, struct sockaddr *from, socklen_t *fromlen, void *info, socklen_t *infolen, unsigned int *infotype, int *flags);",
      "zh-CHS": "ssize_t sctp_recvv（int sd，const struct iovec*iov，int iovlen，struct sockaddr*from，socklen_t*from，void*info，socklen_t*infolen，unsigned int*infotype，int*flags）；"
    },
    {
      "indent": 3,
      "text": "The function sctp_recvv() provides an extensible way for the SCTP stack to pass up different SCTP attributes associated with a received message to an application. An implementation may provide sctp_recvv() as a library function or as a system call.",
      "zh-CHS": "函数sctp_recvv（）为sctp堆栈提供了一种可扩展的方式，用于将与接收到的消息相关联的不同sctp属性传递给应用程序。实现可以将sctp_recvv（）作为库函数或系统调用提供。"
    },
    {
      "indent": 3,
      "text": "This document defines two types of attributes that can be returned by this call: the attribute of the received message and the attribute of the next message in the receive buffer. The caller enables the SCTP_RECVRCVINFO and SCTP_RECVNXTINFO socket options, respectively, to receive these attributes. Attributes of the received message are returned in struct sctp_rcvinfo (Section 5.3.5), and attributes of the next message are returned in struct sctp_nxtinfo (Section 5.3.6). If both options are enabled, both attributes are returned using the following structure.",
      "zh-CHS": "本文档定义了此调用可以返回的两种类型的属性：接收消息的属性和接收缓冲区中下一条消息的属性。调用者分别启用SCTP_RECVRCVINFO和SCTP_RECVNXTINFO套接字选项来接收这些属性。接收到的消息的属性在struct sctp_rcvinfo（第5.3.5节）中返回，下一条消息的属性在struct sctp_nxtinfo（第5.3.6节）中返回。如果两个选项都已启用，则使用以下结构返回两个属性。"
    },
    {
      "indent": 3,
      "text": "struct sctp_recvv_rn {\n  struct sctp_rcvinfo recvv_rcvinfo;\n  struct sctp_nxtinfo recvv_nxtinfo;\n};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "In future, new structures can be defined to hold new types of attributes. The new structures do not need to be based on struct sctp_recvv_rn or struct sctp_rcvinfo.",
      "zh-CHS": "将来，可以定义新的结构来保存新类型的属性。新结构不需要基于struct sctp_recvv_rn或struct sctp_rcvinfo。"
    },
    {
      "indent": 3,
      "text": "This function takes the following arguments:",
      "zh-CHS": "此函数采用以下参数："
    },
    {
      "indent": 3,
      "text": "sd: The socket descriptor.",
      "zh-CHS": "sd：套接字描述符。"
    },
    {
      "indent": 3,
      "text": "iov: The scatter buffer. Only one user message is returned in this buffer.",
      "zh-CHS": "iov：分散缓冲区。此缓冲区中只返回一条用户消息。"
    },
    {
      "indent": 3,
      "text": "iovlen: The number of elements in iov.",
      "zh-CHS": "iovlen：iov中的元素数。"
    },
    {
      "indent": 3,
      "text": "from: A pointer to an address to be filled with the sender of the received message's address.",
      "zh-CHS": "发件人：指向地址的指针，该地址将由接收到的邮件地址的发件人填写。"
    },
    {
      "indent": 3,
      "text": "fromlen: An in/out parameter describing the from length.",
      "zh-CHS": "fromlen：描述起始长度的输入/输出参数。"
    },
    {
      "indent": 3,
      "text": "info: A pointer to the buffer to hold the attributes of the received message. The structure type of info is determined by the info_type parameter.",
      "zh-CHS": "信息：指向缓冲区的指针，用于保存所接收消息的属性。info的结构类型由info_type参数确定。"
    },
    {
      "indent": 3,
      "text": "infolen: An in/out parameter describing the size of the info buffer.",
      "zh-CHS": "infolen：描述信息缓冲区大小的输入/输出参数。"
    },
    {
      "indent": 3,
      "text": "infotype: On return, *info_type is set to the type of the info buffer. The current defined values are as follows:",
      "zh-CHS": "infotype：返回时，*info\\u type设置为信息缓冲区的类型。当前定义的值如下所示："
    },
    {
      "indent": 6,
      "text": "SCTP_RECVV_NOINFO: If both SCTP_RECVRCVINFO and SCTP_RECVNXTINFO options are not enabled, no attribute will be returned. If only the SCTP_RECVNXTINFO option is enabled but there is no next message in the buffer, no attribute will be returned. In these cases, *info_type will be set to SCTP_RECVV_NOINFO.",
      "zh-CHS": "SCTP_RECVV_NOINFO：如果未启用SCTP_RECVRCVINFO和SCTP_RECVNXTINFO选项，则不会返回任何属性。如果仅启用了SCTP_RECVNXTINFO选项，但缓冲区中没有下一条消息，则不会返回任何属性。在这些情况下，*info\\U type将设置为SCTP\\U RECVV\\U NOINFO。"
    },
    {
      "indent": 6,
      "text": "SCTP_RECVV_RCVINFO: The type of info is struct sctp_rcvinfo, and the attribute relates to the received message.",
      "zh-CHS": "SCTP_RECVV_RCVINFO：信息的类型为struct SCTP_RCVINFO，属性与接收到的消息相关。"
    },
    {
      "indent": 6,
      "text": "SCTP_RECVV_NXTINFO: The type of info is struct sctp_nxtinfo, and the attribute relates to the next message in the receive buffer. This is the case when only the SCTP_RECVNXTINFO option is enabled and there is a next message in the buffer.",
      "zh-CHS": "SCTP_RECVV_NXTINFO:info的类型是struct SCTP_NXTINFO，该属性与接收缓冲区中的下一条消息相关。当仅启用SCTP_RECVNXTINFO选项且缓冲区中存在下一条消息时，会出现这种情况。"
    },
    {
      "indent": 6,
      "text": "SCTP_RECVV_RN: The type of info is struct sctp_recvv_rn. The recvv_rcvinfo field is the attribute of the received message, and the recvv_nxtinfo field is the attribute of the next message in the buffer. This is the case when both SCTP_RECVRCVINFO and SCTP_RECVNXTINFO options are enabled and there is a next message in the receive buffer.",
      "zh-CHS": "SCTP_RECVV_RN：信息类型为struct SCTP_RECVV_RN。recvv_rcvinfo字段是接收消息的属性，recvv_nxtinfo字段是缓冲区中下一条消息的属性。当SCTP_RECVRCVINFO和SCTP_RECVNXTINFO选项均已启用且接收缓冲区中存在下一条消息时，即为这种情况。"
    },
    {
      "indent": 3,
      "text": "flags: A pointer to an integer to be filled with any message flags (e.g., MSG_NOTIFICATION). Note that this field is an in/out parameter. Options for the receive may also be passed into the value (e.g., MSG_PEEK). On return from the call, the flags value will be different than what was sent in to the call. If implemented via a recvmsg() call, the flags should only contain the value of the flags from the recvmsg() call when calling sctp_recvv(), and on return it has the value from msg_flags.",
      "zh-CHS": "标志：指向要填充任何消息标志（例如MSG_通知）的整数的指针。请注意，此字段是一个输入/输出参数。接收选项也可以传递到值中（例如，MSG_PEEK）。从调用返回时，标志值将不同于发送到调用中的值。如果通过recvmsg（）调用实现，则当调用sctp_recvv（）时，标志应仅包含recvmsg（）调用中的标志值，并且在返回时，它具有来自msg_标志的值。"
    },
    {
      "indent": 3,
      "text": "The call returns the number of bytes received, or -1 if an error occurred. The variable errno is then set appropriately.",
      "zh-CHS": "调用返回接收的字节数，如果发生错误，则返回-1。然后适当设置变量errno。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "zh-CHS": "10. 安全考虑"
    },
    {
      "indent": 3,
      "text": "Many TCP and UDP implementations reserve port numbers below 1024 for privileged users. If the target platform supports privileged users, the SCTP implementation should restrict the ability to call bind() or sctp_bindx() on these port numbers to privileged users.",
      "zh-CHS": "许多TCP和UDP实现为特权用户保留1024以下的端口号。如果目标平台支持特权用户，则SCTP实现应限制对特权用户调用这些端口号上的bind（）或SCTP_bindx（）的能力。"
    },
    {
      "indent": 3,
      "text": "Similarly, unprivileged users should not be able to set protocol parameters that could result in the congestion control algorithm being more aggressive than permitted on the public Internet. These parameters are as follows:",
      "zh-CHS": "类似地，非特权用户不应该能够设置可能导致拥塞控制算法比公共互联网上允许的更具攻击性的协议参数。这些参数如下："
    },
    {
      "indent": 3,
      "text": "o struct sctp_rtoinfo",
      "zh-CHS": "o 结构sctp\\U rtoinfo"
    },
    {
      "indent": 3,
      "text": "If an unprivileged user inherits a one-to-many style socket with open associations on a privileged port, accepting new associations might be permitted, but opening new associations should not be permitted. This could be relevant for the r* family (rsh, rlogin, rwho, ...) of protocols.",
      "zh-CHS": "如果非特权用户继承了一个一对多样式的套接字，并在特权端口上打开了关联，则可能允许接受新关联，但不允许打开新关联。这可能与r*系列（rsh、rlogin、rwho等）协议有关。"
    },
    {
      "indent": 3,
      "text": "Applications using the one-to-many style sockets and using the interleave level (if 0) are subject to denial-of-service attacks, as described in Section 8.1.20.",
      "zh-CHS": "如第8.1.20节所述，使用一对多类型套接字和交错级别（如果为0）的应用程序会受到拒绝服务攻击。"
    },
    {
      "indent": 3,
      "text": "Applications needing transport layer security can use Datagram Transport Layer Security/SCTP (DTLS/SCTP) as specified in [RFC6083]. This can be implemented using the sockets API described in this document.",
      "zh-CHS": "需要传输层安全的应用程序可以使用[RFC6083]中指定的数据报传输层安全/SCTP（DTLS/SCTP）。这可以使用本文档中描述的套接字API实现。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgments",
      "section_title": true,
      "zh-CHS": "11. 致谢"
    },
    {
      "indent": 3,
      "text": "Special acknowledgment is given to Ken Fujita, Jonathan Woods, Qiaobing Xie, and La Monte Yarroll, who helped extensively in the early formation of this document.",
      "zh-CHS": "特别感谢Ken Fujita、Jonathan Woods、Xiaobing Xie和La Monte Yarroll，他们在本文件的早期形成过程中提供了广泛的帮助。"
    },
    {
      "indent": 3,
      "text": "The authors also wish to thank Kavitha Baratakke, Mike Bartlett, Martin Becke, Jon Berger, Mark Butler, Thomas Dreibholz, Andreas Fink, Scott Kimble, Jonathan Leighton, Renee Revis, Irene Ruengeler, Dan Wing, and many others on the TSVWG mailing list for contributing valuable comments.",
      "zh-CHS": "作者还想感谢卡维塔·巴拉塔克、迈克·巴特利特、马丁·贝克、乔恩·伯杰、马克·巴特勒、托马斯·德雷霍尔茨、安德烈亚斯·芬克、斯科特·金布尔、乔纳森·莱顿、雷尼·雷维斯、艾琳·鲁恩格勒、丹·荣格以及TSVWG邮件列表上的许多其他人提供了宝贵的意见。"
    },
    {
      "indent": 3,
      "text": "A special thanks to Phillip Conrad, for his suggested text, quick and constructive insights, and most of all his persistent fighting to keep the interface to SCTP usable for the application programmer.",
      "zh-CHS": "特别感谢Phillip Conrad，感谢他提出的文本、快速而有建设性的见解，最重要的是，感谢他坚持不懈地努力使SCTP接口可供应用程序程序员使用。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "zh-CHS": "12. 工具书类"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "zh-CHS": "12.1. 规范性引用文件"
    },
    {
      "indent": 3,
      "text": "[IEEE-1003.1-2008] Institute of Electrical and Electronics Engineers, \"Information Technology - Portable Operating System Interface (POSIX)\", IEEE Standard 1003.1, 2008.",
      "zh-CHS": "[IEEE-1003.1-2008]电气和电子工程师协会，“信息技术-便携式操作系统接口（POSIX）”，IEEE标准1003.12008。"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, February 2003.",
      "zh-CHS": "[RFC3493]Gilligan，R.，Thomson，S.，Bound，J.，McCann，J.，和W.Stevens，“IPv6的基本套接字接口扩展”，RFC 3493，2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3542] Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, \"Advanced Sockets Application Program Interface (API) for IPv6\", RFC 3542, May 2003.",
      "zh-CHS": "[RFC3542]Stevens，W.，Thomas，M.，Nordmark，E.，和T.Jinmei，“IPv6的高级套接字应用程序接口（API）”，RFC 3542，2003年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3758] Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P. Conrad, \"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension\", RFC 3758, May 2004.",
      "zh-CHS": "[RFC3758]Stewart，R.，Ramalho，M.，Xie，Q.，Tuexen，M.，和P.Conrad，“流控制传输协议（SCTP）部分可靠性扩展”，RFC 3758，2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4895] Tuexen, M., Stewart, R., Lei, P., and E. Rescorla, \"Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)\", RFC 4895, August 2007.",
      "zh-CHS": "[RFC4895]Tuexen，M.，Stewart，R.，Lei，P.，和E.Rescorla，“流控制传输协议（SCTP）的认证块”，RFC 48952007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., Ed., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "zh-CHS": "[RFC4960]Stewart，R.，Ed.“流控制传输协议”，RFC 49602007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5061] Stewart, R., Xie, Q., Tuexen, M., Maruyama, S., and M. Kozuka, \"Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration\", RFC 5061, September 2007.",
      "zh-CHS": "[RFC5061]Stewart，R.，Xie，Q.，Tuexen，M.，Maruyama，S.，和M.Kozuka，“流控制传输协议（SCTP）动态地址重新配置”，RFC 50612007年9月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "zh-CHS": "12.2. 资料性引用"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "zh-CHS": "[RFC0768]Postel，J.，“用户数据报协议”，STD 6，RFC 768，1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "zh-CHS": "[RFC0793]Postel，J.，“传输控制协议”，标准7，RFC 793，1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1644] Braden, R., \"T/TCP -- TCP Extensions for Transactions Functional Specification\", RFC 1644, July 1994.",
      "zh-CHS": "[RFC1644]Braden，R.，“T/TCP——事务功能规范的TCP扩展”，RFC16441994年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC6083] Tuexen, M., Seggelmann, R., and E. Rescorla, \"Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)\", RFC 6083, January 2011.",
      "zh-CHS": "[RFC6083]Tuexen，M.，Seggelmann，R.，和E.Rescorla，“流控制传输协议（SCTP）的数据报传输层安全性（DTLS）”，RFC 6083，2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6247] Eggert, L., \"Moving the Undeployed TCP Extensions RFC 1072, RFC 1106, RFC 1110, RFC 1145, RFC 1146, RFC 1379, RFC 1644, and RFC 1693 to Historic Status\", RFC 6247, May 2011.",
      "zh-CHS": "[RFC6247]Eggert，L.“将未部署的TCP扩展RFC 1072、RFC 1106、RFC 1110、RFC 1145、RFC 1146、RFC 1379、RFC 1644和RFC 1693移动到历史状态”，RFC 6247，2011年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example Using One-to-One Style Sockets",
      "section_title": true,
      "zh-CHS": "附录A.使用一对一插座的示例"
    },
    {
      "indent": 3,
      "text": "The following code is an implementation of a simple client that sends a number of messages marked for unordered delivery to an echo server making use of all outgoing streams. The example shows how to use some features of one-to-one style IPv4 SCTP sockets, including",
      "zh-CHS": "下面的代码是一个简单客户端的实现，该客户端使用所有传出流向echo服务器发送大量标记为无序传递的消息。该示例演示如何使用一对一样式的IPv4 SCTP套接字的一些功能，包括"
    },
    {
      "indent": 3,
      "text": "o Creating and connecting an SCTP socket.",
      "zh-CHS": "o 创建和连接SCTP套接字。"
    },
    {
      "indent": 3,
      "text": "o Making a request to negotiate a number of outgoing streams.",
      "zh-CHS": "o 请求协商多个传出流。"
    },
    {
      "indent": 3,
      "text": "o Determining the negotiated number of outgoing streams.",
      "zh-CHS": "o 确定传出流的协商数量。"
    },
    {
      "indent": 3,
      "text": "o Setting an adaptation layer indication.",
      "zh-CHS": "o 设置适配层指示。"
    },
    {
      "indent": 3,
      "text": "o Sending messages with a given payload protocol identifier on a particular stream using sctp_sendv().",
      "zh-CHS": "o 使用sctp_sendv（）在特定流上发送具有给定有效负载协议标识符的消息。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\n/*",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as authors of the code. All rights reserved.",
      "zh-CHS": "版权所有（c）2011 IETF信托基金和被确定为代码作者的人员。版权所有。"
    },
    {
      "indent": 6,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).",
      "zh-CHS": "根据IETF信托有关IETF文件的法律规定第4.c节规定的简化BSD许可证中包含的许可条款，允许以源代码和二进制格式重新分发和使用，无论是否修改(http://trustee.ietf.org/license-info)."
    },
    {
      "indent": 3,
      "text": "*/",
      "zh-CHS": "*/"
    },
    {
      "indent": 3,
      "text": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/sctp.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "#define PORT 9 #define ADDR \"127.0.0.1\" #define SIZE_OF_MESSAGE 1000 #define NUMBER_OF_MESSAGES 10 #define PPID 1234",
      "zh-CHS": "#定义端口9#定义地址“127.0.0.1”#定义消息1000的大小#定义消息10的数量#定义PPID 1234"
    },
    {
      "indent": 3,
      "text": "int\nmain(void) {\n  unsigned int i;\n  int sd;\n  struct sockaddr_in addr;\n  char buffer[SIZE_OF_MESSAGE];\n  struct iovec iov;\n  struct sctp_status status;\n  struct sctp_initmsg init;\n  struct sctp_sndinfo info;\n  struct sctp_setadaptation ind;\n  socklen_t opt_len;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* Create a one-to-one style SCTP socket. */\nif ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)) < 0) {\n  perror(\"socket\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* Prepare for requesting 2048 outgoing streams. */\nmemset(&init, 0, sizeof(init));\ninit.sinit_num_ostreams = 2048;\nif (setsockopt(sd, IPPROTO_SCTP, SCTP_INITMSG,\n               &init, (socklen_t)sizeof(init)) < 0) {\n  perror(\"setsockopt\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "ind.ssb_adaptation_ind  = 0x01020304;\nif (setsockopt(sd, IPPROTO_SCTP, SCTP_ADAPTATION_LAYER,\n               &ind, (socklen_t)sizeof(ind)) < 0) {\n  perror(\"setsockopt\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  /* Connect to the discard server. */\n  memset(&addr, 0, sizeof(addr));\n#ifdef HAVE_SIN_LEN\n  addr.sin_len         = sizeof(struct sockaddr_in);\n#endif\n  addr.sin_family      = AF_INET;\n  addr.sin_port        = htons(PORT);\n  addr.sin_addr.s_addr = inet_addr(ADDR);",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "if (connect(sd,\n            (const struct sockaddr *)&addr,\n            sizeof(struct sockaddr_in)) < 0) {\n  perror(\"connect\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* Get the actual number of outgoing streams. */\nmemset(&status, 0, sizeof(status));\nopt_len = (socklen_t)sizeof(status);\nif (getsockopt(sd, IPPROTO_SCTP, SCTP_STATUS,\n               &status, &opt_len) < 0) {\n  perror(\"getsockopt\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "memset(&info, 0, sizeof(info));\ninfo.snd_ppid = htonl(PPID);\ninfo.snd_flags = SCTP_UNORDERED;\nmemset(buffer, 'A', SIZE_OF_MESSAGE);\niov.iov_base = buffer;\niov.iov_len = SIZE_OF_MESSAGE;\nfor (i = 0; i <  NUMBER_OF_MESSAGES; i++) {\n  info.snd_sid = i % status.sstat_outstrms;\n  if (sctp_sendv(sd,\n                 (const struct iovec *)&iov, 1,\n                 NULL, 0,\n                 &info, sizeof(info), SCTP_SENDV_SNDINFO,\n                 0) < 0) {\n    perror(\"sctp_sendv\");\n    exit(1);\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  if (close(sd) < 0) {\n    perror(\"close\");\n    exit(1);\n  }\n  return(0);\n}\n<CODE ENDS>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Appendix B. Example Using One-to-Many Style Sockets",
      "section_title": true,
      "zh-CHS": "附录B.使用一对多样式插座的示例"
    },
    {
      "indent": 3,
      "text": "The following code is a simple implementation of a discard server over SCTP. The example shows how to use some features of one-to-many style IPv6 SCTP sockets, including",
      "zh-CHS": "下面的代码是通过SCTP丢弃服务器的简单实现。该示例显示了如何使用一对多样式IPv6 SCTP套接字的一些功能，包括"
    },
    {
      "indent": 3,
      "text": "o Opening and binding of a socket.",
      "zh-CHS": "o 插座的打开和绑定。"
    },
    {
      "indent": 3,
      "text": "o Enabling notifications.",
      "zh-CHS": "o 启用通知。"
    },
    {
      "indent": 3,
      "text": "o Handling notifications.",
      "zh-CHS": "o 处理通知。"
    },
    {
      "indent": 3,
      "text": "o Configuring the auto-close timer.",
      "zh-CHS": "o 配置自动关闭计时器。"
    },
    {
      "indent": 3,
      "text": "o Using sctp_recvv() to receive messages.",
      "zh-CHS": "o 使用sctp_recvv（）接收消息。"
    },
    {
      "indent": 3,
      "text": "Please note that this server can be used in combination with the client described in Appendix A.",
      "zh-CHS": "请注意，此服务器可与附录A中所述的客户端结合使用。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\n/*",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 6,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as authors of the code. All rights reserved.",
      "zh-CHS": "版权所有（c）2011 IETF信托基金和被确定为代码作者的人员。版权所有。"
    },
    {
      "indent": 6,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).",
      "zh-CHS": "根据IETF信托有关IETF文件的法律规定第4.c节规定的简化BSD许可证中包含的许可条款，允许以源代码和二进制格式重新分发和使用，无论是否修改(http://trustee.ietf.org/license-info)."
    },
    {
      "indent": 3,
      "text": "*/",
      "zh-CHS": "*/"
    },
    {
      "indent": 3,
      "text": "#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netinet/sctp.h>\n#include <arpa/inet.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "#define BUFFER_SIZE (1<<16)\n#define PORT 9\n#define ADDR \"0.0.0.0\"\n#define TIMEOUT 5",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "static void\nprint_notification(void *buf)\n{\n  struct sctp_assoc_change *sac;\n  struct sctp_paddr_change *spc;\n  struct sctp_adaptation_event *sad;\n  union sctp_notification *snp;\n  char addrbuf[INET6_ADDRSTRLEN];\n  const char *ap;\n  struct sockaddr_in *sin;\n  struct sockaddr_in6 *sin6;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "snp = buf;",
      "zh-CHS": "snp=buf；"
    },
    {
      "indent": 5,
      "text": "switch (snp->sn_header.sn_type) {\ncase SCTP_ASSOC_CHANGE:\n  sac = &snp->sn_assoc_change;\n  printf(\"^^^ Association change: \");\n  switch (sac->sac_state) {\n  case SCTP_COMM_UP:\n    printf(\"Communication up (streams (in/out)=(%u/%u)).\\n\",\n           sac->sac_inbound_streams, sac->sac_outbound_streams);\n    break;\n  case SCTP_COMM_LOST:\n    printf(\"Communication lost (error=%d).\\n\", sac->sac_error);\n    break;\n  case SCTP_RESTART:\n    printf(\"Communication restarted (streams (in/out)=(%u/%u).\\n\",\n           sac->sac_inbound_streams, sac->sac_outbound_streams);\n    break;\n  case SCTP_SHUTDOWN_COMP:\n    printf(\"Communication completed.\\n\");\n    break;\n  case SCTP_CANT_STR_ASSOC:\n    printf(\"Communication couldn't be started.\\n\");\n    break;\n  default:\n    printf(\"Unknown state: %d.\\n\", sac->sac_state);\n    break;\n  }\n  break;\ncase SCTP_PEER_ADDR_CHANGE:\n  spc = &snp->sn_paddr_change;\n  if (spc->spc_aaddr.ss_family == AF_INET) {\n    sin = (struct sockaddr_in *)&spc->spc_aaddr;\n    ap = inet_ntop(AF_INET, &sin->sin_addr,\n                   addrbuf, INET6_ADDRSTRLEN);\n  } else {",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "      sin6 = (struct sockaddr_in6 *)&spc->spc_aaddr;\n      ap = inet_ntop(AF_INET6, &sin6->sin6_addr,\n                     addrbuf, INET6_ADDRSTRLEN);\n    }\n    printf(\"^^^ Peer Address change: %s \", ap);\n    switch (spc->spc_state) {\n    case SCTP_ADDR_AVAILABLE:\n      printf(\"is available.\\n\");\n      break;\n    case SCTP_ADDR_UNREACHABLE:\n      printf(\"is not available (error=%d).\\n\", spc->spc_error);\n      break;\n    case SCTP_ADDR_REMOVED:\n      printf(\"was removed.\\n\");\n      break;\n    case SCTP_ADDR_ADDED:\n      printf(\"was added.\\n\");\n      break;\n    case SCTP_ADDR_MADE_PRIM:\n      printf(\"is primary.\\n\");\n      break;\n    default:\n      printf(\"unknown state (%d).\\n\", spc->spc_state);\n      break;\n    }\n    break;\n  case SCTP_SHUTDOWN_EVENT:\n    printf(\"^^^ Shutdown received.\\n\");\n    break;\n  case SCTP_ADAPTATION_INDICATION:\n    sad = &snp->sn_adaptation_event;\n    printf(\"^^^ Adaptation indication 0x%08x received.\\n\",\n           sad->sai_adaptation_ind);\n    break;\n  default:\n    printf(\"^^^ Unknown event of type: %u.\\n\",\n           snp->sn_header.sn_type);\n    break;\n  };\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "int\nmain(void) {\n  int sd, flags, timeout, on;\n  ssize_t n;\n  unsigned int i;\n  union {\n    struct sockaddr sa;\n    struct sockaddr_in sin;\n    struct sockaddr_in6 sin6;\n  } addr;\n  socklen_t fromlen, infolen;\n  struct sctp_rcvinfo info;\n  unsigned int infotype;\n  struct iovec iov;\n  char buffer[BUFFER_SIZE];\n  struct sctp_event event;\n  uint16_t event_types[] = {SCTP_ASSOC_CHANGE,\n                            SCTP_PEER_ADDR_CHANGE,\n                            SCTP_SHUTDOWN_EVENT,\n                            SCTP_ADAPTATION_INDICATION};",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* Create a one-to-many style SCTP socket. */\nif ((sd = socket(AF_INET6, SOCK_SEQPACKET, IPPROTO_SCTP)) < 0) {\n  perror(\"socket\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* Enable the events of interest. */\nmemset(&event, 0, sizeof(event));\nevent.se_assoc_id = SCTP_FUTURE_ASSOC;\nevent.se_on = 1;\nfor (i = 0; i < sizeof(event_types)/sizeof(uint16_t); i++) {\n  event.se_type = event_types[i];\n  if (setsockopt(sd, IPPROTO_SCTP, SCTP_EVENT,\n                 &event, sizeof(event)) < 0) {\n    perror(\"setsockopt\");\n    exit(1);\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* Configure auto-close timer. */\ntimeout = TIMEOUT;\nif (setsockopt(sd, IPPROTO_SCTP, SCTP_AUTOCLOSE,\n               &timeout, sizeof(timeout)) < 0) {\n  perror(\"setsockopt SCTP_AUTOCLOSE\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "/* Enable delivery of SCTP_RCVINFO. */\non = 1;\nif (setsockopt(sd, IPPROTO_SCTP, SCTP_RECVRCVINFO,\n               &on, sizeof(on)) < 0) {\n  perror(\"setsockopt SCTP_RECVRCVINFO\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  /* Bind the socket to all local addresses. */\n  memset(&addr, 0, sizeof(addr));\n#ifdef HAVE_SIN6_LEN\n  addr.sin6.sin6_len         = sizeof(addr.sin6);\n#endif\n  addr.sin6.sin6_family      = AF_INET6;\n  addr.sin6.sin6_port        = htons(PORT);\n  addr.sin6.sin6_addr        = in6addr_any;\n  if (bind(sd, &addr.sa, sizeof(addr.sin6)) < 0) {\n    perror(\"bind\");\n    exit(1);\n  }\n  /* Enable accepting associations. */\n  if (listen(sd, 1) < 0) {\n    perror(\"listen\");\n    exit(1);\n  }",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "for (;;) {\n  flags = 0;\n  memset(&addr, 0, sizeof(addr));\n  fromlen = (socklen_t)sizeof(addr);\n  memset(&info, 0, sizeof(info));\n  infolen = (socklen_t)sizeof(info);\n  infotype = 0;\n  iov.iov_base = buffer;\n  iov.iov_len = BUFFER_SIZE;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 7,
      "text": "n = sctp_recvv(sd, &iov, 1, &addr.sa, &fromlen, &info, &infolen, &infotype, &flags);",
      "zh-CHS": "n=sctp_recvv（sd、&iov、1、&addr.sa、&fromlen、&info、&infolen、&infotype、&flags）；"
    },
    {
      "indent": 7,
      "text": "if (flags & MSG_NOTIFICATION) {\n  print_notification(iov.iov_base);\n} else {\n  char addrbuf[INET6_ADDRSTRLEN];\n  const char *ap;\n  in_port_t port;",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "    if (addr.sa.sa_family == AF_INET) {\n           ap = inet_ntop(AF_INET, &addr.sin.sin_addr,\n                          addrbuf, INET6_ADDRSTRLEN);\n           port = ntohs(addr.sin.sin_port);\n    } else {\n           ap = inet_ntop(AF_INET6, &addr.sin6.sin6_addr,\n                          addrbuf, INET6_ADDRSTRLEN);\n           port = ntohs(addr.sin6.sin6_port);\n    }\n    printf(\"Message received from %s:%u: len=%d\",\n           ap, port, (int)n);\n    switch (infotype) {\n    case SCTP_RECVV_RCVINFO:\n      printf(\", sid=%u\", info.rcv_sid);\n      if (info.rcv_flags & SCTP_UNORDERED) {\n        printf(\", unordered\");\n      } else {\n        printf(\", ssn=%u\", info.rcv_ssn);\n      }\n      printf(\", tsn=%u\", info.rcv_tsn);\n      printf(\", ppid=%u.\\n\", ntohl(info.rcv_ppid));\n      break;\n    case SCTP_RECVV_NOINFO:\n    case SCTP_RECVV_NXTINFO:\n    case SCTP_RECVV_RN:\n      printf(\".\\n\");\n      break;\n    default:\n      printf(\" unknown infotype.\\n\");\n    }\n  }\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 5,
      "text": "if (close(sd) < 0) {\n  perror(\"close\");\n  exit(1);\n}",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "  return (0);\n}\n<CODE ENDS>",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "zh-CHS": "作者地址"
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Adara Networks Chapin, SC 29036 USA",
      "zh-CHS": "Randall R.Stewart Adara Networks Chapin，SC 29036美国"
    },
    {
      "indent": 3,
      "text": "EMail: randall@lakerest.net",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Michael Tuexen Muenster University of Applied Sciences Stegerwaldstr. 39 48565 Steinfurt Germany",
      "zh-CHS": "米迦勒TuxEN明斯特应用科学大学StigalddSTR。39 48565德国斯坦福德"
    },
    {
      "indent": 3,
      "text": "EMail: tuexen@fh-muenster.de",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Kacheong Poon Oracle Corporation",
      "zh-CHS": "卡昌潘甲骨文公司"
    },
    {
      "indent": 3,
      "text": "EMail: ka-cheong.poon@oracle.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Peter Lei Cisco Systems, Inc. 9501 Technology Blvd. West Office Center Rosemont, IL 60018 USA",
      "zh-CHS": "Peter Lei思科系统公司，科技大道9501号。美国伊利诺伊州罗斯蒙特西办公中心，邮编：60018"
    },
    {
      "indent": 3,
      "text": "EMail: peterlei@cisco.com",
      "raw": true,
      "zh-CHS": " "
    },
    {
      "indent": 3,
      "text": "Vladislav Yasevich HP 110 Spitrook Rd. Nashua, NH 03062 USA",
      "zh-CHS": "美国新罕布什尔州纳舒亚斯皮布鲁克路110号弗拉迪斯拉夫·亚舍维奇惠普公司，邮编：03062"
    },
    {
      "indent": 3,
      "text": "EMail: vladislav.yasevich@hp.com",
      "raw": true,
      "zh-CHS": " "
    }
  ]
}